// Скрипт читает файлы справки в КаталогСправки и создает *.cs файлы в КаталогВыгрузки
// Из каталога C:\444\ВыгрузкаДекларФорм\ файлы *.cs можно скопировать в каталог проекта.

Перем СтрРазделОбъявленияПеременных;
Перем КаталогСправки, КаталогВыгрузки, СписокНеизменныхКлассов;

Функция ОтобратьФайлы(Фильтр)
	// Фильтр = Класс Конструктор Члены Свойства Свойство Методы Метод Перечисление
	М_Фильтр = Новый Массив;
	ВыбранныеФайлы = НайтиФайлы(КаталогСправки, "*.html", Истина);
	Найдено1 = 0;
	Для А = 0 По ВыбранныеФайлы.ВГраница() Цикл
		ТекстДок = Новый ТекстовыйДокумент;
		ТекстДок.Прочитать(ВыбранныеФайлы[А].ПолноеИмя);
		Стр = ТекстДок.ПолучитьТекст();
		М = СтрНайтиМежду(Стр, "<H1 class=dtH1", "/H1>", , );
		Если М.Количество() > 0 Тогда
			СтрЗаголовка= М[0];
			Если (СтрНайти(СтрЗаголовка, Фильтр + "<") > 0) или (СтрНайти(СтрЗаголовка, Фильтр + " <") > 0) Тогда
				Найдено1 = Найдено1 + 1;
				// // // Сообщить("================================================================================================");
				// // // Сообщить("" + ВыбранныеФайлы[А].ПолноеИмя + "=" + СтрЗаголовка);
				// Сообщить("" + СтрЗаголовка);22
				М_Фильтр.Добавить(ВыбранныеФайлы[А].ПолноеИмя);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Сообщить("Найдено1 (" + Фильтр + ") = " + Найдено1);
	Возврат М_Фильтр;
КонецФункции

Функция РазобратьСтроку(Строка, Разделитель)
	// Сообщить("==" + Строка);
	Стр = СтрЗаменить(Строка, Разделитель, Символы.ПС);
	М = Новый Массив;
	Если ПустаяСтрока(Стр) Тогда
		Возврат М;
	КонецЕсли;
	Для Ч = 1 По СтрЧислоСтрок(Стр) Цикл
		М.Добавить(СтрПолучитьСтроку(Стр, Ч));
	КонецЦикла;
	Возврат М;
КонецФункции

Функция СтрНайтиМежду(СтрПараметр, Фрагмент1 = Неопределено, Фрагмент2 = Неопределено, ИсключитьФрагменты = Истина, БезНаложения = Истина)
	//Стр - исходная строка
	//Фрагмент1 - подстрока поиска от которой ведем поиск
	//Фрагмент2 - подстрока поиска до которой ведем поиск
	//ИсключитьФрагменты - не включать Фрагмент1 и Фрагмент2 в результат
	//БезНаложения - в результат не будут включены участки, содержащие другие найденные участки, удовлетворяющие переданным параметрам
	//функция возвращает массив строк
	Стр = СтрПараметр;
	М = Новый Массив;
	Если (Фрагмент1 <> Неопределено) и (Фрагмент2 = Неопределено) Тогда
		Позиция = Найти(Стр, Фрагмент1);
		Пока Позиция > 0 Цикл
			М.Добавить(?(ИсключитьФрагменты, Сред(Стр, Позиция + СтрДлина(Фрагмент1)), Сред(Стр, Позиция)));
			Стр = Сред(Стр, Позиция + 1);
			Позиция = Найти(Стр, Фрагмент1);
		КонецЦикла;
	ИначеЕсли (Фрагмент1 = Неопределено) и (Фрагмент2 <> Неопределено) Тогда
		Позиция = Найти(Стр, Фрагмент2);
		СуммаПозиций = Позиция;
		Пока Позиция > 0 Цикл
			М.Добавить(?(ИсключитьФрагменты, Сред(Стр, 1, СуммаПозиций - 1), Сред(Стр, 1, СуммаПозиций - 1 + СтрДлина(Фрагмент2))));
			Позиция = Найти(Сред(Стр, СуммаПозиций + 1), Фрагмент2);
			СуммаПозиций = СуммаПозиций + Позиция;
		КонецЦикла;
	ИначеЕсли (Фрагмент1 <> Неопределено) и (Фрагмент2 <> Неопределено) Тогда
		Позиция = Найти(Стр, Фрагмент1);
		Пока Позиция > 0 Цикл
			Стр2 = ?(ИсключитьФрагменты, Сред(Стр, Позиция + СтрДлина(Фрагмент1)), Сред(Стр, Позиция));
			Позиция2 = Найти(Стр2, Фрагмент2);
			СуммаПозиций2 = Позиция2;
			Пока Позиция2 > 0 Цикл
				Если БезНаложения Тогда
					Если Найти(Сред(Стр2, 1, СуммаПозиций2 - 1), Фрагмент2) = 0 Тогда
						М.Добавить("" + ?(ИсключитьФрагменты, Сред(Стр2, 1, СуммаПозиций2 - 1), Сред(Стр2, 1, СуммаПозиций2 - 1 + СтрДлина(Фрагмент2))));
					КонецЕсли;
				Иначе
					М.Добавить("" + ?(ИсключитьФрагменты, Сред(Стр2, 1, СуммаПозиций2 - 1), Сред(Стр2, 1, СуммаПозиций2 - 1 + СтрДлина(Фрагмент2))));
				КонецЕсли;
				Позиция2 = Найти(Сред(Стр2, СуммаПозиций2 + 1), Фрагмент2);
				СуммаПозиций2 = СуммаПозиций2 + Позиция2;
			КонецЦикла;
			Стр = Сред(Стр, Позиция + 1);
			Позиция = Найти(Стр, Фрагмент1);
		КонецЦикла;
	КонецЕсли;
	
	Возврат М;
КонецФункции//СтрНайтиМежду

Функция Директивы(КлассАнгл)
	Если КлассАнгл = "qqqqqqqqqq" Тогда
		Стр = 
		"using System;
		|using System.Collections.Generic;
		|using System.Text;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using System.Reflection;
		|using ScriptEngine.HostedScript.Library;
		|using Terminal.Gui;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "VerticalTextAlignment"
		или КлассАнгл = "CursorVisibility"
		или КлассАнгл = "TextAlignment"
		или КлассАнгл = "Keys"
		или КлассАнгл = "ConsoleKey"
		или КлассАнгл = "CommandTUI"
		или КлассАнгл = "TextDirection"
		или КлассАнгл = "BorderStyle"
		или КлассАнгл = "LayoutStyle"
		или КлассАнгл = "MenuItemCheckStyle"
		или КлассАнгл = "MouseFlags"
		или КлассАнгл = "Color"
		или КлассАнгл = "SubviewCollection"
		Тогда
		Стр = 
		"using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using System.Collections.Generic;
		|using System.Collections;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "Attribute"
		или КлассАнгл = "MenusCollection"
		или КлассАнгл = "StatusBarItems"
		Тогда
		Стр = 
		"using ScriptEngine.Machine.Contexts;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "Border"
		или КлассАнгл = "MenuBar"
		или КлассАнгл = "StatusBar"
		или КлассАнгл = "Toplevel"
		или КлассАнгл = "MenuBarItemChildren"
		Тогда
		Стр = 
		"using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "MenuItem"
		или КлассАнгл = "MenuBarItem"
		Тогда
		Стр = 
		"using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using ScriptEngine.HostedScript.Library.ValueList;
		|using System.Collections;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "Dim"
		или КлассАнгл = "EventArgs"
		или КлассАнгл = "Pos"
		или КлассАнгл = "Rect"
		Тогда
		Стр = 
		"using System;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "Button"
		Тогда
		Стр = 
		"using System;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using ScriptEngine.HostedScript.Library.ValueList;
		|using System.Collections;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "StatusItem"
		Тогда
		Стр = 
		"using System;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using ScriptEngine.HostedScript.Library.ValueList;
		|using System.Collections;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "Window"
		Тогда
		Стр = 
		"using System;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "Colors"
		или КлассАнгл = "ColorScheme"
		или КлассАнгл = "Point"
		или КлассАнгл = "Size"
		или КлассАнгл = "Thickness"
		Тогда
		Стр = 
		"using ScriptEngine.Machine.Contexts;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "MessageBox"
		Тогда
		Стр = 
		"using System;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using ScriptEngine.HostedScript.Library;
		|using Terminal.Gui;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "TextFormatter"
		Тогда
		Стр = 
		"using System;
		|using System.Collections.Generic;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using ScriptEngine.HostedScript.Library;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "Timer"
		Тогда
		Стр = 
		"using System;
		|using ScriptEngine.Machine.Contexts;
		|using Terminal.Gui;
		|";
		Возврат Стр;
	ИначеЕсли КлассАнгл = "View"
		Тогда
		Стр = 
		"using System;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using Terminal.Gui;
		|using System.Collections;
		|using ScriptEngine.HostedScript.Library.ValueList;
		|";
		Возврат Стр;
		
		

		
		
		
	Иначе
		Стр = 
		"using System;
		|using System.Collections;
		|using System.Collections.Generic;
		|using System.Text;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using System.Reflection;
		|using ScriptEngine.HostedScript.Library;
		|using Terminal.Gui;
		|";
		Возврат Стр;
		
	КонецЕсли;
	Возврат "";
КонецФункции//Директивы

Функция Шапка(КлассАнгл, КлассРус)
	Если КлассАнгл = "SubviewCollection" Тогда
		Стр = "
		|    [ContextClass(""ТфКоллекцияПодэлементов"", ""TfSubviewCollection"")]
		|    public class TfSubviewCollection : AutoContext<TfSubviewCollection>, ICollectionContext, IEnumerable<IValue>
		|    {";
	ИначеЕсли КлассАнгл = "MenusCollection" Тогда
		Стр = "
		|    [ContextClass(""ТфКоллекцияПодменю"", ""TfMenusCollection"")]
		|    public class TfMenusCollection : AutoContext<TfMenusCollection>
		|    {";
		
	
	Иначе
		Стр = "
		|    [ContextClass(""Тф" + КлассРус + """, ""Tf" + КлассАнгл + """)]
		|    public class Tf" + КлассАнгл + " : AutoContext<Tf" + КлассАнгл + ">
		|    {";
	КонецЕсли;
	Возврат Стр;
КонецФункции //Шапка

Функция РазделОбъявленияПеременных(КлассАнгл, КлассРус)
	Если КлассАнгл = "йййййййййййййййййй" Тогда
		Стр = 
		"        [DllImport(""User32.dll"")] static extern void mouse_event(uint dwFlags, int dx, int dy, int dwData, UIntPtr dwExtraInfo);
		|        private static object syncRoot = new Object();
		|
		|        public static bool systemVersionIsMicrosoft = false;
		|        public static bool goOn = true;";
		
	Иначе
		Стр = "";
	КонецЕсли;
	Возврат Стр;
КонецФункции//РазделОбъявленияПеременных

Функция Конструктор(КлассАнгл, КлассРус)
	Если КлассАнгл = "Button" Тогда
		Стр = 
		"        public TfButton()
		|        {
		|            Button Button1 = new Button();
		|            Button1.dll_obj = this;
		|            Base_obj = Button1;
		|        }
		|
		|        public TfButton(string p1, bool p2 = false)
		|        {
		|            Button Button1 = new Button(p1, p2);
		|            Button1.dll_obj = this;
		|            Base_obj = Button1;
		|        }
		|
		|        public TfButton(int p1, int p2, string p3)
		|        {
		|            Button Button1 = new Button(p1, p2, p3);
		|            Button1.dll_obj = this;
		|            Base_obj = Button1;
		|        }
		|
		|        public TfButton(int p1, int p2, string p3, bool p4)
		|        {
		|            Button Button1 = new Button(p1, p2, p3, p4);
		|            Button1.dll_obj = this;
		|            Base_obj = Button1;
		|        }
		|
		|        public TfAction LayoutComplete { get; set; }
		|        public TfAction LayoutStarted { get; set; }
		|        public TfAction DrawContentComplete { get; set; }
		|        public TfAction DrawContent { get; set; }
		|        public TfAction InitializedItem { get; set; }
		|        public TfAction CanFocusChanged { get; set; }
		|        public TfAction Added { get; set; }
		|        public TfAction Removed { get; set; }
		|        public TfAction HotKeyChanged { get; set; }
		|
		|        public Button Base_obj;
		|";
	ИначеЕсли КлассАнгл = "ColorScheme" Тогда
		Стр = 
		"        public TfColorScheme()
		|        {
		|            ColorScheme ColorScheme1 = new ColorScheme();
		|            ColorScheme1.dll_obj = this;
		|            Base_obj = ColorScheme1;
		|        }
		|
		|        public TfColorScheme(ostgui.ColorScheme p1)
		|        {
		|            ColorScheme ColorScheme1 = p1;
		|            ColorScheme1.dll_obj = this;
		|            Base_obj = ColorScheme1;
		|        }
		|
		|        public ColorScheme Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Timer" Тогда
		Стр = 
		"        private object token;
		|        private bool stop = false;
		|
		|        public TfTimer()
		|        {
		|        }
		|";
	ИначеЕсли КлассАнгл = "MessageBox" Тогда
		Стр = 
		"        public TfMessageBox()
		|        {
		|            buttons = new ArrayImpl();
		|            buttons.Add(ValueFactory.Create(""Yes""));
		|            buttons.Add(ValueFactory.Create(""No""));
		|        }
		|
		|        private int Clicked = -1;
		|        private object token = null;
		|";
	ИначеЕсли КлассАнгл = "Dim" Тогда
		Стр = 
		"        public TfDim()
		|        {
		|            Dim Dim1 = new Dim();
		|            Dim1.dll_obj = this;
		|            Base_obj = Dim1;
		|        }
		|
		|        public TfDim(Dim p1)
		|        {
		|            Dim Dim1 = p1;
		|            Dim1.dll_obj = this;
		|            Base_obj = Dim1;
		|        }
		|
		|        public Dim Base_obj;
		|";
	ИначеЕсли КлассАнгл = "MenuBarItemChildren" Тогда
		Стр = 
		"        public ostgui.MenuBarItem M_MenuBarItem;
		|
		|        public Terminal.Gui.MenuItem[] M_Object
		|        {
		|            get { return M_MenuBarItem.Children; }
		|            set { M_MenuBarItem.Children = value; }
		|        }
		|";
	ИначеЕсли КлассАнгл = "MenuItem" Тогда
		Стр = 
		"        public TfMenuItem()
		|        {
		|            MenuItem MenuItem1 = new MenuItem();
		|            MenuItem1.dll_obj = this;
		|            Base_obj = MenuItem1;
		|        }
		|
		|        public MenuItem Base_obj;
		|";
	ИначеЕсли КлассАнгл = "StatusBar" Тогда
		Стр = 
		"        private TfStatusBarItems statusBarItems;
		|
		|        public TfStatusBar()
		|        {
		|            StatusBar StatusBar1 = new StatusBar();
		|            StatusBar1.dll_obj = this;
		|            Base_obj = StatusBar1;
		|
		|            statusBarItems = new TfStatusBarItems();
		|            statusBarItems.M_StatusBar = Base_obj.M_StatusBar;
		|        }
		|
		|        public TfAction HotKeyChanged { get; set; }
		|        public TfAction LayoutComplete { get; set; }
		|        public TfAction LayoutStarted { get; set; }
		|        public TfAction DrawContentComplete { get; set; }
		|        public TfAction DrawContent { get; set; }
		|        public TfAction Added { get; set; }
		|        public TfAction InitializedItem { get; set; }
		|        public TfAction Removed { get; set; }
		|        public TfAction KeyPress { get; set; }
		|
		|        public StatusBar Base_obj;
		|";
	ИначеЕсли КлассАнгл = "StatusBarItems" Тогда
		Стр = 
		"        public Terminal.Gui.StatusBar M_StatusBar;
		|
		|        public Terminal.Gui.StatusItem[] M_Object
		|        {
		|            get { return M_StatusBar.Items; }
		|            set { M_StatusBar.Items = value; }
		|        }
		|";
	ИначеЕсли КлассАнгл = "StatusItem" Тогда
		Стр = 
		"        public Terminal.Gui.StatusBar M_StatusBar { get; set; }
		|
		|        public TfStatusItem(int p1, string p2)
		|        {
		|            StatusItem StatusItem1 = new StatusItem((Terminal.Gui.Key)p1, p2);
		|            StatusItem1.dll_obj = this;
		|            Base_obj = StatusItem1;
		|        }
		|
		|        public StatusItem Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Pos" Тогда
		Стр = 
		"        public TfPos()
		|        {
		|            Pos Pos1 = new Pos();
		|            Pos1.dll_obj = this;
		|            Base_obj = Pos1;
		|        }
		|
		|        public TfPos(Pos p1)
		|        {
		|            Pos Pos1 = p1;
		|            Pos1.dll_obj = this;
		|            Base_obj = Pos1;
		|        }
		|
		|        public Pos Base_obj;
		|";
	ИначеЕсли КлассАнгл = "MenuBar" Тогда
		Стр = 
		"        private TfMenusCollection menusCollection;
		|
		|        public TfMenuBar()
		|        {
		|            MenuBar MenuBar1 = new MenuBar();
		|            MenuBar1.dll_obj = this;
		|            Base_obj = MenuBar1;
		|
		|            menusCollection = new TfMenusCollection();
		|            menusCollection.M_MenuBar = Base_obj.M_MenuBar;
		|        }
		|
		|        public TfAction LayoutComplete { get; set; }
		|        public TfAction LayoutStarted { get; set; }
		|        public TfAction DrawContentComplete { get; set; }
		|        public TfAction DrawContent { get; set; }
		|        public TfAction ShortcutAction { get; set; }
		|        public TfAction Added { get; set; }
		|        public TfAction InitializedItem { get; set; }
		|        public TfAction Initialized { get; set; }
		|        public TfAction MenuClosing { get; set; }
		|        public TfAction KeyPress { get; set; }
		|        public TfAction Removed { get; set; }
		|        public TfAction MouseClick { get; set; }
		|        public TfAction CanFocusChanged { get; set; }
		|        public TfAction Enter { get; set; }
		|        public TfAction Leave { get; set; }
		|
		|        public MenuBar Base_obj;
		|";
	ИначеЕсли КлассАнгл = "MenuBarItem" Тогда
		Стр = 
		"        private TfMenuBarItemChildren menuBarItemChildren;
		|        public Terminal.Gui.MenuBar M_MenuBar { get; set; }
		|
		|        public TfMenuBarItem()
		|        {
		|            MenuBarItem MenuBarItem1 = new MenuBarItem();
		|            MenuBarItem1.dll_obj = this;
		|            Base_obj = MenuBarItem1;
		|
		|            menuBarItemChildren = new TfMenuBarItemChildren();
		|            menuBarItemChildren.M_MenuBarItem = Base_obj;
		|        }
		|
		|        public MenuBarItem Base_obj;
		|";
	ИначеЕсли КлассАнгл = "MenusCollection" Тогда
		Стр = 
		"        public Terminal.Gui.MenuBar M_MenuBar;
		|
		|        public Terminal.Gui.MenuBarItem[] M_Object
		|        {
		|            get { return M_MenuBar.Menus; }
		|            set { M_MenuBar.Menus = value; }
		|        }
		|";
	ИначеЕсли КлассАнгл = "Thickness" Тогда
		Стр = 
		"        public TfThickness(int p1)
		|        {
		|            Thickness Thickness1 = new Thickness(p1);
		|            Thickness1.dll_obj = this;
		|            Base_obj = Thickness1;
		|        }
		|
		|        public TfThickness(int left, int top, int right, int bottom)
		|        {
		|            Thickness Thickness1 = new Thickness(left, top, right, bottom);
		|            Thickness1.dll_obj = this;
		|            Base_obj = Thickness1;
		|        }
		|
		|        public TfThickness(ostgui.Thickness p1)
		|        {
		|            Thickness Thickness1 = p1;
		|            Thickness1.dll_obj = this;
		|            Base_obj = Thickness1;
		|        }
		|
		|        public Thickness Base_obj;
		|";
	ИначеЕсли КлассАнгл = "EventArgs" Тогда
		Стр = 
		"        public TfEventArgs()
		|        {
		|        }
		|";
	ИначеЕсли КлассАнгл = "TextFormatter" Тогда
		Стр = 
		"        public TfTextFormatter()
		|        {
		|            TextFormatter TextFormatter1 = new TextFormatter();
		|            TextFormatter1.dll_obj = this;
		|            Base_obj = TextFormatter1;
		|        }
		|
		|        public TfSize Size
		|        {
		|            get { return new TfSize(Base_obj.Size); }
		|            set { Base_obj.Size = value.Base_obj; }
		|        }
		|
		|        public TextFormatter Base_obj;
		|
		|        public TfAction HotKeyChanged { get; set; }
		|";
	ИначеЕсли КлассАнгл = "SubviewCollection" Тогда
		Стр = 
		"        public TfSubviewCollection(IList<Terminal.Gui.View> p1)
		|        {
		|            SubviewCollection SubviewCollection1 = new SubviewCollection(p1);
		|            SubviewCollection1.dll_obj = this;
		|            Base_obj = SubviewCollection1;
		|        }
		|
		|        public int Count()
		|        {
		|            return CountControl;
		|        }
		|
		|        public CollectionEnumerator GetManagedIterator()
		|        {
		|            return new CollectionEnumerator(this);
		|        }
		|
		|        IEnumerator IEnumerable.GetEnumerator()
		|        {
		|            return ((IEnumerable<IValue>)this).GetEnumerator();
		|        }
		|
		|        IEnumerator<IValue> IEnumerable<IValue>.GetEnumerator()
		|        {
		|            foreach (var item in Base_obj.M_SubviewCollection)
		|            {
		|                yield return (OneScriptTerminalGui.RevertEqualsObj(item).dll_obj as IValue);
		|            }
		|        }
		|
		|        public SubviewCollection Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Window" Тогда
		Стр = 
		"        public TfWindow()
		|        {
		|            Window Window1 = new Window();
		|            Window1.dll_obj = this;
		|            Base_obj = Window1;
		|        }
		|
		|        public TfWindow(string p1)
		|        {
		|            Window Window1 = new Window(p1);
		|            Window1.dll_obj = this;
		|            Base_obj = Window1;
		|        }
		|
		|        public TfWindow(TfRect p1, string p2)
		|        {
		|            Window Window1 = new Window(p1.Base_obj, p2);
		|            Window1.dll_obj = this;
		|            Base_obj = Window1;
		|        }
		|
		|        public TfWindow(string p1, int p2, TfBorder p3)
		|        {
		|            Window Window1 = new Window(p1, p2, p3.Base_obj);
		|            Window1.dll_obj = this;
		|            Base_obj = Window1;
		|        }
		|
		|        public TfWindow(TfRect p1, string p2, int p3, TfBorder p4)
		|        {
		|            Window Window1 = new Window(p1.Base_obj, p2, p3, p4.Base_obj);
		|            Window1.dll_obj = this;
		|            Base_obj = Window1;
		|        }
		|
		|        public TfAction Activate { get; set; }
		|        public TfAction Deactivate { get; set; }
		|        public TfAction AllChildClosed { get; set; }
		|        public TfAction InitializedItem { get; set; }
		|        public TfAction Added { get; set; }
		|        public TfAction Removed { get; set; }
		|        public TfAction LayoutComplete { get; set; }
		|        public TfAction LayoutStarted { get; set; }
		|        public TfAction DrawContentComplete { get; set; }
		|        public TfAction DrawContent { get; set; }
		|        public TfAction TitleChanging { get; set; }
		|        public TfAction Loaded { get; set; }
		|        public TfAction Resized { get; set; }
		|        public TfAction Closing { get; set; }
		|
		|        public Window Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Point" Тогда
		Стр = 
		"        public TfPoint()
		|        {
		|            Point Point1 = new Point();
		|            Point1.dll_obj = this;
		|            Base_obj = Point1;
		|        }
		|
		|        public TfPoint(TfSize p1)
		|        {
		|            Point Point1 = new Point(p1.Base_obj.M_Size);
		|            Point1.dll_obj = this;
		|            Base_obj = Point1;
		|        }
		|
		|        public TfPoint(Point p1)
		|        {
		|            Point Point1 = p1;
		|            Point1.dll_obj = this;
		|            Base_obj = Point1;
		|        }
		|
		|        public TfPoint(int p1, int p2)
		|        {
		|            Point Point1 = new Point(p1, p2);
		|            Point1.dll_obj = this;
		|            Base_obj = Point1;
		|        }
		|
		|        public Point Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Attribute" Тогда
		Стр = 
		"        public TfAttribute()
		|        {
		|            Attribute Attribute1 = new Attribute();
		|            Attribute1.dll_obj = this;
		|            Base_obj = Attribute1;
		|        }
		|
		|        public TfAttribute(int p1)
		|        {
		|            Attribute Attribute1 = new Attribute(p1);
		|            Attribute1.dll_obj = this;
		|            Base_obj = Attribute1;
		|        }
		|
		|        public TfAttribute(int p1, int p2)
		|        {
		|            Attribute Attribute1 = new Attribute(p1, p2);
		|            Attribute1.dll_obj = this;
		|            Base_obj = Attribute1;
		|        }
		|
		|        public TfAttribute(int p1, int p2, int p3)
		|        {
		|            Attribute Attribute1 = new Attribute(p1, p2, p3);
		|            Attribute1.dll_obj = this;
		|            Base_obj = Attribute1;
		|        }
		|
		|        public TfAttribute(ostgui.Attribute p1)
		|        {
		|            Attribute Attribute1 = p1;
		|            Attribute1.dll_obj = this;
		|            Base_obj = Attribute1;
		|        }
		|
		|        public Attribute Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Rect" Тогда
		Стр = 
		"        public TfRect()
		|        {
		|            Rect Rect1 = new Rect();
		|            Rect1.dll_obj = this;
		|            Base_obj = Rect1;
		|        }
		|
		|        public TfRect(TfPoint p1, TfSize p2)
		|        {
		|            Rect Rect1 = new Rect(p1.Base_obj.M_Point, p2.Base_obj.M_Size);
		|            Rect1.dll_obj = this;
		|            Base_obj = Rect1;
		|        }
		|
		|        public TfRect(Rect p1)
		|        {
		|            Rect Rect1 = p1;
		|            Rect1.dll_obj = this;
		|            Base_obj = Rect1;
		|        }
		|
		|        public TfRect(int x, int y, int width, int height)
		|        {
		|            Rect Rect1 = new Rect(x, y, width, height);
		|            Rect1.dll_obj = this;
		|            Base_obj = Rect1;
		|        }
		|
		|        public Rect Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Size" Тогда
		Стр = 
		"        public TfSize()
		|        {
		|            Size Size1 = new Size();
		|            Size1.dll_obj = this;
		|            Base_obj = Size1;
		|        }
		|
		|        public TfSize(Size p1)
		|        {
		|            Size Size1 = p1;
		|            Size1.dll_obj = this;
		|            Base_obj = Size1;
		|        }
		|
		|        public TfSize(int p1, int p2)
		|        {
		|            Size Size1 = new Size(p1, p2);
		|            Size1.dll_obj = this;
		|            Base_obj = Size1;
		|        }
		|
		|        public Size Base_obj;
		|";
	ИначеЕсли КлассАнгл = "View" Тогда
		Стр = 
		"        public TfView()
		|        {
		|            View View1 = new View();
		|            View1.dll_obj = this;
		|            Base_obj = View1;
		|        }
		|
		|        public TfView(TfRect p1)
		|        {
		|            View View1 = new View(p1.Base_obj.M_Rect);
		|            View1.dll_obj = this;
		|            Base_obj = View1;
		|        }
		|
		|        public TfView(int p1, int p2, string p3)
		|        {
		|            View View1 = new View(p1, p2, p3);
		|            View1.dll_obj = this;
		|            Base_obj = View1;
		|        }
		|
		|        public TfView(TfRect p1, string p2, TfBorder p3)
		|        {
		|            View View1 = new View(p1.Base_obj.M_Rect, p2, p3.Base_obj.M_Border);
		|            View1.dll_obj = this;
		|            Base_obj = View1;
		|        }
		|
		|        public TfView(View p1)
		|        {
		|            View View1 = p1;
		|            View1.dll_obj = this;
		|            Base_obj = View1;
		|        }
		|
		|        public TfView(string p1, int p2, TfBorder p3)
		|        {
		|            View View1 = new View(p1, p2, p3.Base_obj.M_Border);
		|            View1.dll_obj = this;
		|            Base_obj = View1;
		|        }
		|
		|        public void CorrectionZet()
		|        {
		|            Base_obj.CorrectionZet();
		|        }
		|
		|        public TfAction LayoutComplete { get; set; }
		|        public TfAction LayoutStarted { get; set; }
		|        public TfAction DrawContentComplete { get; set; }
		|        public TfAction DrawContent { get; set; }
		|        public TfAction Added { get; set; }
		|        public TfAction Removed { get; set; }
		|        public TfAction HotKeyChanged { get; set; }
		|
		|        public View Base_obj;
		|";
	ИначеЕсли КлассАнгл = "Toplevel" Тогда
		Стр = 
		"        public TfToplevel()
		|        {
		|            Toplevel Toplevel1 = new Toplevel();
		|            Toplevel1.dll_obj = this;
		|            Base_obj = Toplevel1;
		|        }
		|
		|        public TfToplevel(int p1, int p2, int p3, int p4)
		|        {
		|            TfRect Rect1 = new TfRect(p1, p2, p3, p4);
		|            Toplevel Toplevel1 = new Toplevel(Rect1.Base_obj.M_Rect);
		|            Toplevel1.dll_obj = this;
		|            Base_obj = Toplevel1;
		|        }
		|
		|        public TfToplevel(TfRect p1)
		|        {
		|            Toplevel Toplevel1 = new Toplevel(p1.Base_obj.M_Rect);
		|            Toplevel1.dll_obj = this;
		|            Base_obj = Toplevel1;
		|        }
		|
		|        public TfToplevel(ostgui.Toplevel p1)
		|        {
		|            Toplevel Toplevel1 = p1;
		|            Toplevel1.dll_obj = this;
		|            Base_obj = Toplevel1;
		|        }
		|
		|        public TfToplevel(Terminal.Gui.Toplevel p1)
		|        {
		|            Toplevel Toplevel1 = new Toplevel(p1);
		|            Toplevel1.dll_obj = this;
		|            Base_obj = Toplevel1;
		|        }
		|
		|        public void CorrectionZet()
		|        {
		|            Base_obj.CorrectionZet();
		|        }
		|
		|        public TfAction Unloaded { get; set; }
		|        public TfAction Ready { get; set; }
		|        public TfAction ChildUnloaded { get; set; }
		|        public TfAction ChildLoaded { get; set; }
		|        public TfAction ChildClosed { get; set; }
		|        public TfAction QuitKeyChanged { get; set; }
		|        public TfAction Closed { get; set; }
		|        public TfAction CanFocusChanged { get; set; }
		|        public TfAction InitializedItem { get; set; }
		|        public TfAction Activate { get; set; }
		|        public TfAction Deactivate { get; set; }
		|        public TfAction AllChildClosed { get; set; }
		|        public TfAction Added { get; set; }
		|        public TfAction Removed { get; set; }
		|        public TfAction LayoutComplete { get; set; }
		|        public TfAction LayoutStarted { get; set; }
		|        public TfAction DrawContentComplete { get; set; }
		|        public TfAction DrawContent { get; set; }
		|        public TfAction Leave { get; set; }
		|        public TfAction Enter { get; set; }
		|        public TfAction Loaded { get; set; }
		|        public TfAction Closing { get; set; }
		|        public TfAction Resized { get; set; }
		|
		|        public Toplevel Base_obj;
		|";
		
		
		
	Иначе
		Стр = 
		"        public Tf" + КлассАнгл + "()
		|        {
		|            " + КлассАнгл + " " + КлассАнгл + "1 = new " + КлассАнгл + "();
		|            " + КлассАнгл + "1.dll_obj = this;
		|            Base_obj = " + КлассАнгл + "1;
		|        }
		|
		|        public " + КлассАнгл + " Base_obj;
		|";
	КонецЕсли;
	Возврат Стр;
КонецФункции//Конструктор

Функция Свойства(ФайлСвойств, КлассАнгл, КлассРус)
	ТекстДокСвойств = Новый ТекстовыйДокумент;
	КаталогНаДиске = Новый Файл(ФайлСвойств);
    Если Не (КаталогНаДиске.Существует()) Тогда
		Возврат "";
	КонецЕсли;
	ТекстДокСвойств.Прочитать(ФайлСвойств);
	СтрТекстДокСвойств = ТекстДокСвойств.ПолучитьТекст();
	М505 = СтрНайтиМежду(СтрТекстДокСвойств, "<TBODY>", "</TABLE>", Ложь, );
	Если Не (М505.Количество() > 1) Тогда
		Возврат "";
	КонецЕсли;
	СтрТаблицаСвойств = М505[1];
	Массив1 = СтрНайтиМежду(СтрТаблицаСвойств, "<TR vAlign=top>", "</TR>", Ложь, );
	// Сообщить("Массив1.Количество()=" + Массив1.Количество());
	Если Массив1.Количество() > 0 Тогда
		Стр = "";
		Для А = 0 По Массив1.ВГраница() Цикл
			//найдем первую ячейку строки таблицы
			М07 = СтрНайтиМежду(Массив1[А], "<TD width=""50%"">", "</TD>", Ложь, );
			СтрХ = М07[0];
			СтрХ = СтрЗаменить(СтрХ, "&nbsp;", " ");
			
			ИмяФайлаСвойства = КаталогСправки + "\" + СтрНайтиМежду(СтрХ, "<A href=""", """>", , )[0];
			
			КаталогНаДиске = Новый Файл(ИмяФайлаСвойства);
			Если Не КаталогНаДиске.Существует() Тогда
				Продолжить;
			КонецЕсли;
			
			ТекстДокСвойства = Новый ТекстовыйДокумент;
			ТекстДокСвойства.Прочитать(ИмяФайлаСвойства);
			СтрТекстДокСвойства = ТекстДокСвойства.ПолучитьТекст();
			СтрРаздела = СтрНайтиМежду(СтрТекстДокСвойства, "<H4 class=dtH4>Использование</H4>", "<H4 class=dtH4>Значение</H4>", , )[0];
			СтрИспользование = СтрНайтиМежду(СтрРаздела, "<P>", "</P>", , )[0];
			СтрИспользование = СтрЗаменить(СтрИспользование, ".", "");

			СвойствоАнгл = СтрНайтиМежду(СтрХ, "(", ")", , )[0];
			СвойствоРус = СтрНайтиМежду(СтрХ, ".html"">", " (", , )[0];
			
			ТипЗнач = "xxxx";
			СтрРаздела = СтрНайтиМежду(СтрТекстДокСвойства, "<H4 class=dtH4>Значение</H4>", "/P>", , )[0];
			ТипЗнач = СтрНайтиМежду(СтрРаздела, "<P>Тип: ", "<", , )[0];
			ТипЗнач = СтрЗаменить(ТипЗнач, ".", "");
			Если ТипЗнач = "Число" Тогда
				ТипЗнач = "int";
			ИначеЕсли ТипЗнач = "Строка" Тогда
				ТипЗнач = "string";
			ИначеЕсли ТипЗнач = "Булево" Тогда
				ТипЗнач = "bool";
			ИначеЕсли ТипЗнач = "Произвольный" Тогда
				ТипЗнач = "IValue";
			ИначеЕсли СвойствоАнгл = "VerticalTextAlignment" 
				или СвойствоАнгл = "TextAlignment" 
				или СвойствоАнгл = "HotKey" 
				или СвойствоАнгл = "TextDirection" 
				или СвойствоАнгл = "Shortcut" 
				или СвойствоАнгл = "LayoutStyle" 
			
				Тогда
				ТипЗнач = "int";
			ИначеЕсли СвойствоАнгл = "TextFormatter" Тогда
				ТипЗнач = "TfTextFormatter";
			ИначеЕсли СвойствоАнгл = "Subviews" Тогда
				ТипЗнач = "ArrayImpl";
			ИначеЕсли СвойствоАнгл = "ShortcutAction" Тогда
				ТипЗнач = "TfAction";
			ИначеЕсли СвойствоАнгл = "ColorScheme" Тогда
				ТипЗнач = "TfColorScheme";
			ИначеЕсли СвойствоАнгл = "Border" Тогда
				ТипЗнач = "TfBorder";
			ИначеЕсли СвойствоАнгл = "Bounds" 
				или СвойствоАнгл = "Frame" 
				Тогда
				ТипЗнач = "TfRect";
			КонецЕсли;

			Если (СвойствоРус = "Данные") Тогда
				Стр = Стр +
				"        [ContextProperty(""Данные"", ""Data"")]
				|        public IValue Data
				|        {
				|            get { return OneScriptTerminalGui.RevertObj(Base_obj.Data); }
				|            set { Base_obj.Data = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Подэлементы") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""Подэлементы"", ""Subviews"")]
				|        public TfSubviewCollection Subviews
				|        {
				|            get { return new TfSubviewCollection((dynamic)Base_obj.M_Window.Subviews[0].Subviews); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Подэлементы") Тогда
				Стр = Стр +
				"        [ContextProperty(""Подэлементы"", ""Subviews"")]
				|        public TfSubviewCollection Subviews
				|        {
				|            get { return new TfSubviewCollection(Base_obj.M_" + КлассАнгл + ".Subviews); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Количество") и (КлассАнгл = "SubviewCollection") Тогда
				Стр = Стр +
				"        [ContextProperty(""Количество"", ""Count"")]
				|        public int CountControl
				|        {
				|            get { return Base_obj.M_SubviewCollection.Count; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ОсновнойЦвет") Тогда
				Стр = Стр +
				"        [ContextProperty(""ОсновнойЦвет"", ""Foreground"")]
				|        public int Foreground
				|        {
				|            get { return Base_obj.Foreground; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЦветФона") и (КлассАнгл = "Attribute") Тогда
				Стр = Стр +
				"        [ContextProperty(""ЦветФона"", ""Background"")]
				|        public int Background
				|        {
				|            get { return Base_obj.Background; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЦветФона") Тогда
				Стр = Стр +
				"        [ContextProperty(""ЦветФона"", ""Background"")]
				|        public int Background
				|        {
				|            get { return Base_obj.Background; }
				|            set { Base_obj.Background = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ПанельМеню") и (КлассАнгл = "Toplevel") Тогда
				Стр = Стр +
				"        [ContextProperty(""ПанельМеню"", ""MenuBar"")]
				|        public TfMenuBar MenuBar
				|        {
				|            get { return Base_obj.MenuBar.dll_obj; }
				|            set { Base_obj.MenuBar = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СтрокаСостояния") и (КлассАнгл = "Toplevel") Тогда
				Стр = Стр +
				"        [ContextProperty(""СтрокаСостояния"", ""StatusBar"")]
				|        public TfStatusBar StatusBar
				|        {
				|            get { return Base_obj.StatusBar.dll_obj; }
				|            set { Base_obj.M_View.Add(value.Base_obj.M_View); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Игрек") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue y = null;
				|        [ContextProperty(""Игрек"", ""Y"")]
				|        public int Y
				|        {
				|            get { return Convert.ToInt32(y.AsNumber()); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Игрек") и (
				(КлассАнгл = "Point") или 
				(КлассАнгл = "Rect")) Тогда
				Стр = Стр +
				"        [ContextProperty(""Игрек"", ""Y"")]
				|        public int Y
				|        {
				|            get { return Base_obj.Y; }
				|            set { Base_obj.Y = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Икс") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue x = null;
				|        [ContextProperty(""Икс"", ""X"")]
				|        public int X
				|        {
				|            get { return Convert.ToInt32(x.AsNumber()); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Икс") и (
				(КлассАнгл = "Point") или 
				(КлассАнгл = "Rect")) Тогда
				Стр = Стр +
				"        [ContextProperty(""Икс"", ""X"")]
				|        public int X
				|        {
				|            get { return Base_obj.X; }
				|            set { Base_obj.X = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Икс") Тогда
				Стр = Стр +
				"        [ContextProperty(""Икс"", ""X"")]
				|        public TfPos X
				|        {
				|            get { return new TfPos(Base_obj.X); }
				|            set { Base_obj.X = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Клавиша") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue keyValue = null;
				|        [ContextProperty(""Клавиша"", ""KeyValue"")]
				|        public int KeyValue
				|        {
				|            get { return Convert.ToInt32(keyValue.AsNumber()); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "КлавишаСтрокой") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue keyToString = null;
				|        [ContextProperty(""КлавишаСтрокой"", ""KeyToString"")]
				|        public string KeyToString
				|        {
				|            get { return keyToString.AsString(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Отправитель") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue sender = null;
				|        [ContextProperty(""Отправитель"", ""Sender"")]
				|        public IValue Sender
				|        {
				|            get { return sender; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Параметр") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue parameter = null;
				|        [ContextProperty(""Параметр"", ""Parameter"")]
				|        public IValue Parameter
				|        {
				|            get { return parameter; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Прямоугольник") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public TfRect rect = null;
				|        [ContextProperty(""Прямоугольник"", ""Rect"")]
				|        public TfRect Rect
				|        {
				|            get { return rect; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СмещениеИгрек") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue ofY = null;
				|        [ContextProperty(""СмещениеИгрек"", ""OfY"")]
				|        public int OfY
				|        {
				|            get { return Convert.ToInt32(ofY.AsNumber()); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СмещениеИкс") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue ofX = null;
				|        [ContextProperty(""СмещениеИкс"", ""OfX"")]
				|        public int OfX
				|        {
				|            get { return Convert.ToInt32(ofX.AsNumber()); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СтарыеГраницы") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public TfRect oldBounds = null;
				|        [ContextProperty(""СтарыеГраницы"", ""OldBounds"")]
				|        public TfRect OldBounds
				|        {
				|            get { return oldBounds; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ФлагиМыши") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue flags = null;
				|        [ContextProperty(""ФлагиМыши"", ""Flags"")]
				|        public int Flags
				|        {
				|            get { return Convert.ToInt32(flags.AsNumber()); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Элемент") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue view = null;
				|        [ContextProperty(""Элемент"", ""View"")]
				|        public IValue View
				|        {
				|            get { return view; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЭтоAlt") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue isAlt = null;
				|        [ContextProperty(""ЭтоAlt"", ""IsAlt"")]
				|        public bool IsAlt
				|        {
				|            get { return isAlt.AsBoolean(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЭтоCapslock") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue isCapslock = null;
				|        [ContextProperty(""ЭтоCapslock"", ""IsCapslock"")]
				|        public bool IsCapslock
				|        {
				|            get { return isCapslock.AsBoolean(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЭтоCtrl") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue isCtrl = null;
				|        [ContextProperty(""ЭтоCtrl"", ""IsCtrl"")]
				|        public bool IsCtrl
				|        {
				|            get { return isCtrl.AsBoolean(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЭтоNumlock") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue isNumlock = null;
				|        [ContextProperty(""ЭтоNumlock"", ""IsNumlock"")]
				|        public bool IsNumlock
				|        {
				|            get { return isNumlock.AsBoolean(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЭтоScrolllock") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue isScrolllock = null;
				|        [ContextProperty(""ЭтоScrolllock"", ""IsScrolllock"")]
				|        public bool IsScrolllock
				|        {
				|            get { return isScrolllock.AsBoolean(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЭтоShift") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue isShift = null;
				|        [ContextProperty(""ЭтоShift"", ""IsShift"")]
				|        public bool IsShift
				|        {
				|            get { return isShift.AsBoolean(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Размер") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public TfSize size = null;
				|        [ContextProperty(""Размер"", ""Size"")]
				|        public TfSize Size
				|        {
				|            get { return size; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Отмена") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue cancel = null;
				|        [ContextProperty(""Отмена"", ""Cancel"")]
				|        public bool Cancel
				|        {
				|            get { return cancel.AsBoolean(); }
				|            set { cancel = ValueFactory.Create(value); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Заголовок") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextProperty(""Заголовок"", ""Title"")]
				|        public string Title
				|        {
				|            get { return Base_obj.Title; }
				|            set { Base_obj.Title = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Смещение3D") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextProperty(""Смещение3D"", ""Effect3DOffset"")]
				|        public TfPoint Effect3DOffset
				|        {
				|            get { return new TfPoint(Base_obj.Effect3DOffset); }
				|            set { Base_obj.Effect3DOffset = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СтильГраницы") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextProperty(""СтильГраницы"", ""BorderStyle"")]
				|        public int BorderStyle
				|        {
				|            get { return Base_obj.BorderStyle; }
				|            set { Base_obj.BorderStyle = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ТолщинаГраницы") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextProperty(""ТолщинаГраницы"", ""BorderThickness"")]
				|        public TfThickness BorderThickness
				|        {
				|            get { return new TfThickness(Base_obj.BorderThickness); }
				|            set { Base_obj.BorderThickness = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Цвет3D") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextProperty(""Цвет3D"", ""Effect3DBrush"")]
				|        public TfAttribute Effect3DBrush
				|        {
				|            get { return new TfAttribute(Base_obj.Effect3DBrush); }
				|            set { Base_obj.Effect3DBrush = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЦветГраницы") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextProperty(""ЦветГраницы"", ""BorderBrush"")]
				|        public int BorderBrush
				|        {
				|            get { return Base_obj.BorderBrush; }
				|            set { Base_obj.BorderBrush = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СимволКлавиши") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue keySymbol = null;
				|        [ContextProperty(""СимволКлавиши"", ""KeySymbol"")]
				|        public string KeySymbol
				|        {
				|            get { return keySymbol.AsString(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Граница") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public TfBorder border = null;
				|        [ContextProperty(""Граница"", ""Border"")]
				|        public TfBorder Border
				|        {
				|            get { return border; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Граница") Тогда
				Стр = Стр +
				"        [ContextProperty(""Граница"", ""Border"")]
				|        public TfBorder Border
				|        {
				|            get { return Base_obj.Border.dll_obj; }
				|            set { Base_obj.Border = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Заголовок") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""Заголовок"", ""Title"")]
				|        public string Title
				|        {
				|            get { return Base_obj.Title; }
				|            set { Base_obj.Title = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ПанельМеню") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""ПанельМеню"", ""MenuBar"")]
				|        public TfMenuBar MenuBar
				|        {
				|            get { return Base_obj.MenuBar.dll_obj; }
				|            set { Base_obj.MenuBar = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СтрокаСостояния") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""СтрокаСостояния"", ""StatusBar"")]
				|        public TfStatusBar StatusBar
				|        {
				|            get { return Base_obj.StatusBar.dll_obj; }
				|            set { Base_obj.M_View.Add(value.Base_obj.M_View); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ВертикальноеВыравнивание") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextProperty(""ВертикальноеВыравнивание"", ""VerticalAlignment"")]
				|        public int VerticalAlignment
				|        {
				|            get { return Base_obj.VerticalAlignment; }
				|            set { Base_obj.VerticalAlignment = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Выравнивание") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextProperty(""Выравнивание"", ""Alignment"")]
				|        public int Alignment
				|        {
				|            get { return Base_obj.Alignment; }
				|            set { Base_obj.Alignment = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "НаправлениеТекста") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextProperty(""НаправлениеТекста"", ""Direction"")]
				|        public int Direction
				|        {
				|            get { return Base_obj.Direction; }
				|            set { Base_obj.Direction = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ГорячийНормальный") и (КлассАнгл = "ColorScheme") Тогда
				Стр = Стр +
				"        [ContextProperty(""ГорячийНормальный"", ""HotNormal"")]
				|        public TfAttribute HotNormal
				|        {
				|            get { return Base_obj.HotNormal.dll_obj; }
				|            set { Base_obj.HotNormal = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ГорячийФокус") и (КлассАнгл = "ColorScheme") Тогда
				Стр = Стр +
				"        [ContextProperty(""ГорячийФокус"", ""HotFocus"")]
				|        public TfAttribute HotFocus
				|        {
				|            get { return Base_obj.HotFocus.dll_obj; }
				|            set { Base_obj.HotFocus = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Нормальный") и (КлассАнгл = "ColorScheme") Тогда
				Стр = Стр +
				"        [ContextProperty(""Нормальный"", ""Normal"")]
				|        public TfAttribute Normal
				|        {
				|            get { return Base_obj.Normal.dll_obj; }
				|            set { Base_obj.Normal = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Отключено") и (КлассАнгл = "ColorScheme") Тогда
				Стр = Стр +
				"        [ContextProperty(""Отключено"", ""Disabled"")]
				|        public TfAttribute Disabled
				|        {
				|            get { return Base_obj.Disabled.dll_obj; }
				|            set { Base_obj.Disabled = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Фокус") и (КлассАнгл = "ColorScheme") Тогда
				Стр = Стр +
				"        [ContextProperty(""Фокус"", ""Focus"")]
				|        public TfAttribute Focus
				|        {
				|            get { return Base_obj.Focus.dll_obj; }
				|            set { Base_obj.Focus = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Количество") и (КлассАнгл = "MenusCollection") Тогда
				Стр = Стр +
				"        [ContextProperty(""Количество"", ""Count"")]
				|        public int Count
				|        {
				|            get { return M_Object.Length; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Клавиша") и (КлассАнгл = "MenuBar") Тогда
				Стр = Стр +
				"        [ContextProperty(""Клавиша"", ""Key"")]
				|        public int Key
				|        {
				|            get { return Base_obj.Key; }
				|            set { Base_obj.Key = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ПодМеню") и (КлассАнгл = "MenuBar") Тогда
				Стр = Стр +
				"        [ContextProperty(""ПодМеню"", ""Menus"")]
				|        public TfMenusCollection Menus
				|        {
				|            get { return menusCollection; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ПоследнийФокус") и (КлассАнгл = "MenuBar") Тогда
				Стр = Стр +
				"        [ContextProperty(""ПоследнийФокус"", ""LastFocused"")]
				|        public IValue LastFocused
				|        {
				|            get { return Base_obj.LastFocused.dll_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Количество") и (КлассАнгл = "StatusBarItems") Тогда
				Стр = Стр +
				"        [ContextProperty(""Количество"", ""Count"")]
				|        public int Count
				|        {
				|            get { return M_Object.Length; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Элементы") и (КлассАнгл = "StatusBar") Тогда
				Стр = Стр +
				"        [ContextProperty(""Элементы"", ""Items"")]
				|        public TfStatusBarItems Items
				|        {
				|            get { return statusBarItems; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СтильФлажка") и (КлассАнгл = "MenuItem") Тогда
				Стр = Стр +
				"        [ContextProperty(""СтильФлажка"", ""CheckType"")]
				|        public int CheckType
				|        {
				|            get { return Base_obj.CheckType; }
				|            set { Base_obj.CheckType = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Родитель") и (КлассАнгл = "MenuItem") Тогда
				Стр = Стр +
				"        [ContextProperty(""Родитель"", ""Parent"")]
				|        public IValue Parent
				|        {
				|            get { return Base_obj.Parent; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Количество") и (КлассАнгл = "MenuBarItemChildren") Тогда
				Стр = Стр +
				"        [ContextProperty(""Количество"", ""Count"")]
				|        public int Count
				|        {
				|            get { return M_Object.Length; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Родитель") и (КлассАнгл = "MenuBarItem") Тогда
				Стр = Стр +
				"        [ContextProperty(""Родитель"", ""Parent"")]
				|        public IValue Parent
				|        {
				|            get { return Base_obj.Parent; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Родитель") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextProperty(""Родитель"", ""Parent"")]
				|        public IValue Parent
				|        {
				|            get { return Base_obj.Parent; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Родитель") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""Родитель"", ""SuperView"")]
				|        public IValue SuperView
				|        {
				|            get
				|            {
				|                try
				|                {
				|                    return OneScriptTerminalGui.RevertEqualsObj(Base_obj.M_Window.Subviews[0].SuperView.SuperView.SuperView).dll_obj;
				|                }
				|                catch (Exception)
				|                {
				|                    return OneScriptTerminalGui.RevertEqualsObj(Base_obj.M_Window.Subviews[0].SuperView.SuperView).dll_obj;
				|                }
				|            }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Родитель") Тогда
				Стр = Стр +
				"        [ContextProperty(""Родитель"", ""SuperView"")]
				|        public IValue SuperView
				|        {
				|            get { return OneScriptTerminalGui.RevertEqualsObj(Base_obj.SuperView.M_View).dll_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СтильФлажка") и (КлассАнгл = "MenuBarItem") Тогда
				Стр = Стр +
				"        [ContextProperty(""СтильФлажка"", ""CheckType"")]
				|        public int CheckType
				|        {
				|            get { return Base_obj.CheckType; }
				|            set { Base_obj.CheckType = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Элементы") и (КлассАнгл = "MenuBarItem") Тогда
				Стр = Стр +
				"        [ContextProperty(""Элементы"", ""Children"")]
				|        public TfMenuBarItemChildren Children
				|        {
				|            get { return menuBarItemChildren; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Верхний") и (КлассАнгл = "Colors") Тогда
				Стр = Стр +
				"        [ContextProperty(""Верхний"", ""TopLevel"")]
				|        public TfColorScheme TopLevel
				|        {
				|            get { return new TfColorScheme(Base_obj.TopLevel); }
				|            set { Base_obj.TopLevel = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Диалог") и (КлассАнгл = "Colors") Тогда
				Стр = Стр +
				"        [ContextProperty(""Диалог"", ""Dialog"")]
				|        public TfColorScheme Dialog
				|        {
				|            get { return new TfColorScheme(Base_obj.Dialog); }
				|            set { Base_obj.Dialog = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Меню") и (КлассАнгл = "Colors") Тогда
				Стр = Стр +
				"        [ContextProperty(""Меню"", ""Menu"")]
				|        public TfColorScheme Menu
				|        {
				|            get { return new TfColorScheme(Base_obj.Menu); }
				|            set { Base_obj.Menu = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Основа") и (КлассАнгл = "Colors") Тогда
				Стр = Стр +
				"        [ContextProperty(""Основа"", ""Base"")]
				|        public TfColorScheme Base
				|        {
				|            get { return new TfColorScheme(Base_obj.Base); }
				|            set { Base_obj.Base = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Ошибка") и (КлассАнгл = "Colors") Тогда
				Стр = Стр +
				"        [ContextProperty(""Ошибка"", ""Error"")]
				|        public TfColorScheme Error
				|        {
				|            get { return new TfColorScheme(Base_obj.Error); }
				|            set { Base_obj.Error = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Высота") и (КлассАнгл = "Size") Тогда
				Стр = Стр +
				"        [ContextProperty(""Высота"", ""Height"")]
				|        public int Height
				|        {
				|            get { return Base_obj.Height; }
				|            set { Base_obj.Height = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Высота") и (КлассАнгл = "Rect") Тогда
				Стр = Стр +
				"        [ContextProperty(""Высота"", ""Height"")]
				|        public int Height
				|        {
				|            get { return Base_obj.Height; }
				|            set { Base_obj.Height = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Ширина") и (КлассАнгл = "Rect") Тогда
				Стр = Стр +
				"        [ContextProperty(""Ширина"", ""Width"")]
				|        public int Width
				|        {
				|            get { return Base_obj.Width; }
				|            set { Base_obj.Width = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Ширина") и (КлассАнгл = "Size") Тогда
				Стр = Стр +
				"        [ContextProperty(""Ширина"", ""Width"")]
				|        public int Width
				|        {
				|            get { return Base_obj.Width; }
				|            set { Base_obj.Width = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Высота") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private int height = 4;
				|        [ContextProperty(""Высота"", ""Height"")]
				|        public int Height
				|        {
				|            get { return height; }
				|            set { height = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Высота") Тогда
				Стр = Стр +
				"        [ContextProperty(""Высота"", ""Height"")]
				|        public TfDim Height
				|        {
				|            get { return Base_obj.Height.dll_obj; }
				|            set { Base_obj.Height = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Верх") и (КлассАнгл = "Thickness") Тогда
				Стр = Стр +
				"        [ContextProperty(""Верх"", ""Top"")]
				|        public int Top
				|        {
				|            get { return Base_obj.Top; }
				|            set { Base_obj.Top = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Низ") и (КлассАнгл = "Thickness") Тогда
				Стр = Стр +
				"        [ContextProperty(""Низ"", ""Bottom"")]
				|        public int Bottom
				|        {
				|            get { return Base_obj.Bottom; }
				|            set { Base_obj.Bottom = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Лево") и (КлассАнгл = "Thickness") Тогда
				Стр = Стр +
				"        [ContextProperty(""Лево"", ""Left"")]
				|        public int Left
				|        {
				|            get { return Base_obj.Left; }
				|            set { Base_obj.Left = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Право") и (КлассАнгл = "Thickness") Тогда
				Стр = Стр +
				"        [ContextProperty(""Право"", ""Right"")]
				|        public int Right
				|        {
				|            get { return Base_obj.Right; }
				|            set { Base_obj.Right = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Верх") и (КлассАнгл = "Rect") Тогда
				Стр = Стр +
				"        [ContextProperty(""Верх"", ""Top"")]
				|        public int Top
				|        {
				|            get { return Base_obj.Top; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Лево") и (КлассАнгл = "Rect") Тогда
				Стр = Стр +
				"        [ContextProperty(""Лево"", ""Left"")]
				|        public int Left
				|        {
				|            get { return Base_obj.Left; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Низ") и (КлассАнгл = "Rect") Тогда
				Стр = Стр +
				"        [ContextProperty(""Низ"", ""Bottom"")]
				|        public int Bottom
				|        {
				|            get { return Base_obj.Bottom; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Право") и (КлассАнгл = "Rect") Тогда
				Стр = Стр +
				"        [ContextProperty(""Право"", ""Right"")]
				|        public int Right
				|        {
				|            get { return Base_obj.Right; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Верх") Тогда
				Стр = Стр +
				"        [ContextProperty(""Верх"", ""Top"")]
				|        public TfPos Top
				|        {
				|            get { return new TfPos(Base_obj.Top); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Низ") Тогда
				Стр = Стр +
				"        [ContextProperty(""Низ"", ""Bottom"")]
				|        public TfPos Bottom
				|        {
				|            get { return new TfPos(Base_obj.Bottom); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Лево") Тогда
				Стр = Стр +
				"        [ContextProperty(""Лево"", ""Left"")]
				|        public TfPos Left
				|        {
				|            get { return new TfPos(Base_obj.Left); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Право") Тогда
				Стр = Стр +
				"        [ContextProperty(""Право"", ""Right"")]
				|        public TfPos Right
				|        {
				|            get { return new TfPos(Base_obj.Right); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Игрек") Тогда
				Стр = Стр +
				"        [ContextProperty(""Игрек"", ""Y"")]
				|        public TfPos Y
				|        {
				|            get { return new TfPos(Base_obj.Y); }
				|            set { Base_obj.Y = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Ширина") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private int width = 50;
				|        [ContextProperty(""Ширина"", ""Width"")]
				|        public int Width
				|        {
				|            get { return width; }
				|            set { width = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Ширина") Тогда
				Стр = Стр +
				"        [ContextProperty(""Ширина"", ""Width"")]
				|        public TfDim Width
				|        {
				|            get { return Base_obj.Width.dll_obj; }
				|            set { Base_obj.Width = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Границы") Тогда
				Стр = Стр +
				"        [ContextProperty(""Границы"", ""Bounds"")]
				|        public TfRect Bounds
				|        {
				|            get { return new TfRect(Base_obj.Frame.M_Rect.X, Base_obj.Frame.M_Rect.Y, Base_obj.Bounds.M_Rect.Width, Base_obj.Bounds.M_Rect.Height); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Кадр") Тогда
				Стр = Стр +
				"        [ContextProperty(""Кадр"", ""Frame"")]
				|        public TfRect Frame
				|        {
				|            get { return new TfRect(Base_obj.Frame.M_Rect.X, Base_obj.Frame.M_Rect.Y, Base_obj.Frame.M_Rect.Width, Base_obj.Frame.M_Rect.Height); }
				|            set { Base_obj.Frame = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЦветоваяСхема") Тогда
				Стр = Стр +
				"        [ContextProperty(""ЦветоваяСхема"", ""ColorScheme"")]
				|        public TfColorScheme ColorScheme
				|        {
				|            get { return Base_obj.ColorScheme.dll_obj; }
				|            set { Base_obj.ColorScheme = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СимволКлавишиВызова") Тогда
				Стр = Стр +
				"        [ContextProperty(""СимволКлавишиВызова"", ""HotKeySpecifier"")]
				|        public IValue HotKeySpecifier
				|        {
				|            get
				|            {
				|                if (Base_obj.HotKeySpecifier == (Rune)0xFFFF)
				|                {
				|                    return ValueFactory.CreateNullValue();
				|                }
				|                else
				|                {
				|                    return ValueFactory.Create(Base_obj.HotKeySpecifier.ToString());
				|                }
				|            }
				|            set
				|            {
				|                if (value.SystemType.Name == ""Неопределено"")
				|                {
				|                    Base_obj.HotKeySpecifier = (Rune)0xFFFF;
				|                }
				|                else
				|                {
				|                    Base_obj.HotKeySpecifier = value.AsString().ToCharArray()[0];
				|                }
				|            }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ВертикальноеВыравниваниеТекста") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""ВертикальноеВыравниваниеТекста"", ""VerticalTextAlignment"")]
				|        public int VerticalTextAlignment
				|        {
				|            get { return (int)Base_obj.M_Window.Subviews[0].VerticalTextAlignment; }
				|            set { Base_obj.M_Window.Subviews[0].VerticalTextAlignment = (Terminal.Gui.VerticalTextAlignment)value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ВФокусе") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""ВФокусе"", ""Focused"")]
				|        public IValue Focused
				|        {
				|            get
				|            {
				|                if (Base_obj.M_Window.Subviews[0].Focused != null)
				|                {
				|                    return OneScriptTerminalGui.RevertEqualsObj(Base_obj.M_Window.Subviews[0].Focused).dll_obj;
				|                }
				|                return null;
				|            }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ВыравниваниеТекста") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""ВыравниваниеТекста"", ""TextAlignment"")]
				|        public int TextAlignment
				|        {
				|            get { return (int)Base_obj.M_Window.Subviews[0].TextAlignment; }
				|            set { Base_obj.M_Window.Subviews[0].TextAlignment = (Terminal.Gui.TextAlignment)value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ИгнорироватьГраницуПриПерерисовке") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""ИгнорироватьГраницуПриПерерисовке"", ""IgnoreBorderPropertyOnRedraw"")]
				|        public bool IgnoreBorderPropertyOnRedraw
				|        {
				|            get { return Base_obj.M_Window.Subviews[0].IgnoreBorderPropertyOnRedraw; }
				|            set { Base_obj.M_Window.Subviews[0].IgnoreBorderPropertyOnRedraw = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "НаправлениеТекста") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""НаправлениеТекста"", ""TextDirection"")]
				|        public int TextDirection
				|        {
				|            get { return (int)Base_obj.M_Window.Subviews[0].TextDirection; }
				|            set { Base_obj.M_Window.Subviews[0].TextDirection = (Terminal.Gui.TextDirection)value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ОформительТекста") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextProperty(""ОформительТекста"", ""TextFormatter"")]
				|        public TfTextFormatter TextFormatter
				|        {
				|            get { return OneScriptTerminalGui.RevertEqualsObj(Base_obj.M_Window.Subviews[0].TextFormatter).dll_obj; }
				|            set { Base_obj.M_Window.Subviews[0].TextFormatter = value.Base_obj.M_TextFormatter; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ОформительТекста") Тогда
				Стр = Стр +
				"        [ContextProperty(""ОформительТекста"", ""TextFormatter"")]
				|        public TfTextFormatter TextFormatter
				|        {
				|            get { return Base_obj.TextFormatter.dll_obj; }
				|            set { Base_obj.TextFormatter = value.Base_obj; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Линии") Тогда
				Стр = Стр +
				"        [ContextProperty(""Линии"", ""Lines"")]
				|        public ArrayImpl Lines
				|        {
				|            get { return Base_obj.Lines; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Заголовок") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private string title = ""ОкноСообщений"";
				|        [ContextProperty(""Заголовок"", ""Title"")]
				|        public string Title
				|        {
				|            get { return title; }
				|            set { title = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ИндексКнопкиПоУмолчанию") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private int defaultButtonIndex = 0;
				|        [ContextProperty(""ИндексКнопкиПоУмолчанию"", ""DefaultButtonIndex"")]
				|        public int DefaultButtonIndex
				|        {
				|            get { return defaultButtonIndex; }
				|            set { defaultButtonIndex = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Кнопки") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private ArrayImpl buttons;
				|        [ContextProperty(""Кнопки"", ""Buttons"")]
				|        public ArrayImpl Buttons
				|        {
				|            get { return buttons; }
				|            set { buttons = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Сообщение") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private string message = """";
				|        [ContextProperty(""Сообщение"", ""Message"")]
				|        public string Message
				|        {
				|            get { return message; }
				|            set { message = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "АвтоРазмер") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private bool autoSize = true;
				|        [ContextProperty(""АвтоРазмер"", ""AutoSize"")]
				|        public bool AutoSize
				|        {
				|            get { return autoSize; }
				|            set { autoSize = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Интервал") и (КлассАнгл = "Timer") Тогда
				Стр = Стр +
				"        private int interval = 0;
				|        [ContextProperty(""Интервал"", ""Interval"")]
				|        public int Interval
				|        {
				|            get { return interval; }
				|            set { interval = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Интервал") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        private int interval = 0;
				|        [ContextProperty(""Интервал"", ""Interval"")]
				|        public int Interval
				|        {
				|            get { return interval; }
				|            set { interval = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "НовыйЗаголовок") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue newTitle = null;
				|        [ContextProperty(""НовыйЗаголовок"", ""NewTitle"")]
				|        public string NewTitle
				|        {
				|            get { return newTitle.AsString(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СтарыйЗаголовок") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue oldTitle = null;
				|        [ContextProperty(""СтарыйЗаголовок"", ""OldTitle"")]
				|        public string OldTitle
				|        {
				|            get { return oldTitle.AsString(); }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ЭлементМеню") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue menuItem = null;
				|        [ContextProperty(""ЭлементМеню"", ""MenuItem"")]
				|        public IValue MenuItem
				|        {
				|            get { return menuItem; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ТекущийПунктМеню") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue currentMenu = null;
				|        [ContextProperty(""ТекущийПунктМеню"", ""CurrentMenu"")]
				|        public IValue CurrentMenu
				|        {
				|            get { return currentMenu; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "НовыйПунктМеню") и (КлассАнгл = "EventArgs") Тогда
				Стр = Стр +
				"        public IValue newMenuBarItem = null;
				|        [ContextProperty(""НовыйПунктМеню"", ""NewMenuBarItem"")]
				|        public IValue NewMenuBarItem
				|        {
				|            get { return newMenuBarItem; }
				|            set { newMenuBarItem = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ОтключитьКлавишуВызова") и (КлассАнгл = "View") Тогда
				Стр = Стр +
				"        private bool disableHotKey = false;
				|        [ContextProperty(""ОтключитьКлавишуВызова"", ""DisableHotKey"")]
				|        public bool DisableHotKey
				|        {
				|            get { return disableHotKey; }
				|            set
				|            {
				|                if (value)
				|                {
				|                    Base_obj.HotKeySpecifier = (Rune)0xFFFF;
				|                    disableHotKey = true;
				|                }
				|                else
				|                {
				|                    Base_obj.HotKeySpecifier = new Rune(""_"".ToCharArray()[0]);
				|                    disableHotKey = false;
				|                }
				|            }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "СочетаниеКлавиш") Тогда
				Стр = Стр +
				"        private decimal shortcut;
				|        [ContextProperty(""СочетаниеКлавиш"", ""Shortcut"")]
				|        public decimal Shortcut
				|        {
				|            get { return shortcut; }
				|            set { shortcut = value; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "КлавишаВызова") и (
				(КлассАнгл = "MenuItem") 
				или (КлассАнгл = "MenuBarItem") 
				) 
				Тогда
				Стр = Стр +
				"        [ContextProperty(""КлавишаВызова"", ""HotKey"")]
				|        public string HotKey
				|        {
				|            get { return Base_obj.HotKey; }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "ОтключитьКлавишуВызова") Тогда
				Стр = Стр +
				"        private bool disableHotKey = false;
				|        [ContextProperty(""ОтключитьКлавишуВызова"", ""DisableHotKey"")]
				|        public bool DisableHotKey
				|        {
				|            get { return disableHotKey; }
				|            set
				|            {
				|                if (value)
				|                {
				|                    Base_obj.HotKeySpecifier = (Rune)0xFFFF;
				|                    disableHotKey = true;
				|                }
				|                else
				|                {
				|                    Base_obj.HotKeySpecifier = new Rune(""_"".ToCharArray()[0]);
				|                    disableHotKey = false;
				|                }
				|            }
				|        }
				|
				|";
			ИначеЕсли (СвойствоРус = "Метка") Тогда
				Стр = Стр +
				"        [ContextProperty(""Метка"", ""Tag"")]
				|        public IValue Tag
				|        {
				|            get { return Base_obj.Tag; }
				|            set { Base_obj.Tag = value; }
				|        }
				|
				|";




				
				
				
				
				
				
				
				
			ИначеЕсли (СвойствоРус = "йййййййй") и (КлассАнгл = "йййййййй") Тогда
				Стр = Стр +
				"        [ContextProperty(""йййййййй"", ""йййййййй"")]


				|
				|";
				
				
				
				
				
			Иначе
				Если СтрИспользование = "Только чтение" Тогда
					Стр = Стр +
					"        [ContextProperty(""" + СвойствоРус + """, """ + СвойствоАнгл + """)]
					|        public " + ТипЗнач + " " + СвойствоАнгл + "
					|        {
					|            get { return Base_obj." + СвойствоАнгл + "; }
					|        }
					|
					|";
				ИначеЕсли СтрИспользование = "Чтение и запись" Тогда
					Стр = Стр +
					"        [ContextProperty(""" + СвойствоРус + """, """ + СвойствоАнгл + """)]
					|        public " + ТипЗнач + " " + СвойствоАнгл + "
					|        {
					|            get { return Base_obj." + СвойствоАнгл + "; }
					|            set { Base_obj." + СвойствоАнгл + " = value; }
					|        }
					|
					|";
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Иначе
		Стр = "";
	КонецЕсли;
	
	Возврат Стр;
КонецФункции//Свойства

Функция События(ФайлСобытий, КлассАнгл, КлассРус)
	ТекстДокСобытия = Новый ТекстовыйДокумент;
	КаталогНаДиске = Новый Файл(ФайлСобытий);
    Если Не (КаталогНаДиске.Существует()) Тогда
		Возврат "";
	КонецЕсли;
	ТекстДокСобытия.Прочитать(ФайлСобытий);
	СтрТекстДокСобытия = ТекстДокСобытия.ПолучитьТекст();
	М505 = СтрНайтиМежду(СтрТекстДокСобытия, "<TBODY>", "</TABLE>", Ложь, );
	Если Не (М505.Количество() > 1) Тогда
		Возврат "";
	КонецЕсли;
	СтрТаблицаСобытий = М505[1];
	Массив1 = СтрНайтиМежду(СтрТаблицаСобытий, "<TR vAlign=top>", "</TR>", Ложь, );
	// Сообщить("Массив1.Количество()=" + Массив1.Количество());
	Если Массив1.Количество() > 0 Тогда
		Стр = "";
		Для А = 0 По Массив1.ВГраница() Цикл
			//найдем первую ячейку строки таблицы
			М07 = СтрНайтиМежду(Массив1[А], "<TD width=""50%"">", "</TD>", Ложь, );
			СтрХ = М07[0];
			СтрХ = СтрЗаменить(СтрХ, "&nbsp;", " ");
			ИмяФайлаСобытия = КаталогСправки + "\" + СтрНайтиМежду(СтрХ, "<A href=""", """>", , )[0];
			// Сообщить("ИмяФайлаСобытия = " + ИмяФайлаСобытия);
			
			КаталогНаДиске = Новый Файл(ИмяФайлаСобытия);
			Если Не КаталогНаДиске.Существует() Тогда
				Продолжить;
			КонецЕсли;
			
			ТекстДокСобытия = Новый ТекстовыйДокумент;
			ТекстДокСобытия.Прочитать(ИмяФайлаСобытия);
			СтрТекстДокСобытия = ТекстДокСобытия.ПолучитьТекст();
			// <H1 class=dtH1>Кнопка.Нажатие&nbsp;(Button.Clicked)&nbsp;Событие</H1>
			М506 = СтрНайтиМежду(СтрТекстДокСобытия, "<H1 class=dtH1>", "Событие</H1>", , );
			Если М506.Количество() > 0 Тогда
				Стр506 = М506[0];
				Стр506 = СтрЗаменить(Стр506, "&nbsp;", ".");
				Стр506 = СтрЗаменить(Стр506, ".", " ");
				Стр506 = СтрЗаменить(Стр506, "(", "");
				Стр506 = СтрЗаменить(Стр506, ")", "");
				Стр506 = СокрЛП(Стр506);
				// Сообщить("Стр506 = " + Стр506);
			КонецЕсли;
			М507 = СтрРазделить(Стр506, " ");
			КлассРус = М507[0];
			СобытиеРус = М507[1];
			КлассАнгл = М507[2];
			СобытиеАнгл = М507[3];
			// Сообщить("КлассРус = " + КлассРус);
			// Сообщить("СобытиеРус = " + СобытиеРус);
			// Сообщить("КлассАнгл = " + КлассАнгл);
			// Сообщить("СобытиеАнгл = " + СобытиеАнгл);
			// Сообщить("====================================");
			
			Если (СобытиеРус = "йййййййй") и (КлассАнгл = "йййййййй") Тогда
				Стр = Стр +
				"        [ContextProperty(""ЭлементАктивирован"", ""InitializedItem"")]
				|        public TfAction InitializedItem
				|        {
				|            get { return Base_obj.Initialized; }
				|            set { Base_obj.Initialized = value; }
				|        }
				|
				|";
			ИначеЕсли (СобытиеРус = "йййййййй") и (КлассАнгл = "йййййййй") Тогда
				Стр = Стр +
				"        [ContextMethod(""Закрыть"", ""Close"")]
				|        public void Close()
				|        {
				|            string strFunc = ""mapKeyEl.get(\u0022"" + ItemKey + ""\u0022).close();"";
				|            йййййййййййййй.SendStrFunc(strFunc);
				|        }
				|
				|";
				

			
			Иначе	
				Стр = Стр +
				"        [ContextProperty(""" + СобытиеРус + """, """ + СобытиеАнгл + """)]
				|        public TfAction " + СобытиеАнгл + " { get; set; }
				|
				|";
			КонецЕсли;
		КонецЦикла;
	Иначе
		Стр = "" + Символы.ПС;
	КонецЕсли;
	
	Возврат Стр;
	// Возврат "";
КонецФункции//События

Функция Методы(ФайлМетодов, КлассАнгл)
	ТекстДокМетоды = Новый ТекстовыйДокумент;
	КаталогНаДиске = Новый Файл(ФайлМетодов);
    Если Не (КаталогНаДиске.Существует()) Тогда
		Возврат "";
	КонецЕсли;
	ТекстДокМетоды.Прочитать(ФайлМетодов);
	СтрТекстДокМетоды = ТекстДокМетоды.ПолучитьТекст();
	М505 = СтрНайтиМежду(СтрТекстДокМетоды, "<TBODY>", "</TABLE>", Ложь, );
	Если Не (М505.Количество() > 1) Тогда
		Возврат "";
	КонецЕсли;
	СтрТаблицаСвойств = М505[1];
	Массив1 = СтрНайтиМежду(СтрТаблицаСвойств, "<TR vAlign=top>", "</TR>", Ложь, );
	// Сообщить("Массив1.Количество()=" + Массив1.Количество());
	Если Массив1.Количество() > 0 Тогда
		Стр = "";
		Для А = 0 По Массив1.ВГраница() Цикл
			М07 = СтрНайтиМежду(Массив1[А], "<TD width=""50%"">", "</TD>", Ложь, );
			СтрХ = М07[0];
			СтрХ = СтрЗаменить(СтрХ, "&nbsp;", " ");
			
			ИмяФайлаМетода = КаталогСправки + "\" + СтрНайтиМежду(СтрХ, "<A href=""", """>", , )[0];
			
			КаталогНаДиске = Новый Файл(ИмяФайлаМетода);
			Если Не КаталогНаДиске.Существует() Тогда
				Продолжить;
			КонецЕсли;
			
			ТекстДокСвойства = Новый ТекстовыйДокумент;
			ТекстДокСвойства.Прочитать(ИмяФайлаМетода);
			СтрТекстДокМетода = ТекстДокСвойства.ПолучитьТекст();
			// <H1 class=dtH1>Верхний.Добавить (Toplevel.Add)&nbsp;Метод</H1>
			М506 = СтрНайтиМежду(СтрТекстДокМетода, "<H1 class=dtH1>", "Метод</H1>", , );
			Если М506.Количество() > 0 Тогда
				Стр506 = М506[0];
				Стр506 = СтрЗаменить(Стр506, "&nbsp;", "");
				Стр506 = СтрЗаменить(Стр506, ".", " ");
				Стр506 = СтрЗаменить(Стр506, "(", "");
				Стр506 = СтрЗаменить(Стр506, ")", "");
				// Сообщить("Стр506 = " + Стр506);
			КонецЕсли;
			М507 = СтрРазделить(Стр506, " ");
			КлассРус = М507[0];
			МетодРус = М507[1];
			КлассАнгл = М507[2];
			МетодАнгл = М507[3];
			// Сообщить("КлассРус = " + КлассРус);
			// Сообщить("МетодРус = " + МетодРус);
			// Сообщить("КлассАнгл = " + КлассАнгл);
			// Сообщить("МетодАнгл = " + МетодАнгл);
			// Сообщить("====================================");
			
			Если (МетодРус = "йййййййй") и (КлассАнгл = "йййййййй") Тогда
				Стр = Стр +
				"        [ContextMethod(""Закрыть"", ""Close"")]
				|        public void Close()
				|        {
				|            string strFunc = ""mapKeyEl.get(\u0022"" + ItemKey + ""\u0022).close();"";
				|            йййййййййййййй.SendStrFunc(strFunc);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Добавить") и (КлассАнгл = "Point") Тогда
				Стр = Стр +
				"        [ContextMethod(""Добавить"", ""Add"")]
				|        public TfPoint Add(TfPoint p1, TfSize p2)
				|        {
				|            Terminal.Gui.Point point1 = Terminal.Gui.Point.Add(p1.Base_obj.M_Point, p2.Base_obj.M_Size);
				|            return new TfPoint(point1.X, point1.Y);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Добавить") и (КлассАнгл = "Size") Тогда
				Стр = Стр +
				"        [ContextMethod(""Добавить"", ""Add"")]
				|        public TfSize Add(TfSize p1, TfSize p2)
				|        {
				|            Terminal.Gui.Size size1 = Terminal.Gui.Size.Add(p1.Base_obj.M_Size, p2.Base_obj.M_Size);
				|            return new TfSize(size1.Width, size1.Height);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Добавить") и (КлассАнгл = "Toplevel") Тогда
				Стр = Стр +
				"        [ContextMethod(""Добавить"", ""Add"")]
				|        public void Add(IValue p1)
				|        {
				|            Base_obj.Add(((dynamic)p1).Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Добавить") и (КлассАнгл = "MenusCollection") Тогда
				Стр = Стр +
				"        [ContextMethod(""Добавить"", ""Add"")]
				|        public void Add(TfMenuBarItem p1)
				|        {
				|            Terminal.Gui.MenuBarItem[] MenuBarItem2 = new Terminal.Gui.MenuBarItem[M_Object.Length + 1];
				|            M_Object.CopyTo(MenuBarItem2, 0);
				|            MenuBarItem2[M_Object.Length] = p1.Base_obj.M_MenuBarItem;
				|            M_Object = MenuBarItem2;
				|            p1.M_MenuBar = M_MenuBar;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Добавить") и (КлассАнгл = "StatusBarItems") Тогда
				Стр = Стр +
				"        [ContextMethod(""Добавить"", ""Add"")]
				|        public void Add(TfStatusItem p1)
				|        {
				|            Terminal.Gui.StatusItem[] StatusItem2 = new Terminal.Gui.StatusItem[M_Object.Length + 1];
				|            M_Object.CopyTo(StatusItem2, 0);
				|            StatusItem2[M_Object.Length] = p1.Base_obj.M_StatusItem;
				|            M_Object = StatusItem2;
				|            p1.M_StatusBar = M_StatusBar;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Добавить") и (КлассАнгл = "MenuBarItemChildren") Тогда
				Стр = Стр +
				"        [ContextMethod(""Добавить"", ""Add"")]
				|        public void Add(IValue p1 = null)
				|        {
				|            if (p1 == null)
				|            {
				|                Terminal.Gui.MenuItem[] MenuItem2 = new Terminal.Gui.MenuItem[M_Object.Length + 1];
				|                M_Object.CopyTo(MenuItem2, 0);
				|                MenuItem2[M_Object.Length] = null;
				|                M_Object = MenuItem2;
				|            }
				|            else
				|            {
				|                Terminal.Gui.MenuItem[] MenuItem2 = new Terminal.Gui.MenuItem[M_Object.Length + 1];
				|                M_Object.CopyTo(MenuItem2, 0);
				|                MenuItem2[M_Object.Length] = (Terminal.Gui.MenuItem)((dynamic)p1).Base_obj.M_MenuItem;
				|                M_Object = MenuItem2;
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Добавить") Тогда
				Стр = Стр +
				"        [ContextMethod(""Добавить"", ""Add"")]
				|        public void Add(IValue p1)
				|        {
				|            Base_obj.Add(((dynamic)p1).Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ВСтроку") Тогда
				Стр = Стр +
				"        [ContextMethod(""ВСтроку"", ""ToString"")]
				|        public new string ToString()
				|        {
				|            return Base_obj.ToString();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Содержит") и (КлассАнгл = "SubviewCollection") Тогда
				Стр = Стр +
				"        [ContextMethod(""Содержит"", ""Contains"")]
				|        public bool Contains(IValue p1)
				|        {
				|            return Base_obj.M_SubviewCollection.Contains((Terminal.Gui.View)((dynamic)p1).Base_obj.M_View);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Содержит") и (КлассАнгл = "Rect") Тогда
				Стр = Стр +
				"        [ContextMethod(""Содержит"", ""Contains"")]
				|        public IValue Contains(IValue p1, IValue p2 = null)
				|        {
				|            if (p1.GetType() == typeof(TfRect))
				|            {
				|                return ValueFactory.Create(Base_obj.Contains(((TfRect)p1).Base_obj.M_Rect));
				|            }
				|            else if (p1.GetType() == typeof(TfPoint))
				|            {
				|                return ValueFactory.Create(Base_obj.Contains(((TfPoint)p1).Base_obj.M_Point));
				|            }
				|            else if (p1.SystemType.Name == ""Число"" && p2 != null)
				|            {
				|                return ValueFactory.Create(Base_obj.Contains(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber())));
				|            }
				|            else
				|            {
				|                return ValueFactory.CreateNullValue();
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Получить") и (КлассАнгл = "Attribute") Тогда
				Стр = Стр +
				"        [ContextMethod(""Получить"", ""Get"")]
				|        public TfAttribute Get()
				|        {
				|            return new TfAttribute(Base_obj.Get());
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Создать") и (КлассАнгл = "Attribute") Тогда
				Стр = Стр +
				"        [ContextMethod(""Создать"", ""Make"")]
				|        public TfAttribute Make(int p1, int p2)
				|        {
				|            return new TfAttribute(Base_obj.Make(p1, p2));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ВерхнийРодитель") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextMethod(""ВерхнийРодитель"", ""GetTopSuperView"")]
				|        public IValue GetTopSuperView()
				|        {
				|            try
				|            {
				|                return OneScriptTerminalGui.RevertEqualsObj(Base_obj.M_Window.Subviews[0].SuperView.SuperView.SuperView.GetTopSuperView()).dll_obj;
				|            }
				|            catch (Exception)
				|            {
				|                return OneScriptTerminalGui.RevertEqualsObj(Base_obj.M_Window.Subviews[0].SuperView.SuperView.GetTopSuperView()).dll_obj;
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ВерхнийРодитель") Тогда
				Стр = Стр +
				"        [ContextMethod(""ВерхнийРодитель"", ""GetTopSuperView"")]
				|        public IValue GetTopSuperView()
				|        {
				|            return Base_obj.GetTopSuperView().dll_obj;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаШагВперед") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаШагВперед"", ""BringSubviewForward"")]
				|        public void BringSubviewForward(IValue p1)
				|        {
				|            Base_obj.M_Window.Subviews[0].BringSubviewForward(((dynamic)p1).Base_obj.M_View);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаШагВперед") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаШагВперед"", ""BringSubviewForward"")]
				|        public void BringSubviewForward(IValue p1)
				|        {
				|            Base_obj.BringSubviewForward(((dynamic)p1).Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Обновить") Тогда
				Стр = Стр +
				"        [ContextMethod(""Обновить"", ""SetNeedsDisplay"")]
				|        public void SetNeedsDisplay(TfRect p1 = null)
				|        {
				|            Base_obj.SetNeedsDisplay(p1.Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаЗаднийПлан") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаЗаднийПлан"", ""SendSubviewToBack"")]
				|        public void SendSubviewToBack(IValue p1)
				|        {
				|            Base_obj.M_Window.Subviews[0].SendSubviewToBack(((dynamic)p1).Base_obj.M_View);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаЗаднийПлан") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаЗаднийПлан"", ""SendSubviewToBack"")]
				|        public void SendSubviewToBack(IValue p1)
				|        {
				|            Base_obj.SendSubviewToBack(((dynamic)p1).Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаШагНазад") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаШагНазад"", ""SendSubviewBackwards"")]
				|        public void SendSubviewBackwards(IValue p1)
				|        {
				|            Base_obj.M_Window.Subviews[0].SendSubviewBackwards(((dynamic)p1).Base_obj.M_View);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаШагНазад") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаШагНазад"", ""SendSubviewBackwards"")]
				|        public void SendSubviewBackwards(IValue p1)
				|        {
				|            Base_obj.SendSubviewBackwards(((dynamic)p1).Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Очистить") и (КлассАнгл = "MenusCollection") Тогда
				Стр = Стр +
				"        [ContextMethod(""Очистить"", ""Clear"")]
				|        public void Clear()
				|        {
				|            M_Object = new Terminal.Gui.MenuBarItem[0];
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Удалить") и (КлассАнгл = "MenuBarItemChildren") Тогда
				Стр = Стр +
				"        [ContextMethod(""Удалить"", ""Remove"")]
				|        public void Remove(IValue p1)
				|        {
				|            Terminal.Gui.MenuItem[] MenuItem2 = new Terminal.Gui.MenuItem[M_Object.Length - 1];
				|            int index = 0;
				|            for (int i = 0; i < M_Object.Length; i++)
				|            {
				|                Terminal.Gui.MenuItem MenuItem1 = M_Object[i];
				|                if (MenuItem1 != ((dynamic)p1).Base_obj.M_MenuItem)
				|                {
				|                    MenuItem2[index] = MenuItem1;
				|                    index++;
				|                }
				|            }
				|            M_Object = MenuItem2;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Удалить") и (КлассАнгл = "StatusBar") Тогда
				Стр = Стр +
				"        [ContextMethod(""Удалить"", ""Remove"")]
				|        public void Remove(TfStatusItem p1)
				|        {
				|            Items.Remove(p1);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Удалить") и (КлассАнгл = "MenusCollection") Тогда
				Стр = Стр +
				"        [ContextMethod(""Удалить"", ""Remove"")]
				|        public void Remove(TfMenuBarItem p1)
				|        {
				|            Terminal.Gui.MenuBarItem[] MenuBarItem2 = new Terminal.Gui.MenuBarItem[M_Object.Length - 1];
				|            int index = 0;
				|            for (int i = 0; i < M_Object.Length; i++)
				|            {
				|                Terminal.Gui.MenuBarItem MenuBarItem1 = M_Object[i];
				|                if (MenuBarItem1 != p1.Base_obj.M_MenuBarItem)
				|                {
				|                    MenuBarItem2[index] = MenuBarItem1;
				|                    index++;
				|                }
				|            }
				|            M_Object = MenuBarItem2;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Очистить") и (КлассАнгл = "StatusBarItems") Тогда
				Стр = Стр +
				"        [ContextMethod(""Очистить"", ""Clear"")]
				|        public void Clear()
				|        {
				|            M_Object = new Terminal.Gui.StatusItem[0];
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Очистить") и (КлассАнгл = "MenuBarItemChildren") Тогда
				Стр = Стр +
				"        [ContextMethod(""Очистить"", ""Clear"")]
				|        public void Clear()
				|        {
				|            M_Object = new Terminal.Gui.MenuItem[0];
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Перерисовать") Тогда
				Стр = Стр +
				"        [ContextMethod(""Перерисовать"", ""Redraw"")]
				|        public void Redraw(TfRect p1)
				|        {
				|            Base_obj.Redraw(p1.Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПерерисоватьДочерние") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПерерисоватьДочерние"", ""SetChildNeedsDisplay"")]
				|        public void SetChildNeedsDisplay()
				|        {
				|            Base_obj.SetChildNeedsDisplay();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "УстановитьАвтоРазмер") Тогда
				Стр = Стр +
				"        [ContextMethod(""УстановитьАвтоРазмер"", ""SetAutoSize"")]
				|        public void SetAutoSize()
				|        {
				|            TfSize TfSize1 = GetAutoSize();
				|            Width = new TfDim().Sized(TfSize1.Width);
				|            Height = new TfDim().Sized(TfSize1.Height);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПолучитьАвтоРазмер") и (
				КлассАнгл = "Button" 
				или КлассАнгл = "Toplevel") 
				Тогда
				Стр = Стр +
				"        [ContextMethod(""ПолучитьАвтоРазмер"", ""GetAutoSize"")]
				|        public TfSize GetAutoSize()
				|        {
				|            int offsetWidth = 0;
				|            int offsetHeight = 0;
				|            try
				|            {
				|                offsetWidth = Border.BorderThickness.Left + Border.BorderThickness.Right;
				|                offsetHeight = Border.BorderThickness.Top + Border.BorderThickness.Bottom;
				|            }
				|            catch { }
				|            int MaxWidthLine = Terminal.Gui.TextFormatter.MaxWidthLine(Text);
				|            int MaxLines = Terminal.Gui.TextFormatter.MaxLines(Text, MaxWidthLine);
				|            try
				|            {
				|                return new TfSize(MaxWidthLine + offsetWidth, MaxLines + offsetHeight);
				|            }
				|            catch
				|            {
				|                return null;
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПолучитьАвтоРазмер") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПолучитьАвтоРазмер"", ""GetAutoSize"")]
				|        public TfSize GetAutoSize()
				|        {
				|            try
				|            {
				|                return new TfSize(MaxWidthLine(Text) + 2, MaxLines(Text, MaxWidthLine(Text)) + 2);
				|            }
				|            catch
				|            {
				|                return null;
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПолучитьАвтоРазмер") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПолучитьАвтоРазмер"", ""GetAutoSize"")]
				|        public TfSize GetAutoSize()
				|        {
				|            int offsetWidth = 0;
				|            int offsetHeight = 0;
				|            try
				|            {
				|                offsetWidth = Border.BorderThickness.Left + Border.BorderThickness.Right;
				|                offsetHeight = Border.BorderThickness.Top + Border.BorderThickness.Bottom;
				|            }
				|            catch { }
				|            int MaxWidthLine = Terminal.Gui.TextFormatter.MaxWidthLine(Text);
				|            int MaxLines = Terminal.Gui.TextFormatter.MaxLines(Text, MaxWidthLine);
				|            try
				|            {
				|                return new TfSize(MaxWidthLine + 2 + offsetWidth, MaxLines + 2 + offsetHeight);
				|            }
				|            catch
				|            {
				|                return null;
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "РазместитьПодэлементы") Тогда
				Стр = Стр +
				"        [ContextMethod(""РазместитьПодэлементы"", ""LayoutSubviews"")]
				|        public void LayoutSubviews()
				|        {
				|            Base_obj.LayoutSubviews();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ТочкаНаЭлементе") Тогда
				Стр = Стр +
				"        [ContextMethod(""ТочкаНаЭлементе"", ""ScreenToView"")]
				|        public TfPoint ScreenToView(int p1, int p2)
				|        {
				|            return new TfPoint(Base_obj.ScreenToView(p1, p2));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Удалить") и (КлассАнгл = "StatusBarItems") Тогда
				Стр = Стр +
				"        [ContextMethod(""Удалить"", ""Remove"")]
				|        public void Remove(TfStatusItem p1)
				|        {
				|            Terminal.Gui.StatusItem[] StatusItem2 = new Terminal.Gui.StatusItem[M_Object.Length - 1];
				|            int index = 0;
				|            for (int i = 0; i < M_Object.Length; i++)
				|            {
				|                Terminal.Gui.StatusItem StatusItem1 = M_Object[i];
				|                if (StatusItem1 != p1.Base_obj.M_StatusItem)
				|                {
				|                    StatusItem2[index] = StatusItem1;
				|                    index++;
				|                }
				|            }
				|            M_Object = StatusItem2;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Удалить") и (КлассАнгл = "MenuBar") Тогда
				Стр = Стр +
				"        [ContextMethod(""Удалить"", ""Remove"")]
				|        public void Remove(TfMenuBarItem p1)
				|        {
				|            Menus.Remove(p1);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Удалить") Тогда
				Стр = Стр +
				"        [ContextMethod(""Удалить"", ""Remove"")]
				|        public void Remove(IValue p1)
				|        {
				|            Base_obj.Remove(((dynamic)p1).Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "УдалитьВсе") и (КлассАнгл = "StatusBar") Тогда
				Стр = Стр +
				"        [ContextMethod(""УдалитьВсе"", ""RemoveAll"")]
				|        public void RemoveAll()
				|        {
				|            Items.Clear();
				|        }

				|
				|";
			ИначеЕсли (МетодРус = "УдалитьВсе") и (КлассАнгл = "MenuBar") Тогда
				Стр = Стр +
				"        [ContextMethod(""УдалитьВсе"", ""RemoveAll"")]
				|        public void RemoveAll()
				|        {
				|            Menus.Clear();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "УдалитьВсе") Тогда
				Стр = Стр +
				"        [ContextMethod(""УдалитьВсе"", ""RemoveAll"")]
				|        public void RemoveAll()
				|        {
				|            Base_obj.RemoveAll();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "УстановитьФокус") Тогда
				Стр = Стр +
				"        [ContextMethod(""УстановитьФокус"", ""SetFocus"")]
				|        public void SetFocus()
				|        {
				|            Base_obj.SetFocus();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЦветВыделенного") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЦветВыделенного"", ""GetHotNormalColor"")]
				|        public TfAttribute GetHotNormalColor()
				|        {
				|            return new TfAttribute(Base_obj.GetHotNormalColor());
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЦветОбычного") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЦветОбычного"", ""GetNormalColor"")]
				|        public TfAttribute GetNormalColor()
				|        {
				|            return new TfAttribute(Base_obj.GetNormalColor());
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЦветФокуса") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЦветФокуса"", ""GetFocusColor"")]
				|        public TfAttribute GetFocusColor()
				|        {
				|            return new TfAttribute(Base_obj.GetFocusColor());
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Вычесть") и (КлассАнгл = "Point") Тогда
				Стр = Стр +
				"        [ContextMethod(""Вычесть"", ""Subtract"")]
				|        public TfPoint Subtract(TfPoint p1, TfSize p2)
				|        {
				|            return new TfPoint(Base_obj.Subtract(p1.Base_obj, p2.Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Вычесть") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Вычесть"", ""Subtract"")]
				|        public TfPos Subtract(TfPos p1, TfPos p2)
				|        {
				|            return new TfPos(Base_obj.Subtract(p1.Base_obj, p2.Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Вычесть") и (КлассАнгл = "Dim") Тогда
				Стр = Стр +
				"        [ContextMethod(""Вычесть"", ""Subtract"")]
				|        public TfDim Subtract(TfDim p1, TfDim p2)
				|        {
				|            return new TfDim(Base_obj.Subtract(p1.Base_obj, p2.Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Вычесть") Тогда
				Стр = Стр +
				"        [ContextMethod(""Вычесть"", ""Subtract"")]
				|        public TfSize Subtract(TfSize p1, TfSize p2)
				|        {
				|            return new TfSize(Base_obj.Subtract(p1.Base_obj, p2.Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ИзГраниц") Тогда
				Стр = Стр +
				"        [ContextMethod(""ИзГраниц"", ""FromLTRB"")]
				|        public TfRect FromLTRB(int p1, int p2, int p3, int p4)
				|        {
				|            return new TfRect(Base_obj.FromLTRB(p1, p2, p3, p4));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Образовать") Тогда
				Стр = Стр +
				"        [ContextMethod(""Образовать"", ""Inflate"")]
				|        public TfRect Inflate(IValue p1, IValue p2 = null, IValue p3 = null)
				|        {
				|            if (p1.GetType() == typeof(TfSize))
				|            {
				|                Base_obj.Inflate(((TfSize)p1).Base_obj.M_Size);
				|                return this;
				|            }
				|            else if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"")
				|            {
				|                Base_obj.Inflate(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()));
				|                return this;
				|            }
				|            else if (p1.GetType() == typeof(TfRect) && p2.SystemType.Name == ""Число"" && p3.SystemType.Name == ""Число"")
				|            {
				|                return new TfRect(Base_obj.Inflate(((TfRect)p1).Base_obj, Convert.ToInt32(p2.AsNumber()), Convert.ToInt32(p3.AsNumber())));
				|            }
				|            else
				|            {
				|                return null;
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Сместить") Тогда
				Стр = Стр +
				"        [ContextMethod(""Сместить"", ""Offset"")]
				|        public void Offset(int p1, int p2)
				|        {
				|            Base_obj.Offset(p1, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Элемент") и (КлассАнгл = "SubviewCollection") Тогда
				Стр = Стр +
				"        [ContextMethod(""Элемент"", ""Item"")]
				|        public IValue Item(int p1)
				|        {
				|            return OneScriptTerminalGui.RevertEqualsObj(Base_obj.M_SubviewCollection[p1]).dll_obj;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ВычислитьТолщину") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextMethod(""ВычислитьТолщину"", ""GetSumThickness"")]
				|        public TfThickness GetSumThickness()
				|        {
				|            return new TfThickness(Base_obj.GetSumThickness());
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "РисоватьВсеГраницы") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextMethod(""РисоватьВсеГраницы"", ""DrawFullContent"")]
				|        public void DrawFullContent()
				|        {
				|            Base_obj.DrawFullContent();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "РисоватьГраницу") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextMethod(""РисоватьГраницу"", ""DrawContent"")]
				|        public void DrawContent(TfView view = null, bool fill = true)
				|        {
				|            Base_obj.DrawContent(view.Base_obj, fill);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "РисоватьЗаголовок") и (КлассАнгл = "Border") Тогда
				Стр = Стр +
				"        [ContextMethod(""РисоватьЗаголовок"", ""DrawTitle"")]
				|        public void DrawTitle(TfView p1, TfRect p2 = null)
				|        {
				|            if (p2 != null)
				|            {
				|                Base_obj.DrawTitle(p1.Base_obj, p2.Base_obj);
				|            }
				|            else
				|            {
				|                Base_obj.DrawTitle(p1.Base_obj);
				|            }
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Выровнять") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""Выровнять"", ""Justify"")]
				|        public string Justify(string p1, int p2, string p3 = "" "", int p4 = 0)
				|        {
				|            return Base_obj.Justify(p1, p2, p3, (Terminal.Gui.TextDirection)p4);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "МаксимальнаяШирина") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""МаксимальнаяШирина"", ""MaxWidth"")]
				|        public int MaxWidth(string p1, int p2)
				|        {
				|            return Base_obj.MaxWidth(p1, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "МаксимальноСтрок") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""МаксимальноСтрок"", ""MaxLines"")]
				|        public int MaxLines(string p1, int p2)
				|        {
				|            return Base_obj.MaxLines(p1, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПереносСлов") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПереносСлов"", ""WordWrap"")]
				|        public string WordWrap(string p1, int p2, bool p3 = false, int p4 = 0, int p5 = 0)
				|        {
				|            return Base_obj.WordWrap(p1, p2, p3, p4, (Terminal.Gui.TextDirection)p5);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Рисовать") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""Рисовать"", ""Draw"")]
				|        public void Draw(TfRect p1, TfAttribute p2, TfAttribute p3, TfRect p4 = default, bool p5 = true)
				|        {
				|            Base_obj.Draw(p1.Base_obj, p2.Base_obj, p3.Base_obj, p4.Base_obj, p5);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "МаксимальнаяШиринаСтроки") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""МаксимальнаяШиринаСтроки"", ""MaxWidthLine"")]
				|        public int MaxWidthLine(string p1)
				|        {
				|            return Base_obj.MaxWidthLine(p1);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ШиринаТекста") и (КлассАнгл = "TextFormatter") Тогда
				Стр = Стр +
				"        [ContextMethod(""ШиринаТекста"", ""GetTextWidth"")]
				|        public int GetTextWidth(string p1)
				|        {
				|            return Base_obj.GetTextWidth(p1);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПунктМеню") и (КлассАнгл = "MenusCollection") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПунктМеню"", ""MenuBarItem"")]
				|        public TfMenuBarItem MenuBarItem(int p1)
				|        {
				|            return OneScriptTerminalGui.RevertEqualsObj(M_Object[p1]).dll_obj;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Закрыть") и (КлассАнгл = "MenuBar") Тогда
				Стр = Стр +
				"        [ContextMethod(""Закрыть"", ""CloseMenu"")]
				|        public bool CloseMenu()
				|        {
				|            return Base_obj.CloseMenu();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Открыть") и (КлассАнгл = "MenuBar") Тогда
				Стр = Стр +
				"        [ContextMethod(""Открыть"", ""OpenMenu"")]
				|        public void OpenMenu()
				|        {
				|            Base_obj.OpenMenu();
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Абсолютно") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Абсолютно"", ""At"")]
				|        public TfPos At(int p1)
				|        {
				|            return new TfPos(Base_obj.At(p1));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Центр") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Центр"", ""Center"")]
				|        public TfPos Center()
				|        {
				|            return new TfPos(Base_obj.Center());
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЯкорьКонец") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЯкорьКонец"", ""AnchorEnd"")]
				|        public TfPos AnchorEnd(int p1 = 0)
				|        {
				|            return new TfPos(Base_obj.AnchorEnd(p1));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЭлементСтрокиСостояния") и (КлассАнгл = "StatusBarItems") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЭлементСтрокиСостояния"", ""StatusItem"")]
				|        public TfStatusItem StatusItem(int p1)
				|        {
				|            return OneScriptTerminalGui.RevertEqualsObj(M_Object[p1]).dll_obj;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ВставитьПоИндексу") и (КлассАнгл = "StatusBar") Тогда
				Стр = Стр +
				"        [ContextMethod(""ВставитьПоИндексу"", ""AddItemAt"")]
				|        public void AddItemAt(int p1, TfStatusItem p2)
				|        {
				|            Base_obj.AddItemAt(p1, p2.Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЭлементПунктаМеню") и (КлассАнгл = "MenuBarItemChildren") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЭлементПунктаМеню"", ""ItemMenuBarItem"")]
				|        public TfMenuItem ItemMenuBarItem(int p1)
				|        {
				|            return OneScriptTerminalGui.RevertEqualsObj(M_Object[p1]).dll_obj;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Высота") и (КлассАнгл = "Dim") Тогда
				Стр = Стр +
				"        [ContextMethod(""Высота"", ""Height"")]
				|        public TfDim Height(IValue p1)
				|        {
				|            return new TfDim(Base_obj.Height(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Заполнить") и (КлассАнгл = "Dim") Тогда
				Стр = Стр +
				"        [ContextMethod(""Заполнить"", ""Fill"")]
				|        public TfDim Fill(int p1 = 0)
				|        {
				|            return new TfDim(Base_obj.Fill(p1));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Выше") Тогда
				Стр = Стр +
				"        [ContextMethod(""Выше"", ""PlaceTop"")]
				|        public void PlaceTop(IValue p1, int p2)
				|        {
				|            Base_obj.PlaceTop(((dynamic)p1.AsObject()).Base_obj, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Левее") Тогда
				Стр = Стр +
				"        [ContextMethod(""Левее"", ""PlaceLeft"")]
				|        public void PlaceLeft(IValue p1, int p2)
				|        {
				|            Base_obj.PlaceLeft(((dynamic)p1.AsObject()).Base_obj, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Ниже") Тогда
				Если КлассАнгл = "Window" Тогда
					Величина1 = "p2 - 1";
				Иначе
					Величина1 = "p2";
				КонецЕсли;
				Стр = Стр +
				"        [ContextMethod(""Ниже"", ""PlaceBottom"")]
				|        public void PlaceBottom(IValue p1, int p2)
				|        {
				|            Base_obj.PlaceBottom(((dynamic)p1.AsObject()).Base_obj, " + Величина1 + ");
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Правее") Тогда
				Стр = Стр +
				"        [ContextMethod(""Правее"", ""PlaceRight"")]
				|        public void PlaceRight(IValue p1, int p2)
				|        {
				|            Base_obj.PlaceRight(((dynamic)p1.AsObject()).Base_obj, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Абсолютно") и (КлассАнгл = "Dim") Тогда
				Стр = Стр +
				"        [ContextMethod(""Абсолютно"", ""Sized"")]
				|        public TfDim Sized(int p1)
				|        {
				|            return new TfDim(Base_obj.Sized(p1));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Ширина") и (КлассАнгл = "Dim") Тогда
				Стр = Стр +
				"        [ContextMethod(""Ширина"", ""Width"")]
				|        public TfDim Width(IValue p1)
				|        {
				|            return new TfDim(Base_obj.Width(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Сложить") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Сложить"", ""Summation"")]
				|        public TfPos Summation(TfPos p1, TfPos p2)
				|        {
				|            return new TfPos(Base_obj.Summation(p1.Base_obj, p2.Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Верх") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Верх"", ""Top"")]
				|        public TfPos Top(IValue p1)
				|        {
				|            return new TfPos(Base_obj.Top(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Игрек") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Игрек"", ""Y"")]
				|        public TfPos Y(IValue p1)
				|        {
				|            return new TfPos(Base_obj.Y(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Икс") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Икс"", ""X"")]
				|        public TfPos X(IValue p1)
				|        {
				|            return new TfPos(Base_obj.X(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Лево") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Лево"", ""Left"")]
				|        public TfPos Left(IValue p1)
				|        {
				|            return new TfPos(Base_obj.Left(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Низ") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Низ"", ""Bottom"")]
				|        public TfPos Bottom(IValue p1)
				|        {
				|            return new TfPos(Base_obj.Bottom(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Право") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Право"", ""Right"")]
				|        public TfPos Right(IValue p1)
				|        {
				|            return new TfPos(Base_obj.Right(((dynamic)p1).Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Процент") и (КлассАнгл = "Pos") Тогда
				Стр = Стр +
				"        [ContextMethod(""Процент"", ""Percent"")]
				|        public TfPos Percent(IValue p1)
				|        {
				|            return new TfPos(Base_obj.Percent(Convert.ToSingle(p1.AsNumber())));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Процент") и (КлассАнгл = "Dim") Тогда
				Стр = Стр +
				"        [ContextMethod(""Процент"", ""Percent"")]
				|        public TfDim Percent(IValue p1, bool p2 = false)
				|        {
				|            return new TfDim(Base_obj.Percent(Convert.ToSingle(p1.AsNumber()), p2));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Сложить") и (КлассАнгл = "Dim") Тогда
				Стр = Стр +
				"        [ContextMethod(""Сложить"", ""Summation"")]
				|        public TfDim Summation(TfDim p1, TfDim p2)
				|        {
				|            return new TfDim(Base_obj.Summation(p1.Base_obj, p2.Base_obj));
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ВышеЛевее") Тогда
				Стр = Стр +
				"        [ContextMethod(""ВышеЛевее"", ""PlaceTopLeft"")]
				|        public void PlaceTopLeft(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceTopLeft(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ВышеПравее") Тогда
				Стр = Стр +
				"        [ContextMethod(""ВышеПравее"", ""PlaceTopRight"")]
				|        public void PlaceTopRight(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceTopRight(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЛевееВыше") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЛевееВыше"", ""PlaceLeftTop"")]
				|        public void PlaceLeftTop(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceLeftTop(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ЛевееНиже") Тогда
				Стр = Стр +
				"        [ContextMethod(""ЛевееНиже"", ""PlaceLeftBottom"")]
				|        public void PlaceLeftBottom(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceLeftBottom(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НижеЛевее") Тогда
				Стр = Стр +
				"        [ContextMethod(""НижеЛевее"", ""PlaceBottomLeft"")]
				|        public void PlaceBottomLeft(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceBottomLeft(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НижеПравее") Тогда
				Стр = Стр +
				"        [ContextMethod(""НижеПравее"", ""PlaceBottomRight"")]
				|        public void PlaceBottomRight(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceBottomRight(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПравееВыше") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПравееВыше"", ""PlaceRightTop"")]
				|        public void PlaceRightTop(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceRightTop(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПравееНиже") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПравееНиже"", ""PlaceRightBottom"")]
				|        public void PlaceRightBottom(IValue p1, int p2, int p3)
				|        {
				|            Base_obj.PlaceRightBottom(((dynamic)p1.AsObject()).Base_obj, p2, p3);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Индекс") и (КлассАнгл = "SubviewCollection") Тогда
				Стр = Стр +
				"        [ContextMethod(""Индекс"", ""IndexOf"")]
				|        public int IndexOf(IValue p1)
				|        {
				|            int index1 = -1;
				|            for (int i = 0; i < Base_obj.M_SubviewCollection.Count; i++)
				|            {
				|                if (Base_obj.M_SubviewCollection[i] == ((dynamic)p1).Base_obj.M_View)
				|                {
				|                    index1 = i;
				|                    break;
				|                }
				|            }
				|            return index1;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Центр") Тогда
				Стр = Стр +
				"        [ContextMethod(""Центр"", ""Center"")]
				|        public void Center(int p1 = 0, int p2 = 0)
				|        {
				|            Base_obj.Center(p1, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Заполнить") Тогда
				Стр = Стр +
				"        [ContextMethod(""Заполнить"", ""Fill"")]
				|        public void Fill(int p1 = 0, int p2 = 0)
				|        {
				|            Base_obj.Fill(p1, p2);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаПереднийПлан") и (КлассАнгл = "Window") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаПереднийПлан"", ""BringSubviewToFront"")]
				|        public void BringSubviewToFront(IValue p1)
				|        {
				|            Base_obj.M_Window.Subviews[0].BringSubviewToFront(((dynamic)p1).Base_obj.M_View);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "НаПереднийПлан") Тогда
				Стр = Стр +
				"        [ContextMethod(""НаПереднийПлан"", ""BringSubviewToFront"")]
				|        public void BringSubviewToFront(IValue p1)
				|        {
				|            Base_obj.BringSubviewToFront(((dynamic)p1).Base_obj);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Запрос") и (КлассАнгл = "MessageBox") Тогда
				Стр = Стр +
				"        [ContextMethod(""Запрос"", ""Query"")]
				|        public int Query()
				|        {
				|            // Уберем на время появления модального окна события мыши.
				|            dynamic actRootMouseEvent = Application.RootMouseEvent;
				|            Application.RootMouseEvent = null;
				|
				|            int maxLengthButtons = 0;
				|            NStack.ustring[] _buttons = new NStack.ustring[Buttons.Count()];
				|            for (int i = 0; i < Buttons.Count(); i++)
				|            {
				|                string str = Buttons.Get(i).AsString();
				|                maxLengthButtons = maxLengthButtons + str.Length + 8;
				|                _buttons[i] = str;
				|            }
				|
				|            TfTextFormatter TfTextFormatter1 = new TfTextFormatter();
				|            TfTextFormatter1.Text = Message;
				|            TfSize TfSize1 = TfTextFormatter1.GetAutoSize();
				|            int _height = TfSize1.Height + 1;
				|            int _widthMessage = TfSize1.Width;
				|            int _widthTitle = Title.Length + 5;
				|            int _widthTerminal = Application.Driver.Cols - 8;
				|            int _width = Math.Max(_widthMessage, Math.Max(_widthTitle, maxLengthButtons));
				|            if (_width >= _widthTerminal)
				|            {
				|                _width = _widthTerminal;
				|            }
				|            int _heightTerminal = Application.Driver.Rows - 8;
				|            if (_height >= _heightTerminal)
				|            {
				|                _height = _heightTerminal;
				|            }
				|            if (!AutoSize)
				|            {
				|                _width = Width;
				|                _height = Height;
				|            }
				|
				|            Clicked = Terminal.Gui.MessageBox.Query(_width, _height, Title, Message, DefaultButtonIndex, _buttons);
				|            Application.MainLoop.RemoveTimeout(token);
				|            // Вернем события мыши.
				|            Application.RootMouseEvent = actRootMouseEvent;
				|            return Clicked;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Начать") и (КлассАнгл = "Timer") Тогда
				Стр = Стр +
				"        [ContextMethod(""Начать"", ""Start"")]
				|        public void Start()
				|        {
				|            stop = false;
				|            token = Application.MainLoop.AddTimeout(TimeSpan.FromMilliseconds(Interval), (m) =>
				|            {
				|                if (Tick != null)
				|                {
				|                    TfEventArgs TfEventArgs1 = new TfEventArgs();
				|                    TfEventArgs1.sender = this;
				|                    TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Tick);
				|                    OneScriptTerminalGui.Event = TfEventArgs1;
				|                    OneScriptTerminalGui.ExecuteEvent(Tick);
				|                }
				|                if (stop)
				|                {
				|                    return false;
				|                }
				|                return true;
				|            });
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "Остановить") и (КлассАнгл = "Timer") Тогда
				Стр = Стр +
				"        [ContextMethod(""Остановить"", ""Stop"")]
				|        public void Stop()
				|        {
				|            stop = true;
				|            // token для остановки не срабатывает, поэтому добавлено поле stop.
				|            Application.MainLoop.RemoveTimeout(token);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ДобавитьСочетаниеКлавиш") Тогда
				Стр = Стр +
				"        [ContextMethod(""ДобавитьСочетаниеКлавиш"", ""AddShortcut"")]
				|        public void AddShortcut(decimal p1)
				|        {
				|            OneScriptTerminalGui.AddToShortcutDictionary(p1, this);
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "ПолучитьСочетаниеКлавиш") Тогда
				Стр = Стр +
				"        [ContextMethod(""ПолучитьСочетаниеКлавиш"", ""GetShortcut"")]
				|        public ValueListImpl GetShortcut()
				|        {
				|            ValueListImpl ValueListImpl1 = new ValueListImpl();
				|            ArrayList ArrayList1 = OneScriptTerminalGui.GetFromShortcutDictionary(this);
				|            for (int i = 0; i < ArrayList1.Count; i++)
				|            {
				|                decimal shortcut = (decimal)ArrayList1[i];
				|                ValueListImpl1.Add(ValueFactory.Create(shortcut), OneScriptTerminalGui.instance.Keys.ToStringRu(shortcut));
				|            }
				|            if (ValueListImpl1.Count() > 0)
				|            {
				|                return ValueListImpl1;
				|            }
				|            return null;
				|        }
				|
				|";
			ИначеЕсли (МетодРус = "УдалитьСочетаниеКлавиш") Тогда
				Стр = Стр +
				"        [ContextMethod(""УдалитьСочетаниеКлавиш"", ""RemoveShortcut"")]
				|        public void RemoveShortcut(decimal p1)
				|        {
				|            OneScriptTerminalGui.RemoveFromShortcutDictionary(p1, this);
				|        }
				|
				|";
				
				

				
				
				
				
				
				
				
				
				
				
				
				
				
				
			ИначеЕсли (МетодРус = "йййййййй") и (КлассАнгл = "йййййййй") Тогда
				Стр = Стр +
				"        [ContextMethod(""Закрыть"", ""Close"")]


				|
				|";
				
				
			
			
			
			Иначе
				Стр = Стр +
				"        [ContextMethod(""" + МетодРус + """, """ + МетодАнгл + """)]
				|        public ййййй " + МетодАнгл + "()
				|        {
				|            return Base_obj." + МетодАнгл + "();
				|        }
				|
				|";
			КонецЕсли;
		КонецЦикла;
	Иначе
		Стр = "" + Символы.ПС;
	КонецЕсли;
	
	Возврат Стр;
КонецФункции//Методы

Функция Подвал()
	Стр = 
	"    }
	|}";
	Возврат Стр;
КонецФункции

Процедура ВыгрузкаTUI()
	Таймер = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	УдалитьФайлы(КаталогВыгрузки, "*.cs");
	
	// Создадим файлы cs которые не нуждаются в сборке и неизменны. Остальные будем собирать анализируя справку.
	СоздатьФайлТФ("OneScriptTerminalGui");
	СоздатьФайлТФ("Action");
	СоздатьФайлТФ("Responder");
	
	// Соберем и запишем файлы перечислений.
	ЗаписатьПеречисления();

	//===== Обработаем классы ==========================================================================================================================
	ВыбранныеФайлы = ОтобратьФайлы("Класс");
	Для А = 0 По ВыбранныеФайлы.ВГраница() Цикл
		// Пропустим неизменные классы.
		Пропустим = Ложь;
		Для А2 = 0 По СписокНеизменныхКлассов.Количество() - 1 Цикл
			Если ВыбранныеФайлы[А] = КаталогСправки + "\OSTGui." + СписокНеизменныхКлассов.Получить(А2).Значение + ".html" Тогда
				Пропустим = Истина;
				// Сообщить("Пропустим = Истина " + СписокНеизменныхКлассов.Получить(А2).Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если Пропустим Тогда
			Продолжить;
		КонецЕсли;
		
		ТекстДок = Новый ТекстовыйДокумент;
		ТекстДок.Прочитать(ВыбранныеФайлы[А]);
		Стр = ТекстДок.ПолучитьТекст();
		
		// Сообщить("" + Стр);
		// Сообщить("=====================================================================================================");
		
		СтрЗаголовка = СтрНайтиМежду(Стр, "<H1 class=dtH1", "/H1>", , )[0];
		М01 = СтрНайтиМежду(СтрЗаголовка, "(", ")", , );
		Стр33 = СтрЗаголовка;
		Стр33 = СтрЗаменить(Стр33, "&nbsp;", " ");
		Стр33 = СтрЗаменить(Стр33, ">", "");
		М08 = РазобратьСтроку(Стр33, " ");
		ИмяФайлаВыгрузки = КаталогВыгрузки + "\" + М01[0] + ".cs";
		КлассАнгл = М01[0];
		КлассРус = М08[0];
		
		// Сообщить("ИмяФайлаВыгрузки = " + ИмяФайлаВыгрузки);
		// Сообщить("КлассАнгл = " + КлассАнгл);
		// Сообщить("КлассРус = " + КлассРус);
		
		// определим имя файлов событий, свойств, методов.
		ФайлСобытий = КаталогСправки + "\OSTGui." + КлассАнгл + "Events.html";
		ФайлСвойств = КаталогСправки + "\OSTGui." + КлассАнгл + "Properties.html";
		ФайлМетодов = КаталогСправки + "\OSTGui." + КлассАнгл + "Methods.html";
		СтрДирективы = Директивы(КлассАнгл);
		СтрШапка = Шапка(КлассАнгл, КлассРус);
		СтрРазделОбъявленияПеременных = РазделОбъявленияПеременных(КлассАнгл, КлассРус);
		СтрКонструктор = Конструктор(КлассАнгл, КлассРус);
		СтрСвойства = Свойства(ФайлСвойств, КлассАнгл, КлассРус);
		СтрСобытия = События(ФайлСобытий, КлассАнгл, КлассРус);
		СтрМетоды = Методы(ФайлМетодов, КлассАнгл);
		СтрПодвал = Подвал();
		
		// СортироватьСтрРазделОбъявленияПеременных();
		СтрВыгрузки = "";
		СтрВыгрузки = СтрВыгрузки + СтрДирективы + Символы.ПС;
		СтрВыгрузки = СтрВыгрузки + КлассВторогоУровня(КлассАнгл);
		СтрВыгрузки = СтрВыгрузки + СтрШапка + Символы.ПС;
		СтрВыгрузки = СтрВыгрузки + СтрРазделОбъявленияПеременных + Символы.ПС;
		СтрВыгрузки = СтрВыгрузки + СтрКонструктор + Символы.ПС;
		СтрВыгрузки = СтрВыгрузки + СтрСвойства;
		СтрВыгрузки = СтрВыгрузки + СтрСобытия;
		СтрВыгрузки = СтрВыгрузки + СтрМетоды;
		СтрВыгрузки = СтрВыгрузки + СтрПодвал + Символы.ПС;
		
		ЗаписьТекста = Новый ЗаписьТекста();
		ЗаписьТекста.Открыть(ИмяФайлаВыгрузки,,,);
		ЗаписьТекста.Записать(СтрВыгрузки);
		ЗаписьТекста.Закрыть();

		
	КонецЦикла;
	//===== Закончили с классами ==========================================================================================================================
	// ЗавершитьРаботу(0);
	
	Сообщить("Выполнено за: " + ((ТекущаяУниверсальнаяДатаВМиллисекундах()-Таймер)/1000)/60 + " мин." + " " + ТекущаяДата());
КонецПроцедуры//ВыгрузкаTUI

Процедура ЗаписатьПеречисления()
	ВыбранныеФайлы = ОтобратьФайлы("Перечисление");
	Для А = 0 По ВыбранныеФайлы.ВГраница() Цикл
		Если ВыбранныеФайлы[А] = КаталогСправки + "\йййййййййййййй.ColorEnumeration.html" Тогда
			Продолжить;
		КонецЕсли;
		
		ТекстДок = Новый ТекстовыйДокумент;
		ТекстДок.Прочитать(ВыбранныеФайлы[А]);
		Стр = ТекстДок.ПолучитьТекст();
		
		// Сообщить("" + Стр);
		// Сообщить("=====================================================================================================");
		
		СтрЗаголовка= СтрНайтиМежду(Стр, "<H1 class=dtH1", "/H1>", , )[0];
		М01 = СтрНайтиМежду(СтрЗаголовка, "(", ")", , );
		СтрЗаголовка = СтрЗаменить(СтрЗаголовка, "&nbsp;", " ");
		Стр33 = СтрНайтиМежду(СтрЗаголовка, ">", " Перечисление<", , )[0];
		Стр33 = СтрЗаменить(Стр33, "&nbsp;", " ");
		Стр33 = СтрЗаменить(Стр33, ">", "");
		М08 = РазобратьСтроку(Стр33, " ");
		ИмяФайлаВыгрузки = КаталогВыгрузки + "\" + М01[0] + ".cs";
		КлассАнгл = М01[0];
		КлассРус = М08[0];
		// Сообщить("====" + КлассРус);
		// Сообщить("====" + КлассАнгл);
		// Сообщить("=====================================================================================================");
		
		//находим текст таблицы
		СтрТаблица = СтрНайтиМежду(Стр, "<TBODY>", "</TABLE>", Ложь, );
		СтрТаблицыПеречисления = СтрНайтиМежду(СтрТаблица[1], "<TR vAlign=top>", "</TR>", Ложь, );
		СтрРазделОбъявленияПеременныхДляПеречисления = "";
		СтрСвойстваДляПеречисления = "";
		
		СтрРазделОбъявленияПеременныхДляПеречисления = 
        "
		|        private List<IValue> _list;
		|
		|        public int Count()
		|        {
		|            return _list.Count;
		|        }
		|
		|        public CollectionEnumerator GetManagedIterator()
		|        {
		|            return new CollectionEnumerator(this);
		|        }
		|
		|        IEnumerator IEnumerable.GetEnumerator()
		|        {
		|            return ((IEnumerable<IValue>)_list).GetEnumerator();
		|        }
		|
		|        IEnumerator<IValue> IEnumerable<IValue>.GetEnumerator()
		|        {
		|            foreach (var item in _list)
		|            {
		|                yield return (item as IValue);
		|            }
		|        }
		|";
		
		СтрКонструктораДляПеречисления = 
		"        public Tf" + КлассАнгл + "()
		|        {
		|            _list = new List<IValue>();";
		
		СтрМетодаВСтрокуДляПеречисленияНачало = "
		|        [ContextMethod(""ВСтроку"", ""ВСтроку"")]
		|        public string ToStringRu(decimal p1)
		|        {
		|            string str = p1.ToString();
		|            switch (p1)
		|            {";
		
		СтрМетодаВСтрокуДляПеречисленияКонец = 
		"            }
		|            return str;
		|        }";
		
		СтрМетодаToStringДляПеречисленияНачало = "
		|        [ContextMethod(""ToString"", ""ToString"")]
		|        public string ToStringEn(decimal p1)
		|        {
		|            string str = p1.ToString();
		|            switch (p1)
		|            {";
		
		СтрМетодаToStringДляПеречисленияКонец = 
		"            }
		|            return str;
		|        }";
		
		Для А02 = 1 По СтрТаблицыПеречисления.ВГраница() Цикл
			М12 = СтрНайтиМежду(СтрТаблицыПеречисления[А02], "<TD>", "</TD>", , );
			М14 = СтрНайтиМежду(М12[0], "<B>", "</B>", , );
			М13 = РазобратьСтроку(СтрЗаменить(М14[0], "&nbsp;", " "), " ");
			ИмяПеречАнгл = М01[0];
			ИмяПеречРус = М08[0];
			ИмяЧленаАнгл = М13[1];
			// Сообщить("==" + ИмяЧленаАнгл);
			// если здесь ошибка, тогда возможно есть лишний пробел в одном из значений перечисления
			ИмяЧленаАнгл = СтрНайтиМежду(ИмяЧленаАнгл, "(", ")", , )[0];
			ИмяЧленаРус = М13[0];
			ОписаниеЧлена = М12[1];
			Пока СтрЧислоВхождений(ОписаниеЧлена, Символы.ПС) > 0 Цикл
				ОписаниеЧлена = СтрЗаменить(ОписаниеЧлена, Символы.ПС, " ");
			КонецЦикла;
			Пока СтрЧислоВхождений(ОписаниеЧлена, Символы.Таб) > 0 Цикл
				ОписаниеЧлена = СтрЗаменить(ОписаниеЧлена, Символы.Таб, " ");
			КонецЦикла;
			Пока СтрЧислоВхождений(ОписаниеЧлена, "  ") > 0 Цикл
				ОписаниеЧлена = СтрЗаменить(ОписаниеЧлена, "  ", " ");
			КонецЦикла;
			ЗначениеЧлена = М12[2];
			// Сообщить("--------------");
			// Сообщить("ИмяПеречРус = " + ИмяПеречРус);
			// Сообщить("ИмяПеречАнгл = " + ИмяПеречАнгл);
			// Сообщить("ИмяЧленаРус = " + ИмяЧленаРус);
			// Сообщить("ИмяЧленаАнгл = " + ИмяЧленаАнгл);
			// Сообщить("ОписаниеЧлена = " + ОписаниеЧлена);
			// Сообщить("ЗначениеЧлена = " + ЗначениеЧлена);
			
			СтрСвойстваДляПеречисления = СтрСвойстваДляПеречисления + Символы.ПС + 
			"        [ContextProperty(""" + ИмяЧленаРус + """, """ + ИмяЧленаАнгл + """)]
			|        public int " + ИмяЧленаАнгл + "
			|        {
			|            get { return " + ЗначениеЧлена + "; }
			|        }" + ?(А02 = СтрТаблицыПеречисления.ВГраница(), "", Символы.ПС);
			
			СтрКонструктораДляПеречисления = СтрКонструктораДляПеречисления + "
			|            _list.Add(ValueFactory.Create(" + ИмяЧленаАнгл + "));";
			
			СтрМетодаВСтрокуДляПеречисленияНачало = СтрМетодаВСтрокуДляПеречисленияНачало + "
			|                case " + ЗначениеЧлена + ":
			|                    str = """ + ИмяЧленаРус + """;
			|                    break;";
			
			СтрМетодаToStringДляПеречисленияНачало = СтрМетодаToStringДляПеречисленияНачало + "
			|                case " + ЗначениеЧлена + ":
			|                    str = """ + ИмяЧленаАнгл + """;
			|                    break;";
			
		КонецЦикла;
		
		СтрКонструктораДляПеречисления = СтрКонструктораДляПеречисления + "
		|        }";
		
		СтрВыгрузкиПеречисленийШапка = Директивы(КлассАнгл);
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречисленийШапка + 
		"
		|namespace ostgui
		|{
		|    [ContextClass(""Тф" + КлассРус + """, ""Tf" + КлассАнгл + """)]
		|    public class Tf" + КлассАнгл + " : AutoContext<Tf" + КлассАнгл + ">, ICollectionContext, IEnumerable<IValue>
		|    {";
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + СтрРазделОбъявленияПеременныхДляПеречисления + Символы.ПС;
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + СтрКонструктораДляПеречисления + Символы.ПС;
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + СтрСвойстваДляПеречисления + Символы.ПС;
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + СтрМетодаВСтрокуДляПеречисленияНачало + Символы.ПС;
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + СтрМетодаВСтрокуДляПеречисленияКонец + Символы.ПС;
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + СтрМетодаToStringДляПеречисленияНачало + Символы.ПС;
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + СтрМетодаToStringДляПеречисленияКонец + Символы.ПС;
		СтрВыгрузкиПеречислений = СтрВыгрузкиПеречислений + 
		"    }" + Символы.ПС + 
		"}";
		
		ПодстрокаПоиска = "public int SpecialMask";
		ПодстрокаЗамены = "public decimal SpecialMask";
		СтрВыгрузкиПеречислений = СтрЗаменить(СтрВыгрузкиПеречислений, ПодстрокаПоиска, ПодстрокаЗамены);
		
		ПодстрокаПоиска = "public int AltMask";
		ПодстрокаЗамены = "public decimal AltMask";
		СтрВыгрузкиПеречислений = СтрЗаменить(СтрВыгрузкиПеречислений, ПодстрокаПоиска, ПодстрокаЗамены);
		
		ТекстДокПеречислений = Новый ТекстовыйДокумент;
		ТекстДокПеречислений.УстановитьТекст(СтрВыгрузкиПеречислений);
		ТекстДокПеречислений.Записать(ИмяФайлаВыгрузки);
	КонецЦикла;
КонецПроцедуры//ЗаписатьПеречисления

Функция КлассВторогоУровня(ИмяФайлаТФ)
	Стр = "";
	Если Ложь Тогда
	// ИначеЕсли ИмяФайлаТФ = "" Тогда
		// Стр = Стр + 
		// "namespace ostgui
		// |{
		

		// |";
		
		
		
		
	ИначеЕсли ИмяФайлаТФ = "Timer" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|";
	ИначеЕсли ИмяФайлаТФ = "MessageBox" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|";
	ИначеЕсли ИмяФайлаТФ = "Dim" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Dim
		|    {
		|        public TfDim dll_obj;
		|        public Terminal.Gui.Dim M_Dim;
		|
		|        public Dim()
		|        {
		|            M_Dim = new Terminal.Gui.Dim();
		|            OneScriptTerminalGui.AddToHashtable(M_Dim, this);
		|        }
		|
		|        public Dim(Terminal.Gui.Dim p1)
		|        {
		|            M_Dim = p1;
		|            OneScriptTerminalGui.AddToHashtable(M_Dim, this);
		|        }
		|
		|        public Dim Percent(float p1, bool p2 = false)
		|        {
		|            return new Dim(Terminal.Gui.Dim.Percent(p1, p2));
		|        }
		|
		|        public Dim Height(View p1)
		|        {
		|            return new Dim(Terminal.Gui.Dim.Height(p1.M_View));
		|        }
		|
		|        public Dim Fill(int p1 = 0)
		|        {
		|            return new Dim(Terminal.Gui.Dim.Fill(p1));
		|        }
		|
		|        public Dim Sized(int p1)
		|        {
		|            return new Dim(Terminal.Gui.Dim.Sized(p1));
		|        }
		|
		|        public Dim Width(View p1)
		|        {
		|            return new Dim(Terminal.Gui.Dim.Width(p1.M_View));
		|        }
		|
		|        public Dim Summation(Dim p1, Dim p2)
		|        {
		|            return new Dim(p1.M_Dim + p2.M_Dim);
		|        }
		|
		|        public Dim Subtract(Dim p1, Dim p2)
		|        {
		|            return new Dim(p1.M_Dim - p2.M_Dim);
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Colors" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Colors
		|    {
		|        public TfColors dll_obj;
		|        public Terminal.Gui.ColorScheme M_Colors;
		|
		|        public Colors()
		|        {
		|            M_Colors = new Terminal.Gui.ColorScheme();
		|        }
		|
		|        public ColorScheme TopLevel
		|        {
		|            get { return new ColorScheme(Terminal.Gui.Colors.TopLevel); }
		|            set { M_Colors = value.M_ColorScheme; }
		|        }
		|
		|        public ColorScheme Dialog
		|        {
		|            get { return new ColorScheme(Terminal.Gui.Colors.Dialog); }
		|            set { M_Colors = value.M_ColorScheme; }
		|        }
		|
		|        public ColorScheme Menu
		|        {
		|            get { return new ColorScheme(Terminal.Gui.Colors.Menu); }
		|            set { M_Colors = value.M_ColorScheme; }
		|        }
		|
		|        public ColorScheme Base
		|        {
		|            get { return new ColorScheme(Terminal.Gui.Colors.Base); }
		|            set { M_Colors = value.M_ColorScheme; }
		|        }
		|
		|        public ColorScheme Error
		|        {
		|            get { return new ColorScheme(Terminal.Gui.Colors.Error); }
		|            set { M_Colors = value.M_ColorScheme; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Colors.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "MenuBarItemChildren" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|";
	ИначеЕсли ИмяФайлаТФ = "MenuItem" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class MenuItem
		|    {
		|        public TfMenuItem dll_obj;
		|        public Terminal.Gui.MenuItem m_MenuItem;
		|        public System.Action Clicked;
		|
		|        public MenuItem()
		|        {
		|            Clicked = delegate ()
		|            {
		|                if (dll_obj.Clicked != null)
		|                {
		|                    TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                    TfEventArgs1.sender = dll_obj;
		|                    TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Clicked);
		|                    OneScriptTerminalGui.Event = TfEventArgs1;
		|                    OneScriptTerminalGui.ExecuteEvent(dll_obj.Clicked);
		|                }
		|            };
		|
		|            M_MenuItem = new Terminal.Gui.MenuItem();
		|            M_MenuItem.Action = Clicked;
		|            OneScriptTerminalGui.AddToHashtable(M_MenuItem, this);
		|        }
		|
		|        public Terminal.Gui.MenuItem M_MenuItem
		|        {
		|            get { return m_MenuItem; }
		|            set { m_MenuItem = value; }
		|        }
		|
		|        public IValue Tag
		|        {
		|            get { return M_MenuItem.Tag; }
		|            set { M_MenuItem.Tag = value; }
		|        }
		|
		|        public object Data
		|        {
		|            get { return M_MenuItem.Data; }
		|            set { M_MenuItem.Data = value; }
		|        }
		|
		|        public string Title
		|        {
		|            get { return M_MenuItem.Title.ToString(); }
		|            set { M_MenuItem.Title = value; }
		|        }
		|
		|        public string HotKey
		|        {
		|            get { return M_MenuItem.HotKey.ToString(); }
		|            set { M_MenuItem.HotKey = value.ToCharArray()[0]; }
		|        }
		|
		|        public string Help
		|        {
		|            get { return M_MenuItem.Help.ToString(); }
		|            set { M_MenuItem.Help = value; }
		|        }
		|
		|        public bool Checked
		|        {
		|            get { return M_MenuItem.Checked; }
		|            set { M_MenuItem.Checked = value; }
		|        }
		|
		|        public int Shortcut
		|        {
		|            get { return (int)M_MenuItem.Shortcut; }
		|            set { M_MenuItem.Shortcut = (Terminal.Gui.Key)value; }
		|        }
		|
		|        public IValue Parent
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_MenuItem.Parent).dll_obj; }
		|        }
		|
		|        public string ShortcutTag
		|        {
		|            get { return M_MenuItem.ShortcutTag.ToString(); }
		|        }
		|
		|        public int CheckType
		|        {
		|            get { return (int)M_MenuItem.CheckType; }
		|            set { M_MenuItem.CheckType = (Terminal.Gui.MenuItemCheckStyle)value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_MenuItem.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "StatusBarItems" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|";
	ИначеЕсли ИмяФайлаТФ = "StatusItem" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class StatusItem
		|    {
		|        public TfStatusItem dll_obj;
		|        public Terminal.Gui.StatusItem M_StatusItem;
		|        Action Clicked;
		|
		|        public StatusItem(Terminal.Gui.Key p1, string p2)
		|        {
		|            Clicked = delegate ()
		|            {
		|                if (dll_obj.Clicked != null)
		|                {
		|                    TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                    TfEventArgs1.sender = dll_obj;
		|                    TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Clicked);
		|                    OneScriptTerminalGui.Event = TfEventArgs1;
		|                    OneScriptTerminalGui.ExecuteEvent(dll_obj.Clicked);
		|                }
		|            };
		|
		|            M_StatusItem = new Terminal.Gui.StatusItem(p1, p2, Clicked);
		|            OneScriptTerminalGui.AddToHashtable(M_StatusItem, this);
		|        }
		|
		|        public IValue Tag
		|        {
		|            get { return M_StatusItem.Tag; }
		|            set { M_StatusItem.Tag = value; }
		|        }
		|
		|        public string HotTextSpecifier
		|        {
		|            get { return M_StatusItem.HotTextSpecifier.ToString(); }
		|            set { M_StatusItem.HotTextSpecifier = value.ToCharArray()[0]; }
		|        }
		|
		|        public string Title
		|        {
		|            get { return M_StatusItem.Title.ToString(); }
		|            set { M_StatusItem.Title = value; }
		|        }
		|
		|        public object Data
		|        {
		|            get { return M_StatusItem.Data; }
		|            set { M_StatusItem.Data = value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_StatusItem.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Pos" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Pos
		|    {
		|        public TfPos dll_obj;
		|        public Terminal.Gui.Pos M_Pos;
		|
		|        public Pos()
		|        {
		|            M_Pos = new Terminal.Gui.Pos();
		|            OneScriptTerminalGui.AddToHashtable(M_Pos, this);
		|        }
		|
		|        public Pos(Terminal.Gui.Pos p1)
		|        {
		|            M_Pos = p1;
		|            OneScriptTerminalGui.AddToHashtable(M_Pos, this);
		|        }
		|
		|        public Pos At(int p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.At(p1));
		|        }
		|
		|        public Pos Top(ostgui.View p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.Top(p1.M_View));
		|        }
		|
		|        public Pos Y(ostgui.View p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.Y(p1.M_View));
		|        }
		|
		|        public Pos X(ostgui.View p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.X(p1.M_View));
		|        }
		|
		|        public Pos Left(ostgui.View p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.Left(p1.M_View));
		|        }
		|
		|        public Pos Bottom(ostgui.View p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.Bottom(p1.M_View));
		|        }
		|
		|        public Pos Right(ostgui.View p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.Right(p1.M_View));
		|        }
		|
		|        public Pos Percent(float p1)
		|        {
		|            return new Pos(Terminal.Gui.Pos.Percent(p1));
		|        }
		|
		|        public Pos Center()
		|        {
		|            return new Pos(Terminal.Gui.Pos.Center());
		|        }
		|
		|        public Pos AnchorEnd(int p1 = 0)
		|        {
		|            return new Pos(Terminal.Gui.Pos.AnchorEnd(p1));
		|        }
		|
		|        public Pos Summation(Pos p1, Pos p2)
		|        {
		|            return new Pos(p1.M_Pos + p2.M_Pos);
		|        }
		|
		|        public Pos Subtract(Pos p1, Pos p2)
		|        {
		|            return new Pos(p1.M_Pos - p2.M_Pos);
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "MenuBarItem" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class MenuBarItem : ostgui.MenuItem
		|    {
		|        public new TfMenuBarItem dll_obj;
		|        public Terminal.Gui.MenuBarItem M_MenuBarItem;
		|        public new System.Action Clicked;
		|
		|        public MenuBarItem()
		|        {
		|            Clicked = delegate ()
		|            {
		|                if (dll_obj.Clicked != null)
		|                {
		|                    TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                    TfEventArgs1.sender = dll_obj;
		|                    TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Clicked);
		|                    OneScriptTerminalGui.Event = TfEventArgs1;
		|                    OneScriptTerminalGui.ExecuteEvent(dll_obj.Clicked);
		|                }
		|            };
		|
		|            M_MenuBarItem = new Terminal.Gui.MenuBarItem();
		|            base.M_MenuItem = M_MenuBarItem;
		|            M_MenuBarItem.Action = Clicked;
		|            OneScriptTerminalGui.AddToHashtable(M_MenuBarItem, this);
		|        }
		|
		|        public Terminal.Gui.MenuItem[] Children
		|        {
		|            get { return M_MenuBarItem.Children; }
		|            set { M_MenuBarItem.Children = value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_MenuBarItem.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "MenusCollection" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{";
	ИначеЕсли ИмяФайлаТФ = "Thickness" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Thickness
		|    {
		|        public TfThickness dll_obj;
		|        public Terminal.Gui.Thickness M_Thickness;
		|
		|        public Thickness(int p1)
		|        {
		|            M_Thickness = new Terminal.Gui.Thickness(p1);
		|        }
		|
		|        public Thickness(int left, int top, int right, int bottom)
		|        {
		|            M_Thickness = new Terminal.Gui.Thickness(left, top, right, bottom);
		|        }
		|
		|        public int Top
		|        {
		|            get { return M_Thickness.Top; }
		|            set { M_Thickness.Top = value; }
		|        }
		|
		|        public int Left
		|        {
		|            get { return M_Thickness.Left; }
		|            set { M_Thickness.Left = value; }
		|        }
		|
		|        public int Bottom
		|        {
		|            get { return M_Thickness.Bottom; }
		|            set { M_Thickness.Bottom = value; }
		|        }
		|
		|        public int Right
		|        {
		|            get { return M_Thickness.Right; }
		|            set { M_Thickness.Right = value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Thickness.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "StatusBar" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class StatusBar : View
		|    {
		|        public new TfStatusBar dll_obj;
		|        public Terminal.Gui.StatusBar M_StatusBar;
		|
		|        public StatusBar()
		|        {
		|            M_StatusBar = new Terminal.Gui.StatusBar();
		|            base.M_View = M_StatusBar;
		|            OneScriptTerminalGui.AddToHashtable(M_StatusBar, this);
		|        }
		|
		|        public string ShortcutDelimiter
		|        {
		|            get { return Terminal.Gui.StatusBar.ShortcutDelimiter.ToString(); }
		|            set { Terminal.Gui.StatusBar.ShortcutDelimiter = value; }
		|        }
		|
		|        public void AddItemAt(int p1, StatusItem p2)
		|        {
		|            M_StatusBar.AddItemAt(p1, p2.M_StatusItem);
		|        }
		|
		|        public Terminal.Gui.StatusItem[] Items
		|        {
		|            get { return M_StatusBar.Items; }
		|            set { M_StatusBar.Items = value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_StatusBar.ToString();
		|        }
		|
		|        public new Toplevel GetTopSuperView()
		|        {
		|            return OneScriptTerminalGui.RevertEqualsObj(M_StatusBar.GetTopSuperView());
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "MenuBar" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class MenuBar : View
		|    {
		|        public new TfMenuBar dll_obj;
		|        public Terminal.Gui.MenuBar M_MenuBar;
		|
		|        public MenuBar()
		|        {
		|            M_MenuBar = new Terminal.Gui.MenuBar();
		|            base.M_View = M_MenuBar;
		|            OneScriptTerminalGui.AddToHashtable(M_MenuBar, this);
		|
		|            M_MenuBar.MenuAllClosed += M_MenuBar_MenuAllClosed;
		|            M_MenuBar.MenuOpened += M_MenuBar_MenuOpened;
		|            M_MenuBar.MenuOpening += M_MenuBar_MenuOpening;
		|            M_MenuBar.MouseLeave += M_MenuBar_MouseLeave;
		|        }
		|
		|        private void M_MenuBar_MouseLeave(Terminal.Gui.View.MouseEventArgs obj)
		|        {
		|            if (dll_obj.MouseLeave != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.MouseLeave);
		|                TfEventArgs1.flags = ValueFactory.Create((int)obj.MouseEvent.Flags);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(M_MenuBar).dll_obj;
		|                TfEventArgs1.x = ValueFactory.Create(obj.MouseEvent.X);
		|                TfEventArgs1.y = ValueFactory.Create(obj.MouseEvent.Y);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.MouseLeave);
		|            }
		|        }
		|
		|        private void M_MenuBar_MenuOpening(Terminal.Gui.MenuOpeningEventArgs obj)
		|        {
		|            if (dll_obj.MenuOpening != null)
		|            {
		|                obj.NewMenuBarItem = obj.CurrentMenu;
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.MenuOpening);
		|                TfEventArgs1.cancel = ValueFactory.Create(false);
		|                TfEventArgs1.cancel = ValueFactory.Create(obj.Cancel);
		|                TfEventArgs1.currentMenu = OneScriptTerminalGui.RevertEqualsObj(obj.CurrentMenu).dll_obj;
		|                TfEventArgs1.newMenuBarItem = OneScriptTerminalGui.RevertEqualsObj(obj.NewMenuBarItem).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.MenuOpening);
		|
		|                if (TfEventArgs1.Cancel)
		|                {
		|                    M_MenuBar.MenuOpening -= M_MenuBar_MenuOpening;
		|                    obj.NewMenuBarItem = ((TfMenuBarItem)TfEventArgs1.NewMenuBarItem).Base_obj.M_MenuBarItem;
		|                    M_MenuBar.MenuOpening += M_MenuBar_MenuOpening;
		|                }
		|            }
		|        }
		|
		|        private void M_MenuBar_MenuOpened(Terminal.Gui.MenuItem obj)
		|        {
		|            if (dll_obj.MenuOpened != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.MenuOpened);
		|                TfEventArgs1.menuItem = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.MenuOpened);
		|            }
		|        }
		|
		|        private void M_MenuBar_MenuAllClosed()
		|        {
		|            if (dll_obj.MenuAllClosed != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.MenuAllClosed);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.MenuAllClosed);
		|            }
		|        }
		|
		|        public bool UseSubMenusSingleFrame
		|        {
		|            get { return M_MenuBar.UseSubMenusSingleFrame; }
		|            set { M_MenuBar.UseSubMenusSingleFrame = value; }
		|        }
		|
		|        public bool UseKeysUpDownAsKeysLeftRight
		|        {
		|            get { return M_MenuBar.UseKeysUpDownAsKeysLeftRight; }
		|            set { M_MenuBar.UseKeysUpDownAsKeysLeftRight = value; }
		|        }
		|
		|        public bool IsMenuOpen
		|        {
		|            get { return M_MenuBar.IsMenuOpen; }
		|        }
		|
		|        public new bool Visible
		|        {
		|            get { return M_MenuBar.Visible; }
		|            set { M_MenuBar.Visible = value; }
		|        }
		|
		|        public bool CloseMenu()
		|        {
		|            M_MenuBar.OnMenuAllClosed();
		|            return M_MenuBar.CloseMenu(true);
		|        }
		|
		|        public void OpenMenu()
		|        {
		|            M_MenuBar.OpenMenu();
		|        }
		|
		|        public int Key
		|        {
		|            get { return (int)M_MenuBar.Key; }
		|            set { M_MenuBar.Key = (Terminal.Gui.Key)value; }
		|        }
		|
		|        public Terminal.Gui.MenuBarItem[] Menus
		|        {
		|            get { return M_MenuBar.Menus; }
		|            set { M_MenuBar.Menus = value; }
		|        }
		|
		|        public ostgui.View LastFocused
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_MenuBar.LastFocused); }
		|        }
		|
		|        public string ShortcutDelimiter
		|        {
		|            get { return Terminal.Gui.MenuBar.ShortcutDelimiter.ToString(); }
		|            set { Terminal.Gui.MenuBar.ShortcutDelimiter = value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_MenuBar.ToString();
		|        }
		|
		|        public new Toplevel GetTopSuperView()
		|        {
		|            return OneScriptTerminalGui.RevertEqualsObj(M_MenuBar.GetTopSuperView());
		|        }
		|
		|        public int OpenIndex
		|        {
		|            get { return M_MenuBar.OpenIndex; }
		|            set { M_MenuBar.OpenIndex = value; }
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "EventArgs" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|";
	ИначеЕсли ИмяФайлаТФ = "Attribute" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Attribute
		|    {
		|        public TfAttribute dll_obj;
		|        public Terminal.Gui.Attribute M_Attribute;
		|
		|        public Attribute()
		|        {
		|            M_Attribute = new Terminal.Gui.Attribute();
		|            OneScriptTerminalGui.AddToHashtable(M_Attribute, this);
		|        }
		|
		|        public Attribute(int p1)
		|        {
		|            M_Attribute = new Terminal.Gui.Attribute((Terminal.Gui.Color)p1);
		|            OneScriptTerminalGui.AddToHashtable(M_Attribute, this);
		|        }
		|
		|        public Attribute(int p1, int p2)
		|        {
		|            M_Attribute = new Terminal.Gui.Attribute((Terminal.Gui.Color)p1, (Terminal.Gui.Color)p2);
		|            OneScriptTerminalGui.AddToHashtable(M_Attribute, this);
		|        }
		|
		|        public Attribute(int p1, int p2, int p3)
		|        {
		|            M_Attribute = new Terminal.Gui.Attribute(p1, (Terminal.Gui.Color)p2, (Terminal.Gui.Color)p3);
		|            OneScriptTerminalGui.AddToHashtable(M_Attribute, this);
		|        }
		|
		|        public Attribute(Terminal.Gui.Attribute p1)
		|        {
		|            M_Attribute = p1;
		|            OneScriptTerminalGui.AddToHashtable(M_Attribute, this);
		|        }
		|
		|        public bool Initialized
		|        {
		|            get { return M_Attribute.Initialized; }
		|        }
		|
		|        public bool HasValidColors
		|        {
		|            get { return M_Attribute.HasValidColors; }
		|        }
		|
		|        public int Value
		|        {
		|            get { return M_Attribute.Value; }
		|        }
		|
		|        public int Foreground
		|        {
		|            get { return (int)M_Attribute.Foreground; }
		|        }
		|
		|        public int Background
		|        {
		|            get { return (int)M_Attribute.Background; }
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "SubviewCollection" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class SubviewCollection : System.Collections.IEnumerator, System.Collections.IEnumerable
		|    {
		|        public TfSubviewCollection dll_obj;
		|        public IList<Terminal.Gui.View> M_SubviewCollection;
		|        public System.Collections.IEnumerator Enumerator;
		|        public object current;
		|
		|        public SubviewCollection(IList<Terminal.Gui.View> p1)
		|        {
		|            M_SubviewCollection = p1;
		|        }
		|
		|        public IList<Terminal.Gui.View> List
		|        {
		|            get { return M_SubviewCollection; }
		|        }
		|
		|        public IEnumerator<Terminal.Gui.View> GetEnumerator()
		|        {
		|            return List.GetEnumerator();
		|        }
		|
		|        IEnumerator IEnumerable.GetEnumerator()
		|        {
		|            return List.GetEnumerator();
		|        }
		|
		|        public virtual object Current
		|        {
		|            get { return current; }
		|        }
		|
		|        public virtual void Reset()
		|        {
		|            Enumerator.Reset();
		|        }
		|
		|        public virtual bool MoveNext()
		|        {
		|            return Enumerator.MoveNext();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Window" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Window : Toplevel
		|    {
		|        public new TfWindow dll_obj;
		|        public Terminal.Gui.Window M_Window;
		|
		|        public Window()
		|        {
		|            M_Window = new Terminal.Gui.Window();
		|            base.M_Toplevel = M_Window;
		|            OneScriptTerminalGui.AddToHashtable(M_Window, this);
		|            SetActions(M_Window);
		|        }
		|
		|        public Window(string p1)
		|        {
		|            M_Window = new Terminal.Gui.Window(p1);
		|            base.M_Toplevel = M_Window;
		|            OneScriptTerminalGui.AddToHashtable(M_Window, this);
		|            SetActions(M_Window);
		|        }
		|
		|        public Window(Rect p1, string p2)
		|        {
		|            M_Window = new Terminal.Gui.Window(p1.M_Rect, p2);
		|            base.M_Toplevel = M_Window;
		|            OneScriptTerminalGui.AddToHashtable(M_Window, this);
		|            SetActions(M_Window);
		|        }
		|
		|        public Window(string p1, int p2, Border p3)
		|        {
		|            M_Window = new Terminal.Gui.Window(p1, p2, p3.M_Border);
		|            base.M_Toplevel = M_Window;
		|            OneScriptTerminalGui.AddToHashtable(M_Window, this);
		|            SetActions(M_Window);
		|        }
		|
		|        public Window(Rect p1, string p2, int p3, Border p4)
		|        {
		|            M_Window = new Terminal.Gui.Window(p1.M_Rect, p2, p3, p4.M_Border);
		|            base.M_Toplevel = M_Window;
		|            OneScriptTerminalGui.AddToHashtable(M_Window, this);
		|            SetActions(M_Window);
		|        }
		|
		|        private void SetActions(Terminal.Gui.Window window)
		|        {
		|            window.TitleChanged += Window_TitleChanged;
		|            M_Window.Subviews[0].MouseEnter += Window_MouseEnter;
		|            M_Window.Subviews[0].MouseLeave += Window_MouseLeave;
		|            M_Window.MouseClick += Window_MouseClick;
		|            M_Window.Subviews[0].Leave += M_Window_Leave;
		|            M_Window.KeyPress += M_Window_KeyPress;
		|        }
		|
		|        private void M_Window_KeyPress(Terminal.Gui.View.KeyEventEventArgs obj)
		|        {
		|            if (dll_obj.KeyPress != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.KeyPress);
		|                TfEventArgs1.isAlt = ValueFactory.Create(obj.KeyEvent.IsAlt);
		|                TfEventArgs1.isCapslock = ValueFactory.Create(obj.KeyEvent.IsCapslock);
		|                TfEventArgs1.isCtrl = ValueFactory.Create(obj.KeyEvent.IsCtrl);
		|                TfEventArgs1.isNumlock = ValueFactory.Create(obj.KeyEvent.IsNumlock);
		|                TfEventArgs1.isScrolllock = ValueFactory.Create(obj.KeyEvent.IsScrolllock);
		|                TfEventArgs1.isShift = ValueFactory.Create(obj.KeyEvent.IsShift);
		|                TfEventArgs1.keyValue = ValueFactory.Create(obj.KeyEvent.KeyValue);
		|                TfEventArgs1.keyToString = ValueFactory.Create(obj.KeyEvent.Key.ToString());
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.KeyPress);
		|            }
		|        }
		|
		|        private void M_Window_Leave(Terminal.Gui.View.FocusEventArgs obj)
		|        {
		|            if (dll_obj.Leave != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Leave);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Leave);
		|            }
		|        }
		|
		|        private void Window_MouseClick(Terminal.Gui.View.MouseEventArgs obj)
		|        {
		|            if (dll_obj.MouseClick != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.MouseClick);
		|                TfEventArgs1.flags = ValueFactory.Create((int)obj.MouseEvent.Flags);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(M_Window).dll_obj;
		|                TfEventArgs1.x = ValueFactory.Create(obj.MouseEvent.X);
		|                TfEventArgs1.y = ValueFactory.Create(obj.MouseEvent.Y);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.MouseClick);
		|            }
		|        }
		|
		|        private void Window_MouseLeave(Terminal.Gui.View.MouseEventArgs obj)
		|        {
		|            if (dll_obj.MouseLeave != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.MouseLeave);
		|                TfEventArgs1.flags = ValueFactory.Create((int)obj.MouseEvent.Flags);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj.MouseEvent.View).dll_obj;
		|                TfEventArgs1.x = ValueFactory.Create(obj.MouseEvent.X);
		|                TfEventArgs1.y = ValueFactory.Create(obj.MouseEvent.Y);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.MouseLeave);
		|            }
		|        }
		|
		|        private void Window_MouseEnter(Terminal.Gui.View.MouseEventArgs obj)
		|        {
		|            if (dll_obj.MouseEnter != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.MouseEnter);
		|                TfEventArgs1.flags = ValueFactory.Create((int)obj.MouseEvent.Flags);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(M_Window).dll_obj;
		|                TfEventArgs1.x = ValueFactory.Create(obj.MouseEvent.X);
		|                TfEventArgs1.y = ValueFactory.Create(obj.MouseEvent.Y);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.MouseEnter);
		|            }
		|        }
		|
		|        private void Window_TitleChanged(Terminal.Gui.Window.TitleEventArgs obj)
		|        {
		|            if (dll_obj.TitleChanged != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.TitleChanged);
		|                TfEventArgs1.cancel = ValueFactory.Create(obj.Cancel);
		|                TfEventArgs1.newTitle = ValueFactory.Create(obj.NewTitle.ToString());
		|                TfEventArgs1.oldTitle = ValueFactory.Create(obj.OldTitle.ToString());
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.TitleChanged);
		|
		|                if (TfEventArgs1.Cancel)
		|                {
		|                    M_Window.TitleChanged -= Window_TitleChanged;
		|                    dll_obj.Title = TfEventArgs1.OldTitle;
		|                    M_Window.TitleChanged += Window_TitleChanged;
		|                }
		|            }
		|        }
		|
		|        public string Title
		|        {
		|            get { return M_Window.Title.ToString(); }
		|            set { M_Window.Title = value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Window.ToString();
		|        }
		|
		|        public new Window GetTopSuperView()
		|        {
		|            return OneScriptTerminalGui.RevertEqualsObj(M_Window.GetTopSuperView());
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Border" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Border
		|    {
		|        public TfBorder dll_obj;
		|        public Terminal.Gui.Border M_Border;
		|
		|        public Border()
		|        {
		|            M_Border = new Terminal.Gui.Border();
		|            OneScriptTerminalGui.AddToHashtable(M_Border, this);
		|            M_Border.BorderChanged += M_Border_BorderChanged;
		|        }
		|
		|        public Border(Terminal.Gui.Border p1)
		|        {
		|            M_Border = p1;
		|            OneScriptTerminalGui.AddToHashtable(M_Border, this);
		|            M_Border.BorderChanged += M_Border_BorderChanged;
		|        }
		|
		|        private void M_Border_BorderChanged(Terminal.Gui.Border obj)
		|        {
		|            if (dll_obj.BorderChanged != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.BorderChanged);
		|                TfEventArgs1.border = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.BorderChanged);
		|            }
		|        }
		|
		|        public int ActualHeight
		|        {
		|            get { return M_Border.ActualHeight; }
		|        }
		|
		|        public int ActualWidth
		|        {
		|            get { return M_Border.ActualWidth; }
		|        }
		|
		|        public string Title
		|        {
		|            get { return M_Border.Title.ToString(); }
		|            set { M_Border.Title = value; }
		|        }
		|
		|        public bool DrawMarginFrame
		|        {
		|            get { return M_Border.DrawMarginFrame; }
		|            set { M_Border.DrawMarginFrame = value; }
		|        }
		|
		|        public IValue Parent
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_Border.Parent).dll_obj; }
		|        }
		|
		|        public Point Effect3DOffset
		|        {
		|            get { return new Point(M_Border.Effect3DOffset); }
		|            set { M_Border.Effect3DOffset = value.M_Point; }
		|        }
		|
		|        public int BorderStyle
		|        {
		|            get { return (int)M_Border.BorderStyle; }
		|            set { M_Border.BorderStyle = (Terminal.Gui.BorderStyle)value; }
		|        }
		|
		|        public Thickness BorderThickness
		|        {
		|            get { return new Thickness(M_Border.BorderThickness.Left, M_Border.BorderThickness.Top, M_Border.BorderThickness.Right, M_Border.BorderThickness.Bottom); }
		|            set { M_Border.BorderThickness = value.M_Thickness; }
		|        }
		|
		|        public Attribute Effect3DBrush
		|        {
		|            get { return new Attribute(M_Border.Effect3DBrush.Value); }
		|            set { M_Border.Effect3DBrush = value.M_Attribute; }
		|        }
		|
		|        public int BorderBrush
		|        {
		|            get { return (int)M_Border.BorderBrush; }
		|            set { M_Border.BorderBrush = (Terminal.Gui.Color)value; }
		|        }
		|
		|        public int Background
		|        {
		|            get { return (int)M_Border.Background; }
		|            set { M_Border.Background = (Terminal.Gui.Color)value; }
		|        }
		|
		|        public bool Effect3D
		|        {
		|            get { return M_Border.Effect3D; }
		|            set { M_Border.Effect3D = value; }
		|        }
		|
		|        public Thickness GetSumThickness()
		|        {
		|            Terminal.Gui.Thickness Thickness1 = M_Border.GetSumThickness();
		|            return new Thickness(Thickness1.Left, Thickness1.Top, Thickness1.Right, Thickness1.Bottom);
		|        }
		|
		|        public void DrawFullContent()
		|        {
		|            M_Border.DrawFullContent();
		|        }
		|
		|        public void DrawContent(View view = null, bool fill = true)
		|        {
		|            M_Border.DrawContent(view.M_View, fill);
		|        }
		|
		|        public void DrawTitle(View p1)
		|        {
		|            M_Border.DrawTitle(p1.M_View);
		|        }
		|
		|        public void DrawTitle(View p1, Rect p2)
		|        {
		|            M_Border.DrawTitle(p1.M_View, p2.M_Rect);
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Border.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "View" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class View : Responder
		|    {
		|        public TfView dll_obj;
		|        private Terminal.Gui.View m_View;
		|
		|        public View(Terminal.Gui.View view = null)
		|        {
		|            if (view != null)
		|            {
		|                M_View = view;
		|                OneScriptTerminalGui.AddToHashtable(M_View, this);
		|            }
		|            else
		|            {
		|                M_View = new Terminal.Gui.View();
		|                OneScriptTerminalGui.AddToHashtable(M_View, this);
		|            }
		|        }
		|        public View(Terminal.Gui.Rect p1)
		|        {
		|            M_View = new Terminal.Gui.View(p1);
		|            OneScriptTerminalGui.AddToHashtable(M_View, this);
		|        }
		|        public View(int p1, int p2, string p3)
		|        {
		|            M_View = new Terminal.Gui.View(p1, p2, p3);
		|            OneScriptTerminalGui.AddToHashtable(M_View, this);
		|        }
		|        public View(Terminal.Gui.Rect p1, string p2, Terminal.Gui.Border p3)
		|        {
		|            M_View = new Terminal.Gui.View(p1, p2, p3);
		|            OneScriptTerminalGui.AddToHashtable(M_View, this);
		|        }
		|        public View(string p1, int p2, Terminal.Gui.Border p3)
		|        {
		|            M_View = new Terminal.Gui.View(p1, (Terminal.Gui.TextDirection)p2, p3);
		|            OneScriptTerminalGui.AddToHashtable(M_View, this);
		|        }
		|
		|        public Terminal.Gui.View M_View
		|        {
		|            get { return m_View; }
		|            set
		|            {
		|                m_View = value;
		|                base.M_Responder = m_View;
		|                m_View.Added += M_View_Added;
		|                m_View.CanFocusChanged += M_View_CanFocusChanged;
		|                //m_View.DrawContent += M_View_DrawContent;
		|                //m_View.DrawContentComplete += M_View_DrawContentComplete;
		|                m_View.EnabledChanged += M_View_EnabledChanged;
		|                m_View.Enter += M_View_Enter;
		|                m_View.HotKeyChanged += M_View_HotKeyChanged;
		|                m_View.Initialized += M_View_Initialized;
		|                //m_View.KeyDown += M_View_KeyDown;
		|                m_View.KeyPress += M_View_KeyPress;
		|                //m_View.KeyUp += M_View_KeyUp;
		|                //m_View.LayoutComplete += M_View_LayoutComplete;
		|                //m_View.LayoutStarted += M_View_LayoutStarted;
		|                m_View.Leave += M_View_Leave;
		|                m_View.MouseClick += M_View_MouseClick;
		|                m_View.MouseEnter += M_View_MouseEnter;
		|                m_View.MouseLeave += M_View_MouseLeave;
		|                m_View.Removed += M_View_Removed;
		|                m_View.VisibleChanged += M_View_VisibleChanged;
		|
		|                System.Action OnShortcutAction = delegate ()
		|                {
		|                    if (OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj.ShortcutAction != null)
		|                    {
		|                        TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                        TfEventArgs1.sender = dll_obj;
		|                        TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj.ShortcutAction);
		|                        OneScriptTerminalGui.Event = TfEventArgs1;
		|                        OneScriptTerminalGui.ExecuteEvent(OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj.ShortcutAction);
		|                    }
		|                };
		|                m_View.ShortcutAction = OnShortcutAction;
		|
		|                // Обеспечим данными событие мыши MouseEnter.
		|                Application.RootMouseEvent += delegate (MouseEvent me)
		|                {
		|                    Terminal.Gui.View host1 = me.View;
		|                    MouseEvent myme = new MouseEvent();
		|                    myme.Flags = me.Flags;
		|                    myme.Handled = me.Handled;
		|                    myme.View = me.View;
		|                    int meX = me.X;
		|                    int meY = me.Y;
		|                    Terminal.Gui.Point point = host1.ScreenToView(me.X, me.Y);
		|                    int frameX = host1.Frame.X;
		|                    int frameY = host1.Frame.Y;
		|                    int frameWidth = host1.Frame.Width;
		|                    int frameHeight = host1.Frame.Height;
		|                    int x = point.X;
		|                    int y = point.Y;
		|                    if (me.View.GetType().ToString() == ""Terminal.Gui.Window+ContentView"")
		|                    {
		|                        if (meX >= (frameX + 1))
		|                        {
		|                            if (meY >= (frameY + 1))
		|                            {
		|                                if (meX < (frameX + frameWidth + 1))
		|                                {
		|                                    if (meY > (frameY + frameHeight + 1))
		|                                    {
		|                                        myme.X = x;
		|                                        myme.Y = y;
		|                                        if (OneScriptTerminalGui.lastMeX != x || OneScriptTerminalGui.lastMeY != y)
		|                                        {
		|                                            host1.OnMouseEnter(myme);
		|                                            OneScriptTerminalGui.lastMeX = x;
		|                                            OneScriptTerminalGui.lastMeY = y;
		|                                        }
		|                                    }
		|                                }
		|                            }
		|                        }
		|                    }
		|                    else if (me.View.GetType().ToString() == ""Terminal.Gui.Window"")
		|                    {
		|                        // Ничего не делаем.
		|                    }
		|                    else
		|                    {
		|                        if (meX >= frameX)
		|                        {
		|                            if (meY >= frameY)
		|                            {
		|                                if (meX < (frameX + frameWidth))
		|                                {
		|                                    if (meY < (frameY + frameHeight))
		|                                    {
		|                                        myme.X = x;
		|                                        myme.Y = y;
		|                                        if (OneScriptTerminalGui.lastMeX != x || OneScriptTerminalGui.lastMeY != y)
		|                                        {
		|                                            host1.OnMouseEnter(myme);
		|                                            OneScriptTerminalGui.lastMeX = x;
		|                                            OneScriptTerminalGui.lastMeY = y;
		|                                        }
		|                                    }
		|                                }
		|                            }
		|                        }
		|                    }
		|                };
		|            }
		|        }
		|
		|        private void M_View_VisibleChanged()
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.VisibleChanged != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.VisibleChanged);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.VisibleChanged);
		|            }
		|        }
		|
		|        private void M_View_Removed(Terminal.Gui.View obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.Removed != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.Removed);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.Removed);
		|            }
		|        }
		|
		|        private void M_View_MouseLeave(Terminal.Gui.View.MouseEventArgs obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.GetType() == typeof(TfWindow))
		|            {
		|                return;
		|            }
		|            if (Sender.GetType() == typeof(TfMenuBar))
		|            {
		|                return;
		|            }
		|            if (Sender.MouseLeave != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.MouseLeave);
		|                TfEventArgs1.flags = ValueFactory.Create((int)obj.MouseEvent.Flags);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj.MouseEvent.View).dll_obj;
		|                TfEventArgs1.x = ValueFactory.Create(obj.MouseEvent.X);
		|                TfEventArgs1.y = ValueFactory.Create(obj.MouseEvent.Y);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.MouseLeave);
		|            }
		|        }
		|
		|        private void M_View_MouseEnter(Terminal.Gui.View.MouseEventArgs obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.GetType() == typeof(TfWindow))
		|            {
		|                return;
		|            }
		|            if (Sender.MouseEnter != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.MouseEnter);
		|                TfEventArgs1.flags = ValueFactory.Create((int)obj.MouseEvent.Flags);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj.MouseEvent.View).dll_obj;
		|                TfEventArgs1.x = ValueFactory.Create(obj.MouseEvent.X);
		|                TfEventArgs1.y = ValueFactory.Create(obj.MouseEvent.Y);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.MouseEnter);
		|            }
		|        }
		|
		|        private void M_View_MouseClick(Terminal.Gui.View.MouseEventArgs obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.GetType() == typeof(TfWindow))
		|            {
		|                return;
		|            }
		|            if (Sender.MouseClick != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.MouseClick);
		|                TfEventArgs1.flags = ValueFactory.Create((int)obj.MouseEvent.Flags);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj.MouseEvent.View).dll_obj;
		|                TfEventArgs1.x = ValueFactory.Create(obj.MouseEvent.X);
		|                TfEventArgs1.y = ValueFactory.Create(obj.MouseEvent.Y);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.MouseClick);
		|            }
		|        }
		|
		|        private void M_View_Leave(Terminal.Gui.View.FocusEventArgs obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.GetType() == typeof(TfWindow))
		|            {
		|                return;
		|            }
		|            if (Sender.Leave != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.Leave);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.Leave);
		|            }
		|        }
		|
		|        //private void M_View_LayoutStarted(Terminal.Gui.View.LayoutEventArgs obj)
		|        //{
		|        //    dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|        //    if (Sender.LayoutStarted != null)
		|        //    {
		|        //        TfEventArgs TfEventArgs1 = new TfEventArgs();
		|        //        TfEventArgs1.sender = Sender;
		|        //        TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.LayoutStarted);
		|        //        TfEventArgs1.oldBounds = new TfRect(obj.OldBounds.X, obj.OldBounds.Y, obj.OldBounds.Width, obj.OldBounds.Height);
		|        //        OneScriptTerminalGui.Event = TfEventArgs1;
		|        //        OneScriptTerminalGui.ExecuteEvent(Sender.LayoutStarted);
		|        //    }
		|        //}
		|
		|        //private void M_View_LayoutComplete(Terminal.Gui.View.LayoutEventArgs obj)
		|        //{
		|        //    dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|        //    if (Sender.LayoutComplete != null)
		|        //    {
		|        //        TfEventArgs TfEventArgs1 = new TfEventArgs();
		|        //        TfEventArgs1.sender = Sender;
		|        //        TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.LayoutComplete);
		|        //        TfEventArgs1.oldBounds = new TfRect(obj.OldBounds.X, obj.OldBounds.Y, obj.OldBounds.Width, obj.OldBounds.Height);
		|        //        OneScriptTerminalGui.Event = TfEventArgs1;
		|        //        OneScriptTerminalGui.ExecuteEvent(Sender.LayoutComplete);
		|        //    }
		|        //}
		|
		|        private void M_View_KeyUp(Terminal.Gui.View.KeyEventEventArgs obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.KeyUp != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.KeyUp);
		|                TfEventArgs1.isAlt = ValueFactory.Create(obj.KeyEvent.IsAlt);
		|                TfEventArgs1.isCapslock = ValueFactory.Create(obj.KeyEvent.IsCapslock);
		|                TfEventArgs1.isCtrl = ValueFactory.Create(obj.KeyEvent.IsCtrl);
		|                TfEventArgs1.isNumlock = ValueFactory.Create(obj.KeyEvent.IsNumlock);
		|                TfEventArgs1.isScrolllock = ValueFactory.Create(obj.KeyEvent.IsScrolllock);
		|                TfEventArgs1.isShift = ValueFactory.Create(obj.KeyEvent.IsShift);
		|                TfEventArgs1.keyValue = ValueFactory.Create(obj.KeyEvent.KeyValue);
		|                TfEventArgs1.keyToString = ValueFactory.Create(obj.KeyEvent.Key.ToString());
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.KeyUp);
		|            }
		|        }
		|
		|        private void M_View_KeyPress(Terminal.Gui.View.KeyEventEventArgs obj)
		|        {
		|            // Обработаем клавишу выхода для приложения.
		|            if (OneScriptTerminalGui.instance.QuitKey == Convert.ToDecimal(obj.KeyEvent.KeyValue))
		|            {
		|                Application.RequestStop(OneScriptTerminalGui.instance.Top.Base_obj.M_Toplevel);
		|                return;
		|            }
		|
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            // Обработаем клавиши вызова для панели меню.
		|            if (Sender.GetType() == typeof(TfToplevel))
		|            {
		|                TfMenuBar TfMenuBar1 = null;
		|                try
		|                {
		|                    TfMenuBar1 = ((TfToplevel)Sender).MenuBar;
		|                }
		|                catch { }
		|                if (TfMenuBar1 != null)
		|                {
		|                    if (((TfToplevel)Sender).MenuBar.IsMenuOpen)
		|                    {
		|                        TfMenuBar menuBar = ((TfToplevel)Sender).MenuBar;
		|                        Terminal.Gui.MenuBar m_menuBar = menuBar.Base_obj.M_MenuBar;
		|                        for (int i = 0; i < menuBar.Menus.Count; i++)
		|                        {
		|                            TfMenuBarItem TfMenuBarItem1 = menuBar.Menus.MenuBarItem(i);
		|                            string hotKey = TfMenuBarItem1.HotKey.ToLower();
		|                            System.Char char1 = Convert.ToChar(hotKey.Substring(0, 1));
		|                            int num = Convert.ToInt32(char1);
		|                            if (num == (int)obj.KeyEvent.Key)
		|                            {
		|                                m_menuBar.CloseMenu(true);
		|                                m_menuBar.OpenIndex = i;
		|                                m_menuBar.OpenMenu();
		|                                m_menuBar.OpenIndex = 0;
		|                                TfMenuBarItem1.Base_obj.M_MenuBarItem.Action.Invoke();
		|                                break;
		|                            }
		|                        }
		|                    }
		|                }
		|            }
		|
		|            // Здесь мы  в хэш таблице ищем сочетание клавиш и соответствующий объект.
		|            ArrayList ShortcutDictionaryValue = null;
		|            try
		|            {
		|                ShortcutDictionaryValue = OneScriptTerminalGui.RevertShortcut(Convert.ToDecimal((int)obj.KeyEvent.Key));
		|            }
		|            catch { }
		|            if (ShortcutDictionaryValue != null)
		|            {
		|                for (int i = 0; i < ShortcutDictionaryValue.Count; i++)
		|                {
		|                    dynamic shortcutObj = ShortcutDictionaryValue[i];
		|                    // Если shortcutObj это пункт меню
		|                    if (shortcutObj.GetType() == typeof(TfMenuBarItem))
		|                    {
		|                        Terminal.Gui.MenuBar menuBar = ((TfMenuBarItem)shortcutObj).M_MenuBar;
		|                        if (menuBar.Visible && menuBar.Enabled)
		|                        {
		|                            //public static object lastEventObj = null;
		|                            //public static object lastEventValue = null;
		|                            //public static long lastEventTime = TimeSpan.TicksPerMillisecond;
		|                            // Предотвратим повторы события, если клавиша не отпущена.
		|                            long nowEventTime = DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;
		|                            if ((nowEventTime - OneScriptTerminalGui.lastEventTime) > 90)
		|                            {
		|                                if (shortcutObj.ShortcutAction != null)
		|                                {
		|                                    TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                                    TfEventArgs1.sender = dll_obj;
		|                                    TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(shortcutObj.ShortcutAction);
		|                                    OneScriptTerminalGui.Event = TfEventArgs1;
		|                                    OneScriptTerminalGui.ExecuteEvent(shortcutObj.ShortcutAction);
		|                                }
		|                            }
		|                            else { }
		|                            OneScriptTerminalGui.lastEventTime = nowEventTime;
		|                        }
		|                    }
		|                    else if (shortcutObj.GetType() == typeof(TfStatusItem))
		|                    {
		|                        Terminal.Gui.StatusBar statusBar = ((TfStatusItem)shortcutObj).M_StatusBar;
		|                        if (statusBar.Visible && statusBar.Enabled)
		|                        {
		|                            //public static object lastEventObj = null;
		|                            //public static object lastEventValue = null;
		|                            //public static long lastEventTime = TimeSpan.TicksPerMillisecond;
		|                            // Предотвратим повторы события, если клавиша не отпущена.
		|                            long nowEventTime = DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;
		|                            if ((nowEventTime - OneScriptTerminalGui.lastEventTime) > 90)
		|                            {
		|                                if (shortcutObj.ShortcutAction != null)
		|                                {
		|                                    TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                                    TfEventArgs1.sender = dll_obj;
		|                                    TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(shortcutObj.ShortcutAction);
		|                                    OneScriptTerminalGui.Event = TfEventArgs1;
		|                                    OneScriptTerminalGui.ExecuteEvent(shortcutObj.ShortcutAction);
		|                                }
		|                            }
		|                            else { }
		|                            OneScriptTerminalGui.lastEventTime = nowEventTime;
		|                        }
		|                    }
		|                    else
		|                    {
		|                        // Предотвратим повторы события, если клавиша не отпущена.
		|                        long nowEventTime = DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;
		|                        if ((nowEventTime - OneScriptTerminalGui.lastEventTime) > 90)
		|                        {
		|                            if (shortcutObj.ShortcutAction != null)
		|                            {
		|                                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                                TfEventArgs1.sender = dll_obj;
		|                                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(shortcutObj.ShortcutAction);
		|                                OneScriptTerminalGui.Event = TfEventArgs1;
		|                                OneScriptTerminalGui.ExecuteEvent(shortcutObj.ShortcutAction);
		|                            }
		|                        }
		|                        else { }
		|                        OneScriptTerminalGui.lastEventTime = nowEventTime;
		|                    }
		|                }
		|            }
		|            if (Sender.KeyPress != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.KeyPress);
		|                TfEventArgs1.isAlt = ValueFactory.Create(obj.KeyEvent.IsAlt);
		|                TfEventArgs1.isCapslock = ValueFactory.Create(obj.KeyEvent.IsCapslock);
		|                TfEventArgs1.isCtrl = ValueFactory.Create(obj.KeyEvent.IsCtrl);
		|                TfEventArgs1.isNumlock = ValueFactory.Create(obj.KeyEvent.IsNumlock);
		|                TfEventArgs1.isScrolllock = ValueFactory.Create(obj.KeyEvent.IsScrolllock);
		|                TfEventArgs1.isShift = ValueFactory.Create(obj.KeyEvent.IsShift);
		|                TfEventArgs1.keyValue = ValueFactory.Create(obj.KeyEvent.KeyValue);
		|                TfEventArgs1.keyToString = ValueFactory.Create(obj.KeyEvent.Key.ToString());
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.KeyPress);
		|            }
		|        }
		|
		|        private void M_View_KeyDown(Terminal.Gui.View.KeyEventEventArgs obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.KeyDown != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.KeyDown);
		|                TfEventArgs1.isAlt = ValueFactory.Create(obj.KeyEvent.IsAlt);
		|                TfEventArgs1.isCapslock = ValueFactory.Create(obj.KeyEvent.IsCapslock);
		|                TfEventArgs1.isCtrl = ValueFactory.Create(obj.KeyEvent.IsCtrl);
		|                TfEventArgs1.isNumlock = ValueFactory.Create(obj.KeyEvent.IsNumlock);
		|                TfEventArgs1.isScrolllock = ValueFactory.Create(obj.KeyEvent.IsScrolllock);
		|                TfEventArgs1.isShift = ValueFactory.Create(obj.KeyEvent.IsShift);
		|                TfEventArgs1.keyValue = ValueFactory.Create(obj.KeyEvent.KeyValue);
		|                TfEventArgs1.keyToString = ValueFactory.Create(obj.KeyEvent.Key.ToString());
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.KeyDown);
		|            }
		|        }
		|
		|        private void M_View_Initialized(object sender, System.EventArgs e)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.InitializedItem != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.InitializedItem);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.InitializedItem);
		|            }
		|        }
		|
		|        private void M_View_HotKeyChanged(Terminal.Gui.Key obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.HotKeyChanged != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.HotKeyChanged);
		|                TfEventArgs1.keyValue = ValueFactory.Create((int)obj);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.HotKeyChanged);
		|            }
		|        }
		|
		|        private void M_View_Enter(Terminal.Gui.View.FocusEventArgs obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.Enter != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.Enter);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.Enter);
		|            }
		|        }
		|
		|        private void M_View_EnabledChanged()
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.EnabledChanged != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.EnabledChanged);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.EnabledChanged);
		|            }
		|        }
		|
		|        //private void M_View_DrawContentComplete(Terminal.Gui.Rect obj)
		|        //{
		|        //    dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|        //    if (Sender.DrawContentComplete != null)
		|        //    {
		|        //        TfEventArgs TfEventArgs1 = new TfEventArgs();
		|        //        TfEventArgs1.sender = Sender;
		|        //        TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.DrawContentComplete);
		|        //        TfEventArgs1.rect = new TfRect(obj.X, obj.Y, obj.Width, obj.Height);
		|        //        OneScriptTerminalGui.Event = TfEventArgs1;
		|        //        OneScriptTerminalGui.ExecuteEvent(Sender.DrawContentComplete);
		|        //    }
		|        //}
		|
		|        //private void M_View_DrawContent(Terminal.Gui.Rect obj)
		|        //{
		|        //    dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|        //    if (Sender.DrawContent != null)
		|        //    {
		|        //        TfEventArgs TfEventArgs1 = new TfEventArgs();
		|        //        TfEventArgs1.sender = Sender;
		|        //        TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.DrawContent);
		|        //        TfEventArgs1.rect = new TfRect(obj.X, obj.Y, obj.Width, obj.Height);
		|        //        OneScriptTerminalGui.Event = TfEventArgs1;
		|        //        OneScriptTerminalGui.ExecuteEvent(Sender.DrawContent);
		|        //    }
		|        //}
		|
		|        private void M_View_CanFocusChanged()
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.CanFocusChanged != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.CanFocusChanged);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.CanFocusChanged);
		|            }
		|        }
		|
		|        private void M_View_Added(Terminal.Gui.View obj)
		|        {
		|            dynamic Sender = OneScriptTerminalGui.RevertEqualsObj(M_View).dll_obj;
		|            if (Sender.Added != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = Sender;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(Sender.Added);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(Sender.Added);
		|            }
		|        }
		|
		|        public IValue Tag
		|        {
		|            get { return M_View.Tag; }
		|            set { M_View.Tag = value; }
		|        }
		|
		|        public ostgui.Pos X
		|        {
		|            get { return new Pos(Terminal.Gui.Pos.X(M_View)); }
		|            set
		|            {
		|                if (M_View.GetType() != typeof(Terminal.Gui.Window))
		|                {
		|                    if (value.M_Pos.ToString().Contains(""Pos.Absolute""))
		|                    {
		|                        M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Absolute;
		|                    }
		|                }
		|                M_View.X = value.M_Pos;
		|            }
		|        }
		|
		|        public ostgui.Pos Y
		|        {
		|            get { return new Pos(Terminal.Gui.Pos.Y(M_View)); }
		|            set { M_View.Y = value.M_Pos; }
		|        }
		|
		|        public string Text
		|        {
		|            get { return M_View.Text.ToString(); }
		|            set { M_View.Text = value; }
		|        }
		|
		|        public ostgui.Dim Width
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_View.Width); }
		|            set { M_View.Width = value.M_Dim; }
		|        }
		|
		|        public ostgui.Dim Height
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_View.Height); }
		|            set { M_View.Height = value.M_Dim; }
		|        }
		|
		|        public ostgui.Pos Left
		|        {
		|            get { return new Pos(Terminal.Gui.Pos.Left(M_View)); }
		|        }
		|
		|        public ostgui.Pos Right
		|        {
		|            get { return new Pos(Terminal.Gui.Pos.Right(M_View)); }
		|        }
		|
		|        public ostgui.Pos Top
		|        {
		|            get { return new Pos(Terminal.Gui.Pos.Top(M_View)); }
		|        }
		|
		|        public ostgui.Pos Bottom
		|        {
		|            get { return new Pos(Terminal.Gui.Pos.Bottom(M_View)); }
		|        }
		|
		|        public int LayoutStyle
		|        {
		|            get { return (int)M_View.LayoutStyle; }
		|            set { M_View.LayoutStyle = (LayoutStyle)value; }
		|        }
		|
		|        public bool AutoSize
		|        {
		|            get { return M_View.AutoSize; }
		|            set { M_View.AutoSize = value; }
		|        }
		|
		|        public int VerticalTextAlignment
		|        {
		|            get { return (int)M_View.VerticalTextAlignment; }
		|            set { M_View.VerticalTextAlignment = (Terminal.Gui.VerticalTextAlignment)value; }
		|        }
		|
		|        public int TextAlignment
		|        {
		|            get { return (int)M_View.TextAlignment; }
		|            set { M_View.TextAlignment = (TextAlignment)value; }
		|        }
		|
		|        public int HotKey
		|        {
		|            get { return (int)M_View.HotKey; }
		|            set { M_View.HotKey = (Terminal.Gui.Key)value; }
		|        }
		|
		|        public bool IsAdded
		|        {
		|            get { return M_View.IsAdded; }
		|        }
		|
		|        public bool IgnoreBorderPropertyOnRedraw
		|        {
		|            get { return M_View.IgnoreBorderPropertyOnRedraw; }
		|            set { M_View.IgnoreBorderPropertyOnRedraw = value; }
		|        }
		|
		|        public bool IsInitialized
		|        {
		|            get { return M_View.IsInitialized; }
		|            set { M_View.IsInitialized = value; }
		|        }
		|
		|        public string Id
		|        {
		|            get { return M_View.Id.ToString(); }
		|            set { M_View.Id = value; }
		|        }
		|
		|        public int TextDirection
		|        {
		|            get { return (int)M_View.TextDirection; }
		|            set { M_View.TextDirection = (Terminal.Gui.TextDirection)value; }
		|        }
		|
		|        public bool ClearOnVisibleFalse
		|        {
		|            get { return M_View.ClearOnVisibleFalse; }
		|            set { M_View.ClearOnVisibleFalse = value; }
		|        }
		|
		|        public bool WantContinuousButtonPressed
		|        {
		|            get { return M_View.WantContinuousButtonPressed; }
		|            set { M_View.WantContinuousButtonPressed = value; }
		|        }
		|
		|        public bool WantMousePositionReports
		|        {
		|            get { return M_View.WantMousePositionReports; }
		|            set { M_View.WantMousePositionReports = value; }
		|        }
		|
		|        public int TabIndex
		|        {
		|            get { return M_View.TabIndex; }
		|            set { M_View.TabIndex = value; }
		|        }
		|
		|        public Rune HotKeySpecifier
		|        {
		|            get { return M_View.HotKeySpecifier; }
		|            set { M_View.HotKeySpecifier = value; }
		|        }
		|
		|        public bool PreserveTrailingSpaces
		|        {
		|            get { return M_View.PreserveTrailingSpaces; }
		|            set { M_View.PreserveTrailingSpaces = value; }
		|        }
		|
		|        public string ShortcutTag
		|        {
		|            get { return M_View.ShortcutTag.ToString(); }
		|        }
		|
		|        public bool IsCurrentTop
		|        {
		|            get
		|            {
		|                bool isCurrentTop = false;
		|                Terminal.Gui.View parent = M_View.SuperView;
		|                int num = parent.Subviews.IndexOf(M_View);
		|                int count = parent.Subviews.Count;
		|                if (num == (count - 1))
		|                {
		|                    isCurrentTop = true;
		|                }
		|                return isCurrentTop;
		|            }
		|        }
		|
		|        public bool TabStop
		|        {
		|            get { return M_View.TabStop; }
		|            set { M_View.TabStop = value; }
		|        }
		|
		|        public IValue Focused
		|        {
		|            get
		|            {
		|                if (M_View.Focused != null)
		|                {
		|                    return OneScriptTerminalGui.RevertEqualsObj(M_View.Focused).dll_obj;
		|                }
		|                return null;
		|            }
		|        }
		|
		|        public Border Border
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_View.Border); }
		|            set { M_View.Border = value.M_Border; }
		|        }
		|
		|        public Rect Bounds
		|        {
		|            get { return new Rect(M_View.Frame.X, M_View.Frame.Y, M_View.Bounds.Width, M_View.Bounds.Height); }
		|        }
		|
		|        public object Data
		|        {
		|            get { return M_View.Data; }
		|            set { M_View.Data = value; }
		|        }
		|
		|        public Rect Frame
		|        {
		|            get { return new Rect(M_View.Frame.X, M_View.Frame.Y, M_View.Frame.Width, M_View.Frame.Height); }
		|            set { M_View.Frame = value.M_Rect; }
		|        }
		|
		|        public TextFormatter TextFormatter
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_View.TextFormatter); }
		|            set { M_View.TextFormatter = value.M_TextFormatter; }
		|        }
		|
		|        public View SuperView
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_View.SuperView); }
		|        }
		|
		|        public ColorScheme ColorScheme
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_View.ColorScheme); }
		|            set { M_View.ColorScheme = value.M_ColorScheme; }
		|        }
		|
		|        public Attribute GetFocusColor()
		|        {
		|            return new Attribute(M_View.GetFocusColor());
		|        }
		|
		|        public Attribute GetNormalColor()
		|        {
		|            return new Attribute(M_View.GetNormalColor());
		|        }
		|
		|        public void SetFocus()
		|        {
		|            M_View.SetFocus();
		|        }
		|
		|        public void RemoveAll()
		|        {
		|            M_View.RemoveAll();
		|        }
		|
		|        public void Remove(View p1)
		|        {
		|            M_View.Remove(p1.M_View);
		|        }
		|
		|        public Point ScreenToView(int p1, int p2)
		|        {
		|            return new Point(M_View.ScreenToView(p1, p2));
		|        }
		|
		|        public void LayoutSubviews()
		|        {
		|            M_View.LayoutSubviews();
		|        }
		|
		|        public Size GetAutoSize()
		|        {
		|            return new Size(M_View.GetAutoSize());
		|        }
		|
		|        public void SetChildNeedsDisplay()
		|        {
		|            M_View.SetChildNeedsDisplay();
		|        }
		|
		|        public void Redraw(Rect p1)
		|        {
		|            M_View.Redraw(p1.M_Rect);
		|        }
		|
		|        public void Clear()
		|        {
		|            M_View.Clear();
		|        }
		|
		|        public void SendSubviewBackwards(View p1)
		|        {
		|            M_View.SendSubviewBackwards(p1.M_View);
		|        }
		|
		|        public void SendSubviewToBack(View p1)
		|        {
		|            M_View.SendSubviewToBack(p1.M_View);
		|        }
		|
		|        public void SetNeedsDisplay(Rect p1 = null)
		|        {
		|            M_View.SetNeedsDisplay(p1.M_Rect);
		|        }
		|
		|        public void BringSubviewToFront(View p1)
		|        {
		|            M_View.BringSubviewToFront(p1.M_View);
		|        }
		|
		|        public void Add(View p1)
		|        {
		|            M_View.Add(p1.M_View);
		|        }
		|
		|        public void BringSubviewForward(View p1)
		|        {
		|            M_View.BringSubviewForward(p1.M_View);
		|        }
		|
		|        public void CorrectionZet()
		|        {
		|            // Необходимая коррекция z-порядка элементов при запуске приложения.
		|            // Найдено экспериментальным путем.
		|            Terminal.Gui.View[] array1 = new Terminal.Gui.View[M_View.Subviews.Count];
		|            for (int i = 0; i < M_View.Subviews.Count; i++)
		|            {
		|                Terminal.Gui.View view1 = M_View.Subviews[i];
		|                array1[i] = view1;
		|            }
		|            M_View.RemoveAll();
		|            //M_View.Add(array1[3]);
		|            //M_View.Add(array1[0]);
		|            //M_View.Add(array1[1]);
		|            //M_View.Add(array1[2]);
		|            M_View.Add(array1[array1.Length - 1]);
		|            for (int i = 0; i < array1.Length - 1; i++)
		|            {
		|                M_View.Add(array1[i]);
		|            }
		|        }
		|
		|        public View GetTopSuperView()
		|        {
		|            return OneScriptTerminalGui.RevertEqualsObj(M_View.GetTopSuperView());
		|        }
		|
		|        public System.Action ShortcutAction
		|        {
		|            get { return M_View.ShortcutAction; }
		|            set { M_View.ShortcutAction = value; }
		|        }
		|
		|        public ostgui.Attribute GetHotNormalColor()
		|        {
		|            return new Attribute(M_View.GetHotNormalColor());
		|        }
		|
		|        public void PlaceTop(View p1, int p2)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.Y = Terminal.Gui.Pos.Top(p1.M_View) - M_View.Frame.Height - p2 - 1;
		|        }
		|
		|        public void PlaceLeft(View p1, int p2)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.X = Terminal.Gui.Pos.Left(p1.M_View) - M_View.Frame.Width - p2 - 1;
		|        }
		|
		|        public void PlaceBottom(View p1, int p2)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.Y = Terminal.Gui.Pos.Bottom(p1.M_View) + p2 + 1;
		|        }
		|
		|        public void PlaceRight(View p1, int p2)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.X = Terminal.Gui.Pos.Right(p1.M_View) + p2 + 1;
		|        }
		|
		|        public void PlaceTopLeft(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.Y = Terminal.Gui.Pos.Top(p1.M_View) - M_View.Frame.Height - p2 - 1;
		|
		|            M_View.X = Terminal.Gui.Pos.Left(p1.M_View) - M_View.Frame.Width - p3 - 1;
		|        }
		|
		|        public void PlaceTopRight(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.Y = Terminal.Gui.Pos.Top(p1.M_View) - M_View.Frame.Height - p2 - 1;
		|
		|            M_View.X = Terminal.Gui.Pos.Right(p1.M_View) + p3 + 1;
		|        }
		|
		|        public void PlaceBottomLeft(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.Y = Terminal.Gui.Pos.Bottom(p1.M_View) + p2 + 1;
		|
		|            M_View.X = Terminal.Gui.Pos.Left(p1.M_View) - M_View.Frame.Width - p3 - 1;
		|        }
		|
		|        public void PlaceBottomRight(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.Y = Terminal.Gui.Pos.Bottom(p1.M_View) + p2 + 1;
		|
		|            M_View.X = Terminal.Gui.Pos.Right(p1.M_View) + p3 + 1;
		|        }
		|
		|        public void PlaceLeftTop(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.X = Terminal.Gui.Pos.Left(p1.M_View) - M_View.Frame.Width - p2 - 1;
		|
		|            M_View.Y = Terminal.Gui.Pos.Top(p1.M_View) - M_View.Frame.Height - p3 - 1;
		|        }
		|
		|        public void PlaceLeftBottom(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.X = Terminal.Gui.Pos.Left(p1.M_View) - M_View.Frame.Width - p2 - 1;
		|
		|            M_View.Y = Terminal.Gui.Pos.Bottom(p1.M_View) + p3 + 1;
		|        }
		|
		|        public void PlaceRightTop(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.X = Terminal.Gui.Pos.Right(p1.M_View) + p2 + 1;
		|
		|            M_View.Y = Terminal.Gui.Pos.Top(p1.M_View) - M_View.Frame.Height - p3 - 1;
		|        }
		|
		|        public void PlaceRightBottom(View p1, int p2, int p3)
		|        {
		|            M_View.LayoutStyle = Terminal.Gui.LayoutStyle.Computed;
		|            M_View.X = Terminal.Gui.Pos.Right(p1.M_View) + p2 + 1;
		|
		|            M_View.Y = Terminal.Gui.Pos.Bottom(p1.M_View) + p3 + 1;
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_View.ToString();
		|        }
		|
		|        public SubviewCollection Subviews
		|        {
		|            get { return new SubviewCollection(M_View.Subviews); }
		|        }
		|
		|        public void Center(int p1 = 0, int p2 = 0)
		|        {
		|            if (p1 != 0)
		|            {
		|                M_View.X = Terminal.Gui.Pos.Center() + p1 - (M_View.Frame.Width / 2) - 1;
		|            }
		|            else
		|            {
		|                M_View.X = Terminal.Gui.Pos.Center();
		|            }
		|            if (p2 != 0)
		|            {
		|                M_View.Y = Terminal.Gui.Pos.Center() + p2 - (M_View.Frame.Height / 2) - 1;
		|            }
		|            else
		|            {
		|                M_View.Y = Terminal.Gui.Pos.Center();
		|            }
		|        }
		|
		|        public void Fill(int p1 = 0, int p2 = 0)
		|        {
		|            M_View.Width = Terminal.Gui.Dim.Fill(p1);
		|            M_View.Height = Terminal.Gui.Dim.Fill(p2);
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Toplevel" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Toplevel : View
		|    {
		|        public new TfToplevel dll_obj;
		|        public Terminal.Gui.Toplevel m_Toplevel;
		|
		|        public Terminal.Gui.Toplevel M_Toplevel
		|        {
		|            get { return m_Toplevel; }
		|            set
		|            {
		|                m_Toplevel = value;
		|                base.M_View = m_Toplevel;
		|            }
		|        }
		|
		|        public Toplevel()
		|        {
		|            M_Toplevel = new Terminal.Gui.Toplevel();
		|            base.M_View = M_Toplevel;
		|            OneScriptTerminalGui.AddToHashtable(M_Toplevel, this);
		|            SetActions(M_Toplevel);
		|        }
		|
		|        public Toplevel(Terminal.Gui.Rect p1)
		|        {
		|            M_Toplevel = new Terminal.Gui.Toplevel(p1);
		|            base.M_View = M_Toplevel;
		|            OneScriptTerminalGui.AddToHashtable(M_Toplevel, this);
		|            SetActions(M_Toplevel);
		|        }
		|
		|        public Toplevel(Terminal.Gui.Toplevel p1)
		|        {
		|            M_Toplevel = p1;
		|            base.M_View = M_Toplevel;
		|            OneScriptTerminalGui.AddToHashtable(M_Toplevel, this);
		|            SetActions(M_Toplevel);
		|        }
		|
		|        private void SetActions(Terminal.Gui.Toplevel toplevel)
		|        {
		|            toplevel.Activate += M_Toplevel_Activate;
		|            toplevel.AllChildClosed += M_Toplevel_AllChildClosed;
		|            toplevel.ChildClosed += M_Toplevel_ChildClosed;
		|            toplevel.ChildLoaded += M_Toplevel_ChildLoaded;
		|            toplevel.ChildUnloaded += M_Toplevel_ChildUnloaded;
		|            toplevel.Closed += M_Toplevel_Closed;
		|            toplevel.Closing += M_Toplevel_Closing;
		|            toplevel.Deactivate += M_Toplevel_Deactivate;
		|            toplevel.Loaded += M_Toplevel_Loaded;
		|            toplevel.QuitKeyChanged += M_Toplevel_QuitKeyChanged;
		|            toplevel.Ready += M_Toplevel_Ready;
		|            toplevel.Resized += M_Toplevel_Resized;
		|            toplevel.Unloaded += M_Toplevel_Unloaded;
		|            toplevel.KeyPress += Toplevel_KeyPress;
		|        }
		|
		|        private void Toplevel_KeyPress(Terminal.Gui.View.KeyEventEventArgs obj)
		|        {
		|            if (dll_obj.KeyPress != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.KeyPress);
		|                TfEventArgs1.isAlt = ValueFactory.Create(obj.KeyEvent.IsAlt);
		|                TfEventArgs1.isCapslock = ValueFactory.Create(obj.KeyEvent.IsCapslock);
		|                TfEventArgs1.isCtrl = ValueFactory.Create(obj.KeyEvent.IsCtrl);
		|                TfEventArgs1.isNumlock = ValueFactory.Create(obj.KeyEvent.IsNumlock);
		|                TfEventArgs1.isScrolllock = ValueFactory.Create(obj.KeyEvent.IsScrolllock);
		|                TfEventArgs1.isShift = ValueFactory.Create(obj.KeyEvent.IsShift);
		|                TfEventArgs1.keyValue = ValueFactory.Create(obj.KeyEvent.KeyValue);
		|                TfEventArgs1.keyToString = ValueFactory.Create(obj.KeyEvent.Key.ToString());
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.KeyPress);
		|            }
		|        }
		|
		|        private void M_Toplevel_Activate(Terminal.Gui.Toplevel obj)
		|        {
		|            if (dll_obj.Activate != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Activate);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Activate);
		|            }
		|        }
		|
		|        private void M_Toplevel_AllChildClosed()
		|        {
		|            if (dll_obj.AllChildClosed != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.AllChildClosed);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.AllChildClosed);
		|            }
		|        }
		|
		|        private void M_Toplevel_ChildClosed(Terminal.Gui.Toplevel obj)
		|        {
		|            if (dll_obj.ChildClosed != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.ChildClosed);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.ChildClosed);
		|            }
		|        }
		|
		|        private void M_Toplevel_ChildLoaded(Terminal.Gui.Toplevel obj)
		|        {
		|            if (dll_obj.ChildLoaded != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.ChildLoaded);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.ChildLoaded);
		|            }
		|        }
		|
		|        private void M_Toplevel_ChildUnloaded(Terminal.Gui.Toplevel obj)
		|        {
		|            if (dll_obj.ChildUnloaded != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.ChildUnloaded);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.ChildUnloaded);
		|            }
		|        }
		|
		|        private void M_Toplevel_Closed(Terminal.Gui.Toplevel obj)
		|        {
		|            if (dll_obj.Closed != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Closed);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Closed);
		|            }
		|        }
		|
		|        private void M_Toplevel_Closing(Terminal.Gui.ToplevelClosingEventArgs obj)
		|        {
		|            if (dll_obj.Closing != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Closing);
		|                TfEventArgs1.cancel = ValueFactory.Create(obj.Cancel);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj.RequestingTop).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Closing);
		|                obj.Cancel = TfEventArgs1.Cancel;
		|            }
		|        }
		|
		|        private void M_Toplevel_Deactivate(Terminal.Gui.Toplevel obj)
		|        {
		|            if (dll_obj.Deactivate != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Deactivate);
		|                TfEventArgs1.view = OneScriptTerminalGui.RevertEqualsObj(obj).dll_obj;
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Deactivate);
		|            }
		|        }
		|
		|        private void M_Toplevel_Loaded()
		|        {
		|            if (dll_obj.Loaded != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Loaded);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Loaded);
		|            }
		|        }
		|
		|        private void M_Toplevel_QuitKeyChanged(Terminal.Gui.Key obj)
		|        {
		|            if (dll_obj.QuitKeyChanged != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.QuitKeyChanged);
		|                TfEventArgs1.keyValue = ValueFactory.Create((int)obj);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.QuitKeyChanged);
		|            }
		|        }
		|
		|        private void M_Toplevel_Ready()
		|        {
		|            if (dll_obj.Ready != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Ready);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Ready);
		|            }
		|        }
		|
		|        private void M_Toplevel_Resized(Terminal.Gui.Size obj)
		|        {
		|            if (OneScriptTerminalGui.instance.Resized != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(OneScriptTerminalGui.instance.Resized);
		|                TfEventArgs1.size = new TfSize(obj.Width, obj.Height);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(OneScriptTerminalGui.instance.Resized);
		|            }
		|        }
		|
		|        private void M_Toplevel_Unloaded()
		|        {
		|            if (dll_obj.Unloaded != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Unloaded);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Unloaded);
		|            }
		|        }
		|
		|        public bool Modal
		|        {
		|            get { return M_Toplevel.Modal; }
		|            set { M_Toplevel.Modal = value; }
		|        }
		|
		|        public ostgui.MenuBar MenuBar
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_Toplevel.MenuBar); }
		|            set { M_Toplevel.Add(value.M_MenuBar); }
		|        }
		|
		|        public StatusBar StatusBar
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj((M_Toplevel.StatusBar)); }
		|            set { M_Toplevel.StatusBar = value.M_StatusBar; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Toplevel.ToString();
		|        }
		|
		|        public new Toplevel GetTopSuperView()
		|        {
		|            return OneScriptTerminalGui.RevertEqualsObj(M_Toplevel.GetTopSuperView());
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "TextFormatter" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class TextFormatter
		|    {
		|        public TfTextFormatter dll_obj;
		|        public Terminal.Gui.TextFormatter M_TextFormatter;
		|
		|        public TextFormatter()
		|        {
		|            M_TextFormatter = new Terminal.Gui.TextFormatter();
		|            OneScriptTerminalGui.AddToHashtable(M_TextFormatter, this);
		|        }
		|
		|        public bool AutoSize
		|        {
		|            get { return M_TextFormatter.AutoSize; }
		|            set { M_TextFormatter.AutoSize = value; }
		|        }
		|
		|        public int VerticalAlignment
		|        {
		|            get { return (int)M_TextFormatter.VerticalAlignment; }
		|            set { M_TextFormatter.VerticalAlignment = (Terminal.Gui.VerticalTextAlignment)value; }
		|        }
		|
		|        public int Alignment
		|        {
		|            get { return (int)M_TextFormatter.Alignment; }
		|            set { M_TextFormatter.Alignment = (Terminal.Gui.TextAlignment)value; }
		|        }
		|
		|        public int HotKey
		|        {
		|            get { return (int)M_TextFormatter.HotKey; }
		|        }
		|
		|        public ArrayImpl Lines
		|        {
		|            get
		|            {
		|                ArrayImpl ArrayImpl1 = new ArrayImpl();
		|                List<NStack.ustring> ustring1 = M_TextFormatter.Lines;
		|                for (int i = 0; i < ustring1.Count; i++)
		|                {
		|                    ArrayImpl1.Add(ValueFactory.Create(ustring1[i].ToString()));
		|                }
		|                return ArrayImpl1;
		|            }
		|        }
		|
		|        public int Direction
		|        {
		|            get { return (int)M_TextFormatter.Direction; }
		|            set { M_TextFormatter.Direction = (Terminal.Gui.TextDirection)value; }
		|        }
		|
		|        public int HotKeyPos
		|        {
		|            get { return M_TextFormatter.HotKeyPos; }
		|            set { M_TextFormatter.HotKeyPos = value; }
		|        }
		|
		|        public int CursorPosition
		|        {
		|            get { return M_TextFormatter.CursorPosition; }
		|            set { M_TextFormatter.CursorPosition = value; }
		|        }
		|
		|        public Size Size
		|        {
		|            get { return new Size(M_TextFormatter.Size); }
		|            set { M_TextFormatter.Size = value.M_Size; }
		|        }
		|
		|        public Rune HotKeySpecifier
		|        {
		|            get { return M_TextFormatter.HotKeySpecifier; }
		|            set { M_TextFormatter.HotKeySpecifier = value; }
		|        }
		|
		|        public bool PreserveTrailingSpaces
		|        {
		|            get { return M_TextFormatter.PreserveTrailingSpaces; }
		|            set { M_TextFormatter.PreserveTrailingSpaces = value; }
		|        }
		|
		|        public string Text
		|        {
		|            get { return M_TextFormatter.Text.ToString(); }
		|            set { M_TextFormatter.Text = value; }
		|        }
		|
		|        public bool NeedsFormat
		|        {
		|            get { return M_TextFormatter.NeedsFormat; }
		|            set { M_TextFormatter.NeedsFormat = value; }
		|        }
		|
		|        public string Justify(string p1, int p2, string p3 = "" "", Terminal.Gui.TextDirection p4 = Terminal.Gui.TextDirection.LeftRight_TopBottom)
		|        {
		|            return Terminal.Gui.TextFormatter.Justify(p1, p2, Convert.ToChar(p3), p4).ToString();
		|        }
		|
		|        public Rect CalcRect(int p1, int p2, string p3, Terminal.Gui.TextDirection p4 = Terminal.Gui.TextDirection.LeftRight_TopBottom)
		|        {
		|            return new Rect(Terminal.Gui.TextFormatter.CalcRect(p1, p2, p3, p4));
		|        }
		|
		|        public string ReplaceHotKeyWithTag(string p1, int p2)
		|        {
		|            return M_TextFormatter.ReplaceHotKeyWithTag(p1, p2).ToString();
		|        }
		|
		|        public int MaxWidth(string p1, int p2)
		|        {
		|            return Terminal.Gui.TextFormatter.MaxWidth(p1, p2);
		|        }
		|
		|        public int GetMaxColsForWidth(string p1, int p2)
		|        {
		|            List<NStack.ustring> ustring1 = new List<NStack.ustring>();
		|            string[] result = p1.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
		|            for (int i = 0; i < result.Length; i++)
		|            {
		|                ustring1.Add(result[i]);
		|            }
		|            return Terminal.Gui.TextFormatter.GetMaxColsForWidth(ustring1, p2);
		|        }
		|
		|        public int GetSumMaxCharWidth(string p1, int p2 = -1, int p3 = -1)
		|        {
		|            List<NStack.ustring> ustring1 = new List<NStack.ustring>();
		|            string[] result = p1.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
		|            for (int i = 0; i < result.Length; i++)
		|            {
		|                ustring1.Add(result[i]);
		|            }
		|            return Terminal.Gui.TextFormatter.GetSumMaxCharWidth(ustring1, p2, p3);
		|        }
		|
		|        public int GetMaxLengthForWidth(string p1, int p2)
		|        {
		|            return Terminal.Gui.TextFormatter.GetMaxLengthForWidth(p1, p2);
		|        }
		|
		|        public int MaxLines(string p1, int p2)
		|        {
		|            return Terminal.Gui.TextFormatter.MaxLines(p1, p2);
		|        }
		|
		|        public bool FindHotKey(string p1, string p2, bool p3, out int p4, out Terminal.Gui.Key p5)
		|        {
		|            Rune Rune1 = p2.ToCharArray()[0];
		|            return Terminal.Gui.TextFormatter.FindHotKey(p1, Rune1, p3, out p4, out p5);
		|        }
		|
		|        public string ClipAndJustify(string p1, int p2, int p3, Terminal.Gui.TextDirection p4 = Terminal.Gui.TextDirection.LeftRight_TopBottom)
		|        {
		|            return Terminal.Gui.TextFormatter.ClipAndJustify(p1, p2, (Terminal.Gui.TextAlignment)p3, p4).ToString();
		|        }
		|
		|        public string ClipOrPad(string p1, int p2)
		|        {
		|            return Terminal.Gui.TextFormatter.ClipOrPad(p1, p2);
		|        }
		|
		|        public string WordWrap(string p1, int p2, bool p3 = false, int p4 = 0, Terminal.Gui.TextDirection p5 = Terminal.Gui.TextDirection.LeftRight_TopBottom)
		|        {
		|            string str = """";
		|            List<NStack.ustring> list1 = Terminal.Gui.TextFormatter.WordWrap(p1, p2, p3, p4, (Terminal.Gui.TextDirection)p5);
		|            for (int i = 0; i < list1.Count; i++)
		|            {
		|                if (i == 0)
		|                {
		|                    str = list1[i].ToString() + Environment.NewLine;
		|                }
		|                else if (i == (list1.Count - 1))
		|                {
		|                    str += list1[i].ToString();
		|                }
		|                else
		|                {
		|                    str += list1[i].ToString() + Environment.NewLine;
		|                }
		|            }
		|            return str;
		|        }
		|
		|        public string SplitNewLine(string p1)
		|        {
		|            List<NStack.ustring> ustring1 = Terminal.Gui.TextFormatter.SplitNewLine(p1);
		|            string str = """";
		|            for (int i = 0; i < ustring1.Count; i++)
		|            {
		|                str += ustring1[i].ToString() + Environment.NewLine;
		|            }
		|            return str;
		|        }
		|
		|        public void Draw(Rect p1, Attribute p2, Attribute p3, Rect p4 = default, bool p5 = true)
		|        {
		|            M_TextFormatter.Draw(p1.M_Rect, p2.M_Attribute, p3.M_Attribute, p4.M_Rect, p5);
		|        }
		|
		|        public int MaxWidthLine(string p1)
		|        {
		|            return Terminal.Gui.TextFormatter.MaxWidthLine(p1);
		|        }
		|
		|        public string RemoveHotKeySpecifier(string p1, int p2, string p3)
		|        {
		|            return Terminal.Gui.TextFormatter.RemoveHotKeySpecifier(p1, p2, p3.ToCharArray()[0]).ToString();
		|        }
		|
		|        public string Format(string p1, int p2, int p3, bool p4, bool p5 = false, int p6 = 0, int p7 = 0)
		|        {
		|            List<NStack.ustring> ustring1 = Terminal.Gui.TextFormatter.Format(p1, p2, (Terminal.Gui.TextAlignment)p3, p4, p5, p6, (Terminal.Gui.TextDirection)p7);
		|            string str = """";
		|            for (int i = 0; i < ustring1.Count; i++)
		|            {
		|                str += ustring1[i].ToString() + Environment.NewLine;
		|            }
		|            return str;
		|        }
		|
		|        public int GetTextWidth(string p1)
		|        {
		|            return Terminal.Gui.TextFormatter.GetTextWidth(p1.ToString());
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_TextFormatter.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Size" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Size
		|    {
		|        public TfSize dll_obj;
		|        public Terminal.Gui.Size M_Size;
		|
		|        public Size()
		|        {
		|            M_Size = new Terminal.Gui.Size();
		|        }
		|
		|        public Size(Terminal.Gui.Point p1)
		|        {
		|            M_Size = new Terminal.Gui.Size(p1);
		|        }
		|
		|        public Size(Terminal.Gui.Size p1)
		|        {
		|            M_Size = p1;
		|        }
		|
		|        public Size(int width, int height)
		|        {
		|            M_Size = new Terminal.Gui.Size(width, height);
		|        }
		|
		|        public int Width
		|        {
		|            get { return M_Size.Width; }
		|            set { M_Size.Width = value; }
		|        }
		|
		|        public int Height
		|        {
		|            get { return M_Size.Height; }
		|            set { M_Size.Height = value; }
		|        }
		|
		|        public Size Subtract(Size p1, Size p2)
		|        {
		|            return new Size(Terminal.Gui.Size.Subtract(p1.M_Size, p2.M_Size));
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Size.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Rect" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Rect
		|    {
		|        public TfRect dll_obj;
		|        public Terminal.Gui.Rect M_Rect;
		|
		|        public Rect()
		|        {
		|            M_Rect = new Terminal.Gui.Rect();
		|        }
		|
		|        public Rect(Terminal.Gui.Point p1, Terminal.Gui.Size p2)
		|        {
		|            M_Rect = new Terminal.Gui.Rect(p1, p2);
		|        }
		|
		|        public Rect(Terminal.Gui.Rect p1)
		|        {
		|            M_Rect = p1;
		|        }
		|
		|        public Rect(int x, int y, int width, int height)
		|        {
		|            M_Rect = new Terminal.Gui.Rect(x, y, width, height);
		|        }
		|
		|        public int X
		|        {
		|            get { return M_Rect.X; }
		|            set { M_Rect.X = value; }
		|        }
		|
		|        public int Y
		|        {
		|            get { return M_Rect.Y; }
		|            set { M_Rect.Y = value; }
		|        }
		|
		|        public int Width
		|        {
		|            get { return M_Rect.Width; }
		|            set { M_Rect.Width = value; }
		|        }
		|
		|        public int Height
		|        {
		|            get { return M_Rect.Height; }
		|            set { M_Rect.Height = value; }
		|        }
		|
		|        public int Left
		|        {
		|            get { return M_Rect.Left; }
		|        }
		|
		|        public int Right
		|        {
		|            get { return M_Rect.Right; }
		|        }
		|
		|        public int Top
		|        {
		|            get { return M_Rect.Top; }
		|        }
		|
		|        public int Bottom
		|        {
		|            get { return M_Rect.Bottom; }
		|        }
		|
		|        public bool Contains(Terminal.Gui.Rect p1)
		|        {
		|            return M_Rect.Contains(p1);
		|        }
		|
		|        public bool Contains(Terminal.Gui.Point p1)
		|        {
		|            return M_Rect.Contains(p1);
		|        }
		|
		|        public bool Contains(int p1, int p2)
		|        {
		|            return M_Rect.Contains(p1, p2);
		|        }
		|
		|        public void Offset(int p1, int p2)
		|        {
		|            M_Rect.Offset(p1, p2);
		|        }
		|
		|        public void Inflate(Terminal.Gui.Size p1)
		|        {
		|            M_Rect.Inflate(p1);
		|        }
		|
		|        public ostgui.Rect Inflate(Rect p1, int p2, int p3)
		|        {
		|            return new Rect(Terminal.Gui.Rect.Inflate(p1.M_Rect, p2, p3));
		|        }
		|
		|        public void Inflate(int p1, int p2)
		|        {
		|            M_Rect.Inflate(p1, p2);
		|        }
		|
		|        public Rect FromLTRB(int p1, int p2, int p3, int p4)
		|        {
		|            return new Rect(Terminal.Gui.Rect.FromLTRB(p1, p2, p3, p4));
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Rect.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Point" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Point
		|    {
		|        public TfPoint dll_obj;
		|        public Terminal.Gui.Point M_Point;
		|
		|        public Point()
		|        {
		|            M_Point = new Terminal.Gui.Point();
		|        }
		|
		|        public Point(Terminal.Gui.Size p1)
		|        {
		|            M_Point = new Terminal.Gui.Point(p1);
		|        }
		|
		|        public Point(int x, int y)
		|        {
		|            M_Point = new Terminal.Gui.Point(x, y);
		|        }
		|
		|        public Point(Terminal.Gui.Point p1)
		|        {
		|            M_Point = p1;
		|        }
		|
		|        public int X
		|        {
		|            get { return M_Point.X; }
		|            set { M_Point.X = value; }
		|        }
		|
		|        public int Y
		|        {
		|            get { return M_Point.Y; }
		|            set { M_Point.Y = value; }
		|        }
		|
		|        public void Offset(int p1, int p2)
		|        {
		|            M_Point.Offset(p1, p2);
		|        }
		|
		|        public ostgui.Point Subtract(Point p1, Size p2)
		|        {
		|            return new Point(Terminal.Gui.Point.Subtract(p1.M_Point, p2.M_Size));
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Point.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "ColorScheme" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class ColorScheme
		|    {
		|        public TfColorScheme dll_obj;
		|        public Terminal.Gui.ColorScheme M_ColorScheme;
		|
		|        public ColorScheme()
		|        {
		|            M_ColorScheme = new Terminal.Gui.ColorScheme();
		|            OneScriptTerminalGui.AddToHashtable(M_ColorScheme, this);
		|        }
		|
		|        public ColorScheme(Terminal.Gui.ColorScheme p1)
		|        {
		|            M_ColorScheme = p1;
		|            OneScriptTerminalGui.AddToHashtable(M_ColorScheme, this);
		|        }
		|
		|        public Attribute HotNormal
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_ColorScheme.HotNormal); }
		|            set { M_ColorScheme.HotNormal = value.M_Attribute; }
		|        }
		|
		|        public Attribute HotFocus
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_ColorScheme.HotFocus); }
		|            set { M_ColorScheme.HotFocus = value.M_Attribute; }
		|        }
		|
		|        public Attribute Normal
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_ColorScheme.Normal); }
		|            set { M_ColorScheme.Normal = value.M_Attribute; }
		|        }
		|
		|        public Attribute Disabled
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_ColorScheme.Disabled); }
		|            set { M_ColorScheme.Disabled = value.M_Attribute; }
		|        }
		|
		|        public Attribute Focus
		|        {
		|            get { return OneScriptTerminalGui.RevertEqualsObj(M_ColorScheme.Focus); }
		|            set { M_ColorScheme.Focus = value.M_Attribute; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_ColorScheme.ToString();
		|        }
		|    }
		|";
	ИначеЕсли ИмяФайлаТФ = "Button" Тогда
		Стр = Стр + 
		"namespace ostgui
		|{
		|    public class Button : View
		|    {
		|        public new TfButton dll_obj;
		|        public Terminal.Gui.Button M_Button;
		|
		|        public Button()
		|        {
		|            M_Button = new Terminal.Gui.Button();
		|            base.M_View = M_Button;
		|            OneScriptTerminalGui.AddToHashtable(M_Button, this);
		|            SetActions(M_Button);
		|        }
		|
		|        public Button(string p1, bool p2 = false)
		|        {
		|            M_Button = new Terminal.Gui.Button(p1, p2);
		|            base.M_View = M_Button;
		|            OneScriptTerminalGui.AddToHashtable(M_Button, this);
		|            SetActions(M_Button);
		|        }
		|
		|        public Button(int p1, int p2, string p3)
		|        {
		|            M_Button = new Terminal.Gui.Button(p1, p2, p3);
		|            base.M_View = M_Button;
		|            OneScriptTerminalGui.AddToHashtable(M_Button, this);
		|            SetActions(M_Button);
		|        }
		|
		|        public Button(int p1, int p2, string p3, bool p4)
		|        {
		|            M_Button = new Terminal.Gui.Button(p1, p2, p3, p4);
		|            base.M_View = M_Button;
		|            OneScriptTerminalGui.AddToHashtable(M_Button, this);
		|            SetActions(M_Button);
		|        }
		|
		|        private void SetActions(Terminal.Gui.Button button)
		|        {
		|            button.Clicked += Button_Clicked;
		|        }
		|
		|        private void Button_Clicked()
		|        {
		|            if (dll_obj.Clicked != null)
		|            {
		|                TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                TfEventArgs1.sender = dll_obj;
		|                TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(dll_obj.Clicked);
		|                OneScriptTerminalGui.Event = TfEventArgs1;
		|                OneScriptTerminalGui.ExecuteEvent(dll_obj.Clicked);
		|            }
		|        }
		|
		|        public bool IsDefault
		|        {
		|            get { return M_Button.IsDefault; }
		|            set { M_Button.IsDefault = value; }
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Button.ToString();
		|        }
		|
		|        public new Toplevel GetTopSuperView()
		|        {
		|            return OneScriptTerminalGui.RevertEqualsObj(M_Button.GetTopSuperView());
		|        }
		|    }
		|";
	КонецЕсли;
	Возврат Стр;
КонецФункции//КлассВторогоУровня

Процедура СоздатьФайлТФ(ИмяФайлаТФ)
	СписокНеизменныхКлассов.Добавить(ИмяФайлаТФ);
	СтрВыгрузки = "";
	Если Ложь Тогда
	// ИначеЕсли ИмяФайлаТФ = "" Тогда
		// СтрВыгрузки = СтрВыгрузки + 
		// "namespace ostgui
		// |{
		
		// |    }
		// |}
		// |";
		// ТекстДокХХХ = Новый ТекстовыйДокумент;
		// ТекстДокХХХ.УстановитьТекст(СтрВыгрузки);
		// ТекстДокХХХ.Записать(КаталогВыгрузки + "\" + ИмяФайлаТФ + ".cs");
		
		
		
		
		
	ИначеЕсли ИмяФайлаТФ = "Responder" Тогда
		СтрВыгрузки = СтрВыгрузки + 
		"namespace ostgui
		|{
		|    public class Responder : Terminal.Gui.Responder
		|    {
		|        public Terminal.Gui.Responder M_Responder;
		|
		|        public new bool CanFocus
		|        {
		|            get { return M_Responder.CanFocus; }
		|            set { M_Responder.CanFocus = value; }
		|        }
		|
		|        public new bool Enabled
		|        {
		|            get { return M_Responder.Enabled; }
		|            set { M_Responder.Enabled = value; }
		|        }
		|
		|        public new bool Visible
		|        {
		|            get { return M_Responder.Visible; }
		|            set { M_Responder.Visible = value; }
		|        }
		|
		|        public new bool HasFocus
		|        {
		|            get { return M_Responder.HasFocus; }
		|        }
		|
		|        public new void Dispose()
		|        {
		|            M_Responder.Dispose();
		|        }
		|
		|        public new string ToString()
		|        {
		|            return M_Responder.ToString();
		|        }
		|    }
		|}
		|";
		ТекстДокХХХ = Новый ТекстовыйДокумент;
		ТекстДокХХХ.УстановитьТекст(СтрВыгрузки);
		ТекстДокХХХ.Записать(КаталогВыгрузки + "\" + ИмяФайлаТФ + ".cs");
	ИначеЕсли ИмяФайлаТФ = "Action" Тогда
		СтрВыгрузки = СтрВыгрузки + 
		"using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|
		|namespace ostgui
		|{
		|    [ContextClass(""ТфДействие"", ""TfAction"")]
		|    public class TfAction : AutoContext<TfAction>
		|    {
		|        public TfAction(IRuntimeContextInstance script = null, string methodName = null, IValue param = null)
		|        {
		|            Script = script;
		|            MethodName = methodName;
		|            Parameter = param;
		|        }
		|
		|        [ContextProperty(""ИмяМетода"", ""MethodName"")]
		|        public string MethodName { get; set; }
		|
		|        [ContextProperty(""Параметр"", ""Parameter"")]
		|        public IValue Parameter { get; set; }
		|
		|        [ContextProperty(""Сценарий"", ""Script"")]
		|        public IRuntimeContextInstance Script { get; set; }
		|    }
		|}
		|";
		ТекстДокХХХ = Новый ТекстовыйДокумент;
		ТекстДокХХХ.УстановитьТекст(СтрВыгрузки);
		ТекстДокХХХ.Записать(КаталогВыгрузки + "\" + ИмяФайлаТФ + ".cs");
	ИначеЕсли ИмяФайлаТФ = "OneScriptTerminalGui" Тогда
		СтрВыгрузки = СтрВыгрузки + 
		"using System;
		|using System.IO;
		|using System.Collections;
		|using System.Text;
		|using ScriptEngine.Machine.Contexts;
		|using ScriptEngine.Machine;
		|using ScriptEngine.HostedScript.Library;
		|using System.Collections.Generic;
		|using Terminal.Gui;
		|using System.Reflection;
		|
		|namespace ostgui
		|{
		|    [ContextClass(""ТерминалФормыДляОдноСкрипта"", ""OneScriptTerminalGui"")]
		|    public class OneScriptTerminalGui : AutoContext<OneScriptTerminalGui>
		|    {
		|        public static TfToplevel top;
		|        public static System.Collections.Hashtable hashtable = new Hashtable();
		|        public static OneScriptTerminalGui instance;
		|        private static object syncRoot = new Object();
		|        public static TfEventArgs Event = null;
		|        public static bool handleEvents = true;
		|        public static Dictionary<decimal, ArrayList> shortcutDictionary = new Dictionary<decimal, ArrayList>();
		|        public static int lastMeX = -1;
		|        public static int lastMeY = -1;
		|        public static long lastEventTime = DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;
		|
		|        static byte[] StreamToBytes(Stream input)
		|        {
		|            var capacity = input.CanSeek ? (int)input.Length : 0;
		|            using (var output = new MemoryStream(capacity))
		|            {
		|                int readLength;
		|                var buffer = new byte[4096];
		|                do
		|                {
		|                    readLength = input.Read(buffer, 0, buffer.Length);
		|                    output.Write(buffer, 0, readLength);
		|                }
		|                while (readLength != 0);
		|                return output.ToArray();
		|            }
		|        }
		|
		|        public static OneScriptTerminalGui getInstance()
		|        {
		|            if (instance == null)
		|            {
		|                lock (syncRoot)
		|                {
		|                    if (instance == null)
		|                    {
		|                        instance = new OneScriptTerminalGui();
		|                    }
		|                }
		|            }
		|            return instance;
		|        }
		|
		|        [ScriptConstructor]
		|        public static IRuntimeContextInstance Constructor()
		|        {
		|            AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =>
		|            {
		|                string resourcepath = ""ostgui."" + new AssemblyName(args.Name).Name + "".dll"";
		|                if (Assembly.GetExecutingAssembly().GetName().Name == ""OneScriptTerminalGui"" &&
		|                    resourcepath != ""ostgui.Terminal.Gui.dll"")
		|                {
		|                    var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourcepath);
		|                    if (stream != null)
		|                    {
		|                        using (stream)
		|                        {
		|                            return Assembly.Load(StreamToBytes(stream));
		|                        }
		|                    }
		|                }
		|                return null;
		|            };
		|
		|            OnOpen = delegate ()
		|            {
		|                if (instance.NotifyNewRunState != null)
		|                {
		|                    TfEventArgs TfEventArgs1 = new TfEventArgs();
		|                    TfEventArgs1.sender = instance;
		|                    TfEventArgs1.parameter = OneScriptTerminalGui.GetEventParameter(instance.NotifyNewRunState);
		|                    OneScriptTerminalGui.Event = TfEventArgs1;
		|                    OneScriptTerminalGui.ExecuteEvent(instance.NotifyNewRunState);
		|                }
		|            };
		|
		|            OneScriptTerminalGui inst = getInstance();
		|            return inst;
		|        }
		|
		|        static Action OnOpen;
		|        private static void Application_NotifyNewRunState(Application.RunState obj)
		|        {
		|            OnOpen.Invoke();
		|        }
		|
		|        [ContextProperty(""РазмерИзменен"", ""Resized"")]
		|        public TfAction Resized { get; set; }
		|
		|        public static SystemGlobalContext GlobalContext()
		|        {
		|            return GlobalsManager.GetGlobalContext<SystemGlobalContext>();
		|        }
		|
		|        private decimal quitKey;
		|        [ContextProperty(""КлавишаВыхода"", ""QuitKey"")]
		|        public decimal QuitKey
		|        {
		|            get { return quitKey; }
		|            set { quitKey = value; }
		|        }
		|
		|        private static TfConsoleKey tf_ConsoleKey = new TfConsoleKey();
		|        [ContextProperty(""КлавишиКонсоли"", ""ConsoleKey"")]
		|        public TfConsoleKey ConsoleKey
		|        {
		|            get { return tf_ConsoleKey; }
		|        }
		|
		|        private static TfCommandTUI tf_CommandTUI = new TfCommandTUI();
		|        [ContextProperty(""КомандаTUI"", ""CommandTUI"")]
		|        public TfCommandTUI CommandTUI
		|        {
		|            get { return tf_CommandTUI; }
		|        }
		|
		|        [ContextMethod(""Эмодзи"", ""Emoji"")]
		|        public string Emoji(IValue p1)
		|        {
		|            var sb = new StringBuilder();
		|            if (p1.SystemType.Name == ""Число"")
		|            {
		|                try
		|                {
		|                    sb.Append(Char.ConvertFromUtf32(Convert.ToInt32(p1.AsNumber()))).ToString();
		|                }
		|                catch { }
		|            }
		|            else if (p1.SystemType.Name == ""Строка"")
		|            {
		|                string p2 = p1.AsString();
		|                p2 = p2.Replace(""0x"", """").Replace(""0х"", """").Replace(""\\u"", """");
		|                try
		|                {
		|                    try
		|                    {
		|                        int num = Convert.ToInt32(p2);
		|                        string str = Char.ConvertFromUtf32(num);
		|                        sb.Append(str).ToString();
		|                    }
		|                    catch
		|                    {
		|                        int num = Convert.ToInt32(p2, 16);
		|                        string str = Char.ConvertFromUtf32(num);
		|                        sb.Append(str).ToString();
		|                    }
		|                }
		|                catch { }
		|            }
		|            return sb.ToString();
		|        }
		|
		|        [ContextProperty(""Высота"", ""Rows"")]
		|        public int Rows
		|        {
		|            get { return Application.Driver.Rows; }
		|        }
		|
		|        [ContextProperty(""Ширина"", ""Cols"")]
		|        public int Cols
		|        {
		|            get { return Application.Driver.Cols; }
		|        }
		|
		|        [ContextMethod(""КлавишаВвод"", ""ButtonEnter"")]
		|        public void ButtonEnter()
		|        {
		|            Application.Driver.SendKeys(System.Char.MinValue, System.ConsoleKey.Enter, false, false, false);
		|        }
		|
		|        [ContextMethod(""ПраваяКвадратная"", ""RightBracket"")]
		|        public string RightBracket()
		|        {
		|            return Application.Driver.RightBracket.ToString();
		|        }
		|
		|        [ContextMethod(""ЛеваяКвадратная"", ""LeftBracket"")]
		|        public string LeftBracket()
		|        {
		|            return Application.Driver.LeftBracket.ToString();
		|        }
		|
		|        [ContextMethod(""МалыйБлок"", ""BlocksMeterSegment"")]
		|        public string BlocksMeterSegment()
		|        {
		|            return Application.Driver.BlocksMeterSegment.ToString();
		|        }
		|
		|        [ContextMethod(""БольшойБлок"", ""ContinuousMeterSegment"")]
		|        public string ContinuousMeterSegment()
		|        {
		|            return Application.Driver.ContinuousMeterSegment.ToString();
		|        }
		|
		|        [ContextMethod(""ЛевыйИндикатор"", ""LeftDefaultIndicator"")]
		|        public string LeftDefaultIndicator()
		|        {
		|            return Application.Driver.LeftDefaultIndicator.ToString();
		|        }
		|
		|        [ContextMethod(""ПравыйИндикатор"", ""RightDefaultIndicator"")]
		|        public string RightDefaultIndicator()
		|        {
		|            return Application.Driver.RightDefaultIndicator.ToString();
		|        }
		|
		|        [ContextMethod(""ВерхняяСтрелка"", ""ArrowUp"")]
		|        public string ArrowUp()
		|        {
		|            return Application.Driver.UpArrow.ToString();
		|        }
		|
		|        [ContextMethod(""ЛеваяСтрелка"", ""ArrowLeft"")]
		|        public string ArrowLeft()
		|        {
		|            return Application.Driver.LeftArrow.ToString();
		|        }
		|
		|       [ContextMethod(""НижняяСтрелка"", ""ArrowDown"")]
		|        public string ArrowDown()
		|        {
		|            return Application.Driver.DownArrow.ToString();
		|        }
		|
		|       [ContextMethod(""ПраваяСтрелка"", ""ArrowRight"")]
		|        public string ArrowRight()
		|        {
		|            return Application.Driver.RightArrow.ToString();
		|        }
		|
		|       [ContextMethod(""ВерхнийТройник"", ""TopTee"")]
		|        public string TopTee()
		|        {
		|            return Application.Driver.TopTee.ToString();
		|        }
		|
		|       [ContextMethod(""ЛевыйТройник"", ""LeftTee"")]
		|        public string LeftTee()
		|        {
		|            return Application.Driver.LeftTee.ToString();
		|        }
		|
		|       [ContextMethod(""НижнийТройник"", ""BottomTee"")]
		|        public string BottomTee()
		|        {
		|            return Application.Driver.BottomTee.ToString();
		|        }
		|
		|       [ContextMethod(""ПравыйТройник"", ""RightTee"")]
		|        public string RightTee()
		|        {
		|            return Application.Driver.RightTee.ToString();
		|        }
		|
		|        [ContextMethod(""Пометка"", ""Checked"")]
		|        public string Checked()
		|        {
		|            return Application.Driver.Checked.ToString();
		|        }
		|
		|        [ContextMethod(""Алмаз"", ""Diamond"")]
		|        public string Diamond()
		|        {
		|            return Application.Driver.Diamond.ToString();
		|        }
		|
		|        [ContextMethod(""ДвойнаяГоризонтальная"", ""HDLine"")]
		|        public string HDLine()
		|        {
		|            return Application.Driver.HDLine.ToString();
		|        }
		|
		|        [ContextMethod(""Горизонтальная"", ""HLine"")]
		|        public string HLine()
		|        {
		|            return Application.Driver.HLine.ToString();
		|        }
		|
		|        [ContextMethod(""ГоризонтальнаяСЗакругленнымиУглами"", ""HRLine"")]
		|        public string HRLine()
		|        {
		|            return Application.Driver.HRLine.ToString();
		|        }
		|
		|        [ContextMethod(""НижнийЛевыйУгол"", ""LLCorner"")]
		|        public string LLCorner()
		|        {
		|            return Application.Driver.LLCorner.ToString();
		|        }
		|
		|        [ContextMethod(""НижнийЛевыйДвойнойУгол"", ""LLDCorner"")]
		|        public string LLDCorner()
		|        {
		|            return Application.Driver.LLDCorner.ToString();
		|        }
		|
		|        [ContextMethod(""НижнийЛевыйЗакругленныйУгол"", ""LLRCorner"")]
		|        public string LLRCorner()
		|        {
		|            return Application.Driver.LLRCorner.ToString();
		|        }
		|
		|        [ContextMethod(""НижнийПравыйУгол"", ""LRCorner"")]
		|        public string LRCorner()
		|        {
		|            return Application.Driver.LRCorner.ToString();
		|        }
		|
		|        [ContextMethod(""НижнийПравыйДвойнойУгол"", ""LRDCorner"")]
		|        public string LRDCorner()
		|        {
		|            return Application.Driver.LRDCorner.ToString();
		|        }
		|
		|        [ContextMethod(""НижнийПравыйЗакругленныйУгол"", ""LRRCorner"")]
		|        public string LRRCorner()
		|        {
		|            return Application.Driver.LRRCorner.ToString();
		|        }
		|
		|        [ContextMethod(""Выделенный"", ""Selected"")]
		|        public string Selected()
		|        {
		|            return Application.Driver.Selected.ToString();
		|        }
		|
		|        [ContextMethod(""Точечный"", ""Stipple"")]
		|        public string Stipple()
		|        {
		|            return Application.Driver.Stipple.ToString();
		|        }
		|
		|        [ContextMethod(""ВерхнийЛевыйУгол"", ""ULCorner"")]
		|        public string ULCorner()
		|        {
		|            return Application.Driver.ULCorner.ToString();
		|        }
		|
		|        [ContextMethod(""ВерхнийЛевыйДвойнойУгол"", ""ULDCorner"")]
		|        public string ULDCorner()
		|        {
		|            return Application.Driver.ULDCorner.ToString();
		|        }
		|
		|        [ContextMethod(""ВерхнийЛевыйЗакругленныйУгол"", ""ULRCorner"")]
		|        public string ULRCorner()
		|        {
		|            return Application.Driver.ULRCorner.ToString();
		|        }
		|
		|        [ContextMethod(""БезПометки"", ""UnChecked"")]
		|        public string UnChecked()
		|        {
		|            return Application.Driver.UnChecked.ToString();
		|        }
		|
		|        [ContextMethod(""БезВыделения"", ""UnSelected"")]
		|        public string UnSelected()
		|        {
		|            return Application.Driver.UnSelected.ToString();
		|        }
		|
		|        [ContextMethod(""ВерхнийПравыйУгол"", ""URCorner"")]
		|        public string URCorner()
		|        {
		|            return Application.Driver.URCorner.ToString();
		|        }
		|
		|        [ContextMethod(""ВерхнийПравыйДвойнойУгол"", ""URDCorner"")]
		|        public string URDCorner()
		|        {
		|            return Application.Driver.URDCorner.ToString();
		|        }
		|
		|        [ContextMethod(""ВерхнийПравыйЗакругленныйУгол"", ""URRCorner"")]
		|        public string URRCorner()
		|        {
		|            return Application.Driver.URRCorner.ToString();
		|        }
		|
		|        [ContextMethod(""ВертикальнаяДвойная"", ""VDLine"")]
		|        public string VDLine()
		|        {
		|            return Application.Driver.VDLine.ToString();
		|        }
		|
		|        [ContextMethod(""Вертикальная"", ""VLine"")]
		|        public string VLine()
		|        {
		|            return Application.Driver.VLine.ToString();
		|        }
		|
		|        [ContextMethod(""ВертикальнаяСЗакругленнымиУглами"", ""VRLine"")]
		|        public string VRLine()
		|        {
		|            return Application.Driver.VRLine.ToString();
		|        }
		|
		|        [ContextMethod(""Таймер"", ""Timer"")]
		|        public TfTimer Timer()
		|        {
		|            return new TfTimer();
		|        }
		|
		|        [ContextMethod(""ОкноСообщений"", ""MessageBox"")]
		|        public TfMessageBox MessageBox()
		|        {
		|            return new TfMessageBox();
		|        }
		|
		|        [ContextMethod(""ОтправитьКлавиши"", ""SendKeys"")]
		|        public void SendKeys(string p1, bool p3, bool p4, bool p5)
		|        {
		|            System.Char char1 = Convert.ToChar(p1.Substring(0, 1));
		|            Application.Driver.SendKeys(char1, (System.ConsoleKey)0, p3, p4, p5);
		|        }
		|
		|        [ContextProperty(""ТекстБуфераОбмена"", ""ClipboardText"")]
		|        public string ClipboardText
		|        {
		|            get { return Terminal.Gui.Clipboard.Contents.ToString(); }
		|            set { Terminal.Gui.Clipboard.Contents = value; }
		|        }
		|
		|        [ContextMethod(""СтрокаСостояния"", ""StatusBar"")]
		|        public TfStatusBar StatusBar()
		|        {
		|            return new TfStatusBar();
		|        }
		|
		|        [ContextMethod(""Выполнить"", ""Execute"")]
		|        public IValue Execute(TfAction p1)
		|        {
		|            TfEventArgs eventArgs = new TfEventArgs();
		|            eventArgs.sender = instance;
		|            eventArgs.parameter = OneScriptTerminalGui.GetEventParameter(p1);
		|            Event = eventArgs;
		|
		|            TfAction Action1 = p1;
		|            IRuntimeContextInstance script = Action1.Script;
		|            string method = Action1.MethodName;
		|            ReflectorContext reflector = new ReflectorContext();
		|            IValue res = ValueFactory.Create();
		|            try
		|            {
		|                res = reflector.CallMethod(script, method, null);
		|            }
		|            catch (Exception ex)
		|            {
		|                GlobalContext().Echo(""Ошибка2: "" + ex.Message);
		|            }
		|            return res;
		|        }
		|
		|        [ContextProperty(""ПриОткрытии"", ""NotifyNewRunState"")]
		|        public TfAction NotifyNewRunState { get; set; }
		|
		|        [ContextMethod(""ЭлементМеню"", ""MenuItem"")]
		|        public TfMenuItem MenuItem()
		|        {
		|            return new TfMenuItem();
		|        }
		|
		|        [ContextProperty(""Цвета"", ""Colors"")]
		|        public TfColors Colors
		|        {
		|            get { return new TfColors(); }
		|        }
		|
		|        [ContextMethod(""Толщина"", ""Thickness"")]
		|        public TfThickness Thickness(IValue p1, IValue p2 = null, IValue p3 = null, IValue p4 = null)
		|        {
		|            if (p2 != null && p3 != null && p4 != null)
		|            {
		|                return new TfThickness(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()), Convert.ToInt32(p3.AsNumber()), Convert.ToInt32(p4.AsNumber()));
		|            }
		|            return new TfThickness(Convert.ToInt32(p1.AsNumber()));
		|        }
		|
		|        [ContextMethod(""ЭлементСтрокиСостояния"", ""StatusItem"")]
		|        public TfStatusItem StatusItem(int p1, string p2)
		|        {
		|            return new TfStatusItem(p1, p2);
		|        }
		|
		|        [ContextMethod(""ПунктМеню"", ""MenuBarItem"")]
		|        public TfMenuBarItem MenuBarItem()
		|        {
		|            return new TfMenuBarItem();
		|        }
		|
		|        [ContextMethod(""ПанельМеню"", ""MenuBar"")]
		|        public TfMenuBar MenuBar()
		|        {
		|            return new TfMenuBar();
		|        }
		|
		|        [ContextMethod(""ДобавитьВесьТекст"", ""AppendAllText"")]
		|        public void AppendAllText(string p1, string p2)
		|        {
		|            File.AppendAllText(p1, p2, Encoding.UTF8);
		|        }
		|
		|        [ContextProperty(""Величина"", ""Dim"")]
		|        public TfDim Dim
		|        {
		|            get { return new TfDim(); }
		|        }
		|
		|        [ContextProperty(""Позиция"", ""Pos"")]
		|        public TfPos Pos
		|        {
		|            get { return new TfPos(); }
		|        }
		|
		|        [ContextMethod(""Обновить"", ""Refresh"")]
		|        public void Refresh()
		|        {
		|            Application.Refresh();
		|        }
		|
		|        [ContextMethod(""Завершить"", ""Shutdown"")]
		|        public void Shutdown()
		|        {
		|            //Application.Shutdown();
		|            Application.RequestStop(Top.Base_obj.M_Toplevel);
		|        }
		|
		|        [ContextMethod(""ОформительТекста"", ""TextFormatter"")]
		|        public TfTextFormatter TextFormatter()
		|        {
		|            return new TfTextFormatter();
		|        }
		|
		|        [ContextMethod(""ЦветоваяСхема"", ""ColorScheme"")]
		|        public TfColorScheme ColorScheme()
		|        {
		|            return new TfColorScheme();
		|        }
		|
		|        [ContextMethod(""Атрибут"", ""Attribute"")]
		|        public TfAttribute Attribute(IValue p1 = null, IValue p2 = null, IValue p3 = null)
		|        {
		|            if (p1 == null && p2 == null && p3 == null)
		|            {
		|                return new TfAttribute();
		|            }
		|            else if (p1 != null && p2 == null && p3 == null)
		|            {
		|                if (p1.SystemType.Name == ""Число"")
		|                {
		|                    return new TfAttribute(Convert.ToInt32(p1.AsNumber()));
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 == null)
		|            {
		|                if (p1.SystemType.Name == ""Число"")
		|                {
		|                    return new TfAttribute(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()));
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 != null)
		|            {
		|                if (p1.SystemType.Name == ""Число"")
		|                {
		|                    return new TfAttribute(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()), Convert.ToInt32(p3.AsNumber()));
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        [ContextMethod(""ЗапуститьИЗавершить"", ""RunAndShutdown"")]
		|        public void RunAndShutdown()
		|        {
		|            //Top.CorrectionZet(); // Конфликтует с созданием меню.
		|            Application.Begin(top.Base_obj.M_Toplevel);
		|        }
		|
		|        [ContextMethod(""Запуск"", ""Run"")]
		|        public void Run()
		|        {
		|            //Top.CorrectionZet(); // Конфликтует с созданием меню.
		|            Application.Run();
		|        }
		|
		|        [ContextProperty(""РазрешитьСобытия"", ""AllowEvents"")]
		|        public bool HandleEvents
		|        {
		|            get { return handleEvents; }
		|            set { handleEvents = value; }
		|        }
		|
		|        public static dynamic GetEventParameter(dynamic dll_objEvent)
		|        {
		|            if (dll_objEvent != null)
		|            {
		|                dynamic eventType = dll_objEvent.GetType();
		|                if (eventType == typeof(DelegateAction))
		|                {
		|                    return null;
		|                }
		|                else if (eventType == typeof(TfAction))
		|                {
		|                    return ((TfAction)dll_objEvent).Parameter;
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        public static void ExecuteEvent(TfAction action)
		|        {
		|            if (!handleEvents)
		|            {
		|                return;
		|            }
		|            if (action == null)
		|            {
		|                return;
		|            }
		|            ReflectorContext reflector = new ReflectorContext();
		|            try
		|            {
		|                reflector.CallMethod(action.Script, action.MethodName, null);
		|            }
		|            catch (Exception ex)
		|            {
		|                GlobalContext().Echo(""Обработчик не выполнен: "" + action.MethodName + Environment.NewLine + ex.StackTrace);
		|            }
		|            Event = null;
		|            Application.Refresh();
		|        }
		|
		|        [ContextProperty(""Отправитель"", ""Sender"")]
		|        public IValue Sender
		|        {
		|            get { return RevertEqualsObj(Event.Sender); }
		|        }
		|
		|        [ContextProperty(""АргументыСобытия"", ""EventArgs"")]
		|        public TfEventArgs EventArgs
		|        {
		|            get { return Event; }
		|        }
		|
		|        private static TfVerticalTextAlignment tf_VerticalTextAlignment = new TfVerticalTextAlignment();
		|        [ContextProperty(""ВертикальноеВыравниваниеТекста"", ""VerticalTextAlignment"")]
		|        public TfVerticalTextAlignment VerticalTextAlignment
		|        {
		|            get { return tf_VerticalTextAlignment; }
		|        }
		|
		|        private static TfCursorVisibility tf_CursorVisibility = new TfCursorVisibility();
		|        [ContextProperty(""ВидКурсора"", ""CursorVisibility"")]
		|        public TfCursorVisibility CursorVisibility
		|        {
		|            get { return tf_CursorVisibility; }
		|        }
		|
		|        private static TfTextAlignment tf_TextAlignment = new TfTextAlignment();
		|        [ContextProperty(""ВыравниваниеТекста"", ""TextAlignment"")]
		|        public TfTextAlignment TextAlignment
		|        {
		|            get { return tf_TextAlignment; }
		|        }
		|
		|        private static TfKeys tf_Keys = new TfKeys();
		|        [ContextProperty(""Клавиши"", ""Keys"")]
		|        public TfKeys Keys
		|        {
		|            get { return tf_Keys; }
		|        }
		|
		|        private static TfTextDirection tf_TextDirection = new TfTextDirection();
		|        [ContextProperty(""НаправлениеТекста"", ""TextDirection"")]
		|        public TfTextDirection TextDirection
		|        {
		|            get { return tf_TextDirection; }
		|        }
		|
		|        private static TfLayoutStyle tf_LayoutStyle = new TfLayoutStyle();
		|        [ContextProperty(""СтильКомпоновки"", ""LayoutStyle"")]
		|        public TfLayoutStyle LayoutStyle
		|        {
		|            get { return tf_LayoutStyle; }
		|        }
		|
		|        private static TfMenuItemCheckStyle tf_MenuItemCheckStyle = new TfMenuItemCheckStyle();
		|        [ContextProperty(""СтильФлажкаЭлементаМеню"", ""MenuItemCheckStyle"")]
		|        public TfMenuItemCheckStyle MenuItemCheckStyle
		|        {
		|            get { return tf_MenuItemCheckStyle; }
		|        }
		|
		|        private static TfMouseFlags tf_MouseFlags = new TfMouseFlags();
		|        [ContextProperty(""ФлагиМыши"", ""MouseFlags"")]
		|        public TfMouseFlags MouseFlags
		|        {
		|            get { return tf_MouseFlags; }
		|        }
		|
		|        private static TfColor tf_Color = new TfColor();
		|        [ContextProperty(""Цвет"", ""Color"")]
		|        public TfColor Color
		|        {
		|            get { return tf_Color; }
		|        }
		|
		|        private static TfBorderStyle tf_BorderStyle = new TfBorderStyle();
		|        [ContextProperty(""СтильГраницы"", ""BorderStyle"")]
		|        public TfBorderStyle BorderStyle
		|        {
		|            get { return tf_BorderStyle; }
		|        }
		|
		|        [ContextMethod(""Граница"", ""Border"")]
		|        public TfBorder Border()
		|        {
		|            return new TfBorder();
		|        }
		|
		|        [ContextMethod(""Окно"", ""Window"")]
		|        public TfWindow Window(IValue p1 = null, IValue p2 = null, IValue p3 = null, IValue p4 = null)
		|        {
		|            if (p1 == null && p2 == null && p3 == null && p4 == null)
		|            {
		|                return new TfWindow();
		|            }
		|            else if (p1 != null && p2 == null && p3 == null && p4 == null)
		|            {
		|                if (p1.SystemType.Name == ""Строка"")
		|                {
		|                    return new TfWindow(p1.AsString());
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 == null && p4 == null)
		|            {
		|                if (p1.GetType() == typeof(TfRect) && p2.SystemType.Name == ""Строка"")
		|                {
		|                    return new TfWindow((TfRect)p1, p2.AsString());
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 != null && p4 == null)
		|            {
		|                if (p1.SystemType.Name == ""Строка"" && p2.SystemType.Name == ""Число"" && p3.GetType() == typeof(TfBorder))
		|                {
		|                    return new TfWindow(p1.AsString(), Convert.ToInt32(p2.AsNumber()), (TfBorder)p3);
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 != null && p4 != null)
		|            {
		|                if (p1.GetType() == typeof(TfRect) && p2.SystemType.Name == ""Строка"" && p3.SystemType.Name == ""Число"" && p4.GetType() == typeof(TfBorder))
		|                {
		|                    return new TfWindow((TfRect)p1, p2.AsString(), Convert.ToInt32(p3.AsNumber()), (TfBorder)p4);
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        [ContextMethod(""Действие"", ""Action"")]
		|        public TfAction Action(IRuntimeContextInstance script = null, string methodName = null, IValue param = null)
		|        {
		|            return new TfAction(script, methodName, param);
		|        }
		|
		|        [ContextMethod(""Активировать"", ""Init"")]
		|        public void Init()
		|        {
		|            Application.Init();
		|            try
		|            {
		|                Application.NotifyNewRunState += Application_NotifyNewRunState;
		|                top = new TfToplevel(Application.Top);
		|            }
		|            catch { }
		|        }
		|
		|        [ContextProperty(""Верхний"", ""Top"")]
		|        public TfToplevel Top
		|        {
		|            get { return top; }
		|        }
		|
		|        [ContextMethod(""Кнопка"", ""Button"")]
		|        public TfButton Button(IValue p1 = null, IValue p2 = null, IValue p3 = null, IValue p4 = null)
		|        {
		|            if (p1 == null && p2 == null && p3 == null && p4 == null)
		|            {
		|                return new TfButton();
		|            }
		|            else if (p1 != null && p2 != null && p3 != null && p4 != null)
		|            {
		|                if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"" && p3.SystemType.Name == ""Строка"" && p4.SystemType.Name == ""Булево"")
		|                {
		|                    return new TfButton(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()), p3.AsString(), p4.AsBoolean());
		|                }
		|                else if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"" && p3.SystemType.Name == ""Число"" && p4.SystemType.Name == ""Число"")
		|                {
		|                    TfButton TfButton1 = new TfButton();
		|                    TfButton1.Base_obj.M_Button.X = Terminal.Gui.Pos.At(Convert.ToInt32(p1.AsNumber()));
		|                    TfButton1.Base_obj.M_Button.Y = Terminal.Gui.Pos.At(Convert.ToInt32(p2.AsNumber()));
		|                    TfButton1.Base_obj.M_Button.Width = Terminal.Gui.Dim.Sized(Convert.ToInt32(p3.AsNumber()));
		|                    TfButton1.Base_obj.M_Button.Height = Terminal.Gui.Dim.Sized(Convert.ToInt32(p4.AsNumber()));
		|                    return TfButton1;
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 != null && p4 == null)
		|            {
		|                if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"" && p3.SystemType.Name == ""Строка"")
		|                {
		|                    return new TfButton(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()), p3.AsString());
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 == null && p4 == null)
		|            {
		|                if (p1.SystemType.Name == ""Строка"" && p2.SystemType.Name == ""Булево"")
		|                {
		|                    return new TfButton(p1.AsString(), p2.AsBoolean());
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 == null && p3 == null && p4 == null)
		|            {
		|                if (p1.SystemType.Name == ""Строка"")
		|                {
		|                    return new TfButton(p1.AsString());
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        public TfView View(IValue p1 = null, IValue p2 = null, IValue p3 = null)
		|        {
		|            if (p1 == null && p2 == null && p3 == null)
		|            {
		|                return new TfView();
		|            }
		|            else if (p1 != null && p2 == null && p3 == null)
		|            {
		|                if (p1.GetType() == typeof(TfRect))
		|                {
		|                    return new TfView((TfRect)p1);
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 != null)
		|            {
		|                if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"" && p3.SystemType.Name == ""Строка"")
		|                {
		|                    return new TfView(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()), p3.AsString());
		|                }
		|                else if (p1.GetType() == typeof(TfRect) && p2.SystemType.Name == ""Строка"" && p3.GetType() == typeof(TfBorder))
		|                {
		|                    return new TfView((TfRect)p1, p2.AsString(), (TfBorder)p3);
		|                }
		|                else if (p1.SystemType.Name == ""Строка"" && p2.SystemType.Name == ""Число"" && p3.GetType() == typeof(TfBorder))
		|                {
		|                    return new TfView(p1.AsString(), Convert.ToInt32(p2.AsNumber()), (TfBorder)p3);
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        [ContextMethod(""Размер"", ""Size"")]
		|        public TfSize Size(IValue p1 = null, IValue p2 = null)
		|        {
		|            if (p1 == null && p2 == null)
		|            {
		|                return new TfSize();
		|            }
		|            else if (p1 != null && p2 != null)
		|            {
		|                if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"")
		|                {
		|                    return new TfSize(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()));
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        [ContextMethod(""Прямоугольник"", ""Rect"")]
		|        public TfRect Rect(IValue p1 = null, IValue p2 = null, IValue p3 = null, IValue p4 = null)
		|        {
		|            if (p1 == null && p2 == null && p3 == null && p4 == null)
		|            {
		|                return new TfRect();
		|            }
		|            else if (p1 != null && p2 != null && p3 == null && p4 == null)
		|            {
		|                if (p1.GetType() == typeof(TfPoint) && p2.GetType() == typeof(TfSize))
		|                {
		|                    return new TfRect((TfPoint)p1, (TfSize)p2);
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 != null && p3 != null && p4 != null)
		|            {
		|                if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"" && p3.SystemType.Name == ""Число"" && p4.SystemType.Name == ""Число"")
		|                {
		|                    return new TfRect(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()), Convert.ToInt32(p3.AsNumber()), Convert.ToInt32(p4.AsNumber()));
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        [ContextMethod(""Точка"", ""Point"")]
		|        public TfPoint Rect(IValue p1 = null, IValue p2 = null)
		|        {
		|            if (p1 == null && p2 == null)
		|            {
		|                return new TfPoint();
		|            }
		|            else if (p1 != null && p2 != null)
		|            {
		|                if (p1.SystemType.Name == ""Число"" && p2.SystemType.Name == ""Число"")
		|                {
		|                    return new TfPoint(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()));
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else if (p1 != null && p2 == null)
		|            {
		|                if (p1.GetType() == typeof(TfSize))
		|                {
		|                    return new TfPoint((TfSize)p1);
		|                }
		|                else
		|                {
		|                    return null;
		|                }
		|            }
		|            else
		|            {
		|                return null;
		|            }
		|        }
		|
		|        [ContextMethod(""Верхний"", ""Toplevel"")]
		|        public TfToplevel Toplevel(IValue p1 = null, IValue p2 = null, IValue p3 = null, IValue p4 = null)
		|        {
		|            if (p1 != null)
		|            {
		|                if (p1.GetType() == typeof(TfRect))
		|                {
		|                    return new TfToplevel((TfRect)p1);
		|                }
		|                else if (p1.SystemType.Name == ""Число"")
		|                {
		|                    TfRect TfRect1 = new TfRect(Convert.ToInt32(p1.AsNumber()), Convert.ToInt32(p2.AsNumber()), Convert.ToInt32(p3.AsNumber()), Convert.ToInt32(p4.AsNumber()));
		|                    return new TfToplevel(TfRect1);
		|                }
		|            }
		|            return new TfToplevel();
		|        }
		|
		|        public static System.Collections.ArrayList StrFindBetween(string p1, string p2 = null, string p3 = null, bool p4 = true, bool p5 = true)
		|        {
		|            //p1 - исходная строка
		|            //p2 - подстрока поиска от которой ведем поиск
		|            //p3 - подстрока поиска до которой ведем поиск
		|            //p4 - не включать p2 и p3 в результат
		|            //p5 - в результат не будут включены участки, содержащие другие найденные участки, удовлетворяющие переданным параметрам
		|            //функция возвращает массив строк
		|            string str1 = p1;
		|            int Position1;
		|            System.Collections.ArrayList ArrayList1 = new System.Collections.ArrayList();
		|            if (p2 != null && p3 == null)
		|            {
		|                Position1 = str1.IndexOf(p2);
		|                while (Position1 >= 0)
		|                {
		|                    ArrayList1.Add(ValueFactory.Create("""" + ((p4) ? str1.Substring(Position1 + p2.Length) : str1.Substring(Position1))));
		|                    str1 = str1.Substring(Position1 + 1);
		|                    Position1 = str1.IndexOf(p2);
		|                }
		|            }
		|            else if (p2 == null && p3 != null)
		|            {
		|                Position1 = str1.IndexOf(p3) + 1;
		|                int SumPosition1 = Position1;
		|                while (Position1 > 0)
		|                {
		|                    ArrayList1.Add(ValueFactory.Create("""" + ((p4) ? str1.Substring(0, SumPosition1 - 1) : str1.Substring(0, SumPosition1 - 1 + p3.Length))));
		|                    try
		|                    {
		|                        Position1 = str1.Substring(SumPosition1 + 1).IndexOf(p3) + 1;
		|                        SumPosition1 = SumPosition1 + Position1 + 1;
		|                    }
		|                    catch
		|                    {
		|                        break;
		|                    }
		|                }
		|            }
		|            else if (p2 != null && p3 != null)
		|            {
		|                Position1 = str1.IndexOf(p2);
		|                while (Position1 >= 0)
		|                {
		|                    string Стр2;
		|                    Стр2 = (p4) ? str1.Substring(Position1 + p2.Length) : str1.Substring(Position1);
		|                    int Position2 = Стр2.IndexOf(p3) + 1;
		|                    int SumPosition2 = Position2;
		|                    while (Position2 > 0)
		|                    {
		|                        if (p5)
		|                        {
		|                            if (Стр2.Substring(0, SumPosition2 - 1).IndexOf(p3) <= -1)
		|                            {
		|                                ArrayList1.Add(ValueFactory.Create("""" + ((p4) ? Стр2.Substring(0, SumPosition2 - 1) : Стр2.Substring(0, SumPosition2 - 1 + p3.Length))));
		|                            }
		|                        }
		|                        else
		|                        {
		|                            ArrayList1.Add(ValueFactory.Create("""" + ((p4) ? Стр2.Substring(0, SumPosition2 - 1) : Стр2.Substring(0, SumPosition2 - 1 + p3.Length))));
		|                        }
		|                        try
		|                        {
		|                            Position2 = Стр2.Substring(SumPosition2 + 1).IndexOf(p3) + 1;
		|                            SumPosition2 = SumPosition2 + Position2 + 1;
		|                        }
		|                        catch
		|                        {
		|                            break;
		|
		|                        }
		|                    }
		|                    str1 = str1.Substring(Position1 + 1);
		|                    Position1 = str1.IndexOf(p2);
		|                }
		|            }
		|            return ArrayList1;
		|        }
		|
		|        public static void AddToHashtable(dynamic p1, dynamic p2)
		|        {
		|            if (!hashtable.ContainsKey(p1))
		|            {
		|                hashtable.Add(p1, p2);
		|            }
		|            else
		|            {
		|                if (!((object)hashtable[p1]).Equals(p2))
		|                {
		|                    hashtable[p1] = p2;
		|                }
		|            }
		|        }
		|
		|        public static void AddToShortcutDictionary(decimal p1, IValue p2)
		|        {
		|            if (!shortcutDictionary.ContainsKey(p1))
		|            {
		|                ArrayList ArrayList1 = new ArrayList();
		|                ArrayList1.Add(p2);
		|                shortcutDictionary.Add(p1, ArrayList1);
		|            }
		|            else
		|            {
		|                ArrayList ArrayList1 = shortcutDictionary[p1];
		|                if (!ArrayList1.Contains(p2))
		|                {
		|                    ArrayList1.Add(p2);
		|                }
		|            }
		|        }
		|
		|        public static void RemoveFromShortcutDictionary(decimal p1, IValue p2)
		|        {
		|            if (shortcutDictionary.ContainsKey(p1))
		|            {
		|                try
		|                {
		|                    shortcutDictionary[p1].Remove(p2);
		|                }
		|                catch { }
		|            }
		|        }
		|
		|        public static ArrayList GetFromShortcutDictionary(IValue p1)
		|        {
		|            ArrayList ArrayList1 = new ArrayList();
		|            foreach (var item in shortcutDictionary)
		|            {
		|                for (int i = 0; i < item.Value.Count; i++)
		|                {
		|                    if (item.Value[i] == p1)
		|                    {
		|                        ArrayList1.Add(item.Key);
		|                    }
		|                }
		|            }
		|            return ArrayList1;
		|        }
		|
		|        public static dynamic RevertShortcut(dynamic shortcut)
		|        {
		|            try
		|            {
		|                return shortcutDictionary[shortcut];
		|            }
		|            catch
		|            {
		|                return null;
		|            }
		|        }
		|
		|        public static dynamic RevertEqualsObj(dynamic initialObject)
		|        {
		|            try
		|            {
		|                return hashtable[initialObject];
		|            }
		|            catch
		|            {
		|                return null;
		|            }
		|        }
		|
		|        public static IValue RevertObj(dynamic initialObject)
		|        {
		|            //ScriptEngine.Machine.Values.NullValue NullValue1;
		|            //ScriptEngine.Machine.Values.BooleanValue BooleanValue1;
		|            //ScriptEngine.Machine.Values.DateValue DateValue1;
		|            //ScriptEngine.Machine.Values.NumberValue NumberValue1;
		|            //ScriptEngine.Machine.Values.StringValue StringValue1;
		|
		|            //ScriptEngine.Machine.Values.GenericValue GenericValue1;
		|            //ScriptEngine.Machine.Values.TypeTypeValue TypeTypeValue1;
		|            //ScriptEngine.Machine.Values.UndefinedValue UndefinedValue1;
		|
		|            // Если initialObject равен null.
		|            try
		|            {
		|                if (initialObject == null)
		|                {
		|                    return (IValue)null;
		|                }
		|            }
		|            catch { }
		|            // Если initialObject равен null.
		|            try
		|            {
		|                string str_initialObject = initialObject.GetType().ToString();
		|            }
		|            catch
		|            {
		|                return (IValue)null;
		|            }
		|            // initialObject не равен null
		|            dynamic Obj1 = null;
		|            string str1 = initialObject.GetType().ToString();
		|            // Если initialObject второго уровня и у него есть ссылка на третий уровень.
		|            try
		|            {
		|                Obj1 = initialObject.dll_obj;
		|            }
		|            catch { }
		|            if (Obj1 != null)
		|            {
		|                return (IValue)Obj1;
		|            }
		|            // если initialObject не из пространства имен onescriptgui, то есть Уровень1 и у него есть аналог в
		|            // пространстве имен ostgui с конструктором принимающим параметром initialObject
		|            try
		|            {
		|                if (!str1.Contains(""ostgui.""))
		|                {
		|                    string str2 = ""ostgui.Tf"" + str1.Substring(str1.LastIndexOf(""."") + 1);
		|                    System.Type TestType = System.Type.GetType(str2, false, true);
		|                    object[] args = { initialObject };
		|                    Obj1 = Activator.CreateInstance(TestType, args);
		|                }
		|            }
		|            catch { }
		|            if (Obj1 != null)
		|            {
		|                return (IValue)Obj1;
		|            }
		|            // если initialObject из пространства имен onescriptgui, то есть Уровень2 и у него есть аналог в
		|            // пространстве имен ostgui с конструктором принимающим параметром initialObject
		|            try
		|            {
		|                if (str1.Contains(""ostgui.""))
		|                {
		|                    string str3 = str1.Replace(""ostgui."", ""ostgui.Tf"");
		|                    System.Type TestType = System.Type.GetType(str3, false, true);
		|                    object[] args = { initialObject };
		|                    Obj1 = Activator.CreateInstance(TestType, args);
		|                }
		|            }
		|            catch { }
		|            if (Obj1 != null)
		|            {
		|                return (IValue)Obj1;
		|            }
		|            // Если initialObject с возможными другими типами.
		|            string str4 = null;
		|            try
		|            {
		|                str4 = initialObject.SystemType.Name;
		|            }
		|            catch
		|            {
		|                if ((str1 == ""System.String"") ||
		|                (str1 == ""System.Decimal"") ||
		|                (str1 == ""System.Int32"") ||
		|                (str1 == ""System.Boolean"") ||
		|                (str1 == ""System.DateTime""))
		|                {
		|                    return (IValue)ValueFactory.Create(initialObject);
		|                }
		|                else if (str1 == ""System.Byte"")
		|                {
		|                    int vOut = Convert.ToInt32(initialObject);
		|                    return (IValue)ValueFactory.Create(vOut);
		|                }
		|                else if (str1 == ""System.DBNull"")
		|                {
		|                    string vOut = Convert.ToString(initialObject);
		|                    return (IValue)ValueFactory.Create(vOut);
		|                }
		|            }
		|            // Если тип initialObject определяется односкриптом.
		|            if (str4 == ""Неопределено"")
		|            {
		|                return (IValue)null;
		|            }
		|            if (str4 == ""Булево"")
		|            {
		|                return (IValue)initialObject;
		|            }
		|            if (str4 == ""Дата"")
		|            {
		|                return (IValue)initialObject;
		|            }
		|            if (str4 == ""Число"")
		|            {
		|                return (IValue)initialObject;
		|            }
		|            if (str4 == ""Строка"")
		|            {
		|                return (IValue)initialObject;
		|            }
		|            // Если ничего не подходит.
		|            return (IValue)initialObject;
		|        }
		|
		|        public static void WriteToFile(string str)
		|        {
		|            // добавление в файл
		|            using (System.IO.StreamWriter writer = new System.IO.StreamWriter(""C:\\444\\Ошибки.txt"", true, Encoding.UTF8))
		|            {
		|                writer.WriteLineAsync(str);
		|            }
		|        }
		|    }
		|}
		|";
		ТекстДокХХХ = Новый ТекстовыйДокумент;
		ТекстДокХХХ.УстановитьТекст(СтрВыгрузки);
		ТекстДокХХХ.Записать(КаталогВыгрузки + "\" + ИмяФайлаТФ + ".cs");
	КонецЕсли;
	
	
	СтрФайла = 
	"ifeq ($(OS),Windows_NT)
	|    EXEC := maketables --tables=all --url=https://www.unicode.org/Public/15.0.0/ucd/ > Tables.cs
	|else
	|    EXEC := ./maketables --tables=all --url=https://www.unicode.org/Public/15.0.0/ucd/ > Tables.cs
	|endif
	|
	|tables: unicodeData caseFolding maketables
	|	$(EXEC)
	|
	|unicodeData:
	|	curl -O https://www.unicode.org/Public/15.0.0/ucd/UnicodeData.txt
	|
	|caseFolding:
	|	curl -O https://www.unicode.org/Public/15.0.0/ucd/CaseFolding.txt
	|
	|maketables: maketables.go
	|	go build maketables.go
	|";
	ТекстДокХХХ = Новый ТекстовыйДокумент;
	ТекстДокХХХ.УстановитьТекст(СтрФайла);
	ТекстДокХХХ.Записать(КаталогВыгрузки + "\Makefile");
	
	СтрФайла = 
	"
	|// Modified to generate C# - the current code does not take ordering into consideration
	|// so that needs to be fixed.
	|//
	|// Additionally the encoding will likely change to a more efficient storage format that
	|// we can initialize from a blob, rather than constructing all these strongly typed
	|// structures that we produce now
	|//
	|// Last import from Go code: 8eca08611ac1c65622400f526ab5b9065a4c9d67
	|
	|// Copyright 2009 The Go Authors, Microsoft. All rights reserved.
	|// Use of this source code is governed by a BSD-style
	|// license that can be found in the LICENSE file.
	|//
	|// NOTES:
	|//    Dictionary ctors should probably come after the actual things they reference
	|
	|//go:build ignore
	|// +build ignore
	|
	|// Unicode table generator.
	|// Data read from the web.
	|
	|package main
	|
	|import (
	|	""bufio""
	|	""flag""
	|	""fmt""
	|	""io""
	|	""log""
	|	""net/http""
	|	""os""
	|	""os/exec""
	|	""path/filepath""
	|	""regexp""
	|	""sort""
	|	""strconv""
	|	""strings""
	|	""unicode""
	|)
	|
	|func main() {
	|	flag.Parse()
	|	setupOutput()
	|	loadChars() // always needed
	|	loadCasefold()
	|	printCategories()
	|	printScriptOrProperty(false)
	|	printScriptOrProperty(true)
	|	printCases()
	|	printLatinProperties()
	|	printCasefold()
	|	printSizes()
	|	printf(""} /* partial class Unicode */\n"")
	|	printf(""} /* namespace */\n"")
	|	flushOutput()
	|}
	|
	|var dataURL = flag.String(""data"", """", ""full URL for UnicodeData.txt; defaults to --url/UnicodeData.txt"")
	|var casefoldingURL = flag.String(""casefolding"", """", ""full URL for CaseFolding.txt; defaults to --url/CaseFolding.txt"")
	|var url = flag.String(""url"",
	|	""https://www.unicode.org/Public/15.0.0/ucd/"",
	|	""URL of Unicode database directory"")
	|var tablelist = flag.String(""tables"",
	|	""all"",
	|	""comma-separated list of which tables to generate; can be letter"")
	|var scriptlist = flag.String(""scripts"",
	|	""all"",
	|	""comma-separated list of which script tables to generate"")
	|var proplist = flag.String(""props"",
	|	""all"",
	|	""comma-separated list of which property tables to generate"")
	|var cases = flag.Bool(""cases"",
	|	true,
	|	""generate case tables"")
	|var test = flag.Bool(""test"",
	|	false,
	|	""test existing tables; can be used to compare web data with package data"")
	|var localFiles = flag.Bool(""local"",
	|	false,
	|	""data files have been copied to current directory; for debugging only"")
	|var outputFile = flag.String(""output"",
	|	"""",
	|	""output file for generated tables; default stdout"")
	|
	|var scriptRe = regexp.MustCompile(`^([0-9A-F]+)(\.\.[0-9A-F]+)? *; ([A-Za-z_]+)$`)
	|var logger = log.New(os.Stderr, """", log.Lshortfile)
	|
	|var output *bufio.Writer // points to os.Stdout or to ""gofmt > outputFile""
	|
	|func setupOutput() {
	|	output = bufio.NewWriter(startGofmt())
	|}
	|
	|// startGofmt connects output to a gofmt process if -output is set.
	|func startGofmt() io.Writer {
	|	if *outputFile == """" {
	|		return os.Stdout
	|	}
	|	stdout, err := os.Create(*outputFile)
	|	if err != nil {
	|		logger.Fatal(err)
	|	}
	|	// Pipe output to gofmt.
	|	gofmt := exec.Command(""gofmt"")
	|	fd, err := gofmt.StdinPipe()
	|	if err != nil {
	|		logger.Fatal(err)
	|	}
	|	gofmt.Stdout = stdout
	|	gofmt.Stderr = os.Stderr
	|	err = gofmt.Start()
	|	if err != nil {
	|		logger.Fatal(err)
	|	}
	|	return fd
	|}
	|
	|func flushOutput() {
	|	err := output.Flush()
	|	if err != nil {
	|		logger.Fatal(err)
	|	}
	|}
	|
	|func printf(format string, args ...interface{}) {
	|	fmt.Fprintf(output, format, args...)
	|}
	|
	|func print(args ...interface{}) {
	|	fmt.Fprint(output, args...)
	|}
	|
	|func println(args ...interface{}) {
	|	fmt.Fprintln(output, args...)
	|}
	|
	|type reader struct {
	|	*bufio.Reader
	|	fd   *os.File
	|	resp *http.Response
	|}
	|
	|func open(url string) *reader {
	|	file := filepath.Base(url)
	|	if *localFiles {
	|		fd, err := os.Open(file)
	|		if err != nil {
	|			logger.Fatal(err)
	|		}
	|		return &reader{bufio.NewReader(fd), fd, nil}
	|	}
	|	resp, err := http.Get(url)
	|	if err != nil {
	|		logger.Fatal(err)
	|	}
	|	if resp.StatusCode != 200 {
	|		_, err := strconv.ParseInt(resp.Status, 10, 0)
	|		logger.Fatalf(""bad GET status for %s: %d"", file, err)
	|	}
	|	return &reader{bufio.NewReader(resp.Body), nil, resp}
	|
	|}
	|
	|func (r *reader) close() {
	|	if r.fd != nil {
	|		r.fd.Close()
	|	} else {
	|		r.resp.Body.Close()
	|	}
	|}
	|
	|var category = map[string]bool{
	|	// Nd Lu etc.
	|	// We use one-character names to identify merged categories
	|	""L"": true, // Lu Ll Lt Lm Lo
	|	""P"": true, // Pc Pd Ps Pe Pu Pf Po
	|	""M"": true, // Mn Mc Me
	|	""N"": true, // Nd Nl No
	|	""S"": true, // Sm Sc Sk So
	|	""Z"": true, // Zs Zl Zp
	|	""C"": true, // Cc Cf Cs Co Cn
	|}
	|
	|// UnicodeData.txt has form:
	|//	0037;DIGIT SEVEN;Nd;0;EN;;7;7;7;N;;;;;
	|//	007A;LATIN SMALL LETTER Z;Ll;0;L;;;;;N;;;005A;;005A
	|// See http://www.unicode.org/reports/tr44/ for a full explanation
	|// The fields:
	|const (
	|	FCodePoint = iota
	|	FName
	|	FGeneralCategory
	|	FCanonicalCombiningClass
	|	FBidiClass
	|	FDecompositionTypeAndMapping
	|	FNumericType
	|	FNumericDigit // If a decimal digit.
	|	FNumericValue // Includes non-decimal, e.g. U+2155=1/5
	|	FBidiMirrored
	|	FUnicode1Name
	|	FISOComment
	|	FSimpleUppercaseMapping
	|	FSimpleLowercaseMapping
	|	FSimpleTitlecaseMapping
	|	NumField
	|
	|	MaxChar = 0x10FFFF // anything above this shouldn't exist
	|)
	|
	|var fieldName = []string{
	|	FCodePoint:                   ""CodePoint"",
	|	FName:                        ""Name"",
	|	FGeneralCategory:             ""GeneralCategory"",
	|	FCanonicalCombiningClass:     ""CanonicalCombiningClass"",
	|	FBidiClass:                   ""BidiClass"",
	|	FDecompositionTypeAndMapping: ""DecompositionTypeAndMapping"",
	|	FNumericType:                 ""NumericType"",
	|	FNumericDigit:                ""NumericDigit"",
	|	FNumericValue:                ""NumericValue"",
	|	FBidiMirrored:                ""BidiMirrored"",
	|	FUnicode1Name:                ""Unicode1Name"",
	|	FISOComment:                  ""ISOComment"",
	|	FSimpleUppercaseMapping:      ""SimpleUppercaseMapping"",
	|	FSimpleLowercaseMapping:      ""SimpleLowercaseMapping"",
	|	FSimpleTitlecaseMapping:      ""SimpleTitlecaseMapping"",
	|}
	|
	|// This contains only the properties we're interested in.
	|type Char struct {
	|	field     []string // debugging only; could be deleted if we take out char.dump()
	|	codePoint rune     // if zero, this index is not a valid code point.
	|	category  string
	|	upperCase rune
	|	lowerCase rune
	|	titleCase rune
	|	foldCase  rune // simple case folding
	|	caseOrbit rune // next in simple case folding orbit
	|}
	|
	|// Scripts.txt has form:
	|//	A673          ; Cyrillic # Po       SLAVONIC ASTERISK
	|//	A67C..A67D    ; Cyrillic # Mn   [2] COMBINING CYRILLIC KAVYKA..COMBINING CYRILLIC PAYEROK
	|// See http://www.unicode.org/Public/5.1.0/ucd/UCD.html for full explanation
	|
	|type Script struct {
	|	lo, hi uint32 // range of code points
	|	script string
	|}
	|
	|var chars = make([]Char, MaxChar+1)
	|var scripts = make(map[string][]Script)
	|var props = make(map[string][]Script) // a property looks like a script; can share the format
	|
	|var lastChar rune = 0
	|
	|// In UnicodeData.txt, some ranges are marked like this:
	|//	3400;<CJK Ideograph Extension A, First>;Lo;0;L;;;;;N;;;;;
	|//	4DB5;<CJK Ideograph Extension A, Last>;Lo;0;L;;;;;N;;;;;
	|// parseCategory returns a state variable indicating the weirdness.
	|type State int
	|
	|const (
	|	SNormal State = iota // known to be zero for the type
	|	SFirst
	|	SLast
	|	SMissing
	|)
	|
	|func parseCategory(line string) (state State) {
	|	field := strings.Split(line, "";"")
	|	if len(field) != NumField {
	|		logger.Fatalf(""%5s: %d fields (expected %d)\n"", line, len(field), NumField)
	|	}
	|	point, err := strconv.ParseUint(field[FCodePoint], 16, 64)
	|	if err != nil {
	|		logger.Fatalf(""%.5s...: %s"", line, err)
	|	}
	|	lastChar = rune(point)
	|	if point > MaxChar {
	|		return
	|	}
	|	char := &chars[point]
	|	char.field = field
	|	if char.codePoint != 0 {
	|		logger.Fatalf(""point %U reused"", point)
	|	}
	|	char.codePoint = lastChar
	|	char.category = field[FGeneralCategory]
	|	category[char.category] = true
	|	switch char.category {
	|	case ""Nd"":
	|		// Decimal digit
	|		_, err := strconv.Atoi(field[FNumericValue])
	|		if err != nil {
	|			logger.Fatalf(""%U: bad numeric field: %s"", point, err)
	|		}
	|	case ""Lu"":
	|		char.letter(field[FCodePoint], field[FSimpleLowercaseMapping], field[FSimpleTitlecaseMapping])
	|	case ""Ll"":
	|		char.letter(field[FSimpleUppercaseMapping], field[FCodePoint], field[FSimpleTitlecaseMapping])
	|	case ""Lt"":
	|		char.letter(field[FSimpleUppercaseMapping], field[FSimpleLowercaseMapping], field[FCodePoint])
	|	default:
	|		char.letter(field[FSimpleUppercaseMapping], field[FSimpleLowercaseMapping], field[FSimpleTitlecaseMapping])
	|	}
	|	switch {
	|	case strings.Index(field[FName], "", First>"") > 0:
	|		state = SFirst
	|	case strings.Index(field[FName], "", Last>"") > 0:
	|		state = SLast
	|	}
	|	return
	|}
	|
	|func (char *Char) dump(s string) {
	|	print(s, "" "")
	|	for i := 0; i < len(char.field); i++ {
	|		printf(""%s:%q "", fieldName[i], char.field[i])
	|	}
	|	print(""\n"")
	|}
	|
	|func (char *Char) letter(u, l, t string) {
	|	char.upperCase = char.letterValue(u, ""U"")
	|	char.lowerCase = char.letterValue(l, ""L"")
	|	char.titleCase = char.letterValue(t, ""T"")
	|}
	|
	|func (char *Char) letterValue(s string, cas string) rune {
	|	if s == """" {
	|		return 0
	|	}
	|	v, err := strconv.ParseUint(s, 16, 64)
	|	if err != nil {
	|		char.dump(cas)
	|		logger.Fatalf(""%U: bad letter(%s): %s"", char.codePoint, s, err)
	|	}
	|	return rune(v)
	|}
	|
	|func allCategories() []string {
	|	a := make([]string, 0, len(category))
	|	for k := range category {
	|		a = append(a, k)
	|	}
	|	sort.Strings(a)
	|	return a
	|}
	|
	|func all(scripts map[string][]Script) []string {
	|	a := make([]string, 0, len(scripts))
	|	for k := range scripts {
	|		a = append(a, k)
	|	}
	|	sort.Strings(a)
	|	return a
	|}
	|
	|func allCatFold(m map[string]map[rune]bool) []string {
	|	a := make([]string, 0, len(m))
	|	for k := range m {
	|		a = append(a, k)
	|	}
	|	sort.Strings(a)
	|	return a
	|}
	|
	|// Extract the version number from the URL
	|func version() string {
	|	// Break on slashes and look for the first numeric field
	|	fields := strings.Split(*url, ""/"")
	|	for _, f := range fields {
	|		if len(f) > 0 && '0' <= f[0] && f[0] <= '9' {
	|			return f
	|		}
	|	}
	|	logger.Fatal(""unknown version"")
	|	return ""Unknown""
	|}
	|
	|func categoryOp(code rune, class uint8) bool {
	|	category := chars[code].category
	|	return len(category) > 0 && category[0] == class
	|}
	|
	|func loadChars() {
	|	if *dataURL == """" {
	|		flag.Set(""data"", *url+""UnicodeData.txt"")
	|	}
	|	input := open(*dataURL)
	|	defer input.close()
	|	scanner := bufio.NewScanner(input)
	|	var first rune = 0
	|	for scanner.Scan() {
	|		switch parseCategory(scanner.Text()) {
	|		case SNormal:
	|			if first != 0 {
	|				logger.Fatalf(""bad state normal at %U"", lastChar)
	|			}
	|		case SFirst:
	|			if first != 0 {
	|				logger.Fatalf(""bad state first at %U"", lastChar)
	|			}
	|			first = lastChar
	|		case SLast:
	|			if first == 0 {
	|				logger.Fatalf(""bad state last at %U"", lastChar)
	|			}
	|			for i := first + 1; i <= lastChar; i++ {
	|				chars[i] = chars[first]
	|				chars[i].codePoint = i
	|			}
	|			first = 0
	|		}
	|	}
	|	if scanner.Err() != nil {
	|		logger.Fatal(scanner.Err())
	|	}
	|}
	|
	|func loadCasefold() {
	|	if *casefoldingURL == """" {
	|		flag.Set(""casefolding"", *url+""CaseFolding.txt"")
	|	}
	|	input := open(*casefoldingURL)
	|	defer input.close()
	|	scanner := bufio.NewScanner(input)
	|	for scanner.Scan() {
	|		line := scanner.Text()
	|		if len(line) == 0 || line[0] == '#' || len(strings.TrimSpace(line)) == 0 {
	|			continue
	|		}
	|		field := strings.Split(line, ""; "")
	|		if len(field) != 4 {
	|			logger.Fatalf(""CaseFolding.txt %.5s...: %d fields (expected %d)\n"", line, len(field), 4)
	|		}
	|		kind := field[1]
	|		if kind != ""C"" && kind != ""S"" {
	|			// Only care about 'common' and 'simple' foldings.
	|			continue
	|		}
	|		p1, err := strconv.ParseUint(field[0], 16, 64)
	|		if err != nil {
	|			logger.Fatalf(""CaseFolding.txt %.5s...: %s"", line, err)
	|		}
	|		p2, err := strconv.ParseUint(field[2], 16, 64)
	|		if err != nil {
	|			logger.Fatalf(""CaseFolding.txt %.5s...: %s"", line, err)
	|		}
	|		chars[p1].foldCase = rune(p2)
	|	}
	|	if scanner.Err() != nil {
	|		logger.Fatal(scanner.Err())
	|	}
	|}
	|
	|const progHeader = `// Copyright 2013 The Go Authors, Microsoft. All rights reserved.
	|// Use of this source code is governed by a BSD-style
	|// license that can be found in the LICENSE file.
	|
	|// Generated by running
	|//	maketables --tables=%s --data=%s --casefolding=%s
	|// DO NOT EDIT
	|
	|using System;
	|using System.Collections.Generic;
	|namespace NStack {
	|public partial class Unicode {
	|`
	|
	|func printCategories() {
	|	if *tablelist == """" {
	|		return
	|	}
	|	// Find out which categories to dump
	|	list := strings.Split(*tablelist, "","")
	|	if *tablelist == ""all"" {
	|		list = allCategories()
	|	}
	|	if *test {
	|		fullCategoryTest(list)
	|		return
	|	}
	|	printf(progHeader, *tablelist, *dataURL, *casefoldingURL)
	|
	|	println(""\t/// <summary>"")
	|	println(""\t/// Version is the Unicode edition from which the tables are derived."")
	|	println(""\t/// </summary>"")
	|	printf(""\tpublic const string Version = %q;\n\n"", version())
	|
	|	println(""\t/// <summary>Static class containing the various Unicode category range tables</summary>"")
	|	println(""\t/// <remarks><para>There are static properties that can be used to fetch a specific category, or you can use the <see cref=\""M:NStack.Unicode.Category.Get\""/> method this class to retrieve the RangeTable by its Unicode category table name</para></remarks>"")
	|	println(""\tpublic static class Category {"")
	|	println(""\t\t/// <summary>Retrieves the specified RangeTable from the Unicode category name</summary>"")
	|	println(""\t\t/// <param name=\""categoryName\"">The unicode character category name</param>"")
	|	println(""\t\tpublic static RangeTable Get (string categoryName) => Categories [categoryName];"")
	|
	|	if *tablelist == ""all"" {
	|		println(""\t\t// Categories is the set of Unicode category tables."")
	|		println(""\t\tstatic Dictionary<string,RangeTable> Categories = new Dictionary<string,RangeTable> () {"")
	|		for _, k := range allCategories() {
	|			printf(""\t\t\t{ %q, %s },\n"", k, k)
	|		}
	|		print(""\t\t};\n\n"")
	|	}
	|
	|	decl := make(sort.StringSlice, len(list))
	|	ndecl := 0
	|	for _, name := range list {
	|		if _, ok := category[name]; !ok {
	|			logger.Fatal(""unknown category"", name)
	|		}
	|		// We generate an UpperCase name to serve as concise documentation and an _UnderScored
	|		// name to store the data. This stops godoc dumping all the tables but keeps them
	|		// available to clients.
	|		// Cases deserving special comments
	|		varDecl := """"
	|		switch name {
	|		case ""C"":
	|			varDecl = ""\t/// <summary>Other/C is the set of Unicode control and special characters, category C.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Other => _C; \n""
	|			varDecl += ""\t/// <summary>Other/C is the set of Unicode control and special characters, category C.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable C => _C;\n""
	|		case ""L"":
	|			varDecl = ""\t/// <summary>Letter/L is the set of Unicode letters, category L.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Letter => _L;\n""
	|			varDecl += ""\t/// <summary>Letter/L is the set of Unicode letters, category L.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable L => _L;\n""
	|		case ""M"":
	|			varDecl = ""\t/// <summary>Mark/M is the set of Unicode mark characters, category M.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Mark => _M;\n""
	|			varDecl += ""\t/// <summary>Mark/M is the set of Unicode mark characters, category M.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable M => _M;\n""
	|		case ""N"":
	|			varDecl = ""\t/// <summary>Number/N is the set of Unicode number characters, category N.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Number => _N;\n""
	|			varDecl += ""\t/// <summary>Number/N is the set of Unicode number characters, category N.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable N => _N;\n""
	|		case ""P"":
	|			varDecl = ""\t/// <summary>Punct/P is the set of Unicode punctuation characters, category P.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Punct => _P;\n""
	|			varDecl += ""\t/// <summary>Punct/P is the set of Unicode punctuation characters, category P.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable P => _P;\n""
	|		case ""S"":
	|			varDecl = ""\t/// <summary>Symbol/S is the set of Unicode symbol characters, category S.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Symbol => _S;\n""
	|			varDecl += ""\t/// <summary>Symbol/S is the set of Unicode symbol characters, category S.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable S => _S;\n""
	|		case ""Z"":
	|			varDecl = ""\t/// <summary>Space/Z is the set of Unicode space characters, category Z.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Space => _Z;\n""
	|			varDecl += ""\t/// <summary>Space/Z is the set of Unicode space characters, category Z.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable Z => _Z;\n""
	|		case ""Nd"":
	|			varDecl = ""\t/// <summary>Digit is the set of Unicode characters with the \""decimal digit\"" property.</summary>\n""
	|			varDecl += ""\tpublic static RangeTable Digit => _Nd;\n""
	|		case ""Lu"":
	|			varDecl = ""\t/// <summary>Upper is the set of Unicode upper case letters.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable Upper => _Lu;\n""
	|		case ""Ll"":
	|			varDecl = ""\t/// <summary>Lower is the set of Unicode lower case letters.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable Lower => _Ll;\n""
	|		case ""Lt"":
	|			varDecl = ""\t/// <summary>Title is the set of Unicode title case letters.</summary>;\n""
	|			varDecl += ""\tpublic static RangeTable Title => _Lt;\n""
	|		}
	|		if len(name) > 1 {
	|			varDecl += fmt.Sprintf(
	|				""\t/// <summary>%s is the set of Unicode characters in category %s.</summary>\n\tpublic static RangeTable %s => _%s;\n"",
	|				name, name, name, name)
	|		}
	|		decl[ndecl] = varDecl
	|		ndecl++
	|		if len(name) == 1 { // unified categories
	|			decl := fmt.Sprintf(""\tinternal static RangeTable _%s = new RangeTable (\n"", name)
	|			dumpRange(
	|				decl,
	|				func(code rune) bool { return categoryOp(code, name[0]) })
	|			continue
	|		}
	|		dumpRange(
	|			fmt.Sprintf(""\tinternal static RangeTable _%s = new RangeTable (\n"", name),
	|			func(code rune) bool { return chars[code].category == name })
	|	}
	|	decl.Sort()
	|	for _, d := range decl {
	|		print(d)
	|	}
	|	println(""\t}"")
	|	println()
	|}
	|
	|type Op func(code rune) bool
	|
	|const format16 = ""\t\t\tnew Range16 (0x%04x, 0x%04x, %d),\n""
	|const format32 = ""\t\t\tnew Range32 (0x%04x, 0x%04x, %d),\n""
	|
	|func dumpRange(header string, inCategory Op) {
	|	print(header)
	|	next := rune(0)
	|	latinOffset := 0
	|	print(""\t\tr16: new Range16 [] {\n"")
	|	// one Range for each iteration
	|	count := &range16Count
	|	size := 16
	|	for {
	|		// look for start of range
	|		for next < rune(len(chars)) && !inCategory(next) {
	|			next++
	|		}
	|		if next >= rune(len(chars)) {
	|			// no characters remain
	|			break
	|		}
	|
	|		// start of range
	|		lo := next
	|		hi := next
	|		stride := rune(1)
	|		// accept lo
	|		next++
	|		// look for another character to set the stride
	|		for next < rune(len(chars)) && !inCategory(next) {
	|			next++
	|		}
	|		if next >= rune(len(chars)) {
	|			// no more characters
	|			printRange(uint32(lo), uint32(hi), uint32(stride), size, count)
	|			break
	|		}
	|		// set stride
	|		stride = next - lo
	|		// check for length of run. next points to first jump in stride
	|		for i := next; i < rune(len(chars)); i++ {
	|			if inCategory(i) == (((i - lo) % stride) == 0) {
	|				// accept
	|				if inCategory(i) {
	|					hi = i
	|				}
	|			} else {
	|				// no more characters in this run
	|				break
	|			}
	|		}
	|		if uint32(hi) <= unicode.MaxLatin1 {
	|			latinOffset++
	|		}
	|		size, count = printRange(uint32(lo), uint32(hi), uint32(stride), size, count)
	|		// next range: start looking where this range ends
	|		next = hi + 1
	|	}
	|	print(""\t\t}"")
	|	if latinOffset > 0 {
	|		printf("",\n\t\tlatinOffset: %d\n"", latinOffset)
	|	} else {
	|		printf(""\n"")
	|	}
	|	print(""\t);\n\n"")
	|}
	|
	|func printRange(lo, hi, stride uint32, size int, count *int) (int, *int) {
	|	format := """"
	|	if size == 16 {
	|		format = format16
	|	} else {
	|		format = format32
	|	}
	|
	|	if size == 16 && hi >= 1<<16 {
	|		if lo < 1<<16 {
	|			if lo+stride != hi {
	|				logger.Fatalf(""unexpected straddle: %U %U %d"", lo, hi, stride)
	|			}
	|			// No range contains U+FFFF as an instance, so split
	|			// the range into two entries. That way we can maintain
	|			// the invariant that R32 contains only >= 1<<16.
	|			printf(format, lo, lo, 1)
	|			lo = hi
	|			stride = 1
	|			*count++
	|		}
	|		print(""\t\t},\n"")
	|		print(""\t\tr32: new Range32 [] {\n"")
	|		size = 32
	|		format = format32
	|
	|		count = &range32Count
	|	}
	|	printf(format, lo, hi, stride)
	|	*count++
	|	return size, count
	|}
	|
	|func fullCategoryTest(list []string) {
	|	for _, name := range list {
	|		if _, ok := category[name]; !ok {
	|			logger.Fatal(""unknown category"", name)
	|		}
	|		r, ok := unicode.Categories[name]
	|		if !ok && len(name) > 1 {
	|			logger.Fatalf(""unknown table %q"", name)
	|		}
	|		if len(name) == 1 {
	|			verifyRange(name, func(code rune) bool { return categoryOp(code, name[0]) }, r)
	|		} else {
	|			verifyRange(
	|				name,
	|				func(code rune) bool { return chars[code].category == name },
	|				r)
	|		}
	|	}
	|}
	|
	|func verifyRange(name string, inCategory Op, table *unicode.RangeTable) {
	|	count := 0
	|	for j := range chars {
	|		i := rune(j)
	|		web := inCategory(i)
	|		pkg := unicode.Is(table, i)
	|		if web != pkg {
	|			fmt.Fprintf(os.Stderr, ""%s: %U: web=%t pkg=%t\n"", name, i, web, pkg)
	|			count++
	|			if count > 10 {
	|				break
	|			}
	|		}
	|	}
	|}
	|
	|func parseScript(line string, scripts map[string][]Script) {
	|	comment := strings.Index(line, ""#"")
	|	if comment >= 0 {
	|		line = line[0:comment]
	|	}
	|	line = strings.TrimSpace(line)
	|	if len(line) == 0 {
	|		return
	|	}
	|	field := strings.Split(line, "";"")
	|	if len(field) != 2 {
	|		logger.Fatalf(""%s: %d fields (expected 2)\n"", line, len(field))
	|	}
	|	matches := scriptRe.FindStringSubmatch(line)
	|	if len(matches) != 4 {
	|		logger.Fatalf(""%s: %d matches (expected 3)\n"", line, len(matches))
	|	}
	|	lo, err := strconv.ParseUint(matches[1], 16, 64)
	|	if err != nil {
	|		logger.Fatalf(""%.5s...: %s"", line, err)
	|	}
	|	hi := lo
	|	if len(matches[2]) > 2 { // ignore leading ..
	|		hi, err = strconv.ParseUint(matches[2][2:], 16, 64)
	|		if err != nil {
	|			logger.Fatalf(""%.5s...: %s"", line, err)
	|		}
	|	}
	|	name := matches[3]
	|	scripts[name] = append(scripts[name], Script{uint32(lo), uint32(hi), name})
	|}
	|
	|// The script tables have a lot of adjacent elements. Fold them together.
	|func foldAdjacent(r []Script) []unicode.Range32 {
	|	s := make([]unicode.Range32, 0, len(r))
	|	j := 0
	|	for i := 0; i < len(r); i++ {
	|		if j > 0 && r[i].lo == s[j-1].Hi+1 {
	|			s[j-1].Hi = r[i].hi
	|		} else {
	|			s = s[0 : j+1]
	|			s[j] = unicode.Range32{
	|				Lo:     uint32(r[i].lo),
	|				Hi:     uint32(r[i].hi),
	|				Stride: 1,
	|			}
	|			j++
	|		}
	|	}
	|	return s
	|}
	|
	|func fullScriptTest(list []string, installed map[string]*unicode.RangeTable, scripts map[string][]Script) {
	|	for _, name := range list {
	|		if _, ok := scripts[name]; !ok {
	|			logger.Fatal(""unknown script"", name)
	|		}
	|		_, ok := installed[name]
	|		if !ok {
	|			logger.Fatal(""unknown table"", name)
	|		}
	|		for _, script := range scripts[name] {
	|			for r := script.lo; r <= script.hi; r++ {
	|				if !unicode.Is(installed[name], rune(r)) {
	|					fmt.Fprintf(os.Stderr, ""%U: not in script %s\n"", r, name)
	|				}
	|			}
	|		}
	|	}
	|}
	|
	|var deprecatedAliases = map[string]string{
	|	""Sentence_Terminal"": ""STerm"",
	|}
	|
	|// PropList.txt has the same format as Scripts.txt so we can share its parser.
	|func printScriptOrProperty(doProps bool) {
	|	flag := ""scripts""
	|	flaglist := *scriptlist
	|	file := ""Scripts.txt""
	|	table := scripts
	|	installed := unicode.Scripts
	|	if doProps {
	|		flag = ""props""
	|		flaglist = *proplist
	|		file = ""PropList.txt""
	|		table = props
	|		installed = unicode.Properties
	|	}
	|	if flaglist == """" {
	|		return
	|	}
	|	input := open(*url + file)
	|	scanner := bufio.NewScanner(input)
	|	for scanner.Scan() {
	|		parseScript(scanner.Text(), table)
	|	}
	|	if scanner.Err() != nil {
	|		logger.Fatal(scanner.Err())
	|	}
	|	input.close()
	|
	|	// Find out which scripts to dump
	|	list := strings.Split(flaglist, "","")
	|	if flaglist == ""all"" {
	|		list = all(table)
	|	}
	|	if *test {
	|		fullScriptTest(list, installed, table)
	|		return
	|	}
	|
	|	printf(
	|		""// Generated by running\n""+
	|			""//	maketables --%s=%s --url=%s\n""+
	|			""// DO NOT EDIT\n\n"",
	|		flag,
	|		flaglist,
	|		*url)
	|	if doProps {
	|		println(""\t/// <summary>Static class containing the proeprty-based tables.</summary>"")
	|		println(""\t/// <remarks><para>There are static properties that can be used to fetch RangeTables that identify characters that have a specific property, or you can use the <see cref=\""T:NStack.Unicode.Property.Get\""/> method in this class to retrieve the range table by the property name</para></remarks>"")
	|		println(""\tpublic static class Property {"")
	|		println(""\t\t/// <summary>Retrieves the specified RangeTable having that property.</summary>"")
	|		println(""\t\t/// <param name=\""propertyName\"">The property name.</param>"")
	|		println(""\t\tpublic static RangeTable Get (string propertyName) => Properties [propertyName];"")
	|	} else {
	|		println(""\t/// <summary>Static class containing the Unicode script tables.</summary>"")
	|		println(""\t/// <remarks><para>There are static properties that can be used to fetch a specific category, or you can use the <see cref=\""T:NStack.Unicode.Script.Get\""/> method in this class to retrieve the range table by its script name</para></remarks>"")
	|		println(""\tpublic static class Script {"")
	|		println(""\t\t/// <summary>Retrieves the specified RangeTable from the Unicode script name.</summary>"")
	|		println(""\t\t/// <param name=\""scriptName\"">The unicode script name</param>"")
	|		println(""\t\tpublic static RangeTable Get (string scriptName) => Scripts [scriptName];"")
	|	}
	|	if flaglist == ""all"" {
	|		if doProps {
	|			println(""\t\t// Properties is the set of Unicode property tables."")
	|			println(""\t\tstatic Dictionary<string,RangeTable> Properties = new Dictionary<string,RangeTable> (){"")
	|		} else {
	|			println(""\t\t// Scripts is the set of Unicode script tables."")
	|			println(""\t\tstatic Dictionary<string,RangeTable> Scripts = new Dictionary<string,RangeTable> (){"")
	|		}
	|		for _, k := range all(table) {
	|			printf(""\t\t\t{ %q, %s },\n"", k, k)
	|			if alias, ok := deprecatedAliases[k]; ok {
	|				printf(""\t\t\t{ %q, %s },\n"", alias, k)
	|			}
	|		}
	|		print(""\t\t};\n\n"")
	|	}
	|
	|	decl := make(sort.StringSlice, len(list)+len(deprecatedAliases))
	|	ndecl := 0
	|	for _, name := range list {
	|		if doProps {
	|			decl[ndecl] = fmt.Sprintf(
	|				""\t/// <summary>%s is the set of Unicode characters with property %s.</summary>\n\tpublic static RangeTable %s => _%s;\n"",
	|				name, name, name, name)
	|		} else {
	|			decl[ndecl] = fmt.Sprintf(
	|				""\t/// <summary>%s is the set of Unicode characters in script %s.</summary>\n\tpublic static RangeTable %s => _%s;\n"",
	|				name, name, name, name)
	|		}
	|		ndecl++
	|		if alias, ok := deprecatedAliases[name]; ok {
	|			decl[ndecl] = fmt.Sprintf(
	|				""\t/// <summary>%[1]s is an alias for %[2]s.</summary>\n\tpublic static RangeTable %[1]s => _%[2]s;\n"",
	|				alias, name)
	|			ndecl++
	|		}
	|		printf(""\tinternal static RangeTable _%s = new RangeTable (\n"", name)
	|		ranges := foldAdjacent(table[name])
	|		print(""\t\tr16: new Range16 [] {\n"")
	|		size := 16
	|		count := &range16Count
	|		for _, s := range ranges {
	|			size, count = printRange(s.Lo, s.Hi, s.Stride, size, count)
	|		}
	|		print(""\t\t}"")
	|		if off := findLatinOffset(ranges); off > 0 {
	|			printf("",\n\t\tlatinOffset: %d\n"", off)
	|		} else {
	|			printf(""\n"")
	|		}
	|		print(""\t); /* RangeTable */\n\n"")
	|	}
	|	decl.Sort()
	|
	|	for _, d := range decl {
	|		print(d)
	|	}
	|	println(""\t}"")
	|	println()
	|}
	|
	|func findLatinOffset(ranges []unicode.Range32) int {
	|	i := 0
	|	for i < len(ranges) && ranges[i].Hi <= unicode.MaxLatin1 {
	|		i++
	|	}
	|	return i
	|}
	|
	|const (
	|	CaseUpper = 1 << iota
	|	CaseLower
	|	CaseTitle
	|	CaseNone    = 0  // must be zero
	|	CaseMissing = -1 // character not present; not a valid case state
	|)
	|
	|type caseState struct {
	|	point        rune
	|	_case        int
	|	deltaToUpper rune
	|	deltaToLower rune
	|	deltaToTitle rune
	|}
	|
	|// Is d a continuation of the state of c?
	|func (c *caseState) adjacent(d *caseState) bool {
	|	if d.point < c.point {
	|		c, d = d, c
	|	}
	|	switch {
	|	case d.point != c.point+1: // code points not adjacent (shouldn't happen)
	|		return false
	|	case d._case != c._case: // different cases
	|		return c.upperLowerAdjacent(d)
	|	case c._case == CaseNone:
	|		return false
	|	case c._case == CaseMissing:
	|		return false
	|	case d.deltaToUpper != c.deltaToUpper:
	|		return false
	|	case d.deltaToLower != c.deltaToLower:
	|		return false
	|	case d.deltaToTitle != c.deltaToTitle:
	|		return false
	|	}
	|	return true
	|}
	|
	|// Is d the same as c, but opposite in upper/lower case? this would make it
	|// an element of an UpperLower sequence.
	|func (c *caseState) upperLowerAdjacent(d *caseState) bool {
	|	// check they're a matched case pair.  we know they have adjacent values
	|	switch {
	|	case c._case == CaseUpper && d._case != CaseLower:
	|		return false
	|	case c._case == CaseLower && d._case != CaseUpper:
	|		return false
	|	}
	|	// matched pair (at least in upper/lower).  make the order Upper Lower
	|	if c._case == CaseLower {
	|		c, d = d, c
	|	}
	|	// for an Upper Lower sequence the deltas have to be in order
	|	//	c: 0 1 0
	|	//	d: -1 0 -1
	|	switch {
	|	case c.deltaToUpper != 0:
	|		return false
	|	case c.deltaToLower != 1:
	|		return false
	|	case c.deltaToTitle != 0:
	|		return false
	|	case d.deltaToUpper != -1:
	|		return false
	|	case d.deltaToLower != 0:
	|		return false
	|	case d.deltaToTitle != -1:
	|		return false
	|	}
	|	return true
	|}
	|
	|// Does this character start an UpperLower sequence?
	|func (c *caseState) isUpperLower() bool {
	|	// for an Upper Lower sequence the deltas have to be in order
	|	//	c: 0 1 0
	|	switch {
	|	case c.deltaToUpper != 0:
	|		return false
	|	case c.deltaToLower != 1:
	|		return false
	|	case c.deltaToTitle != 0:
	|		return false
	|	}
	|	return true
	|}
	|
	|// Does this character start a LowerUpper sequence?
	|func (c *caseState) isLowerUpper() bool {
	|	// for an Upper Lower sequence the deltas have to be in order
	|	//	c: -1 0 -1
	|	switch {
	|	case c.deltaToUpper != -1:
	|		return false
	|	case c.deltaToLower != 0:
	|		return false
	|	case c.deltaToTitle != -1:
	|		return false
	|	}
	|	return true
	|}
	|
	|func getCaseState(i rune) (c *caseState) {
	|	c = &caseState{point: i, _case: CaseNone}
	|	ch := &chars[i]
	|	switch ch.codePoint {
	|	case 0:
	|		c._case = CaseMissing // Will get NUL wrong but that doesn't matter
	|		return
	|	case ch.upperCase:
	|		c._case = CaseUpper
	|	case ch.lowerCase:
	|		c._case = CaseLower
	|	case ch.titleCase:
	|		c._case = CaseTitle
	|	}
	|	// Some things such as roman numeral U+2161 don't describe themselves
	|	// as upper case, but have a lower case. Second-guess them.
	|	if c._case == CaseNone && ch.lowerCase != 0 {
	|		c._case = CaseUpper
	|	}
	|	// Same in the other direction.
	|	if c._case == CaseNone && ch.upperCase != 0 {
	|		c._case = CaseLower
	|	}
	|
	|	if ch.upperCase != 0 {
	|		c.deltaToUpper = ch.upperCase - i
	|	}
	|	if ch.lowerCase != 0 {
	|		c.deltaToLower = ch.lowerCase - i
	|	}
	|	if ch.titleCase != 0 {
	|		c.deltaToTitle = ch.titleCase - i
	|	}
	|	return
	|}
	|
	|func printCases() {
	|	if !*cases {
	|		return
	|	}
	|	if *test {
	|		fullCaseTest()
	|		return
	|	}
	|	printf(
	|		""\t// Generated by running\n""+
	|			""\t//	maketables --data=%s --casefolding=%s\n""+
	|			""\t// DO NOT EDIT\n\n""+
	|			""\t// CaseRanges is the table describing case mappings for all letters with\n""+
	|			""\t// non-self mappings.\n""+
	|			""\tstatic CaseRange [] CaseRanges => _CaseRanges;\n""+
	|			""\tstatic CaseRange [] _CaseRanges =  new CaseRange [] {\n"",
	|		*dataURL, *casefoldingURL)
	|
	|	var startState *caseState    // the start of a run; nil for not active
	|	var prevState = &caseState{} // the state of the previous character
	|	for i := range chars {
	|		state := getCaseState(rune(i))
	|		if state.adjacent(prevState) {
	|			prevState = state
	|			continue
	|		}
	|		// end of run (possibly)
	|		printCaseRange(startState, prevState)
	|		startState = nil
	|		if state._case != CaseMissing && state._case != CaseNone {
	|			startState = state
	|		}
	|		prevState = state
	|	}
	|	print(""\t};\n"")
	|}
	|
	|func printCaseRange(lo, hi *caseState) {
	|	if lo == nil {
	|		return
	|	}
	|	if lo.deltaToUpper == 0 && lo.deltaToLower == 0 && lo.deltaToTitle == 0 {
	|		// character represents itself in all cases - no need to mention it
	|		return
	|	}
	|	switch {
	|	case hi.point > lo.point && lo.isUpperLower():
	|		printf(""\t\tnew CaseRange (0x%04X, 0x%04X, UpperLower, UpperLower, UpperLower),\n"",
	|			lo.point, hi.point)
	|	case hi.point > lo.point && lo.isLowerUpper():
	|		logger.Fatalf(""LowerUpper sequence: should not happen: %U.  If it's real, need to fix To()"", lo.point)
	|		printf(""\t\tnew CaseRange (0x%04X, 0x%04X, LowerUpper, LowerUpper, LowerUpper),\n"",
	|			lo.point, hi.point)
	|	default:
	|		printf(""\t\tnew CaseRange (0x%04X, 0x%04X, %d, %d, %d),\n"",
	|			lo.point, hi.point,
	|			lo.deltaToUpper, lo.deltaToLower, lo.deltaToTitle)
	|	}
	|}
	|
	|// If the cased value in the Char is 0, it means use the rune itself.
	|func caseIt(r, cased rune) rune {
	|	if cased == 0 {
	|		return r
	|	}
	|	return cased
	|}
	|
	|func fullCaseTest() {
	|	for j, c := range chars {
	|		i := rune(j)
	|		lower := unicode.ToLower(i)
	|		want := caseIt(i, c.lowerCase)
	|		if lower != want {
	|			fmt.Fprintf(os.Stderr, ""lower %U should be %U is %U\n"", i, want, lower)
	|		}
	|		upper := unicode.ToUpper(i)
	|		want = caseIt(i, c.upperCase)
	|		if upper != want {
	|			fmt.Fprintf(os.Stderr, ""upper %U should be %U is %U\n"", i, want, upper)
	|		}
	|		title := unicode.ToTitle(i)
	|		want = caseIt(i, c.titleCase)
	|		if title != want {
	|			fmt.Fprintf(os.Stderr, ""title %U should be %U is %U\n"", i, want, title)
	|		}
	|	}
	|}
	|
	|func printLatinProperties() {
	|	if *test {
	|		return
	|	}
	|	println(""\tstatic CharClass [] properties = new CharClass [256] {"")
	|	for code := 0; code <= unicode.MaxLatin1; code++ {
	|		var property string
	|		switch chars[code].category {
	|		case ""Cc"", """": // NUL has no category.
	|			property = ""CharClass.pC""
	|		case ""Cf"": // soft hyphen, unique category, not printable.
	|			property = ""0""
	|		case ""Ll"":
	|			property = ""CharClass.pLl | CharClass.pp""
	|		case ""Lo"":
	|			property = ""CharClass.pLo | CharClass.pp""
	|		case ""Lu"":
	|			property = ""CharClass.pLu | CharClass.pp""
	|		case ""Nd"", ""No"":
	|			property = ""CharClass.pN | CharClass.pp""
	|		case ""Pc"", ""Pd"", ""Pe"", ""Pf"", ""Pi"", ""Po"", ""Ps"":
	|			property = ""CharClass.pP | CharClass.pp""
	|		case ""Sc"", ""Sk"", ""Sm"", ""So"":
	|			property = ""CharClass.pS | CharClass.pp""
	|		case ""Zs"":
	|			property = ""CharClass.pZ""
	|		default:
	|			logger.Fatalf(""%U has unknown category %q"", code, chars[code].category)
	|		}
	|		// Special case
	|		if code == ' ' {
	|			property = ""CharClass.pZ | CharClass.pp""
	|		}
	|		printf(""\t\t/*0x%02X */ %s, // %q\n"", code, property, code)
	|	}
	|	printf(""\t};\n\n"")
	|}
	|
	|type runeSlice []rune
	|
	|func (p runeSlice) Len() int           { return len(p) }
	|func (p runeSlice) Less(i, j int) bool { return p[i] < p[j] }
	|func (p runeSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
	|
	|func printCasefold() {
	|	// Build list of case-folding groups attached to each canonical folded char (typically lower case).
	|	var caseOrbit = make([][]rune, MaxChar+1)
	|	for j := range chars {
	|		i := rune(j)
	|		c := &chars[i]
	|		if c.foldCase == 0 {
	|			continue
	|		}
	|		orb := caseOrbit[c.foldCase]
	|		if orb == nil {
	|			orb = append(orb, c.foldCase)
	|		}
	|		caseOrbit[c.foldCase] = append(orb, i)
	|	}
	|
	|	// Insert explicit 1-element groups when assuming [lower, upper] would be wrong.
	|	for j := range chars {
	|		i := rune(j)
	|		c := &chars[i]
	|		f := c.foldCase
	|		if f == 0 {
	|			f = i
	|		}
	|		orb := caseOrbit[f]
	|		if orb == nil && (c.upperCase != 0 && c.upperCase != i || c.lowerCase != 0 && c.lowerCase != i) {
	|			// Default assumption of [upper, lower] is wrong.
	|			caseOrbit[i] = []rune{i}
	|		}
	|	}
	|
	|	// Delete the groups for which assuming [lower, upper] or [upper, lower] is right.
	|	for i, orb := range caseOrbit {
	|		if len(orb) == 2 && chars[orb[0]].upperCase == orb[1] && chars[orb[1]].lowerCase == orb[0] {
	|			caseOrbit[i] = nil
	|		}
	|		if len(orb) == 2 && chars[orb[1]].upperCase == orb[0] && chars[orb[0]].lowerCase == orb[1] {
	|			caseOrbit[i] = nil
	|		}
	|	}
	|
	|	// Record orbit information in chars.
	|	for _, orb := range caseOrbit {
	|		if orb == nil {
	|			continue
	|		}
	|		sort.Sort(runeSlice(orb))
	|		c := orb[len(orb)-1]
	|		for _, d := range orb {
	|			chars[c].caseOrbit = d
	|			c = d
	|		}
	|	}
	|
	|	printAsciiFold()
	|	printCaseOrbit()
	|
	|	// Tables of category and script folding exceptions: code points
	|	// that must be added when interpreting a particular category/script
	|	// in a case-folding context.
	|	cat := make(map[string]map[rune]bool)
	|	for name := range category {
	|		if x := foldExceptions(inCategory(name)); len(x) > 0 {
	|			cat[name] = x
	|		}
	|	}
	|
	|	scr := make(map[string]map[rune]bool)
	|	for name := range scripts {
	|		if x := foldExceptions(inScript(name)); len(x) > 0 {
	|			cat[name] = x
	|		}
	|	}
	|
	|	printCatFold(""FoldCategory"", cat)
	|	printCatFold(""FoldScript"", scr)
	|}
	|
	|// inCategory returns a list of all the runes in the category.
	|func inCategory(name string) []rune {
	|	var x []rune
	|	for j := range chars {
	|		i := rune(j)
	|		c := &chars[i]
	|		if c.category == name || len(name) == 1 && len(c.category) > 1 && c.category[0] == name[0] {
	|			x = append(x, i)
	|		}
	|	}
	|	return x
	|}
	|
	|// inScript returns a list of all the runes in the script.
	|func inScript(name string) []rune {
	|	var x []rune
	|	for _, s := range scripts[name] {
	|		for c := s.lo; c <= s.hi; c++ {
	|			x = append(x, rune(c))
	|		}
	|	}
	|	return x
	|}
	|
	|// foldExceptions returns a list of all the runes fold-equivalent
	|// to runes in class but not in class themselves.
	|func foldExceptions(class []rune) map[rune]bool {
	|	// Create map containing class and all fold-equivalent chars.
	|	m := make(map[rune]bool)
	|	for _, r := range class {
	|		c := &chars[r]
	|		if c.caseOrbit == 0 {
	|			// Just upper and lower.
	|			if u := c.upperCase; u != 0 {
	|				m[u] = true
	|			}
	|			if l := c.lowerCase; l != 0 {
	|				m[l] = true
	|			}
	|			m[r] = true
	|			continue
	|		}
	|		// Otherwise walk orbit.
	|		r0 := r
	|		for {
	|			m[r] = true
	|			r = chars[r].caseOrbit
	|			if r == r0 {
	|				break
	|			}
	|		}
	|	}
	|
	|	// Remove class itself.
	|	for _, r := range class {
	|		delete(m, r)
	|	}
	|
	|	// What's left is the exceptions.
	|	return m
	|}
	|
	|var comment = map[string]string{
	|	""FoldCategory"": ""\t// FoldCategory maps a category name to a table of\n"" +
	|		""\t// code points outside the category that are equivalent under\n"" +
	|		""\t// simple case folding to code points inside the category.\n"" +
	|		""\t// If there is no entry for a category name, there are no such points.\n"",
	|
	|	""FoldScript"": ""\t// FoldScript maps a script name to a table of\n"" +
	|		""\t// code points outside the script that are equivalent under\n"" +
	|		""\t// simple case folding to code points inside the script.\n"" +
	|		""\t// If there is no entry for a script name, there are no such points.\n"",
	|}
	|
	|func printAsciiFold() {
	|	printf(""\tstatic ushort [] asciiFold = new ushort [128]{\n"")
	|	for i := rune(0); i <= unicode.MaxASCII; i++ {
	|		c := chars[i]
	|		f := c.caseOrbit
	|		if f == 0 {
	|			if c.lowerCase != i && c.lowerCase != 0 {
	|				f = c.lowerCase
	|			} else if c.upperCase != i && c.upperCase != 0 {
	|				f = c.upperCase
	|			} else {
	|				f = i
	|			}
	|		}
	|		printf(""\t\t0x%04X,\n"", f)
	|	}
	|	printf(""\t};\n\n"")
	|}
	|
	|func printCaseOrbit() {
	|	if *test {
	|		for j := range chars {
	|			i := rune(j)
	|			c := &chars[i]
	|			f := c.caseOrbit
	|			if f == 0 {
	|				if c.lowerCase != i && c.lowerCase != 0 {
	|					f = c.lowerCase
	|				} else if c.upperCase != i && c.upperCase != 0 {
	|					f = c.upperCase
	|				} else {
	|					f = i
	|				}
	|			}
	|			if g := unicode.SimpleFold(i); g != f {
	|				fmt.Fprintf(os.Stderr, ""unicode.SimpleFold(%#U) = %#U, want %#U\n"", i, g, f)
	|			}
	|		}
	|		return
	|	}
	|
	|	printf(""\tstatic FoldPair [] CaseOrbit = new FoldPair [] {\n"")
	|	for i := range chars {
	|		c := &chars[i]
	|		if c.caseOrbit != 0 {
	|			printf(""\t\tnew FoldPair (0x%04X, 0x%04X),\n"", i, c.caseOrbit)
	|			foldPairCount++
	|		}
	|	}
	|	printf(""\t}; /* CaseOrbit */\n\n"")
	|}
	|
	|func printCatFold(name string, m map[string]map[rune]bool) {
	|	if *test {
	|		var pkgMap map[string]*unicode.RangeTable
	|		if name == ""FoldCategory"" {
	|			pkgMap = unicode.FoldCategory
	|		} else {
	|			pkgMap = unicode.FoldScript
	|		}
	|		if len(pkgMap) != len(m) {
	|			fmt.Fprintf(os.Stderr, ""unicode.%s has %d elements, want %d\n"", name, len(pkgMap), len(m))
	|			return
	|		}
	|		for k, v := range m {
	|			t, ok := pkgMap[k]
	|			if !ok {
	|				fmt.Fprintf(os.Stderr, ""unicode.%s[%q] missing\n"", name, k)
	|				continue
	|			}
	|			n := 0
	|			for _, r := range t.R16 {
	|				for c := rune(r.Lo); c <= rune(r.Hi); c += rune(r.Stride) {
	|					if !v[c] {
	|						fmt.Fprintf(os.Stderr, ""unicode.%s[%q] contains %#U, should not\n"", name, k, c)
	|					}
	|					n++
	|				}
	|			}
	|			for _, r := range t.R32 {
	|				for c := rune(r.Lo); c <= rune(r.Hi); c += rune(r.Stride) {
	|					if !v[c] {
	|						fmt.Fprintf(os.Stderr, ""unicode.%s[%q] contains %#U, should not\n"", name, k, c)
	|					}
	|					n++
	|				}
	|			}
	|			if n != len(v) {
	|				fmt.Fprintf(os.Stderr, ""unicode.%s[%q] has %d code points, want %d\n"", name, k, n, len(v))
	|			}
	|		}
	|		return
	|	}
	|
	|	print(comment[name])
	|	printf(""\tstatic Dictionary<string,RangeTable> %s = new Dictionary<string,RangeTable> () {\n"", name)
	|	for _, name := range allCatFold(m) {
	|		printf(""\t\t { %q, fold%s },\n"", name, name)
	|	}
	|	printf(""\t};\n\n"")
	|	for _, name := range allCatFold(m) {
	|		class := m[name]
	|		dumpRange(
	|			fmt.Sprintf(""\tinternal static RangeTable fold%s = new RangeTable (\n"", name),
	|			func(code rune) bool { return class[code] })
	|	}
	|}
	|
	|var range16Count = 0  // Number of entries in the 16-bit range tables.
	|var range32Count = 0  // Number of entries in the 32-bit range tables.
	|var foldPairCount = 0 // Number of fold pairs in the exception tables.
	|
	|func printSizes() {
	|	if *test {
	|		return
	|	}
	|	println()
	|	printf(""// Range entries: %d 16-bit, %d 32-bit, %d total.\n"", range16Count, range32Count, range16Count+range32Count)
	|	range16Bytes := range16Count * 3 * 2
	|	range32Bytes := range32Count * 3 * 4
	|	printf(""// Range bytes: %d 16-bit, %d 32-bit, %d total.\n"", range16Bytes, range32Bytes, range16Bytes+range32Bytes)
	|	println()
	|	printf(""// Fold orbit bytes: %d pairs, %d bytes\n"", foldPairCount, foldPairCount*2*2)
	|}
	|";
	ТекстДокХХХ = Новый ТекстовыйДокумент;
	ТекстДокХХХ.УстановитьТекст(СтрФайла);
	ТекстДокХХХ.Записать(КаталогВыгрузки + "\maketables.go");
	
	СтрФайла = 
	"//=======================================================================
	|using System;
	|using System.Runtime.InteropServices;
	|using System.Collections.Generic;
	|using System.Text;
	|using System.Collections;
	|using System.Linq;
	|using NStack;
	|
	|namespace NStack
	|{
	|    public partial class Unicode
	|    {
	|        /// <summary>
	|        /// Special casing rules for Turkish.
	|        /// </summary>
	|        public static SpecialCase TurkishCase = new SpecialCase(
	|            new CaseRange[] {
	|                new CaseRange (0x0049, 0x0049, 0, 0x131 - 0x49, 0),
	|                new CaseRange (0x0069, 0x0069, 0x130 - 0x69, 0, 0x130 - 0x69),
	|                new CaseRange (0x0130, 0x0130, 0, 0x69 - 0x130, 0),
	|                new CaseRange (0x0131, 0x0131, 0x49 - 0x131, 0, 0x49 - 0x131),
	|            });
	|    }
	|    //=======================================================================
	|    public partial class Unicode
	|    {
	|        /// <summary>
	|        /// IsDigit reports whether the rune is a decimal digit.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsDigit(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return '0' <= rune && rune <= '9';
	|            return Category.Digit.IsExcludingLatin(rune);
	|        }
	|    }
	|    //=======================================================================
	|    public partial class Unicode
	|    {
	|        [Flags]
	|        internal enum CharClass : byte
	|        {
	|            pC = 1 << 0, // a control character.
	|            pP = 1 << 1, // a punctuation character.
	|            pN = 1 << 2, // a numeral.
	|            pS = 1 << 3, // a symbolic character.
	|            pZ = 1 << 4, // a spacing character.
	|            pLu = 1 << 5, // an upper-case letter.
	|            pLl = 1 << 6, // a lower-case letter.
	|            pp = 1 << 7, // a printable character according to Go's definition.
	|            pg = pp | pZ,   // a graphical character according to the Unicode definition.
	|            pLo = pLl | pLu, // a letter that is neither upper nor lower case.
	|            pLmask = pLo
	|        }
	|
	|        /// <summary>
	|        /// The range tables for graphics
	|        /// </summary>
	|        public static RangeTable[] GraphicRanges = new[] {
	|            Category._L, Category._M, Category._N, Category._P, Category._S, Category._Zs
	|        };
	|
	|        /// <summary>
	|        /// The range tables for print
	|        /// </summary>
	|        public static RangeTable[] PrintRanges = new[] {
	|            Category._L, Category._M, Category._N, Category._P, Category._S
	|        };
	|
	|        /// <summary>
	|        /// Determines if a rune is on a set of ranges.
	|        /// </summary>
	|        /// <returns><c>true</c>, if rune in ranges was used, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        /// <param name=""inRanges"">In ranges.</param>
	|        public static bool IsRuneInRanges(uint rune, params RangeTable[] inRanges)
	|        {
	|            foreach (var range in inRanges)
	|                if (range.InRange(rune))
	|                    return true;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// IsGraphic reports whether the rune is defined as a Graphic by Unicode.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Such characters include letters, marks, numbers, punctuation, symbols, and
	|        /// spaces, from categories L, M, N, P, S, Zs.
	|        /// </remarks>
	|        public static bool IsGraphic(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return (properties[rune] & CharClass.pg) != 0;
	|            return IsRuneInRanges(rune, GraphicRanges);
	|        }
	|
	|        /// <summary>
	|        /// IsPrint reports whether the rune is defined as printable.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Such characters include letters, marks, numbers, punctuation, symbols, and the
	|        /// ASCII space character, from categories L, M, N, P, S and the ASCII space
	|        /// character. This categorization is the same as IsGraphic except that the
	|        /// only spacing character is ASCII space, U+0020.
	|        /// </remarks>
	|        public static bool IsPrint(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return (properties[rune] & CharClass.pp) != 0;
	|            return IsRuneInRanges(rune, PrintRanges);
	|        }
	|
	|        /// <summary>
	|        /// IsControl reports whether the rune is a control character.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// The C (Other) Unicode category includes more code points such as surrogates; use C.InRange (r) to test for them.
	|        /// </remarks>
	|        public static bool IsControl(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return (properties[rune] & CharClass.pC) != 0;
	|            // All control characters are < MaxLatin1.
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// IsLetter reports whether the rune is a letter (category L).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// </remarks>
	|        public static bool IsLetter(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return (properties[rune] & CharClass.pLmask) != 0;
	|            return Category.L.IsExcludingLatin(rune);
	|        }
	|
	|        /// <summary>
	|        /// IsMark reports whether the rune is a letter (category M).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Reports whether the rune is a mark character (category M).
	|        /// </remarks>
	|        public static bool IsMark(uint rune)
	|        {
	|            // There are no mark characters in Latin-1.
	|            return Category.M.IsExcludingLatin(rune);
	|        }
	|
	|        /// <summary>
	|        /// IsNumber reports whether the rune is a letter (category N).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Reports whether the rune is a mark character (category N).
	|        /// </remarks>
	|        public static bool IsNumber(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return (properties[rune] & CharClass.pN) != 0;
	|            return Category.N.IsExcludingLatin(rune);
	|        }
	|
	|        /// <summary>
	|        /// IsPunct reports whether the rune is a letter (category P).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Reports whether the rune is a mark character (category P).
	|        /// </remarks>
	|        public static bool IsPunct(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return (properties[rune] & CharClass.pP) != 0;
	|            return Category.P.IsExcludingLatin(rune);
	|        }
	|
	|        /// <summary>
	|        /// IsSpace reports whether the rune is a space character as defined by Unicode's White Space property.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// In the Latin-1 space, white space includes '\t', '\n', '\v', '\f', '\r', ' ', 
	|        /// U+0085 (NEL), U+00A0 (NBSP).
	|        /// Other definitions of spacing characters are set by category  Z and property Pattern_White_Space.
	|        /// </remarks>
	|        public static bool IsSpace(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|            {
	|                if (rune == '\t' || rune == '\n' || rune == '\v' || rune == '\f' || rune == '\r' || rune == ' ' || rune == 0x85 || rune == 0xa0)
	|                    return true;
	|                return false;
	|            }
	|            return Property.White_Space.IsExcludingLatin(rune);
	|        }
	|
	|        /// <summary>
	|        /// IsSymbol reports whether the rune is a symbolic character.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsSymbol(uint rune)
	|        {
	|            if (rune < MaxLatin1)
	|                return (properties[rune] & CharClass.pS) != 0;
	|            return Category.S.IsExcludingLatin(rune);
	|        }
	|
	|
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Unicode class contains helper methods to support Unicode encoding.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///    Generally the Unicode class provided methods that can help you classify and
	|    ///    convert Unicode code points.  The word codepoint is considered a mouthful so in
	|    ///    this class, the word ""rune"" is used instead and is represented by the
	|    ///    uint value type.  
	|    /// </para>
	|    /// <para>
	|    ///    Unicode code points can be produced by combining independent characters,
	|    ///    so the rune for a character can be produced by combining one character and
	|    ///    other elements of it.  Runes on the other hand correspond to a specific
	|    ///    character.
	|    /// </para>
	|    /// <para>
	|    ///    This class surfaces various methods to classify case of a Rune, like
	|    ///    <see cref=""M:NStack.Unicode.IsUpper""/>, <see cref=""M:NStack.Unicode.IsLower""/>, <see cref=""M:NStack.Unicode.IsDigit""/>,
	|    ///    <see cref=""M:NStack.Unicode.IsGraphic""/> to convert runes from one case to another using the <see cref=""M:NStack.Unicode.ToUpper""/>,
	|    ///    <see cref=""M:NStack.Unicode.ToLower""/>, <see cref=""M:NStack.Unicode.ToTitle""/> as well as various constants
	|    ///    that are useful when working with Unicode runes.
	|    /// </para>  
	|    /// <para>
	|    ///    Unicode defines various character classes which are surfaced as RangeTables
	|    ///    as static properties in this class.   You can probe whether a rune belongs
	|    ///    to a specific range table
	|    /// </para>
	|    /// </remarks>
	|    public partial class Unicode
	|    {
	|        /// <summary>
	|        /// Maximum valid Unicode code point.
	|        /// </summary> 
	|        public const int MaxRune = 0x0010FFFF;
	|
	|        /// <summary>
	|        /// Represents invalid code points.
	|        /// </summary>
	|        public const uint ReplacementChar = 0xfffd;     // 
	|
	|        /// <summary>
	|        /// The maximum ASCII value.
	|        /// </summary>
	|        public const uint MaxAscii = 0x7f;
	|
	|        /// <summary>
	|        /// The maximum latin1 value.
	|        /// </summary>
	|        public const uint MaxLatin1 = 0xff;
	|
	|        // Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi
	|        // inclusive and has the specified stride.
	|        internal struct Range16
	|        {
	|            public ushort Lo, Hi, Stride;
	|
	|            public Range16(ushort lo, ushort hi, ushort stride)
	|            {
	|                Lo = lo;
	|                Hi = hi;
	|                Stride = stride;
	|            }
	|        }
	|
	|        // Range32 represents of a range of Unicode code points and is used when one or
	|        // more of the values will not fit in 16 bits. The range runs from Lo to Hi
	|        // inclusive and has the specified stride. Lo and Hi must always be >= 1<<16.
	|        internal struct Range32
	|        {
	|            public int Lo, Hi, Stride;
	|
	|            public Range32(int lo, int hi, int stride)
	|            {
	|                Lo = lo;
	|                Hi = hi;
	|                Stride = stride;
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Range tables describe classes of unicode code points.
	|        /// </summary>
	|        /// 
	|        // RangeTable defines a set of Unicode code points by listing the ranges of
	|        // code points within the set. The ranges are listed in two slices
	|        // to save space: a slice of 16-bit ranges and a slice of 32-bit ranges.
	|        // The two slices must be in sorted order and non-overlapping.
	|        // Also, R32 should contain only values >= 0x10000 (1<<16).
	|        public struct RangeTable
	|        {
	|            readonly Range16[] R16;
	|            readonly Range32[] R32;
	|
	|            /// <summary>
	|            /// The number of entries in the short range table (R16) with Hi being less than MaxLatin1
	|            /// </summary>
	|            public readonly int LatinOffset;
	|
	|            internal RangeTable(Range16[] r16 = null, Range32[] r32 = null, int latinOffset = 0)
	|            {
	|                R16 = r16;
	|                R32 = r32;
	|                LatinOffset = latinOffset;
	|            }
	|
	|            /// <summary>
	|            /// Used to determine if a given rune is in the range of this RangeTable.
	|            /// </summary>
	|            /// <returns><c>true</c>, if the rune is in this RangeTable, <c>false</c> otherwise.</returns>
	|            /// <param name=""rune"">Rune.</param>
	|            public bool InRange(uint rune)
	|            {
	|                if (R16 != null)
	|                {
	|                    var r16l = R16.Length;
	|
	|                    if (rune <= R16[r16l - 1].Hi)
	|                        return Is16(R16, (ushort)rune);
	|                }
	|                if (R32 != null)
	|                {
	|                    var r32l = R32.Length;
	|                    if (rune >= R32[0].Lo)
	|                        return Is32(R32, rune);
	|                }
	|                return false;
	|            }
	|
	|            /// <summary>
	|            /// Used to determine if a given rune is in the range of this RangeTable, excluding latin1 characters.
	|            /// </summary>
	|            /// <returns><c>true</c>, if the rune is part of the range (not including latin), <c>false</c> otherwise.</returns>
	|            /// <param name=""rune"">Rune.</param>
	|            public bool IsExcludingLatin(uint rune)
	|            {
	|                var off = LatinOffset;
	|
	|                if (R16 != null)
	|                {
	|                    var r16l = R16.Length;
	|
	|                    if (r16l > off && rune <= R16[r16l - 1].Hi)
	|                        return Is16(R16, (ushort)rune, off);
	|                }
	|                if (R32 != null)
	|                {
	|                    if (R32.Length > 0 && rune >= R32[0].Lo)
	|                        return Is32(R32, rune);
	|                }
	|                return false;
	|            }
	|        }
	|
	|        // CaseRange represents a range of Unicode code points for simple (one
	|        // code point to one code point) case conversion.
	|        // The range runs from Lo to Hi inclusive, with a fixed stride of 1.  Deltas
	|        // are the number to add to the code point to reach the code point for a
	|        // different case for that character. They may be negative. If zero, it
	|        // means the character is in the corresponding case. There is a special
	|        // case representing sequences of alternating corresponding Upper and Lower
	|        // pairs. It appears with a fixed Delta of
	|        //      {UpperLower, UpperLower, UpperLower}
	|        // The constant UpperLower has an otherwise impossible delta value.
	|        internal struct CaseRange
	|        {
	|            public int Lo, Hi;
	|            public unsafe fixed int Delta[3];
	|
	|            public CaseRange(int lo, int hi, int d1, int d2, int d3)
	|            {
	|                Lo = lo;
	|                Hi = hi;
	|                unsafe
	|                {
	|                    fixed (int* p = Delta)
	|                    {
	|                        p[0] = d1;
	|                        p[1] = d2;
	|                        p[2] = d3;
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The types of cases supported.
	|        /// </summary>
	|        public enum Case
	|        {
	|            /// <summary>
	|            /// Upper case
	|            /// </summary>
	|            Upper = 0,
	|
	|            /// <summary>
	|            /// Lower case
	|            /// </summary>
	|            Lower = 1,
	|
	|            /// <summary>
	|            /// Titlecase capitalizes the first letter, and keeps the rest in lowercase.
	|            /// Sometimes it is not as straight forward as the uppercase, some characters require special handling, like
	|            /// certain ligatures and greek characters.
	|            /// </summary>
	|            Title = 2
	|        };
	|
	|        // If the Delta field of a CaseRange is UpperLower, it means
	|        // this CaseRange represents a sequence of the form (say)
	|        // Upper Lower Upper Lower.
	|        const int UpperLower = MaxRune + 1;
	|
	|        // linearMax is the maximum size table for linear search for non-Latin1 rune.
	|        const int linearMax = 18;
	|
	|        static bool Is16(Range16[] ranges, ushort r, int lo = 0)
	|        {
	|            if (ranges.Length - lo < linearMax || r <= MaxLatin1)
	|            {
	|                for (int i = lo; i < ranges.Length; i++)
	|                {
	|                    var range = ranges[i];
	|
	|                    if (r < range.Lo)
	|                        return false;
	|                    if (r <= range.Hi)
	|                        return (r - range.Lo) % range.Stride == 0;
	|                }
	|                return false;
	|            }
	|            var hi = ranges.Length;
	|            // binary search over ranges
	|            while (lo < hi)
	|            {
	|                var m = lo + (hi - lo) / 2;
	|                var range = ranges[m];
	|                if (range.Lo <= r && r <= range.Hi)
	|                    return (r - range.Lo) % range.Stride == 0;
	|                if (r < range.Lo)
	|                    hi = m;
	|                else
	|                    lo = m + 1;
	|            }
	|            return false;
	|        }
	|
	|        static bool Is32(Range32[] ranges, uint r)
	|        {
	|            var hi = ranges.Length;
	|            if (hi < linearMax || r <= MaxLatin1)
	|            {
	|                foreach (var range in ranges)
	|                {
	|                    if (r < range.Lo)
	|                        return false;
	|                    if (r <= range.Hi)
	|                        return (r - range.Lo) % range.Stride == 0;
	|                }
	|                return false;
	|            }
	|            // binary search over ranges
	|            var lo = 0;
	|            while (lo < hi)
	|            {
	|                var m = lo + (hi - lo) / 2;
	|                var range = ranges[m];
	|                if (range.Lo <= r && r <= range.Hi)
	|                    return (r - range.Lo) % range.Stride == 0;
	|                if (r < range.Lo)
	|                    hi = m;
	|                else
	|                    lo = m + 1;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Reports whether the rune is an upper case letter.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is an upper case lette, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsUpper(uint rune)
	|        {
	|            if (rune <= MaxLatin1)
	|                return (properties[(byte)rune] & CharClass.pLmask) == CharClass.pLu;
	|            return Category.Upper.IsExcludingLatin(rune);
	|        }
	|
	|        /// <summary>
	|        /// Reports whether the rune is a lower case letter.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case lette, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsLower(uint rune)
	|        {
	|            if (rune <= MaxLatin1)
	|                return (properties[(byte)rune] & CharClass.pLmask) == CharClass.pLl;
	|            return Category.Lower.IsExcludingLatin(rune);
	|        }
	|
	|        /// <summary>
	|        /// Reports whether the rune is a title case letter.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case lette, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsTitle(uint rune)
	|        {
	|            if (rune <= MaxLatin1)
	|                return false;
	|            return Category.Title.IsExcludingLatin(rune);
	|        }
	|
	|        // to maps the rune using the specified case mapping.
	|        static unsafe uint to(Case toCase, uint rune, CaseRange[] caseRange)
	|        {
	|            if (toCase < 0 || toCase > Case.Title)
	|                return ReplacementChar;
	|
	|            // binary search over ranges
	|            var lo = 0;
	|            var hi = caseRange.Length;
	|
	|            while (lo < hi)
	|            {
	|                var m = lo + (hi - lo) / 2;
	|                var cr = caseRange[m];
	|                if (cr.Lo <= rune && rune <= cr.Hi)
	|                {
	|                    var delta = cr.Delta[(int)toCase];
	|                    if (delta > MaxRune)
	|                    {
	|                        // In an Upper-Lower sequence, which always starts with
	|                        // an UpperCase letter, the real deltas always look like:
	|                        //      {0, 1, 0}    UpperCase (Lower is next)
	|                        //      {-1, 0, -1}  LowerCase (Upper, Title are previous)
	|                        // The characters at even offsets from the beginning of the
	|                        // sequence are upper case; the ones at odd offsets are lower.
	|                        // The correct mapping can be done by clearing or setting the low
	|                        // bit in the sequence offset.
	|                        // The constants UpperCase and TitleCase are even while LowerCase
	|                        // is odd so we take the low bit from _case.
	|
	|                        return ((uint)cr.Lo) + (((rune - ((uint)(cr.Lo))) & 0xfffffffe) | ((uint)((uint)toCase) & 1));
	|                    }
	|                    return (uint)((int)rune + delta);
	|                }
	|                if (rune < cr.Lo)
	|                    hi = m;
	|                else
	|                    lo = m + 1;
	|            }
	|            return rune;
	|        }
	|
	|        // To maps the rune to the specified case: Case.Upper, Case.Lower, or Case.Title
	|        /// <summary>
	|        /// To maps the rune to the specified case: Case.Upper, Case.Lower, or Case.Title
	|        /// </summary>
	|        /// <returns>The cased character.</returns>
	|        /// <param name=""toCase"">The destination case.</param>
	|        /// <param name=""rune"">Rune to convert.</param>
	|        public static uint To(Case toCase, uint rune)
	|        {
	|            return to(toCase, rune, CaseRanges);
	|        }
	|
	|        /// <summary>
	|        /// ToUpper maps the rune to upper case.
	|        /// </summary>
	|        /// <returns>The upper cased rune if it can be.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        public static uint ToUpper(uint rune)
	|        {
	|            if (rune <= MaxAscii)
	|            {
	|                if ('a' <= rune && rune <= 'z')
	|                    rune -= 'a' - 'A';
	|                return rune;
	|            }
	|            return To(Case.Upper, rune);
	|        }
	|
	|        /// <summary>
	|        /// ToLower maps the rune to lower case.
	|        /// </summary>
	|        /// <returns>The lower cased rune if it can be.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        public static uint ToLower(uint rune)
	|        {
	|            if (rune <= MaxAscii)
	|            {
	|                if ('A' <= rune && rune <= 'Z')
	|                    rune += 'a' - 'A';
	|                return rune;
	|            }
	|            return To(Case.Lower, rune);
	|        }
	|
	|        /// <summary>
	|        /// ToLower maps the rune to title case.
	|        /// </summary>
	|        /// <returns>The lower cased rune if it can be.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        public static uint ToTitle(uint rune)
	|        {
	|            if (rune <= MaxAscii)
	|            {
	|                if ('a' <= rune && rune <= 'z')
	|                    rune -= 'a' - 'A';
	|                return rune;
	|            }
	|            return To(Case.Title, rune);
	|        }
	|
	|        /// <summary>
	|        /// SpecialCase represents language-specific case mappings such as Turkish.
	|        /// </summary>
	|        /// <remarks>
	|        /// Methods of SpecialCase customize (by overriding) the standard mappings.
	|        /// </remarks>
	|        public struct SpecialCase
	|        {
	|            Unicode.CaseRange[] Special;
	|            internal SpecialCase(CaseRange[] special)
	|            {
	|                Special = special;
	|            }
	|
	|            /// <summary>
	|            /// ToUpper maps the rune to upper case giving priority to the special mapping.
	|            /// </summary>
	|            /// <returns>The upper cased rune if it can be.</returns>
	|            /// <param name=""rune"">Rune.</param>
	|            public uint ToUpper(uint rune)
	|            {
	|                var result = to(Case.Upper, rune, Special);
	|                if (result == rune)
	|                    result = Unicode.ToUpper(rune);
	|                return result;
	|            }
	|
	|            /// <summary>
	|            /// ToTitle maps the rune to title case giving priority to the special mapping.
	|            /// </summary>
	|            /// <returns>The title cased rune if it can be.</returns>
	|            /// <param name=""rune"">Rune.</param>
	|            public uint ToTitle(uint rune)
	|            {
	|                var result = to(Case.Title, rune, Special);
	|                if (result == rune)
	|                    result = Unicode.ToTitle(rune);
	|                return result;
	|            }
	|
	|            /// <summary>
	|            /// ToLower maps the rune to lower case giving priority to the special mapping.
	|            /// </summary>
	|            /// <returns>The lower cased rune if it can be.</returns>
	|            /// <param name=""rune"">Rune.</param>
	|            public uint ToLower(uint rune)
	|            {
	|                var result = to(Case.Lower, rune, Special);
	|                if (result == rune)
	|                    result = Unicode.ToLower(rune);
	|                return result;
	|            }
	|        }
	|
	|        // CaseOrbit is defined in tables.cs as foldPair []. Right now all the
	|        // entries fit in ushort, so use ushort.  If that changes, compilation
	|        // will fail (the constants in the composite literal will not fit in ushort)
	|        // and the types here can change to uint.
	|        struct FoldPair
	|        {
	|            public ushort From, To;
	|
	|            public FoldPair(ushort from, ushort to)
	|            {
	|                From = from;
	|                To = to;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// SimpleFold iterates over Unicode code points equivalent under
	|        /// the Unicode-defined simple case folding.
	|        /// </summary>
	|        /// <returns>The simple-case folded rune.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        /// <remarks>
	|        /// SimpleFold iterates over Unicode code points equivalent under
	|        /// the Unicode-defined simple case folding. Among the code points
	|        /// equivalent to rune (including rune itself), SimpleFold returns the
	|        /// smallest rune > r if one exists, or else the smallest rune >= 0.
	|        /// If r is not a valid Unicode code point, SimpleFold(r) returns r.
	|        ///
	|        /// For example:
	|        /// <code>
	|        ///      SimpleFold('A') = 'a'
	|        ///      SimpleFold('a') = 'A'
	|        ///
	|        ///      SimpleFold('K') = 'k'
	|        ///      SimpleFold('k') = '\u212A' (Kelvin symbol, K)
	|        ///      SimpleFold('\u212A') = 'K'
	|        ///
	|        ///      SimpleFold('1') = '1'
	|        ///
	|        ///      SimpleFold(-2) = -2
	|        /// </code>
	|        /// </remarks>
	|        public static uint SimpleFold(uint rune)
	|        {
	|            if (rune >= MaxRune)
	|                return rune;
	|            if (rune < asciiFold.Length)
	|                return (uint)asciiFold[rune];
	|            // Consult caseOrbit table for special cases.
	|            var lo = 0;
	|            var hi = CaseOrbit.Length;
	|            while (lo < hi)
	|            {
	|                var m = lo + (hi - lo) / 2;
	|                if (CaseOrbit[m].From < rune)
	|                    lo = m + 1;
	|                else
	|                    hi = m;
	|            }
	|            if (lo < CaseOrbit.Length && CaseOrbit[lo].From == rune)
	|                return CaseOrbit[lo].To;
	|            // No folding specified. This is a one- or two-element
	|            // equivalence class containing rune and ToLower(rune)
	|            // and ToUpper(rune) if they are different from rune.
	|            var l = ToLower(rune);
	|            if (l != rune)
	|                return l;
	|            return ToUpper(rune);
	|        }
	|    }
	|    //=======================================================================
	|    // Copyright 2013 The Go Authors, Microsoft. All rights reserved.
	|    // Use of this source code is governed by a BSD-style
	|    // license that can be found in the LICENSE file.
	|
	|    // Generated by running
	|    //	maketables --tables=all --data=https://www.unicode.org/Public/15.0.0/ucd/UnicodeData.txt --casefolding=https://www.unicode.org/Public/15.0.0/ucd/CaseFolding.txt
	|    // DO NOT EDIT
	|
	|    public partial class Unicode
	|    {
	|        /// <summary>
	|        /// Version is the Unicode edition from which the tables are derived.
	|        /// </summary>
	|        public const string Version = ""15.0.0"";
	|
	|        /// <summary>Static class containing the various Unicode category range tables</summary>
	|        /// <remarks><para>There are static properties that can be used to fetch a specific category, or you can use the <see cref=""M:NStack.Unicode.Category.Get""/> method this class to retrieve the RangeTable by its Unicode category table name</para></remarks>
	|        public static class Category
	|        {
	|            /// <summary>Retrieves the specified RangeTable from the Unicode category name</summary>
	|            /// <param name=""categoryName"">The unicode character category name</param>
	|            public static RangeTable Get(string categoryName) => Categories[categoryName];
	|            // Categories is the set of Unicode category tables.
	|            static Dictionary<string, RangeTable> Categories = new Dictionary<string, RangeTable>() {
	|            { ""C"", C },
	|            { ""Cc"", Cc },
	|            { ""Cf"", Cf },
	|            { ""Co"", Co },
	|            { ""Cs"", Cs },
	|            { ""L"", L },
	|            { ""Ll"", Ll },
	|            { ""Lm"", Lm },
	|            { ""Lo"", Lo },
	|            { ""Lt"", Lt },
	|            { ""Lu"", Lu },
	|            { ""M"", M },
	|            { ""Mc"", Mc },
	|            { ""Me"", Me },
	|            { ""Mn"", Mn },
	|            { ""N"", N },
	|            { ""Nd"", Nd },
	|            { ""Nl"", Nl },
	|            { ""No"", No },
	|            { ""P"", P },
	|            { ""Pc"", Pc },
	|            { ""Pd"", Pd },
	|            { ""Pe"", Pe },
	|            { ""Pf"", Pf },
	|            { ""Pi"", Pi },
	|            { ""Po"", Po },
	|            { ""Ps"", Ps },
	|            { ""S"", S },
	|            { ""Sc"", Sc },
	|            { ""Sk"", Sk },
	|            { ""Sm"", Sm },
	|            { ""So"", So },
	|            { ""Z"", Z },
	|            { ""Zl"", Zl },
	|            { ""Zp"", Zp },
	|            { ""Zs"", Zs },
	|        };
	|
	|            internal static RangeTable _C = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0000, 0x001f, 1),
	|            new Range16 (0x007f, 0x009f, 1),
	|            new Range16 (0x00ad, 0x0600, 1363),
	|            new Range16 (0x0601, 0x0605, 1),
	|            new Range16 (0x061c, 0x06dd, 193),
	|            new Range16 (0x070f, 0x0890, 385),
	|            new Range16 (0x0891, 0x08e2, 81),
	|            new Range16 (0x180e, 0x200b, 2045),
	|            new Range16 (0x200c, 0x200f, 1),
	|            new Range16 (0x202a, 0x202e, 1),
	|            new Range16 (0x2060, 0x2064, 1),
	|            new Range16 (0x2066, 0x206f, 1),
	|            new Range16 (0xd800, 0xf8ff, 1),
	|            new Range16 (0xfeff, 0xfff9, 250),
	|            new Range16 (0xfffa, 0xfffb, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x110bd, 0x110cd, 16),
	|            new Range32 (0x13430, 0x1343f, 1),
	|            new Range32 (0x1bca0, 0x1bca3, 1),
	|            new Range32 (0x1d173, 0x1d17a, 1),
	|            new Range32 (0xe0001, 0xe0020, 31),
	|            new Range32 (0xe0021, 0xe007f, 1),
	|            new Range32 (0xf0000, 0xffffd, 1),
	|            new Range32 (0x100000, 0x10fffd, 1),
	|                },
	|                latinOffset: 2
	|            );
	|
	|            internal static RangeTable _Cc = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0000, 0x001f, 1),
	|            new Range16 (0x007f, 0x009f, 1),
	|                },
	|                latinOffset: 2
	|            );
	|
	|            internal static RangeTable _Cf = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00ad, 0x0600, 1363),
	|            new Range16 (0x0601, 0x0605, 1),
	|            new Range16 (0x061c, 0x06dd, 193),
	|            new Range16 (0x070f, 0x0890, 385),
	|            new Range16 (0x0891, 0x08e2, 81),
	|            new Range16 (0x180e, 0x200b, 2045),
	|            new Range16 (0x200c, 0x200f, 1),
	|            new Range16 (0x202a, 0x202e, 1),
	|            new Range16 (0x2060, 0x2064, 1),
	|            new Range16 (0x2066, 0x206f, 1),
	|            new Range16 (0xfeff, 0xfff9, 250),
	|            new Range16 (0xfffa, 0xfffb, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x110bd, 0x110cd, 16),
	|            new Range32 (0x13430, 0x1343f, 1),
	|            new Range32 (0x1bca0, 0x1bca3, 1),
	|            new Range32 (0x1d173, 0x1d17a, 1),
	|            new Range32 (0xe0001, 0xe0020, 31),
	|            new Range32 (0xe0021, 0xe007f, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Co = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xe000, 0xf8ff, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0xf0000, 0xffffd, 1),
	|            new Range32 (0x100000, 0x10fffd, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Cs = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xd800, 0xdfff, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _L = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0041, 0x005a, 1),
	|            new Range16 (0x0061, 0x007a, 1),
	|            new Range16 (0x00aa, 0x00b5, 11),
	|            new Range16 (0x00ba, 0x00c0, 6),
	|            new Range16 (0x00c1, 0x00d6, 1),
	|            new Range16 (0x00d8, 0x00f6, 1),
	|            new Range16 (0x00f8, 0x02c1, 1),
	|            new Range16 (0x02c6, 0x02d1, 1),
	|            new Range16 (0x02e0, 0x02e4, 1),
	|            new Range16 (0x02ec, 0x02ee, 2),
	|            new Range16 (0x0370, 0x0374, 1),
	|            new Range16 (0x0376, 0x0377, 1),
	|            new Range16 (0x037a, 0x037d, 1),
	|            new Range16 (0x037f, 0x0386, 7),
	|            new Range16 (0x0388, 0x038a, 1),
	|            new Range16 (0x038c, 0x038e, 2),
	|            new Range16 (0x038f, 0x03a1, 1),
	|            new Range16 (0x03a3, 0x03f5, 1),
	|            new Range16 (0x03f7, 0x0481, 1),
	|            new Range16 (0x048a, 0x052f, 1),
	|            new Range16 (0x0531, 0x0556, 1),
	|            new Range16 (0x0559, 0x0560, 7),
	|            new Range16 (0x0561, 0x0588, 1),
	|            new Range16 (0x05d0, 0x05ea, 1),
	|            new Range16 (0x05ef, 0x05f2, 1),
	|            new Range16 (0x0620, 0x064a, 1),
	|            new Range16 (0x066e, 0x066f, 1),
	|            new Range16 (0x0671, 0x06d3, 1),
	|            new Range16 (0x06d5, 0x06e5, 16),
	|            new Range16 (0x06e6, 0x06ee, 8),
	|            new Range16 (0x06ef, 0x06fa, 11),
	|            new Range16 (0x06fb, 0x06fc, 1),
	|            new Range16 (0x06ff, 0x0710, 17),
	|            new Range16 (0x0712, 0x072f, 1),
	|            new Range16 (0x074d, 0x07a5, 1),
	|            new Range16 (0x07b1, 0x07ca, 25),
	|            new Range16 (0x07cb, 0x07ea, 1),
	|            new Range16 (0x07f4, 0x07f5, 1),
	|            new Range16 (0x07fa, 0x0800, 6),
	|            new Range16 (0x0801, 0x0815, 1),
	|            new Range16 (0x081a, 0x0824, 10),
	|            new Range16 (0x0828, 0x0840, 24),
	|            new Range16 (0x0841, 0x0858, 1),
	|            new Range16 (0x0860, 0x086a, 1),
	|            new Range16 (0x0870, 0x0887, 1),
	|            new Range16 (0x0889, 0x088e, 1),
	|            new Range16 (0x08a0, 0x08c9, 1),
	|            new Range16 (0x0904, 0x0939, 1),
	|            new Range16 (0x093d, 0x0950, 19),
	|            new Range16 (0x0958, 0x0961, 1),
	|            new Range16 (0x0971, 0x0980, 1),
	|            new Range16 (0x0985, 0x098c, 1),
	|            new Range16 (0x098f, 0x0990, 1),
	|            new Range16 (0x0993, 0x09a8, 1),
	|            new Range16 (0x09aa, 0x09b0, 1),
	|            new Range16 (0x09b2, 0x09b6, 4),
	|            new Range16 (0x09b7, 0x09b9, 1),
	|            new Range16 (0x09bd, 0x09ce, 17),
	|            new Range16 (0x09dc, 0x09dd, 1),
	|            new Range16 (0x09df, 0x09e1, 1),
	|            new Range16 (0x09f0, 0x09f1, 1),
	|            new Range16 (0x09fc, 0x0a05, 9),
	|            new Range16 (0x0a06, 0x0a0a, 1),
	|            new Range16 (0x0a0f, 0x0a10, 1),
	|            new Range16 (0x0a13, 0x0a28, 1),
	|            new Range16 (0x0a2a, 0x0a30, 1),
	|            new Range16 (0x0a32, 0x0a33, 1),
	|            new Range16 (0x0a35, 0x0a36, 1),
	|            new Range16 (0x0a38, 0x0a39, 1),
	|            new Range16 (0x0a59, 0x0a5c, 1),
	|            new Range16 (0x0a5e, 0x0a72, 20),
	|            new Range16 (0x0a73, 0x0a74, 1),
	|            new Range16 (0x0a85, 0x0a8d, 1),
	|            new Range16 (0x0a8f, 0x0a91, 1),
	|            new Range16 (0x0a93, 0x0aa8, 1),
	|            new Range16 (0x0aaa, 0x0ab0, 1),
	|            new Range16 (0x0ab2, 0x0ab3, 1),
	|            new Range16 (0x0ab5, 0x0ab9, 1),
	|            new Range16 (0x0abd, 0x0ad0, 19),
	|            new Range16 (0x0ae0, 0x0ae1, 1),
	|            new Range16 (0x0af9, 0x0b05, 12),
	|            new Range16 (0x0b06, 0x0b0c, 1),
	|            new Range16 (0x0b0f, 0x0b10, 1),
	|            new Range16 (0x0b13, 0x0b28, 1),
	|            new Range16 (0x0b2a, 0x0b30, 1),
	|            new Range16 (0x0b32, 0x0b33, 1),
	|            new Range16 (0x0b35, 0x0b39, 1),
	|            new Range16 (0x0b3d, 0x0b5c, 31),
	|            new Range16 (0x0b5d, 0x0b5f, 2),
	|            new Range16 (0x0b60, 0x0b61, 1),
	|            new Range16 (0x0b71, 0x0b83, 18),
	|            new Range16 (0x0b85, 0x0b8a, 1),
	|            new Range16 (0x0b8e, 0x0b90, 1),
	|            new Range16 (0x0b92, 0x0b95, 1),
	|            new Range16 (0x0b99, 0x0b9a, 1),
	|            new Range16 (0x0b9c, 0x0b9e, 2),
	|            new Range16 (0x0b9f, 0x0ba3, 4),
	|            new Range16 (0x0ba4, 0x0ba8, 4),
	|            new Range16 (0x0ba9, 0x0baa, 1),
	|            new Range16 (0x0bae, 0x0bb9, 1),
	|            new Range16 (0x0bd0, 0x0c05, 53),
	|            new Range16 (0x0c06, 0x0c0c, 1),
	|            new Range16 (0x0c0e, 0x0c10, 1),
	|            new Range16 (0x0c12, 0x0c28, 1),
	|            new Range16 (0x0c2a, 0x0c39, 1),
	|            new Range16 (0x0c3d, 0x0c58, 27),
	|            new Range16 (0x0c59, 0x0c5a, 1),
	|            new Range16 (0x0c5d, 0x0c60, 3),
	|            new Range16 (0x0c61, 0x0c80, 31),
	|            new Range16 (0x0c85, 0x0c8c, 1),
	|            new Range16 (0x0c8e, 0x0c90, 1),
	|            new Range16 (0x0c92, 0x0ca8, 1),
	|            new Range16 (0x0caa, 0x0cb3, 1),
	|            new Range16 (0x0cb5, 0x0cb9, 1),
	|            new Range16 (0x0cbd, 0x0cdd, 32),
	|            new Range16 (0x0cde, 0x0ce0, 2),
	|            new Range16 (0x0ce1, 0x0cf1, 16),
	|            new Range16 (0x0cf2, 0x0d04, 18),
	|            new Range16 (0x0d05, 0x0d0c, 1),
	|            new Range16 (0x0d0e, 0x0d10, 1),
	|            new Range16 (0x0d12, 0x0d3a, 1),
	|            new Range16 (0x0d3d, 0x0d4e, 17),
	|            new Range16 (0x0d54, 0x0d56, 1),
	|            new Range16 (0x0d5f, 0x0d61, 1),
	|            new Range16 (0x0d7a, 0x0d7f, 1),
	|            new Range16 (0x0d85, 0x0d96, 1),
	|            new Range16 (0x0d9a, 0x0db1, 1),
	|            new Range16 (0x0db3, 0x0dbb, 1),
	|            new Range16 (0x0dbd, 0x0dc0, 3),
	|            new Range16 (0x0dc1, 0x0dc6, 1),
	|            new Range16 (0x0e01, 0x0e30, 1),
	|            new Range16 (0x0e32, 0x0e33, 1),
	|            new Range16 (0x0e40, 0x0e46, 1),
	|            new Range16 (0x0e81, 0x0e82, 1),
	|            new Range16 (0x0e84, 0x0e86, 2),
	|            new Range16 (0x0e87, 0x0e8a, 1),
	|            new Range16 (0x0e8c, 0x0ea3, 1),
	|            new Range16 (0x0ea5, 0x0ea7, 2),
	|            new Range16 (0x0ea8, 0x0eb0, 1),
	|            new Range16 (0x0eb2, 0x0eb3, 1),
	|            new Range16 (0x0ebd, 0x0ec0, 3),
	|            new Range16 (0x0ec1, 0x0ec4, 1),
	|            new Range16 (0x0ec6, 0x0edc, 22),
	|            new Range16 (0x0edd, 0x0edf, 1),
	|            new Range16 (0x0f00, 0x0f40, 64),
	|            new Range16 (0x0f41, 0x0f47, 1),
	|            new Range16 (0x0f49, 0x0f6c, 1),
	|            new Range16 (0x0f88, 0x0f8c, 1),
	|            new Range16 (0x1000, 0x102a, 1),
	|            new Range16 (0x103f, 0x1050, 17),
	|            new Range16 (0x1051, 0x1055, 1),
	|            new Range16 (0x105a, 0x105d, 1),
	|            new Range16 (0x1061, 0x1065, 4),
	|            new Range16 (0x1066, 0x106e, 8),
	|            new Range16 (0x106f, 0x1070, 1),
	|            new Range16 (0x1075, 0x1081, 1),
	|            new Range16 (0x108e, 0x10a0, 18),
	|            new Range16 (0x10a1, 0x10c5, 1),
	|            new Range16 (0x10c7, 0x10cd, 6),
	|            new Range16 (0x10d0, 0x10fa, 1),
	|            new Range16 (0x10fc, 0x1248, 1),
	|            new Range16 (0x124a, 0x124d, 1),
	|            new Range16 (0x1250, 0x1256, 1),
	|            new Range16 (0x1258, 0x125a, 2),
	|            new Range16 (0x125b, 0x125d, 1),
	|            new Range16 (0x1260, 0x1288, 1),
	|            new Range16 (0x128a, 0x128d, 1),
	|            new Range16 (0x1290, 0x12b0, 1),
	|            new Range16 (0x12b2, 0x12b5, 1),
	|            new Range16 (0x12b8, 0x12be, 1),
	|            new Range16 (0x12c0, 0x12c2, 2),
	|            new Range16 (0x12c3, 0x12c5, 1),
	|            new Range16 (0x12c8, 0x12d6, 1),
	|            new Range16 (0x12d8, 0x1310, 1),
	|            new Range16 (0x1312, 0x1315, 1),
	|            new Range16 (0x1318, 0x135a, 1),
	|            new Range16 (0x1380, 0x138f, 1),
	|            new Range16 (0x13a0, 0x13f5, 1),
	|            new Range16 (0x13f8, 0x13fd, 1),
	|            new Range16 (0x1401, 0x166c, 1),
	|            new Range16 (0x166f, 0x167f, 1),
	|            new Range16 (0x1681, 0x169a, 1),
	|            new Range16 (0x16a0, 0x16ea, 1),
	|            new Range16 (0x16f1, 0x16f8, 1),
	|            new Range16 (0x1700, 0x1711, 1),
	|            new Range16 (0x171f, 0x1731, 1),
	|            new Range16 (0x1740, 0x1751, 1),
	|            new Range16 (0x1760, 0x176c, 1),
	|            new Range16 (0x176e, 0x1770, 1),
	|            new Range16 (0x1780, 0x17b3, 1),
	|            new Range16 (0x17d7, 0x17dc, 5),
	|            new Range16 (0x1820, 0x1878, 1),
	|            new Range16 (0x1880, 0x1884, 1),
	|            new Range16 (0x1887, 0x18a8, 1),
	|            new Range16 (0x18aa, 0x18b0, 6),
	|            new Range16 (0x18b1, 0x18f5, 1),
	|            new Range16 (0x1900, 0x191e, 1),
	|            new Range16 (0x1950, 0x196d, 1),
	|            new Range16 (0x1970, 0x1974, 1),
	|            new Range16 (0x1980, 0x19ab, 1),
	|            new Range16 (0x19b0, 0x19c9, 1),
	|            new Range16 (0x1a00, 0x1a16, 1),
	|            new Range16 (0x1a20, 0x1a54, 1),
	|            new Range16 (0x1aa7, 0x1b05, 94),
	|            new Range16 (0x1b06, 0x1b33, 1),
	|            new Range16 (0x1b45, 0x1b4c, 1),
	|            new Range16 (0x1b83, 0x1ba0, 1),
	|            new Range16 (0x1bae, 0x1baf, 1),
	|            new Range16 (0x1bba, 0x1be5, 1),
	|            new Range16 (0x1c00, 0x1c23, 1),
	|            new Range16 (0x1c4d, 0x1c4f, 1),
	|            new Range16 (0x1c5a, 0x1c7d, 1),
	|            new Range16 (0x1c80, 0x1c88, 1),
	|            new Range16 (0x1c90, 0x1cba, 1),
	|            new Range16 (0x1cbd, 0x1cbf, 1),
	|            new Range16 (0x1ce9, 0x1cec, 1),
	|            new Range16 (0x1cee, 0x1cf3, 1),
	|            new Range16 (0x1cf5, 0x1cf6, 1),
	|            new Range16 (0x1cfa, 0x1d00, 6),
	|            new Range16 (0x1d01, 0x1dbf, 1),
	|            new Range16 (0x1e00, 0x1f15, 1),
	|            new Range16 (0x1f18, 0x1f1d, 1),
	|            new Range16 (0x1f20, 0x1f45, 1),
	|            new Range16 (0x1f48, 0x1f4d, 1),
	|            new Range16 (0x1f50, 0x1f57, 1),
	|            new Range16 (0x1f59, 0x1f5f, 2),
	|            new Range16 (0x1f60, 0x1f7d, 1),
	|            new Range16 (0x1f80, 0x1fb4, 1),
	|            new Range16 (0x1fb6, 0x1fbc, 1),
	|            new Range16 (0x1fbe, 0x1fc2, 4),
	|            new Range16 (0x1fc3, 0x1fc4, 1),
	|            new Range16 (0x1fc6, 0x1fcc, 1),
	|            new Range16 (0x1fd0, 0x1fd3, 1),
	|            new Range16 (0x1fd6, 0x1fdb, 1),
	|            new Range16 (0x1fe0, 0x1fec, 1),
	|            new Range16 (0x1ff2, 0x1ff4, 1),
	|            new Range16 (0x1ff6, 0x1ffc, 1),
	|            new Range16 (0x2071, 0x207f, 14),
	|            new Range16 (0x2090, 0x209c, 1),
	|            new Range16 (0x2102, 0x2107, 5),
	|            new Range16 (0x210a, 0x2113, 1),
	|            new Range16 (0x2115, 0x2119, 4),
	|            new Range16 (0x211a, 0x211d, 1),
	|            new Range16 (0x2124, 0x212a, 2),
	|            new Range16 (0x212b, 0x212d, 1),
	|            new Range16 (0x212f, 0x2139, 1),
	|            new Range16 (0x213c, 0x213f, 1),
	|            new Range16 (0x2145, 0x2149, 1),
	|            new Range16 (0x214e, 0x2183, 53),
	|            new Range16 (0x2184, 0x2c00, 2684),
	|            new Range16 (0x2c01, 0x2ce4, 1),
	|            new Range16 (0x2ceb, 0x2cee, 1),
	|            new Range16 (0x2cf2, 0x2cf3, 1),
	|            new Range16 (0x2d00, 0x2d25, 1),
	|            new Range16 (0x2d27, 0x2d2d, 6),
	|            new Range16 (0x2d30, 0x2d67, 1),
	|            new Range16 (0x2d6f, 0x2d80, 17),
	|            new Range16 (0x2d81, 0x2d96, 1),
	|            new Range16 (0x2da0, 0x2da6, 1),
	|            new Range16 (0x2da8, 0x2dae, 1),
	|            new Range16 (0x2db0, 0x2db6, 1),
	|            new Range16 (0x2db8, 0x2dbe, 1),
	|            new Range16 (0x2dc0, 0x2dc6, 1),
	|            new Range16 (0x2dc8, 0x2dce, 1),
	|            new Range16 (0x2dd0, 0x2dd6, 1),
	|            new Range16 (0x2dd8, 0x2dde, 1),
	|            new Range16 (0x2e2f, 0x3005, 470),
	|            new Range16 (0x3006, 0x3031, 43),
	|            new Range16 (0x3032, 0x3035, 1),
	|            new Range16 (0x303b, 0x303c, 1),
	|            new Range16 (0x3041, 0x3096, 1),
	|            new Range16 (0x309d, 0x309f, 1),
	|            new Range16 (0x30a1, 0x30fa, 1),
	|            new Range16 (0x30fc, 0x30ff, 1),
	|            new Range16 (0x3105, 0x312f, 1),
	|            new Range16 (0x3131, 0x318e, 1),
	|            new Range16 (0x31a0, 0x31bf, 1),
	|            new Range16 (0x31f0, 0x31ff, 1),
	|            new Range16 (0x3400, 0x4dbf, 1),
	|            new Range16 (0x4e00, 0xa48c, 1),
	|            new Range16 (0xa4d0, 0xa4fd, 1),
	|            new Range16 (0xa500, 0xa60c, 1),
	|            new Range16 (0xa610, 0xa61f, 1),
	|            new Range16 (0xa62a, 0xa62b, 1),
	|            new Range16 (0xa640, 0xa66e, 1),
	|            new Range16 (0xa67f, 0xa69d, 1),
	|            new Range16 (0xa6a0, 0xa6e5, 1),
	|            new Range16 (0xa717, 0xa71f, 1),
	|            new Range16 (0xa722, 0xa788, 1),
	|            new Range16 (0xa78b, 0xa7ca, 1),
	|            new Range16 (0xa7d0, 0xa7d1, 1),
	|            new Range16 (0xa7d3, 0xa7d5, 2),
	|            new Range16 (0xa7d6, 0xa7d9, 1),
	|            new Range16 (0xa7f2, 0xa801, 1),
	|            new Range16 (0xa803, 0xa805, 1),
	|            new Range16 (0xa807, 0xa80a, 1),
	|            new Range16 (0xa80c, 0xa822, 1),
	|            new Range16 (0xa840, 0xa873, 1),
	|            new Range16 (0xa882, 0xa8b3, 1),
	|            new Range16 (0xa8f2, 0xa8f7, 1),
	|            new Range16 (0xa8fb, 0xa8fd, 2),
	|            new Range16 (0xa8fe, 0xa90a, 12),
	|            new Range16 (0xa90b, 0xa925, 1),
	|            new Range16 (0xa930, 0xa946, 1),
	|            new Range16 (0xa960, 0xa97c, 1),
	|            new Range16 (0xa984, 0xa9b2, 1),
	|            new Range16 (0xa9cf, 0xa9e0, 17),
	|            new Range16 (0xa9e1, 0xa9e4, 1),
	|            new Range16 (0xa9e6, 0xa9ef, 1),
	|            new Range16 (0xa9fa, 0xa9fe, 1),
	|            new Range16 (0xaa00, 0xaa28, 1),
	|            new Range16 (0xaa40, 0xaa42, 1),
	|            new Range16 (0xaa44, 0xaa4b, 1),
	|            new Range16 (0xaa60, 0xaa76, 1),
	|            new Range16 (0xaa7a, 0xaa7e, 4),
	|            new Range16 (0xaa7f, 0xaaaf, 1),
	|            new Range16 (0xaab1, 0xaab5, 4),
	|            new Range16 (0xaab6, 0xaab9, 3),
	|            new Range16 (0xaaba, 0xaabd, 1),
	|            new Range16 (0xaac0, 0xaac2, 2),
	|            new Range16 (0xaadb, 0xaadd, 1),
	|            new Range16 (0xaae0, 0xaaea, 1),
	|            new Range16 (0xaaf2, 0xaaf4, 1),
	|            new Range16 (0xab01, 0xab06, 1),
	|            new Range16 (0xab09, 0xab0e, 1),
	|            new Range16 (0xab11, 0xab16, 1),
	|            new Range16 (0xab20, 0xab26, 1),
	|            new Range16 (0xab28, 0xab2e, 1),
	|            new Range16 (0xab30, 0xab5a, 1),
	|            new Range16 (0xab5c, 0xab69, 1),
	|            new Range16 (0xab70, 0xabe2, 1),
	|            new Range16 (0xac00, 0xd7a3, 1),
	|            new Range16 (0xd7b0, 0xd7c6, 1),
	|            new Range16 (0xd7cb, 0xd7fb, 1),
	|            new Range16 (0xf900, 0xfa6d, 1),
	|            new Range16 (0xfa70, 0xfad9, 1),
	|            new Range16 (0xfb00, 0xfb06, 1),
	|            new Range16 (0xfb13, 0xfb17, 1),
	|            new Range16 (0xfb1d, 0xfb1f, 2),
	|            new Range16 (0xfb20, 0xfb28, 1),
	|            new Range16 (0xfb2a, 0xfb36, 1),
	|            new Range16 (0xfb38, 0xfb3c, 1),
	|            new Range16 (0xfb3e, 0xfb40, 2),
	|            new Range16 (0xfb41, 0xfb43, 2),
	|            new Range16 (0xfb44, 0xfb46, 2),
	|            new Range16 (0xfb47, 0xfbb1, 1),
	|            new Range16 (0xfbd3, 0xfd3d, 1),
	|            new Range16 (0xfd50, 0xfd8f, 1),
	|            new Range16 (0xfd92, 0xfdc7, 1),
	|            new Range16 (0xfdf0, 0xfdfb, 1),
	|            new Range16 (0xfe70, 0xfe74, 1),
	|            new Range16 (0xfe76, 0xfefc, 1),
	|            new Range16 (0xff21, 0xff3a, 1),
	|            new Range16 (0xff41, 0xff5a, 1),
	|            new Range16 (0xff66, 0xffbe, 1),
	|            new Range16 (0xffc2, 0xffc7, 1),
	|            new Range16 (0xffca, 0xffcf, 1),
	|            new Range16 (0xffd2, 0xffd7, 1),
	|            new Range16 (0xffda, 0xffdc, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10000, 0x1000b, 1),
	|            new Range32 (0x1000d, 0x10026, 1),
	|            new Range32 (0x10028, 0x1003a, 1),
	|            new Range32 (0x1003c, 0x1003d, 1),
	|            new Range32 (0x1003f, 0x1004d, 1),
	|            new Range32 (0x10050, 0x1005d, 1),
	|            new Range32 (0x10080, 0x100fa, 1),
	|            new Range32 (0x10280, 0x1029c, 1),
	|            new Range32 (0x102a0, 0x102d0, 1),
	|            new Range32 (0x10300, 0x1031f, 1),
	|            new Range32 (0x1032d, 0x10340, 1),
	|            new Range32 (0x10342, 0x10349, 1),
	|            new Range32 (0x10350, 0x10375, 1),
	|            new Range32 (0x10380, 0x1039d, 1),
	|            new Range32 (0x103a0, 0x103c3, 1),
	|            new Range32 (0x103c8, 0x103cf, 1),
	|            new Range32 (0x10400, 0x1049d, 1),
	|            new Range32 (0x104b0, 0x104d3, 1),
	|            new Range32 (0x104d8, 0x104fb, 1),
	|            new Range32 (0x10500, 0x10527, 1),
	|            new Range32 (0x10530, 0x10563, 1),
	|            new Range32 (0x10570, 0x1057a, 1),
	|            new Range32 (0x1057c, 0x1058a, 1),
	|            new Range32 (0x1058c, 0x10592, 1),
	|            new Range32 (0x10594, 0x10595, 1),
	|            new Range32 (0x10597, 0x105a1, 1),
	|            new Range32 (0x105a3, 0x105b1, 1),
	|            new Range32 (0x105b3, 0x105b9, 1),
	|            new Range32 (0x105bb, 0x105bc, 1),
	|            new Range32 (0x10600, 0x10736, 1),
	|            new Range32 (0x10740, 0x10755, 1),
	|            new Range32 (0x10760, 0x10767, 1),
	|            new Range32 (0x10780, 0x10785, 1),
	|            new Range32 (0x10787, 0x107b0, 1),
	|            new Range32 (0x107b2, 0x107ba, 1),
	|            new Range32 (0x10800, 0x10805, 1),
	|            new Range32 (0x10808, 0x1080a, 2),
	|            new Range32 (0x1080b, 0x10835, 1),
	|            new Range32 (0x10837, 0x10838, 1),
	|            new Range32 (0x1083c, 0x1083f, 3),
	|            new Range32 (0x10840, 0x10855, 1),
	|            new Range32 (0x10860, 0x10876, 1),
	|            new Range32 (0x10880, 0x1089e, 1),
	|            new Range32 (0x108e0, 0x108f2, 1),
	|            new Range32 (0x108f4, 0x108f5, 1),
	|            new Range32 (0x10900, 0x10915, 1),
	|            new Range32 (0x10920, 0x10939, 1),
	|            new Range32 (0x10980, 0x109b7, 1),
	|            new Range32 (0x109be, 0x109bf, 1),
	|            new Range32 (0x10a00, 0x10a10, 16),
	|            new Range32 (0x10a11, 0x10a13, 1),
	|            new Range32 (0x10a15, 0x10a17, 1),
	|            new Range32 (0x10a19, 0x10a35, 1),
	|            new Range32 (0x10a60, 0x10a7c, 1),
	|            new Range32 (0x10a80, 0x10a9c, 1),
	|            new Range32 (0x10ac0, 0x10ac7, 1),
	|            new Range32 (0x10ac9, 0x10ae4, 1),
	|            new Range32 (0x10b00, 0x10b35, 1),
	|            new Range32 (0x10b40, 0x10b55, 1),
	|            new Range32 (0x10b60, 0x10b72, 1),
	|            new Range32 (0x10b80, 0x10b91, 1),
	|            new Range32 (0x10c00, 0x10c48, 1),
	|            new Range32 (0x10c80, 0x10cb2, 1),
	|            new Range32 (0x10cc0, 0x10cf2, 1),
	|            new Range32 (0x10d00, 0x10d23, 1),
	|            new Range32 (0x10e80, 0x10ea9, 1),
	|            new Range32 (0x10eb0, 0x10eb1, 1),
	|            new Range32 (0x10f00, 0x10f1c, 1),
	|            new Range32 (0x10f27, 0x10f30, 9),
	|            new Range32 (0x10f31, 0x10f45, 1),
	|            new Range32 (0x10f70, 0x10f81, 1),
	|            new Range32 (0x10fb0, 0x10fc4, 1),
	|            new Range32 (0x10fe0, 0x10ff6, 1),
	|            new Range32 (0x11003, 0x11037, 1),
	|            new Range32 (0x11071, 0x11072, 1),
	|            new Range32 (0x11075, 0x11083, 14),
	|            new Range32 (0x11084, 0x110af, 1),
	|            new Range32 (0x110d0, 0x110e8, 1),
	|            new Range32 (0x11103, 0x11126, 1),
	|            new Range32 (0x11144, 0x11147, 3),
	|            new Range32 (0x11150, 0x11172, 1),
	|            new Range32 (0x11176, 0x11183, 13),
	|            new Range32 (0x11184, 0x111b2, 1),
	|            new Range32 (0x111c1, 0x111c4, 1),
	|            new Range32 (0x111da, 0x111dc, 2),
	|            new Range32 (0x11200, 0x11211, 1),
	|            new Range32 (0x11213, 0x1122b, 1),
	|            new Range32 (0x1123f, 0x11240, 1),
	|            new Range32 (0x11280, 0x11286, 1),
	|            new Range32 (0x11288, 0x1128a, 2),
	|            new Range32 (0x1128b, 0x1128d, 1),
	|            new Range32 (0x1128f, 0x1129d, 1),
	|            new Range32 (0x1129f, 0x112a8, 1),
	|            new Range32 (0x112b0, 0x112de, 1),
	|            new Range32 (0x11305, 0x1130c, 1),
	|            new Range32 (0x1130f, 0x11310, 1),
	|            new Range32 (0x11313, 0x11328, 1),
	|            new Range32 (0x1132a, 0x11330, 1),
	|            new Range32 (0x11332, 0x11333, 1),
	|            new Range32 (0x11335, 0x11339, 1),
	|            new Range32 (0x1133d, 0x11350, 19),
	|            new Range32 (0x1135d, 0x11361, 1),
	|            new Range32 (0x11400, 0x11434, 1),
	|            new Range32 (0x11447, 0x1144a, 1),
	|            new Range32 (0x1145f, 0x11461, 1),
	|            new Range32 (0x11480, 0x114af, 1),
	|            new Range32 (0x114c4, 0x114c5, 1),
	|            new Range32 (0x114c7, 0x11580, 185),
	|            new Range32 (0x11581, 0x115ae, 1),
	|            new Range32 (0x115d8, 0x115db, 1),
	|            new Range32 (0x11600, 0x1162f, 1),
	|            new Range32 (0x11644, 0x11680, 60),
	|            new Range32 (0x11681, 0x116aa, 1),
	|            new Range32 (0x116b8, 0x11700, 72),
	|            new Range32 (0x11701, 0x1171a, 1),
	|            new Range32 (0x11740, 0x11746, 1),
	|            new Range32 (0x11800, 0x1182b, 1),
	|            new Range32 (0x118a0, 0x118df, 1),
	|            new Range32 (0x118ff, 0x11906, 1),
	|            new Range32 (0x11909, 0x1190c, 3),
	|            new Range32 (0x1190d, 0x11913, 1),
	|            new Range32 (0x11915, 0x11916, 1),
	|            new Range32 (0x11918, 0x1192f, 1),
	|            new Range32 (0x1193f, 0x11941, 2),
	|            new Range32 (0x119a0, 0x119a7, 1),
	|            new Range32 (0x119aa, 0x119d0, 1),
	|            new Range32 (0x119e1, 0x119e3, 2),
	|            new Range32 (0x11a00, 0x11a0b, 11),
	|            new Range32 (0x11a0c, 0x11a32, 1),
	|            new Range32 (0x11a3a, 0x11a50, 22),
	|            new Range32 (0x11a5c, 0x11a89, 1),
	|            new Range32 (0x11a9d, 0x11ab0, 19),
	|            new Range32 (0x11ab1, 0x11af8, 1),
	|            new Range32 (0x11c00, 0x11c08, 1),
	|            new Range32 (0x11c0a, 0x11c2e, 1),
	|            new Range32 (0x11c40, 0x11c72, 50),
	|            new Range32 (0x11c73, 0x11c8f, 1),
	|            new Range32 (0x11d00, 0x11d06, 1),
	|            new Range32 (0x11d08, 0x11d09, 1),
	|            new Range32 (0x11d0b, 0x11d30, 1),
	|            new Range32 (0x11d46, 0x11d60, 26),
	|            new Range32 (0x11d61, 0x11d65, 1),
	|            new Range32 (0x11d67, 0x11d68, 1),
	|            new Range32 (0x11d6a, 0x11d89, 1),
	|            new Range32 (0x11d98, 0x11ee0, 328),
	|            new Range32 (0x11ee1, 0x11ef2, 1),
	|            new Range32 (0x11f02, 0x11f04, 2),
	|            new Range32 (0x11f05, 0x11f10, 1),
	|            new Range32 (0x11f12, 0x11f33, 1),
	|            new Range32 (0x11fb0, 0x12000, 80),
	|            new Range32 (0x12001, 0x12399, 1),
	|            new Range32 (0x12480, 0x12543, 1),
	|            new Range32 (0x12f90, 0x12ff0, 1),
	|            new Range32 (0x13000, 0x1342f, 1),
	|            new Range32 (0x13441, 0x13446, 1),
	|            new Range32 (0x14400, 0x14646, 1),
	|            new Range32 (0x16800, 0x16a38, 1),
	|            new Range32 (0x16a40, 0x16a5e, 1),
	|            new Range32 (0x16a70, 0x16abe, 1),
	|            new Range32 (0x16ad0, 0x16aed, 1),
	|            new Range32 (0x16b00, 0x16b2f, 1),
	|            new Range32 (0x16b40, 0x16b43, 1),
	|            new Range32 (0x16b63, 0x16b77, 1),
	|            new Range32 (0x16b7d, 0x16b8f, 1),
	|            new Range32 (0x16e40, 0x16e7f, 1),
	|            new Range32 (0x16f00, 0x16f4a, 1),
	|            new Range32 (0x16f50, 0x16f93, 67),
	|            new Range32 (0x16f94, 0x16f9f, 1),
	|            new Range32 (0x16fe0, 0x16fe1, 1),
	|            new Range32 (0x16fe3, 0x17000, 29),
	|            new Range32 (0x17001, 0x187f7, 1),
	|            new Range32 (0x18800, 0x18cd5, 1),
	|            new Range32 (0x18d00, 0x18d08, 1),
	|            new Range32 (0x1aff0, 0x1aff3, 1),
	|            new Range32 (0x1aff5, 0x1affb, 1),
	|            new Range32 (0x1affd, 0x1affe, 1),
	|            new Range32 (0x1b000, 0x1b122, 1),
	|            new Range32 (0x1b132, 0x1b150, 30),
	|            new Range32 (0x1b151, 0x1b152, 1),
	|            new Range32 (0x1b155, 0x1b164, 15),
	|            new Range32 (0x1b165, 0x1b167, 1),
	|            new Range32 (0x1b170, 0x1b2fb, 1),
	|            new Range32 (0x1bc00, 0x1bc6a, 1),
	|            new Range32 (0x1bc70, 0x1bc7c, 1),
	|            new Range32 (0x1bc80, 0x1bc88, 1),
	|            new Range32 (0x1bc90, 0x1bc99, 1),
	|            new Range32 (0x1d400, 0x1d454, 1),
	|            new Range32 (0x1d456, 0x1d49c, 1),
	|            new Range32 (0x1d49e, 0x1d49f, 1),
	|            new Range32 (0x1d4a2, 0x1d4a5, 3),
	|            new Range32 (0x1d4a6, 0x1d4a9, 3),
	|            new Range32 (0x1d4aa, 0x1d4ac, 1),
	|            new Range32 (0x1d4ae, 0x1d4b9, 1),
	|            new Range32 (0x1d4bb, 0x1d4bd, 2),
	|            new Range32 (0x1d4be, 0x1d4c3, 1),
	|            new Range32 (0x1d4c5, 0x1d505, 1),
	|            new Range32 (0x1d507, 0x1d50a, 1),
	|            new Range32 (0x1d50d, 0x1d514, 1),
	|            new Range32 (0x1d516, 0x1d51c, 1),
	|            new Range32 (0x1d51e, 0x1d539, 1),
	|            new Range32 (0x1d53b, 0x1d53e, 1),
	|            new Range32 (0x1d540, 0x1d544, 1),
	|            new Range32 (0x1d546, 0x1d54a, 4),
	|            new Range32 (0x1d54b, 0x1d550, 1),
	|            new Range32 (0x1d552, 0x1d6a5, 1),
	|            new Range32 (0x1d6a8, 0x1d6c0, 1),
	|            new Range32 (0x1d6c2, 0x1d6da, 1),
	|            new Range32 (0x1d6dc, 0x1d6fa, 1),
	|            new Range32 (0x1d6fc, 0x1d714, 1),
	|            new Range32 (0x1d716, 0x1d734, 1),
	|            new Range32 (0x1d736, 0x1d74e, 1),
	|            new Range32 (0x1d750, 0x1d76e, 1),
	|            new Range32 (0x1d770, 0x1d788, 1),
	|            new Range32 (0x1d78a, 0x1d7a8, 1),
	|            new Range32 (0x1d7aa, 0x1d7c2, 1),
	|            new Range32 (0x1d7c4, 0x1d7cb, 1),
	|            new Range32 (0x1df00, 0x1df1e, 1),
	|            new Range32 (0x1df25, 0x1df2a, 1),
	|            new Range32 (0x1e030, 0x1e06d, 1),
	|            new Range32 (0x1e100, 0x1e12c, 1),
	|            new Range32 (0x1e137, 0x1e13d, 1),
	|            new Range32 (0x1e14e, 0x1e290, 322),
	|            new Range32 (0x1e291, 0x1e2ad, 1),
	|            new Range32 (0x1e2c0, 0x1e2eb, 1),
	|            new Range32 (0x1e4d0, 0x1e4eb, 1),
	|            new Range32 (0x1e7e0, 0x1e7e6, 1),
	|            new Range32 (0x1e7e8, 0x1e7eb, 1),
	|            new Range32 (0x1e7ed, 0x1e7ee, 1),
	|            new Range32 (0x1e7f0, 0x1e7fe, 1),
	|            new Range32 (0x1e800, 0x1e8c4, 1),
	|            new Range32 (0x1e900, 0x1e943, 1),
	|            new Range32 (0x1e94b, 0x1ee00, 1205),
	|            new Range32 (0x1ee01, 0x1ee03, 1),
	|            new Range32 (0x1ee05, 0x1ee1f, 1),
	|            new Range32 (0x1ee21, 0x1ee22, 1),
	|            new Range32 (0x1ee24, 0x1ee27, 3),
	|            new Range32 (0x1ee29, 0x1ee32, 1),
	|            new Range32 (0x1ee34, 0x1ee37, 1),
	|            new Range32 (0x1ee39, 0x1ee3b, 2),
	|            new Range32 (0x1ee42, 0x1ee47, 5),
	|            new Range32 (0x1ee49, 0x1ee4d, 2),
	|            new Range32 (0x1ee4e, 0x1ee4f, 1),
	|            new Range32 (0x1ee51, 0x1ee52, 1),
	|            new Range32 (0x1ee54, 0x1ee57, 3),
	|            new Range32 (0x1ee59, 0x1ee61, 2),
	|            new Range32 (0x1ee62, 0x1ee64, 2),
	|            new Range32 (0x1ee67, 0x1ee6a, 1),
	|            new Range32 (0x1ee6c, 0x1ee72, 1),
	|            new Range32 (0x1ee74, 0x1ee77, 1),
	|            new Range32 (0x1ee79, 0x1ee7c, 1),
	|            new Range32 (0x1ee7e, 0x1ee80, 2),
	|            new Range32 (0x1ee81, 0x1ee89, 1),
	|            new Range32 (0x1ee8b, 0x1ee9b, 1),
	|            new Range32 (0x1eea1, 0x1eea3, 1),
	|            new Range32 (0x1eea5, 0x1eea9, 1),
	|            new Range32 (0x1eeab, 0x1eebb, 1),
	|            new Range32 (0x20000, 0x2a6df, 1),
	|            new Range32 (0x2a700, 0x2b739, 1),
	|            new Range32 (0x2b740, 0x2b81d, 1),
	|            new Range32 (0x2b820, 0x2cea1, 1),
	|            new Range32 (0x2ceb0, 0x2ebe0, 1),
	|            new Range32 (0x2f800, 0x2fa1d, 1),
	|            new Range32 (0x30000, 0x3134a, 1),
	|            new Range32 (0x31350, 0x323af, 1),
	|                },
	|                latinOffset: 6
	|            );
	|
	|            internal static RangeTable _Ll = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0061, 0x007a, 1),
	|            new Range16 (0x00b5, 0x00df, 42),
	|            new Range16 (0x00e0, 0x00f6, 1),
	|            new Range16 (0x00f8, 0x00ff, 1),
	|            new Range16 (0x0101, 0x0137, 2),
	|            new Range16 (0x0138, 0x0148, 2),
	|            new Range16 (0x0149, 0x0177, 2),
	|            new Range16 (0x017a, 0x017e, 2),
	|            new Range16 (0x017f, 0x0180, 1),
	|            new Range16 (0x0183, 0x0185, 2),
	|            new Range16 (0x0188, 0x018c, 4),
	|            new Range16 (0x018d, 0x0192, 5),
	|            new Range16 (0x0195, 0x0199, 4),
	|            new Range16 (0x019a, 0x019b, 1),
	|            new Range16 (0x019e, 0x01a1, 3),
	|            new Range16 (0x01a3, 0x01a5, 2),
	|            new Range16 (0x01a8, 0x01aa, 2),
	|            new Range16 (0x01ab, 0x01ad, 2),
	|            new Range16 (0x01b0, 0x01b4, 4),
	|            new Range16 (0x01b6, 0x01b9, 3),
	|            new Range16 (0x01ba, 0x01bd, 3),
	|            new Range16 (0x01be, 0x01bf, 1),
	|            new Range16 (0x01c6, 0x01cc, 3),
	|            new Range16 (0x01ce, 0x01dc, 2),
	|            new Range16 (0x01dd, 0x01ef, 2),
	|            new Range16 (0x01f0, 0x01f3, 3),
	|            new Range16 (0x01f5, 0x01f9, 4),
	|            new Range16 (0x01fb, 0x0233, 2),
	|            new Range16 (0x0234, 0x0239, 1),
	|            new Range16 (0x023c, 0x023f, 3),
	|            new Range16 (0x0240, 0x0242, 2),
	|            new Range16 (0x0247, 0x024f, 2),
	|            new Range16 (0x0250, 0x0293, 1),
	|            new Range16 (0x0295, 0x02af, 1),
	|            new Range16 (0x0371, 0x0373, 2),
	|            new Range16 (0x0377, 0x037b, 4),
	|            new Range16 (0x037c, 0x037d, 1),
	|            new Range16 (0x0390, 0x03ac, 28),
	|            new Range16 (0x03ad, 0x03ce, 1),
	|            new Range16 (0x03d0, 0x03d1, 1),
	|            new Range16 (0x03d5, 0x03d7, 1),
	|            new Range16 (0x03d9, 0x03ef, 2),
	|            new Range16 (0x03f0, 0x03f3, 1),
	|            new Range16 (0x03f5, 0x03fb, 3),
	|            new Range16 (0x03fc, 0x0430, 52),
	|            new Range16 (0x0431, 0x045f, 1),
	|            new Range16 (0x0461, 0x0481, 2),
	|            new Range16 (0x048b, 0x04bf, 2),
	|            new Range16 (0x04c2, 0x04ce, 2),
	|            new Range16 (0x04cf, 0x052f, 2),
	|            new Range16 (0x0560, 0x0588, 1),
	|            new Range16 (0x10d0, 0x10fa, 1),
	|            new Range16 (0x10fd, 0x10ff, 1),
	|            new Range16 (0x13f8, 0x13fd, 1),
	|            new Range16 (0x1c80, 0x1c88, 1),
	|            new Range16 (0x1d00, 0x1d2b, 1),
	|            new Range16 (0x1d6b, 0x1d77, 1),
	|            new Range16 (0x1d79, 0x1d9a, 1),
	|            new Range16 (0x1e01, 0x1e95, 2),
	|            new Range16 (0x1e96, 0x1e9d, 1),
	|            new Range16 (0x1e9f, 0x1eff, 2),
	|            new Range16 (0x1f00, 0x1f07, 1),
	|            new Range16 (0x1f10, 0x1f15, 1),
	|            new Range16 (0x1f20, 0x1f27, 1),
	|            new Range16 (0x1f30, 0x1f37, 1),
	|            new Range16 (0x1f40, 0x1f45, 1),
	|            new Range16 (0x1f50, 0x1f57, 1),
	|            new Range16 (0x1f60, 0x1f67, 1),
	|            new Range16 (0x1f70, 0x1f7d, 1),
	|            new Range16 (0x1f80, 0x1f87, 1),
	|            new Range16 (0x1f90, 0x1f97, 1),
	|            new Range16 (0x1fa0, 0x1fa7, 1),
	|            new Range16 (0x1fb0, 0x1fb4, 1),
	|            new Range16 (0x1fb6, 0x1fb7, 1),
	|            new Range16 (0x1fbe, 0x1fc2, 4),
	|            new Range16 (0x1fc3, 0x1fc4, 1),
	|            new Range16 (0x1fc6, 0x1fc7, 1),
	|            new Range16 (0x1fd0, 0x1fd3, 1),
	|            new Range16 (0x1fd6, 0x1fd7, 1),
	|            new Range16 (0x1fe0, 0x1fe7, 1),
	|            new Range16 (0x1ff2, 0x1ff4, 1),
	|            new Range16 (0x1ff6, 0x1ff7, 1),
	|            new Range16 (0x210a, 0x210e, 4),
	|            new Range16 (0x210f, 0x2113, 4),
	|            new Range16 (0x212f, 0x2139, 5),
	|            new Range16 (0x213c, 0x213d, 1),
	|            new Range16 (0x2146, 0x2149, 1),
	|            new Range16 (0x214e, 0x2184, 54),
	|            new Range16 (0x2c30, 0x2c5f, 1),
	|            new Range16 (0x2c61, 0x2c65, 4),
	|            new Range16 (0x2c66, 0x2c6c, 2),
	|            new Range16 (0x2c71, 0x2c73, 2),
	|            new Range16 (0x2c74, 0x2c76, 2),
	|            new Range16 (0x2c77, 0x2c7b, 1),
	|            new Range16 (0x2c81, 0x2ce3, 2),
	|            new Range16 (0x2ce4, 0x2cec, 8),
	|            new Range16 (0x2cee, 0x2cf3, 5),
	|            new Range16 (0x2d00, 0x2d25, 1),
	|            new Range16 (0x2d27, 0x2d2d, 6),
	|            new Range16 (0xa641, 0xa66d, 2),
	|            new Range16 (0xa681, 0xa69b, 2),
	|            new Range16 (0xa723, 0xa72f, 2),
	|            new Range16 (0xa730, 0xa731, 1),
	|            new Range16 (0xa733, 0xa771, 2),
	|            new Range16 (0xa772, 0xa778, 1),
	|            new Range16 (0xa77a, 0xa77c, 2),
	|            new Range16 (0xa77f, 0xa787, 2),
	|            new Range16 (0xa78c, 0xa78e, 2),
	|            new Range16 (0xa791, 0xa793, 2),
	|            new Range16 (0xa794, 0xa795, 1),
	|            new Range16 (0xa797, 0xa7a9, 2),
	|            new Range16 (0xa7af, 0xa7b5, 6),
	|            new Range16 (0xa7b7, 0xa7c3, 2),
	|            new Range16 (0xa7c8, 0xa7ca, 2),
	|            new Range16 (0xa7d1, 0xa7d9, 2),
	|            new Range16 (0xa7f6, 0xa7fa, 4),
	|            new Range16 (0xab30, 0xab5a, 1),
	|            new Range16 (0xab60, 0xab68, 1),
	|            new Range16 (0xab70, 0xabbf, 1),
	|            new Range16 (0xfb00, 0xfb06, 1),
	|            new Range16 (0xfb13, 0xfb17, 1),
	|            new Range16 (0xff41, 0xff5a, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10428, 0x1044f, 1),
	|            new Range32 (0x104d8, 0x104fb, 1),
	|            new Range32 (0x10597, 0x105a1, 1),
	|            new Range32 (0x105a3, 0x105b1, 1),
	|            new Range32 (0x105b3, 0x105b9, 1),
	|            new Range32 (0x105bb, 0x105bc, 1),
	|            new Range32 (0x10cc0, 0x10cf2, 1),
	|            new Range32 (0x118c0, 0x118df, 1),
	|            new Range32 (0x16e60, 0x16e7f, 1),
	|            new Range32 (0x1d41a, 0x1d433, 1),
	|            new Range32 (0x1d44e, 0x1d454, 1),
	|            new Range32 (0x1d456, 0x1d467, 1),
	|            new Range32 (0x1d482, 0x1d49b, 1),
	|            new Range32 (0x1d4b6, 0x1d4b9, 1),
	|            new Range32 (0x1d4bb, 0x1d4bd, 2),
	|            new Range32 (0x1d4be, 0x1d4c3, 1),
	|            new Range32 (0x1d4c5, 0x1d4cf, 1),
	|            new Range32 (0x1d4ea, 0x1d503, 1),
	|            new Range32 (0x1d51e, 0x1d537, 1),
	|            new Range32 (0x1d552, 0x1d56b, 1),
	|            new Range32 (0x1d586, 0x1d59f, 1),
	|            new Range32 (0x1d5ba, 0x1d5d3, 1),
	|            new Range32 (0x1d5ee, 0x1d607, 1),
	|            new Range32 (0x1d622, 0x1d63b, 1),
	|            new Range32 (0x1d656, 0x1d66f, 1),
	|            new Range32 (0x1d68a, 0x1d6a5, 1),
	|            new Range32 (0x1d6c2, 0x1d6da, 1),
	|            new Range32 (0x1d6dc, 0x1d6e1, 1),
	|            new Range32 (0x1d6fc, 0x1d714, 1),
	|            new Range32 (0x1d716, 0x1d71b, 1),
	|            new Range32 (0x1d736, 0x1d74e, 1),
	|            new Range32 (0x1d750, 0x1d755, 1),
	|            new Range32 (0x1d770, 0x1d788, 1),
	|            new Range32 (0x1d78a, 0x1d78f, 1),
	|            new Range32 (0x1d7aa, 0x1d7c2, 1),
	|            new Range32 (0x1d7c4, 0x1d7c9, 1),
	|            new Range32 (0x1d7cb, 0x1df00, 1845),
	|            new Range32 (0x1df01, 0x1df09, 1),
	|            new Range32 (0x1df0b, 0x1df1e, 1),
	|            new Range32 (0x1df25, 0x1df2a, 1),
	|            new Range32 (0x1e922, 0x1e943, 1),
	|                },
	|                latinOffset: 4
	|            );
	|
	|            internal static RangeTable _Lm = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x02b0, 0x02c1, 1),
	|            new Range16 (0x02c6, 0x02d1, 1),
	|            new Range16 (0x02e0, 0x02e4, 1),
	|            new Range16 (0x02ec, 0x02ee, 2),
	|            new Range16 (0x0374, 0x037a, 6),
	|            new Range16 (0x0559, 0x0640, 231),
	|            new Range16 (0x06e5, 0x06e6, 1),
	|            new Range16 (0x07f4, 0x07f5, 1),
	|            new Range16 (0x07fa, 0x081a, 32),
	|            new Range16 (0x0824, 0x0828, 4),
	|            new Range16 (0x08c9, 0x0971, 168),
	|            new Range16 (0x0e46, 0x0ec6, 128),
	|            new Range16 (0x10fc, 0x17d7, 1755),
	|            new Range16 (0x1843, 0x1aa7, 612),
	|            new Range16 (0x1c78, 0x1c7d, 1),
	|            new Range16 (0x1d2c, 0x1d6a, 1),
	|            new Range16 (0x1d78, 0x1d9b, 35),
	|            new Range16 (0x1d9c, 0x1dbf, 1),
	|            new Range16 (0x2071, 0x207f, 14),
	|            new Range16 (0x2090, 0x209c, 1),
	|            new Range16 (0x2c7c, 0x2c7d, 1),
	|            new Range16 (0x2d6f, 0x2e2f, 192),
	|            new Range16 (0x3005, 0x3031, 44),
	|            new Range16 (0x3032, 0x3035, 1),
	|            new Range16 (0x303b, 0x309d, 98),
	|            new Range16 (0x309e, 0x30fc, 94),
	|            new Range16 (0x30fd, 0x30fe, 1),
	|            new Range16 (0xa015, 0xa4f8, 1251),
	|            new Range16 (0xa4f9, 0xa4fd, 1),
	|            new Range16 (0xa60c, 0xa67f, 115),
	|            new Range16 (0xa69c, 0xa69d, 1),
	|            new Range16 (0xa717, 0xa71f, 1),
	|            new Range16 (0xa770, 0xa788, 24),
	|            new Range16 (0xa7f2, 0xa7f4, 1),
	|            new Range16 (0xa7f8, 0xa7f9, 1),
	|            new Range16 (0xa9cf, 0xa9e6, 23),
	|            new Range16 (0xaa70, 0xaadd, 109),
	|            new Range16 (0xaaf3, 0xaaf4, 1),
	|            new Range16 (0xab5c, 0xab5f, 1),
	|            new Range16 (0xab69, 0xff70, 21511),
	|            new Range16 (0xff9e, 0xff9f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10780, 0x10785, 1),
	|            new Range32 (0x10787, 0x107b0, 1),
	|            new Range32 (0x107b2, 0x107ba, 1),
	|            new Range32 (0x16b40, 0x16b43, 1),
	|            new Range32 (0x16f93, 0x16f9f, 1),
	|            new Range32 (0x16fe0, 0x16fe1, 1),
	|            new Range32 (0x16fe3, 0x1aff0, 16397),
	|            new Range32 (0x1aff1, 0x1aff3, 1),
	|            new Range32 (0x1aff5, 0x1affb, 1),
	|            new Range32 (0x1affd, 0x1affe, 1),
	|            new Range32 (0x1e030, 0x1e06d, 1),
	|            new Range32 (0x1e137, 0x1e13d, 1),
	|            new Range32 (0x1e4eb, 0x1e94b, 1120),
	|                }
	|            );
	|
	|            internal static RangeTable _Lo = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00aa, 0x00ba, 16),
	|            new Range16 (0x01bb, 0x01c0, 5),
	|            new Range16 (0x01c1, 0x01c3, 1),
	|            new Range16 (0x0294, 0x05d0, 828),
	|            new Range16 (0x05d1, 0x05ea, 1),
	|            new Range16 (0x05ef, 0x05f2, 1),
	|            new Range16 (0x0620, 0x063f, 1),
	|            new Range16 (0x0641, 0x064a, 1),
	|            new Range16 (0x066e, 0x066f, 1),
	|            new Range16 (0x0671, 0x06d3, 1),
	|            new Range16 (0x06d5, 0x06ee, 25),
	|            new Range16 (0x06ef, 0x06fa, 11),
	|            new Range16 (0x06fb, 0x06fc, 1),
	|            new Range16 (0x06ff, 0x0710, 17),
	|            new Range16 (0x0712, 0x072f, 1),
	|            new Range16 (0x074d, 0x07a5, 1),
	|            new Range16 (0x07b1, 0x07ca, 25),
	|            new Range16 (0x07cb, 0x07ea, 1),
	|            new Range16 (0x0800, 0x0815, 1),
	|            new Range16 (0x0840, 0x0858, 1),
	|            new Range16 (0x0860, 0x086a, 1),
	|            new Range16 (0x0870, 0x0887, 1),
	|            new Range16 (0x0889, 0x088e, 1),
	|            new Range16 (0x08a0, 0x08c8, 1),
	|            new Range16 (0x0904, 0x0939, 1),
	|            new Range16 (0x093d, 0x0950, 19),
	|            new Range16 (0x0958, 0x0961, 1),
	|            new Range16 (0x0972, 0x0980, 1),
	|            new Range16 (0x0985, 0x098c, 1),
	|            new Range16 (0x098f, 0x0990, 1),
	|            new Range16 (0x0993, 0x09a8, 1),
	|            new Range16 (0x09aa, 0x09b0, 1),
	|            new Range16 (0x09b2, 0x09b6, 4),
	|            new Range16 (0x09b7, 0x09b9, 1),
	|            new Range16 (0x09bd, 0x09ce, 17),
	|            new Range16 (0x09dc, 0x09dd, 1),
	|            new Range16 (0x09df, 0x09e1, 1),
	|            new Range16 (0x09f0, 0x09f1, 1),
	|            new Range16 (0x09fc, 0x0a05, 9),
	|            new Range16 (0x0a06, 0x0a0a, 1),
	|            new Range16 (0x0a0f, 0x0a10, 1),
	|            new Range16 (0x0a13, 0x0a28, 1),
	|            new Range16 (0x0a2a, 0x0a30, 1),
	|            new Range16 (0x0a32, 0x0a33, 1),
	|            new Range16 (0x0a35, 0x0a36, 1),
	|            new Range16 (0x0a38, 0x0a39, 1),
	|            new Range16 (0x0a59, 0x0a5c, 1),
	|            new Range16 (0x0a5e, 0x0a72, 20),
	|            new Range16 (0x0a73, 0x0a74, 1),
	|            new Range16 (0x0a85, 0x0a8d, 1),
	|            new Range16 (0x0a8f, 0x0a91, 1),
	|            new Range16 (0x0a93, 0x0aa8, 1),
	|            new Range16 (0x0aaa, 0x0ab0, 1),
	|            new Range16 (0x0ab2, 0x0ab3, 1),
	|            new Range16 (0x0ab5, 0x0ab9, 1),
	|            new Range16 (0x0abd, 0x0ad0, 19),
	|            new Range16 (0x0ae0, 0x0ae1, 1),
	|            new Range16 (0x0af9, 0x0b05, 12),
	|            new Range16 (0x0b06, 0x0b0c, 1),
	|            new Range16 (0x0b0f, 0x0b10, 1),
	|            new Range16 (0x0b13, 0x0b28, 1),
	|            new Range16 (0x0b2a, 0x0b30, 1),
	|            new Range16 (0x0b32, 0x0b33, 1),
	|            new Range16 (0x0b35, 0x0b39, 1),
	|            new Range16 (0x0b3d, 0x0b5c, 31),
	|            new Range16 (0x0b5d, 0x0b5f, 2),
	|            new Range16 (0x0b60, 0x0b61, 1),
	|            new Range16 (0x0b71, 0x0b83, 18),
	|            new Range16 (0x0b85, 0x0b8a, 1),
	|            new Range16 (0x0b8e, 0x0b90, 1),
	|            new Range16 (0x0b92, 0x0b95, 1),
	|            new Range16 (0x0b99, 0x0b9a, 1),
	|            new Range16 (0x0b9c, 0x0b9e, 2),
	|            new Range16 (0x0b9f, 0x0ba3, 4),
	|            new Range16 (0x0ba4, 0x0ba8, 4),
	|            new Range16 (0x0ba9, 0x0baa, 1),
	|            new Range16 (0x0bae, 0x0bb9, 1),
	|            new Range16 (0x0bd0, 0x0c05, 53),
	|            new Range16 (0x0c06, 0x0c0c, 1),
	|            new Range16 (0x0c0e, 0x0c10, 1),
	|            new Range16 (0x0c12, 0x0c28, 1),
	|            new Range16 (0x0c2a, 0x0c39, 1),
	|            new Range16 (0x0c3d, 0x0c58, 27),
	|            new Range16 (0x0c59, 0x0c5a, 1),
	|            new Range16 (0x0c5d, 0x0c60, 3),
	|            new Range16 (0x0c61, 0x0c80, 31),
	|            new Range16 (0x0c85, 0x0c8c, 1),
	|            new Range16 (0x0c8e, 0x0c90, 1),
	|            new Range16 (0x0c92, 0x0ca8, 1),
	|            new Range16 (0x0caa, 0x0cb3, 1),
	|            new Range16 (0x0cb5, 0x0cb9, 1),
	|            new Range16 (0x0cbd, 0x0cdd, 32),
	|            new Range16 (0x0cde, 0x0ce0, 2),
	|            new Range16 (0x0ce1, 0x0cf1, 16),
	|            new Range16 (0x0cf2, 0x0d04, 18),
	|            new Range16 (0x0d05, 0x0d0c, 1),
	|            new Range16 (0x0d0e, 0x0d10, 1),
	|            new Range16 (0x0d12, 0x0d3a, 1),
	|            new Range16 (0x0d3d, 0x0d4e, 17),
	|            new Range16 (0x0d54, 0x0d56, 1),
	|            new Range16 (0x0d5f, 0x0d61, 1),
	|            new Range16 (0x0d7a, 0x0d7f, 1),
	|            new Range16 (0x0d85, 0x0d96, 1),
	|            new Range16 (0x0d9a, 0x0db1, 1),
	|            new Range16 (0x0db3, 0x0dbb, 1),
	|            new Range16 (0x0dbd, 0x0dc0, 3),
	|            new Range16 (0x0dc1, 0x0dc6, 1),
	|            new Range16 (0x0e01, 0x0e30, 1),
	|            new Range16 (0x0e32, 0x0e33, 1),
	|            new Range16 (0x0e40, 0x0e45, 1),
	|            new Range16 (0x0e81, 0x0e82, 1),
	|            new Range16 (0x0e84, 0x0e86, 2),
	|            new Range16 (0x0e87, 0x0e8a, 1),
	|            new Range16 (0x0e8c, 0x0ea3, 1),
	|            new Range16 (0x0ea5, 0x0ea7, 2),
	|            new Range16 (0x0ea8, 0x0eb0, 1),
	|            new Range16 (0x0eb2, 0x0eb3, 1),
	|            new Range16 (0x0ebd, 0x0ec0, 3),
	|            new Range16 (0x0ec1, 0x0ec4, 1),
	|            new Range16 (0x0edc, 0x0edf, 1),
	|            new Range16 (0x0f00, 0x0f40, 64),
	|            new Range16 (0x0f41, 0x0f47, 1),
	|            new Range16 (0x0f49, 0x0f6c, 1),
	|            new Range16 (0x0f88, 0x0f8c, 1),
	|            new Range16 (0x1000, 0x102a, 1),
	|            new Range16 (0x103f, 0x1050, 17),
	|            new Range16 (0x1051, 0x1055, 1),
	|            new Range16 (0x105a, 0x105d, 1),
	|            new Range16 (0x1061, 0x1065, 4),
	|            new Range16 (0x1066, 0x106e, 8),
	|            new Range16 (0x106f, 0x1070, 1),
	|            new Range16 (0x1075, 0x1081, 1),
	|            new Range16 (0x108e, 0x1100, 114),
	|            new Range16 (0x1101, 0x1248, 1),
	|            new Range16 (0x124a, 0x124d, 1),
	|            new Range16 (0x1250, 0x1256, 1),
	|            new Range16 (0x1258, 0x125a, 2),
	|            new Range16 (0x125b, 0x125d, 1),
	|            new Range16 (0x1260, 0x1288, 1),
	|            new Range16 (0x128a, 0x128d, 1),
	|            new Range16 (0x1290, 0x12b0, 1),
	|            new Range16 (0x12b2, 0x12b5, 1),
	|            new Range16 (0x12b8, 0x12be, 1),
	|            new Range16 (0x12c0, 0x12c2, 2),
	|            new Range16 (0x12c3, 0x12c5, 1),
	|            new Range16 (0x12c8, 0x12d6, 1),
	|            new Range16 (0x12d8, 0x1310, 1),
	|            new Range16 (0x1312, 0x1315, 1),
	|            new Range16 (0x1318, 0x135a, 1),
	|            new Range16 (0x1380, 0x138f, 1),
	|            new Range16 (0x1401, 0x166c, 1),
	|            new Range16 (0x166f, 0x167f, 1),
	|            new Range16 (0x1681, 0x169a, 1),
	|            new Range16 (0x16a0, 0x16ea, 1),
	|            new Range16 (0x16f1, 0x16f8, 1),
	|            new Range16 (0x1700, 0x1711, 1),
	|            new Range16 (0x171f, 0x1731, 1),
	|            new Range16 (0x1740, 0x1751, 1),
	|            new Range16 (0x1760, 0x176c, 1),
	|            new Range16 (0x176e, 0x1770, 1),
	|            new Range16 (0x1780, 0x17b3, 1),
	|            new Range16 (0x17dc, 0x1820, 68),
	|            new Range16 (0x1821, 0x1842, 1),
	|            new Range16 (0x1844, 0x1878, 1),
	|            new Range16 (0x1880, 0x1884, 1),
	|            new Range16 (0x1887, 0x18a8, 1),
	|            new Range16 (0x18aa, 0x18b0, 6),
	|            new Range16 (0x18b1, 0x18f5, 1),
	|            new Range16 (0x1900, 0x191e, 1),
	|            new Range16 (0x1950, 0x196d, 1),
	|            new Range16 (0x1970, 0x1974, 1),
	|            new Range16 (0x1980, 0x19ab, 1),
	|            new Range16 (0x19b0, 0x19c9, 1),
	|            new Range16 (0x1a00, 0x1a16, 1),
	|            new Range16 (0x1a20, 0x1a54, 1),
	|            new Range16 (0x1b05, 0x1b33, 1),
	|            new Range16 (0x1b45, 0x1b4c, 1),
	|            new Range16 (0x1b83, 0x1ba0, 1),
	|            new Range16 (0x1bae, 0x1baf, 1),
	|            new Range16 (0x1bba, 0x1be5, 1),
	|            new Range16 (0x1c00, 0x1c23, 1),
	|            new Range16 (0x1c4d, 0x1c4f, 1),
	|            new Range16 (0x1c5a, 0x1c77, 1),
	|            new Range16 (0x1ce9, 0x1cec, 1),
	|            new Range16 (0x1cee, 0x1cf3, 1),
	|            new Range16 (0x1cf5, 0x1cf6, 1),
	|            new Range16 (0x1cfa, 0x2135, 1083),
	|            new Range16 (0x2136, 0x2138, 1),
	|            new Range16 (0x2d30, 0x2d67, 1),
	|            new Range16 (0x2d80, 0x2d96, 1),
	|            new Range16 (0x2da0, 0x2da6, 1),
	|            new Range16 (0x2da8, 0x2dae, 1),
	|            new Range16 (0x2db0, 0x2db6, 1),
	|            new Range16 (0x2db8, 0x2dbe, 1),
	|            new Range16 (0x2dc0, 0x2dc6, 1),
	|            new Range16 (0x2dc8, 0x2dce, 1),
	|            new Range16 (0x2dd0, 0x2dd6, 1),
	|            new Range16 (0x2dd8, 0x2dde, 1),
	|            new Range16 (0x3006, 0x303c, 54),
	|            new Range16 (0x3041, 0x3096, 1),
	|            new Range16 (0x309f, 0x30a1, 2),
	|            new Range16 (0x30a2, 0x30fa, 1),
	|            new Range16 (0x30ff, 0x3105, 6),
	|            new Range16 (0x3106, 0x312f, 1),
	|            new Range16 (0x3131, 0x318e, 1),
	|            new Range16 (0x31a0, 0x31bf, 1),
	|            new Range16 (0x31f0, 0x31ff, 1),
	|            new Range16 (0x3400, 0x4dbf, 1),
	|            new Range16 (0x4e00, 0xa014, 1),
	|            new Range16 (0xa016, 0xa48c, 1),
	|            new Range16 (0xa4d0, 0xa4f7, 1),
	|            new Range16 (0xa500, 0xa60b, 1),
	|            new Range16 (0xa610, 0xa61f, 1),
	|            new Range16 (0xa62a, 0xa62b, 1),
	|            new Range16 (0xa66e, 0xa6a0, 50),
	|            new Range16 (0xa6a1, 0xa6e5, 1),
	|            new Range16 (0xa78f, 0xa7f7, 104),
	|            new Range16 (0xa7fb, 0xa801, 1),
	|            new Range16 (0xa803, 0xa805, 1),
	|            new Range16 (0xa807, 0xa80a, 1),
	|            new Range16 (0xa80c, 0xa822, 1),
	|            new Range16 (0xa840, 0xa873, 1),
	|            new Range16 (0xa882, 0xa8b3, 1),
	|            new Range16 (0xa8f2, 0xa8f7, 1),
	|            new Range16 (0xa8fb, 0xa8fd, 2),
	|            new Range16 (0xa8fe, 0xa90a, 12),
	|            new Range16 (0xa90b, 0xa925, 1),
	|            new Range16 (0xa930, 0xa946, 1),
	|            new Range16 (0xa960, 0xa97c, 1),
	|            new Range16 (0xa984, 0xa9b2, 1),
	|            new Range16 (0xa9e0, 0xa9e4, 1),
	|            new Range16 (0xa9e7, 0xa9ef, 1),
	|            new Range16 (0xa9fa, 0xa9fe, 1),
	|            new Range16 (0xaa00, 0xaa28, 1),
	|            new Range16 (0xaa40, 0xaa42, 1),
	|            new Range16 (0xaa44, 0xaa4b, 1),
	|            new Range16 (0xaa60, 0xaa6f, 1),
	|            new Range16 (0xaa71, 0xaa76, 1),
	|            new Range16 (0xaa7a, 0xaa7e, 4),
	|            new Range16 (0xaa7f, 0xaaaf, 1),
	|            new Range16 (0xaab1, 0xaab5, 4),
	|            new Range16 (0xaab6, 0xaab9, 3),
	|            new Range16 (0xaaba, 0xaabd, 1),
	|            new Range16 (0xaac0, 0xaac2, 2),
	|            new Range16 (0xaadb, 0xaadc, 1),
	|            new Range16 (0xaae0, 0xaaea, 1),
	|            new Range16 (0xaaf2, 0xab01, 15),
	|            new Range16 (0xab02, 0xab06, 1),
	|            new Range16 (0xab09, 0xab0e, 1),
	|            new Range16 (0xab11, 0xab16, 1),
	|            new Range16 (0xab20, 0xab26, 1),
	|            new Range16 (0xab28, 0xab2e, 1),
	|            new Range16 (0xabc0, 0xabe2, 1),
	|            new Range16 (0xac00, 0xd7a3, 1),
	|            new Range16 (0xd7b0, 0xd7c6, 1),
	|            new Range16 (0xd7cb, 0xd7fb, 1),
	|            new Range16 (0xf900, 0xfa6d, 1),
	|            new Range16 (0xfa70, 0xfad9, 1),
	|            new Range16 (0xfb1d, 0xfb1f, 2),
	|            new Range16 (0xfb20, 0xfb28, 1),
	|            new Range16 (0xfb2a, 0xfb36, 1),
	|            new Range16 (0xfb38, 0xfb3c, 1),
	|            new Range16 (0xfb3e, 0xfb40, 2),
	|            new Range16 (0xfb41, 0xfb43, 2),
	|            new Range16 (0xfb44, 0xfb46, 2),
	|            new Range16 (0xfb47, 0xfbb1, 1),
	|            new Range16 (0xfbd3, 0xfd3d, 1),
	|            new Range16 (0xfd50, 0xfd8f, 1),
	|            new Range16 (0xfd92, 0xfdc7, 1),
	|            new Range16 (0xfdf0, 0xfdfb, 1),
	|            new Range16 (0xfe70, 0xfe74, 1),
	|            new Range16 (0xfe76, 0xfefc, 1),
	|            new Range16 (0xff66, 0xff6f, 1),
	|            new Range16 (0xff71, 0xff9d, 1),
	|            new Range16 (0xffa0, 0xffbe, 1),
	|            new Range16 (0xffc2, 0xffc7, 1),
	|            new Range16 (0xffca, 0xffcf, 1),
	|            new Range16 (0xffd2, 0xffd7, 1),
	|            new Range16 (0xffda, 0xffdc, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10000, 0x1000b, 1),
	|            new Range32 (0x1000d, 0x10026, 1),
	|            new Range32 (0x10028, 0x1003a, 1),
	|            new Range32 (0x1003c, 0x1003d, 1),
	|            new Range32 (0x1003f, 0x1004d, 1),
	|            new Range32 (0x10050, 0x1005d, 1),
	|            new Range32 (0x10080, 0x100fa, 1),
	|            new Range32 (0x10280, 0x1029c, 1),
	|            new Range32 (0x102a0, 0x102d0, 1),
	|            new Range32 (0x10300, 0x1031f, 1),
	|            new Range32 (0x1032d, 0x10340, 1),
	|            new Range32 (0x10342, 0x10349, 1),
	|            new Range32 (0x10350, 0x10375, 1),
	|            new Range32 (0x10380, 0x1039d, 1),
	|            new Range32 (0x103a0, 0x103c3, 1),
	|            new Range32 (0x103c8, 0x103cf, 1),
	|            new Range32 (0x10450, 0x1049d, 1),
	|            new Range32 (0x10500, 0x10527, 1),
	|            new Range32 (0x10530, 0x10563, 1),
	|            new Range32 (0x10600, 0x10736, 1),
	|            new Range32 (0x10740, 0x10755, 1),
	|            new Range32 (0x10760, 0x10767, 1),
	|            new Range32 (0x10800, 0x10805, 1),
	|            new Range32 (0x10808, 0x1080a, 2),
	|            new Range32 (0x1080b, 0x10835, 1),
	|            new Range32 (0x10837, 0x10838, 1),
	|            new Range32 (0x1083c, 0x1083f, 3),
	|            new Range32 (0x10840, 0x10855, 1),
	|            new Range32 (0x10860, 0x10876, 1),
	|            new Range32 (0x10880, 0x1089e, 1),
	|            new Range32 (0x108e0, 0x108f2, 1),
	|            new Range32 (0x108f4, 0x108f5, 1),
	|            new Range32 (0x10900, 0x10915, 1),
	|            new Range32 (0x10920, 0x10939, 1),
	|            new Range32 (0x10980, 0x109b7, 1),
	|            new Range32 (0x109be, 0x109bf, 1),
	|            new Range32 (0x10a00, 0x10a10, 16),
	|            new Range32 (0x10a11, 0x10a13, 1),
	|            new Range32 (0x10a15, 0x10a17, 1),
	|            new Range32 (0x10a19, 0x10a35, 1),
	|            new Range32 (0x10a60, 0x10a7c, 1),
	|            new Range32 (0x10a80, 0x10a9c, 1),
	|            new Range32 (0x10ac0, 0x10ac7, 1),
	|            new Range32 (0x10ac9, 0x10ae4, 1),
	|            new Range32 (0x10b00, 0x10b35, 1),
	|            new Range32 (0x10b40, 0x10b55, 1),
	|            new Range32 (0x10b60, 0x10b72, 1),
	|            new Range32 (0x10b80, 0x10b91, 1),
	|            new Range32 (0x10c00, 0x10c48, 1),
	|            new Range32 (0x10d00, 0x10d23, 1),
	|            new Range32 (0x10e80, 0x10ea9, 1),
	|            new Range32 (0x10eb0, 0x10eb1, 1),
	|            new Range32 (0x10f00, 0x10f1c, 1),
	|            new Range32 (0x10f27, 0x10f30, 9),
	|            new Range32 (0x10f31, 0x10f45, 1),
	|            new Range32 (0x10f70, 0x10f81, 1),
	|            new Range32 (0x10fb0, 0x10fc4, 1),
	|            new Range32 (0x10fe0, 0x10ff6, 1),
	|            new Range32 (0x11003, 0x11037, 1),
	|            new Range32 (0x11071, 0x11072, 1),
	|            new Range32 (0x11075, 0x11083, 14),
	|            new Range32 (0x11084, 0x110af, 1),
	|            new Range32 (0x110d0, 0x110e8, 1),
	|            new Range32 (0x11103, 0x11126, 1),
	|            new Range32 (0x11144, 0x11147, 3),
	|            new Range32 (0x11150, 0x11172, 1),
	|            new Range32 (0x11176, 0x11183, 13),
	|            new Range32 (0x11184, 0x111b2, 1),
	|            new Range32 (0x111c1, 0x111c4, 1),
	|            new Range32 (0x111da, 0x111dc, 2),
	|            new Range32 (0x11200, 0x11211, 1),
	|            new Range32 (0x11213, 0x1122b, 1),
	|            new Range32 (0x1123f, 0x11240, 1),
	|            new Range32 (0x11280, 0x11286, 1),
	|            new Range32 (0x11288, 0x1128a, 2),
	|            new Range32 (0x1128b, 0x1128d, 1),
	|            new Range32 (0x1128f, 0x1129d, 1),
	|            new Range32 (0x1129f, 0x112a8, 1),
	|            new Range32 (0x112b0, 0x112de, 1),
	|            new Range32 (0x11305, 0x1130c, 1),
	|            new Range32 (0x1130f, 0x11310, 1),
	|            new Range32 (0x11313, 0x11328, 1),
	|            new Range32 (0x1132a, 0x11330, 1),
	|            new Range32 (0x11332, 0x11333, 1),
	|            new Range32 (0x11335, 0x11339, 1),
	|            new Range32 (0x1133d, 0x11350, 19),
	|            new Range32 (0x1135d, 0x11361, 1),
	|            new Range32 (0x11400, 0x11434, 1),
	|            new Range32 (0x11447, 0x1144a, 1),
	|            new Range32 (0x1145f, 0x11461, 1),
	|            new Range32 (0x11480, 0x114af, 1),
	|            new Range32 (0x114c4, 0x114c5, 1),
	|            new Range32 (0x114c7, 0x11580, 185),
	|            new Range32 (0x11581, 0x115ae, 1),
	|            new Range32 (0x115d8, 0x115db, 1),
	|            new Range32 (0x11600, 0x1162f, 1),
	|            new Range32 (0x11644, 0x11680, 60),
	|            new Range32 (0x11681, 0x116aa, 1),
	|            new Range32 (0x116b8, 0x11700, 72),
	|            new Range32 (0x11701, 0x1171a, 1),
	|            new Range32 (0x11740, 0x11746, 1),
	|            new Range32 (0x11800, 0x1182b, 1),
	|            new Range32 (0x118ff, 0x11906, 1),
	|            new Range32 (0x11909, 0x1190c, 3),
	|            new Range32 (0x1190d, 0x11913, 1),
	|            new Range32 (0x11915, 0x11916, 1),
	|            new Range32 (0x11918, 0x1192f, 1),
	|            new Range32 (0x1193f, 0x11941, 2),
	|            new Range32 (0x119a0, 0x119a7, 1),
	|            new Range32 (0x119aa, 0x119d0, 1),
	|            new Range32 (0x119e1, 0x119e3, 2),
	|            new Range32 (0x11a00, 0x11a0b, 11),
	|            new Range32 (0x11a0c, 0x11a32, 1),
	|            new Range32 (0x11a3a, 0x11a50, 22),
	|            new Range32 (0x11a5c, 0x11a89, 1),
	|            new Range32 (0x11a9d, 0x11ab0, 19),
	|            new Range32 (0x11ab1, 0x11af8, 1),
	|            new Range32 (0x11c00, 0x11c08, 1),
	|            new Range32 (0x11c0a, 0x11c2e, 1),
	|            new Range32 (0x11c40, 0x11c72, 50),
	|            new Range32 (0x11c73, 0x11c8f, 1),
	|            new Range32 (0x11d00, 0x11d06, 1),
	|            new Range32 (0x11d08, 0x11d09, 1),
	|            new Range32 (0x11d0b, 0x11d30, 1),
	|            new Range32 (0x11d46, 0x11d60, 26),
	|            new Range32 (0x11d61, 0x11d65, 1),
	|            new Range32 (0x11d67, 0x11d68, 1),
	|            new Range32 (0x11d6a, 0x11d89, 1),
	|            new Range32 (0x11d98, 0x11ee0, 328),
	|            new Range32 (0x11ee1, 0x11ef2, 1),
	|            new Range32 (0x11f02, 0x11f04, 2),
	|            new Range32 (0x11f05, 0x11f10, 1),
	|            new Range32 (0x11f12, 0x11f33, 1),
	|            new Range32 (0x11fb0, 0x12000, 80),
	|            new Range32 (0x12001, 0x12399, 1),
	|            new Range32 (0x12480, 0x12543, 1),
	|            new Range32 (0x12f90, 0x12ff0, 1),
	|            new Range32 (0x13000, 0x1342f, 1),
	|            new Range32 (0x13441, 0x13446, 1),
	|            new Range32 (0x14400, 0x14646, 1),
	|            new Range32 (0x16800, 0x16a38, 1),
	|            new Range32 (0x16a40, 0x16a5e, 1),
	|            new Range32 (0x16a70, 0x16abe, 1),
	|            new Range32 (0x16ad0, 0x16aed, 1),
	|            new Range32 (0x16b00, 0x16b2f, 1),
	|            new Range32 (0x16b63, 0x16b77, 1),
	|            new Range32 (0x16b7d, 0x16b8f, 1),
	|            new Range32 (0x16f00, 0x16f4a, 1),
	|            new Range32 (0x16f50, 0x17000, 176),
	|            new Range32 (0x17001, 0x187f7, 1),
	|            new Range32 (0x18800, 0x18cd5, 1),
	|            new Range32 (0x18d00, 0x18d08, 1),
	|            new Range32 (0x1b000, 0x1b122, 1),
	|            new Range32 (0x1b132, 0x1b150, 30),
	|            new Range32 (0x1b151, 0x1b152, 1),
	|            new Range32 (0x1b155, 0x1b164, 15),
	|            new Range32 (0x1b165, 0x1b167, 1),
	|            new Range32 (0x1b170, 0x1b2fb, 1),
	|            new Range32 (0x1bc00, 0x1bc6a, 1),
	|            new Range32 (0x1bc70, 0x1bc7c, 1),
	|            new Range32 (0x1bc80, 0x1bc88, 1),
	|            new Range32 (0x1bc90, 0x1bc99, 1),
	|            new Range32 (0x1df0a, 0x1e100, 502),
	|            new Range32 (0x1e101, 0x1e12c, 1),
	|            new Range32 (0x1e14e, 0x1e290, 322),
	|            new Range32 (0x1e291, 0x1e2ad, 1),
	|            new Range32 (0x1e2c0, 0x1e2eb, 1),
	|            new Range32 (0x1e4d0, 0x1e4ea, 1),
	|            new Range32 (0x1e7e0, 0x1e7e6, 1),
	|            new Range32 (0x1e7e8, 0x1e7eb, 1),
	|            new Range32 (0x1e7ed, 0x1e7ee, 1),
	|            new Range32 (0x1e7f0, 0x1e7fe, 1),
	|            new Range32 (0x1e800, 0x1e8c4, 1),
	|            new Range32 (0x1ee00, 0x1ee03, 1),
	|            new Range32 (0x1ee05, 0x1ee1f, 1),
	|            new Range32 (0x1ee21, 0x1ee22, 1),
	|            new Range32 (0x1ee24, 0x1ee27, 3),
	|            new Range32 (0x1ee29, 0x1ee32, 1),
	|            new Range32 (0x1ee34, 0x1ee37, 1),
	|            new Range32 (0x1ee39, 0x1ee3b, 2),
	|            new Range32 (0x1ee42, 0x1ee47, 5),
	|            new Range32 (0x1ee49, 0x1ee4d, 2),
	|            new Range32 (0x1ee4e, 0x1ee4f, 1),
	|            new Range32 (0x1ee51, 0x1ee52, 1),
	|            new Range32 (0x1ee54, 0x1ee57, 3),
	|            new Range32 (0x1ee59, 0x1ee61, 2),
	|            new Range32 (0x1ee62, 0x1ee64, 2),
	|            new Range32 (0x1ee67, 0x1ee6a, 1),
	|            new Range32 (0x1ee6c, 0x1ee72, 1),
	|            new Range32 (0x1ee74, 0x1ee77, 1),
	|            new Range32 (0x1ee79, 0x1ee7c, 1),
	|            new Range32 (0x1ee7e, 0x1ee80, 2),
	|            new Range32 (0x1ee81, 0x1ee89, 1),
	|            new Range32 (0x1ee8b, 0x1ee9b, 1),
	|            new Range32 (0x1eea1, 0x1eea3, 1),
	|            new Range32 (0x1eea5, 0x1eea9, 1),
	|            new Range32 (0x1eeab, 0x1eebb, 1),
	|            new Range32 (0x20000, 0x2a6df, 1),
	|            new Range32 (0x2a700, 0x2b739, 1),
	|            new Range32 (0x2b740, 0x2b81d, 1),
	|            new Range32 (0x2b820, 0x2cea1, 1),
	|            new Range32 (0x2ceb0, 0x2ebe0, 1),
	|            new Range32 (0x2f800, 0x2fa1d, 1),
	|            new Range32 (0x30000, 0x3134a, 1),
	|            new Range32 (0x31350, 0x323af, 1),
	|                },
	|                latinOffset: 1
	|            );
	|
	|            internal static RangeTable _Lt = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x01c5, 0x01cb, 3),
	|            new Range16 (0x01f2, 0x1f88, 7574),
	|            new Range16 (0x1f89, 0x1f8f, 1),
	|            new Range16 (0x1f98, 0x1f9f, 1),
	|            new Range16 (0x1fa8, 0x1faf, 1),
	|            new Range16 (0x1fbc, 0x1fcc, 16),
	|            new Range16 (0x1ffc, 0x1ffc, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Lu = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0041, 0x005a, 1),
	|            new Range16 (0x00c0, 0x00d6, 1),
	|            new Range16 (0x00d8, 0x00de, 1),
	|            new Range16 (0x0100, 0x0136, 2),
	|            new Range16 (0x0139, 0x0147, 2),
	|            new Range16 (0x014a, 0x0178, 2),
	|            new Range16 (0x0179, 0x017d, 2),
	|            new Range16 (0x0181, 0x0182, 1),
	|            new Range16 (0x0184, 0x0186, 2),
	|            new Range16 (0x0187, 0x0189, 2),
	|            new Range16 (0x018a, 0x018b, 1),
	|            new Range16 (0x018e, 0x0191, 1),
	|            new Range16 (0x0193, 0x0194, 1),
	|            new Range16 (0x0196, 0x0198, 1),
	|            new Range16 (0x019c, 0x019d, 1),
	|            new Range16 (0x019f, 0x01a0, 1),
	|            new Range16 (0x01a2, 0x01a6, 2),
	|            new Range16 (0x01a7, 0x01a9, 2),
	|            new Range16 (0x01ac, 0x01ae, 2),
	|            new Range16 (0x01af, 0x01b1, 2),
	|            new Range16 (0x01b2, 0x01b3, 1),
	|            new Range16 (0x01b5, 0x01b7, 2),
	|            new Range16 (0x01b8, 0x01bc, 4),
	|            new Range16 (0x01c4, 0x01cd, 3),
	|            new Range16 (0x01cf, 0x01db, 2),
	|            new Range16 (0x01de, 0x01ee, 2),
	|            new Range16 (0x01f1, 0x01f4, 3),
	|            new Range16 (0x01f6, 0x01f8, 1),
	|            new Range16 (0x01fa, 0x0232, 2),
	|            new Range16 (0x023a, 0x023b, 1),
	|            new Range16 (0x023d, 0x023e, 1),
	|            new Range16 (0x0241, 0x0243, 2),
	|            new Range16 (0x0244, 0x0246, 1),
	|            new Range16 (0x0248, 0x024e, 2),
	|            new Range16 (0x0370, 0x0372, 2),
	|            new Range16 (0x0376, 0x037f, 9),
	|            new Range16 (0x0386, 0x0388, 2),
	|            new Range16 (0x0389, 0x038a, 1),
	|            new Range16 (0x038c, 0x038e, 2),
	|            new Range16 (0x038f, 0x0391, 2),
	|            new Range16 (0x0392, 0x03a1, 1),
	|            new Range16 (0x03a3, 0x03ab, 1),
	|            new Range16 (0x03cf, 0x03d2, 3),
	|            new Range16 (0x03d3, 0x03d4, 1),
	|            new Range16 (0x03d8, 0x03ee, 2),
	|            new Range16 (0x03f4, 0x03f7, 3),
	|            new Range16 (0x03f9, 0x03fa, 1),
	|            new Range16 (0x03fd, 0x042f, 1),
	|            new Range16 (0x0460, 0x0480, 2),
	|            new Range16 (0x048a, 0x04c0, 2),
	|            new Range16 (0x04c1, 0x04cd, 2),
	|            new Range16 (0x04d0, 0x052e, 2),
	|            new Range16 (0x0531, 0x0556, 1),
	|            new Range16 (0x10a0, 0x10c5, 1),
	|            new Range16 (0x10c7, 0x10cd, 6),
	|            new Range16 (0x13a0, 0x13f5, 1),
	|            new Range16 (0x1c90, 0x1cba, 1),
	|            new Range16 (0x1cbd, 0x1cbf, 1),
	|            new Range16 (0x1e00, 0x1e94, 2),
	|            new Range16 (0x1e9e, 0x1efe, 2),
	|            new Range16 (0x1f08, 0x1f0f, 1),
	|            new Range16 (0x1f18, 0x1f1d, 1),
	|            new Range16 (0x1f28, 0x1f2f, 1),
	|            new Range16 (0x1f38, 0x1f3f, 1),
	|            new Range16 (0x1f48, 0x1f4d, 1),
	|            new Range16 (0x1f59, 0x1f5f, 2),
	|            new Range16 (0x1f68, 0x1f6f, 1),
	|            new Range16 (0x1fb8, 0x1fbb, 1),
	|            new Range16 (0x1fc8, 0x1fcb, 1),
	|            new Range16 (0x1fd8, 0x1fdb, 1),
	|            new Range16 (0x1fe8, 0x1fec, 1),
	|            new Range16 (0x1ff8, 0x1ffb, 1),
	|            new Range16 (0x2102, 0x2107, 5),
	|            new Range16 (0x210b, 0x210d, 1),
	|            new Range16 (0x2110, 0x2112, 1),
	|            new Range16 (0x2115, 0x2119, 4),
	|            new Range16 (0x211a, 0x211d, 1),
	|            new Range16 (0x2124, 0x212a, 2),
	|            new Range16 (0x212b, 0x212d, 1),
	|            new Range16 (0x2130, 0x2133, 1),
	|            new Range16 (0x213e, 0x213f, 1),
	|            new Range16 (0x2145, 0x2183, 62),
	|            new Range16 (0x2c00, 0x2c2f, 1),
	|            new Range16 (0x2c60, 0x2c62, 2),
	|            new Range16 (0x2c63, 0x2c64, 1),
	|            new Range16 (0x2c67, 0x2c6d, 2),
	|            new Range16 (0x2c6e, 0x2c70, 1),
	|            new Range16 (0x2c72, 0x2c75, 3),
	|            new Range16 (0x2c7e, 0x2c80, 1),
	|            new Range16 (0x2c82, 0x2ce2, 2),
	|            new Range16 (0x2ceb, 0x2ced, 2),
	|            new Range16 (0x2cf2, 0xa640, 31054),
	|            new Range16 (0xa642, 0xa66c, 2),
	|            new Range16 (0xa680, 0xa69a, 2),
	|            new Range16 (0xa722, 0xa72e, 2),
	|            new Range16 (0xa732, 0xa76e, 2),
	|            new Range16 (0xa779, 0xa77d, 2),
	|            new Range16 (0xa77e, 0xa786, 2),
	|            new Range16 (0xa78b, 0xa78d, 2),
	|            new Range16 (0xa790, 0xa792, 2),
	|            new Range16 (0xa796, 0xa7aa, 2),
	|            new Range16 (0xa7ab, 0xa7ae, 1),
	|            new Range16 (0xa7b0, 0xa7b4, 1),
	|            new Range16 (0xa7b6, 0xa7c4, 2),
	|            new Range16 (0xa7c5, 0xa7c7, 1),
	|            new Range16 (0xa7c9, 0xa7d0, 7),
	|            new Range16 (0xa7d6, 0xa7d8, 2),
	|            new Range16 (0xa7f5, 0xff21, 22316),
	|            new Range16 (0xff22, 0xff3a, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10400, 0x10427, 1),
	|            new Range32 (0x104b0, 0x104d3, 1),
	|            new Range32 (0x10570, 0x1057a, 1),
	|            new Range32 (0x1057c, 0x1058a, 1),
	|            new Range32 (0x1058c, 0x10592, 1),
	|            new Range32 (0x10594, 0x10595, 1),
	|            new Range32 (0x10c80, 0x10cb2, 1),
	|            new Range32 (0x118a0, 0x118bf, 1),
	|            new Range32 (0x16e40, 0x16e5f, 1),
	|            new Range32 (0x1d400, 0x1d419, 1),
	|            new Range32 (0x1d434, 0x1d44d, 1),
	|            new Range32 (0x1d468, 0x1d481, 1),
	|            new Range32 (0x1d49c, 0x1d49e, 2),
	|            new Range32 (0x1d49f, 0x1d4a5, 3),
	|            new Range32 (0x1d4a6, 0x1d4a9, 3),
	|            new Range32 (0x1d4aa, 0x1d4ac, 1),
	|            new Range32 (0x1d4ae, 0x1d4b5, 1),
	|            new Range32 (0x1d4d0, 0x1d4e9, 1),
	|            new Range32 (0x1d504, 0x1d505, 1),
	|            new Range32 (0x1d507, 0x1d50a, 1),
	|            new Range32 (0x1d50d, 0x1d514, 1),
	|            new Range32 (0x1d516, 0x1d51c, 1),
	|            new Range32 (0x1d538, 0x1d539, 1),
	|            new Range32 (0x1d53b, 0x1d53e, 1),
	|            new Range32 (0x1d540, 0x1d544, 1),
	|            new Range32 (0x1d546, 0x1d54a, 4),
	|            new Range32 (0x1d54b, 0x1d550, 1),
	|            new Range32 (0x1d56c, 0x1d585, 1),
	|            new Range32 (0x1d5a0, 0x1d5b9, 1),
	|            new Range32 (0x1d5d4, 0x1d5ed, 1),
	|            new Range32 (0x1d608, 0x1d621, 1),
	|            new Range32 (0x1d63c, 0x1d655, 1),
	|            new Range32 (0x1d670, 0x1d689, 1),
	|            new Range32 (0x1d6a8, 0x1d6c0, 1),
	|            new Range32 (0x1d6e2, 0x1d6fa, 1),
	|            new Range32 (0x1d71c, 0x1d734, 1),
	|            new Range32 (0x1d756, 0x1d76e, 1),
	|            new Range32 (0x1d790, 0x1d7a8, 1),
	|            new Range32 (0x1d7ca, 0x1e900, 4406),
	|            new Range32 (0x1e901, 0x1e921, 1),
	|                },
	|                latinOffset: 3
	|            );
	|
	|            internal static RangeTable _M = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0300, 0x036f, 1),
	|            new Range16 (0x0483, 0x0489, 1),
	|            new Range16 (0x0591, 0x05bd, 1),
	|            new Range16 (0x05bf, 0x05c1, 2),
	|            new Range16 (0x05c2, 0x05c4, 2),
	|            new Range16 (0x05c5, 0x05c7, 2),
	|            new Range16 (0x0610, 0x061a, 1),
	|            new Range16 (0x064b, 0x065f, 1),
	|            new Range16 (0x0670, 0x06d6, 102),
	|            new Range16 (0x06d7, 0x06dc, 1),
	|            new Range16 (0x06df, 0x06e4, 1),
	|            new Range16 (0x06e7, 0x06e8, 1),
	|            new Range16 (0x06ea, 0x06ed, 1),
	|            new Range16 (0x0711, 0x0730, 31),
	|            new Range16 (0x0731, 0x074a, 1),
	|            new Range16 (0x07a6, 0x07b0, 1),
	|            new Range16 (0x07eb, 0x07f3, 1),
	|            new Range16 (0x07fd, 0x0816, 25),
	|            new Range16 (0x0817, 0x0819, 1),
	|            new Range16 (0x081b, 0x0823, 1),
	|            new Range16 (0x0825, 0x0827, 1),
	|            new Range16 (0x0829, 0x082d, 1),
	|            new Range16 (0x0859, 0x085b, 1),
	|            new Range16 (0x0898, 0x089f, 1),
	|            new Range16 (0x08ca, 0x08e1, 1),
	|            new Range16 (0x08e3, 0x0903, 1),
	|            new Range16 (0x093a, 0x093c, 1),
	|            new Range16 (0x093e, 0x094f, 1),
	|            new Range16 (0x0951, 0x0957, 1),
	|            new Range16 (0x0962, 0x0963, 1),
	|            new Range16 (0x0981, 0x0983, 1),
	|            new Range16 (0x09bc, 0x09be, 2),
	|            new Range16 (0x09bf, 0x09c4, 1),
	|            new Range16 (0x09c7, 0x09c8, 1),
	|            new Range16 (0x09cb, 0x09cd, 1),
	|            new Range16 (0x09d7, 0x09e2, 11),
	|            new Range16 (0x09e3, 0x09fe, 27),
	|            new Range16 (0x0a01, 0x0a03, 1),
	|            new Range16 (0x0a3c, 0x0a3e, 2),
	|            new Range16 (0x0a3f, 0x0a42, 1),
	|            new Range16 (0x0a47, 0x0a48, 1),
	|            new Range16 (0x0a4b, 0x0a4d, 1),
	|            new Range16 (0x0a51, 0x0a70, 31),
	|            new Range16 (0x0a71, 0x0a75, 4),
	|            new Range16 (0x0a81, 0x0a83, 1),
	|            new Range16 (0x0abc, 0x0abe, 2),
	|            new Range16 (0x0abf, 0x0ac5, 1),
	|            new Range16 (0x0ac7, 0x0ac9, 1),
	|            new Range16 (0x0acb, 0x0acd, 1),
	|            new Range16 (0x0ae2, 0x0ae3, 1),
	|            new Range16 (0x0afa, 0x0aff, 1),
	|            new Range16 (0x0b01, 0x0b03, 1),
	|            new Range16 (0x0b3c, 0x0b3e, 2),
	|            new Range16 (0x0b3f, 0x0b44, 1),
	|            new Range16 (0x0b47, 0x0b48, 1),
	|            new Range16 (0x0b4b, 0x0b4d, 1),
	|            new Range16 (0x0b55, 0x0b57, 1),
	|            new Range16 (0x0b62, 0x0b63, 1),
	|            new Range16 (0x0b82, 0x0bbe, 60),
	|            new Range16 (0x0bbf, 0x0bc2, 1),
	|            new Range16 (0x0bc6, 0x0bc8, 1),
	|            new Range16 (0x0bca, 0x0bcd, 1),
	|            new Range16 (0x0bd7, 0x0c00, 41),
	|            new Range16 (0x0c01, 0x0c04, 1),
	|            new Range16 (0x0c3c, 0x0c3e, 2),
	|            new Range16 (0x0c3f, 0x0c44, 1),
	|            new Range16 (0x0c46, 0x0c48, 1),
	|            new Range16 (0x0c4a, 0x0c4d, 1),
	|            new Range16 (0x0c55, 0x0c56, 1),
	|            new Range16 (0x0c62, 0x0c63, 1),
	|            new Range16 (0x0c81, 0x0c83, 1),
	|            new Range16 (0x0cbc, 0x0cbe, 2),
	|            new Range16 (0x0cbf, 0x0cc4, 1),
	|            new Range16 (0x0cc6, 0x0cc8, 1),
	|            new Range16 (0x0cca, 0x0ccd, 1),
	|            new Range16 (0x0cd5, 0x0cd6, 1),
	|            new Range16 (0x0ce2, 0x0ce3, 1),
	|            new Range16 (0x0cf3, 0x0d00, 13),
	|            new Range16 (0x0d01, 0x0d03, 1),
	|            new Range16 (0x0d3b, 0x0d3c, 1),
	|            new Range16 (0x0d3e, 0x0d44, 1),
	|            new Range16 (0x0d46, 0x0d48, 1),
	|            new Range16 (0x0d4a, 0x0d4d, 1),
	|            new Range16 (0x0d57, 0x0d62, 11),
	|            new Range16 (0x0d63, 0x0d81, 30),
	|            new Range16 (0x0d82, 0x0d83, 1),
	|            new Range16 (0x0dca, 0x0dcf, 5),
	|            new Range16 (0x0dd0, 0x0dd4, 1),
	|            new Range16 (0x0dd6, 0x0dd8, 2),
	|            new Range16 (0x0dd9, 0x0ddf, 1),
	|            new Range16 (0x0df2, 0x0df3, 1),
	|            new Range16 (0x0e31, 0x0e34, 3),
	|            new Range16 (0x0e35, 0x0e3a, 1),
	|            new Range16 (0x0e47, 0x0e4e, 1),
	|            new Range16 (0x0eb1, 0x0eb4, 3),
	|            new Range16 (0x0eb5, 0x0ebc, 1),
	|            new Range16 (0x0ec8, 0x0ece, 1),
	|            new Range16 (0x0f18, 0x0f19, 1),
	|            new Range16 (0x0f35, 0x0f39, 2),
	|            new Range16 (0x0f3e, 0x0f3f, 1),
	|            new Range16 (0x0f71, 0x0f84, 1),
	|            new Range16 (0x0f86, 0x0f87, 1),
	|            new Range16 (0x0f8d, 0x0f97, 1),
	|            new Range16 (0x0f99, 0x0fbc, 1),
	|            new Range16 (0x0fc6, 0x102b, 101),
	|            new Range16 (0x102c, 0x103e, 1),
	|            new Range16 (0x1056, 0x1059, 1),
	|            new Range16 (0x105e, 0x1060, 1),
	|            new Range16 (0x1062, 0x1064, 1),
	|            new Range16 (0x1067, 0x106d, 1),
	|            new Range16 (0x1071, 0x1074, 1),
	|            new Range16 (0x1082, 0x108d, 1),
	|            new Range16 (0x108f, 0x109a, 11),
	|            new Range16 (0x109b, 0x109d, 1),
	|            new Range16 (0x135d, 0x135f, 1),
	|            new Range16 (0x1712, 0x1715, 1),
	|            new Range16 (0x1732, 0x1734, 1),
	|            new Range16 (0x1752, 0x1753, 1),
	|            new Range16 (0x1772, 0x1773, 1),
	|            new Range16 (0x17b4, 0x17d3, 1),
	|            new Range16 (0x17dd, 0x180b, 46),
	|            new Range16 (0x180c, 0x180d, 1),
	|            new Range16 (0x180f, 0x1885, 118),
	|            new Range16 (0x1886, 0x18a9, 35),
	|            new Range16 (0x1920, 0x192b, 1),
	|            new Range16 (0x1930, 0x193b, 1),
	|            new Range16 (0x1a17, 0x1a1b, 1),
	|            new Range16 (0x1a55, 0x1a5e, 1),
	|            new Range16 (0x1a60, 0x1a7c, 1),
	|            new Range16 (0x1a7f, 0x1ab0, 49),
	|            new Range16 (0x1ab1, 0x1ace, 1),
	|            new Range16 (0x1b00, 0x1b04, 1),
	|            new Range16 (0x1b34, 0x1b44, 1),
	|            new Range16 (0x1b6b, 0x1b73, 1),
	|            new Range16 (0x1b80, 0x1b82, 1),
	|            new Range16 (0x1ba1, 0x1bad, 1),
	|            new Range16 (0x1be6, 0x1bf3, 1),
	|            new Range16 (0x1c24, 0x1c37, 1),
	|            new Range16 (0x1cd0, 0x1cd2, 1),
	|            new Range16 (0x1cd4, 0x1ce8, 1),
	|            new Range16 (0x1ced, 0x1cf4, 7),
	|            new Range16 (0x1cf7, 0x1cf9, 1),
	|            new Range16 (0x1dc0, 0x1dff, 1),
	|            new Range16 (0x20d0, 0x20f0, 1),
	|            new Range16 (0x2cef, 0x2cf1, 1),
	|            new Range16 (0x2d7f, 0x2de0, 97),
	|            new Range16 (0x2de1, 0x2dff, 1),
	|            new Range16 (0x302a, 0x302f, 1),
	|            new Range16 (0x3099, 0x309a, 1),
	|            new Range16 (0xa66f, 0xa672, 1),
	|            new Range16 (0xa674, 0xa67d, 1),
	|            new Range16 (0xa69e, 0xa69f, 1),
	|            new Range16 (0xa6f0, 0xa6f1, 1),
	|            new Range16 (0xa802, 0xa806, 4),
	|            new Range16 (0xa80b, 0xa823, 24),
	|            new Range16 (0xa824, 0xa827, 1),
	|            new Range16 (0xa82c, 0xa880, 84),
	|            new Range16 (0xa881, 0xa8b4, 51),
	|            new Range16 (0xa8b5, 0xa8c5, 1),
	|            new Range16 (0xa8e0, 0xa8f1, 1),
	|            new Range16 (0xa8ff, 0xa926, 39),
	|            new Range16 (0xa927, 0xa92d, 1),
	|            new Range16 (0xa947, 0xa953, 1),
	|            new Range16 (0xa980, 0xa983, 1),
	|            new Range16 (0xa9b3, 0xa9c0, 1),
	|            new Range16 (0xa9e5, 0xaa29, 68),
	|            new Range16 (0xaa2a, 0xaa36, 1),
	|            new Range16 (0xaa43, 0xaa4c, 9),
	|            new Range16 (0xaa4d, 0xaa7b, 46),
	|            new Range16 (0xaa7c, 0xaa7d, 1),
	|            new Range16 (0xaab0, 0xaab2, 2),
	|            new Range16 (0xaab3, 0xaab4, 1),
	|            new Range16 (0xaab7, 0xaab8, 1),
	|            new Range16 (0xaabe, 0xaabf, 1),
	|            new Range16 (0xaac1, 0xaaeb, 42),
	|            new Range16 (0xaaec, 0xaaef, 1),
	|            new Range16 (0xaaf5, 0xaaf6, 1),
	|            new Range16 (0xabe3, 0xabea, 1),
	|            new Range16 (0xabec, 0xabed, 1),
	|            new Range16 (0xfb1e, 0xfe00, 738),
	|            new Range16 (0xfe01, 0xfe0f, 1),
	|            new Range16 (0xfe20, 0xfe2f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x101fd, 0x102e0, 227),
	|            new Range32 (0x10376, 0x1037a, 1),
	|            new Range32 (0x10a01, 0x10a03, 1),
	|            new Range32 (0x10a05, 0x10a06, 1),
	|            new Range32 (0x10a0c, 0x10a0f, 1),
	|            new Range32 (0x10a38, 0x10a3a, 1),
	|            new Range32 (0x10a3f, 0x10ae5, 166),
	|            new Range32 (0x10ae6, 0x10d24, 574),
	|            new Range32 (0x10d25, 0x10d27, 1),
	|            new Range32 (0x10eab, 0x10eac, 1),
	|            new Range32 (0x10efd, 0x10eff, 1),
	|            new Range32 (0x10f46, 0x10f50, 1),
	|            new Range32 (0x10f82, 0x10f85, 1),
	|            new Range32 (0x11000, 0x11002, 1),
	|            new Range32 (0x11038, 0x11046, 1),
	|            new Range32 (0x11070, 0x11073, 3),
	|            new Range32 (0x11074, 0x1107f, 11),
	|            new Range32 (0x11080, 0x11082, 1),
	|            new Range32 (0x110b0, 0x110ba, 1),
	|            new Range32 (0x110c2, 0x11100, 62),
	|            new Range32 (0x11101, 0x11102, 1),
	|            new Range32 (0x11127, 0x11134, 1),
	|            new Range32 (0x11145, 0x11146, 1),
	|            new Range32 (0x11173, 0x11180, 13),
	|            new Range32 (0x11181, 0x11182, 1),
	|            new Range32 (0x111b3, 0x111c0, 1),
	|            new Range32 (0x111c9, 0x111cc, 1),
	|            new Range32 (0x111ce, 0x111cf, 1),
	|            new Range32 (0x1122c, 0x11237, 1),
	|            new Range32 (0x1123e, 0x11241, 3),
	|            new Range32 (0x112df, 0x112ea, 1),
	|            new Range32 (0x11300, 0x11303, 1),
	|            new Range32 (0x1133b, 0x1133c, 1),
	|            new Range32 (0x1133e, 0x11344, 1),
	|            new Range32 (0x11347, 0x11348, 1),
	|            new Range32 (0x1134b, 0x1134d, 1),
	|            new Range32 (0x11357, 0x11362, 11),
	|            new Range32 (0x11363, 0x11366, 3),
	|            new Range32 (0x11367, 0x1136c, 1),
	|            new Range32 (0x11370, 0x11374, 1),
	|            new Range32 (0x11435, 0x11446, 1),
	|            new Range32 (0x1145e, 0x114b0, 82),
	|            new Range32 (0x114b1, 0x114c3, 1),
	|            new Range32 (0x115af, 0x115b5, 1),
	|            new Range32 (0x115b8, 0x115c0, 1),
	|            new Range32 (0x115dc, 0x115dd, 1),
	|            new Range32 (0x11630, 0x11640, 1),
	|            new Range32 (0x116ab, 0x116b7, 1),
	|            new Range32 (0x1171d, 0x1172b, 1),
	|            new Range32 (0x1182c, 0x1183a, 1),
	|            new Range32 (0x11930, 0x11935, 1),
	|            new Range32 (0x11937, 0x11938, 1),
	|            new Range32 (0x1193b, 0x1193e, 1),
	|            new Range32 (0x11940, 0x11942, 2),
	|            new Range32 (0x11943, 0x119d1, 142),
	|            new Range32 (0x119d2, 0x119d7, 1),
	|            new Range32 (0x119da, 0x119e0, 1),
	|            new Range32 (0x119e4, 0x11a01, 29),
	|            new Range32 (0x11a02, 0x11a0a, 1),
	|            new Range32 (0x11a33, 0x11a39, 1),
	|            new Range32 (0x11a3b, 0x11a3e, 1),
	|            new Range32 (0x11a47, 0x11a51, 10),
	|            new Range32 (0x11a52, 0x11a5b, 1),
	|            new Range32 (0x11a8a, 0x11a99, 1),
	|            new Range32 (0x11c2f, 0x11c36, 1),
	|            new Range32 (0x11c38, 0x11c3f, 1),
	|            new Range32 (0x11c92, 0x11ca7, 1),
	|            new Range32 (0x11ca9, 0x11cb6, 1),
	|            new Range32 (0x11d31, 0x11d36, 1),
	|            new Range32 (0x11d3a, 0x11d3c, 2),
	|            new Range32 (0x11d3d, 0x11d3f, 2),
	|            new Range32 (0x11d40, 0x11d45, 1),
	|            new Range32 (0x11d47, 0x11d8a, 67),
	|            new Range32 (0x11d8b, 0x11d8e, 1),
	|            new Range32 (0x11d90, 0x11d91, 1),
	|            new Range32 (0x11d93, 0x11d97, 1),
	|            new Range32 (0x11ef3, 0x11ef6, 1),
	|            new Range32 (0x11f00, 0x11f01, 1),
	|            new Range32 (0x11f03, 0x11f34, 49),
	|            new Range32 (0x11f35, 0x11f3a, 1),
	|            new Range32 (0x11f3e, 0x11f42, 1),
	|            new Range32 (0x13440, 0x13447, 7),
	|            new Range32 (0x13448, 0x13455, 1),
	|            new Range32 (0x16af0, 0x16af4, 1),
	|            new Range32 (0x16b30, 0x16b36, 1),
	|            new Range32 (0x16f4f, 0x16f51, 2),
	|            new Range32 (0x16f52, 0x16f87, 1),
	|            new Range32 (0x16f8f, 0x16f92, 1),
	|            new Range32 (0x16fe4, 0x16ff0, 12),
	|            new Range32 (0x16ff1, 0x1bc9d, 19628),
	|            new Range32 (0x1bc9e, 0x1cf00, 4706),
	|            new Range32 (0x1cf01, 0x1cf2d, 1),
	|            new Range32 (0x1cf30, 0x1cf46, 1),
	|            new Range32 (0x1d165, 0x1d169, 1),
	|            new Range32 (0x1d16d, 0x1d172, 1),
	|            new Range32 (0x1d17b, 0x1d182, 1),
	|            new Range32 (0x1d185, 0x1d18b, 1),
	|            new Range32 (0x1d1aa, 0x1d1ad, 1),
	|            new Range32 (0x1d242, 0x1d244, 1),
	|            new Range32 (0x1da00, 0x1da36, 1),
	|            new Range32 (0x1da3b, 0x1da6c, 1),
	|            new Range32 (0x1da75, 0x1da84, 15),
	|            new Range32 (0x1da9b, 0x1da9f, 1),
	|            new Range32 (0x1daa1, 0x1daaf, 1),
	|            new Range32 (0x1e000, 0x1e006, 1),
	|            new Range32 (0x1e008, 0x1e018, 1),
	|            new Range32 (0x1e01b, 0x1e021, 1),
	|            new Range32 (0x1e023, 0x1e024, 1),
	|            new Range32 (0x1e026, 0x1e02a, 1),
	|            new Range32 (0x1e08f, 0x1e130, 161),
	|            new Range32 (0x1e131, 0x1e136, 1),
	|            new Range32 (0x1e2ae, 0x1e2ec, 62),
	|            new Range32 (0x1e2ed, 0x1e2ef, 1),
	|            new Range32 (0x1e4ec, 0x1e4ef, 1),
	|            new Range32 (0x1e8d0, 0x1e8d6, 1),
	|            new Range32 (0x1e944, 0x1e94a, 1),
	|            new Range32 (0xe0100, 0xe01ef, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Mc = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0903, 0x093b, 56),
	|            new Range16 (0x093e, 0x0940, 1),
	|            new Range16 (0x0949, 0x094c, 1),
	|            new Range16 (0x094e, 0x094f, 1),
	|            new Range16 (0x0982, 0x0983, 1),
	|            new Range16 (0x09be, 0x09c0, 1),
	|            new Range16 (0x09c7, 0x09c8, 1),
	|            new Range16 (0x09cb, 0x09cc, 1),
	|            new Range16 (0x09d7, 0x0a03, 44),
	|            new Range16 (0x0a3e, 0x0a40, 1),
	|            new Range16 (0x0a83, 0x0abe, 59),
	|            new Range16 (0x0abf, 0x0ac0, 1),
	|            new Range16 (0x0ac9, 0x0acb, 2),
	|            new Range16 (0x0acc, 0x0b02, 54),
	|            new Range16 (0x0b03, 0x0b3e, 59),
	|            new Range16 (0x0b40, 0x0b47, 7),
	|            new Range16 (0x0b48, 0x0b4b, 3),
	|            new Range16 (0x0b4c, 0x0b57, 11),
	|            new Range16 (0x0bbe, 0x0bbf, 1),
	|            new Range16 (0x0bc1, 0x0bc2, 1),
	|            new Range16 (0x0bc6, 0x0bc8, 1),
	|            new Range16 (0x0bca, 0x0bcc, 1),
	|            new Range16 (0x0bd7, 0x0c01, 42),
	|            new Range16 (0x0c02, 0x0c03, 1),
	|            new Range16 (0x0c41, 0x0c44, 1),
	|            new Range16 (0x0c82, 0x0c83, 1),
	|            new Range16 (0x0cbe, 0x0cc0, 2),
	|            new Range16 (0x0cc1, 0x0cc4, 1),
	|            new Range16 (0x0cc7, 0x0cc8, 1),
	|            new Range16 (0x0cca, 0x0ccb, 1),
	|            new Range16 (0x0cd5, 0x0cd6, 1),
	|            new Range16 (0x0cf3, 0x0d02, 15),
	|            new Range16 (0x0d03, 0x0d3e, 59),
	|            new Range16 (0x0d3f, 0x0d40, 1),
	|            new Range16 (0x0d46, 0x0d48, 1),
	|            new Range16 (0x0d4a, 0x0d4c, 1),
	|            new Range16 (0x0d57, 0x0d82, 43),
	|            new Range16 (0x0d83, 0x0dcf, 76),
	|            new Range16 (0x0dd0, 0x0dd1, 1),
	|            new Range16 (0x0dd8, 0x0ddf, 1),
	|            new Range16 (0x0df2, 0x0df3, 1),
	|            new Range16 (0x0f3e, 0x0f3f, 1),
	|            new Range16 (0x0f7f, 0x102b, 172),
	|            new Range16 (0x102c, 0x1031, 5),
	|            new Range16 (0x1038, 0x103b, 3),
	|            new Range16 (0x103c, 0x1056, 26),
	|            new Range16 (0x1057, 0x1062, 11),
	|            new Range16 (0x1063, 0x1064, 1),
	|            new Range16 (0x1067, 0x106d, 1),
	|            new Range16 (0x1083, 0x1084, 1),
	|            new Range16 (0x1087, 0x108c, 1),
	|            new Range16 (0x108f, 0x109a, 11),
	|            new Range16 (0x109b, 0x109c, 1),
	|            new Range16 (0x1715, 0x1734, 31),
	|            new Range16 (0x17b6, 0x17be, 8),
	|            new Range16 (0x17bf, 0x17c5, 1),
	|            new Range16 (0x17c7, 0x17c8, 1),
	|            new Range16 (0x1923, 0x1926, 1),
	|            new Range16 (0x1929, 0x192b, 1),
	|            new Range16 (0x1930, 0x1931, 1),
	|            new Range16 (0x1933, 0x1938, 1),
	|            new Range16 (0x1a19, 0x1a1a, 1),
	|            new Range16 (0x1a55, 0x1a57, 2),
	|            new Range16 (0x1a61, 0x1a63, 2),
	|            new Range16 (0x1a64, 0x1a6d, 9),
	|            new Range16 (0x1a6e, 0x1a72, 1),
	|            new Range16 (0x1b04, 0x1b35, 49),
	|            new Range16 (0x1b3b, 0x1b3d, 2),
	|            new Range16 (0x1b3e, 0x1b41, 1),
	|            new Range16 (0x1b43, 0x1b44, 1),
	|            new Range16 (0x1b82, 0x1ba1, 31),
	|            new Range16 (0x1ba6, 0x1ba7, 1),
	|            new Range16 (0x1baa, 0x1be7, 61),
	|            new Range16 (0x1bea, 0x1bec, 1),
	|            new Range16 (0x1bee, 0x1bf2, 4),
	|            new Range16 (0x1bf3, 0x1c24, 49),
	|            new Range16 (0x1c25, 0x1c2b, 1),
	|            new Range16 (0x1c34, 0x1c35, 1),
	|            new Range16 (0x1ce1, 0x1cf7, 22),
	|            new Range16 (0x302e, 0x302f, 1),
	|            new Range16 (0xa823, 0xa824, 1),
	|            new Range16 (0xa827, 0xa880, 89),
	|            new Range16 (0xa881, 0xa8b4, 51),
	|            new Range16 (0xa8b5, 0xa8c3, 1),
	|            new Range16 (0xa952, 0xa953, 1),
	|            new Range16 (0xa983, 0xa9b4, 49),
	|            new Range16 (0xa9b5, 0xa9ba, 5),
	|            new Range16 (0xa9bb, 0xa9be, 3),
	|            new Range16 (0xa9bf, 0xa9c0, 1),
	|            new Range16 (0xaa2f, 0xaa30, 1),
	|            new Range16 (0xaa33, 0xaa34, 1),
	|            new Range16 (0xaa4d, 0xaa7b, 46),
	|            new Range16 (0xaa7d, 0xaaeb, 110),
	|            new Range16 (0xaaee, 0xaaef, 1),
	|            new Range16 (0xaaf5, 0xabe3, 238),
	|            new Range16 (0xabe4, 0xabe6, 2),
	|            new Range16 (0xabe7, 0xabe9, 2),
	|            new Range16 (0xabea, 0xabec, 2),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11000, 0x11002, 2),
	|            new Range32 (0x11082, 0x110b0, 46),
	|            new Range32 (0x110b1, 0x110b2, 1),
	|            new Range32 (0x110b7, 0x110b8, 1),
	|            new Range32 (0x1112c, 0x11145, 25),
	|            new Range32 (0x11146, 0x11182, 60),
	|            new Range32 (0x111b3, 0x111b5, 1),
	|            new Range32 (0x111bf, 0x111c0, 1),
	|            new Range32 (0x111ce, 0x1122c, 94),
	|            new Range32 (0x1122d, 0x1122e, 1),
	|            new Range32 (0x11232, 0x11233, 1),
	|            new Range32 (0x11235, 0x112e0, 171),
	|            new Range32 (0x112e1, 0x112e2, 1),
	|            new Range32 (0x11302, 0x11303, 1),
	|            new Range32 (0x1133e, 0x1133f, 1),
	|            new Range32 (0x11341, 0x11344, 1),
	|            new Range32 (0x11347, 0x11348, 1),
	|            new Range32 (0x1134b, 0x1134d, 1),
	|            new Range32 (0x11357, 0x11362, 11),
	|            new Range32 (0x11363, 0x11435, 210),
	|            new Range32 (0x11436, 0x11437, 1),
	|            new Range32 (0x11440, 0x11441, 1),
	|            new Range32 (0x11445, 0x114b0, 107),
	|            new Range32 (0x114b1, 0x114b2, 1),
	|            new Range32 (0x114b9, 0x114bb, 2),
	|            new Range32 (0x114bc, 0x114be, 1),
	|            new Range32 (0x114c1, 0x115af, 238),
	|            new Range32 (0x115b0, 0x115b1, 1),
	|            new Range32 (0x115b8, 0x115bb, 1),
	|            new Range32 (0x115be, 0x11630, 114),
	|            new Range32 (0x11631, 0x11632, 1),
	|            new Range32 (0x1163b, 0x1163c, 1),
	|            new Range32 (0x1163e, 0x116ac, 110),
	|            new Range32 (0x116ae, 0x116af, 1),
	|            new Range32 (0x116b6, 0x11720, 106),
	|            new Range32 (0x11721, 0x11726, 5),
	|            new Range32 (0x1182c, 0x1182e, 1),
	|            new Range32 (0x11838, 0x11930, 248),
	|            new Range32 (0x11931, 0x11935, 1),
	|            new Range32 (0x11937, 0x11938, 1),
	|            new Range32 (0x1193d, 0x11940, 3),
	|            new Range32 (0x11942, 0x119d1, 143),
	|            new Range32 (0x119d2, 0x119d3, 1),
	|            new Range32 (0x119dc, 0x119df, 1),
	|            new Range32 (0x119e4, 0x11a39, 85),
	|            new Range32 (0x11a57, 0x11a58, 1),
	|            new Range32 (0x11a97, 0x11c2f, 408),
	|            new Range32 (0x11c3e, 0x11ca9, 107),
	|            new Range32 (0x11cb1, 0x11cb4, 3),
	|            new Range32 (0x11d8a, 0x11d8e, 1),
	|            new Range32 (0x11d93, 0x11d94, 1),
	|            new Range32 (0x11d96, 0x11ef5, 351),
	|            new Range32 (0x11ef6, 0x11f03, 13),
	|            new Range32 (0x11f34, 0x11f35, 1),
	|            new Range32 (0x11f3e, 0x11f3f, 1),
	|            new Range32 (0x11f41, 0x16f51, 20496),
	|            new Range32 (0x16f52, 0x16f87, 1),
	|            new Range32 (0x16ff0, 0x16ff1, 1),
	|            new Range32 (0x1d165, 0x1d166, 1),
	|            new Range32 (0x1d16d, 0x1d172, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Me = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0488, 0x0489, 1),
	|            new Range16 (0x1abe, 0x20dd, 1567),
	|            new Range16 (0x20de, 0x20e0, 1),
	|            new Range16 (0x20e2, 0x20e4, 1),
	|            new Range16 (0xa670, 0xa672, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Mn = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0300, 0x036f, 1),
	|            new Range16 (0x0483, 0x0487, 1),
	|            new Range16 (0x0591, 0x05bd, 1),
	|            new Range16 (0x05bf, 0x05c1, 2),
	|            new Range16 (0x05c2, 0x05c4, 2),
	|            new Range16 (0x05c5, 0x05c7, 2),
	|            new Range16 (0x0610, 0x061a, 1),
	|            new Range16 (0x064b, 0x065f, 1),
	|            new Range16 (0x0670, 0x06d6, 102),
	|            new Range16 (0x06d7, 0x06dc, 1),
	|            new Range16 (0x06df, 0x06e4, 1),
	|            new Range16 (0x06e7, 0x06e8, 1),
	|            new Range16 (0x06ea, 0x06ed, 1),
	|            new Range16 (0x0711, 0x0730, 31),
	|            new Range16 (0x0731, 0x074a, 1),
	|            new Range16 (0x07a6, 0x07b0, 1),
	|            new Range16 (0x07eb, 0x07f3, 1),
	|            new Range16 (0x07fd, 0x0816, 25),
	|            new Range16 (0x0817, 0x0819, 1),
	|            new Range16 (0x081b, 0x0823, 1),
	|            new Range16 (0x0825, 0x0827, 1),
	|            new Range16 (0x0829, 0x082d, 1),
	|            new Range16 (0x0859, 0x085b, 1),
	|            new Range16 (0x0898, 0x089f, 1),
	|            new Range16 (0x08ca, 0x08e1, 1),
	|            new Range16 (0x08e3, 0x0902, 1),
	|            new Range16 (0x093a, 0x093c, 2),
	|            new Range16 (0x0941, 0x0948, 1),
	|            new Range16 (0x094d, 0x0951, 4),
	|            new Range16 (0x0952, 0x0957, 1),
	|            new Range16 (0x0962, 0x0963, 1),
	|            new Range16 (0x0981, 0x09bc, 59),
	|            new Range16 (0x09c1, 0x09c4, 1),
	|            new Range16 (0x09cd, 0x09e2, 21),
	|            new Range16 (0x09e3, 0x09fe, 27),
	|            new Range16 (0x0a01, 0x0a02, 1),
	|            new Range16 (0x0a3c, 0x0a41, 5),
	|            new Range16 (0x0a42, 0x0a47, 5),
	|            new Range16 (0x0a48, 0x0a4b, 3),
	|            new Range16 (0x0a4c, 0x0a4d, 1),
	|            new Range16 (0x0a51, 0x0a70, 31),
	|            new Range16 (0x0a71, 0x0a75, 4),
	|            new Range16 (0x0a81, 0x0a82, 1),
	|            new Range16 (0x0abc, 0x0ac1, 5),
	|            new Range16 (0x0ac2, 0x0ac5, 1),
	|            new Range16 (0x0ac7, 0x0ac8, 1),
	|            new Range16 (0x0acd, 0x0ae2, 21),
	|            new Range16 (0x0ae3, 0x0afa, 23),
	|            new Range16 (0x0afb, 0x0aff, 1),
	|            new Range16 (0x0b01, 0x0b3c, 59),
	|            new Range16 (0x0b3f, 0x0b41, 2),
	|            new Range16 (0x0b42, 0x0b44, 1),
	|            new Range16 (0x0b4d, 0x0b55, 8),
	|            new Range16 (0x0b56, 0x0b62, 12),
	|            new Range16 (0x0b63, 0x0b82, 31),
	|            new Range16 (0x0bc0, 0x0bcd, 13),
	|            new Range16 (0x0c00, 0x0c04, 4),
	|            new Range16 (0x0c3c, 0x0c3e, 2),
	|            new Range16 (0x0c3f, 0x0c40, 1),
	|            new Range16 (0x0c46, 0x0c48, 1),
	|            new Range16 (0x0c4a, 0x0c4d, 1),
	|            new Range16 (0x0c55, 0x0c56, 1),
	|            new Range16 (0x0c62, 0x0c63, 1),
	|            new Range16 (0x0c81, 0x0cbc, 59),
	|            new Range16 (0x0cbf, 0x0cc6, 7),
	|            new Range16 (0x0ccc, 0x0ccd, 1),
	|            new Range16 (0x0ce2, 0x0ce3, 1),
	|            new Range16 (0x0d00, 0x0d01, 1),
	|            new Range16 (0x0d3b, 0x0d3c, 1),
	|            new Range16 (0x0d41, 0x0d44, 1),
	|            new Range16 (0x0d4d, 0x0d62, 21),
	|            new Range16 (0x0d63, 0x0d81, 30),
	|            new Range16 (0x0dca, 0x0dd2, 8),
	|            new Range16 (0x0dd3, 0x0dd4, 1),
	|            new Range16 (0x0dd6, 0x0e31, 91),
	|            new Range16 (0x0e34, 0x0e3a, 1),
	|            new Range16 (0x0e47, 0x0e4e, 1),
	|            new Range16 (0x0eb1, 0x0eb4, 3),
	|            new Range16 (0x0eb5, 0x0ebc, 1),
	|            new Range16 (0x0ec8, 0x0ece, 1),
	|            new Range16 (0x0f18, 0x0f19, 1),
	|            new Range16 (0x0f35, 0x0f39, 2),
	|            new Range16 (0x0f71, 0x0f7e, 1),
	|            new Range16 (0x0f80, 0x0f84, 1),
	|            new Range16 (0x0f86, 0x0f87, 1),
	|            new Range16 (0x0f8d, 0x0f97, 1),
	|            new Range16 (0x0f99, 0x0fbc, 1),
	|            new Range16 (0x0fc6, 0x102d, 103),
	|            new Range16 (0x102e, 0x1030, 1),
	|            new Range16 (0x1032, 0x1037, 1),
	|            new Range16 (0x1039, 0x103a, 1),
	|            new Range16 (0x103d, 0x103e, 1),
	|            new Range16 (0x1058, 0x1059, 1),
	|            new Range16 (0x105e, 0x1060, 1),
	|            new Range16 (0x1071, 0x1074, 1),
	|            new Range16 (0x1082, 0x1085, 3),
	|            new Range16 (0x1086, 0x108d, 7),
	|            new Range16 (0x109d, 0x135d, 704),
	|            new Range16 (0x135e, 0x135f, 1),
	|            new Range16 (0x1712, 0x1714, 1),
	|            new Range16 (0x1732, 0x1733, 1),
	|            new Range16 (0x1752, 0x1753, 1),
	|            new Range16 (0x1772, 0x1773, 1),
	|            new Range16 (0x17b4, 0x17b5, 1),
	|            new Range16 (0x17b7, 0x17bd, 1),
	|            new Range16 (0x17c6, 0x17c9, 3),
	|            new Range16 (0x17ca, 0x17d3, 1),
	|            new Range16 (0x17dd, 0x180b, 46),
	|            new Range16 (0x180c, 0x180d, 1),
	|            new Range16 (0x180f, 0x1885, 118),
	|            new Range16 (0x1886, 0x18a9, 35),
	|            new Range16 (0x1920, 0x1922, 1),
	|            new Range16 (0x1927, 0x1928, 1),
	|            new Range16 (0x1932, 0x1939, 7),
	|            new Range16 (0x193a, 0x193b, 1),
	|            new Range16 (0x1a17, 0x1a18, 1),
	|            new Range16 (0x1a1b, 0x1a56, 59),
	|            new Range16 (0x1a58, 0x1a5e, 1),
	|            new Range16 (0x1a60, 0x1a62, 2),
	|            new Range16 (0x1a65, 0x1a6c, 1),
	|            new Range16 (0x1a73, 0x1a7c, 1),
	|            new Range16 (0x1a7f, 0x1ab0, 49),
	|            new Range16 (0x1ab1, 0x1abd, 1),
	|            new Range16 (0x1abf, 0x1ace, 1),
	|            new Range16 (0x1b00, 0x1b03, 1),
	|            new Range16 (0x1b34, 0x1b36, 2),
	|            new Range16 (0x1b37, 0x1b3a, 1),
	|            new Range16 (0x1b3c, 0x1b42, 6),
	|            new Range16 (0x1b6b, 0x1b73, 1),
	|            new Range16 (0x1b80, 0x1b81, 1),
	|            new Range16 (0x1ba2, 0x1ba5, 1),
	|            new Range16 (0x1ba8, 0x1ba9, 1),
	|            new Range16 (0x1bab, 0x1bad, 1),
	|            new Range16 (0x1be6, 0x1be8, 2),
	|            new Range16 (0x1be9, 0x1bed, 4),
	|            new Range16 (0x1bef, 0x1bf1, 1),
	|            new Range16 (0x1c2c, 0x1c33, 1),
	|            new Range16 (0x1c36, 0x1c37, 1),
	|            new Range16 (0x1cd0, 0x1cd2, 1),
	|            new Range16 (0x1cd4, 0x1ce0, 1),
	|            new Range16 (0x1ce2, 0x1ce8, 1),
	|            new Range16 (0x1ced, 0x1cf4, 7),
	|            new Range16 (0x1cf8, 0x1cf9, 1),
	|            new Range16 (0x1dc0, 0x1dff, 1),
	|            new Range16 (0x20d0, 0x20dc, 1),
	|            new Range16 (0x20e1, 0x20e5, 4),
	|            new Range16 (0x20e6, 0x20f0, 1),
	|            new Range16 (0x2cef, 0x2cf1, 1),
	|            new Range16 (0x2d7f, 0x2de0, 97),
	|            new Range16 (0x2de1, 0x2dff, 1),
	|            new Range16 (0x302a, 0x302d, 1),
	|            new Range16 (0x3099, 0x309a, 1),
	|            new Range16 (0xa66f, 0xa674, 5),
	|            new Range16 (0xa675, 0xa67d, 1),
	|            new Range16 (0xa69e, 0xa69f, 1),
	|            new Range16 (0xa6f0, 0xa6f1, 1),
	|            new Range16 (0xa802, 0xa806, 4),
	|            new Range16 (0xa80b, 0xa825, 26),
	|            new Range16 (0xa826, 0xa82c, 6),
	|            new Range16 (0xa8c4, 0xa8c5, 1),
	|            new Range16 (0xa8e0, 0xa8f1, 1),
	|            new Range16 (0xa8ff, 0xa926, 39),
	|            new Range16 (0xa927, 0xa92d, 1),
	|            new Range16 (0xa947, 0xa951, 1),
	|            new Range16 (0xa980, 0xa982, 1),
	|            new Range16 (0xa9b3, 0xa9b6, 3),
	|            new Range16 (0xa9b7, 0xa9b9, 1),
	|            new Range16 (0xa9bc, 0xa9bd, 1),
	|            new Range16 (0xa9e5, 0xaa29, 68),
	|            new Range16 (0xaa2a, 0xaa2e, 1),
	|            new Range16 (0xaa31, 0xaa32, 1),
	|            new Range16 (0xaa35, 0xaa36, 1),
	|            new Range16 (0xaa43, 0xaa4c, 9),
	|            new Range16 (0xaa7c, 0xaab0, 52),
	|            new Range16 (0xaab2, 0xaab4, 1),
	|            new Range16 (0xaab7, 0xaab8, 1),
	|            new Range16 (0xaabe, 0xaabf, 1),
	|            new Range16 (0xaac1, 0xaaec, 43),
	|            new Range16 (0xaaed, 0xaaf6, 9),
	|            new Range16 (0xabe5, 0xabe8, 3),
	|            new Range16 (0xabed, 0xfb1e, 20273),
	|            new Range16 (0xfe00, 0xfe0f, 1),
	|            new Range16 (0xfe20, 0xfe2f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x101fd, 0x102e0, 227),
	|            new Range32 (0x10376, 0x1037a, 1),
	|            new Range32 (0x10a01, 0x10a03, 1),
	|            new Range32 (0x10a05, 0x10a06, 1),
	|            new Range32 (0x10a0c, 0x10a0f, 1),
	|            new Range32 (0x10a38, 0x10a3a, 1),
	|            new Range32 (0x10a3f, 0x10ae5, 166),
	|            new Range32 (0x10ae6, 0x10d24, 574),
	|            new Range32 (0x10d25, 0x10d27, 1),
	|            new Range32 (0x10eab, 0x10eac, 1),
	|            new Range32 (0x10efd, 0x10eff, 1),
	|            new Range32 (0x10f46, 0x10f50, 1),
	|            new Range32 (0x10f82, 0x10f85, 1),
	|            new Range32 (0x11001, 0x11038, 55),
	|            new Range32 (0x11039, 0x11046, 1),
	|            new Range32 (0x11070, 0x11073, 3),
	|            new Range32 (0x11074, 0x1107f, 11),
	|            new Range32 (0x11080, 0x11081, 1),
	|            new Range32 (0x110b3, 0x110b6, 1),
	|            new Range32 (0x110b9, 0x110ba, 1),
	|            new Range32 (0x110c2, 0x11100, 62),
	|            new Range32 (0x11101, 0x11102, 1),
	|            new Range32 (0x11127, 0x1112b, 1),
	|            new Range32 (0x1112d, 0x11134, 1),
	|            new Range32 (0x11173, 0x11180, 13),
	|            new Range32 (0x11181, 0x111b6, 53),
	|            new Range32 (0x111b7, 0x111be, 1),
	|            new Range32 (0x111c9, 0x111cc, 1),
	|            new Range32 (0x111cf, 0x1122f, 96),
	|            new Range32 (0x11230, 0x11231, 1),
	|            new Range32 (0x11234, 0x11236, 2),
	|            new Range32 (0x11237, 0x1123e, 7),
	|            new Range32 (0x11241, 0x112df, 158),
	|            new Range32 (0x112e3, 0x112ea, 1),
	|            new Range32 (0x11300, 0x11301, 1),
	|            new Range32 (0x1133b, 0x1133c, 1),
	|            new Range32 (0x11340, 0x11366, 38),
	|            new Range32 (0x11367, 0x1136c, 1),
	|            new Range32 (0x11370, 0x11374, 1),
	|            new Range32 (0x11438, 0x1143f, 1),
	|            new Range32 (0x11442, 0x11444, 1),
	|            new Range32 (0x11446, 0x1145e, 24),
	|            new Range32 (0x114b3, 0x114b8, 1),
	|            new Range32 (0x114ba, 0x114bf, 5),
	|            new Range32 (0x114c0, 0x114c2, 2),
	|            new Range32 (0x114c3, 0x115b2, 239),
	|            new Range32 (0x115b3, 0x115b5, 1),
	|            new Range32 (0x115bc, 0x115bd, 1),
	|            new Range32 (0x115bf, 0x115c0, 1),
	|            new Range32 (0x115dc, 0x115dd, 1),
	|            new Range32 (0x11633, 0x1163a, 1),
	|            new Range32 (0x1163d, 0x1163f, 2),
	|            new Range32 (0x11640, 0x116ab, 107),
	|            new Range32 (0x116ad, 0x116b0, 3),
	|            new Range32 (0x116b1, 0x116b5, 1),
	|            new Range32 (0x116b7, 0x1171d, 102),
	|            new Range32 (0x1171e, 0x1171f, 1),
	|            new Range32 (0x11722, 0x11725, 1),
	|            new Range32 (0x11727, 0x1172b, 1),
	|            new Range32 (0x1182f, 0x11837, 1),
	|            new Range32 (0x11839, 0x1183a, 1),
	|            new Range32 (0x1193b, 0x1193c, 1),
	|            new Range32 (0x1193e, 0x11943, 5),
	|            new Range32 (0x119d4, 0x119d7, 1),
	|            new Range32 (0x119da, 0x119db, 1),
	|            new Range32 (0x119e0, 0x11a01, 33),
	|            new Range32 (0x11a02, 0x11a0a, 1),
	|            new Range32 (0x11a33, 0x11a38, 1),
	|            new Range32 (0x11a3b, 0x11a3e, 1),
	|            new Range32 (0x11a47, 0x11a51, 10),
	|            new Range32 (0x11a52, 0x11a56, 1),
	|            new Range32 (0x11a59, 0x11a5b, 1),
	|            new Range32 (0x11a8a, 0x11a96, 1),
	|            new Range32 (0x11a98, 0x11a99, 1),
	|            new Range32 (0x11c30, 0x11c36, 1),
	|            new Range32 (0x11c38, 0x11c3d, 1),
	|            new Range32 (0x11c3f, 0x11c92, 83),
	|            new Range32 (0x11c93, 0x11ca7, 1),
	|            new Range32 (0x11caa, 0x11cb0, 1),
	|            new Range32 (0x11cb2, 0x11cb3, 1),
	|            new Range32 (0x11cb5, 0x11cb6, 1),
	|            new Range32 (0x11d31, 0x11d36, 1),
	|            new Range32 (0x11d3a, 0x11d3c, 2),
	|            new Range32 (0x11d3d, 0x11d3f, 2),
	|            new Range32 (0x11d40, 0x11d45, 1),
	|            new Range32 (0x11d47, 0x11d90, 73),
	|            new Range32 (0x11d91, 0x11d95, 4),
	|            new Range32 (0x11d97, 0x11ef3, 348),
	|            new Range32 (0x11ef4, 0x11f00, 12),
	|            new Range32 (0x11f01, 0x11f36, 53),
	|            new Range32 (0x11f37, 0x11f3a, 1),
	|            new Range32 (0x11f40, 0x11f42, 2),
	|            new Range32 (0x13440, 0x13447, 7),
	|            new Range32 (0x13448, 0x13455, 1),
	|            new Range32 (0x16af0, 0x16af4, 1),
	|            new Range32 (0x16b30, 0x16b36, 1),
	|            new Range32 (0x16f4f, 0x16f8f, 64),
	|            new Range32 (0x16f90, 0x16f92, 1),
	|            new Range32 (0x16fe4, 0x1bc9d, 19641),
	|            new Range32 (0x1bc9e, 0x1cf00, 4706),
	|            new Range32 (0x1cf01, 0x1cf2d, 1),
	|            new Range32 (0x1cf30, 0x1cf46, 1),
	|            new Range32 (0x1d167, 0x1d169, 1),
	|            new Range32 (0x1d17b, 0x1d182, 1),
	|            new Range32 (0x1d185, 0x1d18b, 1),
	|            new Range32 (0x1d1aa, 0x1d1ad, 1),
	|            new Range32 (0x1d242, 0x1d244, 1),
	|            new Range32 (0x1da00, 0x1da36, 1),
	|            new Range32 (0x1da3b, 0x1da6c, 1),
	|            new Range32 (0x1da75, 0x1da84, 15),
	|            new Range32 (0x1da9b, 0x1da9f, 1),
	|            new Range32 (0x1daa1, 0x1daaf, 1),
	|            new Range32 (0x1e000, 0x1e006, 1),
	|            new Range32 (0x1e008, 0x1e018, 1),
	|            new Range32 (0x1e01b, 0x1e021, 1),
	|            new Range32 (0x1e023, 0x1e024, 1),
	|            new Range32 (0x1e026, 0x1e02a, 1),
	|            new Range32 (0x1e08f, 0x1e130, 161),
	|            new Range32 (0x1e131, 0x1e136, 1),
	|            new Range32 (0x1e2ae, 0x1e2ec, 62),
	|            new Range32 (0x1e2ed, 0x1e2ef, 1),
	|            new Range32 (0x1e4ec, 0x1e4ef, 1),
	|            new Range32 (0x1e8d0, 0x1e8d6, 1),
	|            new Range32 (0x1e944, 0x1e94a, 1),
	|            new Range32 (0xe0100, 0xe01ef, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _N = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0030, 0x0039, 1),
	|            new Range16 (0x00b2, 0x00b3, 1),
	|            new Range16 (0x00b9, 0x00bc, 3),
	|            new Range16 (0x00bd, 0x00be, 1),
	|            new Range16 (0x0660, 0x0669, 1),
	|            new Range16 (0x06f0, 0x06f9, 1),
	|            new Range16 (0x07c0, 0x07c9, 1),
	|            new Range16 (0x0966, 0x096f, 1),
	|            new Range16 (0x09e6, 0x09ef, 1),
	|            new Range16 (0x09f4, 0x09f9, 1),
	|            new Range16 (0x0a66, 0x0a6f, 1),
	|            new Range16 (0x0ae6, 0x0aef, 1),
	|            new Range16 (0x0b66, 0x0b6f, 1),
	|            new Range16 (0x0b72, 0x0b77, 1),
	|            new Range16 (0x0be6, 0x0bf2, 1),
	|            new Range16 (0x0c66, 0x0c6f, 1),
	|            new Range16 (0x0c78, 0x0c7e, 1),
	|            new Range16 (0x0ce6, 0x0cef, 1),
	|            new Range16 (0x0d58, 0x0d5e, 1),
	|            new Range16 (0x0d66, 0x0d78, 1),
	|            new Range16 (0x0de6, 0x0def, 1),
	|            new Range16 (0x0e50, 0x0e59, 1),
	|            new Range16 (0x0ed0, 0x0ed9, 1),
	|            new Range16 (0x0f20, 0x0f33, 1),
	|            new Range16 (0x1040, 0x1049, 1),
	|            new Range16 (0x1090, 0x1099, 1),
	|            new Range16 (0x1369, 0x137c, 1),
	|            new Range16 (0x16ee, 0x16f0, 1),
	|            new Range16 (0x17e0, 0x17e9, 1),
	|            new Range16 (0x17f0, 0x17f9, 1),
	|            new Range16 (0x1810, 0x1819, 1),
	|            new Range16 (0x1946, 0x194f, 1),
	|            new Range16 (0x19d0, 0x19da, 1),
	|            new Range16 (0x1a80, 0x1a89, 1),
	|            new Range16 (0x1a90, 0x1a99, 1),
	|            new Range16 (0x1b50, 0x1b59, 1),
	|            new Range16 (0x1bb0, 0x1bb9, 1),
	|            new Range16 (0x1c40, 0x1c49, 1),
	|            new Range16 (0x1c50, 0x1c59, 1),
	|            new Range16 (0x2070, 0x2074, 4),
	|            new Range16 (0x2075, 0x2079, 1),
	|            new Range16 (0x2080, 0x2089, 1),
	|            new Range16 (0x2150, 0x2182, 1),
	|            new Range16 (0x2185, 0x2189, 1),
	|            new Range16 (0x2460, 0x249b, 1),
	|            new Range16 (0x24ea, 0x24ff, 1),
	|            new Range16 (0x2776, 0x2793, 1),
	|            new Range16 (0x2cfd, 0x3007, 778),
	|            new Range16 (0x3021, 0x3029, 1),
	|            new Range16 (0x3038, 0x303a, 1),
	|            new Range16 (0x3192, 0x3195, 1),
	|            new Range16 (0x3220, 0x3229, 1),
	|            new Range16 (0x3248, 0x324f, 1),
	|            new Range16 (0x3251, 0x325f, 1),
	|            new Range16 (0x3280, 0x3289, 1),
	|            new Range16 (0x32b1, 0x32bf, 1),
	|            new Range16 (0xa620, 0xa629, 1),
	|            new Range16 (0xa6e6, 0xa6ef, 1),
	|            new Range16 (0xa830, 0xa835, 1),
	|            new Range16 (0xa8d0, 0xa8d9, 1),
	|            new Range16 (0xa900, 0xa909, 1),
	|            new Range16 (0xa9d0, 0xa9d9, 1),
	|            new Range16 (0xa9f0, 0xa9f9, 1),
	|            new Range16 (0xaa50, 0xaa59, 1),
	|            new Range16 (0xabf0, 0xabf9, 1),
	|            new Range16 (0xff10, 0xff19, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10107, 0x10133, 1),
	|            new Range32 (0x10140, 0x10178, 1),
	|            new Range32 (0x1018a, 0x1018b, 1),
	|            new Range32 (0x102e1, 0x102fb, 1),
	|            new Range32 (0x10320, 0x10323, 1),
	|            new Range32 (0x10341, 0x1034a, 9),
	|            new Range32 (0x103d1, 0x103d5, 1),
	|            new Range32 (0x104a0, 0x104a9, 1),
	|            new Range32 (0x10858, 0x1085f, 1),
	|            new Range32 (0x10879, 0x1087f, 1),
	|            new Range32 (0x108a7, 0x108af, 1),
	|            new Range32 (0x108fb, 0x108ff, 1),
	|            new Range32 (0x10916, 0x1091b, 1),
	|            new Range32 (0x109bc, 0x109bd, 1),
	|            new Range32 (0x109c0, 0x109cf, 1),
	|            new Range32 (0x109d2, 0x109ff, 1),
	|            new Range32 (0x10a40, 0x10a48, 1),
	|            new Range32 (0x10a7d, 0x10a7e, 1),
	|            new Range32 (0x10a9d, 0x10a9f, 1),
	|            new Range32 (0x10aeb, 0x10aef, 1),
	|            new Range32 (0x10b58, 0x10b5f, 1),
	|            new Range32 (0x10b78, 0x10b7f, 1),
	|            new Range32 (0x10ba9, 0x10baf, 1),
	|            new Range32 (0x10cfa, 0x10cff, 1),
	|            new Range32 (0x10d30, 0x10d39, 1),
	|            new Range32 (0x10e60, 0x10e7e, 1),
	|            new Range32 (0x10f1d, 0x10f26, 1),
	|            new Range32 (0x10f51, 0x10f54, 1),
	|            new Range32 (0x10fc5, 0x10fcb, 1),
	|            new Range32 (0x11052, 0x1106f, 1),
	|            new Range32 (0x110f0, 0x110f9, 1),
	|            new Range32 (0x11136, 0x1113f, 1),
	|            new Range32 (0x111d0, 0x111d9, 1),
	|            new Range32 (0x111e1, 0x111f4, 1),
	|            new Range32 (0x112f0, 0x112f9, 1),
	|            new Range32 (0x11450, 0x11459, 1),
	|            new Range32 (0x114d0, 0x114d9, 1),
	|            new Range32 (0x11650, 0x11659, 1),
	|            new Range32 (0x116c0, 0x116c9, 1),
	|            new Range32 (0x11730, 0x1173b, 1),
	|            new Range32 (0x118e0, 0x118f2, 1),
	|            new Range32 (0x11950, 0x11959, 1),
	|            new Range32 (0x11c50, 0x11c6c, 1),
	|            new Range32 (0x11d50, 0x11d59, 1),
	|            new Range32 (0x11da0, 0x11da9, 1),
	|            new Range32 (0x11f50, 0x11f59, 1),
	|            new Range32 (0x11fc0, 0x11fd4, 1),
	|            new Range32 (0x12400, 0x1246e, 1),
	|            new Range32 (0x16a60, 0x16a69, 1),
	|            new Range32 (0x16ac0, 0x16ac9, 1),
	|            new Range32 (0x16b50, 0x16b59, 1),
	|            new Range32 (0x16b5b, 0x16b61, 1),
	|            new Range32 (0x16e80, 0x16e96, 1),
	|            new Range32 (0x1d2c0, 0x1d2d3, 1),
	|            new Range32 (0x1d2e0, 0x1d2f3, 1),
	|            new Range32 (0x1d360, 0x1d378, 1),
	|            new Range32 (0x1d7ce, 0x1d7ff, 1),
	|            new Range32 (0x1e140, 0x1e149, 1),
	|            new Range32 (0x1e2f0, 0x1e2f9, 1),
	|            new Range32 (0x1e4f0, 0x1e4f9, 1),
	|            new Range32 (0x1e8c7, 0x1e8cf, 1),
	|            new Range32 (0x1e950, 0x1e959, 1),
	|            new Range32 (0x1ec71, 0x1ecab, 1),
	|            new Range32 (0x1ecad, 0x1ecaf, 1),
	|            new Range32 (0x1ecb1, 0x1ecb4, 1),
	|            new Range32 (0x1ed01, 0x1ed2d, 1),
	|            new Range32 (0x1ed2f, 0x1ed3d, 1),
	|            new Range32 (0x1f100, 0x1f10c, 1),
	|            new Range32 (0x1fbf0, 0x1fbf9, 1),
	|                },
	|                latinOffset: 4
	|            );
	|
	|            internal static RangeTable _Nd = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0030, 0x0039, 1),
	|            new Range16 (0x0660, 0x0669, 1),
	|            new Range16 (0x06f0, 0x06f9, 1),
	|            new Range16 (0x07c0, 0x07c9, 1),
	|            new Range16 (0x0966, 0x096f, 1),
	|            new Range16 (0x09e6, 0x09ef, 1),
	|            new Range16 (0x0a66, 0x0a6f, 1),
	|            new Range16 (0x0ae6, 0x0aef, 1),
	|            new Range16 (0x0b66, 0x0b6f, 1),
	|            new Range16 (0x0be6, 0x0bef, 1),
	|            new Range16 (0x0c66, 0x0c6f, 1),
	|            new Range16 (0x0ce6, 0x0cef, 1),
	|            new Range16 (0x0d66, 0x0d6f, 1),
	|            new Range16 (0x0de6, 0x0def, 1),
	|            new Range16 (0x0e50, 0x0e59, 1),
	|            new Range16 (0x0ed0, 0x0ed9, 1),
	|            new Range16 (0x0f20, 0x0f29, 1),
	|            new Range16 (0x1040, 0x1049, 1),
	|            new Range16 (0x1090, 0x1099, 1),
	|            new Range16 (0x17e0, 0x17e9, 1),
	|            new Range16 (0x1810, 0x1819, 1),
	|            new Range16 (0x1946, 0x194f, 1),
	|            new Range16 (0x19d0, 0x19d9, 1),
	|            new Range16 (0x1a80, 0x1a89, 1),
	|            new Range16 (0x1a90, 0x1a99, 1),
	|            new Range16 (0x1b50, 0x1b59, 1),
	|            new Range16 (0x1bb0, 0x1bb9, 1),
	|            new Range16 (0x1c40, 0x1c49, 1),
	|            new Range16 (0x1c50, 0x1c59, 1),
	|            new Range16 (0xa620, 0xa629, 1),
	|            new Range16 (0xa8d0, 0xa8d9, 1),
	|            new Range16 (0xa900, 0xa909, 1),
	|            new Range16 (0xa9d0, 0xa9d9, 1),
	|            new Range16 (0xa9f0, 0xa9f9, 1),
	|            new Range16 (0xaa50, 0xaa59, 1),
	|            new Range16 (0xabf0, 0xabf9, 1),
	|            new Range16 (0xff10, 0xff19, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x104a0, 0x104a9, 1),
	|            new Range32 (0x10d30, 0x10d39, 1),
	|            new Range32 (0x11066, 0x1106f, 1),
	|            new Range32 (0x110f0, 0x110f9, 1),
	|            new Range32 (0x11136, 0x1113f, 1),
	|            new Range32 (0x111d0, 0x111d9, 1),
	|            new Range32 (0x112f0, 0x112f9, 1),
	|            new Range32 (0x11450, 0x11459, 1),
	|            new Range32 (0x114d0, 0x114d9, 1),
	|            new Range32 (0x11650, 0x11659, 1),
	|            new Range32 (0x116c0, 0x116c9, 1),
	|            new Range32 (0x11730, 0x11739, 1),
	|            new Range32 (0x118e0, 0x118e9, 1),
	|            new Range32 (0x11950, 0x11959, 1),
	|            new Range32 (0x11c50, 0x11c59, 1),
	|            new Range32 (0x11d50, 0x11d59, 1),
	|            new Range32 (0x11da0, 0x11da9, 1),
	|            new Range32 (0x11f50, 0x11f59, 1),
	|            new Range32 (0x16a60, 0x16a69, 1),
	|            new Range32 (0x16ac0, 0x16ac9, 1),
	|            new Range32 (0x16b50, 0x16b59, 1),
	|            new Range32 (0x1d7ce, 0x1d7ff, 1),
	|            new Range32 (0x1e140, 0x1e149, 1),
	|            new Range32 (0x1e2f0, 0x1e2f9, 1),
	|            new Range32 (0x1e4f0, 0x1e4f9, 1),
	|            new Range32 (0x1e950, 0x1e959, 1),
	|            new Range32 (0x1fbf0, 0x1fbf9, 1),
	|                },
	|                latinOffset: 1
	|            );
	|
	|            internal static RangeTable _Nl = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x16ee, 0x16f0, 1),
	|            new Range16 (0x2160, 0x2182, 1),
	|            new Range16 (0x2185, 0x2188, 1),
	|            new Range16 (0x3007, 0x3021, 26),
	|            new Range16 (0x3022, 0x3029, 1),
	|            new Range16 (0x3038, 0x303a, 1),
	|            new Range16 (0xa6e6, 0xa6ef, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10140, 0x10174, 1),
	|            new Range32 (0x10341, 0x1034a, 9),
	|            new Range32 (0x103d1, 0x103d5, 1),
	|            new Range32 (0x12400, 0x1246e, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _No = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00b2, 0x00b3, 1),
	|            new Range16 (0x00b9, 0x00bc, 3),
	|            new Range16 (0x00bd, 0x00be, 1),
	|            new Range16 (0x09f4, 0x09f9, 1),
	|            new Range16 (0x0b72, 0x0b77, 1),
	|            new Range16 (0x0bf0, 0x0bf2, 1),
	|            new Range16 (0x0c78, 0x0c7e, 1),
	|            new Range16 (0x0d58, 0x0d5e, 1),
	|            new Range16 (0x0d70, 0x0d78, 1),
	|            new Range16 (0x0f2a, 0x0f33, 1),
	|            new Range16 (0x1369, 0x137c, 1),
	|            new Range16 (0x17f0, 0x17f9, 1),
	|            new Range16 (0x19da, 0x2070, 1686),
	|            new Range16 (0x2074, 0x2079, 1),
	|            new Range16 (0x2080, 0x2089, 1),
	|            new Range16 (0x2150, 0x215f, 1),
	|            new Range16 (0x2189, 0x2460, 727),
	|            new Range16 (0x2461, 0x249b, 1),
	|            new Range16 (0x24ea, 0x24ff, 1),
	|            new Range16 (0x2776, 0x2793, 1),
	|            new Range16 (0x2cfd, 0x3192, 1173),
	|            new Range16 (0x3193, 0x3195, 1),
	|            new Range16 (0x3220, 0x3229, 1),
	|            new Range16 (0x3248, 0x324f, 1),
	|            new Range16 (0x3251, 0x325f, 1),
	|            new Range16 (0x3280, 0x3289, 1),
	|            new Range16 (0x32b1, 0x32bf, 1),
	|            new Range16 (0xa830, 0xa835, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10107, 0x10133, 1),
	|            new Range32 (0x10175, 0x10178, 1),
	|            new Range32 (0x1018a, 0x1018b, 1),
	|            new Range32 (0x102e1, 0x102fb, 1),
	|            new Range32 (0x10320, 0x10323, 1),
	|            new Range32 (0x10858, 0x1085f, 1),
	|            new Range32 (0x10879, 0x1087f, 1),
	|            new Range32 (0x108a7, 0x108af, 1),
	|            new Range32 (0x108fb, 0x108ff, 1),
	|            new Range32 (0x10916, 0x1091b, 1),
	|            new Range32 (0x109bc, 0x109bd, 1),
	|            new Range32 (0x109c0, 0x109cf, 1),
	|            new Range32 (0x109d2, 0x109ff, 1),
	|            new Range32 (0x10a40, 0x10a48, 1),
	|            new Range32 (0x10a7d, 0x10a7e, 1),
	|            new Range32 (0x10a9d, 0x10a9f, 1),
	|            new Range32 (0x10aeb, 0x10aef, 1),
	|            new Range32 (0x10b58, 0x10b5f, 1),
	|            new Range32 (0x10b78, 0x10b7f, 1),
	|            new Range32 (0x10ba9, 0x10baf, 1),
	|            new Range32 (0x10cfa, 0x10cff, 1),
	|            new Range32 (0x10e60, 0x10e7e, 1),
	|            new Range32 (0x10f1d, 0x10f26, 1),
	|            new Range32 (0x10f51, 0x10f54, 1),
	|            new Range32 (0x10fc5, 0x10fcb, 1),
	|            new Range32 (0x11052, 0x11065, 1),
	|            new Range32 (0x111e1, 0x111f4, 1),
	|            new Range32 (0x1173a, 0x1173b, 1),
	|            new Range32 (0x118ea, 0x118f2, 1),
	|            new Range32 (0x11c5a, 0x11c6c, 1),
	|            new Range32 (0x11fc0, 0x11fd4, 1),
	|            new Range32 (0x16b5b, 0x16b61, 1),
	|            new Range32 (0x16e80, 0x16e96, 1),
	|            new Range32 (0x1d2c0, 0x1d2d3, 1),
	|            new Range32 (0x1d2e0, 0x1d2f3, 1),
	|            new Range32 (0x1d360, 0x1d378, 1),
	|            new Range32 (0x1e8c7, 0x1e8cf, 1),
	|            new Range32 (0x1ec71, 0x1ecab, 1),
	|            new Range32 (0x1ecad, 0x1ecaf, 1),
	|            new Range32 (0x1ecb1, 0x1ecb4, 1),
	|            new Range32 (0x1ed01, 0x1ed2d, 1),
	|            new Range32 (0x1ed2f, 0x1ed3d, 1),
	|            new Range32 (0x1f100, 0x1f10c, 1),
	|                },
	|                latinOffset: 3
	|            );
	|
	|            internal static RangeTable _P = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0021, 0x0023, 1),
	|            new Range16 (0x0025, 0x002a, 1),
	|            new Range16 (0x002c, 0x002f, 1),
	|            new Range16 (0x003a, 0x003b, 1),
	|            new Range16 (0x003f, 0x0040, 1),
	|            new Range16 (0x005b, 0x005d, 1),
	|            new Range16 (0x005f, 0x007b, 28),
	|            new Range16 (0x007d, 0x00a1, 36),
	|            new Range16 (0x00a7, 0x00ab, 4),
	|            new Range16 (0x00b6, 0x00b7, 1),
	|            new Range16 (0x00bb, 0x00bf, 4),
	|            new Range16 (0x037e, 0x0387, 9),
	|            new Range16 (0x055a, 0x055f, 1),
	|            new Range16 (0x0589, 0x058a, 1),
	|            new Range16 (0x05be, 0x05c0, 2),
	|            new Range16 (0x05c3, 0x05c6, 3),
	|            new Range16 (0x05f3, 0x05f4, 1),
	|            new Range16 (0x0609, 0x060a, 1),
	|            new Range16 (0x060c, 0x060d, 1),
	|            new Range16 (0x061b, 0x061d, 2),
	|            new Range16 (0x061e, 0x061f, 1),
	|            new Range16 (0x066a, 0x066d, 1),
	|            new Range16 (0x06d4, 0x0700, 44),
	|            new Range16 (0x0701, 0x070d, 1),
	|            new Range16 (0x07f7, 0x07f9, 1),
	|            new Range16 (0x0830, 0x083e, 1),
	|            new Range16 (0x085e, 0x0964, 262),
	|            new Range16 (0x0965, 0x0970, 11),
	|            new Range16 (0x09fd, 0x0a76, 121),
	|            new Range16 (0x0af0, 0x0c77, 391),
	|            new Range16 (0x0c84, 0x0df4, 368),
	|            new Range16 (0x0e4f, 0x0e5a, 11),
	|            new Range16 (0x0e5b, 0x0f04, 169),
	|            new Range16 (0x0f05, 0x0f12, 1),
	|            new Range16 (0x0f14, 0x0f3a, 38),
	|            new Range16 (0x0f3b, 0x0f3d, 1),
	|            new Range16 (0x0f85, 0x0fd0, 75),
	|            new Range16 (0x0fd1, 0x0fd4, 1),
	|            new Range16 (0x0fd9, 0x0fda, 1),
	|            new Range16 (0x104a, 0x104f, 1),
	|            new Range16 (0x10fb, 0x1360, 613),
	|            new Range16 (0x1361, 0x1368, 1),
	|            new Range16 (0x1400, 0x166e, 622),
	|            new Range16 (0x169b, 0x169c, 1),
	|            new Range16 (0x16eb, 0x16ed, 1),
	|            new Range16 (0x1735, 0x1736, 1),
	|            new Range16 (0x17d4, 0x17d6, 1),
	|            new Range16 (0x17d8, 0x17da, 1),
	|            new Range16 (0x1800, 0x180a, 1),
	|            new Range16 (0x1944, 0x1945, 1),
	|            new Range16 (0x1a1e, 0x1a1f, 1),
	|            new Range16 (0x1aa0, 0x1aa6, 1),
	|            new Range16 (0x1aa8, 0x1aad, 1),
	|            new Range16 (0x1b5a, 0x1b60, 1),
	|            new Range16 (0x1b7d, 0x1b7e, 1),
	|            new Range16 (0x1bfc, 0x1bff, 1),
	|            new Range16 (0x1c3b, 0x1c3f, 1),
	|            new Range16 (0x1c7e, 0x1c7f, 1),
	|            new Range16 (0x1cc0, 0x1cc7, 1),
	|            new Range16 (0x1cd3, 0x2010, 829),
	|            new Range16 (0x2011, 0x2027, 1),
	|            new Range16 (0x2030, 0x2043, 1),
	|            new Range16 (0x2045, 0x2051, 1),
	|            new Range16 (0x2053, 0x205e, 1),
	|            new Range16 (0x207d, 0x207e, 1),
	|            new Range16 (0x208d, 0x208e, 1),
	|            new Range16 (0x2308, 0x230b, 1),
	|            new Range16 (0x2329, 0x232a, 1),
	|            new Range16 (0x2768, 0x2775, 1),
	|            new Range16 (0x27c5, 0x27c6, 1),
	|            new Range16 (0x27e6, 0x27ef, 1),
	|            new Range16 (0x2983, 0x2998, 1),
	|            new Range16 (0x29d8, 0x29db, 1),
	|            new Range16 (0x29fc, 0x29fd, 1),
	|            new Range16 (0x2cf9, 0x2cfc, 1),
	|            new Range16 (0x2cfe, 0x2cff, 1),
	|            new Range16 (0x2d70, 0x2e00, 144),
	|            new Range16 (0x2e01, 0x2e2e, 1),
	|            new Range16 (0x2e30, 0x2e4f, 1),
	|            new Range16 (0x2e52, 0x2e5d, 1),
	|            new Range16 (0x3001, 0x3003, 1),
	|            new Range16 (0x3008, 0x3011, 1),
	|            new Range16 (0x3014, 0x301f, 1),
	|            new Range16 (0x3030, 0x303d, 13),
	|            new Range16 (0x30a0, 0x30fb, 91),
	|            new Range16 (0xa4fe, 0xa4ff, 1),
	|            new Range16 (0xa60d, 0xa60f, 1),
	|            new Range16 (0xa673, 0xa67e, 11),
	|            new Range16 (0xa6f2, 0xa6f7, 1),
	|            new Range16 (0xa874, 0xa877, 1),
	|            new Range16 (0xa8ce, 0xa8cf, 1),
	|            new Range16 (0xa8f8, 0xa8fa, 1),
	|            new Range16 (0xa8fc, 0xa92e, 50),
	|            new Range16 (0xa92f, 0xa95f, 48),
	|            new Range16 (0xa9c1, 0xa9cd, 1),
	|            new Range16 (0xa9de, 0xa9df, 1),
	|            new Range16 (0xaa5c, 0xaa5f, 1),
	|            new Range16 (0xaade, 0xaadf, 1),
	|            new Range16 (0xaaf0, 0xaaf1, 1),
	|            new Range16 (0xabeb, 0xfd3e, 20819),
	|            new Range16 (0xfd3f, 0xfe10, 209),
	|            new Range16 (0xfe11, 0xfe19, 1),
	|            new Range16 (0xfe30, 0xfe52, 1),
	|            new Range16 (0xfe54, 0xfe61, 1),
	|            new Range16 (0xfe63, 0xfe68, 5),
	|            new Range16 (0xfe6a, 0xfe6b, 1),
	|            new Range16 (0xff01, 0xff03, 1),
	|            new Range16 (0xff05, 0xff0a, 1),
	|            new Range16 (0xff0c, 0xff0f, 1),
	|            new Range16 (0xff1a, 0xff1b, 1),
	|            new Range16 (0xff1f, 0xff20, 1),
	|            new Range16 (0xff3b, 0xff3d, 1),
	|            new Range16 (0xff3f, 0xff5b, 28),
	|            new Range16 (0xff5d, 0xff5f, 2),
	|            new Range16 (0xff60, 0xff65, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10100, 0x10102, 1),
	|            new Range32 (0x1039f, 0x103d0, 49),
	|            new Range32 (0x1056f, 0x10857, 744),
	|            new Range32 (0x1091f, 0x1093f, 32),
	|            new Range32 (0x10a50, 0x10a58, 1),
	|            new Range32 (0x10a7f, 0x10af0, 113),
	|            new Range32 (0x10af1, 0x10af6, 1),
	|            new Range32 (0x10b39, 0x10b3f, 1),
	|            new Range32 (0x10b99, 0x10b9c, 1),
	|            new Range32 (0x10ead, 0x10f55, 168),
	|            new Range32 (0x10f56, 0x10f59, 1),
	|            new Range32 (0x10f86, 0x10f89, 1),
	|            new Range32 (0x11047, 0x1104d, 1),
	|            new Range32 (0x110bb, 0x110bc, 1),
	|            new Range32 (0x110be, 0x110c1, 1),
	|            new Range32 (0x11140, 0x11143, 1),
	|            new Range32 (0x11174, 0x11175, 1),
	|            new Range32 (0x111c5, 0x111c8, 1),
	|            new Range32 (0x111cd, 0x111db, 14),
	|            new Range32 (0x111dd, 0x111df, 1),
	|            new Range32 (0x11238, 0x1123d, 1),
	|            new Range32 (0x112a9, 0x1144b, 418),
	|            new Range32 (0x1144c, 0x1144f, 1),
	|            new Range32 (0x1145a, 0x1145b, 1),
	|            new Range32 (0x1145d, 0x114c6, 105),
	|            new Range32 (0x115c1, 0x115d7, 1),
	|            new Range32 (0x11641, 0x11643, 1),
	|            new Range32 (0x11660, 0x1166c, 1),
	|            new Range32 (0x116b9, 0x1173c, 131),
	|            new Range32 (0x1173d, 0x1173e, 1),
	|            new Range32 (0x1183b, 0x11944, 265),
	|            new Range32 (0x11945, 0x11946, 1),
	|            new Range32 (0x119e2, 0x11a3f, 93),
	|            new Range32 (0x11a40, 0x11a46, 1),
	|            new Range32 (0x11a9a, 0x11a9c, 1),
	|            new Range32 (0x11a9e, 0x11aa2, 1),
	|            new Range32 (0x11b00, 0x11b09, 1),
	|            new Range32 (0x11c41, 0x11c45, 1),
	|            new Range32 (0x11c70, 0x11c71, 1),
	|            new Range32 (0x11ef7, 0x11ef8, 1),
	|            new Range32 (0x11f43, 0x11f4f, 1),
	|            new Range32 (0x11fff, 0x12470, 1137),
	|            new Range32 (0x12471, 0x12474, 1),
	|            new Range32 (0x12ff1, 0x12ff2, 1),
	|            new Range32 (0x16a6e, 0x16a6f, 1),
	|            new Range32 (0x16af5, 0x16b37, 66),
	|            new Range32 (0x16b38, 0x16b3b, 1),
	|            new Range32 (0x16b44, 0x16e97, 851),
	|            new Range32 (0x16e98, 0x16e9a, 1),
	|            new Range32 (0x16fe2, 0x1bc9f, 19645),
	|            new Range32 (0x1da87, 0x1da8b, 1),
	|            new Range32 (0x1e95e, 0x1e95f, 1),
	|                },
	|                latinOffset: 11
	|            );
	|
	|            internal static RangeTable _Pc = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x005f, 0x203f, 8160),
	|            new Range16 (0x2040, 0x2054, 20),
	|            new Range16 (0xfe33, 0xfe34, 1),
	|            new Range16 (0xfe4d, 0xfe4f, 1),
	|            new Range16 (0xff3f, 0xff3f, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Pd = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x002d, 0x058a, 1373),
	|            new Range16 (0x05be, 0x1400, 3650),
	|            new Range16 (0x1806, 0x2010, 2058),
	|            new Range16 (0x2011, 0x2015, 1),
	|            new Range16 (0x2e17, 0x2e1a, 3),
	|            new Range16 (0x2e3a, 0x2e3b, 1),
	|            new Range16 (0x2e40, 0x2e5d, 29),
	|            new Range16 (0x301c, 0x3030, 20),
	|            new Range16 (0x30a0, 0xfe31, 52625),
	|            new Range16 (0xfe32, 0xfe58, 38),
	|            new Range16 (0xfe63, 0xff0d, 170),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10ead, 0x10ead, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Pe = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0029, 0x005d, 52),
	|            new Range16 (0x007d, 0x0f3b, 3774),
	|            new Range16 (0x0f3d, 0x169c, 1887),
	|            new Range16 (0x2046, 0x207e, 56),
	|            new Range16 (0x208e, 0x2309, 635),
	|            new Range16 (0x230b, 0x232a, 31),
	|            new Range16 (0x2769, 0x2775, 2),
	|            new Range16 (0x27c6, 0x27e7, 33),
	|            new Range16 (0x27e9, 0x27ef, 2),
	|            new Range16 (0x2984, 0x2998, 2),
	|            new Range16 (0x29d9, 0x29db, 2),
	|            new Range16 (0x29fd, 0x2e23, 1062),
	|            new Range16 (0x2e25, 0x2e29, 2),
	|            new Range16 (0x2e56, 0x2e5c, 2),
	|            new Range16 (0x3009, 0x3011, 2),
	|            new Range16 (0x3015, 0x301b, 2),
	|            new Range16 (0x301e, 0x301f, 1),
	|            new Range16 (0xfd3e, 0xfe18, 218),
	|            new Range16 (0xfe36, 0xfe44, 2),
	|            new Range16 (0xfe48, 0xfe5a, 18),
	|            new Range16 (0xfe5c, 0xfe5e, 2),
	|            new Range16 (0xff09, 0xff3d, 52),
	|            new Range16 (0xff5d, 0xff63, 3),
	|                },
	|                latinOffset: 1
	|            );
	|
	|            internal static RangeTable _Pf = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00bb, 0x2019, 8030),
	|            new Range16 (0x201d, 0x203a, 29),
	|            new Range16 (0x2e03, 0x2e05, 2),
	|            new Range16 (0x2e0a, 0x2e0d, 3),
	|            new Range16 (0x2e1d, 0x2e21, 4),
	|                }
	|            );
	|
	|            internal static RangeTable _Pi = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00ab, 0x2018, 8045),
	|            new Range16 (0x201b, 0x201c, 1),
	|            new Range16 (0x201f, 0x2039, 26),
	|            new Range16 (0x2e02, 0x2e04, 2),
	|            new Range16 (0x2e09, 0x2e0c, 3),
	|            new Range16 (0x2e1c, 0x2e20, 4),
	|                }
	|            );
	|
	|            internal static RangeTable _Po = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0021, 0x0023, 1),
	|            new Range16 (0x0025, 0x0027, 1),
	|            new Range16 (0x002a, 0x002e, 2),
	|            new Range16 (0x002f, 0x003a, 11),
	|            new Range16 (0x003b, 0x003f, 4),
	|            new Range16 (0x0040, 0x005c, 28),
	|            new Range16 (0x00a1, 0x00a7, 6),
	|            new Range16 (0x00b6, 0x00b7, 1),
	|            new Range16 (0x00bf, 0x037e, 703),
	|            new Range16 (0x0387, 0x055a, 467),
	|            new Range16 (0x055b, 0x055f, 1),
	|            new Range16 (0x0589, 0x05c0, 55),
	|            new Range16 (0x05c3, 0x05c6, 3),
	|            new Range16 (0x05f3, 0x05f4, 1),
	|            new Range16 (0x0609, 0x060a, 1),
	|            new Range16 (0x060c, 0x060d, 1),
	|            new Range16 (0x061b, 0x061d, 2),
	|            new Range16 (0x061e, 0x061f, 1),
	|            new Range16 (0x066a, 0x066d, 1),
	|            new Range16 (0x06d4, 0x0700, 44),
	|            new Range16 (0x0701, 0x070d, 1),
	|            new Range16 (0x07f7, 0x07f9, 1),
	|            new Range16 (0x0830, 0x083e, 1),
	|            new Range16 (0x085e, 0x0964, 262),
	|            new Range16 (0x0965, 0x0970, 11),
	|            new Range16 (0x09fd, 0x0a76, 121),
	|            new Range16 (0x0af0, 0x0c77, 391),
	|            new Range16 (0x0c84, 0x0df4, 368),
	|            new Range16 (0x0e4f, 0x0e5a, 11),
	|            new Range16 (0x0e5b, 0x0f04, 169),
	|            new Range16 (0x0f05, 0x0f12, 1),
	|            new Range16 (0x0f14, 0x0f85, 113),
	|            new Range16 (0x0fd0, 0x0fd4, 1),
	|            new Range16 (0x0fd9, 0x0fda, 1),
	|            new Range16 (0x104a, 0x104f, 1),
	|            new Range16 (0x10fb, 0x1360, 613),
	|            new Range16 (0x1361, 0x1368, 1),
	|            new Range16 (0x166e, 0x16eb, 125),
	|            new Range16 (0x16ec, 0x16ed, 1),
	|            new Range16 (0x1735, 0x1736, 1),
	|            new Range16 (0x17d4, 0x17d6, 1),
	|            new Range16 (0x17d8, 0x17da, 1),
	|            new Range16 (0x1800, 0x1805, 1),
	|            new Range16 (0x1807, 0x180a, 1),
	|            new Range16 (0x1944, 0x1945, 1),
	|            new Range16 (0x1a1e, 0x1a1f, 1),
	|            new Range16 (0x1aa0, 0x1aa6, 1),
	|            new Range16 (0x1aa8, 0x1aad, 1),
	|            new Range16 (0x1b5a, 0x1b60, 1),
	|            new Range16 (0x1b7d, 0x1b7e, 1),
	|            new Range16 (0x1bfc, 0x1bff, 1),
	|            new Range16 (0x1c3b, 0x1c3f, 1),
	|            new Range16 (0x1c7e, 0x1c7f, 1),
	|            new Range16 (0x1cc0, 0x1cc7, 1),
	|            new Range16 (0x1cd3, 0x2016, 835),
	|            new Range16 (0x2017, 0x2020, 9),
	|            new Range16 (0x2021, 0x2027, 1),
	|            new Range16 (0x2030, 0x2038, 1),
	|            new Range16 (0x203b, 0x203e, 1),
	|            new Range16 (0x2041, 0x2043, 1),
	|            new Range16 (0x2047, 0x2051, 1),
	|            new Range16 (0x2053, 0x2055, 2),
	|            new Range16 (0x2056, 0x205e, 1),
	|            new Range16 (0x2cf9, 0x2cfc, 1),
	|            new Range16 (0x2cfe, 0x2cff, 1),
	|            new Range16 (0x2d70, 0x2e00, 144),
	|            new Range16 (0x2e01, 0x2e06, 5),
	|            new Range16 (0x2e07, 0x2e08, 1),
	|            new Range16 (0x2e0b, 0x2e0e, 3),
	|            new Range16 (0x2e0f, 0x2e16, 1),
	|            new Range16 (0x2e18, 0x2e19, 1),
	|            new Range16 (0x2e1b, 0x2e1e, 3),
	|            new Range16 (0x2e1f, 0x2e2a, 11),
	|            new Range16 (0x2e2b, 0x2e2e, 1),
	|            new Range16 (0x2e30, 0x2e39, 1),
	|            new Range16 (0x2e3c, 0x2e3f, 1),
	|            new Range16 (0x2e41, 0x2e43, 2),
	|            new Range16 (0x2e44, 0x2e4f, 1),
	|            new Range16 (0x2e52, 0x2e54, 1),
	|            new Range16 (0x3001, 0x3003, 1),
	|            new Range16 (0x303d, 0x30fb, 190),
	|            new Range16 (0xa4fe, 0xa4ff, 1),
	|            new Range16 (0xa60d, 0xa60f, 1),
	|            new Range16 (0xa673, 0xa67e, 11),
	|            new Range16 (0xa6f2, 0xa6f7, 1),
	|            new Range16 (0xa874, 0xa877, 1),
	|            new Range16 (0xa8ce, 0xa8cf, 1),
	|            new Range16 (0xa8f8, 0xa8fa, 1),
	|            new Range16 (0xa8fc, 0xa92e, 50),
	|            new Range16 (0xa92f, 0xa95f, 48),
	|            new Range16 (0xa9c1, 0xa9cd, 1),
	|            new Range16 (0xa9de, 0xa9df, 1),
	|            new Range16 (0xaa5c, 0xaa5f, 1),
	|            new Range16 (0xaade, 0xaadf, 1),
	|            new Range16 (0xaaf0, 0xaaf1, 1),
	|            new Range16 (0xabeb, 0xfe10, 21029),
	|            new Range16 (0xfe11, 0xfe16, 1),
	|            new Range16 (0xfe19, 0xfe30, 23),
	|            new Range16 (0xfe45, 0xfe46, 1),
	|            new Range16 (0xfe49, 0xfe4c, 1),
	|            new Range16 (0xfe50, 0xfe52, 1),
	|            new Range16 (0xfe54, 0xfe57, 1),
	|            new Range16 (0xfe5f, 0xfe61, 1),
	|            new Range16 (0xfe68, 0xfe6a, 2),
	|            new Range16 (0xfe6b, 0xff01, 150),
	|            new Range16 (0xff02, 0xff03, 1),
	|            new Range16 (0xff05, 0xff07, 1),
	|            new Range16 (0xff0a, 0xff0e, 2),
	|            new Range16 (0xff0f, 0xff1a, 11),
	|            new Range16 (0xff1b, 0xff1f, 4),
	|            new Range16 (0xff20, 0xff3c, 28),
	|            new Range16 (0xff61, 0xff64, 3),
	|            new Range16 (0xff65, 0xff65, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10100, 0x10100, 1),
	|            new Range32 (0x10101, 0x10102, 1),
	|            new Range32 (0x1039f, 0x103d0, 49),
	|            new Range32 (0x1056f, 0x10857, 744),
	|            new Range32 (0x1091f, 0x1093f, 32),
	|            new Range32 (0x10a50, 0x10a58, 1),
	|            new Range32 (0x10a7f, 0x10af0, 113),
	|            new Range32 (0x10af1, 0x10af6, 1),
	|            new Range32 (0x10b39, 0x10b3f, 1),
	|            new Range32 (0x10b99, 0x10b9c, 1),
	|            new Range32 (0x10f55, 0x10f59, 1),
	|            new Range32 (0x10f86, 0x10f89, 1),
	|            new Range32 (0x11047, 0x1104d, 1),
	|            new Range32 (0x110bb, 0x110bc, 1),
	|            new Range32 (0x110be, 0x110c1, 1),
	|            new Range32 (0x11140, 0x11143, 1),
	|            new Range32 (0x11174, 0x11175, 1),
	|            new Range32 (0x111c5, 0x111c8, 1),
	|            new Range32 (0x111cd, 0x111db, 14),
	|            new Range32 (0x111dd, 0x111df, 1),
	|            new Range32 (0x11238, 0x1123d, 1),
	|            new Range32 (0x112a9, 0x1144b, 418),
	|            new Range32 (0x1144c, 0x1144f, 1),
	|            new Range32 (0x1145a, 0x1145b, 1),
	|            new Range32 (0x1145d, 0x114c6, 105),
	|            new Range32 (0x115c1, 0x115d7, 1),
	|            new Range32 (0x11641, 0x11643, 1),
	|            new Range32 (0x11660, 0x1166c, 1),
	|            new Range32 (0x116b9, 0x1173c, 131),
	|            new Range32 (0x1173d, 0x1173e, 1),
	|            new Range32 (0x1183b, 0x11944, 265),
	|            new Range32 (0x11945, 0x11946, 1),
	|            new Range32 (0x119e2, 0x11a3f, 93),
	|            new Range32 (0x11a40, 0x11a46, 1),
	|            new Range32 (0x11a9a, 0x11a9c, 1),
	|            new Range32 (0x11a9e, 0x11aa2, 1),
	|            new Range32 (0x11b00, 0x11b09, 1),
	|            new Range32 (0x11c41, 0x11c45, 1),
	|            new Range32 (0x11c70, 0x11c71, 1),
	|            new Range32 (0x11ef7, 0x11ef8, 1),
	|            new Range32 (0x11f43, 0x11f4f, 1),
	|            new Range32 (0x11fff, 0x12470, 1137),
	|            new Range32 (0x12471, 0x12474, 1),
	|            new Range32 (0x12ff1, 0x12ff2, 1),
	|            new Range32 (0x16a6e, 0x16a6f, 1),
	|            new Range32 (0x16af5, 0x16b37, 66),
	|            new Range32 (0x16b38, 0x16b3b, 1),
	|            new Range32 (0x16b44, 0x16e97, 851),
	|            new Range32 (0x16e98, 0x16e9a, 1),
	|            new Range32 (0x16fe2, 0x1bc9f, 19645),
	|            new Range32 (0x1da87, 0x1da8b, 1),
	|            new Range32 (0x1e95e, 0x1e95f, 1),
	|                },
	|                latinOffset: 8
	|            );
	|
	|            internal static RangeTable _Ps = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0028, 0x005b, 51),
	|            new Range16 (0x007b, 0x0f3a, 3775),
	|            new Range16 (0x0f3c, 0x169b, 1887),
	|            new Range16 (0x201a, 0x201e, 4),
	|            new Range16 (0x2045, 0x207d, 56),
	|            new Range16 (0x208d, 0x2308, 635),
	|            new Range16 (0x230a, 0x2329, 31),
	|            new Range16 (0x2768, 0x2774, 2),
	|            new Range16 (0x27c5, 0x27e6, 33),
	|            new Range16 (0x27e8, 0x27ee, 2),
	|            new Range16 (0x2983, 0x2997, 2),
	|            new Range16 (0x29d8, 0x29da, 2),
	|            new Range16 (0x29fc, 0x2e22, 1062),
	|            new Range16 (0x2e24, 0x2e28, 2),
	|            new Range16 (0x2e42, 0x2e55, 19),
	|            new Range16 (0x2e57, 0x2e5b, 2),
	|            new Range16 (0x3008, 0x3010, 2),
	|            new Range16 (0x3014, 0x301a, 2),
	|            new Range16 (0x301d, 0xfd3f, 52514),
	|            new Range16 (0xfe17, 0xfe35, 30),
	|            new Range16 (0xfe37, 0xfe43, 2),
	|            new Range16 (0xfe47, 0xfe59, 18),
	|            new Range16 (0xfe5b, 0xfe5d, 2),
	|            new Range16 (0xff08, 0xff3b, 51),
	|            new Range16 (0xff5b, 0xff5f, 4),
	|            new Range16 (0xff62, 0xff62, 1),
	|                },
	|                latinOffset: 1
	|            );
	|
	|            internal static RangeTable _S = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0024, 0x002b, 7),
	|            new Range16 (0x003c, 0x003e, 1),
	|            new Range16 (0x005e, 0x0060, 2),
	|            new Range16 (0x007c, 0x007e, 2),
	|            new Range16 (0x00a2, 0x00a6, 1),
	|            new Range16 (0x00a8, 0x00a9, 1),
	|            new Range16 (0x00ac, 0x00ae, 2),
	|            new Range16 (0x00af, 0x00b1, 1),
	|            new Range16 (0x00b4, 0x00b8, 4),
	|            new Range16 (0x00d7, 0x00f7, 32),
	|            new Range16 (0x02c2, 0x02c5, 1),
	|            new Range16 (0x02d2, 0x02df, 1),
	|            new Range16 (0x02e5, 0x02eb, 1),
	|            new Range16 (0x02ed, 0x02ef, 2),
	|            new Range16 (0x02f0, 0x02ff, 1),
	|            new Range16 (0x0375, 0x0384, 15),
	|            new Range16 (0x0385, 0x03f6, 113),
	|            new Range16 (0x0482, 0x058d, 267),
	|            new Range16 (0x058e, 0x058f, 1),
	|            new Range16 (0x0606, 0x0608, 1),
	|            new Range16 (0x060b, 0x060e, 3),
	|            new Range16 (0x060f, 0x06de, 207),
	|            new Range16 (0x06e9, 0x06fd, 20),
	|            new Range16 (0x06fe, 0x07f6, 248),
	|            new Range16 (0x07fe, 0x07ff, 1),
	|            new Range16 (0x0888, 0x09f2, 362),
	|            new Range16 (0x09f3, 0x09fa, 7),
	|            new Range16 (0x09fb, 0x0af1, 246),
	|            new Range16 (0x0b70, 0x0bf3, 131),
	|            new Range16 (0x0bf4, 0x0bfa, 1),
	|            new Range16 (0x0c7f, 0x0d4f, 208),
	|            new Range16 (0x0d79, 0x0e3f, 198),
	|            new Range16 (0x0f01, 0x0f03, 1),
	|            new Range16 (0x0f13, 0x0f15, 2),
	|            new Range16 (0x0f16, 0x0f17, 1),
	|            new Range16 (0x0f1a, 0x0f1f, 1),
	|            new Range16 (0x0f34, 0x0f38, 2),
	|            new Range16 (0x0fbe, 0x0fc5, 1),
	|            new Range16 (0x0fc7, 0x0fcc, 1),
	|            new Range16 (0x0fce, 0x0fcf, 1),
	|            new Range16 (0x0fd5, 0x0fd8, 1),
	|            new Range16 (0x109e, 0x109f, 1),
	|            new Range16 (0x1390, 0x1399, 1),
	|            new Range16 (0x166d, 0x17db, 366),
	|            new Range16 (0x1940, 0x19de, 158),
	|            new Range16 (0x19df, 0x19ff, 1),
	|            new Range16 (0x1b61, 0x1b6a, 1),
	|            new Range16 (0x1b74, 0x1b7c, 1),
	|            new Range16 (0x1fbd, 0x1fbf, 2),
	|            new Range16 (0x1fc0, 0x1fc1, 1),
	|            new Range16 (0x1fcd, 0x1fcf, 1),
	|            new Range16 (0x1fdd, 0x1fdf, 1),
	|            new Range16 (0x1fed, 0x1fef, 1),
	|            new Range16 (0x1ffd, 0x1ffe, 1),
	|            new Range16 (0x2044, 0x2052, 14),
	|            new Range16 (0x207a, 0x207c, 1),
	|            new Range16 (0x208a, 0x208c, 1),
	|            new Range16 (0x20a0, 0x20c0, 1),
	|            new Range16 (0x2100, 0x2101, 1),
	|            new Range16 (0x2103, 0x2106, 1),
	|            new Range16 (0x2108, 0x2109, 1),
	|            new Range16 (0x2114, 0x2116, 2),
	|            new Range16 (0x2117, 0x2118, 1),
	|            new Range16 (0x211e, 0x2123, 1),
	|            new Range16 (0x2125, 0x2129, 2),
	|            new Range16 (0x212e, 0x213a, 12),
	|            new Range16 (0x213b, 0x2140, 5),
	|            new Range16 (0x2141, 0x2144, 1),
	|            new Range16 (0x214a, 0x214d, 1),
	|            new Range16 (0x214f, 0x218a, 59),
	|            new Range16 (0x218b, 0x2190, 5),
	|            new Range16 (0x2191, 0x2307, 1),
	|            new Range16 (0x230c, 0x2328, 1),
	|            new Range16 (0x232b, 0x2426, 1),
	|            new Range16 (0x2440, 0x244a, 1),
	|            new Range16 (0x249c, 0x24e9, 1),
	|            new Range16 (0x2500, 0x2767, 1),
	|            new Range16 (0x2794, 0x27c4, 1),
	|            new Range16 (0x27c7, 0x27e5, 1),
	|            new Range16 (0x27f0, 0x2982, 1),
	|            new Range16 (0x2999, 0x29d7, 1),
	|            new Range16 (0x29dc, 0x29fb, 1),
	|            new Range16 (0x29fe, 0x2b73, 1),
	|            new Range16 (0x2b76, 0x2b95, 1),
	|            new Range16 (0x2b97, 0x2bff, 1),
	|            new Range16 (0x2ce5, 0x2cea, 1),
	|            new Range16 (0x2e50, 0x2e51, 1),
	|            new Range16 (0x2e80, 0x2e99, 1),
	|            new Range16 (0x2e9b, 0x2ef3, 1),
	|            new Range16 (0x2f00, 0x2fd5, 1),
	|            new Range16 (0x2ff0, 0x2ffb, 1),
	|            new Range16 (0x3004, 0x3012, 14),
	|            new Range16 (0x3013, 0x3020, 13),
	|            new Range16 (0x3036, 0x3037, 1),
	|            new Range16 (0x303e, 0x303f, 1),
	|            new Range16 (0x309b, 0x309c, 1),
	|            new Range16 (0x3190, 0x3191, 1),
	|            new Range16 (0x3196, 0x319f, 1),
	|            new Range16 (0x31c0, 0x31e3, 1),
	|            new Range16 (0x3200, 0x321e, 1),
	|            new Range16 (0x322a, 0x3247, 1),
	|            new Range16 (0x3250, 0x3260, 16),
	|            new Range16 (0x3261, 0x327f, 1),
	|            new Range16 (0x328a, 0x32b0, 1),
	|            new Range16 (0x32c0, 0x33ff, 1),
	|            new Range16 (0x4dc0, 0x4dff, 1),
	|            new Range16 (0xa490, 0xa4c6, 1),
	|            new Range16 (0xa700, 0xa716, 1),
	|            new Range16 (0xa720, 0xa721, 1),
	|            new Range16 (0xa789, 0xa78a, 1),
	|            new Range16 (0xa828, 0xa82b, 1),
	|            new Range16 (0xa836, 0xa839, 1),
	|            new Range16 (0xaa77, 0xaa79, 1),
	|            new Range16 (0xab5b, 0xab6a, 15),
	|            new Range16 (0xab6b, 0xfb29, 20414),
	|            new Range16 (0xfbb2, 0xfbc2, 1),
	|            new Range16 (0xfd40, 0xfd4f, 1),
	|            new Range16 (0xfdcf, 0xfdfc, 45),
	|            new Range16 (0xfdfd, 0xfdff, 1),
	|            new Range16 (0xfe62, 0xfe64, 2),
	|            new Range16 (0xfe65, 0xfe66, 1),
	|            new Range16 (0xfe69, 0xff04, 155),
	|            new Range16 (0xff0b, 0xff1c, 17),
	|            new Range16 (0xff1d, 0xff1e, 1),
	|            new Range16 (0xff3e, 0xff40, 2),
	|            new Range16 (0xff5c, 0xff5e, 2),
	|            new Range16 (0xffe0, 0xffe6, 1),
	|            new Range16 (0xffe8, 0xffee, 1),
	|            new Range16 (0xfffc, 0xfffd, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10137, 0x1013f, 1),
	|            new Range32 (0x10179, 0x10189, 1),
	|            new Range32 (0x1018c, 0x1018e, 1),
	|            new Range32 (0x10190, 0x1019c, 1),
	|            new Range32 (0x101a0, 0x101d0, 48),
	|            new Range32 (0x101d1, 0x101fc, 1),
	|            new Range32 (0x10877, 0x10878, 1),
	|            new Range32 (0x10ac8, 0x1173f, 3191),
	|            new Range32 (0x11fd5, 0x11ff1, 1),
	|            new Range32 (0x16b3c, 0x16b3f, 1),
	|            new Range32 (0x16b45, 0x1bc9c, 20823),
	|            new Range32 (0x1cf50, 0x1cfc3, 1),
	|            new Range32 (0x1d000, 0x1d0f5, 1),
	|            new Range32 (0x1d100, 0x1d126, 1),
	|            new Range32 (0x1d129, 0x1d164, 1),
	|            new Range32 (0x1d16a, 0x1d16c, 1),
	|            new Range32 (0x1d183, 0x1d184, 1),
	|            new Range32 (0x1d18c, 0x1d1a9, 1),
	|            new Range32 (0x1d1ae, 0x1d1ea, 1),
	|            new Range32 (0x1d200, 0x1d241, 1),
	|            new Range32 (0x1d245, 0x1d300, 187),
	|            new Range32 (0x1d301, 0x1d356, 1),
	|            new Range32 (0x1d6c1, 0x1d6db, 26),
	|            new Range32 (0x1d6fb, 0x1d715, 26),
	|            new Range32 (0x1d735, 0x1d74f, 26),
	|            new Range32 (0x1d76f, 0x1d789, 26),
	|            new Range32 (0x1d7a9, 0x1d7c3, 26),
	|            new Range32 (0x1d800, 0x1d9ff, 1),
	|            new Range32 (0x1da37, 0x1da3a, 1),
	|            new Range32 (0x1da6d, 0x1da74, 1),
	|            new Range32 (0x1da76, 0x1da83, 1),
	|            new Range32 (0x1da85, 0x1da86, 1),
	|            new Range32 (0x1e14f, 0x1e2ff, 432),
	|            new Range32 (0x1ecac, 0x1ecb0, 4),
	|            new Range32 (0x1ed2e, 0x1eef0, 450),
	|            new Range32 (0x1eef1, 0x1f000, 271),
	|            new Range32 (0x1f001, 0x1f02b, 1),
	|            new Range32 (0x1f030, 0x1f093, 1),
	|            new Range32 (0x1f0a0, 0x1f0ae, 1),
	|            new Range32 (0x1f0b1, 0x1f0bf, 1),
	|            new Range32 (0x1f0c1, 0x1f0cf, 1),
	|            new Range32 (0x1f0d1, 0x1f0f5, 1),
	|            new Range32 (0x1f10d, 0x1f1ad, 1),
	|            new Range32 (0x1f1e6, 0x1f202, 1),
	|            new Range32 (0x1f210, 0x1f23b, 1),
	|            new Range32 (0x1f240, 0x1f248, 1),
	|            new Range32 (0x1f250, 0x1f251, 1),
	|            new Range32 (0x1f260, 0x1f265, 1),
	|            new Range32 (0x1f300, 0x1f6d7, 1),
	|            new Range32 (0x1f6dc, 0x1f6ec, 1),
	|            new Range32 (0x1f6f0, 0x1f6fc, 1),
	|            new Range32 (0x1f700, 0x1f776, 1),
	|            new Range32 (0x1f77b, 0x1f7d9, 1),
	|            new Range32 (0x1f7e0, 0x1f7eb, 1),
	|            new Range32 (0x1f7f0, 0x1f800, 16),
	|            new Range32 (0x1f801, 0x1f80b, 1),
	|            new Range32 (0x1f810, 0x1f847, 1),
	|            new Range32 (0x1f850, 0x1f859, 1),
	|            new Range32 (0x1f860, 0x1f887, 1),
	|            new Range32 (0x1f890, 0x1f8ad, 1),
	|            new Range32 (0x1f8b0, 0x1f8b1, 1),
	|            new Range32 (0x1f900, 0x1fa53, 1),
	|            new Range32 (0x1fa60, 0x1fa6d, 1),
	|            new Range32 (0x1fa70, 0x1fa7c, 1),
	|            new Range32 (0x1fa80, 0x1fa88, 1),
	|            new Range32 (0x1fa90, 0x1fabd, 1),
	|            new Range32 (0x1fabf, 0x1fac5, 1),
	|            new Range32 (0x1face, 0x1fadb, 1),
	|            new Range32 (0x1fae0, 0x1fae8, 1),
	|            new Range32 (0x1faf0, 0x1faf8, 1),
	|            new Range32 (0x1fb00, 0x1fb92, 1),
	|            new Range32 (0x1fb94, 0x1fbca, 1),
	|                },
	|                latinOffset: 10
	|            );
	|
	|            internal static RangeTable _Sc = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0024, 0x00a2, 126),
	|            new Range16 (0x00a3, 0x00a5, 1),
	|            new Range16 (0x058f, 0x060b, 124),
	|            new Range16 (0x07fe, 0x07ff, 1),
	|            new Range16 (0x09f2, 0x09f3, 1),
	|            new Range16 (0x09fb, 0x0af1, 246),
	|            new Range16 (0x0bf9, 0x0e3f, 582),
	|            new Range16 (0x17db, 0x20a0, 2245),
	|            new Range16 (0x20a1, 0x20c0, 1),
	|            new Range16 (0xa838, 0xfdfc, 21956),
	|            new Range16 (0xfe69, 0xff04, 155),
	|            new Range16 (0xffe0, 0xffe1, 1),
	|            new Range16 (0xffe5, 0xffe6, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11fdd, 0x11fe0, 1),
	|            new Range32 (0x1e2ff, 0x1ecb0, 2481),
	|                },
	|                latinOffset: 2
	|            );
	|
	|            internal static RangeTable _Sk = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x005e, 0x0060, 2),
	|            new Range16 (0x00a8, 0x00af, 7),
	|            new Range16 (0x00b4, 0x00b8, 4),
	|            new Range16 (0x02c2, 0x02c5, 1),
	|            new Range16 (0x02d2, 0x02df, 1),
	|            new Range16 (0x02e5, 0x02eb, 1),
	|            new Range16 (0x02ed, 0x02ef, 2),
	|            new Range16 (0x02f0, 0x02ff, 1),
	|            new Range16 (0x0375, 0x0384, 15),
	|            new Range16 (0x0385, 0x0888, 1283),
	|            new Range16 (0x1fbd, 0x1fbf, 2),
	|            new Range16 (0x1fc0, 0x1fc1, 1),
	|            new Range16 (0x1fcd, 0x1fcf, 1),
	|            new Range16 (0x1fdd, 0x1fdf, 1),
	|            new Range16 (0x1fed, 0x1fef, 1),
	|            new Range16 (0x1ffd, 0x1ffe, 1),
	|            new Range16 (0x309b, 0x309c, 1),
	|            new Range16 (0xa700, 0xa716, 1),
	|            new Range16 (0xa720, 0xa721, 1),
	|            new Range16 (0xa789, 0xa78a, 1),
	|            new Range16 (0xab5b, 0xab6a, 15),
	|            new Range16 (0xab6b, 0xfbb2, 20551),
	|            new Range16 (0xfbb3, 0xfbc2, 1),
	|            new Range16 (0xff3e, 0xff40, 2),
	|            new Range16 (0xffe3, 0xffe3, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1f3fb, 0x1f3fb, 1),
	|            new Range32 (0x1f3fc, 0x1f3ff, 1),
	|                },
	|                latinOffset: 3
	|            );
	|
	|            internal static RangeTable _Sm = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x002b, 0x003c, 17),
	|            new Range16 (0x003d, 0x003e, 1),
	|            new Range16 (0x007c, 0x007e, 2),
	|            new Range16 (0x00ac, 0x00b1, 5),
	|            new Range16 (0x00d7, 0x00f7, 32),
	|            new Range16 (0x03f6, 0x0606, 528),
	|            new Range16 (0x0607, 0x0608, 1),
	|            new Range16 (0x2044, 0x2052, 14),
	|            new Range16 (0x207a, 0x207c, 1),
	|            new Range16 (0x208a, 0x208c, 1),
	|            new Range16 (0x2118, 0x2140, 40),
	|            new Range16 (0x2141, 0x2144, 1),
	|            new Range16 (0x214b, 0x2190, 69),
	|            new Range16 (0x2191, 0x2194, 1),
	|            new Range16 (0x219a, 0x219b, 1),
	|            new Range16 (0x21a0, 0x21a6, 3),
	|            new Range16 (0x21ae, 0x21ce, 32),
	|            new Range16 (0x21cf, 0x21d2, 3),
	|            new Range16 (0x21d4, 0x21f4, 32),
	|            new Range16 (0x21f5, 0x22ff, 1),
	|            new Range16 (0x2320, 0x2321, 1),
	|            new Range16 (0x237c, 0x239b, 31),
	|            new Range16 (0x239c, 0x23b3, 1),
	|            new Range16 (0x23dc, 0x23e1, 1),
	|            new Range16 (0x25b7, 0x25c1, 10),
	|            new Range16 (0x25f8, 0x25ff, 1),
	|            new Range16 (0x266f, 0x27c0, 337),
	|            new Range16 (0x27c1, 0x27c4, 1),
	|            new Range16 (0x27c7, 0x27e5, 1),
	|            new Range16 (0x27f0, 0x27ff, 1),
	|            new Range16 (0x2900, 0x2982, 1),
	|            new Range16 (0x2999, 0x29d7, 1),
	|            new Range16 (0x29dc, 0x29fb, 1),
	|            new Range16 (0x29fe, 0x2aff, 1),
	|            new Range16 (0x2b30, 0x2b44, 1),
	|            new Range16 (0x2b47, 0x2b4c, 1),
	|            new Range16 (0xfb29, 0xfe62, 825),
	|            new Range16 (0xfe64, 0xfe66, 1),
	|            new Range16 (0xff0b, 0xff1c, 17),
	|            new Range16 (0xff1d, 0xff1e, 1),
	|            new Range16 (0xff5c, 0xff5e, 2),
	|            new Range16 (0xffe2, 0xffe9, 7),
	|            new Range16 (0xffea, 0xffec, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1d6c1, 0x1d6db, 26),
	|            new Range32 (0x1d6fb, 0x1d715, 26),
	|            new Range32 (0x1d735, 0x1d74f, 26),
	|            new Range32 (0x1d76f, 0x1d789, 26),
	|            new Range32 (0x1d7a9, 0x1d7c3, 26),
	|            new Range32 (0x1eef0, 0x1eef1, 1),
	|                },
	|                latinOffset: 5
	|            );
	|
	|            internal static RangeTable _So = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00a6, 0x00a9, 3),
	|            new Range16 (0x00ae, 0x00b0, 2),
	|            new Range16 (0x0482, 0x058d, 267),
	|            new Range16 (0x058e, 0x060e, 128),
	|            new Range16 (0x060f, 0x06de, 207),
	|            new Range16 (0x06e9, 0x06fd, 20),
	|            new Range16 (0x06fe, 0x07f6, 248),
	|            new Range16 (0x09fa, 0x0b70, 374),
	|            new Range16 (0x0bf3, 0x0bf8, 1),
	|            new Range16 (0x0bfa, 0x0c7f, 133),
	|            new Range16 (0x0d4f, 0x0d79, 42),
	|            new Range16 (0x0f01, 0x0f03, 1),
	|            new Range16 (0x0f13, 0x0f15, 2),
	|            new Range16 (0x0f16, 0x0f17, 1),
	|            new Range16 (0x0f1a, 0x0f1f, 1),
	|            new Range16 (0x0f34, 0x0f38, 2),
	|            new Range16 (0x0fbe, 0x0fc5, 1),
	|            new Range16 (0x0fc7, 0x0fcc, 1),
	|            new Range16 (0x0fce, 0x0fcf, 1),
	|            new Range16 (0x0fd5, 0x0fd8, 1),
	|            new Range16 (0x109e, 0x109f, 1),
	|            new Range16 (0x1390, 0x1399, 1),
	|            new Range16 (0x166d, 0x1940, 723),
	|            new Range16 (0x19de, 0x19ff, 1),
	|            new Range16 (0x1b61, 0x1b6a, 1),
	|            new Range16 (0x1b74, 0x1b7c, 1),
	|            new Range16 (0x2100, 0x2101, 1),
	|            new Range16 (0x2103, 0x2106, 1),
	|            new Range16 (0x2108, 0x2109, 1),
	|            new Range16 (0x2114, 0x2116, 2),
	|            new Range16 (0x2117, 0x211e, 7),
	|            new Range16 (0x211f, 0x2123, 1),
	|            new Range16 (0x2125, 0x2129, 2),
	|            new Range16 (0x212e, 0x213a, 12),
	|            new Range16 (0x213b, 0x214a, 15),
	|            new Range16 (0x214c, 0x214d, 1),
	|            new Range16 (0x214f, 0x218a, 59),
	|            new Range16 (0x218b, 0x2195, 10),
	|            new Range16 (0x2196, 0x2199, 1),
	|            new Range16 (0x219c, 0x219f, 1),
	|            new Range16 (0x21a1, 0x21a2, 1),
	|            new Range16 (0x21a4, 0x21a5, 1),
	|            new Range16 (0x21a7, 0x21ad, 1),
	|            new Range16 (0x21af, 0x21cd, 1),
	|            new Range16 (0x21d0, 0x21d1, 1),
	|            new Range16 (0x21d3, 0x21d5, 2),
	|            new Range16 (0x21d6, 0x21f3, 1),
	|            new Range16 (0x2300, 0x2307, 1),
	|            new Range16 (0x230c, 0x231f, 1),
	|            new Range16 (0x2322, 0x2328, 1),
	|            new Range16 (0x232b, 0x237b, 1),
	|            new Range16 (0x237d, 0x239a, 1),
	|            new Range16 (0x23b4, 0x23db, 1),
	|            new Range16 (0x23e2, 0x2426, 1),
	|            new Range16 (0x2440, 0x244a, 1),
	|            new Range16 (0x249c, 0x24e9, 1),
	|            new Range16 (0x2500, 0x25b6, 1),
	|            new Range16 (0x25b8, 0x25c0, 1),
	|            new Range16 (0x25c2, 0x25f7, 1),
	|            new Range16 (0x2600, 0x266e, 1),
	|            new Range16 (0x2670, 0x2767, 1),
	|            new Range16 (0x2794, 0x27bf, 1),
	|            new Range16 (0x2800, 0x28ff, 1),
	|            new Range16 (0x2b00, 0x2b2f, 1),
	|            new Range16 (0x2b45, 0x2b46, 1),
	|            new Range16 (0x2b4d, 0x2b73, 1),
	|            new Range16 (0x2b76, 0x2b95, 1),
	|            new Range16 (0x2b97, 0x2bff, 1),
	|            new Range16 (0x2ce5, 0x2cea, 1),
	|            new Range16 (0x2e50, 0x2e51, 1),
	|            new Range16 (0x2e80, 0x2e99, 1),
	|            new Range16 (0x2e9b, 0x2ef3, 1),
	|            new Range16 (0x2f00, 0x2fd5, 1),
	|            new Range16 (0x2ff0, 0x2ffb, 1),
	|            new Range16 (0x3004, 0x3012, 14),
	|            new Range16 (0x3013, 0x3020, 13),
	|            new Range16 (0x3036, 0x3037, 1),
	|            new Range16 (0x303e, 0x303f, 1),
	|            new Range16 (0x3190, 0x3191, 1),
	|            new Range16 (0x3196, 0x319f, 1),
	|            new Range16 (0x31c0, 0x31e3, 1),
	|            new Range16 (0x3200, 0x321e, 1),
	|            new Range16 (0x322a, 0x3247, 1),
	|            new Range16 (0x3250, 0x3260, 16),
	|            new Range16 (0x3261, 0x327f, 1),
	|            new Range16 (0x328a, 0x32b0, 1),
	|            new Range16 (0x32c0, 0x33ff, 1),
	|            new Range16 (0x4dc0, 0x4dff, 1),
	|            new Range16 (0xa490, 0xa4c6, 1),
	|            new Range16 (0xa828, 0xa82b, 1),
	|            new Range16 (0xa836, 0xa837, 1),
	|            new Range16 (0xa839, 0xaa77, 574),
	|            new Range16 (0xaa78, 0xaa79, 1),
	|            new Range16 (0xfd40, 0xfd4f, 1),
	|            new Range16 (0xfdcf, 0xfdfd, 46),
	|            new Range16 (0xfdfe, 0xfdff, 1),
	|            new Range16 (0xffe4, 0xffe8, 4),
	|            new Range16 (0xffed, 0xffee, 1),
	|            new Range16 (0xfffc, 0xfffd, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10137, 0x1013f, 1),
	|            new Range32 (0x10179, 0x10189, 1),
	|            new Range32 (0x1018c, 0x1018e, 1),
	|            new Range32 (0x10190, 0x1019c, 1),
	|            new Range32 (0x101a0, 0x101d0, 48),
	|            new Range32 (0x101d1, 0x101fc, 1),
	|            new Range32 (0x10877, 0x10878, 1),
	|            new Range32 (0x10ac8, 0x1173f, 3191),
	|            new Range32 (0x11fd5, 0x11fdc, 1),
	|            new Range32 (0x11fe1, 0x11ff1, 1),
	|            new Range32 (0x16b3c, 0x16b3f, 1),
	|            new Range32 (0x16b45, 0x1bc9c, 20823),
	|            new Range32 (0x1cf50, 0x1cfc3, 1),
	|            new Range32 (0x1d000, 0x1d0f5, 1),
	|            new Range32 (0x1d100, 0x1d126, 1),
	|            new Range32 (0x1d129, 0x1d164, 1),
	|            new Range32 (0x1d16a, 0x1d16c, 1),
	|            new Range32 (0x1d183, 0x1d184, 1),
	|            new Range32 (0x1d18c, 0x1d1a9, 1),
	|            new Range32 (0x1d1ae, 0x1d1ea, 1),
	|            new Range32 (0x1d200, 0x1d241, 1),
	|            new Range32 (0x1d245, 0x1d300, 187),
	|            new Range32 (0x1d301, 0x1d356, 1),
	|            new Range32 (0x1d800, 0x1d9ff, 1),
	|            new Range32 (0x1da37, 0x1da3a, 1),
	|            new Range32 (0x1da6d, 0x1da74, 1),
	|            new Range32 (0x1da76, 0x1da83, 1),
	|            new Range32 (0x1da85, 0x1da86, 1),
	|            new Range32 (0x1e14f, 0x1ecac, 2909),
	|            new Range32 (0x1ed2e, 0x1f000, 722),
	|            new Range32 (0x1f001, 0x1f02b, 1),
	|            new Range32 (0x1f030, 0x1f093, 1),
	|            new Range32 (0x1f0a0, 0x1f0ae, 1),
	|            new Range32 (0x1f0b1, 0x1f0bf, 1),
	|            new Range32 (0x1f0c1, 0x1f0cf, 1),
	|            new Range32 (0x1f0d1, 0x1f0f5, 1),
	|            new Range32 (0x1f10d, 0x1f1ad, 1),
	|            new Range32 (0x1f1e6, 0x1f202, 1),
	|            new Range32 (0x1f210, 0x1f23b, 1),
	|            new Range32 (0x1f240, 0x1f248, 1),
	|            new Range32 (0x1f250, 0x1f251, 1),
	|            new Range32 (0x1f260, 0x1f265, 1),
	|            new Range32 (0x1f300, 0x1f3fa, 1),
	|            new Range32 (0x1f400, 0x1f6d7, 1),
	|            new Range32 (0x1f6dc, 0x1f6ec, 1),
	|            new Range32 (0x1f6f0, 0x1f6fc, 1),
	|            new Range32 (0x1f700, 0x1f776, 1),
	|            new Range32 (0x1f77b, 0x1f7d9, 1),
	|            new Range32 (0x1f7e0, 0x1f7eb, 1),
	|            new Range32 (0x1f7f0, 0x1f800, 16),
	|            new Range32 (0x1f801, 0x1f80b, 1),
	|            new Range32 (0x1f810, 0x1f847, 1),
	|            new Range32 (0x1f850, 0x1f859, 1),
	|            new Range32 (0x1f860, 0x1f887, 1),
	|            new Range32 (0x1f890, 0x1f8ad, 1),
	|            new Range32 (0x1f8b0, 0x1f8b1, 1),
	|            new Range32 (0x1f900, 0x1fa53, 1),
	|            new Range32 (0x1fa60, 0x1fa6d, 1),
	|            new Range32 (0x1fa70, 0x1fa7c, 1),
	|            new Range32 (0x1fa80, 0x1fa88, 1),
	|            new Range32 (0x1fa90, 0x1fabd, 1),
	|            new Range32 (0x1fabf, 0x1fac5, 1),
	|            new Range32 (0x1face, 0x1fadb, 1),
	|            new Range32 (0x1fae0, 0x1fae8, 1),
	|            new Range32 (0x1faf0, 0x1faf8, 1),
	|            new Range32 (0x1fb00, 0x1fb92, 1),
	|            new Range32 (0x1fb94, 0x1fbca, 1),
	|                },
	|                latinOffset: 2
	|            );
	|
	|            internal static RangeTable _Z = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0020, 0x00a0, 128),
	|            new Range16 (0x1680, 0x2000, 2432),
	|            new Range16 (0x2001, 0x200a, 1),
	|            new Range16 (0x2028, 0x2029, 1),
	|            new Range16 (0x202f, 0x205f, 48),
	|            new Range16 (0x3000, 0x3000, 1),
	|                },
	|                latinOffset: 1
	|            );
	|
	|            internal static RangeTable _Zl = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2028, 0x2028, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Zp = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2029, 0x2029, 1),
	|                }
	|            );
	|
	|            internal static RangeTable _Zs = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0020, 0x00a0, 128),
	|            new Range16 (0x1680, 0x2000, 2432),
	|            new Range16 (0x2001, 0x200a, 1),
	|            new Range16 (0x202f, 0x205f, 48),
	|            new Range16 (0x3000, 0x3000, 1),
	|                },
	|                latinOffset: 1
	|            );
	|
	|            /// <summary>Cc is the set of Unicode characters in category Cc.</summary>
	|            public static RangeTable Cc => _Cc;
	|            /// <summary>Cf is the set of Unicode characters in category Cf.</summary>
	|            public static RangeTable Cf => _Cf;
	|            /// <summary>Co is the set of Unicode characters in category Co.</summary>
	|            public static RangeTable Co => _Co;
	|            /// <summary>Cs is the set of Unicode characters in category Cs.</summary>
	|            public static RangeTable Cs => _Cs;
	|            /// <summary>Digit is the set of Unicode characters with the ""decimal digit"" property.</summary>
	|            public static RangeTable Digit => _Nd;
	|            /// <summary>Nd is the set of Unicode characters in category Nd.</summary>
	|            public static RangeTable Nd => _Nd;
	|            /// <summary>Letter/L is the set of Unicode letters, category L.</summary>
	|            public static RangeTable Letter => _L;
	|            /// <summary>Letter/L is the set of Unicode letters, category L.</summary>
	|            public static RangeTable L => _L;
	|            /// <summary>Lm is the set of Unicode characters in category Lm.</summary>
	|            public static RangeTable Lm => _Lm;
	|            /// <summary>Lo is the set of Unicode characters in category Lo.</summary>
	|            public static RangeTable Lo => _Lo;
	|            /// <summary>Lower is the set of Unicode lower case letters.</summary>;
	|            public static RangeTable Lower => _Ll;
	|            /// <summary>Ll is the set of Unicode characters in category Ll.</summary>
	|            public static RangeTable Ll => _Ll;
	|            /// <summary>Mark/M is the set of Unicode mark characters, category M.</summary>
	|            public static RangeTable Mark => _M;
	|            /// <summary>Mark/M is the set of Unicode mark characters, category M.</summary>;
	|            public static RangeTable M => _M;
	|            /// <summary>Mc is the set of Unicode characters in category Mc.</summary>
	|            public static RangeTable Mc => _Mc;
	|            /// <summary>Me is the set of Unicode characters in category Me.</summary>
	|            public static RangeTable Me => _Me;
	|            /// <summary>Mn is the set of Unicode characters in category Mn.</summary>
	|            public static RangeTable Mn => _Mn;
	|            /// <summary>Nl is the set of Unicode characters in category Nl.</summary>
	|            public static RangeTable Nl => _Nl;
	|            /// <summary>No is the set of Unicode characters in category No.</summary>
	|            public static RangeTable No => _No;
	|            /// <summary>Number/N is the set of Unicode number characters, category N.</summary>
	|            public static RangeTable Number => _N;
	|            /// <summary>Number/N is the set of Unicode number characters, category N.</summary>;
	|            public static RangeTable N => _N;
	|            /// <summary>Other/C is the set of Unicode control and special characters, category C.</summary>
	|            public static RangeTable Other => _C;
	|            /// <summary>Other/C is the set of Unicode control and special characters, category C.</summary>
	|            public static RangeTable C => _C;
	|            /// <summary>Pc is the set of Unicode characters in category Pc.</summary>
	|            public static RangeTable Pc => _Pc;
	|            /// <summary>Pd is the set of Unicode characters in category Pd.</summary>
	|            public static RangeTable Pd => _Pd;
	|            /// <summary>Pe is the set of Unicode characters in category Pe.</summary>
	|            public static RangeTable Pe => _Pe;
	|            /// <summary>Pf is the set of Unicode characters in category Pf.</summary>
	|            public static RangeTable Pf => _Pf;
	|            /// <summary>Pi is the set of Unicode characters in category Pi.</summary>
	|            public static RangeTable Pi => _Pi;
	|            /// <summary>Po is the set of Unicode characters in category Po.</summary>
	|            public static RangeTable Po => _Po;
	|            /// <summary>Ps is the set of Unicode characters in category Ps.</summary>
	|            public static RangeTable Ps => _Ps;
	|            /// <summary>Punct/P is the set of Unicode punctuation characters, category P.</summary>
	|            public static RangeTable Punct => _P;
	|            /// <summary>Punct/P is the set of Unicode punctuation characters, category P.</summary>;
	|            public static RangeTable P => _P;
	|            /// <summary>Sc is the set of Unicode characters in category Sc.</summary>
	|            public static RangeTable Sc => _Sc;
	|            /// <summary>Sk is the set of Unicode characters in category Sk.</summary>
	|            public static RangeTable Sk => _Sk;
	|            /// <summary>Sm is the set of Unicode characters in category Sm.</summary>
	|            public static RangeTable Sm => _Sm;
	|            /// <summary>So is the set of Unicode characters in category So.</summary>
	|            public static RangeTable So => _So;
	|            /// <summary>Space/Z is the set of Unicode space characters, category Z.</summary>
	|            public static RangeTable Space => _Z;
	|            /// <summary>Space/Z is the set of Unicode space characters, category Z.</summary>;
	|            public static RangeTable Z => _Z;
	|            /// <summary>Symbol/S is the set of Unicode symbol characters, category S.</summary>
	|            public static RangeTable Symbol => _S;
	|            /// <summary>Symbol/S is the set of Unicode symbol characters, category S.</summary>;
	|            public static RangeTable S => _S;
	|            /// <summary>Title is the set of Unicode title case letters.</summary>;
	|            public static RangeTable Title => _Lt;
	|            /// <summary>Lt is the set of Unicode characters in category Lt.</summary>
	|            public static RangeTable Lt => _Lt;
	|            /// <summary>Upper is the set of Unicode upper case letters.</summary>;
	|            public static RangeTable Upper => _Lu;
	|            /// <summary>Lu is the set of Unicode characters in category Lu.</summary>
	|            public static RangeTable Lu => _Lu;
	|            /// <summary>Zl is the set of Unicode characters in category Zl.</summary>
	|            public static RangeTable Zl => _Zl;
	|            /// <summary>Zp is the set of Unicode characters in category Zp.</summary>
	|            public static RangeTable Zp => _Zp;
	|            /// <summary>Zs is the set of Unicode characters in category Zs.</summary>
	|            public static RangeTable Zs => _Zs;
	|        }
	|
	|        // Generated by running
	|        //	maketables --scripts=all --url=https://www.unicode.org/Public/15.0.0/ucd/
	|        // DO NOT EDIT
	|
	|        /// <summary>Static class containing the Unicode script tables.</summary>
	|        /// <remarks><para>There are static properties that can be used to fetch a specific category, or you can use the <see cref=""T:NStack.Unicode.Script.Get""/> method in this class to retrieve the range table by its script name</para></remarks>
	|        public static class Script
	|        {
	|            /// <summary>Retrieves the specified RangeTable from the Unicode script name.</summary>
	|            /// <param name=""scriptName"">The unicode script name</param>
	|            public static RangeTable Get(string scriptName) => Scripts[scriptName];
	|            // Scripts is the set of Unicode script tables.
	|            static Dictionary<string, RangeTable> Scripts = new Dictionary<string, RangeTable>(){
	|            { ""Adlam"", Adlam },
	|            { ""Ahom"", Ahom },
	|            { ""Anatolian_Hieroglyphs"", Anatolian_Hieroglyphs },
	|            { ""Arabic"", Arabic },
	|            { ""Armenian"", Armenian },
	|            { ""Avestan"", Avestan },
	|            { ""Balinese"", Balinese },
	|            { ""Bamum"", Bamum },
	|            { ""Bassa_Vah"", Bassa_Vah },
	|            { ""Batak"", Batak },
	|            { ""Bengali"", Bengali },
	|            { ""Bhaiksuki"", Bhaiksuki },
	|            { ""Bopomofo"", Bopomofo },
	|            { ""Brahmi"", Brahmi },
	|            { ""Braille"", Braille },
	|            { ""Buginese"", Buginese },
	|            { ""Buhid"", Buhid },
	|            { ""Canadian_Aboriginal"", Canadian_Aboriginal },
	|            { ""Carian"", Carian },
	|            { ""Caucasian_Albanian"", Caucasian_Albanian },
	|            { ""Chakma"", Chakma },
	|            { ""Cham"", Cham },
	|            { ""Cherokee"", Cherokee },
	|            { ""Chorasmian"", Chorasmian },
	|            { ""Common"", Common },
	|            { ""Coptic"", Coptic },
	|            { ""Cuneiform"", Cuneiform },
	|            { ""Cypriot"", Cypriot },
	|            { ""Cypro_Minoan"", Cypro_Minoan },
	|            { ""Cyrillic"", Cyrillic },
	|            { ""Deseret"", Deseret },
	|            { ""Devanagari"", Devanagari },
	|            { ""Dives_Akuru"", Dives_Akuru },
	|            { ""Dogra"", Dogra },
	|            { ""Duployan"", Duployan },
	|            { ""Egyptian_Hieroglyphs"", Egyptian_Hieroglyphs },
	|            { ""Elbasan"", Elbasan },
	|            { ""Elymaic"", Elymaic },
	|            { ""Ethiopic"", Ethiopic },
	|            { ""Georgian"", Georgian },
	|            { ""Glagolitic"", Glagolitic },
	|            { ""Gothic"", Gothic },
	|            { ""Grantha"", Grantha },
	|            { ""Greek"", Greek },
	|            { ""Gujarati"", Gujarati },
	|            { ""Gunjala_Gondi"", Gunjala_Gondi },
	|            { ""Gurmukhi"", Gurmukhi },
	|            { ""Han"", Han },
	|            { ""Hangul"", Hangul },
	|            { ""Hanifi_Rohingya"", Hanifi_Rohingya },
	|            { ""Hanunoo"", Hanunoo },
	|            { ""Hatran"", Hatran },
	|            { ""Hebrew"", Hebrew },
	|            { ""Hiragana"", Hiragana },
	|            { ""Imperial_Aramaic"", Imperial_Aramaic },
	|            { ""Inherited"", Inherited },
	|            { ""Inscriptional_Pahlavi"", Inscriptional_Pahlavi },
	|            { ""Inscriptional_Parthian"", Inscriptional_Parthian },
	|            { ""Javanese"", Javanese },
	|            { ""Kaithi"", Kaithi },
	|            { ""Kannada"", Kannada },
	|            { ""Katakana"", Katakana },
	|            { ""Kawi"", Kawi },
	|            { ""Kayah_Li"", Kayah_Li },
	|            { ""Kharoshthi"", Kharoshthi },
	|            { ""Khitan_Small_Script"", Khitan_Small_Script },
	|            { ""Khmer"", Khmer },
	|            { ""Khojki"", Khojki },
	|            { ""Khudawadi"", Khudawadi },
	|            { ""Lao"", Lao },
	|            { ""Latin"", Latin },
	|            { ""Lepcha"", Lepcha },
	|            { ""Limbu"", Limbu },
	|            { ""Linear_A"", Linear_A },
	|            { ""Linear_B"", Linear_B },
	|            { ""Lisu"", Lisu },
	|            { ""Lycian"", Lycian },
	|            { ""Lydian"", Lydian },
	|            { ""Mahajani"", Mahajani },
	|            { ""Makasar"", Makasar },
	|            { ""Malayalam"", Malayalam },
	|            { ""Mandaic"", Mandaic },
	|            { ""Manichaean"", Manichaean },
	|            { ""Marchen"", Marchen },
	|            { ""Masaram_Gondi"", Masaram_Gondi },
	|            { ""Medefaidrin"", Medefaidrin },
	|            { ""Meetei_Mayek"", Meetei_Mayek },
	|            { ""Mende_Kikakui"", Mende_Kikakui },
	|            { ""Meroitic_Cursive"", Meroitic_Cursive },
	|            { ""Meroitic_Hieroglyphs"", Meroitic_Hieroglyphs },
	|            { ""Miao"", Miao },
	|            { ""Modi"", Modi },
	|            { ""Mongolian"", Mongolian },
	|            { ""Mro"", Mro },
	|            { ""Multani"", Multani },
	|            { ""Myanmar"", Myanmar },
	|            { ""Nabataean"", Nabataean },
	|            { ""Nag_Mundari"", Nag_Mundari },
	|            { ""Nandinagari"", Nandinagari },
	|            { ""New_Tai_Lue"", New_Tai_Lue },
	|            { ""Newa"", Newa },
	|            { ""Nko"", Nko },
	|            { ""Nushu"", Nushu },
	|            { ""Nyiakeng_Puachue_Hmong"", Nyiakeng_Puachue_Hmong },
	|            { ""Ogham"", Ogham },
	|            { ""Ol_Chiki"", Ol_Chiki },
	|            { ""Old_Hungarian"", Old_Hungarian },
	|            { ""Old_Italic"", Old_Italic },
	|            { ""Old_North_Arabian"", Old_North_Arabian },
	|            { ""Old_Permic"", Old_Permic },
	|            { ""Old_Persian"", Old_Persian },
	|            { ""Old_Sogdian"", Old_Sogdian },
	|            { ""Old_South_Arabian"", Old_South_Arabian },
	|            { ""Old_Turkic"", Old_Turkic },
	|            { ""Old_Uyghur"", Old_Uyghur },
	|            { ""Oriya"", Oriya },
	|            { ""Osage"", Osage },
	|            { ""Osmanya"", Osmanya },
	|            { ""Pahawh_Hmong"", Pahawh_Hmong },
	|            { ""Palmyrene"", Palmyrene },
	|            { ""Pau_Cin_Hau"", Pau_Cin_Hau },
	|            { ""Phags_Pa"", Phags_Pa },
	|            { ""Phoenician"", Phoenician },
	|            { ""Psalter_Pahlavi"", Psalter_Pahlavi },
	|            { ""Rejang"", Rejang },
	|            { ""Runic"", Runic },
	|            { ""Samaritan"", Samaritan },
	|            { ""Saurashtra"", Saurashtra },
	|            { ""Sharada"", Sharada },
	|            { ""Shavian"", Shavian },
	|            { ""Siddham"", Siddham },
	|            { ""SignWriting"", SignWriting },
	|            { ""Sinhala"", Sinhala },
	|            { ""Sogdian"", Sogdian },
	|            { ""Sora_Sompeng"", Sora_Sompeng },
	|            { ""Soyombo"", Soyombo },
	|            { ""Sundanese"", Sundanese },
	|            { ""Syloti_Nagri"", Syloti_Nagri },
	|            { ""Syriac"", Syriac },
	|            { ""Tagalog"", Tagalog },
	|            { ""Tagbanwa"", Tagbanwa },
	|            { ""Tai_Le"", Tai_Le },
	|            { ""Tai_Tham"", Tai_Tham },
	|            { ""Tai_Viet"", Tai_Viet },
	|            { ""Takri"", Takri },
	|            { ""Tamil"", Tamil },
	|            { ""Tangsa"", Tangsa },
	|            { ""Tangut"", Tangut },
	|            { ""Telugu"", Telugu },
	|            { ""Thaana"", Thaana },
	|            { ""Thai"", Thai },
	|            { ""Tibetan"", Tibetan },
	|            { ""Tifinagh"", Tifinagh },
	|            { ""Tirhuta"", Tirhuta },
	|            { ""Toto"", Toto },
	|            { ""Ugaritic"", Ugaritic },
	|            { ""Vai"", Vai },
	|            { ""Vithkuqi"", Vithkuqi },
	|            { ""Wancho"", Wancho },
	|            { ""Warang_Citi"", Warang_Citi },
	|            { ""Yezidi"", Yezidi },
	|            { ""Yi"", Yi },
	|            { ""Zanabazar_Square"", Zanabazar_Square },
	|        };
	|
	|            internal static RangeTable _Adlam = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e900, 0x1e94b, 1),
	|            new Range32 (0x1e950, 0x1e959, 1),
	|            new Range32 (0x1e95e, 0x1e95f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Ahom = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11700, 0x1171a, 1),
	|            new Range32 (0x1171d, 0x1172b, 1),
	|            new Range32 (0x11730, 0x11746, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Anatolian_Hieroglyphs = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x14400, 0x14646, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Arabic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0600, 0x0604, 1),
	|            new Range16 (0x0606, 0x060b, 1),
	|            new Range16 (0x060d, 0x061a, 1),
	|            new Range16 (0x061c, 0x061e, 1),
	|            new Range16 (0x0620, 0x063f, 1),
	|            new Range16 (0x0641, 0x064a, 1),
	|            new Range16 (0x0656, 0x066f, 1),
	|            new Range16 (0x0671, 0x06dc, 1),
	|            new Range16 (0x06de, 0x06ff, 1),
	|            new Range16 (0x0750, 0x077f, 1),
	|            new Range16 (0x0870, 0x088e, 1),
	|            new Range16 (0x0890, 0x0891, 1),
	|            new Range16 (0x0898, 0x08e1, 1),
	|            new Range16 (0x08e3, 0x08ff, 1),
	|            new Range16 (0xfb50, 0xfbc2, 1),
	|            new Range16 (0xfbd3, 0xfd3d, 1),
	|            new Range16 (0xfd40, 0xfd8f, 1),
	|            new Range16 (0xfd92, 0xfdc7, 1),
	|            new Range16 (0xfdcf, 0xfdcf, 1),
	|            new Range16 (0xfdf0, 0xfdff, 1),
	|            new Range16 (0xfe70, 0xfe74, 1),
	|            new Range16 (0xfe76, 0xfefc, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10e60, 0x10e7e, 1),
	|            new Range32 (0x10efd, 0x10eff, 1),
	|            new Range32 (0x1ee00, 0x1ee03, 1),
	|            new Range32 (0x1ee05, 0x1ee1f, 1),
	|            new Range32 (0x1ee21, 0x1ee22, 1),
	|            new Range32 (0x1ee24, 0x1ee24, 1),
	|            new Range32 (0x1ee27, 0x1ee27, 1),
	|            new Range32 (0x1ee29, 0x1ee32, 1),
	|            new Range32 (0x1ee34, 0x1ee37, 1),
	|            new Range32 (0x1ee39, 0x1ee39, 1),
	|            new Range32 (0x1ee3b, 0x1ee3b, 1),
	|            new Range32 (0x1ee42, 0x1ee42, 1),
	|            new Range32 (0x1ee47, 0x1ee47, 1),
	|            new Range32 (0x1ee49, 0x1ee49, 1),
	|            new Range32 (0x1ee4b, 0x1ee4b, 1),
	|            new Range32 (0x1ee4d, 0x1ee4f, 1),
	|            new Range32 (0x1ee51, 0x1ee52, 1),
	|            new Range32 (0x1ee54, 0x1ee54, 1),
	|            new Range32 (0x1ee57, 0x1ee57, 1),
	|            new Range32 (0x1ee59, 0x1ee59, 1),
	|            new Range32 (0x1ee5b, 0x1ee5b, 1),
	|            new Range32 (0x1ee5d, 0x1ee5d, 1),
	|            new Range32 (0x1ee5f, 0x1ee5f, 1),
	|            new Range32 (0x1ee61, 0x1ee62, 1),
	|            new Range32 (0x1ee64, 0x1ee64, 1),
	|            new Range32 (0x1ee67, 0x1ee6a, 1),
	|            new Range32 (0x1ee6c, 0x1ee72, 1),
	|            new Range32 (0x1ee74, 0x1ee77, 1),
	|            new Range32 (0x1ee79, 0x1ee7c, 1),
	|            new Range32 (0x1ee7e, 0x1ee7e, 1),
	|            new Range32 (0x1ee80, 0x1ee89, 1),
	|            new Range32 (0x1ee8b, 0x1ee9b, 1),
	|            new Range32 (0x1eea1, 0x1eea3, 1),
	|            new Range32 (0x1eea5, 0x1eea9, 1),
	|            new Range32 (0x1eeab, 0x1eebb, 1),
	|            new Range32 (0x1eef0, 0x1eef1, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Armenian = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0531, 0x0556, 1),
	|            new Range16 (0x0559, 0x058a, 1),
	|            new Range16 (0x058d, 0x058f, 1),
	|            new Range16 (0xfb13, 0xfb17, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Avestan = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10b00, 0x10b35, 1),
	|            new Range32 (0x10b39, 0x10b3f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Balinese = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1b00, 0x1b4c, 1),
	|            new Range16 (0x1b50, 0x1b7e, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Bamum = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa6a0, 0xa6f7, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16800, 0x16a38, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Bassa_Vah = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16ad0, 0x16aed, 1),
	|            new Range32 (0x16af0, 0x16af5, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Batak = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1bc0, 0x1bf3, 1),
	|            new Range16 (0x1bfc, 0x1bff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Bengali = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0980, 0x0983, 1),
	|            new Range16 (0x0985, 0x098c, 1),
	|            new Range16 (0x098f, 0x0990, 1),
	|            new Range16 (0x0993, 0x09a8, 1),
	|            new Range16 (0x09aa, 0x09b0, 1),
	|            new Range16 (0x09b2, 0x09b2, 1),
	|            new Range16 (0x09b6, 0x09b9, 1),
	|            new Range16 (0x09bc, 0x09c4, 1),
	|            new Range16 (0x09c7, 0x09c8, 1),
	|            new Range16 (0x09cb, 0x09ce, 1),
	|            new Range16 (0x09d7, 0x09d7, 1),
	|            new Range16 (0x09dc, 0x09dd, 1),
	|            new Range16 (0x09df, 0x09e3, 1),
	|            new Range16 (0x09e6, 0x09fe, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Bhaiksuki = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11c00, 0x11c08, 1),
	|            new Range32 (0x11c0a, 0x11c36, 1),
	|            new Range32 (0x11c38, 0x11c45, 1),
	|            new Range32 (0x11c50, 0x11c6c, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Bopomofo = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x02ea, 0x02eb, 1),
	|            new Range16 (0x3105, 0x312f, 1),
	|            new Range16 (0x31a0, 0x31bf, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Brahmi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11000, 0x1104d, 1),
	|            new Range32 (0x11052, 0x11075, 1),
	|            new Range32 (0x1107f, 0x1107f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Braille = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2800, 0x28ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Buginese = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1a00, 0x1a1b, 1),
	|            new Range16 (0x1a1e, 0x1a1f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Buhid = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1740, 0x1753, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Canadian_Aboriginal = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1400, 0x167f, 1),
	|            new Range16 (0x18b0, 0x18f5, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11ab0, 0x11abf, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Carian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x102a0, 0x102d0, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Caucasian_Albanian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10530, 0x10563, 1),
	|            new Range32 (0x1056f, 0x1056f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Chakma = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11100, 0x11134, 1),
	|            new Range32 (0x11136, 0x11147, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Cham = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xaa00, 0xaa36, 1),
	|            new Range16 (0xaa40, 0xaa4d, 1),
	|            new Range16 (0xaa50, 0xaa59, 1),
	|            new Range16 (0xaa5c, 0xaa5f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Cherokee = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x13a0, 0x13f5, 1),
	|            new Range16 (0x13f8, 0x13fd, 1),
	|            new Range16 (0xab70, 0xabbf, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Chorasmian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10fb0, 0x10fcb, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Common = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0000, 0x0040, 1),
	|            new Range16 (0x005b, 0x0060, 1),
	|            new Range16 (0x007b, 0x00a9, 1),
	|            new Range16 (0x00ab, 0x00b9, 1),
	|            new Range16 (0x00bb, 0x00bf, 1),
	|            new Range16 (0x00d7, 0x00d7, 1),
	|            new Range16 (0x00f7, 0x00f7, 1),
	|            new Range16 (0x02b9, 0x02df, 1),
	|            new Range16 (0x02e5, 0x02e9, 1),
	|            new Range16 (0x02ec, 0x02ff, 1),
	|            new Range16 (0x0374, 0x0374, 1),
	|            new Range16 (0x037e, 0x037e, 1),
	|            new Range16 (0x0385, 0x0385, 1),
	|            new Range16 (0x0387, 0x0387, 1),
	|            new Range16 (0x0605, 0x0605, 1),
	|            new Range16 (0x060c, 0x060c, 1),
	|            new Range16 (0x061b, 0x061b, 1),
	|            new Range16 (0x061f, 0x061f, 1),
	|            new Range16 (0x0640, 0x0640, 1),
	|            new Range16 (0x06dd, 0x06dd, 1),
	|            new Range16 (0x08e2, 0x08e2, 1),
	|            new Range16 (0x0964, 0x0965, 1),
	|            new Range16 (0x0e3f, 0x0e3f, 1),
	|            new Range16 (0x0fd5, 0x0fd8, 1),
	|            new Range16 (0x10fb, 0x10fb, 1),
	|            new Range16 (0x16eb, 0x16ed, 1),
	|            new Range16 (0x1735, 0x1736, 1),
	|            new Range16 (0x1802, 0x1803, 1),
	|            new Range16 (0x1805, 0x1805, 1),
	|            new Range16 (0x1cd3, 0x1cd3, 1),
	|            new Range16 (0x1ce1, 0x1ce1, 1),
	|            new Range16 (0x1ce9, 0x1cec, 1),
	|            new Range16 (0x1cee, 0x1cf3, 1),
	|            new Range16 (0x1cf5, 0x1cf7, 1),
	|            new Range16 (0x1cfa, 0x1cfa, 1),
	|            new Range16 (0x2000, 0x200b, 1),
	|            new Range16 (0x200e, 0x2064, 1),
	|            new Range16 (0x2066, 0x2070, 1),
	|            new Range16 (0x2074, 0x207e, 1),
	|            new Range16 (0x2080, 0x208e, 1),
	|            new Range16 (0x20a0, 0x20c0, 1),
	|            new Range16 (0x2100, 0x2125, 1),
	|            new Range16 (0x2127, 0x2129, 1),
	|            new Range16 (0x212c, 0x2131, 1),
	|            new Range16 (0x2133, 0x214d, 1),
	|            new Range16 (0x214f, 0x215f, 1),
	|            new Range16 (0x2189, 0x218b, 1),
	|            new Range16 (0x2190, 0x2426, 1),
	|            new Range16 (0x2440, 0x244a, 1),
	|            new Range16 (0x2460, 0x27ff, 1),
	|            new Range16 (0x2900, 0x2b73, 1),
	|            new Range16 (0x2b76, 0x2b95, 1),
	|            new Range16 (0x2b97, 0x2bff, 1),
	|            new Range16 (0x2e00, 0x2e5d, 1),
	|            new Range16 (0x2ff0, 0x2ffb, 1),
	|            new Range16 (0x3000, 0x3004, 1),
	|            new Range16 (0x3006, 0x3006, 1),
	|            new Range16 (0x3008, 0x3020, 1),
	|            new Range16 (0x3030, 0x3037, 1),
	|            new Range16 (0x303c, 0x303f, 1),
	|            new Range16 (0x309b, 0x309c, 1),
	|            new Range16 (0x30a0, 0x30a0, 1),
	|            new Range16 (0x30fb, 0x30fc, 1),
	|            new Range16 (0x3190, 0x319f, 1),
	|            new Range16 (0x31c0, 0x31e3, 1),
	|            new Range16 (0x3220, 0x325f, 1),
	|            new Range16 (0x327f, 0x32cf, 1),
	|            new Range16 (0x32ff, 0x32ff, 1),
	|            new Range16 (0x3358, 0x33ff, 1),
	|            new Range16 (0x4dc0, 0x4dff, 1),
	|            new Range16 (0xa700, 0xa721, 1),
	|            new Range16 (0xa788, 0xa78a, 1),
	|            new Range16 (0xa830, 0xa839, 1),
	|            new Range16 (0xa92e, 0xa92e, 1),
	|            new Range16 (0xa9cf, 0xa9cf, 1),
	|            new Range16 (0xab5b, 0xab5b, 1),
	|            new Range16 (0xab6a, 0xab6b, 1),
	|            new Range16 (0xfd3e, 0xfd3f, 1),
	|            new Range16 (0xfe10, 0xfe19, 1),
	|            new Range16 (0xfe30, 0xfe52, 1),
	|            new Range16 (0xfe54, 0xfe66, 1),
	|            new Range16 (0xfe68, 0xfe6b, 1),
	|            new Range16 (0xfeff, 0xfeff, 1),
	|            new Range16 (0xff01, 0xff20, 1),
	|            new Range16 (0xff3b, 0xff40, 1),
	|            new Range16 (0xff5b, 0xff65, 1),
	|            new Range16 (0xff70, 0xff70, 1),
	|            new Range16 (0xff9e, 0xff9f, 1),
	|            new Range16 (0xffe0, 0xffe6, 1),
	|            new Range16 (0xffe8, 0xffee, 1),
	|            new Range16 (0xfff9, 0xfffd, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10100, 0x10102, 1),
	|            new Range32 (0x10107, 0x10133, 1),
	|            new Range32 (0x10137, 0x1013f, 1),
	|            new Range32 (0x10190, 0x1019c, 1),
	|            new Range32 (0x101d0, 0x101fc, 1),
	|            new Range32 (0x102e1, 0x102fb, 1),
	|            new Range32 (0x1bca0, 0x1bca3, 1),
	|            new Range32 (0x1cf50, 0x1cfc3, 1),
	|            new Range32 (0x1d000, 0x1d0f5, 1),
	|            new Range32 (0x1d100, 0x1d126, 1),
	|            new Range32 (0x1d129, 0x1d166, 1),
	|            new Range32 (0x1d16a, 0x1d17a, 1),
	|            new Range32 (0x1d183, 0x1d184, 1),
	|            new Range32 (0x1d18c, 0x1d1a9, 1),
	|            new Range32 (0x1d1ae, 0x1d1ea, 1),
	|            new Range32 (0x1d2c0, 0x1d2d3, 1),
	|            new Range32 (0x1d2e0, 0x1d2f3, 1),
	|            new Range32 (0x1d300, 0x1d356, 1),
	|            new Range32 (0x1d360, 0x1d378, 1),
	|            new Range32 (0x1d400, 0x1d454, 1),
	|            new Range32 (0x1d456, 0x1d49c, 1),
	|            new Range32 (0x1d49e, 0x1d49f, 1),
	|            new Range32 (0x1d4a2, 0x1d4a2, 1),
	|            new Range32 (0x1d4a5, 0x1d4a6, 1),
	|            new Range32 (0x1d4a9, 0x1d4ac, 1),
	|            new Range32 (0x1d4ae, 0x1d4b9, 1),
	|            new Range32 (0x1d4bb, 0x1d4bb, 1),
	|            new Range32 (0x1d4bd, 0x1d4c3, 1),
	|            new Range32 (0x1d4c5, 0x1d505, 1),
	|            new Range32 (0x1d507, 0x1d50a, 1),
	|            new Range32 (0x1d50d, 0x1d514, 1),
	|            new Range32 (0x1d516, 0x1d51c, 1),
	|            new Range32 (0x1d51e, 0x1d539, 1),
	|            new Range32 (0x1d53b, 0x1d53e, 1),
	|            new Range32 (0x1d540, 0x1d544, 1),
	|            new Range32 (0x1d546, 0x1d546, 1),
	|            new Range32 (0x1d54a, 0x1d550, 1),
	|            new Range32 (0x1d552, 0x1d6a5, 1),
	|            new Range32 (0x1d6a8, 0x1d7cb, 1),
	|            new Range32 (0x1d7ce, 0x1d7ff, 1),
	|            new Range32 (0x1ec71, 0x1ecb4, 1),
	|            new Range32 (0x1ed01, 0x1ed3d, 1),
	|            new Range32 (0x1f000, 0x1f02b, 1),
	|            new Range32 (0x1f030, 0x1f093, 1),
	|            new Range32 (0x1f0a0, 0x1f0ae, 1),
	|            new Range32 (0x1f0b1, 0x1f0bf, 1),
	|            new Range32 (0x1f0c1, 0x1f0cf, 1),
	|            new Range32 (0x1f0d1, 0x1f0f5, 1),
	|            new Range32 (0x1f100, 0x1f1ad, 1),
	|            new Range32 (0x1f1e6, 0x1f1ff, 1),
	|            new Range32 (0x1f201, 0x1f202, 1),
	|            new Range32 (0x1f210, 0x1f23b, 1),
	|            new Range32 (0x1f240, 0x1f248, 1),
	|            new Range32 (0x1f250, 0x1f251, 1),
	|            new Range32 (0x1f260, 0x1f265, 1),
	|            new Range32 (0x1f300, 0x1f6d7, 1),
	|            new Range32 (0x1f6dc, 0x1f6ec, 1),
	|            new Range32 (0x1f6f0, 0x1f6fc, 1),
	|            new Range32 (0x1f700, 0x1f776, 1),
	|            new Range32 (0x1f77b, 0x1f7d9, 1),
	|            new Range32 (0x1f7e0, 0x1f7eb, 1),
	|            new Range32 (0x1f7f0, 0x1f7f0, 1),
	|            new Range32 (0x1f800, 0x1f80b, 1),
	|            new Range32 (0x1f810, 0x1f847, 1),
	|            new Range32 (0x1f850, 0x1f859, 1),
	|            new Range32 (0x1f860, 0x1f887, 1),
	|            new Range32 (0x1f890, 0x1f8ad, 1),
	|            new Range32 (0x1f8b0, 0x1f8b1, 1),
	|            new Range32 (0x1f900, 0x1fa53, 1),
	|            new Range32 (0x1fa60, 0x1fa6d, 1),
	|            new Range32 (0x1fa70, 0x1fa7c, 1),
	|            new Range32 (0x1fa80, 0x1fa88, 1),
	|            new Range32 (0x1fa90, 0x1fabd, 1),
	|            new Range32 (0x1fabf, 0x1fac5, 1),
	|            new Range32 (0x1face, 0x1fadb, 1),
	|            new Range32 (0x1fae0, 0x1fae8, 1),
	|            new Range32 (0x1faf0, 0x1faf8, 1),
	|            new Range32 (0x1fb00, 0x1fb92, 1),
	|            new Range32 (0x1fb94, 0x1fbca, 1),
	|            new Range32 (0x1fbf0, 0x1fbf9, 1),
	|            new Range32 (0xe0001, 0xe0001, 1),
	|            new Range32 (0xe0020, 0xe007f, 1),
	|                },
	|                latinOffset: 7
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Coptic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x03e2, 0x03ef, 1),
	|            new Range16 (0x2c80, 0x2cf3, 1),
	|            new Range16 (0x2cf9, 0x2cff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Cuneiform = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x12000, 0x12399, 1),
	|            new Range32 (0x12400, 0x1246e, 1),
	|            new Range32 (0x12470, 0x12474, 1),
	|            new Range32 (0x12480, 0x12543, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Cypriot = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10800, 0x10805, 1),
	|            new Range32 (0x10808, 0x10808, 1),
	|            new Range32 (0x1080a, 0x10835, 1),
	|            new Range32 (0x10837, 0x10838, 1),
	|            new Range32 (0x1083c, 0x1083c, 1),
	|            new Range32 (0x1083f, 0x1083f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Cypro_Minoan = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x12f90, 0x12ff2, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Cyrillic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0400, 0x0484, 1),
	|            new Range16 (0x0487, 0x052f, 1),
	|            new Range16 (0x1c80, 0x1c88, 1),
	|            new Range16 (0x1d2b, 0x1d2b, 1),
	|            new Range16 (0x1d78, 0x1d78, 1),
	|            new Range16 (0x2de0, 0x2dff, 1),
	|            new Range16 (0xa640, 0xa69f, 1),
	|            new Range16 (0xfe2e, 0xfe2f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e030, 0x1e06d, 1),
	|            new Range32 (0x1e08f, 0x1e08f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Deseret = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10400, 0x1044f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Devanagari = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0900, 0x0950, 1),
	|            new Range16 (0x0955, 0x0963, 1),
	|            new Range16 (0x0966, 0x097f, 1),
	|            new Range16 (0xa8e0, 0xa8ff, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11b00, 0x11b09, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Dives_Akuru = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11900, 0x11906, 1),
	|            new Range32 (0x11909, 0x11909, 1),
	|            new Range32 (0x1190c, 0x11913, 1),
	|            new Range32 (0x11915, 0x11916, 1),
	|            new Range32 (0x11918, 0x11935, 1),
	|            new Range32 (0x11937, 0x11938, 1),
	|            new Range32 (0x1193b, 0x11946, 1),
	|            new Range32 (0x11950, 0x11959, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Dogra = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11800, 0x1183b, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Duployan = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1bc00, 0x1bc6a, 1),
	|            new Range32 (0x1bc70, 0x1bc7c, 1),
	|            new Range32 (0x1bc80, 0x1bc88, 1),
	|            new Range32 (0x1bc90, 0x1bc99, 1),
	|            new Range32 (0x1bc9c, 0x1bc9f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Egyptian_Hieroglyphs = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x13000, 0x13455, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Elbasan = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10500, 0x10527, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Elymaic = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10fe0, 0x10ff6, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Ethiopic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1200, 0x1248, 1),
	|            new Range16 (0x124a, 0x124d, 1),
	|            new Range16 (0x1250, 0x1256, 1),
	|            new Range16 (0x1258, 0x1258, 1),
	|            new Range16 (0x125a, 0x125d, 1),
	|            new Range16 (0x1260, 0x1288, 1),
	|            new Range16 (0x128a, 0x128d, 1),
	|            new Range16 (0x1290, 0x12b0, 1),
	|            new Range16 (0x12b2, 0x12b5, 1),
	|            new Range16 (0x12b8, 0x12be, 1),
	|            new Range16 (0x12c0, 0x12c0, 1),
	|            new Range16 (0x12c2, 0x12c5, 1),
	|            new Range16 (0x12c8, 0x12d6, 1),
	|            new Range16 (0x12d8, 0x1310, 1),
	|            new Range16 (0x1312, 0x1315, 1),
	|            new Range16 (0x1318, 0x135a, 1),
	|            new Range16 (0x135d, 0x137c, 1),
	|            new Range16 (0x1380, 0x1399, 1),
	|            new Range16 (0x2d80, 0x2d96, 1),
	|            new Range16 (0x2da0, 0x2da6, 1),
	|            new Range16 (0x2da8, 0x2dae, 1),
	|            new Range16 (0x2db0, 0x2db6, 1),
	|            new Range16 (0x2db8, 0x2dbe, 1),
	|            new Range16 (0x2dc0, 0x2dc6, 1),
	|            new Range16 (0x2dc8, 0x2dce, 1),
	|            new Range16 (0x2dd0, 0x2dd6, 1),
	|            new Range16 (0x2dd8, 0x2dde, 1),
	|            new Range16 (0xab01, 0xab06, 1),
	|            new Range16 (0xab09, 0xab0e, 1),
	|            new Range16 (0xab11, 0xab16, 1),
	|            new Range16 (0xab20, 0xab26, 1),
	|            new Range16 (0xab28, 0xab2e, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e7e0, 0x1e7e6, 1),
	|            new Range32 (0x1e7e8, 0x1e7eb, 1),
	|            new Range32 (0x1e7ed, 0x1e7ee, 1),
	|            new Range32 (0x1e7f0, 0x1e7fe, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Georgian = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x10a0, 0x10c5, 1),
	|            new Range16 (0x10c7, 0x10c7, 1),
	|            new Range16 (0x10cd, 0x10cd, 1),
	|            new Range16 (0x10d0, 0x10fa, 1),
	|            new Range16 (0x10fc, 0x10ff, 1),
	|            new Range16 (0x1c90, 0x1cba, 1),
	|            new Range16 (0x1cbd, 0x1cbf, 1),
	|            new Range16 (0x2d00, 0x2d25, 1),
	|            new Range16 (0x2d27, 0x2d27, 1),
	|            new Range16 (0x2d2d, 0x2d2d, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Glagolitic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2c00, 0x2c5f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e000, 0x1e006, 1),
	|            new Range32 (0x1e008, 0x1e018, 1),
	|            new Range32 (0x1e01b, 0x1e021, 1),
	|            new Range32 (0x1e023, 0x1e024, 1),
	|            new Range32 (0x1e026, 0x1e02a, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Gothic = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10330, 0x1034a, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Grantha = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11300, 0x11303, 1),
	|            new Range32 (0x11305, 0x1130c, 1),
	|            new Range32 (0x1130f, 0x11310, 1),
	|            new Range32 (0x11313, 0x11328, 1),
	|            new Range32 (0x1132a, 0x11330, 1),
	|            new Range32 (0x11332, 0x11333, 1),
	|            new Range32 (0x11335, 0x11339, 1),
	|            new Range32 (0x1133c, 0x11344, 1),
	|            new Range32 (0x11347, 0x11348, 1),
	|            new Range32 (0x1134b, 0x1134d, 1),
	|            new Range32 (0x11350, 0x11350, 1),
	|            new Range32 (0x11357, 0x11357, 1),
	|            new Range32 (0x1135d, 0x11363, 1),
	|            new Range32 (0x11366, 0x1136c, 1),
	|            new Range32 (0x11370, 0x11374, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Greek = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0370, 0x0373, 1),
	|            new Range16 (0x0375, 0x0377, 1),
	|            new Range16 (0x037a, 0x037d, 1),
	|            new Range16 (0x037f, 0x037f, 1),
	|            new Range16 (0x0384, 0x0384, 1),
	|            new Range16 (0x0386, 0x0386, 1),
	|            new Range16 (0x0388, 0x038a, 1),
	|            new Range16 (0x038c, 0x038c, 1),
	|            new Range16 (0x038e, 0x03a1, 1),
	|            new Range16 (0x03a3, 0x03e1, 1),
	|            new Range16 (0x03f0, 0x03ff, 1),
	|            new Range16 (0x1d26, 0x1d2a, 1),
	|            new Range16 (0x1d5d, 0x1d61, 1),
	|            new Range16 (0x1d66, 0x1d6a, 1),
	|            new Range16 (0x1dbf, 0x1dbf, 1),
	|            new Range16 (0x1f00, 0x1f15, 1),
	|            new Range16 (0x1f18, 0x1f1d, 1),
	|            new Range16 (0x1f20, 0x1f45, 1),
	|            new Range16 (0x1f48, 0x1f4d, 1),
	|            new Range16 (0x1f50, 0x1f57, 1),
	|            new Range16 (0x1f59, 0x1f59, 1),
	|            new Range16 (0x1f5b, 0x1f5b, 1),
	|            new Range16 (0x1f5d, 0x1f5d, 1),
	|            new Range16 (0x1f5f, 0x1f7d, 1),
	|            new Range16 (0x1f80, 0x1fb4, 1),
	|            new Range16 (0x1fb6, 0x1fc4, 1),
	|            new Range16 (0x1fc6, 0x1fd3, 1),
	|            new Range16 (0x1fd6, 0x1fdb, 1),
	|            new Range16 (0x1fdd, 0x1fef, 1),
	|            new Range16 (0x1ff2, 0x1ff4, 1),
	|            new Range16 (0x1ff6, 0x1ffe, 1),
	|            new Range16 (0x2126, 0x2126, 1),
	|            new Range16 (0xab65, 0xab65, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10140, 0x1018e, 1),
	|            new Range32 (0x101a0, 0x101a0, 1),
	|            new Range32 (0x1d200, 0x1d245, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Gujarati = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0a81, 0x0a83, 1),
	|            new Range16 (0x0a85, 0x0a8d, 1),
	|            new Range16 (0x0a8f, 0x0a91, 1),
	|            new Range16 (0x0a93, 0x0aa8, 1),
	|            new Range16 (0x0aaa, 0x0ab0, 1),
	|            new Range16 (0x0ab2, 0x0ab3, 1),
	|            new Range16 (0x0ab5, 0x0ab9, 1),
	|            new Range16 (0x0abc, 0x0ac5, 1),
	|            new Range16 (0x0ac7, 0x0ac9, 1),
	|            new Range16 (0x0acb, 0x0acd, 1),
	|            new Range16 (0x0ad0, 0x0ad0, 1),
	|            new Range16 (0x0ae0, 0x0ae3, 1),
	|            new Range16 (0x0ae6, 0x0af1, 1),
	|            new Range16 (0x0af9, 0x0aff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Gunjala_Gondi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11d60, 0x11d65, 1),
	|            new Range32 (0x11d67, 0x11d68, 1),
	|            new Range32 (0x11d6a, 0x11d8e, 1),
	|            new Range32 (0x11d90, 0x11d91, 1),
	|            new Range32 (0x11d93, 0x11d98, 1),
	|            new Range32 (0x11da0, 0x11da9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Gurmukhi = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0a01, 0x0a03, 1),
	|            new Range16 (0x0a05, 0x0a0a, 1),
	|            new Range16 (0x0a0f, 0x0a10, 1),
	|            new Range16 (0x0a13, 0x0a28, 1),
	|            new Range16 (0x0a2a, 0x0a30, 1),
	|            new Range16 (0x0a32, 0x0a33, 1),
	|            new Range16 (0x0a35, 0x0a36, 1),
	|            new Range16 (0x0a38, 0x0a39, 1),
	|            new Range16 (0x0a3c, 0x0a3c, 1),
	|            new Range16 (0x0a3e, 0x0a42, 1),
	|            new Range16 (0x0a47, 0x0a48, 1),
	|            new Range16 (0x0a4b, 0x0a4d, 1),
	|            new Range16 (0x0a51, 0x0a51, 1),
	|            new Range16 (0x0a59, 0x0a5c, 1),
	|            new Range16 (0x0a5e, 0x0a5e, 1),
	|            new Range16 (0x0a66, 0x0a76, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Han = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2e80, 0x2e99, 1),
	|            new Range16 (0x2e9b, 0x2ef3, 1),
	|            new Range16 (0x2f00, 0x2fd5, 1),
	|            new Range16 (0x3005, 0x3005, 1),
	|            new Range16 (0x3007, 0x3007, 1),
	|            new Range16 (0x3021, 0x3029, 1),
	|            new Range16 (0x3038, 0x303b, 1),
	|            new Range16 (0x3400, 0x4dbf, 1),
	|            new Range16 (0x4e00, 0x9fff, 1),
	|            new Range16 (0xf900, 0xfa6d, 1),
	|            new Range16 (0xfa70, 0xfad9, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16fe2, 0x16fe3, 1),
	|            new Range32 (0x16ff0, 0x16ff1, 1),
	|            new Range32 (0x20000, 0x2a6df, 1),
	|            new Range32 (0x2a700, 0x2b739, 1),
	|            new Range32 (0x2b740, 0x2b81d, 1),
	|            new Range32 (0x2b820, 0x2cea1, 1),
	|            new Range32 (0x2ceb0, 0x2ebe0, 1),
	|            new Range32 (0x2f800, 0x2fa1d, 1),
	|            new Range32 (0x30000, 0x3134a, 1),
	|            new Range32 (0x31350, 0x323af, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hangul = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1100, 0x11ff, 1),
	|            new Range16 (0x302e, 0x302f, 1),
	|            new Range16 (0x3131, 0x318e, 1),
	|            new Range16 (0x3200, 0x321e, 1),
	|            new Range16 (0x3260, 0x327e, 1),
	|            new Range16 (0xa960, 0xa97c, 1),
	|            new Range16 (0xac00, 0xd7a3, 1),
	|            new Range16 (0xd7b0, 0xd7c6, 1),
	|            new Range16 (0xd7cb, 0xd7fb, 1),
	|            new Range16 (0xffa0, 0xffbe, 1),
	|            new Range16 (0xffc2, 0xffc7, 1),
	|            new Range16 (0xffca, 0xffcf, 1),
	|            new Range16 (0xffd2, 0xffd7, 1),
	|            new Range16 (0xffda, 0xffdc, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hanifi_Rohingya = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10d00, 0x10d27, 1),
	|            new Range32 (0x10d30, 0x10d39, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hanunoo = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1720, 0x1734, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hatran = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x108e0, 0x108f2, 1),
	|            new Range32 (0x108f4, 0x108f5, 1),
	|            new Range32 (0x108fb, 0x108ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hebrew = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0591, 0x05c7, 1),
	|            new Range16 (0x05d0, 0x05ea, 1),
	|            new Range16 (0x05ef, 0x05f4, 1),
	|            new Range16 (0xfb1d, 0xfb36, 1),
	|            new Range16 (0xfb38, 0xfb3c, 1),
	|            new Range16 (0xfb3e, 0xfb3e, 1),
	|            new Range16 (0xfb40, 0xfb41, 1),
	|            new Range16 (0xfb43, 0xfb44, 1),
	|            new Range16 (0xfb46, 0xfb4f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hiragana = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x3041, 0x3096, 1),
	|            new Range16 (0x309d, 0x309f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1b001, 0x1b11f, 1),
	|            new Range32 (0x1b132, 0x1b132, 1),
	|            new Range32 (0x1b150, 0x1b152, 1),
	|            new Range32 (0x1f200, 0x1f200, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Imperial_Aramaic = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10840, 0x10855, 1),
	|            new Range32 (0x10857, 0x1085f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Inherited = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0300, 0x036f, 1),
	|            new Range16 (0x0485, 0x0486, 1),
	|            new Range16 (0x064b, 0x0655, 1),
	|            new Range16 (0x0670, 0x0670, 1),
	|            new Range16 (0x0951, 0x0954, 1),
	|            new Range16 (0x1ab0, 0x1ace, 1),
	|            new Range16 (0x1cd0, 0x1cd2, 1),
	|            new Range16 (0x1cd4, 0x1ce0, 1),
	|            new Range16 (0x1ce2, 0x1ce8, 1),
	|            new Range16 (0x1ced, 0x1ced, 1),
	|            new Range16 (0x1cf4, 0x1cf4, 1),
	|            new Range16 (0x1cf8, 0x1cf9, 1),
	|            new Range16 (0x1dc0, 0x1dff, 1),
	|            new Range16 (0x200c, 0x200d, 1),
	|            new Range16 (0x20d0, 0x20f0, 1),
	|            new Range16 (0x302a, 0x302d, 1),
	|            new Range16 (0x3099, 0x309a, 1),
	|            new Range16 (0xfe00, 0xfe0f, 1),
	|            new Range16 (0xfe20, 0xfe2d, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x101fd, 0x101fd, 1),
	|            new Range32 (0x102e0, 0x102e0, 1),
	|            new Range32 (0x1133b, 0x1133b, 1),
	|            new Range32 (0x1cf00, 0x1cf2d, 1),
	|            new Range32 (0x1cf30, 0x1cf46, 1),
	|            new Range32 (0x1d167, 0x1d169, 1),
	|            new Range32 (0x1d17b, 0x1d182, 1),
	|            new Range32 (0x1d185, 0x1d18b, 1),
	|            new Range32 (0x1d1aa, 0x1d1ad, 1),
	|            new Range32 (0xe0100, 0xe01ef, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Inscriptional_Pahlavi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10b60, 0x10b72, 1),
	|            new Range32 (0x10b78, 0x10b7f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Inscriptional_Parthian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10b40, 0x10b55, 1),
	|            new Range32 (0x10b58, 0x10b5f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Javanese = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa980, 0xa9cd, 1),
	|            new Range16 (0xa9d0, 0xa9d9, 1),
	|            new Range16 (0xa9de, 0xa9df, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Kaithi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11080, 0x110c2, 1),
	|            new Range32 (0x110cd, 0x110cd, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Kannada = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0c80, 0x0c8c, 1),
	|            new Range16 (0x0c8e, 0x0c90, 1),
	|            new Range16 (0x0c92, 0x0ca8, 1),
	|            new Range16 (0x0caa, 0x0cb3, 1),
	|            new Range16 (0x0cb5, 0x0cb9, 1),
	|            new Range16 (0x0cbc, 0x0cc4, 1),
	|            new Range16 (0x0cc6, 0x0cc8, 1),
	|            new Range16 (0x0cca, 0x0ccd, 1),
	|            new Range16 (0x0cd5, 0x0cd6, 1),
	|            new Range16 (0x0cdd, 0x0cde, 1),
	|            new Range16 (0x0ce0, 0x0ce3, 1),
	|            new Range16 (0x0ce6, 0x0cef, 1),
	|            new Range16 (0x0cf1, 0x0cf3, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Katakana = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x30a1, 0x30fa, 1),
	|            new Range16 (0x30fd, 0x30ff, 1),
	|            new Range16 (0x31f0, 0x31ff, 1),
	|            new Range16 (0x32d0, 0x32fe, 1),
	|            new Range16 (0x3300, 0x3357, 1),
	|            new Range16 (0xff66, 0xff6f, 1),
	|            new Range16 (0xff71, 0xff9d, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1aff0, 0x1aff3, 1),
	|            new Range32 (0x1aff5, 0x1affb, 1),
	|            new Range32 (0x1affd, 0x1affe, 1),
	|            new Range32 (0x1b000, 0x1b000, 1),
	|            new Range32 (0x1b120, 0x1b122, 1),
	|            new Range32 (0x1b155, 0x1b155, 1),
	|            new Range32 (0x1b164, 0x1b167, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Kawi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11f00, 0x11f10, 1),
	|            new Range32 (0x11f12, 0x11f3a, 1),
	|            new Range32 (0x11f3e, 0x11f59, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Kayah_Li = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa900, 0xa92d, 1),
	|            new Range16 (0xa92f, 0xa92f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Kharoshthi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10a00, 0x10a03, 1),
	|            new Range32 (0x10a05, 0x10a06, 1),
	|            new Range32 (0x10a0c, 0x10a13, 1),
	|            new Range32 (0x10a15, 0x10a17, 1),
	|            new Range32 (0x10a19, 0x10a35, 1),
	|            new Range32 (0x10a38, 0x10a3a, 1),
	|            new Range32 (0x10a3f, 0x10a48, 1),
	|            new Range32 (0x10a50, 0x10a58, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Khitan_Small_Script = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16fe4, 0x16fe4, 1),
	|            new Range32 (0x18b00, 0x18cd5, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Khmer = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1780, 0x17dd, 1),
	|            new Range16 (0x17e0, 0x17e9, 1),
	|            new Range16 (0x17f0, 0x17f9, 1),
	|            new Range16 (0x19e0, 0x19ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Khojki = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11200, 0x11211, 1),
	|            new Range32 (0x11213, 0x11241, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Khudawadi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x112b0, 0x112ea, 1),
	|            new Range32 (0x112f0, 0x112f9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Lao = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0e81, 0x0e82, 1),
	|            new Range16 (0x0e84, 0x0e84, 1),
	|            new Range16 (0x0e86, 0x0e8a, 1),
	|            new Range16 (0x0e8c, 0x0ea3, 1),
	|            new Range16 (0x0ea5, 0x0ea5, 1),
	|            new Range16 (0x0ea7, 0x0ebd, 1),
	|            new Range16 (0x0ec0, 0x0ec4, 1),
	|            new Range16 (0x0ec6, 0x0ec6, 1),
	|            new Range16 (0x0ec8, 0x0ece, 1),
	|            new Range16 (0x0ed0, 0x0ed9, 1),
	|            new Range16 (0x0edc, 0x0edf, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Latin = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0041, 0x005a, 1),
	|            new Range16 (0x0061, 0x007a, 1),
	|            new Range16 (0x00aa, 0x00aa, 1),
	|            new Range16 (0x00ba, 0x00ba, 1),
	|            new Range16 (0x00c0, 0x00d6, 1),
	|            new Range16 (0x00d8, 0x00f6, 1),
	|            new Range16 (0x00f8, 0x02b8, 1),
	|            new Range16 (0x02e0, 0x02e4, 1),
	|            new Range16 (0x1d00, 0x1d25, 1),
	|            new Range16 (0x1d2c, 0x1d5c, 1),
	|            new Range16 (0x1d62, 0x1d65, 1),
	|            new Range16 (0x1d6b, 0x1d77, 1),
	|            new Range16 (0x1d79, 0x1dbe, 1),
	|            new Range16 (0x1e00, 0x1eff, 1),
	|            new Range16 (0x2071, 0x2071, 1),
	|            new Range16 (0x207f, 0x207f, 1),
	|            new Range16 (0x2090, 0x209c, 1),
	|            new Range16 (0x212a, 0x212b, 1),
	|            new Range16 (0x2132, 0x2132, 1),
	|            new Range16 (0x214e, 0x214e, 1),
	|            new Range16 (0x2160, 0x2188, 1),
	|            new Range16 (0x2c60, 0x2c7f, 1),
	|            new Range16 (0xa722, 0xa787, 1),
	|            new Range16 (0xa78b, 0xa7ca, 1),
	|            new Range16 (0xa7d0, 0xa7d1, 1),
	|            new Range16 (0xa7d3, 0xa7d3, 1),
	|            new Range16 (0xa7d5, 0xa7d9, 1),
	|            new Range16 (0xa7f2, 0xa7ff, 1),
	|            new Range16 (0xab30, 0xab5a, 1),
	|            new Range16 (0xab5c, 0xab64, 1),
	|            new Range16 (0xab66, 0xab69, 1),
	|            new Range16 (0xfb00, 0xfb06, 1),
	|            new Range16 (0xff21, 0xff3a, 1),
	|            new Range16 (0xff41, 0xff5a, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10780, 0x10785, 1),
	|            new Range32 (0x10787, 0x107b0, 1),
	|            new Range32 (0x107b2, 0x107ba, 1),
	|            new Range32 (0x1df00, 0x1df1e, 1),
	|            new Range32 (0x1df25, 0x1df2a, 1),
	|                },
	|                latinOffset: 6
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Lepcha = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1c00, 0x1c37, 1),
	|            new Range16 (0x1c3b, 0x1c49, 1),
	|            new Range16 (0x1c4d, 0x1c4f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Limbu = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1900, 0x191e, 1),
	|            new Range16 (0x1920, 0x192b, 1),
	|            new Range16 (0x1930, 0x193b, 1),
	|            new Range16 (0x1940, 0x1940, 1),
	|            new Range16 (0x1944, 0x194f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Linear_A = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10600, 0x10736, 1),
	|            new Range32 (0x10740, 0x10755, 1),
	|            new Range32 (0x10760, 0x10767, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Linear_B = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10000, 0x1000b, 1),
	|            new Range32 (0x1000d, 0x10026, 1),
	|            new Range32 (0x10028, 0x1003a, 1),
	|            new Range32 (0x1003c, 0x1003d, 1),
	|            new Range32 (0x1003f, 0x1004d, 1),
	|            new Range32 (0x10050, 0x1005d, 1),
	|            new Range32 (0x10080, 0x100fa, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Lisu = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa4d0, 0xa4ff, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11fb0, 0x11fb0, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Lycian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10280, 0x1029c, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Lydian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10920, 0x10939, 1),
	|            new Range32 (0x1093f, 0x1093f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Mahajani = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11150, 0x11176, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Makasar = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11ee0, 0x11ef8, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Malayalam = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0d00, 0x0d0c, 1),
	|            new Range16 (0x0d0e, 0x0d10, 1),
	|            new Range16 (0x0d12, 0x0d44, 1),
	|            new Range16 (0x0d46, 0x0d48, 1),
	|            new Range16 (0x0d4a, 0x0d4f, 1),
	|            new Range16 (0x0d54, 0x0d63, 1),
	|            new Range16 (0x0d66, 0x0d7f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Mandaic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0840, 0x085b, 1),
	|            new Range16 (0x085e, 0x085e, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Manichaean = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10ac0, 0x10ae6, 1),
	|            new Range32 (0x10aeb, 0x10af6, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Marchen = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11c70, 0x11c8f, 1),
	|            new Range32 (0x11c92, 0x11ca7, 1),
	|            new Range32 (0x11ca9, 0x11cb6, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Masaram_Gondi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11d00, 0x11d06, 1),
	|            new Range32 (0x11d08, 0x11d09, 1),
	|            new Range32 (0x11d0b, 0x11d36, 1),
	|            new Range32 (0x11d3a, 0x11d3a, 1),
	|            new Range32 (0x11d3c, 0x11d3d, 1),
	|            new Range32 (0x11d3f, 0x11d47, 1),
	|            new Range32 (0x11d50, 0x11d59, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Medefaidrin = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16e40, 0x16e9a, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Meetei_Mayek = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xaae0, 0xaaf6, 1),
	|            new Range16 (0xabc0, 0xabed, 1),
	|            new Range16 (0xabf0, 0xabf9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Mende_Kikakui = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e800, 0x1e8c4, 1),
	|            new Range32 (0x1e8c7, 0x1e8d6, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Meroitic_Cursive = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x109a0, 0x109b7, 1),
	|            new Range32 (0x109bc, 0x109cf, 1),
	|            new Range32 (0x109d2, 0x109ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Meroitic_Hieroglyphs = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10980, 0x1099f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Miao = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16f00, 0x16f4a, 1),
	|            new Range32 (0x16f4f, 0x16f87, 1),
	|            new Range32 (0x16f8f, 0x16f9f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Modi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11600, 0x11644, 1),
	|            new Range32 (0x11650, 0x11659, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Mongolian = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1800, 0x1801, 1),
	|            new Range16 (0x1804, 0x1804, 1),
	|            new Range16 (0x1806, 0x1819, 1),
	|            new Range16 (0x1820, 0x1878, 1),
	|            new Range16 (0x1880, 0x18aa, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11660, 0x1166c, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Mro = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16a40, 0x16a5e, 1),
	|            new Range32 (0x16a60, 0x16a69, 1),
	|            new Range32 (0x16a6e, 0x16a6f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Multani = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11280, 0x11286, 1),
	|            new Range32 (0x11288, 0x11288, 1),
	|            new Range32 (0x1128a, 0x1128d, 1),
	|            new Range32 (0x1128f, 0x1129d, 1),
	|            new Range32 (0x1129f, 0x112a9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Myanmar = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1000, 0x109f, 1),
	|            new Range16 (0xa9e0, 0xa9fe, 1),
	|            new Range16 (0xaa60, 0xaa7f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Nabataean = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10880, 0x1089e, 1),
	|            new Range32 (0x108a7, 0x108af, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Nag_Mundari = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e4d0, 0x1e4f9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Nandinagari = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x119a0, 0x119a7, 1),
	|            new Range32 (0x119aa, 0x119d7, 1),
	|            new Range32 (0x119da, 0x119e4, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _New_Tai_Lue = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1980, 0x19ab, 1),
	|            new Range16 (0x19b0, 0x19c9, 1),
	|            new Range16 (0x19d0, 0x19da, 1),
	|            new Range16 (0x19de, 0x19df, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Newa = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11400, 0x1145b, 1),
	|            new Range32 (0x1145d, 0x11461, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Nko = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x07c0, 0x07fa, 1),
	|            new Range16 (0x07fd, 0x07ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Nushu = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16fe1, 0x16fe1, 1),
	|            new Range32 (0x1b170, 0x1b2fb, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Nyiakeng_Puachue_Hmong = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e100, 0x1e12c, 1),
	|            new Range32 (0x1e130, 0x1e13d, 1),
	|            new Range32 (0x1e140, 0x1e149, 1),
	|            new Range32 (0x1e14e, 0x1e14f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Ogham = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1680, 0x169c, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Ol_Chiki = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1c50, 0x1c7f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_Hungarian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10c80, 0x10cb2, 1),
	|            new Range32 (0x10cc0, 0x10cf2, 1),
	|            new Range32 (0x10cfa, 0x10cff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_Italic = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10300, 0x10323, 1),
	|            new Range32 (0x1032d, 0x1032f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_North_Arabian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10a80, 0x10a9f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_Permic = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10350, 0x1037a, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_Persian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x103a0, 0x103c3, 1),
	|            new Range32 (0x103c8, 0x103d5, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_Sogdian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10f00, 0x10f27, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_South_Arabian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10a60, 0x10a7f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_Turkic = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10c00, 0x10c48, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Old_Uyghur = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10f70, 0x10f89, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Oriya = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0b01, 0x0b03, 1),
	|            new Range16 (0x0b05, 0x0b0c, 1),
	|            new Range16 (0x0b0f, 0x0b10, 1),
	|            new Range16 (0x0b13, 0x0b28, 1),
	|            new Range16 (0x0b2a, 0x0b30, 1),
	|            new Range16 (0x0b32, 0x0b33, 1),
	|            new Range16 (0x0b35, 0x0b39, 1),
	|            new Range16 (0x0b3c, 0x0b44, 1),
	|            new Range16 (0x0b47, 0x0b48, 1),
	|            new Range16 (0x0b4b, 0x0b4d, 1),
	|            new Range16 (0x0b55, 0x0b57, 1),
	|            new Range16 (0x0b5c, 0x0b5d, 1),
	|            new Range16 (0x0b5f, 0x0b63, 1),
	|            new Range16 (0x0b66, 0x0b77, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Osage = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x104b0, 0x104d3, 1),
	|            new Range32 (0x104d8, 0x104fb, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Osmanya = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10480, 0x1049d, 1),
	|            new Range32 (0x104a0, 0x104a9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Pahawh_Hmong = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16b00, 0x16b45, 1),
	|            new Range32 (0x16b50, 0x16b59, 1),
	|            new Range32 (0x16b5b, 0x16b61, 1),
	|            new Range32 (0x16b63, 0x16b77, 1),
	|            new Range32 (0x16b7d, 0x16b8f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Palmyrene = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10860, 0x1087f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Pau_Cin_Hau = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11ac0, 0x11af8, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Phags_Pa = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa840, 0xa877, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Phoenician = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10900, 0x1091b, 1),
	|            new Range32 (0x1091f, 0x1091f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Psalter_Pahlavi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10b80, 0x10b91, 1),
	|            new Range32 (0x10b99, 0x10b9c, 1),
	|            new Range32 (0x10ba9, 0x10baf, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Rejang = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa930, 0xa953, 1),
	|            new Range16 (0xa95f, 0xa95f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Runic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x16a0, 0x16ea, 1),
	|            new Range16 (0x16ee, 0x16f8, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Samaritan = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0800, 0x082d, 1),
	|            new Range16 (0x0830, 0x083e, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Saurashtra = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa880, 0xa8c5, 1),
	|            new Range16 (0xa8ce, 0xa8d9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Sharada = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11180, 0x111df, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Shavian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10450, 0x1047f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Siddham = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11580, 0x115b5, 1),
	|            new Range32 (0x115b8, 0x115dd, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _SignWriting = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1d800, 0x1da8b, 1),
	|            new Range32 (0x1da9b, 0x1da9f, 1),
	|            new Range32 (0x1daa1, 0x1daaf, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Sinhala = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0d81, 0x0d83, 1),
	|            new Range16 (0x0d85, 0x0d96, 1),
	|            new Range16 (0x0d9a, 0x0db1, 1),
	|            new Range16 (0x0db3, 0x0dbb, 1),
	|            new Range16 (0x0dbd, 0x0dbd, 1),
	|            new Range16 (0x0dc0, 0x0dc6, 1),
	|            new Range16 (0x0dca, 0x0dca, 1),
	|            new Range16 (0x0dcf, 0x0dd4, 1),
	|            new Range16 (0x0dd6, 0x0dd6, 1),
	|            new Range16 (0x0dd8, 0x0ddf, 1),
	|            new Range16 (0x0de6, 0x0def, 1),
	|            new Range16 (0x0df2, 0x0df4, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x111e1, 0x111f4, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Sogdian = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10f30, 0x10f59, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Sora_Sompeng = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x110d0, 0x110e8, 1),
	|            new Range32 (0x110f0, 0x110f9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Soyombo = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11a50, 0x11aa2, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Sundanese = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1b80, 0x1bbf, 1),
	|            new Range16 (0x1cc0, 0x1cc7, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Syloti_Nagri = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa800, 0xa82c, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Syriac = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0700, 0x070d, 1),
	|            new Range16 (0x070f, 0x074a, 1),
	|            new Range16 (0x074d, 0x074f, 1),
	|            new Range16 (0x0860, 0x086a, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tagalog = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1700, 0x1715, 1),
	|            new Range16 (0x171f, 0x171f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tagbanwa = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1760, 0x176c, 1),
	|            new Range16 (0x176e, 0x1770, 1),
	|            new Range16 (0x1772, 0x1773, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tai_Le = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1950, 0x196d, 1),
	|            new Range16 (0x1970, 0x1974, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tai_Tham = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1a20, 0x1a5e, 1),
	|            new Range16 (0x1a60, 0x1a7c, 1),
	|            new Range16 (0x1a7f, 0x1a89, 1),
	|            new Range16 (0x1a90, 0x1a99, 1),
	|            new Range16 (0x1aa0, 0x1aad, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tai_Viet = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xaa80, 0xaac2, 1),
	|            new Range16 (0xaadb, 0xaadf, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Takri = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11680, 0x116b9, 1),
	|            new Range32 (0x116c0, 0x116c9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tamil = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0b82, 0x0b83, 1),
	|            new Range16 (0x0b85, 0x0b8a, 1),
	|            new Range16 (0x0b8e, 0x0b90, 1),
	|            new Range16 (0x0b92, 0x0b95, 1),
	|            new Range16 (0x0b99, 0x0b9a, 1),
	|            new Range16 (0x0b9c, 0x0b9c, 1),
	|            new Range16 (0x0b9e, 0x0b9f, 1),
	|            new Range16 (0x0ba3, 0x0ba4, 1),
	|            new Range16 (0x0ba8, 0x0baa, 1),
	|            new Range16 (0x0bae, 0x0bb9, 1),
	|            new Range16 (0x0bbe, 0x0bc2, 1),
	|            new Range16 (0x0bc6, 0x0bc8, 1),
	|            new Range16 (0x0bca, 0x0bcd, 1),
	|            new Range16 (0x0bd0, 0x0bd0, 1),
	|            new Range16 (0x0bd7, 0x0bd7, 1),
	|            new Range16 (0x0be6, 0x0bfa, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11fc0, 0x11ff1, 1),
	|            new Range32 (0x11fff, 0x11fff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tangsa = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16a70, 0x16abe, 1),
	|            new Range32 (0x16ac0, 0x16ac9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tangut = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16fe0, 0x16fe0, 1),
	|            new Range32 (0x17000, 0x187f7, 1),
	|            new Range32 (0x18800, 0x18aff, 1),
	|            new Range32 (0x18d00, 0x18d08, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Telugu = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0c00, 0x0c0c, 1),
	|            new Range16 (0x0c0e, 0x0c10, 1),
	|            new Range16 (0x0c12, 0x0c28, 1),
	|            new Range16 (0x0c2a, 0x0c39, 1),
	|            new Range16 (0x0c3c, 0x0c44, 1),
	|            new Range16 (0x0c46, 0x0c48, 1),
	|            new Range16 (0x0c4a, 0x0c4d, 1),
	|            new Range16 (0x0c55, 0x0c56, 1),
	|            new Range16 (0x0c58, 0x0c5a, 1),
	|            new Range16 (0x0c5d, 0x0c5d, 1),
	|            new Range16 (0x0c60, 0x0c63, 1),
	|            new Range16 (0x0c66, 0x0c6f, 1),
	|            new Range16 (0x0c77, 0x0c7f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Thaana = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0780, 0x07b1, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Thai = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0e01, 0x0e3a, 1),
	|            new Range16 (0x0e40, 0x0e5b, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tibetan = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0f00, 0x0f47, 1),
	|            new Range16 (0x0f49, 0x0f6c, 1),
	|            new Range16 (0x0f71, 0x0f97, 1),
	|            new Range16 (0x0f99, 0x0fbc, 1),
	|            new Range16 (0x0fbe, 0x0fcc, 1),
	|            new Range16 (0x0fce, 0x0fd4, 1),
	|            new Range16 (0x0fd9, 0x0fda, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tifinagh = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2d30, 0x2d67, 1),
	|            new Range16 (0x2d6f, 0x2d70, 1),
	|            new Range16 (0x2d7f, 0x2d7f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Tirhuta = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11480, 0x114c7, 1),
	|            new Range32 (0x114d0, 0x114d9, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Toto = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e290, 0x1e2ae, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Ugaritic = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10380, 0x1039d, 1),
	|            new Range32 (0x1039f, 0x1039f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Vai = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa500, 0xa62b, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Vithkuqi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10570, 0x1057a, 1),
	|            new Range32 (0x1057c, 0x1058a, 1),
	|            new Range32 (0x1058c, 0x10592, 1),
	|            new Range32 (0x10594, 0x10595, 1),
	|            new Range32 (0x10597, 0x105a1, 1),
	|            new Range32 (0x105a3, 0x105b1, 1),
	|            new Range32 (0x105b3, 0x105b9, 1),
	|            new Range32 (0x105bb, 0x105bc, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Wancho = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1e2c0, 0x1e2f9, 1),
	|            new Range32 (0x1e2ff, 0x1e2ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Warang_Citi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x118a0, 0x118f2, 1),
	|            new Range32 (0x118ff, 0x118ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Yezidi = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10e80, 0x10ea9, 1),
	|            new Range32 (0x10eab, 0x10ead, 1),
	|            new Range32 (0x10eb0, 0x10eb1, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Yi = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xa000, 0xa48c, 1),
	|            new Range16 (0xa490, 0xa4c6, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Zanabazar_Square = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x11a00, 0x11a47, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            /// <summary>Adlam is the set of Unicode characters in script Adlam.</summary>
	|            public static RangeTable Adlam => _Adlam;
	|            /// <summary>Ahom is the set of Unicode characters in script Ahom.</summary>
	|            public static RangeTable Ahom => _Ahom;
	|            /// <summary>Anatolian_Hieroglyphs is the set of Unicode characters in script Anatolian_Hieroglyphs.</summary>
	|            public static RangeTable Anatolian_Hieroglyphs => _Anatolian_Hieroglyphs;
	|            /// <summary>Arabic is the set of Unicode characters in script Arabic.</summary>
	|            public static RangeTable Arabic => _Arabic;
	|            /// <summary>Armenian is the set of Unicode characters in script Armenian.</summary>
	|            public static RangeTable Armenian => _Armenian;
	|            /// <summary>Avestan is the set of Unicode characters in script Avestan.</summary>
	|            public static RangeTable Avestan => _Avestan;
	|            /// <summary>Balinese is the set of Unicode characters in script Balinese.</summary>
	|            public static RangeTable Balinese => _Balinese;
	|            /// <summary>Bamum is the set of Unicode characters in script Bamum.</summary>
	|            public static RangeTable Bamum => _Bamum;
	|            /// <summary>Bassa_Vah is the set of Unicode characters in script Bassa_Vah.</summary>
	|            public static RangeTable Bassa_Vah => _Bassa_Vah;
	|            /// <summary>Batak is the set of Unicode characters in script Batak.</summary>
	|            public static RangeTable Batak => _Batak;
	|            /// <summary>Bengali is the set of Unicode characters in script Bengali.</summary>
	|            public static RangeTable Bengali => _Bengali;
	|            /// <summary>Bhaiksuki is the set of Unicode characters in script Bhaiksuki.</summary>
	|            public static RangeTable Bhaiksuki => _Bhaiksuki;
	|            /// <summary>Bopomofo is the set of Unicode characters in script Bopomofo.</summary>
	|            public static RangeTable Bopomofo => _Bopomofo;
	|            /// <summary>Brahmi is the set of Unicode characters in script Brahmi.</summary>
	|            public static RangeTable Brahmi => _Brahmi;
	|            /// <summary>Braille is the set of Unicode characters in script Braille.</summary>
	|            public static RangeTable Braille => _Braille;
	|            /// <summary>Buginese is the set of Unicode characters in script Buginese.</summary>
	|            public static RangeTable Buginese => _Buginese;
	|            /// <summary>Buhid is the set of Unicode characters in script Buhid.</summary>
	|            public static RangeTable Buhid => _Buhid;
	|            /// <summary>Canadian_Aboriginal is the set of Unicode characters in script Canadian_Aboriginal.</summary>
	|            public static RangeTable Canadian_Aboriginal => _Canadian_Aboriginal;
	|            /// <summary>Carian is the set of Unicode characters in script Carian.</summary>
	|            public static RangeTable Carian => _Carian;
	|            /// <summary>Caucasian_Albanian is the set of Unicode characters in script Caucasian_Albanian.</summary>
	|            public static RangeTable Caucasian_Albanian => _Caucasian_Albanian;
	|            /// <summary>Chakma is the set of Unicode characters in script Chakma.</summary>
	|            public static RangeTable Chakma => _Chakma;
	|            /// <summary>Cham is the set of Unicode characters in script Cham.</summary>
	|            public static RangeTable Cham => _Cham;
	|            /// <summary>Cherokee is the set of Unicode characters in script Cherokee.</summary>
	|            public static RangeTable Cherokee => _Cherokee;
	|            /// <summary>Chorasmian is the set of Unicode characters in script Chorasmian.</summary>
	|            public static RangeTable Chorasmian => _Chorasmian;
	|            /// <summary>Common is the set of Unicode characters in script Common.</summary>
	|            public static RangeTable Common => _Common;
	|            /// <summary>Coptic is the set of Unicode characters in script Coptic.</summary>
	|            public static RangeTable Coptic => _Coptic;
	|            /// <summary>Cuneiform is the set of Unicode characters in script Cuneiform.</summary>
	|            public static RangeTable Cuneiform => _Cuneiform;
	|            /// <summary>Cypriot is the set of Unicode characters in script Cypriot.</summary>
	|            public static RangeTable Cypriot => _Cypriot;
	|            /// <summary>Cypro_Minoan is the set of Unicode characters in script Cypro_Minoan.</summary>
	|            public static RangeTable Cypro_Minoan => _Cypro_Minoan;
	|            /// <summary>Cyrillic is the set of Unicode characters in script Cyrillic.</summary>
	|            public static RangeTable Cyrillic => _Cyrillic;
	|            /// <summary>Deseret is the set of Unicode characters in script Deseret.</summary>
	|            public static RangeTable Deseret => _Deseret;
	|            /// <summary>Devanagari is the set of Unicode characters in script Devanagari.</summary>
	|            public static RangeTable Devanagari => _Devanagari;
	|            /// <summary>Dives_Akuru is the set of Unicode characters in script Dives_Akuru.</summary>
	|            public static RangeTable Dives_Akuru => _Dives_Akuru;
	|            /// <summary>Dogra is the set of Unicode characters in script Dogra.</summary>
	|            public static RangeTable Dogra => _Dogra;
	|            /// <summary>Duployan is the set of Unicode characters in script Duployan.</summary>
	|            public static RangeTable Duployan => _Duployan;
	|            /// <summary>Egyptian_Hieroglyphs is the set of Unicode characters in script Egyptian_Hieroglyphs.</summary>
	|            public static RangeTable Egyptian_Hieroglyphs => _Egyptian_Hieroglyphs;
	|            /// <summary>Elbasan is the set of Unicode characters in script Elbasan.</summary>
	|            public static RangeTable Elbasan => _Elbasan;
	|            /// <summary>Elymaic is the set of Unicode characters in script Elymaic.</summary>
	|            public static RangeTable Elymaic => _Elymaic;
	|            /// <summary>Ethiopic is the set of Unicode characters in script Ethiopic.</summary>
	|            public static RangeTable Ethiopic => _Ethiopic;
	|            /// <summary>Georgian is the set of Unicode characters in script Georgian.</summary>
	|            public static RangeTable Georgian => _Georgian;
	|            /// <summary>Glagolitic is the set of Unicode characters in script Glagolitic.</summary>
	|            public static RangeTable Glagolitic => _Glagolitic;
	|            /// <summary>Gothic is the set of Unicode characters in script Gothic.</summary>
	|            public static RangeTable Gothic => _Gothic;
	|            /// <summary>Grantha is the set of Unicode characters in script Grantha.</summary>
	|            public static RangeTable Grantha => _Grantha;
	|            /// <summary>Greek is the set of Unicode characters in script Greek.</summary>
	|            public static RangeTable Greek => _Greek;
	|            /// <summary>Gujarati is the set of Unicode characters in script Gujarati.</summary>
	|            public static RangeTable Gujarati => _Gujarati;
	|            /// <summary>Gunjala_Gondi is the set of Unicode characters in script Gunjala_Gondi.</summary>
	|            public static RangeTable Gunjala_Gondi => _Gunjala_Gondi;
	|            /// <summary>Gurmukhi is the set of Unicode characters in script Gurmukhi.</summary>
	|            public static RangeTable Gurmukhi => _Gurmukhi;
	|            /// <summary>Han is the set of Unicode characters in script Han.</summary>
	|            public static RangeTable Han => _Han;
	|            /// <summary>Hangul is the set of Unicode characters in script Hangul.</summary>
	|            public static RangeTable Hangul => _Hangul;
	|            /// <summary>Hanifi_Rohingya is the set of Unicode characters in script Hanifi_Rohingya.</summary>
	|            public static RangeTable Hanifi_Rohingya => _Hanifi_Rohingya;
	|            /// <summary>Hanunoo is the set of Unicode characters in script Hanunoo.</summary>
	|            public static RangeTable Hanunoo => _Hanunoo;
	|            /// <summary>Hatran is the set of Unicode characters in script Hatran.</summary>
	|            public static RangeTable Hatran => _Hatran;
	|            /// <summary>Hebrew is the set of Unicode characters in script Hebrew.</summary>
	|            public static RangeTable Hebrew => _Hebrew;
	|            /// <summary>Hiragana is the set of Unicode characters in script Hiragana.</summary>
	|            public static RangeTable Hiragana => _Hiragana;
	|            /// <summary>Imperial_Aramaic is the set of Unicode characters in script Imperial_Aramaic.</summary>
	|            public static RangeTable Imperial_Aramaic => _Imperial_Aramaic;
	|            /// <summary>Inherited is the set of Unicode characters in script Inherited.</summary>
	|            public static RangeTable Inherited => _Inherited;
	|            /// <summary>Inscriptional_Pahlavi is the set of Unicode characters in script Inscriptional_Pahlavi.</summary>
	|            public static RangeTable Inscriptional_Pahlavi => _Inscriptional_Pahlavi;
	|            /// <summary>Inscriptional_Parthian is the set of Unicode characters in script Inscriptional_Parthian.</summary>
	|            public static RangeTable Inscriptional_Parthian => _Inscriptional_Parthian;
	|            /// <summary>Javanese is the set of Unicode characters in script Javanese.</summary>
	|            public static RangeTable Javanese => _Javanese;
	|            /// <summary>Kaithi is the set of Unicode characters in script Kaithi.</summary>
	|            public static RangeTable Kaithi => _Kaithi;
	|            /// <summary>Kannada is the set of Unicode characters in script Kannada.</summary>
	|            public static RangeTable Kannada => _Kannada;
	|            /// <summary>Katakana is the set of Unicode characters in script Katakana.</summary>
	|            public static RangeTable Katakana => _Katakana;
	|            /// <summary>Kawi is the set of Unicode characters in script Kawi.</summary>
	|            public static RangeTable Kawi => _Kawi;
	|            /// <summary>Kayah_Li is the set of Unicode characters in script Kayah_Li.</summary>
	|            public static RangeTable Kayah_Li => _Kayah_Li;
	|            /// <summary>Kharoshthi is the set of Unicode characters in script Kharoshthi.</summary>
	|            public static RangeTable Kharoshthi => _Kharoshthi;
	|            /// <summary>Khitan_Small_Script is the set of Unicode characters in script Khitan_Small_Script.</summary>
	|            public static RangeTable Khitan_Small_Script => _Khitan_Small_Script;
	|            /// <summary>Khmer is the set of Unicode characters in script Khmer.</summary>
	|            public static RangeTable Khmer => _Khmer;
	|            /// <summary>Khojki is the set of Unicode characters in script Khojki.</summary>
	|            public static RangeTable Khojki => _Khojki;
	|            /// <summary>Khudawadi is the set of Unicode characters in script Khudawadi.</summary>
	|            public static RangeTable Khudawadi => _Khudawadi;
	|            /// <summary>Lao is the set of Unicode characters in script Lao.</summary>
	|            public static RangeTable Lao => _Lao;
	|            /// <summary>Latin is the set of Unicode characters in script Latin.</summary>
	|            public static RangeTable Latin => _Latin;
	|            /// <summary>Lepcha is the set of Unicode characters in script Lepcha.</summary>
	|            public static RangeTable Lepcha => _Lepcha;
	|            /// <summary>Limbu is the set of Unicode characters in script Limbu.</summary>
	|            public static RangeTable Limbu => _Limbu;
	|            /// <summary>Linear_A is the set of Unicode characters in script Linear_A.</summary>
	|            public static RangeTable Linear_A => _Linear_A;
	|            /// <summary>Linear_B is the set of Unicode characters in script Linear_B.</summary>
	|            public static RangeTable Linear_B => _Linear_B;
	|            /// <summary>Lisu is the set of Unicode characters in script Lisu.</summary>
	|            public static RangeTable Lisu => _Lisu;
	|            /// <summary>Lycian is the set of Unicode characters in script Lycian.</summary>
	|            public static RangeTable Lycian => _Lycian;
	|            /// <summary>Lydian is the set of Unicode characters in script Lydian.</summary>
	|            public static RangeTable Lydian => _Lydian;
	|            /// <summary>Mahajani is the set of Unicode characters in script Mahajani.</summary>
	|            public static RangeTable Mahajani => _Mahajani;
	|            /// <summary>Makasar is the set of Unicode characters in script Makasar.</summary>
	|            public static RangeTable Makasar => _Makasar;
	|            /// <summary>Malayalam is the set of Unicode characters in script Malayalam.</summary>
	|            public static RangeTable Malayalam => _Malayalam;
	|            /// <summary>Mandaic is the set of Unicode characters in script Mandaic.</summary>
	|            public static RangeTable Mandaic => _Mandaic;
	|            /// <summary>Manichaean is the set of Unicode characters in script Manichaean.</summary>
	|            public static RangeTable Manichaean => _Manichaean;
	|            /// <summary>Marchen is the set of Unicode characters in script Marchen.</summary>
	|            public static RangeTable Marchen => _Marchen;
	|            /// <summary>Masaram_Gondi is the set of Unicode characters in script Masaram_Gondi.</summary>
	|            public static RangeTable Masaram_Gondi => _Masaram_Gondi;
	|            /// <summary>Medefaidrin is the set of Unicode characters in script Medefaidrin.</summary>
	|            public static RangeTable Medefaidrin => _Medefaidrin;
	|            /// <summary>Meetei_Mayek is the set of Unicode characters in script Meetei_Mayek.</summary>
	|            public static RangeTable Meetei_Mayek => _Meetei_Mayek;
	|            /// <summary>Mende_Kikakui is the set of Unicode characters in script Mende_Kikakui.</summary>
	|            public static RangeTable Mende_Kikakui => _Mende_Kikakui;
	|            /// <summary>Meroitic_Cursive is the set of Unicode characters in script Meroitic_Cursive.</summary>
	|            public static RangeTable Meroitic_Cursive => _Meroitic_Cursive;
	|            /// <summary>Meroitic_Hieroglyphs is the set of Unicode characters in script Meroitic_Hieroglyphs.</summary>
	|            public static RangeTable Meroitic_Hieroglyphs => _Meroitic_Hieroglyphs;
	|            /// <summary>Miao is the set of Unicode characters in script Miao.</summary>
	|            public static RangeTable Miao => _Miao;
	|            /// <summary>Modi is the set of Unicode characters in script Modi.</summary>
	|            public static RangeTable Modi => _Modi;
	|            /// <summary>Mongolian is the set of Unicode characters in script Mongolian.</summary>
	|            public static RangeTable Mongolian => _Mongolian;
	|            /// <summary>Mro is the set of Unicode characters in script Mro.</summary>
	|            public static RangeTable Mro => _Mro;
	|            /// <summary>Multani is the set of Unicode characters in script Multani.</summary>
	|            public static RangeTable Multani => _Multani;
	|            /// <summary>Myanmar is the set of Unicode characters in script Myanmar.</summary>
	|            public static RangeTable Myanmar => _Myanmar;
	|            /// <summary>Nabataean is the set of Unicode characters in script Nabataean.</summary>
	|            public static RangeTable Nabataean => _Nabataean;
	|            /// <summary>Nag_Mundari is the set of Unicode characters in script Nag_Mundari.</summary>
	|            public static RangeTable Nag_Mundari => _Nag_Mundari;
	|            /// <summary>Nandinagari is the set of Unicode characters in script Nandinagari.</summary>
	|            public static RangeTable Nandinagari => _Nandinagari;
	|            /// <summary>New_Tai_Lue is the set of Unicode characters in script New_Tai_Lue.</summary>
	|            public static RangeTable New_Tai_Lue => _New_Tai_Lue;
	|            /// <summary>Newa is the set of Unicode characters in script Newa.</summary>
	|            public static RangeTable Newa => _Newa;
	|            /// <summary>Nko is the set of Unicode characters in script Nko.</summary>
	|            public static RangeTable Nko => _Nko;
	|            /// <summary>Nushu is the set of Unicode characters in script Nushu.</summary>
	|            public static RangeTable Nushu => _Nushu;
	|            /// <summary>Nyiakeng_Puachue_Hmong is the set of Unicode characters in script Nyiakeng_Puachue_Hmong.</summary>
	|            public static RangeTable Nyiakeng_Puachue_Hmong => _Nyiakeng_Puachue_Hmong;
	|            /// <summary>Ogham is the set of Unicode characters in script Ogham.</summary>
	|            public static RangeTable Ogham => _Ogham;
	|            /// <summary>Ol_Chiki is the set of Unicode characters in script Ol_Chiki.</summary>
	|            public static RangeTable Ol_Chiki => _Ol_Chiki;
	|            /// <summary>Old_Hungarian is the set of Unicode characters in script Old_Hungarian.</summary>
	|            public static RangeTable Old_Hungarian => _Old_Hungarian;
	|            /// <summary>Old_Italic is the set of Unicode characters in script Old_Italic.</summary>
	|            public static RangeTable Old_Italic => _Old_Italic;
	|            /// <summary>Old_North_Arabian is the set of Unicode characters in script Old_North_Arabian.</summary>
	|            public static RangeTable Old_North_Arabian => _Old_North_Arabian;
	|            /// <summary>Old_Permic is the set of Unicode characters in script Old_Permic.</summary>
	|            public static RangeTable Old_Permic => _Old_Permic;
	|            /// <summary>Old_Persian is the set of Unicode characters in script Old_Persian.</summary>
	|            public static RangeTable Old_Persian => _Old_Persian;
	|            /// <summary>Old_Sogdian is the set of Unicode characters in script Old_Sogdian.</summary>
	|            public static RangeTable Old_Sogdian => _Old_Sogdian;
	|            /// <summary>Old_South_Arabian is the set of Unicode characters in script Old_South_Arabian.</summary>
	|            public static RangeTable Old_South_Arabian => _Old_South_Arabian;
	|            /// <summary>Old_Turkic is the set of Unicode characters in script Old_Turkic.</summary>
	|            public static RangeTable Old_Turkic => _Old_Turkic;
	|            /// <summary>Old_Uyghur is the set of Unicode characters in script Old_Uyghur.</summary>
	|            public static RangeTable Old_Uyghur => _Old_Uyghur;
	|            /// <summary>Oriya is the set of Unicode characters in script Oriya.</summary>
	|            public static RangeTable Oriya => _Oriya;
	|            /// <summary>Osage is the set of Unicode characters in script Osage.</summary>
	|            public static RangeTable Osage => _Osage;
	|            /// <summary>Osmanya is the set of Unicode characters in script Osmanya.</summary>
	|            public static RangeTable Osmanya => _Osmanya;
	|            /// <summary>Pahawh_Hmong is the set of Unicode characters in script Pahawh_Hmong.</summary>
	|            public static RangeTable Pahawh_Hmong => _Pahawh_Hmong;
	|            /// <summary>Palmyrene is the set of Unicode characters in script Palmyrene.</summary>
	|            public static RangeTable Palmyrene => _Palmyrene;
	|            /// <summary>Pau_Cin_Hau is the set of Unicode characters in script Pau_Cin_Hau.</summary>
	|            public static RangeTable Pau_Cin_Hau => _Pau_Cin_Hau;
	|            /// <summary>Phags_Pa is the set of Unicode characters in script Phags_Pa.</summary>
	|            public static RangeTable Phags_Pa => _Phags_Pa;
	|            /// <summary>Phoenician is the set of Unicode characters in script Phoenician.</summary>
	|            public static RangeTable Phoenician => _Phoenician;
	|            /// <summary>Psalter_Pahlavi is the set of Unicode characters in script Psalter_Pahlavi.</summary>
	|            public static RangeTable Psalter_Pahlavi => _Psalter_Pahlavi;
	|            /// <summary>Rejang is the set of Unicode characters in script Rejang.</summary>
	|            public static RangeTable Rejang => _Rejang;
	|            /// <summary>Runic is the set of Unicode characters in script Runic.</summary>
	|            public static RangeTable Runic => _Runic;
	|            /// <summary>Samaritan is the set of Unicode characters in script Samaritan.</summary>
	|            public static RangeTable Samaritan => _Samaritan;
	|            /// <summary>Saurashtra is the set of Unicode characters in script Saurashtra.</summary>
	|            public static RangeTable Saurashtra => _Saurashtra;
	|            /// <summary>Sharada is the set of Unicode characters in script Sharada.</summary>
	|            public static RangeTable Sharada => _Sharada;
	|            /// <summary>Shavian is the set of Unicode characters in script Shavian.</summary>
	|            public static RangeTable Shavian => _Shavian;
	|            /// <summary>Siddham is the set of Unicode characters in script Siddham.</summary>
	|            public static RangeTable Siddham => _Siddham;
	|            /// <summary>SignWriting is the set of Unicode characters in script SignWriting.</summary>
	|            public static RangeTable SignWriting => _SignWriting;
	|            /// <summary>Sinhala is the set of Unicode characters in script Sinhala.</summary>
	|            public static RangeTable Sinhala => _Sinhala;
	|            /// <summary>Sogdian is the set of Unicode characters in script Sogdian.</summary>
	|            public static RangeTable Sogdian => _Sogdian;
	|            /// <summary>Sora_Sompeng is the set of Unicode characters in script Sora_Sompeng.</summary>
	|            public static RangeTable Sora_Sompeng => _Sora_Sompeng;
	|            /// <summary>Soyombo is the set of Unicode characters in script Soyombo.</summary>
	|            public static RangeTable Soyombo => _Soyombo;
	|            /// <summary>Sundanese is the set of Unicode characters in script Sundanese.</summary>
	|            public static RangeTable Sundanese => _Sundanese;
	|            /// <summary>Syloti_Nagri is the set of Unicode characters in script Syloti_Nagri.</summary>
	|            public static RangeTable Syloti_Nagri => _Syloti_Nagri;
	|            /// <summary>Syriac is the set of Unicode characters in script Syriac.</summary>
	|            public static RangeTable Syriac => _Syriac;
	|            /// <summary>Tagalog is the set of Unicode characters in script Tagalog.</summary>
	|            public static RangeTable Tagalog => _Tagalog;
	|            /// <summary>Tagbanwa is the set of Unicode characters in script Tagbanwa.</summary>
	|            public static RangeTable Tagbanwa => _Tagbanwa;
	|            /// <summary>Tai_Le is the set of Unicode characters in script Tai_Le.</summary>
	|            public static RangeTable Tai_Le => _Tai_Le;
	|            /// <summary>Tai_Tham is the set of Unicode characters in script Tai_Tham.</summary>
	|            public static RangeTable Tai_Tham => _Tai_Tham;
	|            /// <summary>Tai_Viet is the set of Unicode characters in script Tai_Viet.</summary>
	|            public static RangeTable Tai_Viet => _Tai_Viet;
	|            /// <summary>Takri is the set of Unicode characters in script Takri.</summary>
	|            public static RangeTable Takri => _Takri;
	|            /// <summary>Tamil is the set of Unicode characters in script Tamil.</summary>
	|            public static RangeTable Tamil => _Tamil;
	|            /// <summary>Tangsa is the set of Unicode characters in script Tangsa.</summary>
	|            public static RangeTable Tangsa => _Tangsa;
	|            /// <summary>Tangut is the set of Unicode characters in script Tangut.</summary>
	|            public static RangeTable Tangut => _Tangut;
	|            /// <summary>Telugu is the set of Unicode characters in script Telugu.</summary>
	|            public static RangeTable Telugu => _Telugu;
	|            /// <summary>Thaana is the set of Unicode characters in script Thaana.</summary>
	|            public static RangeTable Thaana => _Thaana;
	|            /// <summary>Thai is the set of Unicode characters in script Thai.</summary>
	|            public static RangeTable Thai => _Thai;
	|            /// <summary>Tibetan is the set of Unicode characters in script Tibetan.</summary>
	|            public static RangeTable Tibetan => _Tibetan;
	|            /// <summary>Tifinagh is the set of Unicode characters in script Tifinagh.</summary>
	|            public static RangeTable Tifinagh => _Tifinagh;
	|            /// <summary>Tirhuta is the set of Unicode characters in script Tirhuta.</summary>
	|            public static RangeTable Tirhuta => _Tirhuta;
	|            /// <summary>Toto is the set of Unicode characters in script Toto.</summary>
	|            public static RangeTable Toto => _Toto;
	|            /// <summary>Ugaritic is the set of Unicode characters in script Ugaritic.</summary>
	|            public static RangeTable Ugaritic => _Ugaritic;
	|            /// <summary>Vai is the set of Unicode characters in script Vai.</summary>
	|            public static RangeTable Vai => _Vai;
	|            /// <summary>Vithkuqi is the set of Unicode characters in script Vithkuqi.</summary>
	|            public static RangeTable Vithkuqi => _Vithkuqi;
	|            /// <summary>Wancho is the set of Unicode characters in script Wancho.</summary>
	|            public static RangeTable Wancho => _Wancho;
	|            /// <summary>Warang_Citi is the set of Unicode characters in script Warang_Citi.</summary>
	|            public static RangeTable Warang_Citi => _Warang_Citi;
	|            /// <summary>Yezidi is the set of Unicode characters in script Yezidi.</summary>
	|            public static RangeTable Yezidi => _Yezidi;
	|            /// <summary>Yi is the set of Unicode characters in script Yi.</summary>
	|            public static RangeTable Yi => _Yi;
	|            /// <summary>Zanabazar_Square is the set of Unicode characters in script Zanabazar_Square.</summary>
	|            public static RangeTable Zanabazar_Square => _Zanabazar_Square;
	|        }
	|
	|        // Generated by running
	|        //	maketables --props=all --url=https://www.unicode.org/Public/15.0.0/ucd/
	|        // DO NOT EDIT
	|
	|        /// <summary>Static class containing the proeprty-based tables.</summary>
	|        /// <remarks><para>There are static properties that can be used to fetch RangeTables that identify characters that have a specific property, or you can use the <see cref=""T:NStack.Unicode.Property.Get""/> method in this class to retrieve the range table by the property name</para></remarks>
	|        public static class Property
	|        {
	|            /// <summary>Retrieves the specified RangeTable having that property.</summary>
	|            /// <param name=""propertyName"">The property name.</param>
	|            public static RangeTable Get(string propertyName) => Properties[propertyName];
	|            // Properties is the set of Unicode property tables.
	|            static Dictionary<string, RangeTable> Properties = new Dictionary<string, RangeTable>(){
	|            { ""ASCII_Hex_Digit"", ASCII_Hex_Digit },
	|            { ""Bidi_Control"", Bidi_Control },
	|            { ""Dash"", Dash },
	|            { ""Deprecated"", Deprecated },
	|            { ""Diacritic"", Diacritic },
	|            { ""Extender"", Extender },
	|            { ""Hex_Digit"", Hex_Digit },
	|            { ""Hyphen"", Hyphen },
	|            { ""IDS_Binary_Operator"", IDS_Binary_Operator },
	|            { ""IDS_Trinary_Operator"", IDS_Trinary_Operator },
	|            { ""Ideographic"", Ideographic },
	|            { ""Join_Control"", Join_Control },
	|            { ""Logical_Order_Exception"", Logical_Order_Exception },
	|            { ""Noncharacter_Code_Point"", Noncharacter_Code_Point },
	|            { ""Other_Alphabetic"", Other_Alphabetic },
	|            { ""Other_Default_Ignorable_Code_Point"", Other_Default_Ignorable_Code_Point },
	|            { ""Other_Grapheme_Extend"", Other_Grapheme_Extend },
	|            { ""Other_ID_Continue"", Other_ID_Continue },
	|            { ""Other_ID_Start"", Other_ID_Start },
	|            { ""Other_Lowercase"", Other_Lowercase },
	|            { ""Other_Math"", Other_Math },
	|            { ""Other_Uppercase"", Other_Uppercase },
	|            { ""Pattern_Syntax"", Pattern_Syntax },
	|            { ""Pattern_White_Space"", Pattern_White_Space },
	|            { ""Prepended_Concatenation_Mark"", Prepended_Concatenation_Mark },
	|            { ""Quotation_Mark"", Quotation_Mark },
	|            { ""Radical"", Radical },
	|            { ""Regional_Indicator"", Regional_Indicator },
	|            { ""Sentence_Terminal"", Sentence_Terminal },
	|            { ""STerm"", Sentence_Terminal },
	|            { ""Soft_Dotted"", Soft_Dotted },
	|            { ""Terminal_Punctuation"", Terminal_Punctuation },
	|            { ""Unified_Ideograph"", Unified_Ideograph },
	|            { ""Variation_Selector"", Variation_Selector },
	|            { ""White_Space"", White_Space },
	|        };
	|
	|            internal static RangeTable _ASCII_Hex_Digit = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0030, 0x0039, 1),
	|            new Range16 (0x0041, 0x0046, 1),
	|            new Range16 (0x0061, 0x0066, 1),
	|                },
	|                latinOffset: 3
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Bidi_Control = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x061c, 0x061c, 1),
	|            new Range16 (0x200e, 0x200f, 1),
	|            new Range16 (0x202a, 0x202e, 1),
	|            new Range16 (0x2066, 0x2069, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Dash = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x002d, 0x002d, 1),
	|            new Range16 (0x058a, 0x058a, 1),
	|            new Range16 (0x05be, 0x05be, 1),
	|            new Range16 (0x1400, 0x1400, 1),
	|            new Range16 (0x1806, 0x1806, 1),
	|            new Range16 (0x2010, 0x2015, 1),
	|            new Range16 (0x2053, 0x2053, 1),
	|            new Range16 (0x207b, 0x207b, 1),
	|            new Range16 (0x208b, 0x208b, 1),
	|            new Range16 (0x2212, 0x2212, 1),
	|            new Range16 (0x2e17, 0x2e17, 1),
	|            new Range16 (0x2e1a, 0x2e1a, 1),
	|            new Range16 (0x2e3a, 0x2e3b, 1),
	|            new Range16 (0x2e40, 0x2e40, 1),
	|            new Range16 (0x2e5d, 0x2e5d, 1),
	|            new Range16 (0x301c, 0x301c, 1),
	|            new Range16 (0x3030, 0x3030, 1),
	|            new Range16 (0x30a0, 0x30a0, 1),
	|            new Range16 (0xfe31, 0xfe32, 1),
	|            new Range16 (0xfe58, 0xfe58, 1),
	|            new Range16 (0xfe63, 0xfe63, 1),
	|            new Range16 (0xff0d, 0xff0d, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10ead, 0x10ead, 1),
	|                },
	|                latinOffset: 1
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Deprecated = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0149, 0x0149, 1),
	|            new Range16 (0x0673, 0x0673, 1),
	|            new Range16 (0x0f77, 0x0f77, 1),
	|            new Range16 (0x0f79, 0x0f79, 1),
	|            new Range16 (0x17a3, 0x17a4, 1),
	|            new Range16 (0x206a, 0x206f, 1),
	|            new Range16 (0x2329, 0x232a, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0xe0001, 0xe0001, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Diacritic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x005e, 0x005e, 1),
	|            new Range16 (0x0060, 0x0060, 1),
	|            new Range16 (0x00a8, 0x00a8, 1),
	|            new Range16 (0x00af, 0x00af, 1),
	|            new Range16 (0x00b4, 0x00b4, 1),
	|            new Range16 (0x00b7, 0x00b8, 1),
	|            new Range16 (0x02b0, 0x034e, 1),
	|            new Range16 (0x0350, 0x0357, 1),
	|            new Range16 (0x035d, 0x0362, 1),
	|            new Range16 (0x0374, 0x0375, 1),
	|            new Range16 (0x037a, 0x037a, 1),
	|            new Range16 (0x0384, 0x0385, 1),
	|            new Range16 (0x0483, 0x0487, 1),
	|            new Range16 (0x0559, 0x0559, 1),
	|            new Range16 (0x0591, 0x05a1, 1),
	|            new Range16 (0x05a3, 0x05bd, 1),
	|            new Range16 (0x05bf, 0x05bf, 1),
	|            new Range16 (0x05c1, 0x05c2, 1),
	|            new Range16 (0x05c4, 0x05c4, 1),
	|            new Range16 (0x064b, 0x0652, 1),
	|            new Range16 (0x0657, 0x0658, 1),
	|            new Range16 (0x06df, 0x06e0, 1),
	|            new Range16 (0x06e5, 0x06e6, 1),
	|            new Range16 (0x06ea, 0x06ec, 1),
	|            new Range16 (0x0730, 0x074a, 1),
	|            new Range16 (0x07a6, 0x07b0, 1),
	|            new Range16 (0x07eb, 0x07f5, 1),
	|            new Range16 (0x0818, 0x0819, 1),
	|            new Range16 (0x0898, 0x089f, 1),
	|            new Range16 (0x08c9, 0x08d2, 1),
	|            new Range16 (0x08e3, 0x08fe, 1),
	|            new Range16 (0x093c, 0x093c, 1),
	|            new Range16 (0x094d, 0x094d, 1),
	|            new Range16 (0x0951, 0x0954, 1),
	|            new Range16 (0x0971, 0x0971, 1),
	|            new Range16 (0x09bc, 0x09bc, 1),
	|            new Range16 (0x09cd, 0x09cd, 1),
	|            new Range16 (0x0a3c, 0x0a3c, 1),
	|            new Range16 (0x0a4d, 0x0a4d, 1),
	|            new Range16 (0x0abc, 0x0abc, 1),
	|            new Range16 (0x0acd, 0x0acd, 1),
	|            new Range16 (0x0afd, 0x0aff, 1),
	|            new Range16 (0x0b3c, 0x0b3c, 1),
	|            new Range16 (0x0b4d, 0x0b4d, 1),
	|            new Range16 (0x0b55, 0x0b55, 1),
	|            new Range16 (0x0bcd, 0x0bcd, 1),
	|            new Range16 (0x0c3c, 0x0c3c, 1),
	|            new Range16 (0x0c4d, 0x0c4d, 1),
	|            new Range16 (0x0cbc, 0x0cbc, 1),
	|            new Range16 (0x0ccd, 0x0ccd, 1),
	|            new Range16 (0x0d3b, 0x0d3c, 1),
	|            new Range16 (0x0d4d, 0x0d4d, 1),
	|            new Range16 (0x0dca, 0x0dca, 1),
	|            new Range16 (0x0e47, 0x0e4c, 1),
	|            new Range16 (0x0e4e, 0x0e4e, 1),
	|            new Range16 (0x0eba, 0x0eba, 1),
	|            new Range16 (0x0ec8, 0x0ecc, 1),
	|            new Range16 (0x0f18, 0x0f19, 1),
	|            new Range16 (0x0f35, 0x0f35, 1),
	|            new Range16 (0x0f37, 0x0f37, 1),
	|            new Range16 (0x0f39, 0x0f39, 1),
	|            new Range16 (0x0f3e, 0x0f3f, 1),
	|            new Range16 (0x0f82, 0x0f84, 1),
	|            new Range16 (0x0f86, 0x0f87, 1),
	|            new Range16 (0x0fc6, 0x0fc6, 1),
	|            new Range16 (0x1037, 0x1037, 1),
	|            new Range16 (0x1039, 0x103a, 1),
	|            new Range16 (0x1063, 0x1064, 1),
	|            new Range16 (0x1069, 0x106d, 1),
	|            new Range16 (0x1087, 0x108d, 1),
	|            new Range16 (0x108f, 0x108f, 1),
	|            new Range16 (0x109a, 0x109b, 1),
	|            new Range16 (0x135d, 0x135f, 1),
	|            new Range16 (0x1714, 0x1715, 1),
	|            new Range16 (0x17c9, 0x17d3, 1),
	|            new Range16 (0x17dd, 0x17dd, 1),
	|            new Range16 (0x1939, 0x193b, 1),
	|            new Range16 (0x1a75, 0x1a7c, 1),
	|            new Range16 (0x1a7f, 0x1a7f, 1),
	|            new Range16 (0x1ab0, 0x1abe, 1),
	|            new Range16 (0x1ac1, 0x1acb, 1),
	|            new Range16 (0x1b34, 0x1b34, 1),
	|            new Range16 (0x1b44, 0x1b44, 1),
	|            new Range16 (0x1b6b, 0x1b73, 1),
	|            new Range16 (0x1baa, 0x1bab, 1),
	|            new Range16 (0x1c36, 0x1c37, 1),
	|            new Range16 (0x1c78, 0x1c7d, 1),
	|            new Range16 (0x1cd0, 0x1ce8, 1),
	|            new Range16 (0x1ced, 0x1ced, 1),
	|            new Range16 (0x1cf4, 0x1cf4, 1),
	|            new Range16 (0x1cf7, 0x1cf9, 1),
	|            new Range16 (0x1d2c, 0x1d6a, 1),
	|            new Range16 (0x1dc4, 0x1dcf, 1),
	|            new Range16 (0x1df5, 0x1dff, 1),
	|            new Range16 (0x1fbd, 0x1fbd, 1),
	|            new Range16 (0x1fbf, 0x1fc1, 1),
	|            new Range16 (0x1fcd, 0x1fcf, 1),
	|            new Range16 (0x1fdd, 0x1fdf, 1),
	|            new Range16 (0x1fed, 0x1fef, 1),
	|            new Range16 (0x1ffd, 0x1ffe, 1),
	|            new Range16 (0x2cef, 0x2cf1, 1),
	|            new Range16 (0x2e2f, 0x2e2f, 1),
	|            new Range16 (0x302a, 0x302f, 1),
	|            new Range16 (0x3099, 0x309c, 1),
	|            new Range16 (0x30fc, 0x30fc, 1),
	|            new Range16 (0xa66f, 0xa66f, 1),
	|            new Range16 (0xa67c, 0xa67d, 1),
	|            new Range16 (0xa67f, 0xa67f, 1),
	|            new Range16 (0xa69c, 0xa69d, 1),
	|            new Range16 (0xa6f0, 0xa6f1, 1),
	|            new Range16 (0xa700, 0xa721, 1),
	|            new Range16 (0xa788, 0xa78a, 1),
	|            new Range16 (0xa7f8, 0xa7f9, 1),
	|            new Range16 (0xa8c4, 0xa8c4, 1),
	|            new Range16 (0xa8e0, 0xa8f1, 1),
	|            new Range16 (0xa92b, 0xa92e, 1),
	|            new Range16 (0xa953, 0xa953, 1),
	|            new Range16 (0xa9b3, 0xa9b3, 1),
	|            new Range16 (0xa9c0, 0xa9c0, 1),
	|            new Range16 (0xa9e5, 0xa9e5, 1),
	|            new Range16 (0xaa7b, 0xaa7d, 1),
	|            new Range16 (0xaabf, 0xaac2, 1),
	|            new Range16 (0xaaf6, 0xaaf6, 1),
	|            new Range16 (0xab5b, 0xab5f, 1),
	|            new Range16 (0xab69, 0xab6b, 1),
	|            new Range16 (0xabec, 0xabed, 1),
	|            new Range16 (0xfb1e, 0xfb1e, 1),
	|            new Range16 (0xfe20, 0xfe2f, 1),
	|            new Range16 (0xff3e, 0xff3e, 1),
	|            new Range16 (0xff40, 0xff40, 1),
	|            new Range16 (0xff70, 0xff70, 1),
	|            new Range16 (0xff9e, 0xff9f, 1),
	|            new Range16 (0xffe3, 0xffe3, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x102e0, 0x102e0, 1),
	|            new Range32 (0x10780, 0x10785, 1),
	|            new Range32 (0x10787, 0x107b0, 1),
	|            new Range32 (0x107b2, 0x107ba, 1),
	|            new Range32 (0x10ae5, 0x10ae6, 1),
	|            new Range32 (0x10d22, 0x10d27, 1),
	|            new Range32 (0x10efd, 0x10eff, 1),
	|            new Range32 (0x10f46, 0x10f50, 1),
	|            new Range32 (0x10f82, 0x10f85, 1),
	|            new Range32 (0x11046, 0x11046, 1),
	|            new Range32 (0x11070, 0x11070, 1),
	|            new Range32 (0x110b9, 0x110ba, 1),
	|            new Range32 (0x11133, 0x11134, 1),
	|            new Range32 (0x11173, 0x11173, 1),
	|            new Range32 (0x111c0, 0x111c0, 1),
	|            new Range32 (0x111ca, 0x111cc, 1),
	|            new Range32 (0x11235, 0x11236, 1),
	|            new Range32 (0x112e9, 0x112ea, 1),
	|            new Range32 (0x1133c, 0x1133c, 1),
	|            new Range32 (0x1134d, 0x1134d, 1),
	|            new Range32 (0x11366, 0x1136c, 1),
	|            new Range32 (0x11370, 0x11374, 1),
	|            new Range32 (0x11442, 0x11442, 1),
	|            new Range32 (0x11446, 0x11446, 1),
	|            new Range32 (0x114c2, 0x114c3, 1),
	|            new Range32 (0x115bf, 0x115c0, 1),
	|            new Range32 (0x1163f, 0x1163f, 1),
	|            new Range32 (0x116b6, 0x116b7, 1),
	|            new Range32 (0x1172b, 0x1172b, 1),
	|            new Range32 (0x11839, 0x1183a, 1),
	|            new Range32 (0x1193d, 0x1193e, 1),
	|            new Range32 (0x11943, 0x11943, 1),
	|            new Range32 (0x119e0, 0x119e0, 1),
	|            new Range32 (0x11a34, 0x11a34, 1),
	|            new Range32 (0x11a47, 0x11a47, 1),
	|            new Range32 (0x11a99, 0x11a99, 1),
	|            new Range32 (0x11c3f, 0x11c3f, 1),
	|            new Range32 (0x11d42, 0x11d42, 1),
	|            new Range32 (0x11d44, 0x11d45, 1),
	|            new Range32 (0x11d97, 0x11d97, 1),
	|            new Range32 (0x13447, 0x13455, 1),
	|            new Range32 (0x16af0, 0x16af4, 1),
	|            new Range32 (0x16b30, 0x16b36, 1),
	|            new Range32 (0x16f8f, 0x16f9f, 1),
	|            new Range32 (0x16ff0, 0x16ff1, 1),
	|            new Range32 (0x1aff0, 0x1aff3, 1),
	|            new Range32 (0x1aff5, 0x1affb, 1),
	|            new Range32 (0x1affd, 0x1affe, 1),
	|            new Range32 (0x1cf00, 0x1cf2d, 1),
	|            new Range32 (0x1cf30, 0x1cf46, 1),
	|            new Range32 (0x1d167, 0x1d169, 1),
	|            new Range32 (0x1d16d, 0x1d172, 1),
	|            new Range32 (0x1d17b, 0x1d182, 1),
	|            new Range32 (0x1d185, 0x1d18b, 1),
	|            new Range32 (0x1d1aa, 0x1d1ad, 1),
	|            new Range32 (0x1e030, 0x1e06d, 1),
	|            new Range32 (0x1e130, 0x1e136, 1),
	|            new Range32 (0x1e2ae, 0x1e2ae, 1),
	|            new Range32 (0x1e2ec, 0x1e2ef, 1),
	|            new Range32 (0x1e8d0, 0x1e8d6, 1),
	|            new Range32 (0x1e944, 0x1e946, 1),
	|            new Range32 (0x1e948, 0x1e94a, 1),
	|                },
	|                latinOffset: 6
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Extender = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00b7, 0x00b7, 1),
	|            new Range16 (0x02d0, 0x02d1, 1),
	|            new Range16 (0x0640, 0x0640, 1),
	|            new Range16 (0x07fa, 0x07fa, 1),
	|            new Range16 (0x0b55, 0x0b55, 1),
	|            new Range16 (0x0e46, 0x0e46, 1),
	|            new Range16 (0x0ec6, 0x0ec6, 1),
	|            new Range16 (0x180a, 0x180a, 1),
	|            new Range16 (0x1843, 0x1843, 1),
	|            new Range16 (0x1aa7, 0x1aa7, 1),
	|            new Range16 (0x1c36, 0x1c36, 1),
	|            new Range16 (0x1c7b, 0x1c7b, 1),
	|            new Range16 (0x3005, 0x3005, 1),
	|            new Range16 (0x3031, 0x3035, 1),
	|            new Range16 (0x309d, 0x309e, 1),
	|            new Range16 (0x30fc, 0x30fe, 1),
	|            new Range16 (0xa015, 0xa015, 1),
	|            new Range16 (0xa60c, 0xa60c, 1),
	|            new Range16 (0xa9cf, 0xa9cf, 1),
	|            new Range16 (0xa9e6, 0xa9e6, 1),
	|            new Range16 (0xaa70, 0xaa70, 1),
	|            new Range16 (0xaadd, 0xaadd, 1),
	|            new Range16 (0xaaf3, 0xaaf4, 1),
	|            new Range16 (0xff70, 0xff70, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10781, 0x10782, 1),
	|            new Range32 (0x1135d, 0x1135d, 1),
	|            new Range32 (0x115c6, 0x115c8, 1),
	|            new Range32 (0x11a98, 0x11a98, 1),
	|            new Range32 (0x16b42, 0x16b43, 1),
	|            new Range32 (0x16fe0, 0x16fe1, 1),
	|            new Range32 (0x16fe3, 0x16fe3, 1),
	|            new Range32 (0x1e13c, 0x1e13d, 1),
	|            new Range32 (0x1e944, 0x1e946, 1),
	|                },
	|                latinOffset: 1
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hex_Digit = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0030, 0x0039, 1),
	|            new Range16 (0x0041, 0x0046, 1),
	|            new Range16 (0x0061, 0x0066, 1),
	|            new Range16 (0xff10, 0xff19, 1),
	|            new Range16 (0xff21, 0xff26, 1),
	|            new Range16 (0xff41, 0xff46, 1),
	|                },
	|                latinOffset: 3
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Hyphen = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x002d, 0x002d, 1),
	|            new Range16 (0x00ad, 0x00ad, 1),
	|            new Range16 (0x058a, 0x058a, 1),
	|            new Range16 (0x1806, 0x1806, 1),
	|            new Range16 (0x2010, 0x2011, 1),
	|            new Range16 (0x2e17, 0x2e17, 1),
	|            new Range16 (0x30fb, 0x30fb, 1),
	|            new Range16 (0xfe63, 0xfe63, 1),
	|            new Range16 (0xff0d, 0xff0d, 1),
	|            new Range16 (0xff65, 0xff65, 1),
	|                },
	|                latinOffset: 2
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _IDS_Binary_Operator = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2ff0, 0x2ff1, 1),
	|            new Range16 (0x2ff4, 0x2ffb, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _IDS_Trinary_Operator = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2ff2, 0x2ff3, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Ideographic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x3006, 0x3007, 1),
	|            new Range16 (0x3021, 0x3029, 1),
	|            new Range16 (0x3038, 0x303a, 1),
	|            new Range16 (0x3400, 0x4dbf, 1),
	|            new Range16 (0x4e00, 0x9fff, 1),
	|            new Range16 (0xf900, 0xfa6d, 1),
	|            new Range16 (0xfa70, 0xfad9, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x16fe4, 0x16fe4, 1),
	|            new Range32 (0x17000, 0x187f7, 1),
	|            new Range32 (0x18800, 0x18cd5, 1),
	|            new Range32 (0x18d00, 0x18d08, 1),
	|            new Range32 (0x1b170, 0x1b2fb, 1),
	|            new Range32 (0x20000, 0x2a6df, 1),
	|            new Range32 (0x2a700, 0x2b739, 1),
	|            new Range32 (0x2b740, 0x2b81d, 1),
	|            new Range32 (0x2b820, 0x2cea1, 1),
	|            new Range32 (0x2ceb0, 0x2ebe0, 1),
	|            new Range32 (0x2f800, 0x2fa1d, 1),
	|            new Range32 (0x30000, 0x3134a, 1),
	|            new Range32 (0x31350, 0x323af, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Join_Control = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x200c, 0x200d, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Logical_Order_Exception = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0e40, 0x0e44, 1),
	|            new Range16 (0x0ec0, 0x0ec4, 1),
	|            new Range16 (0x19b5, 0x19b7, 1),
	|            new Range16 (0x19ba, 0x19ba, 1),
	|            new Range16 (0xaab5, 0xaab6, 1),
	|            new Range16 (0xaab9, 0xaab9, 1),
	|            new Range16 (0xaabb, 0xaabc, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Noncharacter_Code_Point = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0xfdd0, 0xfdef, 1),
	|            new Range16 (0xfffe, 0xffff, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1fffe, 0x1ffff, 1),
	|            new Range32 (0x2fffe, 0x2ffff, 1),
	|            new Range32 (0x3fffe, 0x3ffff, 1),
	|            new Range32 (0x4fffe, 0x4ffff, 1),
	|            new Range32 (0x5fffe, 0x5ffff, 1),
	|            new Range32 (0x6fffe, 0x6ffff, 1),
	|            new Range32 (0x7fffe, 0x7ffff, 1),
	|            new Range32 (0x8fffe, 0x8ffff, 1),
	|            new Range32 (0x9fffe, 0x9ffff, 1),
	|            new Range32 (0xafffe, 0xaffff, 1),
	|            new Range32 (0xbfffe, 0xbffff, 1),
	|            new Range32 (0xcfffe, 0xcffff, 1),
	|            new Range32 (0xdfffe, 0xdffff, 1),
	|            new Range32 (0xefffe, 0xeffff, 1),
	|            new Range32 (0xffffe, 0xfffff, 1),
	|            new Range32 (0x10fffe, 0x10ffff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_Alphabetic = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0345, 0x0345, 1),
	|            new Range16 (0x05b0, 0x05bd, 1),
	|            new Range16 (0x05bf, 0x05bf, 1),
	|            new Range16 (0x05c1, 0x05c2, 1),
	|            new Range16 (0x05c4, 0x05c5, 1),
	|            new Range16 (0x05c7, 0x05c7, 1),
	|            new Range16 (0x0610, 0x061a, 1),
	|            new Range16 (0x064b, 0x0657, 1),
	|            new Range16 (0x0659, 0x065f, 1),
	|            new Range16 (0x0670, 0x0670, 1),
	|            new Range16 (0x06d6, 0x06dc, 1),
	|            new Range16 (0x06e1, 0x06e4, 1),
	|            new Range16 (0x06e7, 0x06e8, 1),
	|            new Range16 (0x06ed, 0x06ed, 1),
	|            new Range16 (0x0711, 0x0711, 1),
	|            new Range16 (0x0730, 0x073f, 1),
	|            new Range16 (0x07a6, 0x07b0, 1),
	|            new Range16 (0x0816, 0x0817, 1),
	|            new Range16 (0x081b, 0x0823, 1),
	|            new Range16 (0x0825, 0x0827, 1),
	|            new Range16 (0x0829, 0x082c, 1),
	|            new Range16 (0x08d4, 0x08df, 1),
	|            new Range16 (0x08e3, 0x08e9, 1),
	|            new Range16 (0x08f0, 0x0903, 1),
	|            new Range16 (0x093a, 0x093b, 1),
	|            new Range16 (0x093e, 0x094c, 1),
	|            new Range16 (0x094e, 0x094f, 1),
	|            new Range16 (0x0955, 0x0957, 1),
	|            new Range16 (0x0962, 0x0963, 1),
	|            new Range16 (0x0981, 0x0983, 1),
	|            new Range16 (0x09be, 0x09c4, 1),
	|            new Range16 (0x09c7, 0x09c8, 1),
	|            new Range16 (0x09cb, 0x09cc, 1),
	|            new Range16 (0x09d7, 0x09d7, 1),
	|            new Range16 (0x09e2, 0x09e3, 1),
	|            new Range16 (0x0a01, 0x0a03, 1),
	|            new Range16 (0x0a3e, 0x0a42, 1),
	|            new Range16 (0x0a47, 0x0a48, 1),
	|            new Range16 (0x0a4b, 0x0a4c, 1),
	|            new Range16 (0x0a51, 0x0a51, 1),
	|            new Range16 (0x0a70, 0x0a71, 1),
	|            new Range16 (0x0a75, 0x0a75, 1),
	|            new Range16 (0x0a81, 0x0a83, 1),
	|            new Range16 (0x0abe, 0x0ac5, 1),
	|            new Range16 (0x0ac7, 0x0ac9, 1),
	|            new Range16 (0x0acb, 0x0acc, 1),
	|            new Range16 (0x0ae2, 0x0ae3, 1),
	|            new Range16 (0x0afa, 0x0afc, 1),
	|            new Range16 (0x0b01, 0x0b03, 1),
	|            new Range16 (0x0b3e, 0x0b44, 1),
	|            new Range16 (0x0b47, 0x0b48, 1),
	|            new Range16 (0x0b4b, 0x0b4c, 1),
	|            new Range16 (0x0b56, 0x0b57, 1),
	|            new Range16 (0x0b62, 0x0b63, 1),
	|            new Range16 (0x0b82, 0x0b82, 1),
	|            new Range16 (0x0bbe, 0x0bc2, 1),
	|            new Range16 (0x0bc6, 0x0bc8, 1),
	|            new Range16 (0x0bca, 0x0bcc, 1),
	|            new Range16 (0x0bd7, 0x0bd7, 1),
	|            new Range16 (0x0c00, 0x0c04, 1),
	|            new Range16 (0x0c3e, 0x0c44, 1),
	|            new Range16 (0x0c46, 0x0c48, 1),
	|            new Range16 (0x0c4a, 0x0c4c, 1),
	|            new Range16 (0x0c55, 0x0c56, 1),
	|            new Range16 (0x0c62, 0x0c63, 1),
	|            new Range16 (0x0c81, 0x0c83, 1),
	|            new Range16 (0x0cbe, 0x0cc4, 1),
	|            new Range16 (0x0cc6, 0x0cc8, 1),
	|            new Range16 (0x0cca, 0x0ccc, 1),
	|            new Range16 (0x0cd5, 0x0cd6, 1),
	|            new Range16 (0x0ce2, 0x0ce3, 1),
	|            new Range16 (0x0cf3, 0x0cf3, 1),
	|            new Range16 (0x0d00, 0x0d03, 1),
	|            new Range16 (0x0d3e, 0x0d44, 1),
	|            new Range16 (0x0d46, 0x0d48, 1),
	|            new Range16 (0x0d4a, 0x0d4c, 1),
	|            new Range16 (0x0d57, 0x0d57, 1),
	|            new Range16 (0x0d62, 0x0d63, 1),
	|            new Range16 (0x0d81, 0x0d83, 1),
	|            new Range16 (0x0dcf, 0x0dd4, 1),
	|            new Range16 (0x0dd6, 0x0dd6, 1),
	|            new Range16 (0x0dd8, 0x0ddf, 1),
	|            new Range16 (0x0df2, 0x0df3, 1),
	|            new Range16 (0x0e31, 0x0e31, 1),
	|            new Range16 (0x0e34, 0x0e3a, 1),
	|            new Range16 (0x0e4d, 0x0e4d, 1),
	|            new Range16 (0x0eb1, 0x0eb1, 1),
	|            new Range16 (0x0eb4, 0x0eb9, 1),
	|            new Range16 (0x0ebb, 0x0ebc, 1),
	|            new Range16 (0x0ecd, 0x0ecd, 1),
	|            new Range16 (0x0f71, 0x0f83, 1),
	|            new Range16 (0x0f8d, 0x0f97, 1),
	|            new Range16 (0x0f99, 0x0fbc, 1),
	|            new Range16 (0x102b, 0x1036, 1),
	|            new Range16 (0x1038, 0x1038, 1),
	|            new Range16 (0x103b, 0x103e, 1),
	|            new Range16 (0x1056, 0x1059, 1),
	|            new Range16 (0x105e, 0x1060, 1),
	|            new Range16 (0x1062, 0x1064, 1),
	|            new Range16 (0x1067, 0x106d, 1),
	|            new Range16 (0x1071, 0x1074, 1),
	|            new Range16 (0x1082, 0x108d, 1),
	|            new Range16 (0x108f, 0x108f, 1),
	|            new Range16 (0x109a, 0x109d, 1),
	|            new Range16 (0x1712, 0x1713, 1),
	|            new Range16 (0x1732, 0x1733, 1),
	|            new Range16 (0x1752, 0x1753, 1),
	|            new Range16 (0x1772, 0x1773, 1),
	|            new Range16 (0x17b6, 0x17c8, 1),
	|            new Range16 (0x1885, 0x1886, 1),
	|            new Range16 (0x18a9, 0x18a9, 1),
	|            new Range16 (0x1920, 0x192b, 1),
	|            new Range16 (0x1930, 0x1938, 1),
	|            new Range16 (0x1a17, 0x1a1b, 1),
	|            new Range16 (0x1a55, 0x1a5e, 1),
	|            new Range16 (0x1a61, 0x1a74, 1),
	|            new Range16 (0x1abf, 0x1ac0, 1),
	|            new Range16 (0x1acc, 0x1ace, 1),
	|            new Range16 (0x1b00, 0x1b04, 1),
	|            new Range16 (0x1b35, 0x1b43, 1),
	|            new Range16 (0x1b80, 0x1b82, 1),
	|            new Range16 (0x1ba1, 0x1ba9, 1),
	|            new Range16 (0x1bac, 0x1bad, 1),
	|            new Range16 (0x1be7, 0x1bf1, 1),
	|            new Range16 (0x1c24, 0x1c36, 1),
	|            new Range16 (0x1de7, 0x1df4, 1),
	|            new Range16 (0x24b6, 0x24e9, 1),
	|            new Range16 (0x2de0, 0x2dff, 1),
	|            new Range16 (0xa674, 0xa67b, 1),
	|            new Range16 (0xa69e, 0xa69f, 1),
	|            new Range16 (0xa802, 0xa802, 1),
	|            new Range16 (0xa80b, 0xa80b, 1),
	|            new Range16 (0xa823, 0xa827, 1),
	|            new Range16 (0xa880, 0xa881, 1),
	|            new Range16 (0xa8b4, 0xa8c3, 1),
	|            new Range16 (0xa8c5, 0xa8c5, 1),
	|            new Range16 (0xa8ff, 0xa8ff, 1),
	|            new Range16 (0xa926, 0xa92a, 1),
	|            new Range16 (0xa947, 0xa952, 1),
	|            new Range16 (0xa980, 0xa983, 1),
	|            new Range16 (0xa9b4, 0xa9bf, 1),
	|            new Range16 (0xa9e5, 0xa9e5, 1),
	|            new Range16 (0xaa29, 0xaa36, 1),
	|            new Range16 (0xaa43, 0xaa43, 1),
	|            new Range16 (0xaa4c, 0xaa4d, 1),
	|            new Range16 (0xaa7b, 0xaa7d, 1),
	|            new Range16 (0xaab0, 0xaab0, 1),
	|            new Range16 (0xaab2, 0xaab4, 1),
	|            new Range16 (0xaab7, 0xaab8, 1),
	|            new Range16 (0xaabe, 0xaabe, 1),
	|            new Range16 (0xaaeb, 0xaaef, 1),
	|            new Range16 (0xaaf5, 0xaaf5, 1),
	|            new Range16 (0xabe3, 0xabea, 1),
	|            new Range16 (0xfb1e, 0xfb1e, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10376, 0x1037a, 1),
	|            new Range32 (0x10a01, 0x10a03, 1),
	|            new Range32 (0x10a05, 0x10a06, 1),
	|            new Range32 (0x10a0c, 0x10a0f, 1),
	|            new Range32 (0x10d24, 0x10d27, 1),
	|            new Range32 (0x10eab, 0x10eac, 1),
	|            new Range32 (0x11000, 0x11002, 1),
	|            new Range32 (0x11038, 0x11045, 1),
	|            new Range32 (0x11073, 0x11074, 1),
	|            new Range32 (0x11080, 0x11082, 1),
	|            new Range32 (0x110b0, 0x110b8, 1),
	|            new Range32 (0x110c2, 0x110c2, 1),
	|            new Range32 (0x11100, 0x11102, 1),
	|            new Range32 (0x11127, 0x11132, 1),
	|            new Range32 (0x11145, 0x11146, 1),
	|            new Range32 (0x11180, 0x11182, 1),
	|            new Range32 (0x111b3, 0x111bf, 1),
	|            new Range32 (0x111ce, 0x111cf, 1),
	|            new Range32 (0x1122c, 0x11234, 1),
	|            new Range32 (0x11237, 0x11237, 1),
	|            new Range32 (0x1123e, 0x1123e, 1),
	|            new Range32 (0x11241, 0x11241, 1),
	|            new Range32 (0x112df, 0x112e8, 1),
	|            new Range32 (0x11300, 0x11303, 1),
	|            new Range32 (0x1133e, 0x11344, 1),
	|            new Range32 (0x11347, 0x11348, 1),
	|            new Range32 (0x1134b, 0x1134c, 1),
	|            new Range32 (0x11357, 0x11357, 1),
	|            new Range32 (0x11362, 0x11363, 1),
	|            new Range32 (0x11435, 0x11441, 1),
	|            new Range32 (0x11443, 0x11445, 1),
	|            new Range32 (0x114b0, 0x114c1, 1),
	|            new Range32 (0x115af, 0x115b5, 1),
	|            new Range32 (0x115b8, 0x115be, 1),
	|            new Range32 (0x115dc, 0x115dd, 1),
	|            new Range32 (0x11630, 0x1163e, 1),
	|            new Range32 (0x11640, 0x11640, 1),
	|            new Range32 (0x116ab, 0x116b5, 1),
	|            new Range32 (0x1171d, 0x1172a, 1),
	|            new Range32 (0x1182c, 0x11838, 1),
	|            new Range32 (0x11930, 0x11935, 1),
	|            new Range32 (0x11937, 0x11938, 1),
	|            new Range32 (0x1193b, 0x1193c, 1),
	|            new Range32 (0x11940, 0x11940, 1),
	|            new Range32 (0x11942, 0x11942, 1),
	|            new Range32 (0x119d1, 0x119d7, 1),
	|            new Range32 (0x119da, 0x119df, 1),
	|            new Range32 (0x119e4, 0x119e4, 1),
	|            new Range32 (0x11a01, 0x11a0a, 1),
	|            new Range32 (0x11a35, 0x11a39, 1),
	|            new Range32 (0x11a3b, 0x11a3e, 1),
	|            new Range32 (0x11a51, 0x11a5b, 1),
	|            new Range32 (0x11a8a, 0x11a97, 1),
	|            new Range32 (0x11c2f, 0x11c36, 1),
	|            new Range32 (0x11c38, 0x11c3e, 1),
	|            new Range32 (0x11c92, 0x11ca7, 1),
	|            new Range32 (0x11ca9, 0x11cb6, 1),
	|            new Range32 (0x11d31, 0x11d36, 1),
	|            new Range32 (0x11d3a, 0x11d3a, 1),
	|            new Range32 (0x11d3c, 0x11d3d, 1),
	|            new Range32 (0x11d3f, 0x11d41, 1),
	|            new Range32 (0x11d43, 0x11d43, 1),
	|            new Range32 (0x11d47, 0x11d47, 1),
	|            new Range32 (0x11d8a, 0x11d8e, 1),
	|            new Range32 (0x11d90, 0x11d91, 1),
	|            new Range32 (0x11d93, 0x11d96, 1),
	|            new Range32 (0x11ef3, 0x11ef6, 1),
	|            new Range32 (0x11f00, 0x11f01, 1),
	|            new Range32 (0x11f03, 0x11f03, 1),
	|            new Range32 (0x11f34, 0x11f3a, 1),
	|            new Range32 (0x11f3e, 0x11f40, 1),
	|            new Range32 (0x16f4f, 0x16f4f, 1),
	|            new Range32 (0x16f51, 0x16f87, 1),
	|            new Range32 (0x16f8f, 0x16f92, 1),
	|            new Range32 (0x16ff0, 0x16ff1, 1),
	|            new Range32 (0x1bc9e, 0x1bc9e, 1),
	|            new Range32 (0x1e000, 0x1e006, 1),
	|            new Range32 (0x1e008, 0x1e018, 1),
	|            new Range32 (0x1e01b, 0x1e021, 1),
	|            new Range32 (0x1e023, 0x1e024, 1),
	|            new Range32 (0x1e026, 0x1e02a, 1),
	|            new Range32 (0x1e08f, 0x1e08f, 1),
	|            new Range32 (0x1e947, 0x1e947, 1),
	|            new Range32 (0x1f130, 0x1f149, 1),
	|            new Range32 (0x1f150, 0x1f169, 1),
	|            new Range32 (0x1f170, 0x1f189, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_Default_Ignorable_Code_Point = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x034f, 0x034f, 1),
	|            new Range16 (0x115f, 0x1160, 1),
	|            new Range16 (0x17b4, 0x17b5, 1),
	|            new Range16 (0x2065, 0x2065, 1),
	|            new Range16 (0x3164, 0x3164, 1),
	|            new Range16 (0xffa0, 0xffa0, 1),
	|            new Range16 (0xfff0, 0xfff8, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0xe0000, 0xe0000, 1),
	|            new Range32 (0xe0002, 0xe001f, 1),
	|            new Range32 (0xe0080, 0xe00ff, 1),
	|            new Range32 (0xe01f0, 0xe0fff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_Grapheme_Extend = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x09be, 0x09be, 1),
	|            new Range16 (0x09d7, 0x09d7, 1),
	|            new Range16 (0x0b3e, 0x0b3e, 1),
	|            new Range16 (0x0b57, 0x0b57, 1),
	|            new Range16 (0x0bbe, 0x0bbe, 1),
	|            new Range16 (0x0bd7, 0x0bd7, 1),
	|            new Range16 (0x0cc2, 0x0cc2, 1),
	|            new Range16 (0x0cd5, 0x0cd6, 1),
	|            new Range16 (0x0d3e, 0x0d3e, 1),
	|            new Range16 (0x0d57, 0x0d57, 1),
	|            new Range16 (0x0dcf, 0x0dcf, 1),
	|            new Range16 (0x0ddf, 0x0ddf, 1),
	|            new Range16 (0x1b35, 0x1b35, 1),
	|            new Range16 (0x200c, 0x200c, 1),
	|            new Range16 (0x302e, 0x302f, 1),
	|            new Range16 (0xff9e, 0xff9f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1133e, 0x1133e, 1),
	|            new Range32 (0x11357, 0x11357, 1),
	|            new Range32 (0x114b0, 0x114b0, 1),
	|            new Range32 (0x114bd, 0x114bd, 1),
	|            new Range32 (0x115af, 0x115af, 1),
	|            new Range32 (0x11930, 0x11930, 1),
	|            new Range32 (0x1d165, 0x1d165, 1),
	|            new Range32 (0x1d16e, 0x1d172, 1),
	|            new Range32 (0xe0020, 0xe007f, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_ID_Continue = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00b7, 0x00b7, 1),
	|            new Range16 (0x0387, 0x0387, 1),
	|            new Range16 (0x1369, 0x1371, 1),
	|            new Range16 (0x19da, 0x19da, 1),
	|                },
	|                latinOffset: 1
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_ID_Start = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x1885, 0x1886, 1),
	|            new Range16 (0x2118, 0x2118, 1),
	|            new Range16 (0x212e, 0x212e, 1),
	|            new Range16 (0x309b, 0x309c, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_Lowercase = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x00aa, 0x00aa, 1),
	|            new Range16 (0x00ba, 0x00ba, 1),
	|            new Range16 (0x02b0, 0x02b8, 1),
	|            new Range16 (0x02c0, 0x02c1, 1),
	|            new Range16 (0x02e0, 0x02e4, 1),
	|            new Range16 (0x0345, 0x0345, 1),
	|            new Range16 (0x037a, 0x037a, 1),
	|            new Range16 (0x10fc, 0x10fc, 1),
	|            new Range16 (0x1d2c, 0x1d6a, 1),
	|            new Range16 (0x1d78, 0x1d78, 1),
	|            new Range16 (0x1d9b, 0x1dbf, 1),
	|            new Range16 (0x2071, 0x2071, 1),
	|            new Range16 (0x207f, 0x207f, 1),
	|            new Range16 (0x2090, 0x209c, 1),
	|            new Range16 (0x2170, 0x217f, 1),
	|            new Range16 (0x24d0, 0x24e9, 1),
	|            new Range16 (0x2c7c, 0x2c7d, 1),
	|            new Range16 (0xa69c, 0xa69d, 1),
	|            new Range16 (0xa770, 0xa770, 1),
	|            new Range16 (0xa7f2, 0xa7f4, 1),
	|            new Range16 (0xa7f8, 0xa7f9, 1),
	|            new Range16 (0xab5c, 0xab5f, 1),
	|            new Range16 (0xab69, 0xab69, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10780, 0x10780, 1),
	|            new Range32 (0x10783, 0x10785, 1),
	|            new Range32 (0x10787, 0x107b0, 1),
	|            new Range32 (0x107b2, 0x107ba, 1),
	|            new Range32 (0x1e030, 0x1e06d, 1),
	|                },
	|                latinOffset: 2
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_Math = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x005e, 0x005e, 1),
	|            new Range16 (0x03d0, 0x03d2, 1),
	|            new Range16 (0x03d5, 0x03d5, 1),
	|            new Range16 (0x03f0, 0x03f1, 1),
	|            new Range16 (0x03f4, 0x03f5, 1),
	|            new Range16 (0x2016, 0x2016, 1),
	|            new Range16 (0x2032, 0x2034, 1),
	|            new Range16 (0x2040, 0x2040, 1),
	|            new Range16 (0x2061, 0x2064, 1),
	|            new Range16 (0x207d, 0x207e, 1),
	|            new Range16 (0x208d, 0x208e, 1),
	|            new Range16 (0x20d0, 0x20dc, 1),
	|            new Range16 (0x20e1, 0x20e1, 1),
	|            new Range16 (0x20e5, 0x20e6, 1),
	|            new Range16 (0x20eb, 0x20ef, 1),
	|            new Range16 (0x2102, 0x2102, 1),
	|            new Range16 (0x2107, 0x2107, 1),
	|            new Range16 (0x210a, 0x2113, 1),
	|            new Range16 (0x2115, 0x2115, 1),
	|            new Range16 (0x2119, 0x211d, 1),
	|            new Range16 (0x2124, 0x2124, 1),
	|            new Range16 (0x2128, 0x2129, 1),
	|            new Range16 (0x212c, 0x212d, 1),
	|            new Range16 (0x212f, 0x2131, 1),
	|            new Range16 (0x2133, 0x2138, 1),
	|            new Range16 (0x213c, 0x213f, 1),
	|            new Range16 (0x2145, 0x2149, 1),
	|            new Range16 (0x2195, 0x2199, 1),
	|            new Range16 (0x219c, 0x219f, 1),
	|            new Range16 (0x21a1, 0x21a2, 1),
	|            new Range16 (0x21a4, 0x21a5, 1),
	|            new Range16 (0x21a7, 0x21a7, 1),
	|            new Range16 (0x21a9, 0x21ad, 1),
	|            new Range16 (0x21b0, 0x21b1, 1),
	|            new Range16 (0x21b6, 0x21b7, 1),
	|            new Range16 (0x21bc, 0x21cd, 1),
	|            new Range16 (0x21d0, 0x21d1, 1),
	|            new Range16 (0x21d3, 0x21d3, 1),
	|            new Range16 (0x21d5, 0x21db, 1),
	|            new Range16 (0x21dd, 0x21dd, 1),
	|            new Range16 (0x21e4, 0x21e5, 1),
	|            new Range16 (0x2308, 0x230b, 1),
	|            new Range16 (0x23b4, 0x23b5, 1),
	|            new Range16 (0x23b7, 0x23b7, 1),
	|            new Range16 (0x23d0, 0x23d0, 1),
	|            new Range16 (0x23e2, 0x23e2, 1),
	|            new Range16 (0x25a0, 0x25a1, 1),
	|            new Range16 (0x25ae, 0x25b6, 1),
	|            new Range16 (0x25bc, 0x25c0, 1),
	|            new Range16 (0x25c6, 0x25c7, 1),
	|            new Range16 (0x25ca, 0x25cb, 1),
	|            new Range16 (0x25cf, 0x25d3, 1),
	|            new Range16 (0x25e2, 0x25e2, 1),
	|            new Range16 (0x25e4, 0x25e4, 1),
	|            new Range16 (0x25e7, 0x25ec, 1),
	|            new Range16 (0x2605, 0x2606, 1),
	|            new Range16 (0x2640, 0x2640, 1),
	|            new Range16 (0x2642, 0x2642, 1),
	|            new Range16 (0x2660, 0x2663, 1),
	|            new Range16 (0x266d, 0x266e, 1),
	|            new Range16 (0x27c5, 0x27c6, 1),
	|            new Range16 (0x27e6, 0x27ef, 1),
	|            new Range16 (0x2983, 0x2998, 1),
	|            new Range16 (0x29d8, 0x29db, 1),
	|            new Range16 (0x29fc, 0x29fd, 1),
	|            new Range16 (0xfe61, 0xfe61, 1),
	|            new Range16 (0xfe63, 0xfe63, 1),
	|            new Range16 (0xfe68, 0xfe68, 1),
	|            new Range16 (0xff3c, 0xff3c, 1),
	|            new Range16 (0xff3e, 0xff3e, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1d400, 0x1d454, 1),
	|            new Range32 (0x1d456, 0x1d49c, 1),
	|            new Range32 (0x1d49e, 0x1d49f, 1),
	|            new Range32 (0x1d4a2, 0x1d4a2, 1),
	|            new Range32 (0x1d4a5, 0x1d4a6, 1),
	|            new Range32 (0x1d4a9, 0x1d4ac, 1),
	|            new Range32 (0x1d4ae, 0x1d4b9, 1),
	|            new Range32 (0x1d4bb, 0x1d4bb, 1),
	|            new Range32 (0x1d4bd, 0x1d4c3, 1),
	|            new Range32 (0x1d4c5, 0x1d505, 1),
	|            new Range32 (0x1d507, 0x1d50a, 1),
	|            new Range32 (0x1d50d, 0x1d514, 1),
	|            new Range32 (0x1d516, 0x1d51c, 1),
	|            new Range32 (0x1d51e, 0x1d539, 1),
	|            new Range32 (0x1d53b, 0x1d53e, 1),
	|            new Range32 (0x1d540, 0x1d544, 1),
	|            new Range32 (0x1d546, 0x1d546, 1),
	|            new Range32 (0x1d54a, 0x1d550, 1),
	|            new Range32 (0x1d552, 0x1d6a5, 1),
	|            new Range32 (0x1d6a8, 0x1d6c0, 1),
	|            new Range32 (0x1d6c2, 0x1d6da, 1),
	|            new Range32 (0x1d6dc, 0x1d6fa, 1),
	|            new Range32 (0x1d6fc, 0x1d714, 1),
	|            new Range32 (0x1d716, 0x1d734, 1),
	|            new Range32 (0x1d736, 0x1d74e, 1),
	|            new Range32 (0x1d750, 0x1d76e, 1),
	|            new Range32 (0x1d770, 0x1d788, 1),
	|            new Range32 (0x1d78a, 0x1d7a8, 1),
	|            new Range32 (0x1d7aa, 0x1d7c2, 1),
	|            new Range32 (0x1d7c4, 0x1d7cb, 1),
	|            new Range32 (0x1d7ce, 0x1d7ff, 1),
	|            new Range32 (0x1ee00, 0x1ee03, 1),
	|            new Range32 (0x1ee05, 0x1ee1f, 1),
	|            new Range32 (0x1ee21, 0x1ee22, 1),
	|            new Range32 (0x1ee24, 0x1ee24, 1),
	|            new Range32 (0x1ee27, 0x1ee27, 1),
	|            new Range32 (0x1ee29, 0x1ee32, 1),
	|            new Range32 (0x1ee34, 0x1ee37, 1),
	|            new Range32 (0x1ee39, 0x1ee39, 1),
	|            new Range32 (0x1ee3b, 0x1ee3b, 1),
	|            new Range32 (0x1ee42, 0x1ee42, 1),
	|            new Range32 (0x1ee47, 0x1ee47, 1),
	|            new Range32 (0x1ee49, 0x1ee49, 1),
	|            new Range32 (0x1ee4b, 0x1ee4b, 1),
	|            new Range32 (0x1ee4d, 0x1ee4f, 1),
	|            new Range32 (0x1ee51, 0x1ee52, 1),
	|            new Range32 (0x1ee54, 0x1ee54, 1),
	|            new Range32 (0x1ee57, 0x1ee57, 1),
	|            new Range32 (0x1ee59, 0x1ee59, 1),
	|            new Range32 (0x1ee5b, 0x1ee5b, 1),
	|            new Range32 (0x1ee5d, 0x1ee5d, 1),
	|            new Range32 (0x1ee5f, 0x1ee5f, 1),
	|            new Range32 (0x1ee61, 0x1ee62, 1),
	|            new Range32 (0x1ee64, 0x1ee64, 1),
	|            new Range32 (0x1ee67, 0x1ee6a, 1),
	|            new Range32 (0x1ee6c, 0x1ee72, 1),
	|            new Range32 (0x1ee74, 0x1ee77, 1),
	|            new Range32 (0x1ee79, 0x1ee7c, 1),
	|            new Range32 (0x1ee7e, 0x1ee7e, 1),
	|            new Range32 (0x1ee80, 0x1ee89, 1),
	|            new Range32 (0x1ee8b, 0x1ee9b, 1),
	|            new Range32 (0x1eea1, 0x1eea3, 1),
	|            new Range32 (0x1eea5, 0x1eea9, 1),
	|            new Range32 (0x1eeab, 0x1eebb, 1),
	|                },
	|                latinOffset: 1
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Other_Uppercase = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2160, 0x216f, 1),
	|            new Range16 (0x24b6, 0x24cf, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1f130, 0x1f149, 1),
	|            new Range32 (0x1f150, 0x1f169, 1),
	|            new Range32 (0x1f170, 0x1f189, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Pattern_Syntax = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0021, 0x002f, 1),
	|            new Range16 (0x003a, 0x0040, 1),
	|            new Range16 (0x005b, 0x005e, 1),
	|            new Range16 (0x0060, 0x0060, 1),
	|            new Range16 (0x007b, 0x007e, 1),
	|            new Range16 (0x00a1, 0x00a7, 1),
	|            new Range16 (0x00a9, 0x00a9, 1),
	|            new Range16 (0x00ab, 0x00ac, 1),
	|            new Range16 (0x00ae, 0x00ae, 1),
	|            new Range16 (0x00b0, 0x00b1, 1),
	|            new Range16 (0x00b6, 0x00b6, 1),
	|            new Range16 (0x00bb, 0x00bb, 1),
	|            new Range16 (0x00bf, 0x00bf, 1),
	|            new Range16 (0x00d7, 0x00d7, 1),
	|            new Range16 (0x00f7, 0x00f7, 1),
	|            new Range16 (0x2010, 0x2027, 1),
	|            new Range16 (0x2030, 0x203e, 1),
	|            new Range16 (0x2041, 0x2053, 1),
	|            new Range16 (0x2055, 0x205e, 1),
	|            new Range16 (0x2190, 0x245f, 1),
	|            new Range16 (0x2500, 0x2775, 1),
	|            new Range16 (0x2794, 0x2bff, 1),
	|            new Range16 (0x2e00, 0x2e7f, 1),
	|            new Range16 (0x3001, 0x3003, 1),
	|            new Range16 (0x3008, 0x3020, 1),
	|            new Range16 (0x3030, 0x3030, 1),
	|            new Range16 (0xfd3e, 0xfd3f, 1),
	|            new Range16 (0xfe45, 0xfe46, 1),
	|                },
	|                latinOffset: 15
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Pattern_White_Space = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0009, 0x000d, 1),
	|            new Range16 (0x0020, 0x0020, 1),
	|            new Range16 (0x0085, 0x0085, 1),
	|            new Range16 (0x200e, 0x200f, 1),
	|            new Range16 (0x2028, 0x2029, 1),
	|                },
	|                latinOffset: 3
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Prepended_Concatenation_Mark = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0600, 0x0605, 1),
	|            new Range16 (0x06dd, 0x06dd, 1),
	|            new Range16 (0x070f, 0x070f, 1),
	|            new Range16 (0x0890, 0x0891, 1),
	|            new Range16 (0x08e2, 0x08e2, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x110bd, 0x110bd, 1),
	|            new Range32 (0x110cd, 0x110cd, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Quotation_Mark = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0022, 0x0022, 1),
	|            new Range16 (0x0027, 0x0027, 1),
	|            new Range16 (0x00ab, 0x00ab, 1),
	|            new Range16 (0x00bb, 0x00bb, 1),
	|            new Range16 (0x2018, 0x201f, 1),
	|            new Range16 (0x2039, 0x203a, 1),
	|            new Range16 (0x2e42, 0x2e42, 1),
	|            new Range16 (0x300c, 0x300f, 1),
	|            new Range16 (0x301d, 0x301f, 1),
	|            new Range16 (0xfe41, 0xfe44, 1),
	|            new Range16 (0xff02, 0xff02, 1),
	|            new Range16 (0xff07, 0xff07, 1),
	|            new Range16 (0xff62, 0xff63, 1),
	|                },
	|                latinOffset: 4
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Radical = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x2e80, 0x2e99, 1),
	|            new Range16 (0x2e9b, 0x2ef3, 1),
	|            new Range16 (0x2f00, 0x2fd5, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Regional_Indicator = new RangeTable(
	|                r16: new Range16[] {
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1f1e6, 0x1f1ff, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Sentence_Terminal = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0021, 0x0021, 1),
	|            new Range16 (0x002e, 0x002e, 1),
	|            new Range16 (0x003f, 0x003f, 1),
	|            new Range16 (0x0589, 0x0589, 1),
	|            new Range16 (0x061d, 0x061f, 1),
	|            new Range16 (0x06d4, 0x06d4, 1),
	|            new Range16 (0x0700, 0x0702, 1),
	|            new Range16 (0x07f9, 0x07f9, 1),
	|            new Range16 (0x0837, 0x0837, 1),
	|            new Range16 (0x0839, 0x0839, 1),
	|            new Range16 (0x083d, 0x083e, 1),
	|            new Range16 (0x0964, 0x0965, 1),
	|            new Range16 (0x104a, 0x104b, 1),
	|            new Range16 (0x1362, 0x1362, 1),
	|            new Range16 (0x1367, 0x1368, 1),
	|            new Range16 (0x166e, 0x166e, 1),
	|            new Range16 (0x1735, 0x1736, 1),
	|            new Range16 (0x1803, 0x1803, 1),
	|            new Range16 (0x1809, 0x1809, 1),
	|            new Range16 (0x1944, 0x1945, 1),
	|            new Range16 (0x1aa8, 0x1aab, 1),
	|            new Range16 (0x1b5a, 0x1b5b, 1),
	|            new Range16 (0x1b5e, 0x1b5f, 1),
	|            new Range16 (0x1b7d, 0x1b7e, 1),
	|            new Range16 (0x1c3b, 0x1c3c, 1),
	|            new Range16 (0x1c7e, 0x1c7f, 1),
	|            new Range16 (0x203c, 0x203d, 1),
	|            new Range16 (0x2047, 0x2049, 1),
	|            new Range16 (0x2e2e, 0x2e2e, 1),
	|            new Range16 (0x2e3c, 0x2e3c, 1),
	|            new Range16 (0x2e53, 0x2e54, 1),
	|            new Range16 (0x3002, 0x3002, 1),
	|            new Range16 (0xa4ff, 0xa4ff, 1),
	|            new Range16 (0xa60e, 0xa60f, 1),
	|            new Range16 (0xa6f3, 0xa6f3, 1),
	|            new Range16 (0xa6f7, 0xa6f7, 1),
	|            new Range16 (0xa876, 0xa877, 1),
	|            new Range16 (0xa8ce, 0xa8cf, 1),
	|            new Range16 (0xa92f, 0xa92f, 1),
	|            new Range16 (0xa9c8, 0xa9c9, 1),
	|            new Range16 (0xaa5d, 0xaa5f, 1),
	|            new Range16 (0xaaf0, 0xaaf1, 1),
	|            new Range16 (0xabeb, 0xabeb, 1),
	|            new Range16 (0xfe52, 0xfe52, 1),
	|            new Range16 (0xfe56, 0xfe57, 1),
	|            new Range16 (0xff01, 0xff01, 1),
	|            new Range16 (0xff0e, 0xff0e, 1),
	|            new Range16 (0xff1f, 0xff1f, 1),
	|            new Range16 (0xff61, 0xff61, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x10a56, 0x10a57, 1),
	|            new Range32 (0x10f55, 0x10f59, 1),
	|            new Range32 (0x10f86, 0x10f89, 1),
	|            new Range32 (0x11047, 0x11048, 1),
	|            new Range32 (0x110be, 0x110c1, 1),
	|            new Range32 (0x11141, 0x11143, 1),
	|            new Range32 (0x111c5, 0x111c6, 1),
	|            new Range32 (0x111cd, 0x111cd, 1),
	|            new Range32 (0x111de, 0x111df, 1),
	|            new Range32 (0x11238, 0x11239, 1),
	|            new Range32 (0x1123b, 0x1123c, 1),
	|            new Range32 (0x112a9, 0x112a9, 1),
	|            new Range32 (0x1144b, 0x1144c, 1),
	|            new Range32 (0x115c2, 0x115c3, 1),
	|            new Range32 (0x115c9, 0x115d7, 1),
	|            new Range32 (0x11641, 0x11642, 1),
	|            new Range32 (0x1173c, 0x1173e, 1),
	|            new Range32 (0x11944, 0x11944, 1),
	|            new Range32 (0x11946, 0x11946, 1),
	|            new Range32 (0x11a42, 0x11a43, 1),
	|            new Range32 (0x11a9b, 0x11a9c, 1),
	|            new Range32 (0x11c41, 0x11c42, 1),
	|            new Range32 (0x11ef7, 0x11ef8, 1),
	|            new Range32 (0x11f43, 0x11f44, 1),
	|            new Range32 (0x16a6e, 0x16a6f, 1),
	|            new Range32 (0x16af5, 0x16af5, 1),
	|            new Range32 (0x16b37, 0x16b38, 1),
	|            new Range32 (0x16b44, 0x16b44, 1),
	|            new Range32 (0x16e98, 0x16e98, 1),
	|            new Range32 (0x1bc9f, 0x1bc9f, 1),
	|            new Range32 (0x1da88, 0x1da88, 1),
	|                },
	|                latinOffset: 3
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Soft_Dotted = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0069, 0x006a, 1),
	|            new Range16 (0x012f, 0x012f, 1),
	|            new Range16 (0x0249, 0x0249, 1),
	|            new Range16 (0x0268, 0x0268, 1),
	|            new Range16 (0x029d, 0x029d, 1),
	|            new Range16 (0x02b2, 0x02b2, 1),
	|            new Range16 (0x03f3, 0x03f3, 1),
	|            new Range16 (0x0456, 0x0456, 1),
	|            new Range16 (0x0458, 0x0458, 1),
	|            new Range16 (0x1d62, 0x1d62, 1),
	|            new Range16 (0x1d96, 0x1d96, 1),
	|            new Range16 (0x1da4, 0x1da4, 1),
	|            new Range16 (0x1da8, 0x1da8, 1),
	|            new Range16 (0x1e2d, 0x1e2d, 1),
	|            new Range16 (0x1ecb, 0x1ecb, 1),
	|            new Range16 (0x2071, 0x2071, 1),
	|            new Range16 (0x2148, 0x2149, 1),
	|            new Range16 (0x2c7c, 0x2c7c, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1d422, 0x1d423, 1),
	|            new Range32 (0x1d456, 0x1d457, 1),
	|            new Range32 (0x1d48a, 0x1d48b, 1),
	|            new Range32 (0x1d4be, 0x1d4bf, 1),
	|            new Range32 (0x1d4f2, 0x1d4f3, 1),
	|            new Range32 (0x1d526, 0x1d527, 1),
	|            new Range32 (0x1d55a, 0x1d55b, 1),
	|            new Range32 (0x1d58e, 0x1d58f, 1),
	|            new Range32 (0x1d5c2, 0x1d5c3, 1),
	|            new Range32 (0x1d5f6, 0x1d5f7, 1),
	|            new Range32 (0x1d62a, 0x1d62b, 1),
	|            new Range32 (0x1d65e, 0x1d65f, 1),
	|            new Range32 (0x1d692, 0x1d693, 1),
	|            new Range32 (0x1df1a, 0x1df1a, 1),
	|            new Range32 (0x1e04c, 0x1e04d, 1),
	|            new Range32 (0x1e068, 0x1e068, 1),
	|                },
	|                latinOffset: 1
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Terminal_Punctuation = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0021, 0x0021, 1),
	|            new Range16 (0x002c, 0x002c, 1),
	|            new Range16 (0x002e, 0x002e, 1),
	|            new Range16 (0x003a, 0x003b, 1),
	|            new Range16 (0x003f, 0x003f, 1),
	|            new Range16 (0x037e, 0x037e, 1),
	|            new Range16 (0x0387, 0x0387, 1),
	|            new Range16 (0x0589, 0x0589, 1),
	|            new Range16 (0x05c3, 0x05c3, 1),
	|            new Range16 (0x060c, 0x060c, 1),
	|            new Range16 (0x061b, 0x061b, 1),
	|            new Range16 (0x061d, 0x061f, 1),
	|            new Range16 (0x06d4, 0x06d4, 1),
	|            new Range16 (0x0700, 0x070a, 1),
	|            new Range16 (0x070c, 0x070c, 1),
	|            new Range16 (0x07f8, 0x07f9, 1),
	|            new Range16 (0x0830, 0x083e, 1),
	|            new Range16 (0x085e, 0x085e, 1),
	|            new Range16 (0x0964, 0x0965, 1),
	|            new Range16 (0x0e5a, 0x0e5b, 1),
	|            new Range16 (0x0f08, 0x0f08, 1),
	|            new Range16 (0x0f0d, 0x0f12, 1),
	|            new Range16 (0x104a, 0x104b, 1),
	|            new Range16 (0x1361, 0x1368, 1),
	|            new Range16 (0x166e, 0x166e, 1),
	|            new Range16 (0x16eb, 0x16ed, 1),
	|            new Range16 (0x1735, 0x1736, 1),
	|            new Range16 (0x17d4, 0x17d6, 1),
	|            new Range16 (0x17da, 0x17da, 1),
	|            new Range16 (0x1802, 0x1805, 1),
	|            new Range16 (0x1808, 0x1809, 1),
	|            new Range16 (0x1944, 0x1945, 1),
	|            new Range16 (0x1aa8, 0x1aab, 1),
	|            new Range16 (0x1b5a, 0x1b5b, 1),
	|            new Range16 (0x1b5d, 0x1b5f, 1),
	|            new Range16 (0x1b7d, 0x1b7e, 1),
	|            new Range16 (0x1c3b, 0x1c3f, 1),
	|            new Range16 (0x1c7e, 0x1c7f, 1),
	|            new Range16 (0x203c, 0x203d, 1),
	|            new Range16 (0x2047, 0x2049, 1),
	|            new Range16 (0x2e2e, 0x2e2e, 1),
	|            new Range16 (0x2e3c, 0x2e3c, 1),
	|            new Range16 (0x2e41, 0x2e41, 1),
	|            new Range16 (0x2e4c, 0x2e4c, 1),
	|            new Range16 (0x2e4e, 0x2e4f, 1),
	|            new Range16 (0x2e53, 0x2e54, 1),
	|            new Range16 (0x3001, 0x3002, 1),
	|            new Range16 (0xa4fe, 0xa4ff, 1),
	|            new Range16 (0xa60d, 0xa60f, 1),
	|            new Range16 (0xa6f3, 0xa6f7, 1),
	|            new Range16 (0xa876, 0xa877, 1),
	|            new Range16 (0xa8ce, 0xa8cf, 1),
	|            new Range16 (0xa92f, 0xa92f, 1),
	|            new Range16 (0xa9c7, 0xa9c9, 1),
	|            new Range16 (0xaa5d, 0xaa5f, 1),
	|            new Range16 (0xaadf, 0xaadf, 1),
	|            new Range16 (0xaaf0, 0xaaf1, 1),
	|            new Range16 (0xabeb, 0xabeb, 1),
	|            new Range16 (0xfe50, 0xfe52, 1),
	|            new Range16 (0xfe54, 0xfe57, 1),
	|            new Range16 (0xff01, 0xff01, 1),
	|            new Range16 (0xff0c, 0xff0c, 1),
	|            new Range16 (0xff0e, 0xff0e, 1),
	|            new Range16 (0xff1a, 0xff1b, 1),
	|            new Range16 (0xff1f, 0xff1f, 1),
	|            new Range16 (0xff61, 0xff61, 1),
	|            new Range16 (0xff64, 0xff64, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x1039f, 0x1039f, 1),
	|            new Range32 (0x103d0, 0x103d0, 1),
	|            new Range32 (0x10857, 0x10857, 1),
	|            new Range32 (0x1091f, 0x1091f, 1),
	|            new Range32 (0x10a56, 0x10a57, 1),
	|            new Range32 (0x10af0, 0x10af5, 1),
	|            new Range32 (0x10b3a, 0x10b3f, 1),
	|            new Range32 (0x10b99, 0x10b9c, 1),
	|            new Range32 (0x10f55, 0x10f59, 1),
	|            new Range32 (0x10f86, 0x10f89, 1),
	|            new Range32 (0x11047, 0x1104d, 1),
	|            new Range32 (0x110be, 0x110c1, 1),
	|            new Range32 (0x11141, 0x11143, 1),
	|            new Range32 (0x111c5, 0x111c6, 1),
	|            new Range32 (0x111cd, 0x111cd, 1),
	|            new Range32 (0x111de, 0x111df, 1),
	|            new Range32 (0x11238, 0x1123c, 1),
	|            new Range32 (0x112a9, 0x112a9, 1),
	|            new Range32 (0x1144b, 0x1144d, 1),
	|            new Range32 (0x1145a, 0x1145b, 1),
	|            new Range32 (0x115c2, 0x115c5, 1),
	|            new Range32 (0x115c9, 0x115d7, 1),
	|            new Range32 (0x11641, 0x11642, 1),
	|            new Range32 (0x1173c, 0x1173e, 1),
	|            new Range32 (0x11944, 0x11944, 1),
	|            new Range32 (0x11946, 0x11946, 1),
	|            new Range32 (0x11a42, 0x11a43, 1),
	|            new Range32 (0x11a9b, 0x11a9c, 1),
	|            new Range32 (0x11aa1, 0x11aa2, 1),
	|            new Range32 (0x11c41, 0x11c43, 1),
	|            new Range32 (0x11c71, 0x11c71, 1),
	|            new Range32 (0x11ef7, 0x11ef8, 1),
	|            new Range32 (0x11f43, 0x11f44, 1),
	|            new Range32 (0x12470, 0x12474, 1),
	|            new Range32 (0x16a6e, 0x16a6f, 1),
	|            new Range32 (0x16af5, 0x16af5, 1),
	|            new Range32 (0x16b37, 0x16b39, 1),
	|            new Range32 (0x16b44, 0x16b44, 1),
	|            new Range32 (0x16e97, 0x16e98, 1),
	|            new Range32 (0x1bc9f, 0x1bc9f, 1),
	|            new Range32 (0x1da87, 0x1da8a, 1),
	|                },
	|                latinOffset: 5
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Unified_Ideograph = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x3400, 0x4dbf, 1),
	|            new Range16 (0x4e00, 0x9fff, 1),
	|            new Range16 (0xfa0e, 0xfa0f, 1),
	|            new Range16 (0xfa11, 0xfa11, 1),
	|            new Range16 (0xfa13, 0xfa14, 1),
	|            new Range16 (0xfa1f, 0xfa1f, 1),
	|            new Range16 (0xfa21, 0xfa21, 1),
	|            new Range16 (0xfa23, 0xfa24, 1),
	|            new Range16 (0xfa27, 0xfa29, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0x20000, 0x2a6df, 1),
	|            new Range32 (0x2a700, 0x2b739, 1),
	|            new Range32 (0x2b740, 0x2b81d, 1),
	|            new Range32 (0x2b820, 0x2cea1, 1),
	|            new Range32 (0x2ceb0, 0x2ebe0, 1),
	|            new Range32 (0x30000, 0x3134a, 1),
	|            new Range32 (0x31350, 0x323af, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _Variation_Selector = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x180b, 0x180d, 1),
	|            new Range16 (0x180f, 0x180f, 1),
	|            new Range16 (0xfe00, 0xfe0f, 1),
	|                },
	|                r32: new Range32[] {
	|            new Range32 (0xe0100, 0xe01ef, 1),
	|                }
	|            ); /* RangeTable */
	|
	|            internal static RangeTable _White_Space = new RangeTable(
	|                r16: new Range16[] {
	|            new Range16 (0x0009, 0x000d, 1),
	|            new Range16 (0x0020, 0x0020, 1),
	|            new Range16 (0x0085, 0x0085, 1),
	|            new Range16 (0x00a0, 0x00a0, 1),
	|            new Range16 (0x1680, 0x1680, 1),
	|            new Range16 (0x2000, 0x200a, 1),
	|            new Range16 (0x2028, 0x2029, 1),
	|            new Range16 (0x202f, 0x202f, 1),
	|            new Range16 (0x205f, 0x205f, 1),
	|            new Range16 (0x3000, 0x3000, 1),
	|                },
	|                latinOffset: 4
	|            ); /* RangeTable */
	|
	|            /// <summary>ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.</summary>
	|            public static RangeTable ASCII_Hex_Digit => _ASCII_Hex_Digit;
	|            /// <summary>Bidi_Control is the set of Unicode characters with property Bidi_Control.</summary>
	|            public static RangeTable Bidi_Control => _Bidi_Control;
	|            /// <summary>Dash is the set of Unicode characters with property Dash.</summary>
	|            public static RangeTable Dash => _Dash;
	|            /// <summary>Deprecated is the set of Unicode characters with property Deprecated.</summary>
	|            public static RangeTable Deprecated => _Deprecated;
	|            /// <summary>Diacritic is the set of Unicode characters with property Diacritic.</summary>
	|            public static RangeTable Diacritic => _Diacritic;
	|            /// <summary>Extender is the set of Unicode characters with property Extender.</summary>
	|            public static RangeTable Extender => _Extender;
	|            /// <summary>Hex_Digit is the set of Unicode characters with property Hex_Digit.</summary>
	|            public static RangeTable Hex_Digit => _Hex_Digit;
	|            /// <summary>Hyphen is the set of Unicode characters with property Hyphen.</summary>
	|            public static RangeTable Hyphen => _Hyphen;
	|            /// <summary>IDS_Binary_Operator is the set of Unicode characters with property IDS_Binary_Operator.</summary>
	|            public static RangeTable IDS_Binary_Operator => _IDS_Binary_Operator;
	|            /// <summary>IDS_Trinary_Operator is the set of Unicode characters with property IDS_Trinary_Operator.</summary>
	|            public static RangeTable IDS_Trinary_Operator => _IDS_Trinary_Operator;
	|            /// <summary>Ideographic is the set of Unicode characters with property Ideographic.</summary>
	|            public static RangeTable Ideographic => _Ideographic;
	|            /// <summary>Join_Control is the set of Unicode characters with property Join_Control.</summary>
	|            public static RangeTable Join_Control => _Join_Control;
	|            /// <summary>Logical_Order_Exception is the set of Unicode characters with property Logical_Order_Exception.</summary>
	|            public static RangeTable Logical_Order_Exception => _Logical_Order_Exception;
	|            /// <summary>Noncharacter_Code_Point is the set of Unicode characters with property Noncharacter_Code_Point.</summary>
	|            public static RangeTable Noncharacter_Code_Point => _Noncharacter_Code_Point;
	|            /// <summary>Other_Alphabetic is the set of Unicode characters with property Other_Alphabetic.</summary>
	|            public static RangeTable Other_Alphabetic => _Other_Alphabetic;
	|            /// <summary>Other_Default_Ignorable_Code_Point is the set of Unicode characters with property Other_Default_Ignorable_Code_Point.</summary>
	|            public static RangeTable Other_Default_Ignorable_Code_Point => _Other_Default_Ignorable_Code_Point;
	|            /// <summary>Other_Grapheme_Extend is the set of Unicode characters with property Other_Grapheme_Extend.</summary>
	|            public static RangeTable Other_Grapheme_Extend => _Other_Grapheme_Extend;
	|            /// <summary>Other_ID_Continue is the set of Unicode characters with property Other_ID_Continue.</summary>
	|            public static RangeTable Other_ID_Continue => _Other_ID_Continue;
	|            /// <summary>Other_ID_Start is the set of Unicode characters with property Other_ID_Start.</summary>
	|            public static RangeTable Other_ID_Start => _Other_ID_Start;
	|            /// <summary>Other_Lowercase is the set of Unicode characters with property Other_Lowercase.</summary>
	|            public static RangeTable Other_Lowercase => _Other_Lowercase;
	|            /// <summary>Other_Math is the set of Unicode characters with property Other_Math.</summary>
	|            public static RangeTable Other_Math => _Other_Math;
	|            /// <summary>Other_Uppercase is the set of Unicode characters with property Other_Uppercase.</summary>
	|            public static RangeTable Other_Uppercase => _Other_Uppercase;
	|            /// <summary>Pattern_Syntax is the set of Unicode characters with property Pattern_Syntax.</summary>
	|            public static RangeTable Pattern_Syntax => _Pattern_Syntax;
	|            /// <summary>Pattern_White_Space is the set of Unicode characters with property Pattern_White_Space.</summary>
	|            public static RangeTable Pattern_White_Space => _Pattern_White_Space;
	|            /// <summary>Prepended_Concatenation_Mark is the set of Unicode characters with property Prepended_Concatenation_Mark.</summary>
	|            public static RangeTable Prepended_Concatenation_Mark => _Prepended_Concatenation_Mark;
	|            /// <summary>Quotation_Mark is the set of Unicode characters with property Quotation_Mark.</summary>
	|            public static RangeTable Quotation_Mark => _Quotation_Mark;
	|            /// <summary>Radical is the set of Unicode characters with property Radical.</summary>
	|            public static RangeTable Radical => _Radical;
	|            /// <summary>Regional_Indicator is the set of Unicode characters with property Regional_Indicator.</summary>
	|            public static RangeTable Regional_Indicator => _Regional_Indicator;
	|            /// <summary>STerm is an alias for Sentence_Terminal.</summary>
	|            public static RangeTable STerm => _Sentence_Terminal;
	|            /// <summary>Sentence_Terminal is the set of Unicode characters with property Sentence_Terminal.</summary>
	|            public static RangeTable Sentence_Terminal => _Sentence_Terminal;
	|            /// <summary>Soft_Dotted is the set of Unicode characters with property Soft_Dotted.</summary>
	|            public static RangeTable Soft_Dotted => _Soft_Dotted;
	|            /// <summary>Terminal_Punctuation is the set of Unicode characters with property Terminal_Punctuation.</summary>
	|            public static RangeTable Terminal_Punctuation => _Terminal_Punctuation;
	|            /// <summary>Unified_Ideograph is the set of Unicode characters with property Unified_Ideograph.</summary>
	|            public static RangeTable Unified_Ideograph => _Unified_Ideograph;
	|            /// <summary>Variation_Selector is the set of Unicode characters with property Variation_Selector.</summary>
	|            public static RangeTable Variation_Selector => _Variation_Selector;
	|            /// <summary>White_Space is the set of Unicode characters with property White_Space.</summary>
	|            public static RangeTable White_Space => _White_Space;
	|        }
	|
	|        // Generated by running
	|        //	maketables --data=https://www.unicode.org/Public/15.0.0/ucd/UnicodeData.txt --casefolding=https://www.unicode.org/Public/15.0.0/ucd/CaseFolding.txt
	|        // DO NOT EDIT
	|
	|        // CaseRanges is the table describing case mappings for all letters with
	|        // non-self mappings.
	|        static CaseRange[] CaseRanges => _CaseRanges;
	|        static CaseRange[] _CaseRanges = new CaseRange[] {
	|        new CaseRange (0x0041, 0x005A, 0, 32, 0),
	|        new CaseRange (0x0061, 0x007A, -32, 0, -32),
	|        new CaseRange (0x00B5, 0x00B5, 743, 0, 743),
	|        new CaseRange (0x00C0, 0x00D6, 0, 32, 0),
	|        new CaseRange (0x00D8, 0x00DE, 0, 32, 0),
	|        new CaseRange (0x00E0, 0x00F6, -32, 0, -32),
	|        new CaseRange (0x00F8, 0x00FE, -32, 0, -32),
	|        new CaseRange (0x00FF, 0x00FF, 121, 0, 121),
	|        new CaseRange (0x0100, 0x012F, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0130, 0x0130, 0, -199, 0),
	|        new CaseRange (0x0131, 0x0131, -232, 0, -232),
	|        new CaseRange (0x0132, 0x0137, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0139, 0x0148, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x014A, 0x0177, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0178, 0x0178, 0, -121, 0),
	|        new CaseRange (0x0179, 0x017E, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x017F, 0x017F, -300, 0, -300),
	|        new CaseRange (0x0180, 0x0180, 195, 0, 195),
	|        new CaseRange (0x0181, 0x0181, 0, 210, 0),
	|        new CaseRange (0x0182, 0x0185, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0186, 0x0186, 0, 206, 0),
	|        new CaseRange (0x0187, 0x0188, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0189, 0x018A, 0, 205, 0),
	|        new CaseRange (0x018B, 0x018C, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x018E, 0x018E, 0, 79, 0),
	|        new CaseRange (0x018F, 0x018F, 0, 202, 0),
	|        new CaseRange (0x0190, 0x0190, 0, 203, 0),
	|        new CaseRange (0x0191, 0x0192, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0193, 0x0193, 0, 205, 0),
	|        new CaseRange (0x0194, 0x0194, 0, 207, 0),
	|        new CaseRange (0x0195, 0x0195, 97, 0, 97),
	|        new CaseRange (0x0196, 0x0196, 0, 211, 0),
	|        new CaseRange (0x0197, 0x0197, 0, 209, 0),
	|        new CaseRange (0x0198, 0x0199, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x019A, 0x019A, 163, 0, 163),
	|        new CaseRange (0x019C, 0x019C, 0, 211, 0),
	|        new CaseRange (0x019D, 0x019D, 0, 213, 0),
	|        new CaseRange (0x019E, 0x019E, 130, 0, 130),
	|        new CaseRange (0x019F, 0x019F, 0, 214, 0),
	|        new CaseRange (0x01A0, 0x01A5, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01A6, 0x01A6, 0, 218, 0),
	|        new CaseRange (0x01A7, 0x01A8, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01A9, 0x01A9, 0, 218, 0),
	|        new CaseRange (0x01AC, 0x01AD, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01AE, 0x01AE, 0, 218, 0),
	|        new CaseRange (0x01AF, 0x01B0, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01B1, 0x01B2, 0, 217, 0),
	|        new CaseRange (0x01B3, 0x01B6, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01B7, 0x01B7, 0, 219, 0),
	|        new CaseRange (0x01B8, 0x01B9, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01BC, 0x01BD, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01BF, 0x01BF, 56, 0, 56),
	|        new CaseRange (0x01C4, 0x01C4, 0, 2, 1),
	|        new CaseRange (0x01C5, 0x01C5, -1, 1, 0),
	|        new CaseRange (0x01C6, 0x01C6, -2, 0, -1),
	|        new CaseRange (0x01C7, 0x01C7, 0, 2, 1),
	|        new CaseRange (0x01C8, 0x01C8, -1, 1, 0),
	|        new CaseRange (0x01C9, 0x01C9, -2, 0, -1),
	|        new CaseRange (0x01CA, 0x01CA, 0, 2, 1),
	|        new CaseRange (0x01CB, 0x01CB, -1, 1, 0),
	|        new CaseRange (0x01CC, 0x01CC, -2, 0, -1),
	|        new CaseRange (0x01CD, 0x01DC, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01DD, 0x01DD, -79, 0, -79),
	|        new CaseRange (0x01DE, 0x01EF, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01F1, 0x01F1, 0, 2, 1),
	|        new CaseRange (0x01F2, 0x01F2, -1, 1, 0),
	|        new CaseRange (0x01F3, 0x01F3, -2, 0, -1),
	|        new CaseRange (0x01F4, 0x01F5, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x01F6, 0x01F6, 0, -97, 0),
	|        new CaseRange (0x01F7, 0x01F7, 0, -56, 0),
	|        new CaseRange (0x01F8, 0x021F, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0220, 0x0220, 0, -130, 0),
	|        new CaseRange (0x0222, 0x0233, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x023A, 0x023A, 0, 10795, 0),
	|        new CaseRange (0x023B, 0x023C, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x023D, 0x023D, 0, -163, 0),
	|        new CaseRange (0x023E, 0x023E, 0, 10792, 0),
	|        new CaseRange (0x023F, 0x0240, 10815, 0, 10815),
	|        new CaseRange (0x0241, 0x0242, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0243, 0x0243, 0, -195, 0),
	|        new CaseRange (0x0244, 0x0244, 0, 69, 0),
	|        new CaseRange (0x0245, 0x0245, 0, 71, 0),
	|        new CaseRange (0x0246, 0x024F, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0250, 0x0250, 10783, 0, 10783),
	|        new CaseRange (0x0251, 0x0251, 10780, 0, 10780),
	|        new CaseRange (0x0252, 0x0252, 10782, 0, 10782),
	|        new CaseRange (0x0253, 0x0253, -210, 0, -210),
	|        new CaseRange (0x0254, 0x0254, -206, 0, -206),
	|        new CaseRange (0x0256, 0x0257, -205, 0, -205),
	|        new CaseRange (0x0259, 0x0259, -202, 0, -202),
	|        new CaseRange (0x025B, 0x025B, -203, 0, -203),
	|        new CaseRange (0x025C, 0x025C, 42319, 0, 42319),
	|        new CaseRange (0x0260, 0x0260, -205, 0, -205),
	|        new CaseRange (0x0261, 0x0261, 42315, 0, 42315),
	|        new CaseRange (0x0263, 0x0263, -207, 0, -207),
	|        new CaseRange (0x0265, 0x0265, 42280, 0, 42280),
	|        new CaseRange (0x0266, 0x0266, 42308, 0, 42308),
	|        new CaseRange (0x0268, 0x0268, -209, 0, -209),
	|        new CaseRange (0x0269, 0x0269, -211, 0, -211),
	|        new CaseRange (0x026A, 0x026A, 42308, 0, 42308),
	|        new CaseRange (0x026B, 0x026B, 10743, 0, 10743),
	|        new CaseRange (0x026C, 0x026C, 42305, 0, 42305),
	|        new CaseRange (0x026F, 0x026F, -211, 0, -211),
	|        new CaseRange (0x0271, 0x0271, 10749, 0, 10749),
	|        new CaseRange (0x0272, 0x0272, -213, 0, -213),
	|        new CaseRange (0x0275, 0x0275, -214, 0, -214),
	|        new CaseRange (0x027D, 0x027D, 10727, 0, 10727),
	|        new CaseRange (0x0280, 0x0280, -218, 0, -218),
	|        new CaseRange (0x0282, 0x0282, 42307, 0, 42307),
	|        new CaseRange (0x0283, 0x0283, -218, 0, -218),
	|        new CaseRange (0x0287, 0x0287, 42282, 0, 42282),
	|        new CaseRange (0x0288, 0x0288, -218, 0, -218),
	|        new CaseRange (0x0289, 0x0289, -69, 0, -69),
	|        new CaseRange (0x028A, 0x028B, -217, 0, -217),
	|        new CaseRange (0x028C, 0x028C, -71, 0, -71),
	|        new CaseRange (0x0292, 0x0292, -219, 0, -219),
	|        new CaseRange (0x029D, 0x029D, 42261, 0, 42261),
	|        new CaseRange (0x029E, 0x029E, 42258, 0, 42258),
	|        new CaseRange (0x0345, 0x0345, 84, 0, 84),
	|        new CaseRange (0x0370, 0x0373, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0376, 0x0377, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x037B, 0x037D, 130, 0, 130),
	|        new CaseRange (0x037F, 0x037F, 0, 116, 0),
	|        new CaseRange (0x0386, 0x0386, 0, 38, 0),
	|        new CaseRange (0x0388, 0x038A, 0, 37, 0),
	|        new CaseRange (0x038C, 0x038C, 0, 64, 0),
	|        new CaseRange (0x038E, 0x038F, 0, 63, 0),
	|        new CaseRange (0x0391, 0x03A1, 0, 32, 0),
	|        new CaseRange (0x03A3, 0x03AB, 0, 32, 0),
	|        new CaseRange (0x03AC, 0x03AC, -38, 0, -38),
	|        new CaseRange (0x03AD, 0x03AF, -37, 0, -37),
	|        new CaseRange (0x03B1, 0x03C1, -32, 0, -32),
	|        new CaseRange (0x03C2, 0x03C2, -31, 0, -31),
	|        new CaseRange (0x03C3, 0x03CB, -32, 0, -32),
	|        new CaseRange (0x03CC, 0x03CC, -64, 0, -64),
	|        new CaseRange (0x03CD, 0x03CE, -63, 0, -63),
	|        new CaseRange (0x03CF, 0x03CF, 0, 8, 0),
	|        new CaseRange (0x03D0, 0x03D0, -62, 0, -62),
	|        new CaseRange (0x03D1, 0x03D1, -57, 0, -57),
	|        new CaseRange (0x03D5, 0x03D5, -47, 0, -47),
	|        new CaseRange (0x03D6, 0x03D6, -54, 0, -54),
	|        new CaseRange (0x03D7, 0x03D7, -8, 0, -8),
	|        new CaseRange (0x03D8, 0x03EF, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x03F0, 0x03F0, -86, 0, -86),
	|        new CaseRange (0x03F1, 0x03F1, -80, 0, -80),
	|        new CaseRange (0x03F2, 0x03F2, 7, 0, 7),
	|        new CaseRange (0x03F3, 0x03F3, -116, 0, -116),
	|        new CaseRange (0x03F4, 0x03F4, 0, -60, 0),
	|        new CaseRange (0x03F5, 0x03F5, -96, 0, -96),
	|        new CaseRange (0x03F7, 0x03F8, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x03F9, 0x03F9, 0, -7, 0),
	|        new CaseRange (0x03FA, 0x03FB, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x03FD, 0x03FF, 0, -130, 0),
	|        new CaseRange (0x0400, 0x040F, 0, 80, 0),
	|        new CaseRange (0x0410, 0x042F, 0, 32, 0),
	|        new CaseRange (0x0430, 0x044F, -32, 0, -32),
	|        new CaseRange (0x0450, 0x045F, -80, 0, -80),
	|        new CaseRange (0x0460, 0x0481, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x048A, 0x04BF, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x04C0, 0x04C0, 0, 15, 0),
	|        new CaseRange (0x04C1, 0x04CE, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x04CF, 0x04CF, -15, 0, -15),
	|        new CaseRange (0x04D0, 0x052F, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x0531, 0x0556, 0, 48, 0),
	|        new CaseRange (0x0561, 0x0586, -48, 0, -48),
	|        new CaseRange (0x10A0, 0x10C5, 0, 7264, 0),
	|        new CaseRange (0x10C7, 0x10C7, 0, 7264, 0),
	|        new CaseRange (0x10CD, 0x10CD, 0, 7264, 0),
	|        new CaseRange (0x10D0, 0x10FA, 3008, 0, 0),
	|        new CaseRange (0x10FD, 0x10FF, 3008, 0, 0),
	|        new CaseRange (0x13A0, 0x13EF, 0, 38864, 0),
	|        new CaseRange (0x13F0, 0x13F5, 0, 8, 0),
	|        new CaseRange (0x13F8, 0x13FD, -8, 0, -8),
	|        new CaseRange (0x1C80, 0x1C80, -6254, 0, -6254),
	|        new CaseRange (0x1C81, 0x1C81, -6253, 0, -6253),
	|        new CaseRange (0x1C82, 0x1C82, -6244, 0, -6244),
	|        new CaseRange (0x1C83, 0x1C84, -6242, 0, -6242),
	|        new CaseRange (0x1C85, 0x1C85, -6243, 0, -6243),
	|        new CaseRange (0x1C86, 0x1C86, -6236, 0, -6236),
	|        new CaseRange (0x1C87, 0x1C87, -6181, 0, -6181),
	|        new CaseRange (0x1C88, 0x1C88, 35266, 0, 35266),
	|        new CaseRange (0x1C90, 0x1CBA, 0, -3008, 0),
	|        new CaseRange (0x1CBD, 0x1CBF, 0, -3008, 0),
	|        new CaseRange (0x1D79, 0x1D79, 35332, 0, 35332),
	|        new CaseRange (0x1D7D, 0x1D7D, 3814, 0, 3814),
	|        new CaseRange (0x1D8E, 0x1D8E, 35384, 0, 35384),
	|        new CaseRange (0x1E00, 0x1E95, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x1E9B, 0x1E9B, -59, 0, -59),
	|        new CaseRange (0x1E9E, 0x1E9E, 0, -7615, 0),
	|        new CaseRange (0x1EA0, 0x1EFF, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x1F00, 0x1F07, 8, 0, 8),
	|        new CaseRange (0x1F08, 0x1F0F, 0, -8, 0),
	|        new CaseRange (0x1F10, 0x1F15, 8, 0, 8),
	|        new CaseRange (0x1F18, 0x1F1D, 0, -8, 0),
	|        new CaseRange (0x1F20, 0x1F27, 8, 0, 8),
	|        new CaseRange (0x1F28, 0x1F2F, 0, -8, 0),
	|        new CaseRange (0x1F30, 0x1F37, 8, 0, 8),
	|        new CaseRange (0x1F38, 0x1F3F, 0, -8, 0),
	|        new CaseRange (0x1F40, 0x1F45, 8, 0, 8),
	|        new CaseRange (0x1F48, 0x1F4D, 0, -8, 0),
	|        new CaseRange (0x1F51, 0x1F51, 8, 0, 8),
	|        new CaseRange (0x1F53, 0x1F53, 8, 0, 8),
	|        new CaseRange (0x1F55, 0x1F55, 8, 0, 8),
	|        new CaseRange (0x1F57, 0x1F57, 8, 0, 8),
	|        new CaseRange (0x1F59, 0x1F59, 0, -8, 0),
	|        new CaseRange (0x1F5B, 0x1F5B, 0, -8, 0),
	|        new CaseRange (0x1F5D, 0x1F5D, 0, -8, 0),
	|        new CaseRange (0x1F5F, 0x1F5F, 0, -8, 0),
	|        new CaseRange (0x1F60, 0x1F67, 8, 0, 8),
	|        new CaseRange (0x1F68, 0x1F6F, 0, -8, 0),
	|        new CaseRange (0x1F70, 0x1F71, 74, 0, 74),
	|        new CaseRange (0x1F72, 0x1F75, 86, 0, 86),
	|        new CaseRange (0x1F76, 0x1F77, 100, 0, 100),
	|        new CaseRange (0x1F78, 0x1F79, 128, 0, 128),
	|        new CaseRange (0x1F7A, 0x1F7B, 112, 0, 112),
	|        new CaseRange (0x1F7C, 0x1F7D, 126, 0, 126),
	|        new CaseRange (0x1F80, 0x1F87, 8, 0, 8),
	|        new CaseRange (0x1F88, 0x1F8F, 0, -8, 0),
	|        new CaseRange (0x1F90, 0x1F97, 8, 0, 8),
	|        new CaseRange (0x1F98, 0x1F9F, 0, -8, 0),
	|        new CaseRange (0x1FA0, 0x1FA7, 8, 0, 8),
	|        new CaseRange (0x1FA8, 0x1FAF, 0, -8, 0),
	|        new CaseRange (0x1FB0, 0x1FB1, 8, 0, 8),
	|        new CaseRange (0x1FB3, 0x1FB3, 9, 0, 9),
	|        new CaseRange (0x1FB8, 0x1FB9, 0, -8, 0),
	|        new CaseRange (0x1FBA, 0x1FBB, 0, -74, 0),
	|        new CaseRange (0x1FBC, 0x1FBC, 0, -9, 0),
	|        new CaseRange (0x1FBE, 0x1FBE, -7205, 0, -7205),
	|        new CaseRange (0x1FC3, 0x1FC3, 9, 0, 9),
	|        new CaseRange (0x1FC8, 0x1FCB, 0, -86, 0),
	|        new CaseRange (0x1FCC, 0x1FCC, 0, -9, 0),
	|        new CaseRange (0x1FD0, 0x1FD1, 8, 0, 8),
	|        new CaseRange (0x1FD8, 0x1FD9, 0, -8, 0),
	|        new CaseRange (0x1FDA, 0x1FDB, 0, -100, 0),
	|        new CaseRange (0x1FE0, 0x1FE1, 8, 0, 8),
	|        new CaseRange (0x1FE5, 0x1FE5, 7, 0, 7),
	|        new CaseRange (0x1FE8, 0x1FE9, 0, -8, 0),
	|        new CaseRange (0x1FEA, 0x1FEB, 0, -112, 0),
	|        new CaseRange (0x1FEC, 0x1FEC, 0, -7, 0),
	|        new CaseRange (0x1FF3, 0x1FF3, 9, 0, 9),
	|        new CaseRange (0x1FF8, 0x1FF9, 0, -128, 0),
	|        new CaseRange (0x1FFA, 0x1FFB, 0, -126, 0),
	|        new CaseRange (0x1FFC, 0x1FFC, 0, -9, 0),
	|        new CaseRange (0x2126, 0x2126, 0, -7517, 0),
	|        new CaseRange (0x212A, 0x212A, 0, -8383, 0),
	|        new CaseRange (0x212B, 0x212B, 0, -8262, 0),
	|        new CaseRange (0x2132, 0x2132, 0, 28, 0),
	|        new CaseRange (0x214E, 0x214E, -28, 0, -28),
	|        new CaseRange (0x2160, 0x216F, 0, 16, 0),
	|        new CaseRange (0x2170, 0x217F, -16, 0, -16),
	|        new CaseRange (0x2183, 0x2184, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x24B6, 0x24CF, 0, 26, 0),
	|        new CaseRange (0x24D0, 0x24E9, -26, 0, -26),
	|        new CaseRange (0x2C00, 0x2C2F, 0, 48, 0),
	|        new CaseRange (0x2C30, 0x2C5F, -48, 0, -48),
	|        new CaseRange (0x2C60, 0x2C61, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x2C62, 0x2C62, 0, -10743, 0),
	|        new CaseRange (0x2C63, 0x2C63, 0, -3814, 0),
	|        new CaseRange (0x2C64, 0x2C64, 0, -10727, 0),
	|        new CaseRange (0x2C65, 0x2C65, -10795, 0, -10795),
	|        new CaseRange (0x2C66, 0x2C66, -10792, 0, -10792),
	|        new CaseRange (0x2C67, 0x2C6C, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x2C6D, 0x2C6D, 0, -10780, 0),
	|        new CaseRange (0x2C6E, 0x2C6E, 0, -10749, 0),
	|        new CaseRange (0x2C6F, 0x2C6F, 0, -10783, 0),
	|        new CaseRange (0x2C70, 0x2C70, 0, -10782, 0),
	|        new CaseRange (0x2C72, 0x2C73, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x2C75, 0x2C76, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x2C7E, 0x2C7F, 0, -10815, 0),
	|        new CaseRange (0x2C80, 0x2CE3, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x2CEB, 0x2CEE, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x2CF2, 0x2CF3, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0x2D00, 0x2D25, -7264, 0, -7264),
	|        new CaseRange (0x2D27, 0x2D27, -7264, 0, -7264),
	|        new CaseRange (0x2D2D, 0x2D2D, -7264, 0, -7264),
	|        new CaseRange (0xA640, 0xA66D, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA680, 0xA69B, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA722, 0xA72F, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA732, 0xA76F, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA779, 0xA77C, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA77D, 0xA77D, 0, -35332, 0),
	|        new CaseRange (0xA77E, 0xA787, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA78B, 0xA78C, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA78D, 0xA78D, 0, -42280, 0),
	|        new CaseRange (0xA790, 0xA793, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA794, 0xA794, 48, 0, 48),
	|        new CaseRange (0xA796, 0xA7A9, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA7AA, 0xA7AA, 0, -42308, 0),
	|        new CaseRange (0xA7AB, 0xA7AB, 0, -42319, 0),
	|        new CaseRange (0xA7AC, 0xA7AC, 0, -42315, 0),
	|        new CaseRange (0xA7AD, 0xA7AD, 0, -42305, 0),
	|        new CaseRange (0xA7AE, 0xA7AE, 0, -42308, 0),
	|        new CaseRange (0xA7B0, 0xA7B0, 0, -42258, 0),
	|        new CaseRange (0xA7B1, 0xA7B1, 0, -42282, 0),
	|        new CaseRange (0xA7B2, 0xA7B2, 0, -42261, 0),
	|        new CaseRange (0xA7B3, 0xA7B3, 0, 928, 0),
	|        new CaseRange (0xA7B4, 0xA7C3, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA7C4, 0xA7C4, 0, -48, 0),
	|        new CaseRange (0xA7C5, 0xA7C5, 0, -42307, 0),
	|        new CaseRange (0xA7C6, 0xA7C6, 0, -35384, 0),
	|        new CaseRange (0xA7C7, 0xA7CA, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA7D0, 0xA7D1, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA7D6, 0xA7D9, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xA7F5, 0xA7F6, UpperLower, UpperLower, UpperLower),
	|        new CaseRange (0xAB53, 0xAB53, -928, 0, -928),
	|        new CaseRange (0xAB70, 0xABBF, -38864, 0, -38864),
	|        new CaseRange (0xFF21, 0xFF3A, 0, 32, 0),
	|        new CaseRange (0xFF41, 0xFF5A, -32, 0, -32),
	|        new CaseRange (0x10400, 0x10427, 0, 40, 0),
	|        new CaseRange (0x10428, 0x1044F, -40, 0, -40),
	|        new CaseRange (0x104B0, 0x104D3, 0, 40, 0),
	|        new CaseRange (0x104D8, 0x104FB, -40, 0, -40),
	|        new CaseRange (0x10570, 0x1057A, 0, 39, 0),
	|        new CaseRange (0x1057C, 0x1058A, 0, 39, 0),
	|        new CaseRange (0x1058C, 0x10592, 0, 39, 0),
	|        new CaseRange (0x10594, 0x10595, 0, 39, 0),
	|        new CaseRange (0x10597, 0x105A1, -39, 0, -39),
	|        new CaseRange (0x105A3, 0x105B1, -39, 0, -39),
	|        new CaseRange (0x105B3, 0x105B9, -39, 0, -39),
	|        new CaseRange (0x105BB, 0x105BC, -39, 0, -39),
	|        new CaseRange (0x10C80, 0x10CB2, 0, 64, 0),
	|        new CaseRange (0x10CC0, 0x10CF2, -64, 0, -64),
	|        new CaseRange (0x118A0, 0x118BF, 0, 32, 0),
	|        new CaseRange (0x118C0, 0x118DF, -32, 0, -32),
	|        new CaseRange (0x16E40, 0x16E5F, 0, 32, 0),
	|        new CaseRange (0x16E60, 0x16E7F, -32, 0, -32),
	|        new CaseRange (0x1E900, 0x1E921, 0, 34, 0),
	|        new CaseRange (0x1E922, 0x1E943, -34, 0, -34),
	|    };
	|        static CharClass[] properties = new CharClass[256] {
	|		/*0x00 */ CharClass.pC, // '\x00'
	|		/*0x01 */ CharClass.pC, // '\x01'
	|		/*0x02 */ CharClass.pC, // '\x02'
	|		/*0x03 */ CharClass.pC, // '\x03'
	|		/*0x04 */ CharClass.pC, // '\x04'
	|		/*0x05 */ CharClass.pC, // '\x05'
	|		/*0x06 */ CharClass.pC, // '\x06'
	|		/*0x07 */ CharClass.pC, // '\a'
	|		/*0x08 */ CharClass.pC, // '\b'
	|		/*0x09 */ CharClass.pC, // '\t'
	|		/*0x0A */ CharClass.pC, // '\n'
	|		/*0x0B */ CharClass.pC, // '\v'
	|		/*0x0C */ CharClass.pC, // '\f'
	|		/*0x0D */ CharClass.pC, // '\r'
	|		/*0x0E */ CharClass.pC, // '\x0e'
	|		/*0x0F */ CharClass.pC, // '\x0f'
	|		/*0x10 */ CharClass.pC, // '\x10'
	|		/*0x11 */ CharClass.pC, // '\x11'
	|		/*0x12 */ CharClass.pC, // '\x12'
	|		/*0x13 */ CharClass.pC, // '\x13'
	|		/*0x14 */ CharClass.pC, // '\x14'
	|		/*0x15 */ CharClass.pC, // '\x15'
	|		/*0x16 */ CharClass.pC, // '\x16'
	|		/*0x17 */ CharClass.pC, // '\x17'
	|		/*0x18 */ CharClass.pC, // '\x18'
	|		/*0x19 */ CharClass.pC, // '\x19'
	|		/*0x1A */ CharClass.pC, // '\x1a'
	|		/*0x1B */ CharClass.pC, // '\x1b'
	|		/*0x1C */ CharClass.pC, // '\x1c'
	|		/*0x1D */ CharClass.pC, // '\x1d'
	|		/*0x1E */ CharClass.pC, // '\x1e'
	|		/*0x1F */ CharClass.pC, // '\x1f'
	|		/*0x20 */ CharClass.pZ | CharClass.pp, // ' '
	|		/*0x21 */ CharClass.pP | CharClass.pp, // '!'
	|		/*0x22 */ CharClass.pP | CharClass.pp, // '""'
	|		/*0x23 */ CharClass.pP | CharClass.pp, // '#'
	|		/*0x24 */ CharClass.pS | CharClass.pp, // '$'
	|		/*0x25 */ CharClass.pP | CharClass.pp, // '%'
	|		/*0x26 */ CharClass.pP | CharClass.pp, // '&'
	|		/*0x27 */ CharClass.pP | CharClass.pp, // '\''
	|		/*0x28 */ CharClass.pP | CharClass.pp, // '('
	|		/*0x29 */ CharClass.pP | CharClass.pp, // ')'
	|		/*0x2A */ CharClass.pP | CharClass.pp, // '*'
	|		/*0x2B */ CharClass.pS | CharClass.pp, // '+'
	|		/*0x2C */ CharClass.pP | CharClass.pp, // ','
	|		/*0x2D */ CharClass.pP | CharClass.pp, // '-'
	|		/*0x2E */ CharClass.pP | CharClass.pp, // '.'
	|		/*0x2F */ CharClass.pP | CharClass.pp, // '/'
	|		/*0x30 */ CharClass.pN | CharClass.pp, // '0'
	|		/*0x31 */ CharClass.pN | CharClass.pp, // '1'
	|		/*0x32 */ CharClass.pN | CharClass.pp, // '2'
	|		/*0x33 */ CharClass.pN | CharClass.pp, // '3'
	|		/*0x34 */ CharClass.pN | CharClass.pp, // '4'
	|		/*0x35 */ CharClass.pN | CharClass.pp, // '5'
	|		/*0x36 */ CharClass.pN | CharClass.pp, // '6'
	|		/*0x37 */ CharClass.pN | CharClass.pp, // '7'
	|		/*0x38 */ CharClass.pN | CharClass.pp, // '8'
	|		/*0x39 */ CharClass.pN | CharClass.pp, // '9'
	|		/*0x3A */ CharClass.pP | CharClass.pp, // ':'
	|		/*0x3B */ CharClass.pP | CharClass.pp, // ';'
	|		/*0x3C */ CharClass.pS | CharClass.pp, // '<'
	|		/*0x3D */ CharClass.pS | CharClass.pp, // '='
	|		/*0x3E */ CharClass.pS | CharClass.pp, // '>'
	|		/*0x3F */ CharClass.pP | CharClass.pp, // '?'
	|		/*0x40 */ CharClass.pP | CharClass.pp, // '@'
	|		/*0x41 */ CharClass.pLu | CharClass.pp, // 'A'
	|		/*0x42 */ CharClass.pLu | CharClass.pp, // 'B'
	|		/*0x43 */ CharClass.pLu | CharClass.pp, // 'C'
	|		/*0x44 */ CharClass.pLu | CharClass.pp, // 'D'
	|		/*0x45 */ CharClass.pLu | CharClass.pp, // 'E'
	|		/*0x46 */ CharClass.pLu | CharClass.pp, // 'F'
	|		/*0x47 */ CharClass.pLu | CharClass.pp, // 'G'
	|		/*0x48 */ CharClass.pLu | CharClass.pp, // 'H'
	|		/*0x49 */ CharClass.pLu | CharClass.pp, // 'I'
	|		/*0x4A */ CharClass.pLu | CharClass.pp, // 'J'
	|		/*0x4B */ CharClass.pLu | CharClass.pp, // 'K'
	|		/*0x4C */ CharClass.pLu | CharClass.pp, // 'L'
	|		/*0x4D */ CharClass.pLu | CharClass.pp, // 'M'
	|		/*0x4E */ CharClass.pLu | CharClass.pp, // 'N'
	|		/*0x4F */ CharClass.pLu | CharClass.pp, // 'O'
	|		/*0x50 */ CharClass.pLu | CharClass.pp, // 'P'
	|		/*0x51 */ CharClass.pLu | CharClass.pp, // 'Q'
	|		/*0x52 */ CharClass.pLu | CharClass.pp, // 'R'
	|		/*0x53 */ CharClass.pLu | CharClass.pp, // 'S'
	|		/*0x54 */ CharClass.pLu | CharClass.pp, // 'T'
	|		/*0x55 */ CharClass.pLu | CharClass.pp, // 'U'
	|		/*0x56 */ CharClass.pLu | CharClass.pp, // 'V'
	|		/*0x57 */ CharClass.pLu | CharClass.pp, // 'W'
	|		/*0x58 */ CharClass.pLu | CharClass.pp, // 'X'
	|		/*0x59 */ CharClass.pLu | CharClass.pp, // 'Y'
	|		/*0x5A */ CharClass.pLu | CharClass.pp, // 'Z'
	|		/*0x5B */ CharClass.pP | CharClass.pp, // '['
	|		/*0x5C */ CharClass.pP | CharClass.pp, // '\\'
	|		/*0x5D */ CharClass.pP | CharClass.pp, // ']'
	|		/*0x5E */ CharClass.pS | CharClass.pp, // '^'
	|		/*0x5F */ CharClass.pP | CharClass.pp, // '_'
	|		/*0x60 */ CharClass.pS | CharClass.pp, // '`'
	|		/*0x61 */ CharClass.pLl | CharClass.pp, // 'a'
	|		/*0x62 */ CharClass.pLl | CharClass.pp, // 'b'
	|		/*0x63 */ CharClass.pLl | CharClass.pp, // 'c'
	|		/*0x64 */ CharClass.pLl | CharClass.pp, // 'd'
	|		/*0x65 */ CharClass.pLl | CharClass.pp, // 'e'
	|		/*0x66 */ CharClass.pLl | CharClass.pp, // 'f'
	|		/*0x67 */ CharClass.pLl | CharClass.pp, // 'g'
	|		/*0x68 */ CharClass.pLl | CharClass.pp, // 'h'
	|		/*0x69 */ CharClass.pLl | CharClass.pp, // 'i'
	|		/*0x6A */ CharClass.pLl | CharClass.pp, // 'j'
	|		/*0x6B */ CharClass.pLl | CharClass.pp, // 'k'
	|		/*0x6C */ CharClass.pLl | CharClass.pp, // 'l'
	|		/*0x6D */ CharClass.pLl | CharClass.pp, // 'm'
	|		/*0x6E */ CharClass.pLl | CharClass.pp, // 'n'
	|		/*0x6F */ CharClass.pLl | CharClass.pp, // 'o'
	|		/*0x70 */ CharClass.pLl | CharClass.pp, // 'p'
	|		/*0x71 */ CharClass.pLl | CharClass.pp, // 'q'
	|		/*0x72 */ CharClass.pLl | CharClass.pp, // 'r'
	|		/*0x73 */ CharClass.pLl | CharClass.pp, // 's'
	|		/*0x74 */ CharClass.pLl | CharClass.pp, // 't'
	|		/*0x75 */ CharClass.pLl | CharClass.pp, // 'u'
	|		/*0x76 */ CharClass.pLl | CharClass.pp, // 'v'
	|		/*0x77 */ CharClass.pLl | CharClass.pp, // 'w'
	|		/*0x78 */ CharClass.pLl | CharClass.pp, // 'x'
	|		/*0x79 */ CharClass.pLl | CharClass.pp, // 'y'
	|		/*0x7A */ CharClass.pLl | CharClass.pp, // 'z'
	|		/*0x7B */ CharClass.pP | CharClass.pp, // '{'
	|		/*0x7C */ CharClass.pS | CharClass.pp, // '|'
	|		/*0x7D */ CharClass.pP | CharClass.pp, // '}'
	|		/*0x7E */ CharClass.pS | CharClass.pp, // '~'
	|		/*0x7F */ CharClass.pC, // '\u007f'
	|		/*0x80 */ CharClass.pC, // '\u0080'
	|		/*0x81 */ CharClass.pC, // '\u0081'
	|		/*0x82 */ CharClass.pC, // '\u0082'
	|		/*0x83 */ CharClass.pC, // '\u0083'
	|		/*0x84 */ CharClass.pC, // '\u0084'
	|		/*0x85 */ CharClass.pC, // '\u0085'
	|		/*0x86 */ CharClass.pC, // '\u0086'
	|		/*0x87 */ CharClass.pC, // '\u0087'
	|		/*0x88 */ CharClass.pC, // '\u0088'
	|		/*0x89 */ CharClass.pC, // '\u0089'
	|		/*0x8A */ CharClass.pC, // '\u008a'
	|		/*0x8B */ CharClass.pC, // '\u008b'
	|		/*0x8C */ CharClass.pC, // '\u008c'
	|		/*0x8D */ CharClass.pC, // '\u008d'
	|		/*0x8E */ CharClass.pC, // '\u008e'
	|		/*0x8F */ CharClass.pC, // '\u008f'
	|		/*0x90 */ CharClass.pC, // '\u0090'
	|		/*0x91 */ CharClass.pC, // '\u0091'
	|		/*0x92 */ CharClass.pC, // '\u0092'
	|		/*0x93 */ CharClass.pC, // '\u0093'
	|		/*0x94 */ CharClass.pC, // '\u0094'
	|		/*0x95 */ CharClass.pC, // '\u0095'
	|		/*0x96 */ CharClass.pC, // '\u0096'
	|		/*0x97 */ CharClass.pC, // '\u0097'
	|		/*0x98 */ CharClass.pC, // '\u0098'
	|		/*0x99 */ CharClass.pC, // '\u0099'
	|		/*0x9A */ CharClass.pC, // '\u009a'
	|		/*0x9B */ CharClass.pC, // '\u009b'
	|		/*0x9C */ CharClass.pC, // '\u009c'
	|		/*0x9D */ CharClass.pC, // '\u009d'
	|		/*0x9E */ CharClass.pC, // '\u009e'
	|		/*0x9F */ CharClass.pC, // '\u009f'
	|		/*0xA0 */ CharClass.pZ, // '\u00a0'
	|		/*0xA1 */ CharClass.pP | CharClass.pp, // '¡'
	|		/*0xA2 */ CharClass.pS | CharClass.pp, // '¢'
	|		/*0xA3 */ CharClass.pS | CharClass.pp, // '£'
	|		/*0xA4 */ CharClass.pS | CharClass.pp, // '¤'
	|		/*0xA5 */ CharClass.pS | CharClass.pp, // '¥'
	|		/*0xA6 */ CharClass.pS | CharClass.pp, // '¦'
	|		/*0xA7 */ CharClass.pP | CharClass.pp, // '§'
	|		/*0xA8 */ CharClass.pS | CharClass.pp, // '¨'
	|		/*0xA9 */ CharClass.pS | CharClass.pp, // '©'
	|		/*0xAA */ CharClass.pLo | CharClass.pp, // 'ª'
	|		/*0xAB */ CharClass.pP | CharClass.pp, // '«'
	|		/*0xAC */ CharClass.pS | CharClass.pp, // '¬'
	|		/*0xAD */ 0, // '\u00ad'
	|		/*0xAE */ CharClass.pS | CharClass.pp, // '®'
	|		/*0xAF */ CharClass.pS | CharClass.pp, // '¯'
	|		/*0xB0 */ CharClass.pS | CharClass.pp, // '°'
	|		/*0xB1 */ CharClass.pS | CharClass.pp, // '±'
	|		/*0xB2 */ CharClass.pN | CharClass.pp, // '²'
	|		/*0xB3 */ CharClass.pN | CharClass.pp, // '³'
	|		/*0xB4 */ CharClass.pS | CharClass.pp, // '´'
	|		/*0xB5 */ CharClass.pLl | CharClass.pp, // 'µ'
	|		/*0xB6 */ CharClass.pP | CharClass.pp, // '¶'
	|		/*0xB7 */ CharClass.pP | CharClass.pp, // '·'
	|		/*0xB8 */ CharClass.pS | CharClass.pp, // '¸'
	|		/*0xB9 */ CharClass.pN | CharClass.pp, // '¹'
	|		/*0xBA */ CharClass.pLo | CharClass.pp, // 'º'
	|		/*0xBB */ CharClass.pP | CharClass.pp, // '»'
	|		/*0xBC */ CharClass.pN | CharClass.pp, // '¼'
	|		/*0xBD */ CharClass.pN | CharClass.pp, // '½'
	|		/*0xBE */ CharClass.pN | CharClass.pp, // '¾'
	|		/*0xBF */ CharClass.pP | CharClass.pp, // '¿'
	|		/*0xC0 */ CharClass.pLu | CharClass.pp, // 'À'
	|		/*0xC1 */ CharClass.pLu | CharClass.pp, // 'Á'
	|		/*0xC2 */ CharClass.pLu | CharClass.pp, // 'Â'
	|		/*0xC3 */ CharClass.pLu | CharClass.pp, // 'Ã'
	|		/*0xC4 */ CharClass.pLu | CharClass.pp, // 'Ä'
	|		/*0xC5 */ CharClass.pLu | CharClass.pp, // 'Å'
	|		/*0xC6 */ CharClass.pLu | CharClass.pp, // 'Æ'
	|		/*0xC7 */ CharClass.pLu | CharClass.pp, // 'Ç'
	|		/*0xC8 */ CharClass.pLu | CharClass.pp, // 'È'
	|		/*0xC9 */ CharClass.pLu | CharClass.pp, // 'É'
	|		/*0xCA */ CharClass.pLu | CharClass.pp, // 'Ê'
	|		/*0xCB */ CharClass.pLu | CharClass.pp, // 'Ë'
	|		/*0xCC */ CharClass.pLu | CharClass.pp, // 'Ì'
	|		/*0xCD */ CharClass.pLu | CharClass.pp, // 'Í'
	|		/*0xCE */ CharClass.pLu | CharClass.pp, // 'Î'
	|		/*0xCF */ CharClass.pLu | CharClass.pp, // 'Ï'
	|		/*0xD0 */ CharClass.pLu | CharClass.pp, // 'Ð'
	|		/*0xD1 */ CharClass.pLu | CharClass.pp, // 'Ñ'
	|		/*0xD2 */ CharClass.pLu | CharClass.pp, // 'Ò'
	|		/*0xD3 */ CharClass.pLu | CharClass.pp, // 'Ó'
	|		/*0xD4 */ CharClass.pLu | CharClass.pp, // 'Ô'
	|		/*0xD5 */ CharClass.pLu | CharClass.pp, // 'Õ'
	|		/*0xD6 */ CharClass.pLu | CharClass.pp, // 'Ö'
	|		/*0xD7 */ CharClass.pS | CharClass.pp, // '×'
	|		/*0xD8 */ CharClass.pLu | CharClass.pp, // 'Ø'
	|		/*0xD9 */ CharClass.pLu | CharClass.pp, // 'Ù'
	|		/*0xDA */ CharClass.pLu | CharClass.pp, // 'Ú'
	|		/*0xDB */ CharClass.pLu | CharClass.pp, // 'Û'
	|		/*0xDC */ CharClass.pLu | CharClass.pp, // 'Ü'
	|		/*0xDD */ CharClass.pLu | CharClass.pp, // 'Ý'
	|		/*0xDE */ CharClass.pLu | CharClass.pp, // 'Þ'
	|		/*0xDF */ CharClass.pLl | CharClass.pp, // 'ß'
	|		/*0xE0 */ CharClass.pLl | CharClass.pp, // 'à'
	|		/*0xE1 */ CharClass.pLl | CharClass.pp, // 'á'
	|		/*0xE2 */ CharClass.pLl | CharClass.pp, // 'â'
	|		/*0xE3 */ CharClass.pLl | CharClass.pp, // 'ã'
	|		/*0xE4 */ CharClass.pLl | CharClass.pp, // 'ä'
	|		/*0xE5 */ CharClass.pLl | CharClass.pp, // 'å'
	|		/*0xE6 */ CharClass.pLl | CharClass.pp, // 'æ'
	|		/*0xE7 */ CharClass.pLl | CharClass.pp, // 'ç'
	|		/*0xE8 */ CharClass.pLl | CharClass.pp, // 'è'
	|		/*0xE9 */ CharClass.pLl | CharClass.pp, // 'é'
	|		/*0xEA */ CharClass.pLl | CharClass.pp, // 'ê'
	|		/*0xEB */ CharClass.pLl | CharClass.pp, // 'ë'
	|		/*0xEC */ CharClass.pLl | CharClass.pp, // 'ì'
	|		/*0xED */ CharClass.pLl | CharClass.pp, // 'í'
	|		/*0xEE */ CharClass.pLl | CharClass.pp, // 'î'
	|		/*0xEF */ CharClass.pLl | CharClass.pp, // 'ï'
	|		/*0xF0 */ CharClass.pLl | CharClass.pp, // 'ð'
	|		/*0xF1 */ CharClass.pLl | CharClass.pp, // 'ñ'
	|		/*0xF2 */ CharClass.pLl | CharClass.pp, // 'ò'
	|		/*0xF3 */ CharClass.pLl | CharClass.pp, // 'ó'
	|		/*0xF4 */ CharClass.pLl | CharClass.pp, // 'ô'
	|		/*0xF5 */ CharClass.pLl | CharClass.pp, // 'õ'
	|		/*0xF6 */ CharClass.pLl | CharClass.pp, // 'ö'
	|		/*0xF7 */ CharClass.pS | CharClass.pp, // '÷'
	|		/*0xF8 */ CharClass.pLl | CharClass.pp, // 'ø'
	|		/*0xF9 */ CharClass.pLl | CharClass.pp, // 'ù'
	|		/*0xFA */ CharClass.pLl | CharClass.pp, // 'ú'
	|		/*0xFB */ CharClass.pLl | CharClass.pp, // 'û'
	|		/*0xFC */ CharClass.pLl | CharClass.pp, // 'ü'
	|		/*0xFD */ CharClass.pLl | CharClass.pp, // 'ý'
	|		/*0xFE */ CharClass.pLl | CharClass.pp, // 'þ'
	|		/*0xFF */ CharClass.pLl | CharClass.pp, // 'ÿ'
	|	};
	|
	|        static ushort[] asciiFold = new ushort[128]{
	|        0x0000,
	|        0x0001,
	|        0x0002,
	|        0x0003,
	|        0x0004,
	|        0x0005,
	|        0x0006,
	|        0x0007,
	|        0x0008,
	|        0x0009,
	|        0x000A,
	|        0x000B,
	|        0x000C,
	|        0x000D,
	|        0x000E,
	|        0x000F,
	|        0x0010,
	|        0x0011,
	|        0x0012,
	|        0x0013,
	|        0x0014,
	|        0x0015,
	|        0x0016,
	|        0x0017,
	|        0x0018,
	|        0x0019,
	|        0x001A,
	|        0x001B,
	|        0x001C,
	|        0x001D,
	|        0x001E,
	|        0x001F,
	|        0x0020,
	|        0x0021,
	|        0x0022,
	|        0x0023,
	|        0x0024,
	|        0x0025,
	|        0x0026,
	|        0x0027,
	|        0x0028,
	|        0x0029,
	|        0x002A,
	|        0x002B,
	|        0x002C,
	|        0x002D,
	|        0x002E,
	|        0x002F,
	|        0x0030,
	|        0x0031,
	|        0x0032,
	|        0x0033,
	|        0x0034,
	|        0x0035,
	|        0x0036,
	|        0x0037,
	|        0x0038,
	|        0x0039,
	|        0x003A,
	|        0x003B,
	|        0x003C,
	|        0x003D,
	|        0x003E,
	|        0x003F,
	|        0x0040,
	|        0x0061,
	|        0x0062,
	|        0x0063,
	|        0x0064,
	|        0x0065,
	|        0x0066,
	|        0x0067,
	|        0x0068,
	|        0x0069,
	|        0x006A,
	|        0x006B,
	|        0x006C,
	|        0x006D,
	|        0x006E,
	|        0x006F,
	|        0x0070,
	|        0x0071,
	|        0x0072,
	|        0x0073,
	|        0x0074,
	|        0x0075,
	|        0x0076,
	|        0x0077,
	|        0x0078,
	|        0x0079,
	|        0x007A,
	|        0x005B,
	|        0x005C,
	|        0x005D,
	|        0x005E,
	|        0x005F,
	|        0x0060,
	|        0x0041,
	|        0x0042,
	|        0x0043,
	|        0x0044,
	|        0x0045,
	|        0x0046,
	|        0x0047,
	|        0x0048,
	|        0x0049,
	|        0x004A,
	|        0x212A,
	|        0x004C,
	|        0x004D,
	|        0x004E,
	|        0x004F,
	|        0x0050,
	|        0x0051,
	|        0x0052,
	|        0x017F,
	|        0x0054,
	|        0x0055,
	|        0x0056,
	|        0x0057,
	|        0x0058,
	|        0x0059,
	|        0x005A,
	|        0x007B,
	|        0x007C,
	|        0x007D,
	|        0x007E,
	|        0x007F,
	|    };
	|
	|        static FoldPair[] CaseOrbit = new FoldPair[] {
	|        new FoldPair (0x004B, 0x006B),
	|        new FoldPair (0x0053, 0x0073),
	|        new FoldPair (0x006B, 0x212A),
	|        new FoldPair (0x0073, 0x017F),
	|        new FoldPair (0x00B5, 0x039C),
	|        new FoldPair (0x00C5, 0x00E5),
	|        new FoldPair (0x00DF, 0x1E9E),
	|        new FoldPair (0x00E5, 0x212B),
	|        new FoldPair (0x0130, 0x0130),
	|        new FoldPair (0x0131, 0x0131),
	|        new FoldPair (0x017F, 0x0053),
	|        new FoldPair (0x01C4, 0x01C5),
	|        new FoldPair (0x01C5, 0x01C6),
	|        new FoldPair (0x01C6, 0x01C4),
	|        new FoldPair (0x01C7, 0x01C8),
	|        new FoldPair (0x01C8, 0x01C9),
	|        new FoldPair (0x01C9, 0x01C7),
	|        new FoldPair (0x01CA, 0x01CB),
	|        new FoldPair (0x01CB, 0x01CC),
	|        new FoldPair (0x01CC, 0x01CA),
	|        new FoldPair (0x01F1, 0x01F2),
	|        new FoldPair (0x01F2, 0x01F3),
	|        new FoldPair (0x01F3, 0x01F1),
	|        new FoldPair (0x0345, 0x0399),
	|        new FoldPair (0x0392, 0x03B2),
	|        new FoldPair (0x0395, 0x03B5),
	|        new FoldPair (0x0398, 0x03B8),
	|        new FoldPair (0x0399, 0x03B9),
	|        new FoldPair (0x039A, 0x03BA),
	|        new FoldPair (0x039C, 0x03BC),
	|        new FoldPair (0x03A0, 0x03C0),
	|        new FoldPair (0x03A1, 0x03C1),
	|        new FoldPair (0x03A3, 0x03C2),
	|        new FoldPair (0x03A6, 0x03C6),
	|        new FoldPair (0x03A9, 0x03C9),
	|        new FoldPair (0x03B2, 0x03D0),
	|        new FoldPair (0x03B5, 0x03F5),
	|        new FoldPair (0x03B8, 0x03D1),
	|        new FoldPair (0x03B9, 0x1FBE),
	|        new FoldPair (0x03BA, 0x03F0),
	|        new FoldPair (0x03BC, 0x00B5),
	|        new FoldPair (0x03C0, 0x03D6),
	|        new FoldPair (0x03C1, 0x03F1),
	|        new FoldPair (0x03C2, 0x03C3),
	|        new FoldPair (0x03C3, 0x03A3),
	|        new FoldPair (0x03C6, 0x03D5),
	|        new FoldPair (0x03C9, 0x2126),
	|        new FoldPair (0x03D0, 0x0392),
	|        new FoldPair (0x03D1, 0x03F4),
	|        new FoldPair (0x03D5, 0x03A6),
	|        new FoldPair (0x03D6, 0x03A0),
	|        new FoldPair (0x03F0, 0x039A),
	|        new FoldPair (0x03F1, 0x03A1),
	|        new FoldPair (0x03F4, 0x0398),
	|        new FoldPair (0x03F5, 0x0395),
	|        new FoldPair (0x0412, 0x0432),
	|        new FoldPair (0x0414, 0x0434),
	|        new FoldPair (0x041E, 0x043E),
	|        new FoldPair (0x0421, 0x0441),
	|        new FoldPair (0x0422, 0x0442),
	|        new FoldPair (0x042A, 0x044A),
	|        new FoldPair (0x0432, 0x1C80),
	|        new FoldPair (0x0434, 0x1C81),
	|        new FoldPair (0x043E, 0x1C82),
	|        new FoldPair (0x0441, 0x1C83),
	|        new FoldPair (0x0442, 0x1C84),
	|        new FoldPair (0x044A, 0x1C86),
	|        new FoldPair (0x0462, 0x0463),
	|        new FoldPair (0x0463, 0x1C87),
	|        new FoldPair (0x1C80, 0x0412),
	|        new FoldPair (0x1C81, 0x0414),
	|        new FoldPair (0x1C82, 0x041E),
	|        new FoldPair (0x1C83, 0x0421),
	|        new FoldPair (0x1C84, 0x1C85),
	|        new FoldPair (0x1C85, 0x0422),
	|        new FoldPair (0x1C86, 0x042A),
	|        new FoldPair (0x1C87, 0x0462),
	|        new FoldPair (0x1C88, 0xA64A),
	|        new FoldPair (0x1E60, 0x1E61),
	|        new FoldPair (0x1E61, 0x1E9B),
	|        new FoldPair (0x1E9B, 0x1E60),
	|        new FoldPair (0x1E9E, 0x00DF),
	|        new FoldPair (0x1FBE, 0x0345),
	|        new FoldPair (0x2126, 0x03A9),
	|        new FoldPair (0x212A, 0x004B),
	|        new FoldPair (0x212B, 0x00C5),
	|        new FoldPair (0xA64A, 0xA64B),
	|        new FoldPair (0xA64B, 0x1C88),
	|    }; /* CaseOrbit */
	|
	|        // FoldCategory maps a category name to a table of
	|        // code points outside the category that are equivalent under
	|        // simple case folding to code points inside the category.
	|        // If there is no entry for a category name, there are no such points.
	|        static Dictionary<string, RangeTable> FoldCategory = new Dictionary<string, RangeTable>() {
	|         { ""Common"", foldCommon },
	|         { ""Greek"", foldGreek },
	|         { ""Inherited"", foldInherited },
	|         { ""L"", foldL },
	|         { ""Ll"", foldLl },
	|         { ""Lt"", foldLt },
	|         { ""Lu"", foldLu },
	|         { ""M"", foldM },
	|         { ""Mn"", foldMn },
	|    };
	|
	|        internal static RangeTable foldCommon = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x039c, 0x03bc, 32),
	|            }
	|        );
	|
	|        internal static RangeTable foldGreek = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x00b5, 0x0345, 656),
	|            }
	|        );
	|
	|        internal static RangeTable foldInherited = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x0399, 0x03b9, 32),
	|            new Range16 (0x1fbe, 0x1fbe, 1),
	|            }
	|        );
	|
	|        internal static RangeTable foldL = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x0345, 0x0345, 1),
	|            }
	|        );
	|
	|        internal static RangeTable foldLl = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x0041, 0x005a, 1),
	|            new Range16 (0x00c0, 0x00d6, 1),
	|            new Range16 (0x00d8, 0x00de, 1),
	|            new Range16 (0x0100, 0x012e, 2),
	|            new Range16 (0x0132, 0x0136, 2),
	|            new Range16 (0x0139, 0x0147, 2),
	|            new Range16 (0x014a, 0x0178, 2),
	|            new Range16 (0x0179, 0x017d, 2),
	|            new Range16 (0x0181, 0x0182, 1),
	|            new Range16 (0x0184, 0x0186, 2),
	|            new Range16 (0x0187, 0x0189, 2),
	|            new Range16 (0x018a, 0x018b, 1),
	|            new Range16 (0x018e, 0x0191, 1),
	|            new Range16 (0x0193, 0x0194, 1),
	|            new Range16 (0x0196, 0x0198, 1),
	|            new Range16 (0x019c, 0x019d, 1),
	|            new Range16 (0x019f, 0x01a0, 1),
	|            new Range16 (0x01a2, 0x01a6, 2),
	|            new Range16 (0x01a7, 0x01a9, 2),
	|            new Range16 (0x01ac, 0x01ae, 2),
	|            new Range16 (0x01af, 0x01b1, 2),
	|            new Range16 (0x01b2, 0x01b3, 1),
	|            new Range16 (0x01b5, 0x01b7, 2),
	|            new Range16 (0x01b8, 0x01bc, 4),
	|            new Range16 (0x01c4, 0x01c5, 1),
	|            new Range16 (0x01c7, 0x01c8, 1),
	|            new Range16 (0x01ca, 0x01cb, 1),
	|            new Range16 (0x01cd, 0x01db, 2),
	|            new Range16 (0x01de, 0x01ee, 2),
	|            new Range16 (0x01f1, 0x01f2, 1),
	|            new Range16 (0x01f4, 0x01f6, 2),
	|            new Range16 (0x01f7, 0x01f8, 1),
	|            new Range16 (0x01fa, 0x0232, 2),
	|            new Range16 (0x023a, 0x023b, 1),
	|            new Range16 (0x023d, 0x023e, 1),
	|            new Range16 (0x0241, 0x0243, 2),
	|            new Range16 (0x0244, 0x0246, 1),
	|            new Range16 (0x0248, 0x024e, 2),
	|            new Range16 (0x0345, 0x0370, 43),
	|            new Range16 (0x0372, 0x0376, 4),
	|            new Range16 (0x037f, 0x0386, 7),
	|            new Range16 (0x0388, 0x038a, 1),
	|            new Range16 (0x038c, 0x038e, 2),
	|            new Range16 (0x038f, 0x0391, 2),
	|            new Range16 (0x0392, 0x03a1, 1),
	|            new Range16 (0x03a3, 0x03ab, 1),
	|            new Range16 (0x03cf, 0x03d8, 9),
	|            new Range16 (0x03da, 0x03ee, 2),
	|            new Range16 (0x03f4, 0x03f7, 3),
	|            new Range16 (0x03f9, 0x03fa, 1),
	|            new Range16 (0x03fd, 0x042f, 1),
	|            new Range16 (0x0460, 0x0480, 2),
	|            new Range16 (0x048a, 0x04c0, 2),
	|            new Range16 (0x04c1, 0x04cd, 2),
	|            new Range16 (0x04d0, 0x052e, 2),
	|            new Range16 (0x0531, 0x0556, 1),
	|            new Range16 (0x10a0, 0x10c5, 1),
	|            new Range16 (0x10c7, 0x10cd, 6),
	|            new Range16 (0x13a0, 0x13f5, 1),
	|            new Range16 (0x1c90, 0x1cba, 1),
	|            new Range16 (0x1cbd, 0x1cbf, 1),
	|            new Range16 (0x1e00, 0x1e94, 2),
	|            new Range16 (0x1e9e, 0x1efe, 2),
	|            new Range16 (0x1f08, 0x1f0f, 1),
	|            new Range16 (0x1f18, 0x1f1d, 1),
	|            new Range16 (0x1f28, 0x1f2f, 1),
	|            new Range16 (0x1f38, 0x1f3f, 1),
	|            new Range16 (0x1f48, 0x1f4d, 1),
	|            new Range16 (0x1f59, 0x1f5f, 2),
	|            new Range16 (0x1f68, 0x1f6f, 1),
	|            new Range16 (0x1f88, 0x1f8f, 1),
	|            new Range16 (0x1f98, 0x1f9f, 1),
	|            new Range16 (0x1fa8, 0x1faf, 1),
	|            new Range16 (0x1fb8, 0x1fbc, 1),
	|            new Range16 (0x1fc8, 0x1fcc, 1),
	|            new Range16 (0x1fd8, 0x1fdb, 1),
	|            new Range16 (0x1fe8, 0x1fec, 1),
	|            new Range16 (0x1ff8, 0x1ffc, 1),
	|            new Range16 (0x2126, 0x212a, 4),
	|            new Range16 (0x212b, 0x2132, 7),
	|            new Range16 (0x2183, 0x2c00, 2685),
	|            new Range16 (0x2c01, 0x2c2f, 1),
	|            new Range16 (0x2c60, 0x2c62, 2),
	|            new Range16 (0x2c63, 0x2c64, 1),
	|            new Range16 (0x2c67, 0x2c6d, 2),
	|            new Range16 (0x2c6e, 0x2c70, 1),
	|            new Range16 (0x2c72, 0x2c75, 3),
	|            new Range16 (0x2c7e, 0x2c80, 1),
	|            new Range16 (0x2c82, 0x2ce2, 2),
	|            new Range16 (0x2ceb, 0x2ced, 2),
	|            new Range16 (0x2cf2, 0xa640, 31054),
	|            new Range16 (0xa642, 0xa66c, 2),
	|            new Range16 (0xa680, 0xa69a, 2),
	|            new Range16 (0xa722, 0xa72e, 2),
	|            new Range16 (0xa732, 0xa76e, 2),
	|            new Range16 (0xa779, 0xa77d, 2),
	|            new Range16 (0xa77e, 0xa786, 2),
	|            new Range16 (0xa78b, 0xa78d, 2),
	|            new Range16 (0xa790, 0xa792, 2),
	|            new Range16 (0xa796, 0xa7aa, 2),
	|            new Range16 (0xa7ab, 0xa7ae, 1),
	|            new Range16 (0xa7b0, 0xa7b4, 1),
	|            new Range16 (0xa7b6, 0xa7c4, 2),
	|            new Range16 (0xa7c5, 0xa7c7, 1),
	|            new Range16 (0xa7c9, 0xa7d0, 7),
	|            new Range16 (0xa7d6, 0xa7d8, 2),
	|            new Range16 (0xa7f5, 0xff21, 22316),
	|            new Range16 (0xff22, 0xff3a, 1),
	|            },
	|            r32: new Range32[] {
	|            new Range32 (0x10400, 0x10427, 1),
	|            new Range32 (0x104b0, 0x104d3, 1),
	|            new Range32 (0x10570, 0x1057a, 1),
	|            new Range32 (0x1057c, 0x1058a, 1),
	|            new Range32 (0x1058c, 0x10592, 1),
	|            new Range32 (0x10594, 0x10595, 1),
	|            new Range32 (0x10c80, 0x10cb2, 1),
	|            new Range32 (0x118a0, 0x118bf, 1),
	|            new Range32 (0x16e40, 0x16e5f, 1),
	|            new Range32 (0x1e900, 0x1e921, 1),
	|            },
	|            latinOffset: 3
	|        );
	|
	|        internal static RangeTable foldLt = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x01c4, 0x01c6, 2),
	|            new Range16 (0x01c7, 0x01c9, 2),
	|            new Range16 (0x01ca, 0x01cc, 2),
	|            new Range16 (0x01f1, 0x01f3, 2),
	|            new Range16 (0x1f80, 0x1f87, 1),
	|            new Range16 (0x1f90, 0x1f97, 1),
	|            new Range16 (0x1fa0, 0x1fa7, 1),
	|            new Range16 (0x1fb3, 0x1fc3, 16),
	|            new Range16 (0x1ff3, 0x1ff3, 1),
	|            }
	|        );
	|
	|        internal static RangeTable foldLu = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x0061, 0x007a, 1),
	|            new Range16 (0x00b5, 0x00df, 42),
	|            new Range16 (0x00e0, 0x00f6, 1),
	|            new Range16 (0x00f8, 0x00ff, 1),
	|            new Range16 (0x0101, 0x012f, 2),
	|            new Range16 (0x0133, 0x0137, 2),
	|            new Range16 (0x013a, 0x0148, 2),
	|            new Range16 (0x014b, 0x0177, 2),
	|            new Range16 (0x017a, 0x017e, 2),
	|            new Range16 (0x017f, 0x0180, 1),
	|            new Range16 (0x0183, 0x0185, 2),
	|            new Range16 (0x0188, 0x018c, 4),
	|            new Range16 (0x0192, 0x0195, 3),
	|            new Range16 (0x0199, 0x019a, 1),
	|            new Range16 (0x019e, 0x01a1, 3),
	|            new Range16 (0x01a3, 0x01a5, 2),
	|            new Range16 (0x01a8, 0x01ad, 5),
	|            new Range16 (0x01b0, 0x01b4, 4),
	|            new Range16 (0x01b6, 0x01b9, 3),
	|            new Range16 (0x01bd, 0x01bf, 2),
	|            new Range16 (0x01c5, 0x01c6, 1),
	|            new Range16 (0x01c8, 0x01c9, 1),
	|            new Range16 (0x01cb, 0x01cc, 1),
	|            new Range16 (0x01ce, 0x01dc, 2),
	|            new Range16 (0x01dd, 0x01ef, 2),
	|            new Range16 (0x01f2, 0x01f3, 1),
	|            new Range16 (0x01f5, 0x01f9, 4),
	|            new Range16 (0x01fb, 0x021f, 2),
	|            new Range16 (0x0223, 0x0233, 2),
	|            new Range16 (0x023c, 0x023f, 3),
	|            new Range16 (0x0240, 0x0242, 2),
	|            new Range16 (0x0247, 0x024f, 2),
	|            new Range16 (0x0250, 0x0254, 1),
	|            new Range16 (0x0256, 0x0257, 1),
	|            new Range16 (0x0259, 0x025b, 2),
	|            new Range16 (0x025c, 0x0260, 4),
	|            new Range16 (0x0261, 0x0265, 2),
	|            new Range16 (0x0266, 0x0268, 2),
	|            new Range16 (0x0269, 0x026c, 1),
	|            new Range16 (0x026f, 0x0271, 2),
	|            new Range16 (0x0272, 0x0275, 3),
	|            new Range16 (0x027d, 0x0280, 3),
	|            new Range16 (0x0282, 0x0283, 1),
	|            new Range16 (0x0287, 0x028c, 1),
	|            new Range16 (0x0292, 0x029d, 11),
	|            new Range16 (0x029e, 0x0345, 167),
	|            new Range16 (0x0371, 0x0373, 2),
	|            new Range16 (0x0377, 0x037b, 4),
	|            new Range16 (0x037c, 0x037d, 1),
	|            new Range16 (0x03ac, 0x03af, 1),
	|            new Range16 (0x03b1, 0x03ce, 1),
	|            new Range16 (0x03d0, 0x03d1, 1),
	|            new Range16 (0x03d5, 0x03d7, 1),
	|            new Range16 (0x03d9, 0x03ef, 2),
	|            new Range16 (0x03f0, 0x03f3, 1),
	|            new Range16 (0x03f5, 0x03fb, 3),
	|            new Range16 (0x0430, 0x045f, 1),
	|            new Range16 (0x0461, 0x0481, 2),
	|            new Range16 (0x048b, 0x04bf, 2),
	|            new Range16 (0x04c2, 0x04ce, 2),
	|            new Range16 (0x04cf, 0x052f, 2),
	|            new Range16 (0x0561, 0x0586, 1),
	|            new Range16 (0x10d0, 0x10fa, 1),
	|            new Range16 (0x10fd, 0x10ff, 1),
	|            new Range16 (0x13f8, 0x13fd, 1),
	|            new Range16 (0x1c80, 0x1c88, 1),
	|            new Range16 (0x1d79, 0x1d7d, 4),
	|            new Range16 (0x1d8e, 0x1e01, 115),
	|            new Range16 (0x1e03, 0x1e95, 2),
	|            new Range16 (0x1e9b, 0x1ea1, 6),
	|            new Range16 (0x1ea3, 0x1eff, 2),
	|            new Range16 (0x1f00, 0x1f07, 1),
	|            new Range16 (0x1f10, 0x1f15, 1),
	|            new Range16 (0x1f20, 0x1f27, 1),
	|            new Range16 (0x1f30, 0x1f37, 1),
	|            new Range16 (0x1f40, 0x1f45, 1),
	|            new Range16 (0x1f51, 0x1f57, 2),
	|            new Range16 (0x1f60, 0x1f67, 1),
	|            new Range16 (0x1f70, 0x1f7d, 1),
	|            new Range16 (0x1fb0, 0x1fb1, 1),
	|            new Range16 (0x1fbe, 0x1fd0, 18),
	|            new Range16 (0x1fd1, 0x1fe0, 15),
	|            new Range16 (0x1fe1, 0x1fe5, 4),
	|            new Range16 (0x214e, 0x2184, 54),
	|            new Range16 (0x2c30, 0x2c5f, 1),
	|            new Range16 (0x2c61, 0x2c65, 4),
	|            new Range16 (0x2c66, 0x2c6c, 2),
	|            new Range16 (0x2c73, 0x2c76, 3),
	|            new Range16 (0x2c81, 0x2ce3, 2),
	|            new Range16 (0x2cec, 0x2cee, 2),
	|            new Range16 (0x2cf3, 0x2d00, 13),
	|            new Range16 (0x2d01, 0x2d25, 1),
	|            new Range16 (0x2d27, 0x2d2d, 6),
	|            new Range16 (0xa641, 0xa66d, 2),
	|            new Range16 (0xa681, 0xa69b, 2),
	|            new Range16 (0xa723, 0xa72f, 2),
	|            new Range16 (0xa733, 0xa76f, 2),
	|            new Range16 (0xa77a, 0xa77c, 2),
	|            new Range16 (0xa77f, 0xa787, 2),
	|            new Range16 (0xa78c, 0xa791, 5),
	|            new Range16 (0xa793, 0xa794, 1),
	|            new Range16 (0xa797, 0xa7a9, 2),
	|            new Range16 (0xa7b5, 0xa7c3, 2),
	|            new Range16 (0xa7c8, 0xa7ca, 2),
	|            new Range16 (0xa7d1, 0xa7d7, 6),
	|            new Range16 (0xa7d9, 0xa7f6, 29),
	|            new Range16 (0xab53, 0xab70, 29),
	|            new Range16 (0xab71, 0xabbf, 1),
	|            new Range16 (0xff41, 0xff5a, 1),
	|            },
	|            r32: new Range32[] {
	|            new Range32 (0x10428, 0x1044f, 1),
	|            new Range32 (0x104d8, 0x104fb, 1),
	|            new Range32 (0x10597, 0x105a1, 1),
	|            new Range32 (0x105a3, 0x105b1, 1),
	|            new Range32 (0x105b3, 0x105b9, 1),
	|            new Range32 (0x105bb, 0x105bc, 1),
	|            new Range32 (0x10cc0, 0x10cf2, 1),
	|            new Range32 (0x118c0, 0x118df, 1),
	|            new Range32 (0x16e60, 0x16e7f, 1),
	|            new Range32 (0x1e922, 0x1e943, 1),
	|            },
	|            latinOffset: 4
	|        );
	|
	|        internal static RangeTable foldM = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x0399, 0x03b9, 32),
	|            new Range16 (0x1fbe, 0x1fbe, 1),
	|            }
	|        );
	|
	|        internal static RangeTable foldMn = new RangeTable(
	|            r16: new Range16[] {
	|            new Range16 (0x0399, 0x03b9, 32),
	|            new Range16 (0x1fbe, 0x1fbe, 1),
	|            }
	|        );
	|
	|        // FoldScript maps a script name to a table of
	|        // code points outside the script that are equivalent under
	|        // simple case folding to code points inside the script.
	|        // If there is no entry for a script name, there are no such points.
	|        static Dictionary<string, RangeTable> FoldScript = new Dictionary<string, RangeTable>()
	|        {
	|        };
	|
	|        // Range entries: 3675 16-bit, 2081 32-bit, 5756 total.
	|        // Range bytes: 22050 16-bit, 24972 32-bit, 47022 total.
	|
	|        // Fold orbit bytes: 88 pairs, 352 bytes
	|    } /* partial class Unicode */
	|    //=======================================================================
	|    // ustring.cs: UTF8 String representation
	|    //
	|    // Based on the Go strings code
	|    // 
	|    // C# ification by Miguel de Icaza
	|    //
	|    // TODO:
	|    //   Fields
	|    // 
	|    // TODO from .NET API:
	|    // String.Split members (array of strings, StringSplitOptions)
	|    // Replace, should it allow nulls?
	|    // Generally: what to do with null parameters, that we can avoid exceptions and produce a good result.
	|
	|    /// <summary>
	|    /// ustrings are used to manipulate utf8 strings, either from byte arrays or blocks of memory.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   The ustring provides a series of string-like operations over an array of bytes.   The buffer
	|    ///   is expected to contain an UTF8 encoded string, but if the buffer contains an invalid utf8
	|    ///   sequence many of the operations will continue to work.
	|    /// </para>
	|    /// <para>
	|    ///   The strings can be created either from byte arrays, a range within a byte array, or from a 
	|    ///   block of unmanaged memory.  The ustrings are created using one of the Make or MakeCopy methods 
	|    ///   in the class, not by invoking the new operator on the class.
	|    /// </para>
	|    /// <para>
	|    /// <list type=""table"">
	|    ///   <listheader>
	|    ///     <term>Method</term>
	|    ///     <term>Description</term>
	|    ///   </listheader>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.Make(string)""/></term>
	|    ///     <description>Creates a ustring from a C# string.</description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.Make(byte[])""/></term>
	|    ///     <description>Creates a ustring from a byte array.</description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.Make(byte[],int,int)""/></term>
	|    ///     <description>Creates a ustring from a range in a byte array.</description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.Make(uint[])""/></term>
	|    ///     <description>Creates a ustring from a single rune.</description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.Make(char[])""/></term>
	|    ///     <description>Creates a ustring from a character array.</description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.Make(System.IntPtr,int,System.Action{System.IntPtr})""/></term>
	|    ///     <description>Creates a ustring from an unmanaged memory block, with an optional method to invoke to release the block when the ustring is garbage collected.</description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.Make(System.IntPtr,System.Action{System.IntPtr})""/></term>
	|    ///     <description>
	|    ///       Creates a ustring from an unmanaged memory block that is null-terminated, suitable for interoperability with C APIs.   
	|    ///       It takes an optional method to invoke to release the block when the ustring is garbage collected.
	|    ///     </description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.MakeCopy(System.IntPtr,int)""/></term>
	|    ///     <description>Creates a ustring by making a copy of the provided memory block.</description>
	|    ///   </item>
	|    ///   <item>
	|    ///     <term><see cref=""M:NStack.ustring.MakeCopy(System.IntPtr)""/></term>
	|    ///     <description>
	|    ///       Creates a ustring by making a copy of the null-terminated memory block.   Suitable for interoperability with C APIs.   
	|    ///     </description>
	|    ///   </item>
	|    /// </list>
	|    /// </para>
	|    /// <para>
	|    ///   The Length property describes the length in bytes of the underlying array, while the RuneCount 
	|    ///   property describes the number of code points (or runes) that are represented by the underlying 
	|    ///   utf8 encoded buffer.
	|    /// </para>
	|    /// <para>
	|    ///   The ustring supports slicing by calling the indexer with two arguments, the argument represent
	|    ///   indexes into the underlying byte buffer.  The starting index is inclusive, while the ending index
	|    ///   is exclusive.   Negative values can be used to index the string from the end.  See the documentation
	|    ///   for the indexer for more details.
	|    /// </para>
	|    /// 
	|    /// </remarks>
	|    public abstract class ustring : IComparable<ustring>, IComparable, IConvertible, IEnumerable<uint>, IEquatable<ustring>
	|#if NETSTANDARD2_0
	|	, ICloneable
	|#endif
	|    {
	|
	|        // The ustring subclass that supports creating strings for an IntPtr+Size pair.
	|        class IntPtrUString : ustring, IDisposable
	|        {
	|            internal IntPtr block;
	|            readonly int size;
	|            bool copy;
	|            Action<IntPtr> release;
	|
	|            class IntPtrSubUString : IntPtrUString
	|            {
	|                IntPtrUString retain;
	|
	|                public IntPtrSubUString(IntPtrUString retain, IntPtr block, int size) : base(block, size, copy: false, releaseFunc: null)
	|                {
	|                    this.retain = retain;
	|                }
	|
	|                protected override void Dispose(bool disposing)
	|                {
	|                    base.Dispose(disposing);
	|                    retain = null;
	|                }
	|
	|            }
	|
	|            unsafe static int MeasureString(IntPtr block)
	|            {
	|                byte* p = (byte*)block;
	|                while (*p != 0)
	|                    p++;
	|                return (int)(p - ((byte*)block));
	|            }
	|
	|            public IntPtrUString(IntPtr block, bool copy, Action<IntPtr> releaseFunc = null) : this(block, MeasureString(block), copy, releaseFunc)
	|            {
	|            }
	|
	|            public IntPtrUString(IntPtr block, int size, bool copy, Action<IntPtr> releaseFunc = null)
	|            {
	|                if (block == IntPtr.Zero)
	|                    throw new ArgumentException(""Null pointer passed"", nameof(block));
	|                if (size < 0)
	|                    throw new ArgumentException(""Invalid size passed"", nameof(size));
	|                this.size = size;
	|
	|                this.copy = copy;
	|                if (copy)
	|                {
	|                    this.release = null;
	|                    if (size == 0)
	|                        size = 1;
	|                    this.block = Marshal.AllocHGlobal(size);
	|                    unsafe
	|                    {
	|                        Buffer.MemoryCopy((void*)block, (void*)this.block, size, size);
	|                    }
	|                }
	|                else
	|                {
	|                    this.block = block;
	|                    this.release = releaseFunc;
	|                }
	|            }
	|
	|            public override int Length => size;
	|            public override byte this[int index]
	|            {
	|                get
	|                {
	|                    if (index < 0 || index > size)
	|                        throw new ArgumentException(nameof(index));
	|                    return Marshal.ReadByte(block, index);
	|                }
	|            }
	|
	|            public override void CopyTo(int fromOffset, byte[] target, int targetOffset, int count)
	|            {
	|                if (fromOffset < 0 || fromOffset >= size)
	|                    throw new ArgumentException(nameof(fromOffset));
	|                if (count < 0)
	|                    throw new ArgumentException(nameof(count));
	|                if (fromOffset + count > size)
	|                    throw new ArgumentException(nameof(count));
	|                unsafe
	|                {
	|                    byte* p = ((byte*)block) + fromOffset;
	|
	|                    for (int i = 0; i < count; i++, p++)
	|                        target[i] = *p;
	|                }
	|            }
	|
	|            public override string ToString()
	|            {
	|                unsafe
	|                {
	|                    return Encoding.UTF8.GetString((byte*)block, size);
	|                }
	|            }
	|
	|            protected internal override ustring GetRange(int start, int end)
	|            {
	|                unsafe
	|                {
	|                    return new IntPtrSubUString(this, (IntPtr)((byte*)block + start), size: end - start);
	|                }
	|            }
	|
	|            internal override int RealIndexByte(byte b, int offset)
	|            {
	|                var t = size - offset;
	|                unsafe
	|                {
	|                    byte* p = (byte*)block + offset;
	|                    for (int i = 0; i < t; i++)
	|                    {
	|                        if (p[i] == b)
	|                            return i + offset;
	|                    }
	|                }
	|                return -1;
	|            }
	|
	|            public override byte[] ToByteArray()
	|            {
	|                var copy = new byte[size];
	|                Marshal.Copy(block, copy, 0, size);
	|                return copy;
	|            }
	|
	|            #region IDisposable Support
	|            protected virtual void Dispose(bool disposing)
	|            {
	|                if (block != IntPtr.Zero)
	|                {
	|                    if (copy)
	|                    {
	|                        Marshal.FreeHGlobal(block);
	|                    }
	|                    else if (release != null)
	|                        release(block);
	|                    release = null;
	|                    block = IntPtr.Zero;
	|                }
	|            }
	|
	|            ~IntPtrUString()
	|            {
	|                Dispose(false);
	|            }
	|
	|            // This code added to correctly implement the disposable pattern.
	|            void IDisposable.Dispose()
	|            {
	|                Dispose(true);
	|                GC.SuppressFinalize(this);
	|            }
	|            #endregion
	|        }
	|
	|        // The ustring implementation that is implemented on top of a byte buffer.
	|        class ByteBufferUString : ustring
	|        {
	|            internal readonly byte[] buffer;
	|
	|            public ByteBufferUString(byte[] buffer)
	|            {
	|                if (buffer == null)
	|                    throw new ArgumentNullException(nameof(buffer));
	|                this.buffer = buffer;
	|            }
	|
	|            public ByteBufferUString(uint rune)
	|            {
	|                var len = Utf8.RuneLen(rune);
	|                buffer = new byte[len];
	|                Utf8.EncodeRune(rune, buffer, 0);
	|            }
	|
	|            public ByteBufferUString(string str)
	|            {
	|                if (str == null)
	|                    throw new ArgumentNullException(nameof(str));
	|                buffer = Encoding.UTF8.GetBytes(str);
	|            }
	|
	|            public ByteBufferUString(params char[] chars)
	|            {
	|                if (chars == null)
	|                    throw new ArgumentNullException(nameof(chars));
	|                buffer = Encoding.UTF8.GetBytes(chars);
	|            }
	|
	|            public override int Length => buffer.Length;
	|            public override byte this[int index]
	|            {
	|                get
	|                {
	|                    return buffer[index];
	|                }
	|            }
	|
	|            public override void CopyTo(int fromOffset, byte[] target, int targetOffset, int count)
	|            {
	|                Array.Copy(buffer, fromOffset, target, targetOffset, count);
	|            }
	|
	|            public override string ToString()
	|            {
	|                return Encoding.UTF8.GetString(buffer);
	|            }
	|
	|            internal override int RealIndexByte(byte b, int offset)
	|            {
	|                var t = Length - offset;
	|                unsafe
	|                {
	|                    fixed (byte* p = &buffer[offset])
	|                    {
	|                        for (int i = 0; i < t; i++)
	|                            if (p[i] == b)
	|                                return i + offset;
	|                    }
	|                }
	|                return -1;
	|            }
	|
	|            protected internal override ustring GetRange(int start, int end)
	|            {
	|                return new ByteRangeUString(buffer, start, end - start);
	|            }
	|
	|            public override byte[] ToByteArray()
	|            {
	|                return buffer;
	|            }
	|        }
	|
	|        // The ustring implementation that presents a view on an existing byte buffer.
	|        class ByteRangeUString : ustring
	|        {
	|            readonly byte[] buffer;
	|            readonly int start, count;
	|
	|            public ByteRangeUString(byte[] buffer, int start, int count)
	|            {
	|                if (buffer == null)
	|                    throw new ArgumentNullException(nameof(buffer));
	|                if (start < 0)
	|                    throw new ArgumentException(nameof(start));
	|                if (count < 0)
	|                    throw new ArgumentException(nameof(count));
	|                if (start >= buffer.Length)
	|                    throw new ArgumentException(nameof(start));
	|                if (buffer.Length - count < start)
	|                    throw new ArgumentException(nameof(count));
	|                this.start = start;
	|                this.count = count;
	|                this.buffer = buffer;
	|            }
	|
	|            public override int Length => count;
	|            public override byte this[int index]
	|            {
	|                get
	|                {
	|                    if (index < 0 || index >= count)
	|                        throw new ArgumentException(nameof(index));
	|                    return buffer[start + index];
	|                }
	|            }
	|
	|            public override void CopyTo(int fromOffset, byte[] target, int targetOffset, int count)
	|            {
	|                if (fromOffset < 0)
	|                    throw new ArgumentException(nameof(fromOffset));
	|
	|                Array.Copy(buffer, fromOffset + start, target, targetOffset, count);
	|            }
	|
	|            public override string ToString()
	|            {
	|                return Encoding.UTF8.GetString(buffer, start, count);
	|            }
	|
	|            internal override int RealIndexByte(byte b, int offset)
	|            {
	|                var t = count - offset;
	|                unsafe
	|                {
	|                    fixed (byte* p = &buffer[start + offset])
	|                    {
	|                        for (int i = 0; i < t; i++)
	|                            if (p[i] == b)
	|                                return i + offset;
	|                    }
	|                }
	|                return -1;
	|            }
	|
	|            protected internal override ustring GetRange(int start, int end)
	|            {
	|                return new ByteRangeUString(buffer, start + this.start, end - start);
	|            }
	|
	|            public override byte[] ToByteArray()
	|            {
	|                var copy = new byte[count];
	|                Array.Copy(buffer, sourceIndex: start, destinationArray: copy, destinationIndex: 0, length: count);
	|                return copy;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The empty ustring.
	|        /// </summary>
	|        public static ustring Empty = new ByteBufferUString(Array.Empty<byte>());
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class using the provided byte array for its storage.
	|        /// </summary>
	|        /// <param name=""buffer"">Buffer containing the utf8 encoded string.</param>
	|        /// <remarks>
	|        /// <para>
	|        ///   No validation is performed on the contents of the byte buffer, so it
	|        ///   might contains invalid UTF-8 sequences.
	|        /// </para>
	|        /// <para>
	|        ///   No copy is made of the incoming byte buffer, so changes to it will be visible on the ustring.
	|        /// </para>
	|        /// </remarks>
	|        public static ustring Make(params byte[] buffer)
	|        {
	|            return new ByteBufferUString(buffer);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance using the provided rune as the sole character in the string.
	|        /// </summary>
	|        /// <param name=""rune"">Rune (short name for Unicode code point).</param>
	|        public static ustring Make(Rune rune)
	|        {
	|            return new ByteBufferUString((uint)rune);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from a string.
	|        /// </summary>
	|        /// <param name=""str"">C# String.</param>
	|        public static ustring Make(string str)
	|        {
	|            return new ByteBufferUString(str);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from an array of C# characters.
	|        /// </summary>
	|        /// <param name=""chars"">Characters.</param>
	|        public static ustring Make(params char[] chars)
	|        {
	|            return new ByteBufferUString(chars);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from an array of Runes.
	|        /// </summary>
	|        /// <returns>The make.</returns>
	|        /// <param name=""runes"">Runes.</param>
	|        public static ustring Make(IList<Rune> runes)
	|        {
	|            if (runes == null)
	|                throw new ArgumentNullException(nameof(runes));
	|            int size = 0;
	|            foreach (var rune in runes)
	|            {
	|                size += Utf8.RuneLen(rune);
	|            }
	|            var encoded = new byte[size];
	|            int offset = 0;
	|            foreach (var rune in runes)
	|            {
	|                offset += Utf8.EncodeRune(rune, encoded, offset);
	|            }
	|            return Make(encoded);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from an IEnumerable of runes
	|        /// </summary>
	|        /// <returns>The make.</returns>
	|        /// <param name=""runes"">Runes.</param>
	|        public static ustring Make(IEnumerable<Rune> runes)
	|        {
	|            return Make(runes.ToList());
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from an array of uints, which contain CodePoints.
	|        /// </summary>
	|        /// <returns>The make.</returns>
	|        /// <param name=""runes"">Runes.</param>
	|        public static ustring Make(uint[] runes)
	|        {
	|            if (runes == null)
	|                throw new ArgumentNullException(nameof(runes));
	|            int size = 0;
	|            foreach (var rune in runes)
	|            {
	|                size += Utf8.RuneLen(rune);
	|            }
	|            var encoded = new byte[size];
	|            int offset = 0;
	|            foreach (var rune in runes)
	|            {
	|                offset += Utf8.EncodeRune(rune, encoded, offset);
	|            }
	|            return Make(encoded);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from a block of memory and a size.
	|        /// </summary>
	|        /// <param name=""block"">Pointer to a block of memory.</param>
	|        /// <param name=""size"">Number of bytes in the block to treat as a string.</param>
	|        /// <param name=""releaseFunc"">Optional method to invoke to release when this string is finalized to clear the associated resources, you can use this for example to release the unamanged resource to which the block belongs.</param>
	|        /// <remarks>
	|        /// <para>
	|        ///    This will return a ustring that represents the block of memory provided.
	|        /// </para>
	|        /// <para>
	|        ///   The returned object will be a subclass of ustring that implements IDisposable, which you can use
	|        ///   to trigger the synchronous execution of the <paramref name=""releaseFunc""/>.   If you do not call
	|        ///   Dispose manually, the provided release function will be invoked from the finalizer thread.
	|        /// </para>
	|        /// <para>
	|        ///   Alternatively, if the block of data is something that you do not own, and you would like
	|        ///   to make a copy of it, you might want to consider using the <see cref=""T:NStack.ustring.MakeCopy(System.IntPtr,int)""/> method.
	|        /// </para>
	|        /// </remarks>
	|        public static ustring Make(IntPtr block, int size, Action<IntPtr> releaseFunc = null)
	|        {
	|            return new IntPtrUString(block, size, copy: false, releaseFunc: releaseFunc);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from a null terminated block of memory.
	|        /// </summary>
	|        /// <param name=""block"">Pointer to a block of memory, it is expected to be terminated by a 0 byte.</param>
	|        /// <param name=""releaseFunc"">Optional method to invoke to release when this string is finalized to clear the associated resources, you can use this for example to release the unamanged resource to which the block belongs.</param>
	|        /// <remarks>
	|        /// <para>
	|        ///    This will return a ustring that represents the block of memory provided.
	|        /// </para>
	|        /// <para>
	|        ///   The returned object will be a subclass of ustring that implements IDisposable, which you can use
	|        ///   to trigger the synchronous execution of the <paramref name=""releaseFunc""/>.   If you do not call
	|        ///   Dispose manually, the provided release function will be invoked from the finalizer thread.
	|        /// </para>
	|        /// <para>
	|        ///   Alternatively, if the block of data is something that you do not own, and you would like
	|        ///   to make a copy of it, you might want to consider using the <see cref=""T:NStack.ustring.MakeCopy(System.IntPtr)""/> method.
	|        /// </para>
	|        /// </remarks>
	|        public static ustring Make(IntPtr block, Action<IntPtr> releaseFunc = null)
	|        {
	|            return new IntPtrUString(block, copy: false, releaseFunc: releaseFunc);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> by making a copy of the specified block.
	|        /// </summary>
	|        /// <param name=""block"">Pointer to a block of memory which will be copied into the string.</param>
	|        /// <param name=""size"">Number of bytes in the block to treat as a string.</param>
	|        /// <remarks>
	|        /// <para>
	|        ///    This will return a ustring that contains a copy of the buffer pointed to by block.
	|        /// </para>
	|        /// <para>
	|        ///    This is useful when you do not control the lifecycle of the buffer pointed to and
	|        ///    desire the convenience of a method that makes a copy of the data for you.
	|        /// </para>
	|        /// </remarks>
	|        public static ustring MakeCopy(IntPtr block, int size)
	|        {
	|            return new IntPtrUString(block, size, copy: true, releaseFunc: null);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> by making a copy of the null-terminated block of memory.
	|        /// </summary>
	|        /// <param name=""block"">Pointer to a block of memory, it is expected to be terminated by a 0 byte.</param>
	|        /// <remarks>
	|        /// <para>
	|        ///    This will return a ustring that contains a copy of the zero-terminated buffer pointed to by block.
	|        /// </para>
	|        /// <para>
	|        ///   This is useful to create a string returned from C on a region of memory whose lifecycle
	|        ///   you do not control, so this will make a private copy of the buffer.
	|        /// </para>
	|        /// </remarks>
	|        public static ustring MakeCopy(IntPtr block)
	|        {
	|            return new IntPtrUString(block, copy: true, releaseFunc: null);
	|        }
	|
	|        // The low-level version
	|        unsafe static bool EqualsHelper(byte* a, byte* b, int length)
	|        {
	|            // unroll the loop
	|            // the mono jit will inline the 64-bit check and eliminate the irrelevant path
	|            if (sizeof(IntPtr) == 8)
	|            {
	|                // for AMD64 bit platform we unroll by 12 and
	|                // check 3 qword at a time. This is less code
	|                // than the 32 bit case and is shorter
	|                // pathlength
	|
	|                while (length >= 12)
	|                {
	|                    if (*(long*)a != *(long*)b) return false;
	|                    if (*(long*)(a + 4) != *(long*)(b + 4)) return false;
	|                    if (*(long*)(a + 8) != *(long*)(b + 8)) return false;
	|                    a += 12; b += 12; length -= 12;
	|                }
	|            }
	|            else
	|            {
	|                while (length >= 10)
	|                {
	|                    if (*(int*)a != *(int*)b) return false;
	|                    if (*(int*)(a + 2) != *(int*)(b + 2)) return false;
	|                    if (*(int*)(a + 4) != *(int*)(b + 4)) return false;
	|                    if (*(int*)(a + 6) != *(int*)(b + 6)) return false;
	|                    if (*(int*)(a + 8) != *(int*)(b + 8)) return false;
	|                    a += 10; b += 10; length -= 10;
	|                }
	|            }
	|
	|            while (length > 0)
	|            {
	|                if (*a != *b)
	|                    return false;
	|                a++;
	|                b++;
	|                length--;
	|            }
	|            return true;
	|        }
	|
	|        // The high-level version parameters have been validated
	|        static bool EqualsHelper(ustring a, ustring b)
	|        {
	|            // If both string are identical, return true.
	|            if (a.SequenceEqual(b))
	|            {
	|                return true;
	|            }
	|
	|            var alen = a.Length;
	|            var blen = b.Length;
	|            if (alen != blen)
	|                return false;
	|            if (alen == 0)
	|                return true;
	|            var abs = a as ByteBufferUString;
	|            var bbs = b as ByteBufferUString;
	|            if ((object)abs != null && (object)bbs != null)
	|            {
	|                unsafe
	|                {
	|                    fixed (byte* ap = &abs.buffer[0]) fixed (byte* bp = &bbs.buffer[0])
	|                    {
	|                        return EqualsHelper(ap, bp, alen);
	|                    }
	|                }
	|            }
	|            var aip = a as IntPtrUString;
	|            var bip = b as IntPtrUString;
	|            if ((object)aip != null && (object)bip != null)
	|            {
	|                unsafe
	|                {
	|                    return EqualsHelper((byte*)aip.block, (byte*)bip.block, alen);
	|                }
	|            }
	|
	|            for (int i = 0; i < alen; i++)
	|                if (a[i] != b[i])
	|                    return false;
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Determines whether a specified instance of <see cref=""NStack.ustring""/> is equal to another specified <see cref=""NStack.ustring""/>, this means that the contents of the string are identical
	|        /// </summary>
	|        /// <param name=""a"">The first <see cref=""NStack.ustring""/> to compare.</param>
	|        /// <param name=""b"">The second <see cref=""NStack.ustring""/> to compare.</param>
	|        /// <returns><c>true</c> if <c>a</c> and <c>b</c> are equal; otherwise, <c>false</c>.</returns>
	|        public static bool operator ==(ustring a, ustring b)
	|        {
	|            // If both are null, or both are same instance, return true.
	|            if (System.Object.ReferenceEquals(a, b))
	|            {
	|                return true;
	|            }
	|
	|            // If one is null, but not both, return false.
	|            if (((object)a == null) || ((object)b == null))
	|            {
	|                return false;
	|            }
	|
	|            return EqualsHelper(a, b);
	|        }
	|
	|        /// <summary>
	|        /// Determines whether a specified instance of <see cref=""NStack.ustring""/> is not equal to another specified <see cref=""NStack.ustring""/>.
	|        /// </summary>
	|        /// <param name=""a"">The first <see cref=""NStack.ustring""/> to compare.</param>
	|        /// <param name=""b"">The second <see cref=""NStack.ustring""/> to compare.</param>
	|        /// <returns><c>true</c> if <c>a</c> and <c>b</c> are not equal; otherwise, <c>false</c>.</returns>
	|        public static bool operator !=(ustring a, ustring b)
	|        {
	|            // If both are null, or both are same instance, return false
	|            if (System.Object.ReferenceEquals(a, b))
	|            {
	|                return false;
	|            }
	|
	|            // If one is null, but not both, return true.
	|            if (((object)a == null) || ((object)b == null))
	|            {
	|                return true;
	|            }
	|
	|            return !EqualsHelper(a, b);
	|        }
	|
	|        /// <summary>
	|        /// Implicit conversion from a C# string into a ustring.
	|        /// </summary>
	|        /// <returns>The ustring with the same contents as the string.</returns>
	|        /// <param name=""str"">The string to encode as a ustring.</param>
	|        /// <remarks>
	|        /// This will allocate a byte array and copy the contents of the 
	|        /// string encoded as UTF8 into it.
	|        /// </remarks>
	|        public static implicit operator ustring(string str)
	|        {
	|            if (str == null)
	|                return null;
	|
	|            return new ByteBufferUString(str);
	|        }
	|
	|        /// <summary>
	|        /// Implicit conversion from a byte array into a ustring.
	|        /// </summary>
	|        /// <returns>The ustring wrapping the existing byte array.</returns>
	|        /// <param name=""buffer"">The buffer containing the data.</param>
	|        /// <remarks>
	|        /// The returned string will keep a reference to the buffer, which 
	|        /// means that changes done to the buffer will be reflected into the
	|        /// ustring.
	|        /// </remarks>
	|        public static implicit operator ustring(byte[] buffer)
	|        {
	|            return new ByteBufferUString(buffer);
	|        }
	|
	|        /// <summary>
	|        /// Serves as a hash function for a <see cref=""T:NStack.ustring""/> object.
	|        /// </summary>
	|        /// <returns>A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a hash table.</returns>
	|        public override int GetHashCode()
	|        {
	|            return (int)HashStr().hash;
	|        }
	|
	|        /// <summary>
	|        /// Determines whether the specified <see cref=""object""/> is equal to the current <see cref=""T:NStack.ustring""/>.
	|        /// </summary>
	|        /// <param name=""obj"">The <see cref=""object""/> to compare with the current <see cref=""T:NStack.ustring""/>.</param>
	|        /// <returns><c>true</c> if the specified <see cref=""object""/> is equal to the current <see cref=""T:NStack.ustring""/>;
	|        /// otherwise, <c>false</c>.</returns>
	|        public override bool Equals(object obj)
	|        {
	|            // If parameter is null return false.
	|            if (obj == null)
	|                return false;
	|
	|            // If parameter cannot be cast to Point return false.
	|            ustring p = obj as ustring;
	|            if ((object)p == null)
	|                return false;
	|
	|            return EqualsHelper(this, p);
	|        }
	|
	|
	|        /// <summary>
	|        /// Determines whether the specified <see cref=""object""/> is equal to the current <see cref=""T:NStack.ustring""/>.
	|        /// </summary>
	|        /// <param name=""other"">The other string to compare with the current <see cref=""T:NStack.ustring""/>.</param>
	|        /// <returns><c>true</c> if the specified ustring is equal to the current ustring;
	|        /// otherwise, <c>false</c>.</returns>
	|        public bool Equals(ustring other)
	|        {
	|            // If parameter is null return false.
	|            if ((object)other == null)
	|                return false;
	|
	|            return EqualsHelper(this, other);
	|
	|        }
	|
	|        /// <summary>
	|        /// Reports whether this string and the provided string, when interpreted as UTF-8 strings, are equal under Unicode case-folding
	|        /// </summary>
	|        /// <returns><c>true</c>, if fold was equaled, <c>false</c> otherwise.</returns>
	|        /// <param name=""other"">Other.</param>
	|        public bool EqualsFold(ustring other)
	|        {
	|            if ((object)other == null)
	|                return false;
	|
	|            int slen = Length;
	|            int tlen = other.Length;
	|
	|            int soffset = 0, toffset = 0;
	|            while (soffset < slen && toffset < tlen)
	|            {
	|                // Extract first rune of each string
	|                uint sr, tr;
	|                int size;
	|
	|                var rune = this[soffset];
	|                if (rune < Utf8.RuneSelf)
	|                {
	|                    sr = rune;
	|                    soffset++;
	|                }
	|                else
	|                {
	|                    (sr, size) = Utf8.DecodeRune(this, soffset);
	|                    soffset += size;
	|                }
	|                rune = other[toffset];
	|                if (rune < Utf8.RuneSelf)
	|                {
	|                    tr = rune;
	|                    toffset++;
	|                }
	|                else
	|                {
	|                    (tr, size) = Utf8.DecodeRune(other, toffset);
	|                    toffset += size;
	|                }
	|                // If they match, keep going; if not, return false.
	|                // Easy case.
	|                if (tr == sr)
	|                    continue;
	|                // Make sr < tr to simplify what follows.
	|                if (tr < sr)
	|                {
	|                    var x = tr;
	|                    tr = sr;
	|                    sr = x;
	|                }
	|                // Fast check for ascii
	|                if (tr < Utf8.RuneSelf && 'A' <= sr && sr <= 'Z')
	|                {
	|                    // ASCII, and sr is upper case.  tr must be lower case.
	|                    if (tr == sr + 'a' - 'A')
	|                        continue;
	|                    return false;
	|                }
	|                // General case. SimpleFold(x) returns the next equivalent rune > x
	|                // or wraps around to smaller values.
	|                var r = Unicode.SimpleFold(sr);
	|                while (r != sr && r < tr)
	|                {
	|                    r = Unicode.SimpleFold(r);
	|                }
	|                if (r == tr)
	|                    continue;
	|                return false;
	|            }
	|            return (soffset == Length && toffset == other.Length);
	|        }
	|
	|        /// <summary>
	|        /// The Copy method makes a copy of the underlying data, it can be used to release the resources associated with an
	|        /// unmanaged buffer, or a ranged string.
	|        /// </summary>
	|        /// <returns>A copy of the underlying data.</returns>
	|        public ustring Copy()
	|        {
	|            return new ByteBufferUString(this.ToByteArray());
	|        }
	|
	|#if NETSTANDARD2_0
	|		object ICloneable.Clone ()
	|		{
	|			return Copy ();
	|		}
	|#endif
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:NStack.ustring""/> class from a byte array.
	|        /// </summary>
	|        /// <param name=""buffer"">Buffer containing the utf8 encoded string.</param>
	|        /// <param name=""start"">Starting offset into the buffer.</param>
	|        /// <param name=""count"">Number of bytes to consume from the buffer.</param>
	|        /// <remarks>
	|        /// <para>
	|        /// No validation is performed on the contents of the byte buffer, so it
	|        /// might contains invalid UTF-8 sequences.
	|        /// </para>
	|        /// <para>
	|        /// This will make a copy of the buffer range.
	|        /// </para>
	|        /// </remarks>
	|        public static ustring Make(byte[] buffer, int start, int count)
	|        {
	|            return new ByteRangeUString(buffer, start, count);
	|        }
	|
	|        /// <summary>
	|        /// Gets the length in bytes of the byte buffer.
	|        /// </summary>
	|        /// <value>The length in bytes of the encoded UTF8 string, does not represent the number of runes.</value>
	|        /// <remarks>To obtain the number of runes in the string, use the <see cref=""P:System.ustring.RuneCount""/> property.</remarks>
	|        public abstract int Length { get; }
	|
	|        /// <summary>
	|        /// Returns the byte at the specified position.
	|        /// </summary>
	|        /// <value>The byte encoded at the specified position.</value>
	|        /// <remarks>The index value should be between 0 and Length-1.</remarks>
	|        public abstract byte this[int index] { get; }
	|
	|        /// <summary>
	|        /// For internal use, returns the range of bytes specified.
	|        /// </summary>
	|        /// <returns>The range.</returns>
	|        /// <param name=""start"">Start.</param>
	|        /// <param name=""end"">End.</param>
	|        protected internal abstract ustring GetRange(int start, int end);
	|
	|        /// <summary>
	|        /// Returns a slice of the ustring delimited by the [start, end) range.  If the range is invalid, the return is the Empty string.
	|        /// </summary>
	|        /// <param name=""start"">Start index, this value is inclusive.   If the value is negative, the value is added to the length, allowing this parameter to count to count from the end of the string.</param>
	|        /// <param name=""end"">End index, this value is exclusive.   If the value is negative, the value is added to the length, plus one, allowing this parameter to count from the end of the string.</param>
	|        /// <remarks>
	|        /// <para>
	|        /// Some examples given the string ""1234567890"":
	|        /// </para>
	|        /// <para>The range [0, 4] produces ""1234""</para>
	|        /// <para>The range [8, 10] produces ""90""</para>
	|        /// <para>The range [8, null] produces ""90""</para>
	|        /// <para>The range [-2, null] produces ""90""</para>
	|        /// <para>The range [8, 9] produces ""9""</para>
	|        /// <para>The range [-4, -1] produces ""789""</para>
	|        /// <para>The range [-4, null] produces ""7890""</para>
	|        /// <para>The range [-4, null] produces ""7890""</para>
	|        /// <para>The range [-9, -3] produces ""234567""</para>
	|        /// <para>The range [0, 0] produces the empty string</para>
	|        /// <para>
	|        ///   This indexer does not raise exceptions for invalid indexes, instead the value 
	|        ///   returned is the ustring.Empty value:
	|        /// </para>
	|        /// <para>
	|        ///   The range [100, 200] produces the ustring.Empty
	|        /// </para>
	|        /// <para>
	|        ///   The range [-100, 0] produces ustring.Empty
	|        /// </para>
	|        /// <para>
	|        ///   To simulate the optional end boundary, use the indexer that takes the
	|        ///   object parameter and pass a null to it.   For example, to fetch all
	|        ///   elements from the position five until the end, use [5, null]
	|        /// </para>
	|        /// </remarks>
	|        public ustring this[int start, int end]
	|        {
	|            get
	|            {
	|                int size = Length;
	|                if (end < 0)
	|                    end = size + end;
	|
	|                if (start < 0)
	|                    start = size + start;
	|
	|                if (start < 0 || start >= size || start >= end)
	|                    return Empty;
	|                if (end < 0 || end > size)
	|                    return Empty;
	|                return GetRange(start, end);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns a slice of the ustring delimited by the [start, last-element-of-the-string range.  If the range is invalid, the return is the Empty string.
	|        /// </summary>
	|        /// <param name=""start"">Byte start index, this value is inclusive.   If the value is negative, the value is added to the length, allowing this parameter to count to count from the end of the string.</param>
	|        /// <param name=""end"">Byte end index.  This value is expected to be null to indicate that it should be the last element of the string.</param>
	|        /// <remarks>
	|        /// <para>
	|        /// This is a companion indexer to the indexer that takes two integers, it only exists
	|        /// to provide the optional end argument to mean ""until the end"", and to make the code
	|        /// that uses indexer look familiar, without having to resort to another API.
	|        /// 
	|        /// Some examples given the string ""1234567890"":
	|        /// </para>
	|        /// <para>
	|        ///   The indexes are byte indexes, they are not rune indexes.
	|        /// </para>
	|        /// <para>The range [8, null] produces ""90""</para>
	|        /// <para>The range [-2, null] produces ""90""</para>
	|        /// <para>The range [8, 9] produces ""9""</para>
	|        /// <para>The range [-4, -1] produces ""789""</para>
	|        /// <para>The range [-4, null] produces ""7890""</para>
	|        /// <para>The range [-4, null] produces ""7890""</para>
	|        /// <para>The range [-9, -3] produces ""234567""</para>
	|        /// <para>
	|        ///   This indexer does not raise exceptions for invalid indexes, instead the value 
	|        ///   returned is the ustring.Empty value:
	|        /// </para>
	|        /// <para>
	|        ///   The range [100, 200] produces the ustring.Empty
	|        /// </para>
	|        /// <para>
	|        ///   The range [-100, 0] produces ustring.Empty
	|        /// </para>
	|        /// <para>
	|        ///   To simulate the optional end boundary, use the indexer that takes the
	|        ///   object parameter and pass a null to it.   For example, to fetch all
	|        ///   elements from the position five until the end, use [5, null]
	|        /// </para>
	|        /// </remarks>
	|        public ustring this[int start, object end]
	|        {
	|            get
	|            {
	|                int size = Length;
	|                int iend = size;
	|                if (start < 0)
	|                    start = size + start;
	|
	|                if (start < 0 || start >= size || start >= iend)
	|                    return Empty;
	|                if (iend < 0 || iend > size)
	|                    return Empty;
	|                return GetRange(start, iend);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the substring starting at the given position in bytes from the origin of the Utf8 string.   
	|        /// Use RuneSubstring to extract substrings based on the rune index, rather than the byte index inside the
	|        /// Utf8 encoded string.
	|        /// </summary>
	|        /// <returns>The substring starting at the specified offset.</returns>
	|        /// <param name=""byteStart"">Starting point, default value is 0.</param>
	|        /// <param name=""length"">The substring length.</param>
	|        public ustring Substring(int byteStart, int length = 0)
	|        {
	|            if (length <= 0)
	|                length = Length - byteStart;
	|            if (byteStart < 0)
	|                byteStart = 0;
	|            return GetRange(byteStart, byteStart + length);
	|        }
	|
	|        /// <summary>
	|        /// Returns the substring starting at the given position in rune index from the origin of the Utf8 string.
	|        /// </summary>
	|        /// <returns>The substring starting at the specified offset.</returns>
	|        /// <param name=""runeStart"">Starting point, default value is 0.</param>
	|        /// <param name=""length"">The substring length.</param>
	|        public ustring RuneSubstring(int runeStart, int length = 0)
	|        {
	|            if (length <= 0)
	|                length = Length - runeStart;
	|            if (runeStart < 0)
	|                runeStart = 0;
	|
	|            var runes = this.ToRunes();
	|            ustring usRange = """";
	|            for (int i = runeStart; i < runeStart + length; i++)
	|            {
	|                usRange += ustring.Make(runes[i]);
	|            }
	|            return usRange;
	|        }
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref=""T:NStack.ustring""/> is empty.
	|        /// </summary>
	|        /// <value><c>true</c> if is empty (Length is zero); otherwise, <c>false</c>.</value>
	|        public bool IsEmpty => Length == 0;
	|
	|        /// <summary>
	|        /// Gets the rune count of the string.
	|        /// </summary>
	|        /// <value>The rune count.</value>
	|        public int RuneCount => Utf8.RuneCount(this);
	|
	|        /// <summary>
	|        /// Returns the number of columns used by the unicode string on console applications. 
	|        /// This is done by calling the Rune.ColumnWidth or zero, if it's negative, on each rune.
	|        /// </summary>
	|        public int ConsoleWidth
	|        {
	|            get
	|            {
	|                int total = 0;
	|                int blen = Length;
	|                for (int i = 0; i < blen;)
	|                {
	|                    (var rune, var size) = Utf8.DecodeRune(this, i, i - blen);
	|                    i += size;
	|                    total += Math.Max(Rune.ColumnWidth(rune), 0);
	|                }
	|                return total;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Copies the specified number of bytes from the underlying ustring representation to the target array at the specified offset.
	|        /// </summary>
	|        /// <param name=""fromOffset"">Offset in the underlying ustring buffer to copy from.</param>
	|        /// <param name=""target"">Target array where the buffer contents will be copied to.</param>
	|        /// <param name=""targetOffset"">Offset into the target array where this will be copied to.</param>
	|        /// <param name=""count"">Number of bytes to copy.</param>
	|        public abstract void CopyTo(int fromOffset, byte[] target, int targetOffset, int count);
	|
	|        /// <summary>
	|        /// Returns a version of the ustring as a byte array, it might allocate or return the internal byte buffer, depending on the backing implementation.
	|        /// </summary>
	|        /// <returns>A byte array containing the contents of the ustring.</returns>
	|        /// <remarks>
	|        /// The byte array contains either a copy of the underlying data, in the cases where the ustring was created
	|        /// from an unmanaged pointer or when the ustring was created by either slicing or from a range withing a byte
	|        /// array.   Otherwise the returned array that is used by the ustring itself.
	|        /// </remarks>
	|        public abstract byte[] ToByteArray();
	|
	|        /// <summary>
	|        /// Concatenates the provided ustrings into a new ustring.
	|        /// </summary>
	|        /// <returns>A new ustring that contains the concatenation of all the ustrings.</returns>
	|        /// <param name=""args"">One or more ustrings.</param>
	|        public static ustring Concat(params ustring[] args)
	|        {
	|            if (args == null)
	|                throw new ArgumentNullException(nameof(args));
	|            var t = 0;
	|            foreach (var x in args)
	|                t += x.Length;
	|            var copy = new byte[t];
	|            int p = 0;
	|
	|            foreach (var x in args)
	|            {
	|                var n = x.Length;
	|                x.CopyTo(fromOffset: 0, target: copy, targetOffset: p, count: n);
	|                p += n;
	|            }
	|            return new ByteBufferUString(copy);
	|        }
	|
	|        /// <summary>
	|        /// Explode splits the string into a slice of UTF-8 strings
	|        /// </summary>
	|        /// <returns>, one string per unicode character, 
	|        /// up to the specified limit.</returns>
	|        /// <param name=""limit"">Maximum number of entries to return, or -1 for no limits.</param>
	|        public ustring[] Explode(int limit = -1)
	|        {
	|            var n = Utf8.RuneCount(this);
	|            if (limit < 0 || n > limit)
	|                limit = n;
	|            var result = new ustring[limit];
	|            int offset = 0;
	|            for (int i = 0; i < limit - 1; i++)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, offset);
	|                if (rune == Utf8.RuneError)
	|                    result[i] = new ByteBufferUString(Utf8.RuneError);
	|                else
	|                {
	|                    var substr = new byte[size];
	|
	|                    CopyTo(fromOffset: offset, target: substr, targetOffset: 0, count: size);
	|                    result[i] = new ByteBufferUString(substr);
	|                }
	|                offset += size;
	|            }
	|            if (n > 0)
	|            {
	|                var r = new byte[Length - offset];
	|
	|                CopyTo(fromOffset: offset, target: r, targetOffset: 0, count: Length - offset);
	|                result[n - 1] = new ByteBufferUString(r);
	|            }
	|            return result;
	|        }
	|
	|        /// <summary>
	|        /// Converts a ustring into a rune array.
	|        /// </summary>
	|        /// <returns>An array containing the runes for the string up to the specified limit.</returns>
	|        /// <param name=""limit"">Maximum number of entries to return, or -1 for no limits.</param>
	|        public uint[] ToRunes(int limit = -1)
	|        {
	|            var n = Utf8.RuneCount(this);
	|            if (limit < 0 || n > limit)
	|                limit = n;
	|            var result = new uint[limit];
	|            int offset = 0;
	|            for (int i = 0; i < limit; i++)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, offset);
	|                result[i] = rune;
	|                offset += size;
	|            }
	|            return result;
	|        }
	|
	|        /// <summary>
	|        /// Converts a ustring into a List of runes.
	|        /// </summary>
	|        /// <returns>A list containing the runes for the string, it is not bound by any limits.</returns>
	|        public List<Rune> ToRuneList()
	|        {
	|            var result = new List<Rune>();
	|            for (int offset = 0; offset < Length;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, offset);
	|                result.Add(rune);
	|                offset += size;
	|            }
	|            return result;
	|        }
	|
	|        /// <summary>
	|        /// Converts a ustring into a rune array.
	|        /// </summary>
	|        /// <returns>An array containing the runes for the string up to the specified limit.</returns>
	|        /// <param name=""limit"">Maximum number of entries to return, or -1 for no limits.</param>
	|        public List<Rune> ToRuneList(int limit)
	|        {
	|            var n = Utf8.RuneCount(this);
	|            if (limit < 0 || n > limit)
	|                limit = n;
	|            var result = new List<Rune>();
	|            int offset = 0;
	|            for (int i = 0; i < limit; i++)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, offset);
	|                result[i] = rune;
	|                offset += size;
	|            }
	|            return result;
	|        }
	|
	|        // primeRK is the prime base used in Rabin-Karp algorithm.
	|        const uint primeRK = 16777619;
	|
	|        // hashStr returns the hash and the appropriate multiplicative
	|        // factor for use in Rabin-Karp algorithm.
	|        internal (uint hash, uint multFactor) HashStr()
	|        {
	|            uint hash = 0;
	|            int count = Length;
	|            for (int i = 0; i < count; i++)
	|                hash = hash * primeRK + (uint)(this[i]);
	|
	|            uint pow = 1, sq = primeRK;
	|            for (int i = count; i > 0; i >>= 1)
	|            {
	|                if ((i & 1) != 0)
	|                    pow *= sq;
	|                sq *= sq;
	|            }
	|            return (hash, pow);
	|        }
	|
	|        // hashStrRev returns the hash of the reverse of sep and the
	|        // appropriate multiplicative factor for use in Rabin-Karp algorithm.
	|        internal (uint hash, uint multFactor) RevHashStr()
	|        {
	|            uint hash = 0;
	|
	|            int count = Length;
	|            for (int i = count - 1; i >= 0; i--)
	|            {
	|                hash = hash * primeRK + (uint)(this[i]);
	|            }
	|
	|            uint pow = 1, sq = primeRK;
	|
	|            for (int i = count; i > 0; i >>= 1)
	|            {
	|                if ((i & 1) != 0)
	|                {
	|                    pow *= sq;
	|                }
	|                sq *= sq;
	|            }
	|            return (hash, pow);
	|        }
	|
	|        /// <summary>
	|        /// Count the number of non-overlapping instances of substr in the string.
	|        /// </summary>
	|        /// <returns>If substr is an empty string, Count returns 1 + the number of Unicode code points in the string, otherwise the count of non-overlapping instances in string.</returns>
	|        /// <param name=""substr"">Substr.</param>
	|        public int Count(ustring substr)
	|        {
	|            if ((object)substr == null)
	|                throw new ArgumentNullException(nameof(substr));
	|            int n = 0;
	|            if (substr.Length == 0)
	|                return Utf8.RuneCount(this) + 1;
	|            int offset = 0;
	|            int len = Length;
	|            int slen = substr.Length;
	|            while (offset < len)
	|            {
	|                var i = IndexOf(substr, offset);
	|                if (i == -1)
	|                    break;
	|                n++;
	|                offset = i + slen;
	|            }
	|            return n;
	|        }
	|
	|        /// <summary>
	|        /// Returns a value indicating whether a specified substring occurs within this string.
	|        /// </summary>
	|        /// <returns>true if the <paramref name=""substr"" /> parameter occurs within this string, or if <paramref name=""substr"" /> is the empty string (""""); otherwise, false.</returns>
	|        /// <param name=""substr"">The string to seek.</param>
	|        public bool Contains(ustring substr)
	|        {
	|            if ((object)substr == null)
	|                throw new ArgumentNullException(nameof(substr));
	|            return IndexOf(substr) >= 0;
	|        }
	|
	|        /// <summary>
	|        /// Returns a value indicating whether a specified rune occurs within this string.
	|        /// </summary>
	|        /// <returns>true if the <paramref name=""rune"" /> parameter occurs within this string; otherwise, false.</returns>
	|        /// <param name=""rune"">The rune to seek.</param>
	|        public bool Contains(uint rune)
	|        {
	|            return IndexOf(rune) >= 0;
	|        }
	|
	|        /// <summary>
	|        /// Returns a value indicating whether any of the characters in the provided string occurs within this string.
	|        /// </summary>
	|        /// <returns>true if any of the characters in <paramref name=""chars"" /> parameter occurs within this string; otherwise, false.</returns>
	|        /// <param name=""chars"">string containing one or more characters.</param>
	|        public bool ContainsAny(ustring chars)
	|        {
	|            if ((object)chars == null)
	|                throw new ArgumentNullException(nameof(chars));
	|            return IndexOfAny(chars) >= 0;
	|        }
	|
	|        /// <summary>
	|        /// Returns a value indicating whether any of the runes occurs within this string.
	|        /// </summary>
	|        /// <returns>true if any of the runes in <paramref name=""runes"" /> parameter occurs within this string; otherwise, false.</returns>
	|        /// <param name=""runes"">one or more runes.</param>
	|        public bool ContainsAny(params uint[] runes)
	|        {
	|            return IndexOfAny(runes) >= 0;
	|        }
	|
	|        static bool CompareArrayRange(byte[] first, int firstStart, int firstCount, byte[] second)
	|        {
	|            for (int i = 0; i < firstCount; i++)
	|                if (first[i + firstStart] != second[i])
	|                    return false;
	|            return true;
	|        }
	|
	|        static bool CompareStringRange(ustring first, int firstStart, int firstCount, ustring second)
	|        {
	|            for (int i = 0; i < firstCount; i++)
	|                if (first[i + firstStart] != second[i])
	|                    return false;
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance. 
	|        /// </summary>
	|        /// <returns>The zero-based index position of value if that character is found, or -1 if it is not.   The index position returned is relative to the start of the substring, not to the offset.</returns>
	|        /// <param name=""substr"">The string to seek.</param>
	|        /// <param name=""offset"">The search starting position.</param>
	|        public int IndexOf(ustring substr, int offset = 0)
	|        {
	|            if ((object)substr == null)
	|                throw new ArgumentNullException(nameof(substr));
	|
	|            var n = substr.Length;
	|            if (n == 0)
	|                return offset;
	|            var blen = Length;
	|            if (offset < 0 || offset > blen)
	|                throw new ArgumentException(nameof(offset));
	|            if (n > blen)
	|                return -1;
	|            if (n == 1)
	|                return RealIndexByte(substr[0], offset);
	|            if (blen == n)
	|            {
	|                if (this == substr)
	|                    return 0;
	|                return -1;
	|            }
	|            blen -= offset;
	|            if (n == blen)
	|            {
	|                // If the offset is zero, we can compare identity
	|                if (offset == 0)
	|                {
	|                    if (((object)substr == (object)this))
	|                        return offset;
	|                }
	|
	|                if (CompareStringRange(this, offset, n, substr))
	|                    return offset;
	|                return -1;
	|            }
	|            if (n > blen)
	|                return -1;
	|            // Rabin-Karp search
	|            (var hashss, var pow) = substr.HashStr();
	|            uint h = 0;
	|
	|            for (int i = 0; i < n; i++)
	|                h = h * primeRK + (uint)(this[i + offset]);
	|
	|            if (h == hashss && CompareStringRange(this, offset, n, substr))
	|                return offset;
	|
	|            for (int i = n; i < blen;)
	|            {
	|                var reali = offset + i;
	|                h *= primeRK;
	|
	|                h += (uint)this[reali];
	|
	|                h -= pow * (uint)(this[reali - n]);
	|                i++;
	|                reali++;
	|                if (h == hashss && CompareStringRange(this, reali - n, n, substr))
	|                    return reali - n;
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Reports the zero-based index position of the last occurrence of a specified substring within this instance
	|        /// </summary>
	|        /// <returns>The zero-based index position of <paramref name=""substr"" /> if that character is found, or -1 if it is not.</returns>
	|        /// <param name=""substr"">The ustring to seek.</param>
	|        public int LastIndexOf(ustring substr)
	|        {
	|            if ((object)substr == null)
	|                throw new ArgumentNullException(nameof(substr));
	|            var n = substr.Length;
	|            if (n == 0)
	|                return Length;
	|            if (n == 1)
	|                return LastIndexByte(substr[0]);
	|            if (n == Length)
	|            {
	|                if (((object)substr == (object)this))
	|                    return 0;
	|
	|                if (CompareStringRange(substr, 0, n, this))
	|                    return 0;
	|                return -1;
	|            }
	|            if (n > Length)
	|                return -1;
	|
	|            // Rabin-Karp search from the end of the string
	|            (var hashss, var pow) = substr.RevHashStr();
	|            var last = Length - n;
	|            uint h = 0;
	|            for (int i = Length - 1; i >= last; i--)
	|                h = h * primeRK + (uint)this[i];
	|
	|            if (h == hashss && CompareStringRange(this, last, Length - last, substr))
	|                return last;
	|
	|            for (int i = last - 1; i >= 0; i--)
	|            {
	|                h *= primeRK;
	|                h += (uint)(this[i]);
	|                h -= pow * (uint)(this[i + n]);
	|                if (h == hashss && CompareStringRange(this, i, n, substr))
	|                    return i;
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Reports the zero-based index position of the last occurrence of a specified byte on the underlying byte buffer.
	|        /// </summary>
	|        /// <returns>The zero-based index position of <paramref name=""b"" /> if that byte is found, or -1 if it is not.  </returns>
	|        /// <param name=""b"">The byte to seek.</param>
	|        public int LastIndexByte(byte b)
	|        {
	|            for (int i = Length - 1; i >= 0; i--)
	|                if (this[i] == b)
	|                    return i;
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Reports the zero-based index of the first occurrence of the specified Unicode rune in this string
	|        /// </summary>
	|        /// <returns>The zero-based index position of <paramref name=""rune"" /> if that character is found, or -1 if it is not.  If the rune is Utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        /// <param name=""offset"">Starting offset to start the search from.</param>
	|        public int IndexOf(uint rune, int offset = 0)
	|        {
	|            if (rune < Utf8.RuneSelf)
	|                return IndexByte((byte)rune, offset);
	|            if (rune == Utf8.RuneError)
	|                return Utf8.InvalidIndex(this);
	|            if (!Utf8.ValidRune(rune))
	|                return -1;
	|            return IndexOf(new ByteBufferUString(rune));
	|        }
	|
	|        /// <summary>
	|        /// Reports the zero-based index of the first occurrence of the specified byte in the underlying byte buffer.
	|        /// </summary>
	|        /// <returns>The zero-based index position of <paramref name=""b"" /> if that byte is found, or -1 if it is not.  </returns>
	|        /// <param name=""b"">The byte to seek.</param>
	|        /// <param name=""offset"">Starting location.</param>
	|        public int IndexByte(byte b, int offset)
	|        {
	|            if (offset < 0 || offset > Length)
	|                throw new ArgumentException(nameof(offset));
	|            if (Length == 0)
	|                return -1;
	|            return RealIndexByte(b, offset);
	|        }
	|
	|        internal abstract int RealIndexByte(byte b, int offset);
	|
	|        /// <summary>
	|        /// Reports the zero-based index of the first occurrence in this instance of any character in the provided string
	|        /// </summary>
	|        /// <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name=""chars"" /> was found; -1 if no character in <paramref name=""chars"" /> was found.</returns>
	|        /// <param name=""chars"">ustring containing characters to seek.</param>
	|        public int IndexOfAny(ustring chars)
	|        {
	|            if ((object)chars == null)
	|                throw new ArgumentNullException(nameof(chars));
	|            if (chars.Length == 0)
	|                return -1;
	|            var blen = Length;
	|            if (blen > 8)
	|            {
	|                AsciiSet aset;
	|                if (AsciiSet.MakeAsciiSet(ref aset, chars))
	|                {
	|                    for (int i = 0; i < blen; i++)
	|                        if (AsciiSet.Contains(ref aset, this[i]))
	|                            return i;
	|                    return -1;
	|                }
	|            }
	|            var clen = chars.Length;
	|
	|            for (int i = 0; i < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, i, i - blen);
	|                for (int j = 0; j < clen;)
	|                {
	|                    (var crune, var csize) = Utf8.DecodeRune(chars, j, j - clen);
	|                    if (crune == rune)
	|                        return i;
	|                    j += csize;
	|                }
	|                i += size;
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Reports the zero-based index of the first occurrence in this instance of any runes in the provided string
	|        /// </summary>
	|        /// <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name=""runes"" /> was found; -1 if no character in <paramref name=""runes"" /> was found.</returns>
	|        /// <param name=""runes"">ustring containing runes.</param>
	|        public int IndexOfAny(params uint[] runes)
	|        {
	|            if (runes == null)
	|                throw new ArgumentNullException(nameof(runes));
	|            if (runes.Length == 0)
	|                return -1;
	|            var blen = Length;
	|            if (blen > 8)
	|            {
	|                AsciiSet aset;
	|                if (AsciiSet.MakeAsciiSet(ref aset, runes))
	|                {
	|                    for (int i = 0; i < blen; i++)
	|                        if (AsciiSet.Contains(ref aset, this[i]))
	|                            return i;
	|                    return -1;
	|                }
	|            }
	|            var clen = runes.Length;
	|            for (int i = 0; i < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, i, i - blen);
	|                for (int j = 0; j < clen; j++)
	|                {
	|                    if (rune == runes[j])
	|                        return i;
	|                }
	|                i += size;
	|            }
	|
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in the ustring.
	|        /// </summary>
	|        /// <returns>The index position of the last occurrence in this instance where any character in <paramref name=""chars"" /> was found; -1 if no character in <paramref name=""chars"" /> was found.</returns>
	|        /// <param name=""chars"">The string containing characters to seek.</param>
	|        public int LastIndexOfAny(ustring chars)
	|        {
	|            if ((object)chars == null)
	|                throw new ArgumentNullException(nameof(chars));
	|            if (chars.Length == 0)
	|                return -1;
	|            var blen = Length;
	|            if (blen > 8)
	|            {
	|                AsciiSet aset;
	|                if (AsciiSet.MakeAsciiSet(ref aset, chars))
	|                {
	|                    for (int i = blen - 1; i >= 0; i--)
	|                        if (AsciiSet.Contains(ref aset, this[i]))
	|                            return i;
	|                    return -1;
	|                }
	|            }
	|            var clen = chars.Length;
	|            for (int i = blen; i > 0;)
	|            {
	|                (var rune, var size) = Utf8.DecodeLastRune(this, i);
	|                i -= size;
	|
	|                for (int j = 0; j < clen;)
	|                {
	|                    (var crune, var csize) = Utf8.DecodeRune(chars, j, j - clen);
	|                    if (crune == rune)
	|                        return i;
	|                    j += csize;
	|                }
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Implements the IComparable<paramtype name=""ustring""/>.CompareTo method
	|        /// </summary>
	|        /// <returns>Less than zero if this instance is less than value, zero if they are the same, and higher than zero if the instance is greater.</returns>
	|        /// <param name=""other"">Value.</param>
	|        public int CompareTo(ustring other)
	|        {
	|            if ((object)other == null)
	|                return 1;
	|            var blen = Length;
	|            var olen = other.Length;
	|            if (blen == 0)
	|            {
	|                if (olen == 0)
	|                    return 0;
	|                return -1;
	|            }
	|            else if (olen == 0)
	|                return 1;
	|
	|            // Most common case, first character is different
	|            var e = this[0] - other[0];
	|            if (e != 0)
	|                return e;
	|            for (int i = 1; i < blen; i++)
	|            {
	|                if (i >= olen)
	|                    return 1;
	|                e = this[i] - other[i];
	|                if (e == 0)
	|                    continue;
	|                return e;
	|            }
	|            if (olen > blen)
	|                return -1;
	|            return 0;
	|        }
	|
	|        int IComparable.CompareTo(object value)
	|        {
	|            if (value == null)
	|                return 1;
	|            var other = value as ustring;
	|            if ((object)other == null)
	|                throw new ArgumentException(""Argument must be a ustring"");
	|            return CompareTo(other);
	|        }
	|
	|        // Generic split: splits after each instance of sep,
	|        // including sepSave bytes of sep in the subarrays.
	|        ustring[] GenSplit(ustring sep, int sepSave, int n = -1)
	|        {
	|            if (n == 0)
	|                return Array.Empty<ustring>();
	|            if (sep == """")
	|                return Explode(n);
	|            if (n < 0 || n == Int32.MaxValue)
	|                n = Count(sep) + 1;
	|            var result = new ustring[n];
	|            n--;
	|            int offset = 0, i = 0;
	|            var sepLen = sep.Length;
	|            while (i < n)
	|            {
	|                var m = IndexOf(sep, offset);
	|                if (m < 0)
	|                    break;
	|                result[i] = this[offset, m + sepSave];
	|                offset = m + sepLen;
	|                i++;
	|            }
	|            result[i] = this[offset, null];
	|            return result;
	|        }
	|
	|        /// <summary>
	|        /// Split the string using at every instance of a string separator
	|        /// </summary>
	|        /// <returns>An array containing the individual strings, excluding the separator string.</returns>
	|        /// <param name=""separator"">Separator string.</param>
	|        /// <param name=""n"">Optional maximum number of results to return, or -1 for an unlimited result</param>
	|        public ustring[] Split(ustring separator, int n = -1)
	|        {
	|            if ((object)separator == null)
	|                throw new ArgumentNullException(nameof(separator));
	|
	|            return GenSplit(separator, 0, n);
	|        }
	|
	|        /// <summary>
	|        /// Determines whether the beginning of this string instance matches the specified string.
	|        /// </summary>
	|        /// <returns><c>true</c> if <paramref name=""prefix"" /> matches the beginning of this string; otherwise, <c>false</c>.</returns>
	|        /// <param name=""prefix"">Prefix.</param>
	|        public bool StartsWith(ustring prefix)
	|        {
	|            if ((object)prefix == null)
	|                throw new ArgumentNullException(nameof(prefix));
	|            if (Length < prefix.Length)
	|                return false;
	|            return CompareStringRange(this, 0, prefix.Length, prefix);
	|        }
	|
	|        /// <summary>
	|        /// Determines whether the end of this string instance matches the specified string.
	|        /// </summary>
	|        /// <returns>true if <paramref name=""suffix"" /> matches the end of this instance; otherwise, false.</returns>
	|        /// <param name=""suffix"">The string to compare to the substring at the end of this instance.</param>
	|        public bool EndsWith(ustring suffix)
	|        {
	|            if ((object)suffix == null)
	|                throw new ArgumentNullException(nameof(suffix));
	|            if (Length < suffix.Length)
	|                return false;
	|            return CompareStringRange(this, Length - suffix.Length, suffix.Length, suffix);
	|        }
	|
	|        /// <summary>
	|        /// Concatenates all the elements of a ustring array, using the specified separator between each element.
	|        /// </summary>
	|        /// <returns>A string that consists of the elements in <paramref name=""values"" /> delimited by the <paramref name=""separator"" /> string. If <paramref name=""values"" /> is an empty array, the method returns <see cref=""F:System.ustring.Empty"" />.</returns>
	|        /// <param name=""separator"">Separator.</param>
	|        /// <param name=""values"">Values.</param>
	|        public static ustring Join(ustring separator, params ustring[] values)
	|        {
	|            if ((object)separator == null)
	|                separator = Empty;
	|            if (values == null)
	|                throw new ArgumentNullException(nameof(values));
	|            if (values.Length == 0)
	|                return Empty;
	|            int size = 0, items = 0;
	|            foreach (var t in values)
	|            {
	|                if ((object)t == null)
	|                    continue;
	|                size += t.Length;
	|                items++;
	|            }
	|            if (items == 1)
	|            {
	|                foreach (var t in values)
	|                    if (t != null)
	|                        return t;
	|            }
	|            var slen = separator.Length;
	|            size += (items - 1) * slen;
	|            var result = new byte[size];
	|            int offset = 0;
	|            foreach (var t in values)
	|            {
	|                if ((object)t == null)
	|                    continue;
	|                var tlen = t.Length;
	|                t.CopyTo(fromOffset: 0, target: result, targetOffset: offset, count: tlen);
	|                offset += tlen;
	|                separator.CopyTo(fromOffset: 0, target: result, targetOffset: offset, count: slen);
	|                offset += slen;
	|            }
	|            return new ByteBufferUString(result);
	|        }
	|
	|        // asciiSet is a 32-byte value, where each bit represents the presence of a
	|        // given ASCII character in the set. The 128-bits of the lower 16 bytes,
	|        // starting with the least-significant bit of the lowest word to the
	|        // most-significant bit of the highest word, map to the full range of all
	|        // 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,
	|        // ensuring that any non-ASCII character will be reported as not in the set.
	|        struct AsciiSet
	|        {
	|            unsafe internal fixed uint ascii[8];
	|
	|            public static bool MakeAsciiSet(ref AsciiSet aset, ustring chars)
	|            {
	|                var n = chars.Length;
	|                unsafe
	|                {
	|                    fixed (uint* ascii = aset.ascii)
	|                    {
	|                        for (int i = 0; i < n; i++)
	|                        {
	|                            var c = chars[i];
	|                            if (c >= Utf8.RuneSelf)
	|                                return false;
	|
	|                            var t = (uint)(1 << (c & 31));
	|                            ascii[c >> 5] |= t;
	|                        }
	|                    }
	|                }
	|                return true;
	|            }
	|
	|            public static bool MakeAsciiSet(ref AsciiSet aset, uint[] runes)
	|            {
	|                var n = runes.Length;
	|                unsafe
	|                {
	|                    fixed (uint* ascii = aset.ascii)
	|                    {
	|                        for (int i = 0; i < n; i++)
	|                        {
	|                            var r = runes[i];
	|                            if (r >= Utf8.RuneSelf)
	|                                return false;
	|                            byte c = (byte)r;
	|                            var t = (uint)(1 << (c & 31));
	|                            ascii[c >> 5] |= t;
	|                        }
	|                    }
	|                }
	|                return true;
	|            }
	|            public static bool Contains(ref AsciiSet aset, byte b)
	|            {
	|                unsafe
	|                {
	|                    fixed (uint* ascii = aset.ascii)
	|                    {
	|                        return (ascii[b >> 5] & (1 << (b & 31))) != 0;
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Concatenates the contents of two <see cref=""NStack.ustring""/> instances.
	|        /// </summary>
	|        /// <param name=""u1"">The first <see cref=""NStack.ustring""/> to add, can be null.</param>
	|        /// <param name=""u2"">The second <see cref=""NStack.ustring""/> to add, can be null.</param>
	|        /// <returns>The <see cref=""T:NStack.ustring""/> that is the concatenation of the strings of <c>u1</c> and <c>u2</c>.</returns>
	|        public static ustring operator +(ustring u1, ustring u2)
	|        {
	|            var u1l = (object)u1 == null ? 0 : u1.Length;
	|            var u2l = (object)u2 == null ? 0 : u2.Length;
	|            var copy = new byte[u1l + u2l];
	|            if (u1 != null)
	|                u1.CopyTo(fromOffset: 0, target: copy, targetOffset: 0, count: u1l);
	|            if (u2 != null)
	|                u2.CopyTo(fromOffset: 0, target: copy, targetOffset: u1l, count: u2l);
	|            return new ByteBufferUString(copy);
	|        }
	|
	|        /// <summary>
	|        /// Convert from <see cref=""string""/> to <see cref=""ustring""/>
	|        /// or to null if the <paramref name=""v""/> is null.
	|        /// </summary>
	|        /// <param name=""v"">The ustring.</param>
	|        public static explicit operator string(ustring v)
	|        {
	|            if (v == null)
	|                return null;
	|
	|            return v.ToString();
	|        }
	|
	|        /// <summary>
	|        /// An enumerator that returns the index within the string, and the rune found at that location
	|        /// </summary>
	|        /// <returns>Enumerable object that can be used to iterate and get the index of the values at the same time.</returns>
	|        /// <remarks>
	|        /// This is useful to iterate over the string and obtain both the index of the rune and the rune
	|        /// in the same call.  This version does allocate an object for the enumerator, if you want to avoid
	|        /// the object allocation, you can use the following code to iterate over the contents of the string
	|        /// <example>
	|        /// <code lang=""c#"">
	|        ///   ustring mystr = ""hello"";
	|        ///   int byteLen = mystr.Length;
	|        ///   for (int i = 0; i &lt; byteLen;) {
	|        ///       (var rune, var size) = Utf8.DecodeRune(mystr, i, i - byteLen);
	|        ///       Console.WriteLine (""Rune is: "" + rune);
	|        ///       i += size;
	|        ///   }
	|        /// </code>
	|        /// </example>
	|        /// </remarks>
	|        public IEnumerable<(int index, uint rune)> Range()
	|        {
	|            int blen = Length;
	|            for (int i = 0; i < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, i, i - blen);
	|                yield return (i, rune);
	|                i += size;
	|            }
	|            yield break;
	|        }
	|
	|        /// <summary>
	|        /// Returns the Rune encoded at the specified byte <paramref name=""index""/>.   
	|        /// </summary>
	|        /// <returns>The <see cref=""T:System.Rune""/> which might be Rune.Error if the value at the specified index is not UTF8 compliant, for example because it is not a valid UTF8 encoding, or the buffer is too short.</returns>
	|        /// <param name=""index"">Index.</param>
	|        public Rune RuneAt(int index)
	|        {
	|            return Utf8.DecodeRune(this, index).Rune;
	|        }
	|
	|        // Map returns a copy of the string s with all its characters modified
	|        // according to the mapping function. If mapping returns a negative value, the character is
	|        // dropped from the string with no replacement.
	|        static ustring Map(Func<uint, uint> mapping, ustring s, Action scanReset = null)
	|        {
	|            // In the worst case, the string can grow when mapped, making
	|            // things unpleasant. But it's so rare we barge in assuming it's
	|            // fine. It could also shrink but that falls out naturally.
	|
	|            // nbytes is the number of bytes needed to encode the string
	|            int nbytes = 0;
	|
	|            bool modified = false;
	|            int blen = s.Length;
	|            for (int offset = 0; offset < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(s, offset);
	|                var mapped = mapping(rune);
	|                if (mapped == rune)
	|                {
	|                    nbytes++;
	|                    offset += size;
	|                    continue;
	|                }
	|                modified = true;
	|                var mappedLen = Utf8.RuneLen(mapped);
	|                if (mappedLen == -1)
	|                    mappedLen = 3; // Errors are encoded with 3 bytes
	|                nbytes += mappedLen;
	|
	|                if (rune == Utf8.RuneError)
	|                {
	|                    // RuneError is the result of either decoding
	|                    // an invalid sequence or '\uFFFD'. Determine
	|                    // the correct number of bytes we need to advance.
	|                    (_, size) = Utf8.DecodeRune(s[offset, 0]);
	|
	|                }
	|                offset += size;
	|            }
	|
	|
	|            if (!modified)
	|                return s;
	|
	|            scanReset?.Invoke();
	|
	|            var result = new byte[nbytes];
	|            int targetOffset = 0;
	|            for (int offset = 0; offset < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(s, offset);
	|                offset += size;
	|
	|                var mapped = mapping(rune);
	|
	|                // common case
	|                if (0 < mapped && mapped <= Utf8.RuneSelf)
	|                {
	|                    result[targetOffset] = (byte)mapped;
	|                    targetOffset++;
	|                    continue;
	|                }
	|
	|                targetOffset += Utf8.EncodeRune(mapped, dest: result, offset: targetOffset);
	|            }
	|            return new ByteBufferUString(result);
	|        }
	|
	|        /// <summary>
	|        /// Returns a copy of the string s with all Unicode letters mapped to their upper case.
	|        /// </summary>
	|        /// <returns>The string to uppercase.</returns>
	|        public ustring ToUpper()
	|        {
	|            return Map(Unicode.ToUpper, this);
	|        }
	|
	|        /// <summary>
	|        /// Returns a copy of the string s with all Unicode letters mapped to their upper case giving priority to the special casing rules.
	|        /// </summary>
	|        /// <returns>The string to uppercase.</returns>
	|        public ustring ToUpper(Unicode.SpecialCase specialCase)
	|        {
	|            return Map((rune) => specialCase.ToUpper(rune), this);
	|        }
	|
	|        /// <summary>
	|        /// Returns a copy of the string s with all Unicode letters mapped to their lower case.
	|        /// </summary>
	|        /// <returns>The lowercased string.</returns>
	|        public ustring ToLower()
	|        {
	|            return Map(Unicode.ToLower, this);
	|        }
	|
	|        /// <summary>
	|        /// Returns a copy of the string s with all Unicode letters mapped to their lower case giving priority to the special casing rules.
	|        /// </summary>
	|        /// <returns>The string to uppercase.</returns>
	|        public ustring ToLower(Unicode.SpecialCase specialCase)
	|        {
	|            return Map((rune) => specialCase.ToLower(rune), this);
	|        }
	|        /// <summary>
	|        /// Returns a copy of the string s with all Unicode letters mapped to their title case.
	|        /// </summary>
	|        /// <returns>The title-cased string.</returns>
	|        public ustring ToTitle()
	|        {
	|            return Map(Unicode.ToTitle, this);
	|        }
	|
	|        /// <summary>
	|        /// Returns a copy of the string s with all Unicode letters mapped to their title case giving priority to the special casing rules.
	|        /// </summary>
	|        /// <returns>The string to uppercase.</returns>
	|        public ustring ToTitle(Unicode.SpecialCase specialCase)
	|        {
	|            return Map((rune) => specialCase.ToTitle(rune), this);
	|        }
	|
	|        /// <summary>
	|        /// IsSeparator reports whether the rune could mark a word boundary.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune can be considered a word boundary, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test.</param>
	|        public static bool IsSeparator(uint rune)
	|        {
	|            if (rune <= 0x7f)
	|            {
	|                // ASCII alphanumerics and underscore are not separators
	|                if ('0' <= rune && rune <= '9')
	|                    return false;
	|                if ('a' <= rune && rune <= 'z')
	|                    return false;
	|                if ('A' <= rune && rune <= 'Z')
	|                    return false;
	|                if (rune == '_')
	|                    return false;
	|                return true;
	|            }
	|            // Letters and digits are not separators
	|            if (Unicode.IsLetter(rune) || Unicode.IsDigit(rune))
	|                return false;
	|            // Otherwise, all we can do for now is treat spaces as separators.
	|            return Unicode.IsSpace(rune);
	|        }
	|
	|        /// <summary>
	|        /// Converts the string to Title-case, that is every word (as determined by <see cref=""M:NStack.ustring.IsSeparator""/> is Title cased.
	|        /// </summary>
	|        /// <returns>A title-cased string.</returns>
	|        public ustring Title()
	|        {
	|            uint prev = ' ';
	|            return Map((rune) =>
	|            {
	|                if (IsSeparator(prev))
	|                {
	|                    prev = rune;
	|                    return Unicode.ToTitle(rune);
	|                }
	|                prev = rune;
	|                return rune;
	|            }, this, () => { prev = ' '; });
	|        }
	|
	|        // IndexFunc returns the index into s of the first Unicode
	|        // code point satisfying f(c), or -1 if none do.
	|
	|        /// <summary>
	|        /// Rune predicate functions take a rune as input and return a boolean determining if the rune matches or not.
	|        /// </summary>
	|        public delegate bool RunePredicate(uint rune);
	|
	|        /// <summary>
	|        /// IndexOf returns the index into s of the first Unicode rune satisfying matchFunc(rune), or -1 if none do.
	|        /// </summary>
	|        /// <returns>The index inside the string where the rune is found, or -1 on error.</returns>
	|        /// <param name=""matchFunc"">Match func, it receives a rune as a parameter and should return true if it matches, false otherwise.</param>
	|        public int IndexOf(RunePredicate matchFunc)
	|        {
	|            return FlexIndexOf(matchFunc, true);
	|        }
	|
	|        /// <summary>
	|        /// LastIndexOf returns the index into s of the last Unicode rune satisfying matchFunc(rune), or -1 if none do.
	|        /// </summary>
	|        /// <returns>The last index inside the string where the rune is found, or -1 on error.</returns>
	|        /// <param name=""matchFunc"">Match func, it receives a rune as a parameter and should return true if it matches, false otherwise.</param>
	|        public int LastIndexOf(RunePredicate matchFunc)
	|        {
	|            return FlexLastIndexOf(matchFunc, true);
	|        }
	|
	|
	|        /// <summary>
	|        /// Returns a slice of the string with all leading runes matching the predicate removed.
	|        /// </summary>
	|        /// <returns>The current string if the predicate does not match anything, or a slice of the string starting in the first rune after the predicate matched.</returns>
	|        /// <param name=""predicate"">Function that determines whether this character must be trimmed.</param>
	|        public ustring TrimStart(RunePredicate predicate)
	|        {
	|            var i = FlexIndexOf(predicate, false);
	|            if (i == -1)
	|                return this;
	|            return this[i, null];
	|        }
	|
	|        RunePredicate MakeCutSet(ustring cutset)
	|        {
	|            if (cutset.Length == 1 && cutset[0] < Utf8.RuneSelf)
	|                return (x) => x == (uint)cutset[0];
	|            AsciiSet aset;
	|            if (AsciiSet.MakeAsciiSet(ref aset, cutset))
	|            {
	|                return (x) => x < Utf8.RuneSelf && AsciiSet.Contains(ref aset, (byte)x);
	|            }
	|            return (x) => cutset.IndexOf(x) >= 0;
	|        }
	|
	|        /// <summary>
	|        /// TrimStarts returns a slice of the string with all leading characters in cutset removed.
	|        /// </summary>
	|        /// <returns>The slice of the string with all cutset characters removed.</returns>
	|        /// <param name=""cutset"">Characters to remove.</param>
	|        public ustring TrimStart(ustring cutset)
	|        {
	|            if (IsEmpty || (object)cutset == null || cutset.IsEmpty)
	|                return this;
	|            return TrimStart(MakeCutSet(cutset));
	|        }
	|
	|        /// <summary>
	|        /// TrimEnd returns a slice of the string with all leading characters in cutset removed.
	|        /// </summary>
	|        /// <returns>The slice of the string with all cutset characters removed.</returns>
	|        /// <param name=""cutset"">Characters to remove.</param>
	|        public ustring TrimEnd(ustring cutset)
	|        {
	|            if (IsEmpty || (object)cutset == null || cutset.IsEmpty)
	|                return this;
	|            return TrimEnd(MakeCutSet(cutset));
	|        }
	|
	|        /// <summary>
	|        /// Returns a slice of the string with all leading and trailing space characters removed (as determined by <see cref=""M:NStack.Unicode.IsSpace()""/> 
	|        /// </summary>
	|        /// <returns>The space.</returns>
	|        public ustring TrimSpace()
	|        {
	|            return Trim(Unicode.IsSpace);
	|        }
	|
	|        /// <summary>
	|        /// Returns a slice of the string with all trailing runes matching the predicate removed.
	|        /// </summary>
	|        /// <returns>The current string if the predicate does not match anything, or a slice of the string starting in the first rune after the predicate matched.</returns>
	|        /// <param name=""predicate"">Function that determines whether this character must be trimmed.</param>
	|        public ustring TrimEnd(RunePredicate predicate)
	|        {
	|            var i = FlexLastIndexOf(predicate, false);
	|            if (i >= 0 && this[i] >= Utf8.RuneSelf)
	|            {
	|                (var rune, var wid) = Utf8.DecodeRune(this[i, null]);
	|                i += wid;
	|            }
	|            else
	|                i++;
	|            return this[0, i];
	|        }
	|
	|        /// <summary>
	|        /// Returns a slice of the string with all leading and trailing runes matching the predicate removed.
	|        /// </summary>
	|        /// <returns>The trim.</returns>
	|        /// <param name=""predicate"">Predicate.</param>
	|        public ustring Trim(RunePredicate predicate)
	|        {
	|            return TrimStart(predicate).TrimEnd(predicate);
	|        }
	|
	|        // FlexIndexOf is a generalization of IndexOf that allows
	|        // the desired result of the predicate to be specified.
	|        int FlexIndexOf(RunePredicate matchFunc, bool expected)
	|        {
	|            int blen = Length;
	|            for (int i = 0; i < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, i, i - blen);
	|                if (matchFunc(rune) == expected)
	|                    return i;
	|                i += size;
	|            }
	|            return -1;
	|        }
	|
	|        // FlexLastIndexOf is a generalization of IndexOf that allows
	|        // the desired result of the predicate to be specified.
	|        int FlexLastIndexOf(RunePredicate matchFunc, bool expected)
	|        {
	|            int blen = Length;
	|            for (int i = blen; i > 0;)
	|            {
	|                (var rune, var size) = Utf8.DecodeLastRune(this, i);
	|                i -= size;
	|                if (matchFunc(rune) == expected)
	|                    return i;
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Returns a new ustring with the non-overlapping instances of oldValue replaced with newValue.
	|        /// </summary>
	|        /// <returns>The replace.</returns>
	|        /// <param name=""oldValue"">Old value;  if it is empty, the string matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string.</param>
	|        /// <param name=""newValue"">New value that will replace the oldValue.</param>
	|        /// <param name=""maxReplacements"">Optional, the maximum number of replacements.   Negative values indicate that there should be no limit to the replacements.</param>
	|        public ustring Replace(ustring oldValue, ustring newValue, int maxReplacements = -1)
	|        {
	|            if (oldValue == newValue || maxReplacements == 0)
	|                return this;
	|
	|            // Compute number of replacements
	|            var m = Count(oldValue);
	|            if (m == 0)
	|                return this;
	|            if (maxReplacements < 0 || m < maxReplacements)
	|                maxReplacements = m;
	|
	|            var oldLen = oldValue.Length;
	|            var newLen = newValue.Length;
	|
	|            // Apply replacements to buffer
	|            var result = new byte[Length + maxReplacements * (newValue.Length - oldValue.Length)];
	|            int w = 0, start = 0;
	|            for (int i = 0; i < maxReplacements; i++)
	|            {
	|                var j = start;
	|                if (oldLen == 0)
	|                {
	|                    if (i > 0)
	|                    {
	|                        (_, var wid) = Utf8.DecodeRune(this, start);
	|                        j += wid;
	|                    }
	|                }
	|                else
	|                    j += IndexOf(oldValue, start) - start;
	|                var copyCount = j - start;
	|                if (copyCount > 0)
	|                {
	|                    CopyTo(fromOffset: start, target: result, targetOffset: w, count: copyCount);
	|                    w += copyCount;
	|                }
	|
	|                newValue.CopyTo(fromOffset: 0, target: result, targetOffset: w, count: newLen);
	|                w += newLen;
	|                start = j + oldLen;
	|            }
	|            CopyTo(fromOffset: start, target: result, targetOffset: w, count: Length - start);
	|            return new ByteBufferUString(result);
	|        }
	|
	|        /// <summary>
	|        /// Represent the null or empty value related to the ustring.
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        /// <returns></returns>
	|        public static bool IsNullOrEmpty(ustring value)
	|        {
	|            if (value?.IsEmpty != false)
	|                return true;
	|            return false;
	|        }
	|
	|        TypeCode IConvertible.GetTypeCode()
	|        {
	|            return TypeCode.Object;
	|        }
	|
	|        bool IConvertible.ToBoolean(IFormatProvider provider)
	|        {
	|            return Convert.ToBoolean(ToString(), provider);
	|        }
	|
	|        byte IConvertible.ToByte(IFormatProvider provider)
	|        {
	|            return Convert.ToByte(ToString(), provider);
	|        }
	|
	|        char IConvertible.ToChar(IFormatProvider provider)
	|        {
	|            return Convert.ToChar(ToString(), provider);
	|        }
	|
	|        DateTime IConvertible.ToDateTime(IFormatProvider provider)
	|        {
	|            return Convert.ToDateTime(ToString(), provider);
	|        }
	|
	|        decimal IConvertible.ToDecimal(IFormatProvider provider)
	|        {
	|            return Convert.ToDecimal(ToString(), provider);
	|        }
	|
	|        double IConvertible.ToDouble(IFormatProvider provider)
	|        {
	|            return Convert.ToDouble(ToString(), provider);
	|        }
	|
	|        short IConvertible.ToInt16(IFormatProvider provider)
	|        {
	|            return Convert.ToInt16(ToString(), provider);
	|        }
	|
	|        int IConvertible.ToInt32(IFormatProvider provider)
	|        {
	|            return Convert.ToInt32(ToString(), provider);
	|        }
	|
	|        long IConvertible.ToInt64(IFormatProvider provider)
	|        {
	|            return Convert.ToInt64(ToString(), provider);
	|        }
	|
	|        sbyte IConvertible.ToSByte(IFormatProvider provider)
	|        {
	|            return Convert.ToSByte(ToString(), provider);
	|        }
	|
	|        float IConvertible.ToSingle(IFormatProvider provider)
	|        {
	|            return Convert.ToSingle(ToString(), provider);
	|        }
	|
	|        string IConvertible.ToString(IFormatProvider provider)
	|        {
	|            return ToString();
	|        }
	|
	|        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
	|        {
	|            if (conversionType == typeof(string))
	|                return ToString();
	|            return Convert.ChangeType(ToString(), conversionType);
	|        }
	|
	|        ushort IConvertible.ToUInt16(IFormatProvider provider)
	|        {
	|            return Convert.ToUInt16(ToString(), provider);
	|        }
	|
	|        uint IConvertible.ToUInt32(IFormatProvider provider)
	|        {
	|            return Convert.ToUInt32(ToString(), provider);
	|        }
	|
	|        ulong IConvertible.ToUInt64(IFormatProvider provider)
	|        {
	|            return Convert.ToUInt64(ToString(), provider);
	|        }
	|
	|        IEnumerator<uint> IEnumerable<uint>.GetEnumerator()
	|        {
	|            int blen = Length;
	|            for (int i = 0; i < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, i, i - blen);
	|                i += size;
	|                yield return rune;
	|            }
	|        }
	|
	|        IEnumerator IEnumerable.GetEnumerator()
	|        {
	|            int blen = Length;
	|            for (int i = 0; i < blen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(this, i, i - blen);
	|                i += size;
	|                yield return rune;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// UTF8 Helper methods and routines.
	|    /// </summary>
	|    /// <remarks>
	|    /// The term ""rune"" is used to represent a Unicode code point merely because it is a shorter way of talking about it.
	|    /// </remarks>
	|    public static class Utf8
	|    {
	|        /// <summary>
	|        /// The ""error"" Rune or ""Unicode replacement character""
	|        /// </summary>
	|        public static uint RuneError = 0xfffd;
	|
	|        /// <summary>
	|        /// Characters below RuneSelf are represented as themselves in a single byte
	|        /// </summary>
	|        public const byte RuneSelf = 0x80;
	|
	|        /// <summary>
	|        /// Maximum number of bytes required to encode every unicode code point.
	|        /// </summary>
	|        public const int Utf8Max = 4;
	|
	|        /// <summary>
	|        /// Maximum valid Unicode code point.
	|        /// </summary>
	|        public const uint MaxRune = 0x10ffff;
	|
	|        // Code points in the surrogate range are not valid for UTF-8.
	|        const uint surrogateMin = 0xd800;
	|        const uint surrogateMax = 0xdfff;
	|
	|        const byte t1 = 0x00; // 0000 0000
	|        const byte tx = 0x80; // 1000 0000
	|        const byte t2 = 0xC0; // 1100 0000
	|        const byte t3 = 0xE0; // 1110 0000
	|        const byte t4 = 0xF0; // 1111 0000
	|        const byte t5 = 0xF8; // 1111 1000
	|
	|        const byte maskx = 0x3F; // 0011 1111
	|        const byte mask2 = 0x1F; // 0001 1111
	|        const byte mask3 = 0x0F; // 0000 1111
	|        const byte mask4 = 0x07; // 0000 0111
	|
	|        const uint rune1Max = (1 << 7) - 1;
	|        const uint rune2Max = (1 << 11) - 1;
	|        const uint rune3Max = (1 << 16) - 1;
	|
	|        // The default lowest and highest continuation byte.
	|        const byte locb = 0x80; // 1000 0000
	|        const byte hicb = 0xBF; // 1011 1111
	|
	|        // These names of these constants are chosen to give nice alignment in the
	|        // table below. The first nibble is an index into acceptRanges or F for
	|        // special one-byte ca1es. The second nibble is the Rune length or the
	|        // Status for the special one-byte ca1e.
	|        const byte xx = 0xF1; // invalid: size 1
	|        const byte a1 = 0xF0; // a1CII: size 1
	|        const byte s1 = 0x02; // accept 0, size 2
	|        const byte s2 = 0x13; // accept 1, size 3
	|        const byte s3 = 0x03; // accept 0, size 3
	|        const byte s4 = 0x23; // accept 2, size 3
	|        const byte s5 = 0x34; // accept 3, size 4
	|        const byte s6 = 0x04; // accept 0, size 4
	|        const byte s7 = 0x44; // accept 4, size 4
	|
	|        static byte[] first = new byte[256]{
	|			//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x00-0x0F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1,a1, a1, a1, a1, a1, // 0x10-0x1F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x20-0x2F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x30-0x3F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x40-0x4F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x50-0x5F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x60-0x6F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x70-0x7F
	|
	|			//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
	|			xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
	|			s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
	|			s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
	|			s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
	|		};
	|
	|        struct AcceptRange
	|        {
	|            public byte Lo, Hi;
	|            public AcceptRange(byte lo, byte hi)
	|            {
	|                Lo = lo;
	|                Hi = hi;
	|            }
	|        }
	|
	|        static AcceptRange[] AcceptRanges = new AcceptRange[] {
	|            new AcceptRange (locb, hicb),
	|            new AcceptRange (0xa0, hicb),
	|            new AcceptRange (locb, 0x9f),
	|            new AcceptRange (0x90, hicb),
	|            new AcceptRange (locb, 0x8f),
	|        };
	|
	|        /// <summary>
	|        /// FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
	|        /// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the bytes in p begin with a full UTF-8 encoding of a rune, <c>false</c> otherwise.</returns>
	|        /// <param name=""p"">byte array.</param>
	|        public static bool FullRune(byte[] p)
	|        {
	|            if (p == null)
	|                throw new ArgumentNullException(nameof(p));
	|            var n = p.Length;
	|
	|            if (n == 0)
	|                return false;
	|            var x = first[p[0]];
	|            if (n >= (x & 7))
	|            {
	|                // ascii, invalid or valid
	|                return true;
	|            }
	|            // must be short or invalid
	|            if (n > 1)
	|            {
	|                var accept = AcceptRanges[x >> 4];
	|                var c = p[1];
	|                if (c < accept.Lo || accept.Hi < c)
	|                    return true;
	|                else if (n > 2 && (p[2] < locb || hicb < p[2]))
	|                    return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// FullRune reports whether the ustring begins with a full UTF-8 encoding of a rune.
	|        /// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the bytes in p begin with a full UTF-8 encoding of a rune, <c>false</c> otherwise.</returns>
	|        /// <param name=""str"">The string to check.</param>
	|        public static bool FullRune(ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|            var n = str.Length;
	|
	|            if (n == 0)
	|                return false;
	|            var x = first[str[0]];
	|            if (n >= (x & 7))
	|            {
	|                // ascii, invalid or valid
	|                return true;
	|            }
	|            // must be short or invalid
	|            if (n > 1)
	|            {
	|                var accept = AcceptRanges[x >> 4];
	|                var c = str[1];
	|                if (c < accept.Lo || accept.Hi < c)
	|                    return true;
	|                else if (n > 2 && (str[2] < locb || hicb < str[2]))
	|                    return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and
	|        /// its width in bytes. 
	|        /// </summary>
	|        /// <returns>If p is empty it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.
	|        /// </returns>
	|        /// <param name=""buffer"">Byte buffer containing the utf8 string.</param>
	|        /// <param name=""start"">Starting offset to look into..</param>
	|        /// <param name=""n"">Number of bytes valid in the buffer, or -1 to make it the lenght of the buffer.</param>
	|        public static (uint Rune, int Size) DecodeRune(byte[] buffer, int start = 0, int n = -1)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            if (start < 0)
	|                throw new ArgumentException(""invalid offset"", nameof(start));
	|            if (n < 0)
	|                n = buffer.Length - start;
	|            if (start > buffer.Length - n)
	|                throw new ArgumentException(""Out of bounds"");
	|
	|            if (n < 1)
	|                return (RuneError, 0);
	|
	|            var p0 = buffer[start];
	|            var x = first[p0];
	|            if (x >= a1)
	|            {
	|                // The following code simulates an additional check for x == xx and
	|                // handling the ASCII and invalid cases accordingly. This mask-and-or
	|                // approach prevents an additional branch.
	|                uint mask = (uint)((((byte)x) << 31) >> 31); // Create 0x0000 or 0xFFFF.
	|                return (((buffer[start]) & ~mask | RuneError & mask), 1);
	|            }
	|
	|            var sz = x & 7;
	|            var accept = AcceptRanges[x >> 4];
	|            if (n < (int)sz)
	|                return (RuneError, 1);
	|
	|            var b1 = buffer[start + 1];
	|            if (b1 < accept.Lo || accept.Hi < b1)
	|                return (RuneError, 1);
	|
	|            if (sz == 2)
	|                return ((uint)((p0 & mask2)) << 6 | (uint)((b1 & maskx)), 2);
	|
	|            var b2 = buffer[start + 2];
	|            if (b2 < locb || hicb < b2)
	|                return (RuneError, 1);
	|
	|            if (sz == 3)
	|                return (((uint)((p0 & mask3)) << 12 | (uint)((b1 & maskx)) << 6 | (uint)((b2 & maskx))), 3);
	|
	|            var b3 = buffer[start + 3];
	|            if (b3 < locb || hicb < b3)
	|            {
	|                return (RuneError, 1);
	|            }
	|            return ((uint)(p0 & mask4) << 18 | (uint)(b1 & maskx) << 12 | (uint)(b2 & maskx) << 6 | (uint)(b3 & maskx), 4);
	|        }
	|
	|        /// <summary>
	|        /// DecodeRune unpacks the first UTF-8 encoding in the ustring returns the rune and
	|        /// its width in bytes. 
	|        /// </summary>
	|        /// <returns>If p is empty it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.
	|        /// </returns>
	|        /// <param name=""str"">ustring to decode.</param>
	|        /// <param name=""start"">Starting offset to look into..</param>
	|        /// <param name=""n"">Number of bytes valid in the buffer, or -1 to make it the lenght of the buffer.</param>
	|        public static (uint Rune, int size) DecodeRune(ustring str, int start = 0, int n = -1)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|            if (start < 0)
	|                throw new ArgumentException(""invalid offset"", nameof(start));
	|            if (n < 0)
	|                n = str.Length - start;
	|            if (start > str.Length - n)
	|                throw new ArgumentException(""Out of bounds"");
	|
	|            if (n < 1)
	|                return (RuneError, 0);
	|
	|            var p0 = str[start];
	|            var x = first[p0];
	|            if (x >= a1)
	|            {
	|                // The following code simulates an additional check for x == xx and
	|                // handling the ASCII and invalid cases accordingly. This mask-and-or
	|                // approach prevents an additional branch.
	|                uint mask = (uint)((((byte)x) << 31) >> 31); // Create 0x0000 or 0xFFFF.
	|                return (((str[start]) & ~mask | RuneError & mask), 1);
	|            }
	|
	|            var sz = x & 7;
	|            var accept = AcceptRanges[x >> 4];
	|            if (n < (int)sz)
	|                return (RuneError, 1);
	|
	|            var b1 = str[start + 1];
	|            if (b1 < accept.Lo || accept.Hi < b1)
	|                return (RuneError, 1);
	|
	|            if (sz == 2)
	|                return ((uint)((p0 & mask2)) << 6 | (uint)((b1 & maskx)), 2);
	|
	|            var b2 = str[start + 2];
	|            if (b2 < locb || hicb < b2)
	|                return (RuneError, 1);
	|
	|            if (sz == 3)
	|                return (((uint)((p0 & mask3)) << 12 | (uint)((b1 & maskx)) << 6 | (uint)((b2 & maskx))), 3);
	|
	|            var b3 = str[start + 3];
	|            if (b3 < locb || hicb < b3)
	|            {
	|                return (RuneError, 1);
	|            }
	|            return ((uint)(p0 & mask4) << 18 | (uint)(b1 & maskx) << 12 | (uint)(b2 & maskx) << 6 | (uint)(b3 & maskx), 4);
	|        }
	|
	|        // RuneStart reports whether the byte could be the first byte of an encoded,
	|        // possibly invalid rune. Second and subsequent bytes always have the top two
	|        // bits set to 10.
	|        static bool RuneStart(byte b) => (b & 0xc0) != 0x80;
	|
	|        /// <summary>
	|        /// DecodeLastRune unpacks the last UTF-8 encoding in buffer
	|        /// </summary>
	|        /// <returns>The last rune and its width in bytes.</returns>
	|        /// <param name=""buffer"">Buffer to decode rune from;   if it is empty,
	|        /// it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.</param>
	|        /// <param name=""end"">Scan up to that point, if the value is -1, it sets the value to the lenght of the buffer.</param>
	|        /// <remarks>
	|        /// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
	|        /// out of range, or is not the shortest possible UTF-8 encoding for the
	|        /// value. No other validation is performed.</remarks> 
	|        public static (uint Rune, int size) DecodeLastRune(byte[] buffer, int end = -1)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            if (buffer.Length == 0)
	|                return (RuneError, 0);
	|            if (end == -1)
	|                end = buffer.Length;
	|            else if (end > buffer.Length)
	|                throw new ArgumentException(""The end goes beyond the size of the buffer"");
	|
	|            var start = end - 1;
	|            uint r = buffer[start];
	|            if (r < RuneSelf)
	|                return (r, 1);
	|            // guard against O(n^2) behavior when traversing
	|            // backwards through strings with long sequences of
	|            // invalid UTF-8.
	|            var lim = end - Utf8Max;
	|
	|            if (lim < 0)
	|                lim = 0;
	|
	|            for (start--; start >= lim; start--)
	|            {
	|                if (RuneStart(buffer[start]))
	|                {
	|                    break;
	|                }
	|            }
	|            if (start < 0)
	|                start = 0;
	|            int size;
	|            (r, size) = DecodeRune(buffer, start, end - start);
	|            if (start + size != end)
	|                return (RuneError, 1);
	|            return (r, size);
	|        }
	|
	|        /// <summary>
	|        /// DecodeLastRune unpacks the last UTF-8 encoding in the ustring.
	|        /// </summary>
	|        /// <returns>The last rune and its width in bytes.</returns>
	|        /// <param name=""str"">String to decode rune from;   if it is empty,
	|        /// it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.</param>
	|        /// <param name=""end"">Scan up to that point, if the value is -1, it sets the value to the lenght of the buffer.</param>
	|        /// <remarks>
	|        /// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
	|        /// out of range, or is not the shortest possible UTF-8 encoding for the
	|        /// value. No other validation is performed.</remarks> 
	|        public static (uint Rune, int size) DecodeLastRune(ustring str, int end = -1)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|            if (str.Length == 0)
	|                return (RuneError, 0);
	|            if (end == -1)
	|                end = str.Length;
	|            else if (end > str.Length)
	|                throw new ArgumentException(""The end goes beyond the size of the buffer"");
	|
	|            var start = end - 1;
	|            uint r = str[start];
	|            if (r < RuneSelf)
	|                return (r, 1);
	|            // guard against O(n^2) behavior when traversing
	|            // backwards through strings with long sequences of
	|            // invalid UTF-8.
	|            var lim = end - Utf8Max;
	|
	|            if (lim < 0)
	|                lim = 0;
	|
	|            for (start--; start >= lim; start--)
	|            {
	|                if (RuneStart(str[start]))
	|                {
	|                    break;
	|                }
	|            }
	|            if (start < 0)
	|                start = 0;
	|            int size;
	|            (r, size) = DecodeRune(str, start, end - start);
	|            if (start + size != end)
	|                return (RuneError, 1);
	|            return (r, size);
	|        }
	|
	|        /// <summary>
	|        /// number of bytes required to encode the rune.
	|        /// </summary>
	|        /// <returns>The length, or -1 if the rune is not a valid value to encode in UTF-8.</returns>
	|        /// <param name=""rune"">Rune to probe.</param>
	|        public static int RuneLen(uint rune)
	|        {
	|            if (rune <= rune1Max)
	|                return 1;
	|            if (rune <= rune2Max)
	|                return 2;
	|            if (rune > MaxRune || (surrogateMin <= rune && rune <= surrogateMax))
	|                // error
	|                return -1;
	|            if (rune <= rune3Max)
	|                return 3;
	|            if (rune <= MaxRune)
	|                return 4;
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Writes into the destination buffer starting at offset the UTF8 encoded version of the rune
	|        /// </summary>
	|        /// <returns>The number of bytes written into the destination buffer.</returns>
	|        /// <param name=""rune"">Rune to encode.</param>
	|        /// <param name=""dest"">Destination buffer.</param>
	|        /// <param name=""offset"">Offset into the destination buffer.</param>
	|        public static int EncodeRune(uint rune, byte[] dest, int offset = 0)
	|        {
	|            if (dest == null)
	|                throw new ArgumentNullException(nameof(dest));
	|            if (rune <= rune1Max)
	|            {
	|                dest[offset] = (byte)rune;
	|                return 1;
	|            }
	|            if (rune <= rune2Max)
	|            {
	|                dest[offset++] = (byte)(t2 | (byte)(rune >> 6));
	|                dest[offset] = (byte)(tx | (byte)(rune & maskx));
	|                return 2;
	|            }
	|            if ((rune > MaxRune) || (surrogateMin <= rune && rune <= surrogateMax))
	|            {
	|                // error
	|                dest[offset++] = 0xef;
	|                dest[offset++] = 0x3f;
	|                dest[offset] = 0x3d;
	|                return 3;
	|            }
	|            if (rune <= rune3Max)
	|            {
	|                dest[offset++] = (byte)(t3 | (byte)(rune >> 12));
	|                dest[offset++] = (byte)(tx | (byte)(rune >> 6) & maskx);
	|                dest[offset] = (byte)(tx | (byte)(rune) & maskx);
	|                return 3;
	|            }
	|            dest[offset++] = (byte)(t4 | (byte)(rune >> 18));
	|            dest[offset++] = (byte)(tx | (byte)(rune >> 12) & maskx);
	|            dest[offset++] = (byte)(tx | (byte)(rune >> 6) & maskx);
	|            dest[offset++] = (byte)(tx | (byte)(rune) & maskx);
	|            return 4;
	|        }
	|
	|        /// <summary>
	|        /// Returns the number of runes in a utf8 encoded buffer
	|        /// </summary>
	|        /// <returns>Numnber of runes.</returns>
	|        /// <param name=""buffer"">Byte buffer containing a utf8 string.</param>
	|        /// <param name=""offset"">Starting offset in the buffer.</param>
	|        /// <param name=""count"">Number of bytes to process in buffer, or -1 to process until the end of the buffer.</param>
	|        public static int RuneCount(byte[] buffer, int offset = 0, int count = -1)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            if (count == -1)
	|                count = buffer.Length;
	|            int n = 0;
	|            for (int i = offset; i < count;)
	|            {
	|                n++;
	|                var c = buffer[i];
	|
	|                if (c < RuneSelf)
	|                {
	|                    // ASCII fast path
	|                    i++;
	|                    continue;
	|                }
	|                var x = first[c];
	|                if (x == xx)
	|                {
	|                    i++; // invalid.
	|                    continue;
	|                }
	|
	|                var size = (int)(x & 7);
	|
	|                if (i + size > count)
	|                {
	|                    i++; // Short or invalid.
	|                    continue;
	|                }
	|                var accept = AcceptRanges[x >> 4];
	|                c = buffer[i + 1];
	|                if (c < accept.Lo || accept.Hi < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                if (size == 2)
	|                {
	|                    i += 2;
	|                    continue;
	|                }
	|                c = buffer[i + 2];
	|                if (c < locb || hicb < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                if (size == 3)
	|                {
	|                    i += 3;
	|                    continue;
	|                }
	|                c = buffer[i + 3];
	|                if (c < locb || hicb < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                i += size;
	|
	|            }
	|            return n;
	|        }
	|
	|        /// <summary>
	|        /// Returns the number of runes in a ustring.
	|        /// </summary>
	|        /// <returns>Numnber of runes.</returns>
	|        /// <param name=""str"">utf8 string.</param>
	|        public static int RuneCount(ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|            var count = str.Length;
	|            int n = 0;
	|            for (int i = 0; i < count;)
	|            {
	|                n++;
	|                var c = str[i];
	|
	|                if (c < RuneSelf)
	|                {
	|                    // ASCII fast path
	|                    i++;
	|                    continue;
	|                }
	|                var x = first[c];
	|                if (x == xx)
	|                {
	|                    i++; // invalid.
	|                    continue;
	|                }
	|
	|                var size = (int)(x & 7);
	|
	|                //if (i <= str.Length - size )
	|                //{
	|                //	(Rune rune, _) = Utf8.DecodeRune(str, i, size);
	|                //	if (rune.IsSurrogatePair)
	|                //	{
	|                //		i += size;
	|                //		continue;
	|                //	}
	|                //}
	|
	|                if (i + size > count)
	|                {
	|                    i++; // Short or invalid.
	|                    continue;
	|                }
	|                var accept = AcceptRanges[x >> 4];
	|                c = str[i + 1];
	|                if (c < accept.Lo || accept.Hi < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                if (size == 2)
	|                {
	|                    i += 2;
	|                    continue;
	|                }
	|                c = str[i + 2];
	|                if (c < locb || hicb < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                if (size == 3)
	|                {
	|                    i += 3;
	|                    continue;
	|                }
	|                c = str[i + 3];
	|                if (c < locb || hicb < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                i += size;
	|            }
	|            return n;
	|        }
	|
	|        /// <summary>
	|        /// Reports whether p consists entirely of valid UTF-8-encoded runes.
	|        /// </summary>
	|        /// <param name=""buffer"">Byte buffer containing a utf8 string.</param>
	|        public static bool Valid(byte[] buffer)
	|        {
	|            return InvalidIndex(buffer) == -1;
	|        }
	|
	|        /// <summary>
	|        /// Reports whether the ustring consists entirely of valid UTF-8-encoded runes.
	|        /// </summary>
	|        /// <param name=""str"">String to validate.</param>
	|        public static bool Valid(ustring str)
	|        {
	|            return InvalidIndex(str) == -1;
	|        }
	|
	|        /// <summary>
	|        /// Use to find the index of the first invalid utf8 byte sequence in a buffer
	|        /// </summary>
	|        /// <returns>The index of the first insvalid byte sequence or -1 if the entire buffer is valid.</returns>
	|        /// <param name=""buffer"">Buffer containing the utf8 buffer.</param>
	|        public static int InvalidIndex(byte[] buffer)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            var n = buffer.Length;
	|
	|            for (int i = 0; i < n;)
	|            {
	|                var pi = buffer[i];
	|
	|                if (pi < RuneSelf)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                var x = first[pi];
	|                if (x == xx)
	|                    return i; // Illegal starter byte.
	|                var size = (int)(x & 7);
	|                if (i + size > n)
	|                    return i; // Short or invalid.
	|                var accept = AcceptRanges[x >> 4];
	|
	|                var c = buffer[i + 1];
	|
	|                if (c < accept.Lo || accept.Hi < c)
	|                    return i;
	|
	|                if (size == 2)
	|                {
	|                    i += 2;
	|                    continue;
	|                }
	|                c = buffer[i + 2];
	|                if (c < locb || hicb < c)
	|                    return i;
	|                if (size == 3)
	|                {
	|                    i += 3;
	|                    continue;
	|                }
	|                c = buffer[i + 3];
	|                if (c < locb || hicb < c)
	|                    return i;
	|                i += size;
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Use to find the index of the first invalid utf8 byte sequence in a buffer
	|        /// </summary>
	|        /// <returns>The index of the first insvalid byte sequence or -1 if the entire buffer is valid.</returns>
	|        /// <param name=""str"">String containing the utf8 buffer.</param>
	|        public static int InvalidIndex(ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|            var n = str.Length;
	|
	|            for (int i = 0; i < n;)
	|            {
	|                var pi = str[i];
	|
	|                if (pi < RuneSelf)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                var x = first[pi];
	|                if (x == xx)
	|                    return i; // Illegal starter byte.
	|                var size = (int)(x & 7);
	|                if (i + size > n)
	|                    return i; // Short or invalid.
	|                var accept = AcceptRanges[x >> 4];
	|
	|                var c = str[i + 1];
	|
	|                if (c < accept.Lo || accept.Hi < c)
	|                    return i;
	|
	|                if (size == 2)
	|                {
	|                    i += 2;
	|                    continue;
	|                }
	|                c = str[i + 2];
	|                if (c < locb || hicb < c)
	|                    return i;
	|                if (size == 3)
	|                {
	|                    i += 3;
	|                    continue;
	|                }
	|                c = str[i + 3];
	|                if (c < locb || hicb < c)
	|                    return i;
	|                i += size;
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        ///  ValidRune reports whether a rune can be legally encoded as UTF-8.
	|        /// </summary>
	|        /// <returns><c>true</c>, if rune is valid, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test.</param>
	|        public static bool ValidRune(uint rune)
	|        {
	|            if (rune < surrogateMin)
	|                return true;
	|            if (surrogateMax < rune && rune <= MaxRune)
	|                return true;
	|            return false;
	|        }
	|    }
	|}
	|//=======================================================================
	|// Contains a port of this code:
	|// https://www.cl.cam.ac.uk/%7Emgk25/ucs/wcwidth.c
	|
	|namespace System
	|{
	|    public partial struct Rune
	|    {
	|        static uint[,] combining = new uint[,] {
	|            { 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
	|            { 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
	|            { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
	|            { 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
	|            { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
	|            { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
	|            { 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
	|            { 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
	|            { 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
	|            { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
	|            { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
	|            { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
	|            { 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
	|            { 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
	|            { 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
	|            { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
	|            { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
	|            { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
	|            { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
	|            { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
	|            { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
	|            { 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
	|            { 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
	|            { 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
	|            { 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
	|            { 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
	|            { 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
	|            { 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
	|            { 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
	|            { 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
	|            { 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
	|            { 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
	|            { 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
	|            { 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
	|            { 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
	|            { 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
	|            { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
	|            { 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
	|            { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
	|            { 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x2E9A, 0x2E9A },
	|            { 0x2EF4, 0x2EFF }, { 0x2FD6, 0x2FEF }, { 0x2FFC, 0x2FFF },
	|            { 0x31E4, 0x31EF }, { 0x321F, 0x321F }, { 0xA48D, 0xA48F },
	|            { 0xA806, 0xA806 }, { 0xA80B, 0xA80B }, { 0xA825, 0xA826 },
	|            { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F }, { 0xFE1A, 0xFE1F },
	|            { 0xFE20, 0xFE23 }, { 0xFE53, 0xFE53 }, { 0xFE67, 0xFE67 },
	|            { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB },
	|        };
	|
	|        static uint[,] combiningWideChars = new uint[,] {
	|			/* Hangul Jamo init. consonants - 0x1100, 0x11ff */
	|			/* Miscellaneous Technical - 0x2300, 0x23ff */
	|			/* Hangul Syllables - 0x11a8, 0x11c2 */
	|			/* CJK Compatibility Ideographs - f900, fad9 */
	|			/* Vertical forms - fe10, fe19 */
	|			/* CJK Compatibility Forms - fe30, fe4f */
	|			/* Fullwidth Forms - ff01, ffee */
	|			/* Alphabetic Presentation Forms - 0xFB00, 0xFb4f */
	|			/* Chess Symbols - 0x1FA00, 0x1FA0f */
	|
	|			{ 0x1100, 0x115f }, { 0x231a, 0x231b }, { 0x2329, 0x232a },
	|            { 0x23e9, 0x23ec }, { 0x23f0, 0x23f0 }, { 0x23f3, 0x23f3 },
	|            { 0x25fd, 0x25fe }, { 0x2614, 0x2615 }, { 0x2648, 0x2653 },
	|            { 0x267f, 0x267f }, { 0x2693, 0x2693 }, { 0x26a1, 0x26a1 },
	|            { 0x26aa, 0x26ab }, { 0x26bd, 0x26be }, { 0x26c4, 0x26c5 },
	|            { 0x26ce, 0x26ce }, { 0x26d4, 0x26d4 }, { 0x26ea, 0x26ea },
	|            { 0x26f2, 0x26f3 }, { 0x26f5, 0x26f5 }, { 0x26fa, 0x26fa },
	|            { 0x26fd, 0x26fd }, { 0x2705, 0x2705 }, { 0x270a, 0x270b },
	|            { 0x2728, 0x2728 }, { 0x274c, 0x274c }, { 0x274e, 0x274e },
	|            { 0x2753, 0x2755 }, { 0x2757, 0x2757 }, { 0x2795, 0x2797 },
	|            { 0x27b0, 0x27b0 }, { 0x27bf, 0x27bf }, { 0x2b1b, 0x2b1c },
	|            { 0x2b50, 0x2b50 }, { 0x2b55, 0x2b55 }, { 0x2e80, 0x303e },
	|            { 0x3041, 0x3096 }, { 0x3099, 0x30ff }, { 0x3105, 0x312f },
	|            { 0x3131, 0x318e }, { 0x3190, 0x3247 }, { 0x3250, 0x4dbf },
	|            { 0x4e00, 0xa4c6 }, { 0xa960, 0xa97c }, { 0xac00 ,0xd7a3 },
	|            { 0xf900, 0xfaff }, { 0xfe10, 0xfe1f }, { 0xfe30 ,0xfe6b },
	|            { 0xff01, 0xff60 }, { 0xffe0, 0xffe6 }, { 0x10000, 0x10ffff }
	|        };
	|
	|        static int bisearch(uint rune, uint[,] table, int max)
	|        {
	|            int min = 0;
	|            int mid;
	|
	|            if (rune < table[0, 0] || rune > table[max, 1])
	|                return 0;
	|            while (max >= min)
	|            {
	|                mid = (min + max) / 2;
	|                if (rune > table[mid, 1])
	|                    min = mid + 1;
	|                else if (rune < table[mid, 0])
	|                    max = mid - 1;
	|                else
	|                    return 1;
	|            }
	|
	|            return 0;
	|        }
	|
	|        //static bool bisearch(uint rune, uint[,] table, out int width)
	|        //{
	|        //	width = 0;
	|        //	var length = table.GetLength(0);
	|        //	if (length == 0 || rune < table[0, 0] || rune > table[length - 1, 1])
	|        //		return false;
	|
	|        //	for (int i = 0; i < length; i++)
	|        //	{
	|        //		if (rune >= table[i, 0] && rune <= table[i, 1])
	|        //		{
	|        //			width = (int)table[i, 2];
	|        //			return true;
	|        //		}
	|        //	}
	|
	|        //	return false;
	|        //}
	|
	|        /// <summary>
	|        /// Check if the rune is a non-spacing character.
	|        /// </summary>
	|        /// <param name=""rune"">The rune.</param>
	|        /// <returns>True if is a non-spacing character, false otherwise.</returns>
	|        public static bool IsNonSpacingChar(uint rune)
	|        {
	|            return bisearch(rune, combining, combining.GetLength(0) - 1) != 0;
	|        }
	|
	|        /// <summary>
	|        /// Check if the rune is a wide character.
	|        /// </summary>
	|        /// <param name=""rune"">The rune.</param>
	|        /// <returns>True if is a wide character, false otherwise.</returns>
	|        public static bool IsWideChar(uint rune)
	|        {
	|            return bisearch(rune, combiningWideChars, combiningWideChars.GetLength(0) - 1) != 0;
	|        }
	|
	|        /// <summary>
	|        /// Number of column positions of a wide-character code.   This is used to measure runes as displayed by text-based terminals.
	|        /// </summary>
	|        /// <returns>The width in columns, 0 if the argument is the null character, -1 if the value is not printable, otherwise the number of columns that the rune occupies.</returns>
	|        /// <param name=""rune"">The rune.</param>
	|        public static int ColumnWidth(Rune rune)
	|        {
	|            uint irune = (uint)rune;
	|            if (irune < 0x20 || (irune >= 0x7f && irune < 0xa0))
	|                return -1;
	|            if (irune < 0x7f)
	|                return 1;
	|            /* binary search in table of non-spacing characters */
	|            if (bisearch(irune, combining, combining.GetLength(0) - 1) != 0)
	|                return 0;
	|            /* if we arrive here, ucs is not a combining or C0/C1 control character */
	|            return 1 +
	|                (bisearch(irune, combiningWideChars, combiningWideChars.GetLength(0) - 1) != 0 ? 1 : 0);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// A Rune represents a Unicode CodePoint storing the contents in a 32-bit value
	|    /// </summary>
	|    /// <remarks>
	|    /// 
	|    /// </remarks>
	|    [StructLayout(LayoutKind.Sequential)]
	|    public partial struct Rune
	|    {
	|        // Stores the rune
	|        uint value;
	|
	|        /// <summary>
	|        /// Gets the rune unsigned integer value.
	|        /// </summary>
	|        public uint Value => value;
	|
	|        /// <summary>
	|        /// The ""error"" Rune or ""Unicode replacement character""
	|        /// </summary>
	|        public static Rune Error = new Rune(0xfffd);
	|
	|        /// <summary>
	|        /// Maximum valid Unicode code point.
	|        /// </summary>
	|        public static Rune MaxRune = new Rune(0x10ffff);
	|
	|        /// <summary>
	|        /// Characters below RuneSelf are represented as themselves in a single byte
	|        /// </summary>
	|        public const byte RuneSelf = 0x80;
	|
	|        /// <summary>
	|        /// Represents invalid code points.
	|        /// </summary>
	|        public static Rune ReplacementChar = new Rune(0xfffd);
	|
	|        /// <summary>
	|        /// Maximum number of bytes required to encode every unicode code point.
	|        /// </summary>
	|        public const int Utf8Max = 4;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:System.Rune""/> from a unsigned integer.
	|        /// </summary>
	|        /// <param name=""rune"">Unsigned integer.</param>
	|        /// <remarks>
	|        /// The value does not have to be a valid Unicode code point, this API
	|        /// will create an instance of Rune regardless of the whether it is in 
	|        /// range or not.
	|        /// </remarks>
	|        public Rune(uint rune)
	|        {
	|            if (rune > maxRune)
	|            {
	|                throw new ArgumentOutOfRangeException(""Value is beyond the supplementary range!"");
	|            }
	|            this.value = rune;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:System.Rune""/> from a character value.
	|        /// </summary>
	|        /// <param name=""ch"">C# characters.</param>
	|        public Rune(char ch)
	|        {
	|            this.value = (uint)ch;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""T:System.Rune""/> from a surrogate pair value.
	|        /// </summary>
	|        /// <param name=""highSurrogate"">The high surrogate code point.</param>
	|        /// <param name=""lowSurrogate"">The low surrogate code point.</param>
	|        public Rune(uint highSurrogate, uint lowSurrogate)
	|        {
	|            if (EncodeSurrogatePair(highSurrogate, lowSurrogate, out Rune rune))
	|            {
	|                this.value = rune;
	|            }
	|            else if (highSurrogate < highSurrogateMin || lowSurrogate > lowSurrogateMax)
	|            {
	|                throw new ArgumentOutOfRangeException($""Must be between {highSurrogateMin:x} and {lowSurrogateMax:x} inclusive!"");
	|            }
	|            else
	|            {
	|                throw new ArgumentOutOfRangeException($""Resulted rune must be less or equal to {(uint)MaxRune:x}!"");
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref=""T:System.Rune""/> can be encoded as UTF-8
	|        /// </summary>
	|        /// <value><c>true</c> if is valid; otherwise, <c>false</c>.</value>
	|        public bool IsValid => ValidRune(value);
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref=""T:System.Rune""/> is a surrogate code point.
	|        /// </summary>
	|        /// <returns><c>true</c>If is a surrogate code point, <c>false</c>otherwise.</returns>
	|        public bool IsSurrogate => IsSurrogateRune(value);
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref=""T:System.Rune""/> is a valid surrogate pair.
	|        /// </summary>
	|        /// <returns><c>true</c>If is a valid surrogate pair, <c>false</c>otherwise.</returns>
	|        public bool IsSurrogatePair => DecodeSurrogatePair(value, out _);
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref=""T:System.Rune""/> is a high surrogate.
	|        /// </summary>
	|        public bool IsHighSurrogate => value >= highSurrogateMin && value <= highSurrogateMax;
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref=""T:System.Rune""/> is a low surrogate.
	|        /// </summary>
	|        public bool IsLowSurrogate => value >= lowSurrogateMin && value <= lowSurrogateMax;
	|
	|        /// <summary>
	|        /// Check if the rune is a non-spacing character.
	|        /// </summary>
	|        /// <returns>True if is a non-spacing character, false otherwise.</returns>
	|        public bool IsNonSpacing => IsNonSpacingChar(value);
	|
	|        // Code points in the surrogate range are not valid for UTF-8.
	|        const uint highSurrogateMin = 0xd800;
	|        const uint highSurrogateMax = 0xdbff;
	|        const uint lowSurrogateMin = 0xdc00;
	|        const uint lowSurrogateMax = 0xdfff;
	|
	|        const uint maxRune = 0x10ffff;
	|
	|        const byte t1 = 0x00; // 0000 0000
	|        const byte tx = 0x80; // 1000 0000
	|        const byte t2 = 0xC0; // 1100 0000
	|        const byte t3 = 0xE0; // 1110 0000
	|        const byte t4 = 0xF0; // 1111 0000
	|        const byte t5 = 0xF8; // 1111 1000
	|
	|        const byte maskx = 0x3F; // 0011 1111
	|        const byte mask2 = 0x1F; // 0001 1111
	|        const byte mask3 = 0x0F; // 0000 1111
	|        const byte mask4 = 0x07; // 0000 0111
	|
	|        const uint rune1Max = (1 << 7) - 1;
	|        const uint rune2Max = (1 << 11) - 1;
	|        const uint rune3Max = (1 << 16) - 1;
	|
	|        // The default lowest and highest continuation byte.
	|        const byte locb = 0x80; // 1000 0000
	|        const byte hicb = 0xBF; // 1011 1111
	|
	|        // These names of these constants are chosen to give nice alignment in the
	|        // table below. The first nibble is an index into acceptRanges or F for
	|        // special one-byte ca1es. The second nibble is the Rune length or the
	|        // Status for the special one-byte ca1e.
	|        const byte xx = 0xF1; // invalid: size 1
	|        const byte a1 = 0xF0; // a1CII: size 1
	|        const byte s1 = 0x02; // accept 0, size 2
	|        const byte s2 = 0x13; // accept 1, size 3
	|        const byte s3 = 0x03; // accept 0, size 3
	|        const byte s4 = 0x23; // accept 2, size 3
	|        const byte s5 = 0x34; // accept 3, size 4
	|        const byte s6 = 0x04; // accept 0, size 4
	|        const byte s7 = 0x44; // accept 4, size 4
	|
	|        static byte[] first = new byte[256]{
	|			//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x00-0x0F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x10-0x1F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x20-0x2F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x30-0x3F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x40-0x4F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x50-0x5F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x60-0x6F
	|			a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, a1, // 0x70-0x7F
	|
	|			//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
	|			xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
	|			xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
	|			s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
	|			s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
	|			s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
	|		};
	|
	|        struct AcceptRange
	|        {
	|            public byte Lo, Hi;
	|            public AcceptRange(byte lo, byte hi)
	|            {
	|                Lo = lo;
	|                Hi = hi;
	|            }
	|        }
	|
	|        static AcceptRange[] AcceptRanges = new AcceptRange[] {
	|            new AcceptRange (locb, hicb),
	|            new AcceptRange (0xa0, hicb),
	|            new AcceptRange (locb, 0x9f),
	|            new AcceptRange (0x90, hicb),
	|            new AcceptRange (locb, 0x8f),
	|        };
	|
	|        /// <summary>
	|        /// FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
	|        /// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the bytes in p begin with a full UTF-8 encoding of a rune, <c>false</c> otherwise.</returns>
	|        /// <param name=""p"">byte array.</param>
	|        public static bool FullRune(byte[] p)
	|        {
	|            if (p == null)
	|                throw new ArgumentNullException(nameof(p));
	|            var n = p.Length;
	|
	|            if (n == 0)
	|                return false;
	|            var x = first[p[0]];
	|            if (n >= (x & 7))
	|            {
	|                // ascii, invalid or valid
	|                return true;
	|            }
	|            // must be short or invalid
	|            if (n > 1)
	|            {
	|                var accept = AcceptRanges[x >> 4];
	|                var c = p[1];
	|                if (c < accept.Lo || accept.Hi < c)
	|                    return true;
	|                else if (n > 2 && (p[2] < locb || hicb < p[2]))
	|                    return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and
	|        /// its width in bytes. 
	|        /// </summary>
	|        /// <returns>If p is empty it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.
	|        /// </returns>
	|        /// <param name=""buffer"">Byte buffer containing the utf8 string.</param>
	|        /// <param name=""start"">Starting offset to look into..</param>
	|        /// <param name=""n"">Number of bytes valid in the buffer, or -1 to make it the length of the buffer.</param>
	|        public static (Rune rune, int Size) DecodeRune(byte[] buffer, int start = 0, int n = -1)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            if (start < 0)
	|                throw new ArgumentException(""invalid offset"", nameof(start));
	|            if (n < 0)
	|                n = buffer.Length - start;
	|            if (start > buffer.Length - n)
	|                throw new ArgumentException(""Out of bounds"");
	|
	|            if (n < 1)
	|                return (Error, 0);
	|
	|            var p0 = buffer[start];
	|            var x = first[p0];
	|            if (x >= a1)
	|            {
	|                // The following code simulates an additional check for x == xx and
	|                // handling the ASCII and invalid cases accordingly. This mask-and-or
	|                // approach prevents an additional branch.
	|                uint mask = (uint)((((byte)x) << 31) >> 31); // Create 0x0000 or 0xFFFF.
	|                return (new Rune((buffer[start]) & ~mask | Error.value & mask), 1);
	|            }
	|
	|            var sz = x & 7;
	|            var accept = AcceptRanges[x >> 4];
	|            if (n < (int)sz)
	|                return (Error, 1);
	|
	|            var b1 = buffer[start + 1];
	|            if (b1 < accept.Lo || accept.Hi < b1)
	|                return (Error, 1);
	|
	|            if (sz == 2)
	|                return (new Rune((uint)((p0 & mask2)) << 6 | (uint)((b1 & maskx))), 2);
	|
	|            var b2 = buffer[start + 2];
	|            if (b2 < locb || hicb < b2)
	|                return (Error, 1);
	|
	|            if (sz == 3)
	|                return (new Rune((uint)((p0 & mask3)) << 12 | (uint)((b1 & maskx)) << 6 | (uint)((b2 & maskx))), 3);
	|
	|            var b3 = buffer[start + 3];
	|            if (b3 < locb || hicb < b3)
	|            {
	|                return (Error, 1);
	|            }
	|            return (new Rune((uint)(p0 & mask4) << 18 | (uint)(b1 & maskx) << 12 | (uint)(b2 & maskx) << 6 | (uint)(b3 & maskx)), 4);
	|        }
	|
	|
	|        // RuneStart reports whether the byte could be the first byte of an encoded,
	|        // possibly invalid rune. Second and subsequent bytes always have the top two
	|        // bits set to 10.
	|        static bool RuneStart(byte b) => (b & 0xc0) != 0x80;
	|
	|        /// <summary>
	|        /// DecodeLastRune unpacks the last UTF-8 encoding in buffer
	|        /// </summary>
	|        /// <returns>The last rune and its width in bytes.</returns>
	|        /// <param name=""buffer"">Buffer to decode rune from;   if it is empty,
	|        /// it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.</param>
	|        /// <param name=""end"">Scan up to that point, if the value is -1, it sets the value to the length of the buffer.</param>
	|        /// <remarks>
	|        /// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
	|        /// out of range, or is not the shortest possible UTF-8 encoding for the
	|        /// value. No other validation is performed.</remarks> 
	|        public static (Rune rune, int size) DecodeLastRune(byte[] buffer, int end = -1)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            if (buffer.Length == 0)
	|                return (Error, 0);
	|            if (end == -1)
	|                end = buffer.Length;
	|            else if (end > buffer.Length)
	|                throw new ArgumentException(""The end goes beyond the size of the buffer"");
	|
	|            var start = end - 1;
	|            uint r = buffer[start];
	|            if (r < RuneSelf)
	|                return (new Rune(r), 1);
	|            // guard against O(n^2) behavior when traversing
	|            // backwards through strings with long sequences of
	|            // invalid UTF-8.
	|            var lim = end - Utf8Max;
	|
	|            if (lim < 0)
	|                lim = 0;
	|
	|            for (start--; start >= lim; start--)
	|            {
	|                if (RuneStart(buffer[start]))
	|                {
	|                    break;
	|                }
	|            }
	|            if (start < 0)
	|                start = 0;
	|            int size;
	|            Rune r2;
	|            (r2, size) = DecodeRune(buffer, start, end - start);
	|            if (start + size != end)
	|                return (Error, 1);
	|            return (r2, size);
	|        }
	|
	|        /// <summary>
	|        /// number of bytes required to encode the rune.
	|        /// </summary>
	|        /// <returns>The length, or -1 if the rune is not a valid value to encode in UTF-8.</returns>
	|        /// <param name=""rune"">Rune to probe.</param>
	|        public static int RuneLen(Rune rune)
	|        {
	|            var rvalue = rune.value;
	|            if (rvalue <= rune1Max)
	|                return 1;
	|            if (rvalue <= rune2Max)
	|                return 2;
	|            if (highSurrogateMin <= rvalue && rvalue <= lowSurrogateMax)
	|                return -1;
	|            if (rvalue <= rune3Max)
	|                return 3;
	|            if (rvalue <= MaxRune.value)
	|                return 4;
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Writes into the destination buffer starting at offset the UTF8 encoded version of the rune
	|        /// </summary>
	|        /// <returns>The number of bytes written into the destination buffer.</returns>
	|        /// <param name=""rune"">Rune to encode.</param>
	|        /// <param name=""dest"">Destination buffer.</param>
	|        /// <param name=""offset"">Offset into the destination buffer.</param>
	|        public static int EncodeRune(Rune rune, byte[] dest, int offset = 0)
	|        {
	|            if (dest == null)
	|                throw new ArgumentNullException(nameof(dest));
	|            var runeValue = rune.value;
	|            if (runeValue <= rune1Max)
	|            {
	|                dest[offset] = (byte)runeValue;
	|                return 1;
	|            }
	|            if (runeValue <= rune2Max)
	|            {
	|                dest[offset++] = (byte)(t2 | (byte)(runeValue >> 6));
	|                dest[offset] = (byte)(tx | (byte)(runeValue & maskx));
	|                return 2;
	|            }
	|            if ((runeValue > MaxRune.value) || (highSurrogateMin <= runeValue && runeValue <= lowSurrogateMax))
	|            {
	|                // error
	|                dest[offset++] = 0xef;
	|                dest[offset++] = 0x3f;
	|                dest[offset] = 0x3d;
	|                return 3;
	|            }
	|            if (runeValue <= rune3Max)
	|            {
	|                dest[offset++] = (byte)(t3 | (byte)(runeValue >> 12));
	|                dest[offset++] = (byte)(tx | (byte)(runeValue >> 6) & maskx);
	|                dest[offset] = (byte)(tx | (byte)(runeValue) & maskx);
	|                return 3;
	|            }
	|            dest[offset++] = (byte)(t4 | (byte)(runeValue >> 18));
	|            dest[offset++] = (byte)(tx | (byte)(runeValue >> 12) & maskx);
	|            dest[offset++] = (byte)(tx | (byte)(runeValue >> 6) & maskx);
	|            dest[offset++] = (byte)(tx | (byte)(runeValue) & maskx);
	|            return 4;
	|        }
	|
	|        /// <summary>
	|        /// Returns the number of runes in a utf8 encoded buffer
	|        /// </summary>
	|        /// <returns>Number of runes.</returns>
	|        /// <param name=""buffer"">Byte buffer containing a utf8 string.</param>
	|        /// <param name=""offset"">Starting offset in the buffer.</param>
	|        /// <param name=""count"">Number of bytes to process in buffer, or -1 to process until the end of the buffer.</param>
	|        public static int RuneCount(byte[] buffer, int offset = 0, int count = -1)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            if (count == -1)
	|                count = buffer.Length;
	|            int n = 0;
	|            for (int i = offset; i < count;)
	|            {
	|                n++;
	|                var c = buffer[i];
	|
	|                if (c < RuneSelf)
	|                {
	|                    // ASCII fast path
	|                    i++;
	|                    continue;
	|                }
	|                var x = first[c];
	|                if (x == xx)
	|                {
	|                    i++; // invalid.
	|                    continue;
	|                }
	|
	|                var size = (int)(x & 7);
	|
	|                if (i + size > count)
	|                {
	|                    i++; // Short or invalid.
	|                    continue;
	|                }
	|                var accept = AcceptRanges[x >> 4];
	|                c = buffer[i + 1];
	|                if (c < accept.Lo || accept.Hi < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                if (size == 2)
	|                {
	|                    i += 2;
	|                    continue;
	|                }
	|                c = buffer[i + 2];
	|                if (c < locb || hicb < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                if (size == 3)
	|                {
	|                    i += 3;
	|                    continue;
	|                }
	|                c = buffer[i + 3];
	|                if (c < locb || hicb < c)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                i += size;
	|
	|            }
	|            return n;
	|        }
	|
	|        /// <summary>
	|        /// Reports whether p consists entirely of valid UTF-8-encoded runes.
	|        /// </summary>
	|        /// <param name=""buffer"">Byte buffer containing a utf8 string.</param>
	|        public static bool Valid(byte[] buffer)
	|        {
	|            return InvalidIndex(buffer) == -1;
	|        }
	|
	|        /// <summary>
	|        /// Use to find the index of the first invalid utf8 byte sequence in a buffer
	|        /// </summary>
	|        /// <returns>The index of the first invalid byte sequence or -1 if the entire buffer is valid.</returns>
	|        /// <param name=""buffer"">Buffer containing the utf8 buffer.</param>
	|        public static int InvalidIndex(byte[] buffer)
	|        {
	|            if (buffer == null)
	|                throw new ArgumentNullException(nameof(buffer));
	|            var n = buffer.Length;
	|
	|            for (int i = 0; i < n;)
	|            {
	|                var pi = buffer[i];
	|
	|                if (pi < RuneSelf)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                var x = first[pi];
	|                if (x == xx)
	|                    return i; // Illegal starter byte.
	|                var size = (int)(x & 7);
	|                if (i + size > n)
	|                    return i; // Short or invalid.
	|                var accept = AcceptRanges[x >> 4];
	|
	|                var c = buffer[i + 1];
	|
	|                if (c < accept.Lo || accept.Hi < c)
	|                    return i;
	|
	|                if (size == 2)
	|                {
	|                    i += 2;
	|                    continue;
	|                }
	|                c = buffer[i + 2];
	|                if (c < locb || hicb < c)
	|                    return i;
	|                if (size == 3)
	|                {
	|                    i += 3;
	|                    continue;
	|                }
	|                c = buffer[i + 3];
	|                if (c < locb || hicb < c)
	|                    return i;
	|                i += size;
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        ///  ValidRune reports whether a rune can be legally encoded as UTF-8.
	|        /// </summary>
	|        /// <returns><c>true</c>, if rune was validated, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test.</param>
	|        public static bool ValidRune(Rune rune)
	|        {
	|            if ((0 <= (int)rune.value && rune.value < highSurrogateMin) ||
	|                (lowSurrogateMax < rune.value && rune.value <= MaxRune.value))
	|            {
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Reports whether a rune is a surrogate code point.
	|        /// </summary>
	|        /// <param name=""rune"">The rune.</param>
	|        /// <returns><c>true</c>If is a surrogate code point, <c>false</c>otherwise.</returns>
	|        public static bool IsSurrogateRune(uint rune)
	|        {
	|            return rune >= highSurrogateMin && rune <= lowSurrogateMax;
	|        }
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref=""T:System.Rune""/> can be encoded as UTF-16 from a surrogate pair or zero otherwise.
	|        /// </summary>
	|        /// <param name=""highsurrogate"">The high surrogate code point.</param>
	|        /// <param name=""lowSurrogate"">The low surrogate code point.</param>
	|        /// <param name=""rune"">The returning rune.</param>
	|        /// <returns><c>True</c>if the returning rune is greater than 0 <c>False</c>otherwise.</returns>
	|        public static bool EncodeSurrogatePair(uint highsurrogate, uint lowSurrogate, out Rune rune)
	|        {
	|            rune = 0;
	|            if (highsurrogate >= highSurrogateMin && highsurrogate <= highSurrogateMax &&
	|                lowSurrogate >= lowSurrogateMin && lowSurrogate <= lowSurrogateMax)
	|            {
	|                //return 0x10000 + ((highsurrogate - highSurrogateMin) * 0x0400) + (lowSurrogate - lowSurrogateMin);
	|                return (rune = 0x10000 + ((highsurrogate - highSurrogateMin) << 10) + (lowSurrogate - lowSurrogateMin)) > 0;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Reports whether this <see cref=""T:System.Rune""/> is a valid surrogate pair and can be decoded from UTF-16.
	|        /// </summary>
	|        /// <param name=""rune"">The rune</param>
	|        /// <param name=""chars"">The chars if is valid. Empty otherwise.</param>
	|        /// <returns><c>true</c>If is a valid surrogate pair, <c>false</c>otherwise.</returns>
	|        public static bool DecodeSurrogatePair(uint rune, out char[] chars)
	|        {
	|            uint s = rune - 0x10000;
	|            uint h = highSurrogateMin + (s >> 10);
	|            uint l = lowSurrogateMin + (s & 0x3FF);
	|
	|            if (EncodeSurrogatePair(h, l, out Rune dsp) && dsp == rune)
	|            {
	|                chars = new char[] { (char)h, (char)l };
	|                return true;
	|            }
	|            chars = null;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Reports whether this <see cref=""T:System.Rune""/> is a valid surrogate pair and can be decoded from UTF-16.
	|        /// </summary>
	|        /// <param name=""str"">The string.</param>
	|        /// <param name=""chars"">The chars if is valid. Empty otherwise.</param>
	|        /// <returns><c>true</c>If is a valid surrogate pair, <c>false</c>otherwise.</returns>
	|        public static bool DecodeSurrogatePair(string str, out char[] chars)
	|        {
	|            if (str.Length == 2)
	|            {
	|                chars = str.ToCharArray();
	|                if (EncodeSurrogatePair(chars[0], chars[1], out _))
	|                {
	|                    return true;
	|                }
	|            }
	|            chars = null;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Given one byte from a utf8 string, return the number of expected bytes that make up the sequence.
	|        /// </summary>
	|        /// <returns>The number of UTF8 bytes expected given the first prefix.</returns>
	|        /// <param name=""firstByte"">Is the first byte of a UTF8 sequence.</param>
	|        public static int ExpectedSizeFromFirstByte(byte firstByte)
	|        {
	|            var x = first[firstByte];
	|
	|            // Invalid runes, just return 1 for byte, and let higher level pass to print
	|            if (x == xx)
	|                return -1;
	|            if (x == a1)
	|                return 1;
	|            return x & 0xf;
	|        }
	|
	|        /// <summary>
	|        /// IsDigit reports whether the rune is a decimal digit.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsDigit(Rune rune) => NStack.Unicode.IsDigit(rune.value);
	|
	|        /// <summary>
	|        /// IsGraphic reports whether the rune is defined as a Graphic by Unicode.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Such characters include letters, marks, numbers, punctuation, symbols, and
	|        /// spaces, from categories L, M, N, P, S, Zs.
	|        /// </remarks>
	|        public static bool IsGraphic(Rune rune) => NStack.Unicode.IsGraphic(rune.value);
	|
	|        /// <summary>
	|        /// IsPrint reports whether the rune is defined as printable.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Such characters include letters, marks, numbers, punctuation, symbols, and the
	|        /// ASCII space character, from categories L, M, N, P, S and the ASCII space
	|        /// character. This categorization is the same as IsGraphic except that the
	|        /// only spacing character is ASCII space, U+0020.
	|        /// </remarks>
	|        public static bool IsPrint(Rune rune) => NStack.Unicode.IsPrint(rune.value);
	|
	|
	|        /// <summary>
	|        /// IsControl reports whether the rune is a control character.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// The C (Other) Unicode category includes more code points such as surrogates; use C.InRange (r) to test for them.
	|        /// </remarks>
	|        public static bool IsControl(Rune rune) => NStack.Unicode.IsControl(rune.value);
	|
	|        /// <summary>
	|        /// IsLetter reports whether the rune is a letter (category L).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// </remarks>
	|        public static bool IsLetter(Rune rune) => NStack.Unicode.IsLetter(rune.value);
	|
	|        /// <summary>
	|        /// IsLetterOrDigit reports whether the rune is a letter (category L) or a digit.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a letter or digit, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// </remarks>
	|        public static bool IsLetterOrDigit(Rune rune) => NStack.Unicode.IsLetter(rune.value) || NStack.Unicode.IsDigit(rune.value);
	|
	|        /// <summary>
	|        /// IsLetterOrDigit reports whether the rune is a letter (category L) or a number (category N).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a letter or number, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// </remarks>
	|        public static bool IsLetterOrNumber(Rune rune) => NStack.Unicode.IsLetter(rune.value) || NStack.Unicode.IsNumber(rune.value);
	|
	|        /// <summary>
	|        /// IsMark reports whether the rune is a letter (category M).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Reports whether the rune is a mark character (category M).
	|        /// </remarks>
	|        public static bool IsMark(Rune rune) => NStack.Unicode.IsMark(rune.value);
	|
	|        /// <summary>
	|        /// IsNumber reports whether the rune is a letter (category N).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Reports whether the rune is a mark character (category N).
	|        /// </remarks>
	|        public static bool IsNumber(Rune rune) => NStack.Unicode.IsNumber(rune.value);
	|
	|        /// <summary>
	|        /// IsPunct reports whether the rune is a letter (category P).
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// Reports whether the rune is a mark character (category P).
	|        /// </remarks>
	|        public static bool IsPunctuation(Rune rune) => NStack.Unicode.IsPunct(rune.value);
	|
	|        /// <summary>
	|        /// IsSpace reports whether the rune is a space character as defined by Unicode's White Space property.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        /// <remarks>
	|        /// In the Latin-1 space, white space includes '\t', '\n', '\v', '\f', '\r', ' ', 
	|        /// U+0085 (NEL), U+00A0 (NBSP).
	|        /// Other definitions of spacing characters are set by category  Z and property Pattern_White_Space.
	|        /// </remarks>
	|        public static bool IsWhiteSpace(Rune rune) => NStack.Unicode.IsSpace(rune.value);
	|
	|        /// <summary>
	|        /// IsSymbol reports whether the rune is a symbolic character.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a mark, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsSymbol(Rune rune) => NStack.Unicode.IsSymbol(rune.value);
	|
	|        /// <summary>
	|        /// Reports whether the rune is an upper case letter.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is an upper case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsUpper(Rune rune) => NStack.Unicode.IsUpper(rune.value);
	|
	|        /// <summary>
	|        /// Reports whether the rune is a lower case letter.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsLower(Rune rune) => NStack.Unicode.IsLower(rune.value);
	|
	|        /// <summary>
	|        /// Reports whether the rune is a title case letter.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the rune is a lower case letter, <c>false</c> otherwise.</returns>
	|        /// <param name=""rune"">The rune to test for.</param>
	|        public static bool IsTitle(Rune rune) => NStack.Unicode.IsTitle(rune.value);
	|
	|        /// <summary>
	|        /// The types of cases supported.
	|        /// </summary>
	|        public enum Case
	|        {
	|            /// <summary>
	|            /// Upper case
	|            /// </summary>
	|            Upper = 0,
	|
	|            /// <summary>
	|            /// Lower case
	|            /// </summary>
	|            Lower = 1,
	|
	|            /// <summary>
	|            /// Title case capitalizes the first letter, and keeps the rest in lowercase.
	|            /// Sometimes it is not as straight forward as the uppercase, some characters require special handling, like
	|            /// certain ligatures and Greek characters.
	|            /// </summary>
	|            Title = 2
	|        };
	|
	|        // To maps the rune to the specified case: Case.Upper, Case.Lower, or Case.Title
	|        /// <summary>
	|        /// To maps the rune to the specified case: Case.Upper, Case.Lower, or Case.Title
	|        /// </summary>
	|        /// <returns>The cased character.</returns>
	|        /// <param name=""toCase"">The destination case.</param>
	|        /// <param name=""rune"">Rune to convert.</param>
	|        public static Rune To(Case toCase, Rune rune)
	|        {
	|            uint rval = rune.value;
	|            switch (toCase)
	|            {
	|                case Case.Lower:
	|                    return new Rune(NStack.Unicode.To(NStack.Unicode.Case.Lower, rval));
	|                case Case.Title:
	|                    return new Rune(NStack.Unicode.To(NStack.Unicode.Case.Title, rval));
	|                case Case.Upper:
	|                    return new Rune(NStack.Unicode.To(NStack.Unicode.Case.Upper, rval));
	|            }
	|            return ReplacementChar;
	|        }
	|
	|
	|        /// <summary>
	|        /// ToUpper maps the rune to upper case.
	|        /// </summary>
	|        /// <returns>The upper cased rune if it can be.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        public static Rune ToUpper(Rune rune) => NStack.Unicode.ToUpper(rune.value);
	|
	|        /// <summary>
	|        /// ToLower maps the rune to lower case.
	|        /// </summary>
	|        /// <returns>The lower cased rune if it can be.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        public static Rune ToLower(Rune rune) => NStack.Unicode.ToLower(rune.value);
	|
	|        /// <summary>
	|        /// ToLower maps the rune to title case.
	|        /// </summary>
	|        /// <returns>The lower cased rune if it can be.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        public static Rune ToTitle(Rune rune) => NStack.Unicode.ToTitle(rune.value);
	|
	|        /// <summary>
	|        /// SimpleFold iterates over Unicode code points equivalent under
	|        /// the Unicode-defined simple case folding.
	|        /// </summary>
	|        /// <returns>The simple-case folded rune.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        /// <remarks>
	|        /// SimpleFold iterates over Unicode code points equivalent under
	|        /// the Unicode-defined simple case folding. Among the code points
	|        /// equivalent to rune (including rune itself), SimpleFold returns the
	|        /// smallest rune > r if one exists, or else the smallest rune >= 0.
	|        /// If r is not a valid Unicode code point, SimpleFold(r) returns r.
	|        ///
	|        /// For example:
	|        /// <code>
	|        ///      SimpleFold('A') = 'a'
	|        ///      SimpleFold('a') = 'A'
	|        ///
	|        ///      SimpleFold('K') = 'k'
	|        ///      SimpleFold('k') = '\u212A' (Kelvin symbol, K)
	|        ///      SimpleFold('\u212A') = 'K'
	|        ///
	|        ///      SimpleFold('1') = '1'
	|        ///
	|        ///      SimpleFold(-2) = -2
	|        /// </code>
	|        /// </remarks>
	|        public static Rune SimpleFold(Rune rune) => NStack.Unicode.SimpleFold(rune.value);
	|
	|        /// <summary>
	|        /// Implicit operator conversion from a rune to an unsigned integer
	|        /// </summary>
	|        /// <returns>The unsigned integer representation.</returns>
	|        /// <param name=""rune"">Rune.</param>
	|        public static implicit operator uint(Rune rune) => rune.value;
	|
	|        /// <summary>
	|        /// Implicit operator conversion from a C# integer into a rune.
	|        /// </summary>
	|        /// <returns>Rune representing the C# integer</returns>
	|        /// <param name=""value"">32-bit Integer.</param>
	|        public static implicit operator Rune(int value) => new Rune((uint)value);
	|
	|        /// <summary>
	|        /// Implicit operator conversion from a byte to an unsigned integer
	|        /// </summary>
	|        /// <returns>The unsigned integer representation.</returns>
	|        /// <param name=""byt"">Byte.</param>
	|        public static implicit operator Rune(byte byt) => new Rune(byt);
	|
	|        /// <summary>
	|        /// Implicit operator conversion from a C# char into a rune.
	|        /// </summary>
	|        /// <returns>Rune representing the C# character</returns>
	|        /// <param name=""ch"">16-bit Character.</param>
	|        public static implicit operator Rune(char ch) => new Rune(ch);
	|
	|        /// <summary>
	|        /// Implicit operator conversion from an unsigned integer into a rune.
	|        /// </summary>
	|        /// <returns>Rune representing the C# character</returns>
	|        /// <param name=""value"">32-bit unsigned integer.</param>
	|        public static implicit operator Rune(uint value) => new Rune(value);
	|
	|        /// <summary>
	|        /// Serves as a hash function for a <see cref=""T:System.Rune""/> object.
	|        /// </summary>
	|        /// <returns>A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a hash table.</returns>
	|        public override int GetHashCode()
	|        {
	|            return (int)value;
	|        }
	|
	|        /// <summary>
	|        /// Returns a <see cref=""T:System.String""/> that represents the current <see cref=""T:System.Rune""/>.
	|        /// </summary>
	|        /// <returns>A <see cref=""T:System.String""/> that represents the current <see cref=""T:System.Rune""/>.</returns>
	|        public override string ToString()
	|        {
	|            var buff = new byte[4];
	|            var size = EncodeRune(this, buff, 0);
	|            return System.Text.Encoding.UTF8.GetString(buff, 0, size);
	|        }
	|
	|        /// <summary>
	|        /// Determines whether the specified <see cref=""object""/> is equal to the current <see cref=""T:System.Rune""/>.
	|        /// </summary>
	|        /// <param name=""obj"">The <see cref=""object""/> to compare with the current <see cref=""T:System.Rune""/>.</param>
	|        /// <returns><c>true</c> if the specified <see cref=""object""/> is equal to the current <see cref=""T:System.Rune""/>; otherwise, <c>false</c>.</returns>
	|        public override bool Equals(Object obj)
	|        {
	|            // Check for null values and compare run-time types.
	|            if (obj == null)
	|                return false;
	|
	|            Rune p = (Rune)obj;
	|            return p.value == value;
	|        }
	|    }
	|    //=======================================================================
	|    // Code that interoperates with NStack.ustring.
	|
	|    /// <summary>
	|    /// Helper class that implements <see cref=""System.Rune""/> extensions for the <see cref=""NStack.ustring""/> type.
	|    /// </summary>
	|    public static class RuneExtensions
	|    {
	|        /// <summary>
	|        /// FullRune reports whether the ustring begins with a full UTF-8 encoding of a rune.
	|        /// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
	|        /// </summary>
	|        /// <returns><c>true</c>, if the bytes in p begin with a full UTF-8 encoding of a rune, <c>false</c> otherwise.</returns>
	|        /// <param name=""str"">The string to check.</param>
	|        public static bool FullRune(this ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|
	|            foreach (var rune in str)
	|            {
	|                if (rune == Rune.Error)
	|                {
	|                    return false;
	|                }
	|                ustring us = ustring.Make(rune);
	|                if (!Rune.FullRune(us.ToByteArray()))
	|                {
	|                    return false;
	|                }
	|            }
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// DecodeRune unpacks the first UTF-8 encoding in the ustring returns the rune and
	|        /// its width in bytes. 
	|        /// </summary>
	|        /// <returns>If p is empty it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.
	|        /// </returns>
	|        /// <param name=""str"">ustring to decode.</param>
	|        /// <param name=""start"">Starting offset to look into..</param>
	|        /// <param name=""n"">Number of bytes valid in the buffer, or -1 to make it the length of the buffer.</param>
	|        public static (Rune rune, int size) DecodeRune(this ustring str, int start = 0, int n = -1)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|            if (start < 0)
	|                throw new ArgumentException(""invalid offset"", nameof(start));
	|            if (n < 0)
	|                n = str.Length - start;
	|            if (start > str.Length - n)
	|                throw new ArgumentException(""Out of bounds"");
	|
	|            return Rune.DecodeRune(str.ToByteArray(), start, n);
	|        }
	|
	|        /// <summary>
	|        /// DecodeLastRune unpacks the last UTF-8 encoding in the ustring.
	|        /// </summary>
	|        /// <returns>The last rune and its width in bytes.</returns>
	|        /// <param name=""str"">String to decode rune from;   if it is empty,
	|        /// it returns (RuneError, 0). Otherwise, if
	|        /// the encoding is invalid, it returns (RuneError, 1). Both are impossible
	|        /// results for correct, non-empty UTF-8.</param>
	|        /// <param name=""end"">Scan up to that point, if the value is -1, it sets the value to the length of the buffer.</param>
	|        /// <remarks>
	|        /// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
	|        /// out of range, or is not the shortest possible UTF-8 encoding for the
	|        /// value. No other validation is performed.</remarks> 
	|        public static (Rune rune, int size) DecodeLastRune(this ustring str, int end = -1)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|            if (str.Length == 0)
	|                return (Rune.Error, 0);
	|            if (end == -1)
	|                end = str.Length;
	|            else if (end > str.Length)
	|                throw new ArgumentException(""The end goes beyond the size of the buffer"");
	|
	|            return Rune.DecodeLastRune(str.ToByteArray(), end);
	|        }
	|
	|        /// <summary>
	|        /// Returns the number of runes in a ustring.
	|        /// </summary>
	|        /// <returns>Number of runes.</returns>
	|        /// <param name=""str"">utf8 string.</param>
	|        public static int RuneCount(this ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|
	|            return Rune.RuneCount(str.ToByteArray());
	|        }
	|
	|        /// <summary>
	|        /// Use to find the index of the first invalid utf8 byte sequence in a buffer
	|        /// </summary>
	|        /// <returns>The index of the first invalid byte sequence or -1 if the entire buffer is valid.</returns>
	|        /// <param name=""str"">String containing the utf8 buffer.</param>
	|        public static int InvalidIndex(this ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|
	|            return Rune.InvalidIndex(str.ToByteArray());
	|        }
	|
	|        /// <summary>
	|        /// Reports whether the ustring consists entirely of valid UTF-8-encoded runes.
	|        /// </summary>
	|        /// <param name=""str"">String to validate.</param>
	|        public static bool Valid(this ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|
	|            return Rune.Valid(str.ToByteArray());
	|        }
	|
	|        /// <summary>
	|        /// Given one byte from a utf8 string, return the number of expected bytes that make up the sequence.
	|        /// </summary>
	|        /// <returns>The number of UTF8 bytes expected given the first prefix.</returns>
	|        /// <param name=""str"">String to get the first byte of a UTF8 sequence.</param>
	|        public static int ExpectedSizeFromFirstByte(this ustring str)
	|        {
	|            if ((object)str == null)
	|                throw new ArgumentNullException(nameof(str));
	|
	|            return Rune.ExpectedSizeFromFirstByte(str[0]);
	|        }
	|    }
	|}
	|";
	ТекстДокХХХ = Новый ТекстовыйДокумент;
	ТекстДокХХХ.УстановитьТекст(СтрФайла);
	ТекстДокХХХ.Записать(КаталогВыгрузки + "\NStackSupport.cs");
	
	СтрФайла = 
	"using NStack;
	|using Rune = System.Rune;
	|using System.Collections.Generic;
	|using System.Collections.ObjectModel;
	|using System.Collections;
	|using System.ComponentModel;
	|using System.Data;
	|using System.Diagnostics;
	|using System.Globalization;
	|using System.IO;
	|using System.Linq;
	|using System.Management;
	|using System.Reflection;
	|using System.Runtime.CompilerServices;
	|using System.Runtime.InteropServices;
	|using System.Text.RegularExpressions;
	|using System.Text;
	|using System.Threading.Tasks;
	|using System.Threading;
	|using System;
	|using Terminal.Gui.Graphs;
	|using Terminal.Gui.Resources;
	|using Terminal.Gui.TextValidateProviders;
	|using Terminal.Gui.Trees;
	|using Terminal.Gui;
	|using Unix.Terminal;
	|using static Terminal.Gui.Graphs.PathAnnotation;
	|//// Alias Console to MockConsole so we don't accidentally use Console
	|//using Console = Terminal.Gui.FakeConsole;
	|
	|//=======================================================================
	|namespace Terminal.Gui.Graphs
	|{
	|    /// <summary>
	|    /// <para>Describes an overlay element that is rendered either before or
	|    /// after a series.</para>
	|    /// 
	|    /// <para>Annotations can be positioned either in screen space (e.g.
	|    /// a legend) or in graph space (e.g. a line showing high point)
	|    /// </para>
	|    /// <para>Unlike <see cref=""ISeries""/>, annotations are allowed to
	|    /// draw into graph margins
	|    /// </para>
	|    /// </summary>
	|    public interface IAnnotation
	|    {
	|        /// <summary>
	|        /// True if annotation should be drawn before <see cref=""ISeries""/>.  This
	|        /// allowes Series and later annotations to potentially draw over the top
	|        /// of this annotation.
	|        /// </summary>
	|        bool BeforeSeries { get; }
	|
	|        /// <summary>
	|        /// Called once after series have been rendered (or before if <see cref=""BeforeSeries""/> is true).
	|        /// Use <see cref=""View.Driver""/> to draw and <see cref=""View.Bounds""/> to avoid drawing outside of
	|        /// graph
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        void Render(GraphView graph);
	|    }
	|
	|
	|    /// <summary>
	|    /// Displays text at a given position (in screen space or graph space)
	|    /// </summary>
	|    public class TextAnnotation : IAnnotation
	|    {
	|
	|        /// <summary>
	|        /// The location on screen to draw the <see cref=""Text""/> regardless
	|        /// of scroll/zoom settings.  This overrides <see cref=""GraphPosition""/>
	|        /// if specified.
	|        /// </summary>
	|        public Point? ScreenPosition { get; set; }
	|
	|        /// <summary>
	|        /// The location in graph space to draw the <see cref=""Text""/>.  This
	|        /// annotation will only show if the point is in the current viewable
	|        /// area of the graph presented in the <see cref=""GraphView""/>
	|        /// </summary>
	|        public PointF GraphPosition { get; set; }
	|
	|        /// <summary>
	|        /// Text to display on the graph
	|        /// </summary>
	|        public string Text { get; set; }
	|
	|        /// <summary>
	|        /// True to add text before plotting series.  Defaults to false
	|        /// </summary>
	|        public bool BeforeSeries { get; set; }
	|
	|        /// <summary>
	|        /// Draws the annotation
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public void Render(GraphView graph)
	|        {
	|            if (ScreenPosition.HasValue)
	|            {
	|                DrawText(graph, ScreenPosition.Value.X, ScreenPosition.Value.Y);
	|                return;
	|            }
	|
	|            var screenPos = graph.GraphSpaceToScreen(GraphPosition);
	|            DrawText(graph, screenPos.X, screenPos.Y);
	|        }
	|
	|        /// <summary>
	|        /// Draws the <see cref=""Text""/> at the given coordinates with truncation to avoid
	|        /// spilling over <see name=""View.Bounds""/> of the <paramref name=""graph""/>
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""x"">Screen x position to start drawing string</param>
	|        /// <param name=""y"">Screen y position to start drawing string</param>
	|        protected void DrawText(GraphView graph, int x, int y)
	|        {
	|            // the draw point is out of control bounds
	|            if (!graph.Bounds.Contains(new Point(x, y)))
	|            {
	|                return;
	|            }
	|
	|            // There is no text to draw
	|            if (string.IsNullOrWhiteSpace(Text))
	|            {
	|                return;
	|            }
	|
	|            graph.Move(x, y);
	|
	|            int availableWidth = graph.Bounds.Width - x;
	|
	|            if (availableWidth <= 0)
	|            {
	|                return;
	|            }
	|
	|            if (Text.Length < availableWidth)
	|            {
	|                View.Driver.AddStr(Text);
	|            }
	|            else
	|            {
	|                View.Driver.AddStr(Text.Substring(0, availableWidth));
	|            }
	|        }
	|    }
	|
	|    /// <summary>
	|    /// A box containing symbol definitions e.g. meanings for colors in a graph.
	|    /// The 'Key' to the graph
	|    /// </summary>
	|    public class LegendAnnotation : IAnnotation
	|    {
	|
	|        /// <summary>
	|        /// True to draw a solid border around the legend.
	|        /// Defaults to true.  This border will be within the
	|        /// <see cref=""Bounds""/> and so reduces the width/height
	|        /// available for text by 2
	|        /// </summary>
	|        public bool Border { get; set; } = true;
	|
	|        /// <summary>
	|        /// Defines the screen area available for the legend to render in
	|        /// </summary>
	|        public Rect Bounds { get; set; }
	|
	|        /// <summary>
	|        /// Returns false i.e. Lengends render after series
	|        /// </summary>
	|        public bool BeforeSeries => false;
	|
	|        /// <summary>
	|        /// Ordered collection of entries that are rendered in the legend.
	|        /// </summary>
	|        List<Tuple<GraphCellToRender, string>> entries = new List<Tuple<GraphCellToRender, string>>();
	|
	|        /// <summary>
	|        /// Creates a new empty legend at the given screen coordinates
	|        /// </summary>
	|        /// <param name=""legendBounds"">Defines the area available for the legend to render in
	|        /// (within the graph).  This is in screen units (i.e. not graph space)</param>
	|        public LegendAnnotation(Rect legendBounds)
	|        {
	|            Bounds = legendBounds;
	|        }
	|
	|        /// <summary>
	|        /// Draws the Legend and all entries into the area within <see cref=""Bounds""/>
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public void Render(GraphView graph)
	|        {
	|            if (Border)
	|            {
	|                graph.DrawFrame(Bounds, 0, true);
	|            }
	|
	|            // start the legend at
	|            int y = Bounds.Top + (Border ? 1 : 0);
	|            int x = Bounds.Left + (Border ? 1 : 0);
	|
	|            // how much horizontal space is available for writing legend entries?
	|            int availableWidth = Bounds.Width - (Border ? 2 : 0);
	|            int availableHeight = Bounds.Height - (Border ? 2 : 0);
	|
	|            int linesDrawn = 0;
	|
	|            foreach (var entry in entries)
	|            {
	|
	|                if (entry.Item1.Color.HasValue)
	|                {
	|                    Application.Driver.SetAttribute(entry.Item1.Color.Value);
	|                }
	|                else
	|                {
	|                    graph.SetDriverColorToGraphColor();
	|                }
	|
	|                // add the symbol
	|                graph.AddRune(x, y + linesDrawn, entry.Item1.Rune);
	|
	|                // switch to normal coloring (for the text)
	|                graph.SetDriverColorToGraphColor();
	|
	|                // add the text
	|                graph.Move(x + 1, y + linesDrawn);
	|
	|                string str = TextFormatter.ClipOrPad(entry.Item2, availableWidth - 1);
	|                Application.Driver.AddStr(str);
	|
	|                linesDrawn++;
	|
	|                // Legend has run out of space
	|                if (linesDrawn >= availableHeight)
	|                {
	|                    break;
	|                }
	|            }
	|        }
	|
	|
	|        /// <summary>
	|        /// Adds an entry into the legend.  Duplicate entries are permissable
	|        /// </summary>
	|        /// <param name=""graphCellToRender"">The symbol appearing on the graph that should appear in the legend</param>
	|        /// <param name=""text"">Text to render on this line of the legend.  Will be truncated
	|        /// if outside of Legend <see cref=""Bounds""/></param>
	|        public void AddEntry(GraphCellToRender graphCellToRender, string text)
	|        {
	|            entries.Add(Tuple.Create(graphCellToRender, text));
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Sequence of lines to connect points e.g. of a <see cref=""ScatterSeries""/>
	|    /// </summary>
	|    public class PathAnnotation : IAnnotation
	|    {
	|
	|        /// <summary>
	|        /// Points that should be connected.  Lines will be drawn between points in the order
	|        /// they appear in the list
	|        /// </summary>
	|        public List<PointF> Points { get; set; } = new List<PointF>();
	|
	|        /// <summary>
	|        /// Color for the line that connects points
	|        /// </summary>
	|        public Attribute? LineColor { get; set; }
	|
	|        /// <summary>
	|        /// The symbol that gets drawn along the line, defaults to '.'
	|        /// </summary>
	|        public Rune LineRune { get; set; } = new Rune('.');
	|
	|        /// <summary>
	|        /// True to add line before plotting series.  Defaults to false
	|        /// </summary>
	|        public bool BeforeSeries { get; set; }
	|
	|
	|        /// <summary>
	|        /// Draws lines connecting each of the <see cref=""Points""/>
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public void Render(GraphView graph)
	|        {
	|            View.Driver.SetAttribute(LineColor ?? graph.ColorScheme.Normal);
	|
	|            foreach (var line in PointsToLines())
	|            {
	|
	|                var start = graph.GraphSpaceToScreen(line.Start);
	|                var end = graph.GraphSpaceToScreen(line.End);
	|                graph.DrawLine(start, end, LineRune);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Generates lines joining <see cref=""Points""/> 
	|        /// </summary>
	|        /// <returns></returns>
	|        private IEnumerable<LineF> PointsToLines()
	|        {
	|            for (int i = 0; i < Points.Count - 1; i++)
	|            {
	|                yield return new LineF(Points[i], Points[i + 1]);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Describes two points in graph space and a line between them
	|        /// </summary>
	|        public class LineF
	|        {
	|            /// <summary>
	|            /// The start of the line
	|            /// </summary>
	|            public PointF Start { get; }
	|
	|            /// <summary>
	|            /// The end point of the line
	|            /// </summary>
	|            public PointF End { get; }
	|
	|            /// <summary>
	|            /// Creates a new line between the points
	|            /// </summary>
	|            public LineF(PointF start, PointF end)
	|            {
	|                this.Start = start;
	|                this.End = end;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Renders a continuous line with grid line ticks and labels
	|    /// </summary>
	|    public abstract class Axis
	|    {
	|        /// <summary>
	|        /// Default value for <see cref=""ShowLabelsEvery""/>
	|        /// </summary>
	|        const uint DefaultShowLabelsEvery = 5;
	|
	|        /// <summary>
	|        /// Direction of the axis
	|        /// </summary>
	|        /// <value></value>
	|        public Orientation Orientation { get; }
	|
	|        /// <summary>
	|        /// Number of units of graph space between ticks on axis. 0 for no ticks
	|        /// </summary>
	|        /// <value></value>
	|        public float Increment { get; set; } = 1;
	|
	|        /// <summary>
	|        /// The number of <see cref=""Increment""/> before an label is added.
	|        /// 0 = never show labels
	|        /// </summary>
	|        public uint ShowLabelsEvery { get; set; } = DefaultShowLabelsEvery;
	|
	|        /// <summary>
	|        /// True to render axis.  Defaults to true
	|        /// </summary>
	|        public bool Visible { get; set; } = true;
	|
	|        /// <summary>
	|        /// Allows you to control what label text is rendered for a given <see cref=""Increment""/>
	|        /// when <see cref=""ShowLabelsEvery""/> is above 0
	|        /// </summary>
	|        public LabelGetterDelegate LabelGetter;
	|
	|        /// <summary>
	|        /// Displayed below/to left of labels (see <see cref=""Orientation""/>).
	|        /// If text is not visible, check <see cref=""GraphView.MarginBottom""/> / <see cref=""GraphView.MarginLeft""/>
	|        /// </summary>
	|        public string Text { get; set; }
	|
	|        /// <summary>
	|        /// The minimum axis point to show.  Defaults to null (no minimum)
	|        /// </summary>
	|        public float? Minimum { get; set; }
	|
	|        /// <summary>
	|        /// Populates base properties and sets the read only <see cref=""Orientation""/>
	|        /// </summary>
	|        /// <param name=""orientation""></param>
	|        protected Axis(Orientation orientation)
	|        {
	|            Orientation = orientation;
	|            LabelGetter = DefaultLabelGetter;
	|        }
	|
	|        /// <summary>
	|        /// Draws the solid line of the axis
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public abstract void DrawAxisLine(GraphView graph);
	|
	|        /// <summary>
	|        /// Draws a single cell of the solid line of the axis
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""x""></param>
	|        /// <param name=""y""></param>
	|        protected abstract void DrawAxisLine(GraphView graph, int x, int y);
	|
	|        /// <summary>
	|        /// Draws labels and axis <see cref=""Increment""/> ticks
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|
	|        public abstract void DrawAxisLabels(GraphView graph);
	|
	|        /// <summary>
	|        /// Draws a custom label <paramref name=""text""/> at <paramref name=""screenPosition""/> units
	|        /// along the axis (X or Y depending on <see cref=""Orientation""/>)
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""screenPosition""></param>
	|        /// <param name=""text""></param>
	|        public abstract void DrawAxisLabel(GraphView graph, int screenPosition, string text);
	|
	|        /// <summary>
	|        /// Resets all configurable properties of the axis to default values
	|        /// </summary>
	|        public virtual void Reset()
	|        {
	|            Increment = 1;
	|            ShowLabelsEvery = DefaultShowLabelsEvery;
	|            Visible = true;
	|            Text = """";
	|            LabelGetter = DefaultLabelGetter;
	|            Minimum = null;
	|        }
	|
	|        private string DefaultLabelGetter(AxisIncrementToRender toRender)
	|        {
	|            return toRender.Value.ToString(""N0"");
	|        }
	|    }
	|
	|    /// <summary>
	|    /// The horizontal (x axis) of a <see cref=""GraphView""/>
	|    /// </summary>
	|    public class HorizontalAxis : Axis
	|    {
	|
	|        /// <summary>
	|        /// Creates a new instance of axis with an <see cref=""Orientation""/> of <see cref=""Orientation.Horizontal""/>
	|        /// </summary>
	|        public HorizontalAxis() : base(Orientation.Horizontal)
	|        {
	|        }
	|
	|
	|        /// <summary>
	|        /// Draws the horizontal axis line
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public override void DrawAxisLine(GraphView graph)
	|        {
	|            if (!Visible)
	|            {
	|                return;
	|            }
	|            var bounds = graph.Bounds;
	|
	|            graph.Move(0, 0);
	|
	|            var y = GetAxisYPosition(graph);
	|
	|            // start the x axis at left of screen (either 0 or margin)
	|            var xStart = (int)graph.MarginLeft;
	|
	|            // but if the x axis has a minmum (minimum is in graph space units)
	|            if (Minimum.HasValue)
	|            {
	|
	|                // start at the screen location of the minimum
	|                var minimumScreenX = graph.GraphSpaceToScreen(new PointF(Minimum.Value, y)).X;
	|
	|                // unless that is off the screen to the left
	|                xStart = Math.Max(xStart, minimumScreenX);
	|            }
	|
	|            for (int i = xStart; i < bounds.Width; i++)
	|            {
	|
	|                DrawAxisLine(graph, i, y);
	|            }
	|        }
	|
	|
	|        /// <summary>
	|        /// Draws a horizontal axis line at the given <paramref name=""x""/>, <paramref name=""y""/> 
	|        /// screen coordinates
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""x""></param>
	|        /// <param name=""y""></param>
	|        protected override void DrawAxisLine(GraphView graph, int x, int y)
	|        {
	|            graph.Move(x, y);
	|            Application.Driver.AddRune(Application.Driver.HLine);
	|        }
	|
	|        /// <summary>
	|        /// Draws the horizontal x axis labels and <see cref=""Axis.Increment""/> ticks
	|        /// </summary>
	|        public override void DrawAxisLabels(GraphView graph)
	|        {
	|            if (!Visible || Increment == 0)
	|            {
	|                return;
	|            }
	|
	|            var bounds = graph.Bounds;
	|
	|            var labels = GetLabels(graph, bounds);
	|
	|            foreach (var label in labels)
	|            {
	|                DrawAxisLabel(graph, label.ScreenLocation, label.Text);
	|            }
	|
	|            // if there is a title
	|            if (!string.IsNullOrWhiteSpace(Text))
	|            {
	|
	|                string toRender = Text;
	|
	|                // if label is too long
	|                if (toRender.Length > graph.Bounds.Width)
	|                {
	|                    toRender = toRender.Substring(0, graph.Bounds.Width);
	|                }
	|
	|                graph.Move(graph.Bounds.Width / 2 - (toRender.Length / 2), graph.Bounds.Height - 1);
	|                Application.Driver.AddStr(toRender);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Draws the given <paramref name=""text""/> on the axis at x <paramref name=""screenPosition""/>.
	|        /// For the screen y position use <see cref=""GetAxisYPosition(GraphView)""/>
	|        /// </summary>
	|        /// <param name=""graph"">Graph being drawn onto</param>
	|        /// <param name=""screenPosition"">Number of screen columns along the axis to take before rendering</param>
	|        /// <param name=""text"">Text to render under the axis tick</param>
	|        public override void DrawAxisLabel(GraphView graph, int screenPosition, string text)
	|        {
	|            var driver = Application.Driver;
	|            var y = GetAxisYPosition(graph);
	|
	|            graph.Move(screenPosition, y);
	|
	|            // draw the tick on the axis
	|            driver.AddRune(driver.TopTee);
	|
	|            // and the label text
	|            if (!string.IsNullOrWhiteSpace(text))
	|            {
	|
	|                // center the label but don't draw it outside bounds of the graph
	|                int drawAtX = Math.Max(0, screenPosition - (text.Length / 2));
	|                string toRender = text;
	|
	|                // this is how much space is left
	|                int xSpaceAvailable = graph.Bounds.Width - drawAtX;
	|
	|                // There is no space for the label at all!
	|                if (xSpaceAvailable <= 0)
	|                {
	|                    return;
	|                }
	|
	|                // if we are close to right side of graph, don't overspill
	|                if (toRender.Length > xSpaceAvailable)
	|                {
	|                    toRender = toRender.Substring(0, xSpaceAvailable);
	|                }
	|
	|                graph.Move(drawAtX, Math.Min(y + 1, graph.Bounds.Height - 1));
	|                driver.AddStr(toRender);
	|            }
	|        }
	|
	|        private IEnumerable<AxisIncrementToRender> GetLabels(GraphView graph, Rect bounds)
	|        {
	|            // if no labels
	|            if (Increment == 0)
	|            {
	|                yield break;
	|            }
	|
	|            int labels = 0;
	|            int y = GetAxisYPosition(graph);
	|
	|            var start = graph.ScreenToGraphSpace((int)graph.MarginLeft, y);
	|            var end = graph.ScreenToGraphSpace(bounds.Width, y);
	|
	|            // don't draw labels below the minimum
	|            if (Minimum.HasValue)
	|            {
	|                start.X = Math.Max(start.X, Minimum.Value);
	|            }
	|
	|            var current = start;
	|
	|            while (current.X < end.X)
	|            {
	|
	|                int screenX = graph.GraphSpaceToScreen(new PointF(current.X, current.Y)).X;
	|
	|                // The increment we will render (normally a top T unicode symbol)
	|                var toRender = new AxisIncrementToRender(Orientation, screenX, current.X);
	|
	|                // Not every increment has to have a label
	|                if (ShowLabelsEvery != 0)
	|                {
	|
	|                    // if this increment does also needs a label
	|                    if (labels++ % ShowLabelsEvery == 0)
	|                    {
	|                        toRender.Text = LabelGetter(toRender);
	|                    };
	|                }
	|
	|                // Label or no label definetly render it
	|                yield return toRender;
	|
	|
	|                current.X += Increment;
	|            }
	|        }
	|        /// <summary>
	|        /// Returns the Y screen position of the origin (typically 0,0) of graph space.
	|        /// Return value is bounded by the screen i.e. the axis is always rendered even
	|        /// if the origin is offscreen.
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public int GetAxisYPosition(GraphView graph)
	|        {
	|            // find the origin of the graph in screen space (this allows for 'crosshair' style
	|            // graphs where positive and negative numbers visible
	|            var origin = graph.GraphSpaceToScreen(new PointF(0, 0));
	|
	|            // float the X axis so that it accurately represents the origin of the graph
	|            // but anchor it to top/bottom if the origin is offscreen
	|            return Math.Min(Math.Max(0, origin.Y), graph.Bounds.Height - ((int)graph.MarginBottom + 1));
	|        }
	|    }
	|
	|    /// <summary>
	|    /// The vertical (i.e. Y axis) of a <see cref=""GraphView""/>
	|    /// </summary>
	|    public class VerticalAxis : Axis
	|    {
	|
	|
	|        /// <summary>
	|        /// Creates a new <see cref=""Orientation.Vertical""/> axis
	|        /// </summary>
	|        public VerticalAxis() : base(Orientation.Vertical)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Draws the vertical axis line
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public override void DrawAxisLine(GraphView graph)
	|        {
	|            if (!Visible)
	|            {
	|                return;
	|            }
	|            Rect bounds = graph.Bounds;
	|
	|            var x = GetAxisXPosition(graph);
	|
	|            var yEnd = GetAxisYEnd(graph);
	|
	|            // don't draw down further than the control bounds
	|            yEnd = Math.Min(yEnd, bounds.Height - (int)graph.MarginBottom);
	|
	|            // Draw solid line
	|            for (int i = 0; i < yEnd; i++)
	|            {
	|
	|                DrawAxisLine(graph, x, i);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Draws a vertical axis line at the given <paramref name=""x""/>, <paramref name=""y""/> 
	|        /// screen coordinates
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""x""></param>
	|        /// <param name=""y""></param>
	|        protected override void DrawAxisLine(GraphView graph, int x, int y)
	|        {
	|            graph.Move(x, y);
	|            Application.Driver.AddRune(Application.Driver.VLine);
	|        }
	|
	|        private int GetAxisYEnd(GraphView graph)
	|        {
	|            // draw down the screen (0 is top of screen)
	|            // end at the bottom of the screen
	|
	|            //unless there is a minimum 
	|            if (Minimum.HasValue)
	|            {
	|                return graph.GraphSpaceToScreen(new PointF(0, Minimum.Value)).Y;
	|            }
	|
	|            return graph.Bounds.Height;
	|        }
	|
	|
	|        /// <summary>
	|        /// Draws axis <see cref=""Axis.Increment""/> markers and labels
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public override void DrawAxisLabels(GraphView graph)
	|        {
	|            if (!Visible || Increment == 0)
	|            {
	|                return;
	|            }
	|
	|            var bounds = graph.Bounds;
	|            var labels = GetLabels(graph, bounds);
	|
	|            foreach (var label in labels)
	|            {
	|
	|                DrawAxisLabel(graph, label.ScreenLocation, label.Text);
	|            }
	|
	|            // if there is a title
	|            if (!string.IsNullOrWhiteSpace(Text))
	|            {
	|
	|                string toRender = Text;
	|
	|                // if label is too long
	|                if (toRender.Length > graph.Bounds.Height)
	|                {
	|                    toRender = toRender.Substring(0, graph.Bounds.Height);
	|                }
	|
	|                // Draw it 1 letter at a time vertically down row 0 of the control
	|                int startDrawingAtY = graph.Bounds.Height / 2 - (toRender.Length / 2);
	|
	|                for (int i = 0; i < toRender.Length; i++)
	|                {
	|
	|                    graph.Move(0, startDrawingAtY + i);
	|                    Application.Driver.AddRune(toRender[i]);
	|                }
	|
	|            }
	|        }
	|
	|        private IEnumerable<AxisIncrementToRender> GetLabels(GraphView graph, Rect bounds)
	|        {
	|            // if no labels
	|            if (Increment == 0)
	|            {
	|                yield break;
	|            }
	|
	|            int labels = 0;
	|            int x = GetAxisXPosition(graph);
	|
	|            // remember screen space is top down so the lowest graph
	|            // space value is at the bottom of the screen
	|            var start = graph.ScreenToGraphSpace(x, bounds.Height - (1 + (int)graph.MarginBottom));
	|            var end = graph.ScreenToGraphSpace(x, 0);
	|
	|            // don't draw labels below the minimum
	|            if (Minimum.HasValue)
	|            {
	|                start.Y = Math.Max(start.Y, Minimum.Value);
	|            }
	|
	|            var current = start;
	|
	|            while (current.Y < end.Y)
	|            {
	|
	|                int screenY = graph.GraphSpaceToScreen(new PointF(current.X, current.Y)).Y;
	|
	|                // Create the axis symbol
	|                var toRender = new AxisIncrementToRender(Orientation, screenY, current.Y);
	|
	|                // and the label (if we are due one)
	|                if (ShowLabelsEvery != 0)
	|                {
	|
	|                    // if this increment also needs a label
	|                    if (labels++ % ShowLabelsEvery == 0)
	|                    {
	|                        toRender.Text = LabelGetter(toRender);
	|                    };
	|                }
	|
	|                // draw the axis symbol (and label if it has one)
	|                yield return toRender;
	|
	|
	|                current.Y += Increment;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Draws the given <paramref name=""text""/> on the axis at y <paramref name=""screenPosition""/>.
	|        /// For the screen x position use <see cref=""GetAxisXPosition(GraphView)""/>
	|        /// </summary>
	|        /// <param name=""graph"">Graph being drawn onto</param>
	|        /// <param name=""screenPosition"">Number of rows from the top of the screen (i.e. down the axis) before rendering</param>
	|        /// <param name=""text"">Text to render to the left of the axis tick.  Ensure to 
	|        /// set <see cref=""GraphView.MarginLeft""/> or <see cref=""GraphView.ScrollOffset""/> sufficient that it is visible</param>
	|        public override void DrawAxisLabel(GraphView graph, int screenPosition, string text)
	|        {
	|            var x = GetAxisXPosition(graph);
	|            var labelThickness = text.Length;
	|
	|            graph.Move(x, screenPosition);
	|
	|            // draw the tick on the axis
	|            Application.Driver.AddRune(Application.Driver.RightTee);
	|
	|            // and the label text
	|            if (!string.IsNullOrWhiteSpace(text))
	|            {
	|                graph.Move(Math.Max(0, x - labelThickness), screenPosition);
	|                Application.Driver.AddStr(text);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the X screen position of the origin (typically 0,0) of graph space.
	|        /// Return value is bounded by the screen i.e. the axis is always rendered even
	|        /// if the origin is offscreen.
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        public int GetAxisXPosition(GraphView graph)
	|        {
	|            // find the origin of the graph in screen space (this allows for 'crosshair' style
	|            // graphs where positive and negative numbers visible
	|            var origin = graph.GraphSpaceToScreen(new PointF(0, 0));
	|
	|            // float the Y axis so that it accurately represents the origin of the graph
	|            // but anchor it to left/right if the origin is offscreen
	|            return Math.Min(Math.Max((int)graph.MarginLeft, origin.X), graph.Bounds.Width - 1);
	|        }
	|    }
	|
	|
	|    /// <summary>
	|    /// A location on an axis of a <see cref=""GraphView""/> that may
	|    /// or may not have a label associated with it
	|    /// </summary>
	|    public class AxisIncrementToRender
	|    {
	|
	|        /// <summary>
	|        /// Direction of the parent axis
	|        /// </summary>
	|        public Orientation Orientation { get; }
	|
	|        /// <summary>
	|        /// The screen location (X or Y depending on <see cref=""Orientation""/>) that the
	|        /// increment will be rendered at
	|        /// </summary>
	|        public int ScreenLocation { get; }
	|
	|        /// <summary>
	|        /// The value at this position on the axis in graph space
	|        /// </summary>
	|        public float Value { get; }
	|
	|        private string _text = """";
	|
	|        /// <summary>
	|        /// The text (if any) that should be displayed at this axis increment
	|        /// </summary>
	|        /// <value></value>
	|        internal string Text
	|        {
	|            get => _text;
	|            set { _text = value ?? """"; }
	|        }
	|
	|        /// <summary>
	|        /// Describe a new section of an axis that requires an axis increment
	|        /// symbol and/or label
	|        /// </summary>
	|        /// <param name=""orientation""></param>
	|        /// <param name=""screen""></param>
	|        /// <param name=""value""></param>
	|        public AxisIncrementToRender(Orientation orientation, int screen, float value)
	|        {
	|            Orientation = orientation;
	|            ScreenLocation = screen;
	|            Value = value;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Delegate for custom formatting of axis labels.  Determines what should be displayed at a given label
	|    /// </summary>
	|    /// <param name=""toRender"">The axis increment to which the label is attached</param>
	|    /// <returns></returns>
	|    public delegate string LabelGetterDelegate(AxisIncrementToRender toRender);
	|    //=======================================================================
	|    /// <summary>
	|    /// Describes how to render a single row/column of a <see cref=""GraphView""/> based
	|    /// on the value(s) in <see cref=""ISeries""/> at that location
	|    /// </summary>
	|    public class GraphCellToRender
	|    {
	|
	|        /// <summary>
	|        /// The character to render in the console
	|        /// </summary>
	|        public Rune Rune { get; set; }
	|
	|        /// <summary>
	|        /// Optional color to render the <see cref=""Rune""/> with
	|        /// </summary>
	|        public Attribute? Color { get; set; }
	|
	|        /// <summary>
	|        /// Creates instance and sets <see cref=""Rune""/> with default graph coloring
	|        /// </summary>
	|        /// <param name=""rune""></param>
	|        public GraphCellToRender(Rune rune)
	|        {
	|            Rune = rune;
	|        }
	|        /// <summary>
	|        /// Creates instance and sets <see cref=""Rune""/> with custom graph coloring
	|        /// </summary>
	|        /// <param name=""rune""></param>
	|        /// <param name=""color""></param>
	|        public GraphCellToRender(Rune rune, Attribute color) : this(rune)
	|        {
	|            Color = color;
	|        }
	|        /// <summary>
	|        /// Creates instance and sets <see cref=""Rune""/> and <see cref=""Color""/> (or default if null)
	|        /// </summary>
	|        public GraphCellToRender(Rune rune, Attribute? color) : this(rune)
	|        {
	|            Color = color;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Facilitates box drawing and line intersection detection
	|    /// and rendering.  Does not support diagonal lines.
	|    /// </summary>
	|    public class LineCanvas
	|    {
	|
	|
	|        private List<StraightLine> lines = new List<StraightLine>();
	|
	|        Dictionary<IntersectionRuneType, IntersectionRuneResolver> runeResolvers = new Dictionary<IntersectionRuneType, IntersectionRuneResolver> {
	|            {IntersectionRuneType.ULCorner,new ULIntersectionRuneResolver()},
	|            {IntersectionRuneType.URCorner,new URIntersectionRuneResolver()},
	|            {IntersectionRuneType.LLCorner,new LLIntersectionRuneResolver()},
	|            {IntersectionRuneType.LRCorner,new LRIntersectionRuneResolver()},
	|
	|            {IntersectionRuneType.TopTee,new TopTeeIntersectionRuneResolver()},
	|            {IntersectionRuneType.LeftTee,new LeftTeeIntersectionRuneResolver()},
	|            {IntersectionRuneType.RightTee,new RightTeeIntersectionRuneResolver()},
	|            {IntersectionRuneType.BottomTee,new BottomTeeIntersectionRuneResolver()},
	|
	|
	|            {IntersectionRuneType.Crosshair,new CrosshairIntersectionRuneResolver()},
	|			// TODO: Add other resolvers
	|		};
	|
	|        /// <summary>
	|        /// Add a new line to the canvas starting at <paramref name=""from""/>.
	|        /// Use positive <paramref name=""length""/> for Right and negative for Left
	|        /// when <see cref=""Orientation""/> is <see cref=""Orientation.Horizontal""/>.
	|        /// Use positive <paramref name=""length""/> for Down and negative for Up
	|        /// when <see cref=""Orientation""/> is <see cref=""Orientation.Vertical""/>.
	|        /// </summary>
	|        /// <param name=""from"">Starting point.</param>
	|        /// <param name=""length"">Length of line.  0 for a dot.  
	|        /// Positive for Down/Right.  Negative for Up/Left.</param>
	|        /// <param name=""orientation"">Direction of the line.</param>
	|        /// <param name=""style"">The style of line to use</param>
	|        public void AddLine(Point from, int length, Orientation orientation, BorderStyle style)
	|        {
	|            lines.Add(new StraightLine(from, length, orientation, style));
	|        }
	|        /// <summary>
	|        /// Evaluate all currently defined lines that lie within 
	|        /// <paramref name=""inArea""/> and map that
	|        /// shows what characters (if any) should be rendered at each
	|        /// point so that all lines connect up correctly with appropriate
	|        /// intersection symbols.
	|        /// <returns></returns>
	|        /// </summary>
	|        /// <param name=""inArea""></param>
	|        /// <returns>Mapping of all the points within <paramref name=""inArea""/> to
	|        /// line or intersection runes which should be drawn there.</returns>
	|        public Dictionary<Point, Rune> GenerateImage(Rect inArea)
	|        {
	|            var map = new Dictionary<Point, Rune>();
	|
	|            // walk through each pixel of the bitmap
	|            for (int y = inArea.Y; y < inArea.Height; y++)
	|            {
	|                for (int x = inArea.X; x < inArea.Width; x++)
	|                {
	|
	|                    var intersects = lines
	|                        .Select(l => l.Intersects(x, y))
	|                        .Where(i => i != null)
	|                        .ToArray();
	|
	|                    // TODO: use Driver and LineStyle to map
	|                    var rune = GetRuneForIntersects(Application.Driver, intersects);
	|
	|                    if (rune != null)
	|                    {
	|                        map.Add(new Point(x, y), rune.Value);
	|                    }
	|                }
	|            }
	|
	|            return map;
	|        }
	|
	|        private abstract class IntersectionRuneResolver
	|        {
	|            readonly Rune round;
	|            readonly Rune doubleH;
	|            readonly Rune doubleV;
	|            readonly Rune doubleBoth;
	|            readonly Rune normal;
	|
	|            public IntersectionRuneResolver(Rune round, Rune doubleH, Rune doubleV, Rune doubleBoth, Rune normal)
	|            {
	|                this.round = round;
	|                this.doubleH = doubleH;
	|                this.doubleV = doubleV;
	|                this.doubleBoth = doubleBoth;
	|                this.normal = normal;
	|            }
	|
	|            public Rune? GetRuneForIntersects(ConsoleDriver driver, IntersectionDefinition[] intersects)
	|            {
	|                var useRounded = intersects.Any(i => i.Line.Style == BorderStyle.Rounded && i.Line.Length != 0);
	|
	|                bool doubleHorizontal = intersects.Any(l => l.Line.Orientation == Orientation.Horizontal && l.Line.Style == BorderStyle.Double);
	|                bool doubleVertical = intersects.Any(l => l.Line.Orientation == Orientation.Vertical && l.Line.Style == BorderStyle.Double);
	|
	|
	|                if (doubleHorizontal)
	|                {
	|                    return doubleVertical ? doubleBoth : doubleH;
	|                }
	|
	|                if (doubleVertical)
	|                {
	|                    return doubleV;
	|                }
	|
	|                return useRounded ? round : normal;
	|            }
	|        }
	|
	|        private class ULIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|            public ULIntersectionRuneResolver() :
	|                base('╭', '╒', '╓', '╔', '┌')
	|            {
	|
	|            }
	|        }
	|        private class URIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|
	|            public URIntersectionRuneResolver() :
	|                base('╮', '╕', '╖', '╗', '┐')
	|            {
	|
	|            }
	|        }
	|        private class LLIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|
	|            public LLIntersectionRuneResolver() :
	|                base('╰', '╘', '╙', '╚', '└')
	|            {
	|
	|            }
	|        }
	|        private class LRIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|            public LRIntersectionRuneResolver() :
	|                base('╯', '╛', '╜', '╝', '┘')
	|            {
	|
	|            }
	|        }
	|
	|        private class TopTeeIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|            public TopTeeIntersectionRuneResolver() :
	|                base('┬', '╤', '╥', '╦', '┬')
	|            {
	|
	|            }
	|        }
	|        private class LeftTeeIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|            public LeftTeeIntersectionRuneResolver() :
	|                base('├', '╞', '╟', '╠', '├')
	|            {
	|
	|            }
	|        }
	|        private class RightTeeIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|            public RightTeeIntersectionRuneResolver() :
	|                base('┤', '╡', '╢', '╣', '┤')
	|            {
	|
	|            }
	|        }
	|        private class BottomTeeIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|            public BottomTeeIntersectionRuneResolver() :
	|                base('┴', '╧', '╨', '╩', '┴')
	|            {
	|
	|            }
	|        }
	|        private class CrosshairIntersectionRuneResolver : IntersectionRuneResolver
	|        {
	|            public CrosshairIntersectionRuneResolver() :
	|                base('┼', '╪', '╫', '╬', '┼')
	|            {
	|
	|            }
	|        }
	|
	|        private Rune? GetRuneForIntersects(ConsoleDriver driver, IntersectionDefinition[] intersects)
	|        {
	|            if (!intersects.Any())
	|                return null;
	|
	|            var runeType = GetRuneTypeForIntersects(intersects);
	|
	|            if (runeResolvers.ContainsKey(runeType))
	|            {
	|                return runeResolvers[runeType].GetRuneForIntersects(driver, intersects);
	|            }
	|
	|            // TODO: Remove these two once we have all of the below ported to IntersectionRuneResolvers
	|            var useDouble = intersects.Any(i => i.Line.Style == BorderStyle.Double && i.Line.Length != 0);
	|            var useRounded = intersects.Any(i => i.Line.Style == BorderStyle.Rounded && i.Line.Length != 0);
	|
	|            // TODO: maybe make these resolvers to for simplicity?
	|            // or for dotted lines later on or that kind of thing?
	|            switch (runeType)
	|            {
	|                case IntersectionRuneType.None:
	|                    return null;
	|                case IntersectionRuneType.Dot:
	|                    return (Rune)'.';
	|                case IntersectionRuneType.HLine:
	|                    return useDouble ? driver.HDLine : driver.HLine;
	|                case IntersectionRuneType.VLine:
	|                    return useDouble ? driver.VDLine : driver.VLine;
	|                default: throw new Exception(""Could not find resolver or switch case for "" + nameof(runeType) + "":"" + runeType);
	|            }
	|        }
	|
	|
	|        private IntersectionRuneType GetRuneTypeForIntersects(IntersectionDefinition[] intersects)
	|        {
	|            if (intersects.All(i => i.Line.Length == 0))
	|            {
	|                return IntersectionRuneType.Dot;
	|            }
	|
	|            // ignore dots
	|            intersects = intersects.Where(i => i.Type != IntersectionType.Dot).ToArray();
	|
	|            var set = new HashSet<IntersectionType>(intersects.Select(i => i.Type));
	|
	|            #region Crosshair Conditions
	|            if (Has(set,
	|                IntersectionType.PassOverHorizontal,
	|                IntersectionType.PassOverVertical
	|                ))
	|            {
	|                return IntersectionRuneType.Crosshair;
	|            }
	|
	|            if (Has(set,
	|                IntersectionType.PassOverVertical,
	|                IntersectionType.StartLeft,
	|                IntersectionType.StartRight
	|                ))
	|            {
	|                return IntersectionRuneType.Crosshair;
	|            }
	|
	|            if (Has(set,
	|                IntersectionType.PassOverHorizontal,
	|                IntersectionType.StartUp,
	|                IntersectionType.StartDown
	|                ))
	|            {
	|                return IntersectionRuneType.Crosshair;
	|            }
	|
	|
	|            if (Has(set,
	|                IntersectionType.StartLeft,
	|                IntersectionType.StartRight,
	|                IntersectionType.StartUp,
	|                IntersectionType.StartDown))
	|            {
	|                return IntersectionRuneType.Crosshair;
	|            }
	|            #endregion
	|
	|
	|            #region Corner Conditions
	|            if (Exactly(set,
	|                IntersectionType.StartRight,
	|                IntersectionType.StartDown))
	|            {
	|                return IntersectionRuneType.ULCorner;
	|            }
	|
	|            if (Exactly(set,
	|                IntersectionType.StartLeft,
	|                IntersectionType.StartDown))
	|            {
	|                return IntersectionRuneType.URCorner;
	|            }
	|
	|            if (Exactly(set,
	|                IntersectionType.StartUp,
	|                IntersectionType.StartLeft))
	|            {
	|                return IntersectionRuneType.LRCorner;
	|            }
	|
	|            if (Exactly(set,
	|                IntersectionType.StartUp,
	|                IntersectionType.StartRight))
	|            {
	|                return IntersectionRuneType.LLCorner;
	|            }
	|            #endregion Corner Conditions
	|
	|            #region T Conditions
	|            if (Has(set,
	|                IntersectionType.PassOverHorizontal,
	|                IntersectionType.StartDown))
	|            {
	|                return IntersectionRuneType.TopTee;
	|            }
	|            if (Has(set,
	|                IntersectionType.StartRight,
	|                IntersectionType.StartLeft,
	|                IntersectionType.StartDown))
	|            {
	|                return IntersectionRuneType.TopTee;
	|            }
	|
	|            if (Has(set,
	|                IntersectionType.PassOverHorizontal,
	|                IntersectionType.StartUp))
	|            {
	|                return IntersectionRuneType.BottomTee;
	|            }
	|            if (Has(set,
	|                IntersectionType.StartRight,
	|                IntersectionType.StartLeft,
	|                IntersectionType.StartUp))
	|            {
	|                return IntersectionRuneType.BottomTee;
	|            }
	|
	|
	|            if (Has(set,
	|                IntersectionType.PassOverVertical,
	|                IntersectionType.StartRight))
	|            {
	|                return IntersectionRuneType.LeftTee;
	|            }
	|            if (Has(set,
	|                IntersectionType.StartRight,
	|                IntersectionType.StartDown,
	|                IntersectionType.StartUp))
	|            {
	|                return IntersectionRuneType.LeftTee;
	|            }
	|
	|
	|            if (Has(set,
	|                IntersectionType.PassOverVertical,
	|                IntersectionType.StartLeft))
	|            {
	|                return IntersectionRuneType.RightTee;
	|            }
	|            if (Has(set,
	|                IntersectionType.StartLeft,
	|                IntersectionType.StartDown,
	|                IntersectionType.StartUp))
	|            {
	|                return IntersectionRuneType.RightTee;
	|            }
	|            #endregion
	|
	|            if (All(intersects, Orientation.Horizontal))
	|            {
	|                return IntersectionRuneType.HLine;
	|            }
	|
	|            if (All(intersects, Orientation.Vertical))
	|            {
	|                return IntersectionRuneType.VLine;
	|            }
	|
	|            return IntersectionRuneType.Dot;
	|        }
	|
	|        private bool All(IntersectionDefinition[] intersects, Orientation orientation)
	|        {
	|            return intersects.All(i => i.Line.Orientation == orientation);
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the <paramref name=""intersects""/> collection has all the <paramref name=""types""/>
	|        /// specified (i.e. AND).
	|        /// </summary>
	|        /// <param name=""intersects""></param>
	|        /// <param name=""types""></param>
	|        /// <returns></returns>
	|        private bool Has(HashSet<IntersectionType> intersects, params IntersectionType[] types)
	|        {
	|            return types.All(t => intersects.Contains(t));
	|        }
	|
	|        /// <summary>
	|        /// Returns true if all requested <paramref name=""types""/> appear in <paramref name=""intersects""/>
	|        /// and there are no additional <see cref=""IntersectionRuneType""/>
	|        /// </summary>
	|        /// <param name=""intersects""></param>
	|        /// <param name=""types""></param>
	|        /// <returns></returns>
	|        private bool Exactly(HashSet<IntersectionType> intersects, params IntersectionType[] types)
	|        {
	|            return intersects.SetEquals(types);
	|        }
	|
	|        class IntersectionDefinition
	|        {
	|            /// <summary>
	|            /// The point at which the intersection happens
	|            /// </summary>
	|            public Point Point { get; }
	|
	|            /// <summary>
	|            /// Defines how <see cref=""Line""/> position relates
	|            /// to <see cref=""Point""/>.
	|            /// </summary>
	|            public IntersectionType Type { get; }
	|
	|            /// <summary>
	|            /// The line that intersects <see cref=""Point""/>
	|            /// </summary>
	|            public StraightLine Line { get; }
	|
	|            public IntersectionDefinition(Point point, IntersectionType type, StraightLine line)
	|            {
	|                Point = point;
	|                Type = type;
	|                Line = line;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The type of Rune that we will use before considering
	|        /// double width, curved borders etc
	|        /// </summary>
	|        enum IntersectionRuneType
	|        {
	|            None,
	|            Dot,
	|            ULCorner,
	|            URCorner,
	|            LLCorner,
	|            LRCorner,
	|            TopTee,
	|            BottomTee,
	|            RightTee,
	|            LeftTee,
	|            Crosshair,
	|            HLine,
	|            VLine,
	|        }
	|
	|        enum IntersectionType
	|        {
	|            /// <summary>
	|            /// There is no intersection
	|            /// </summary>
	|            None,
	|
	|            /// <summary>
	|            ///  A line passes directly over this point traveling along
	|            ///  the horizontal axis
	|            /// </summary>
	|            PassOverHorizontal,
	|
	|            /// <summary>
	|            ///  A line passes directly over this point traveling along
	|            ///  the vertical axis
	|            /// </summary>
	|            PassOverVertical,
	|
	|            /// <summary>
	|            /// A line starts at this point and is traveling up
	|            /// </summary>
	|            StartUp,
	|
	|            /// <summary>
	|            /// A line starts at this point and is traveling right
	|            /// </summary>
	|            StartRight,
	|
	|            /// <summary>
	|            /// A line starts at this point and is traveling down
	|            /// </summary>
	|            StartDown,
	|
	|            /// <summary>
	|            /// A line starts at this point and is traveling left
	|            /// </summary>
	|            StartLeft,
	|
	|            /// <summary>
	|            /// A line exists at this point who has 0 length
	|            /// </summary>
	|            Dot
	|        }
	|
	|        class StraightLine
	|        {
	|            public Point Start { get; }
	|            public int Length { get; }
	|            public Orientation Orientation { get; }
	|            public BorderStyle Style { get; }
	|
	|            public StraightLine(Point start, int length, Orientation orientation, BorderStyle style)
	|            {
	|                this.Start = start;
	|                this.Length = length;
	|                this.Orientation = orientation;
	|                this.Style = style;
	|            }
	|
	|            internal IntersectionDefinition Intersects(int x, int y)
	|            {
	|                if (IsDot())
	|                {
	|                    if (StartsAt(x, y))
	|                    {
	|                        return new IntersectionDefinition(Start, IntersectionType.Dot, this);
	|                    }
	|                    else
	|                    {
	|                        return null;
	|                    }
	|                }
	|
	|                switch (Orientation)
	|                {
	|                    case Orientation.Horizontal: return IntersectsHorizontally(x, y);
	|                    case Orientation.Vertical: return IntersectsVertically(x, y);
	|                    default: throw new ArgumentOutOfRangeException(nameof(Orientation));
	|                }
	|
	|            }
	|
	|            private IntersectionDefinition IntersectsHorizontally(int x, int y)
	|            {
	|                if (Start.Y != y)
	|                {
	|                    return null;
	|                }
	|                else
	|                {
	|                    if (StartsAt(x, y))
	|                    {
	|
	|                        return new IntersectionDefinition(
	|                            Start,
	|                            Length < 0 ? IntersectionType.StartLeft : IntersectionType.StartRight,
	|                            this
	|                            );
	|
	|                    }
	|
	|                    if (EndsAt(x, y))
	|                    {
	|
	|                        return new IntersectionDefinition(
	|                            Start,
	|                            Length < 0 ? IntersectionType.StartRight : IntersectionType.StartLeft,
	|                            this
	|                            );
	|
	|                    }
	|                    else
	|                    {
	|                        var xmin = Math.Min(Start.X, Start.X + Length);
	|                        var xmax = Math.Max(Start.X, Start.X + Length);
	|
	|                        if (xmin < x && xmax > x)
	|                        {
	|                            return new IntersectionDefinition(
	|                            new Point(x, y),
	|                            IntersectionType.PassOverHorizontal,
	|                            this
	|                            );
	|                        }
	|                    }
	|
	|                    return null;
	|                }
	|            }
	|
	|            private IntersectionDefinition IntersectsVertically(int x, int y)
	|            {
	|                if (Start.X != x)
	|                {
	|                    return null;
	|                }
	|                else
	|                {
	|                    if (StartsAt(x, y))
	|                    {
	|
	|                        return new IntersectionDefinition(
	|                            Start,
	|                            Length < 0 ? IntersectionType.StartUp : IntersectionType.StartDown,
	|                            this
	|                            );
	|
	|                    }
	|
	|                    if (EndsAt(x, y))
	|                    {
	|
	|                        return new IntersectionDefinition(
	|                            Start,
	|                            Length < 0 ? IntersectionType.StartDown : IntersectionType.StartUp,
	|                            this
	|                            );
	|
	|                    }
	|                    else
	|                    {
	|                        var ymin = Math.Min(Start.Y, Start.Y + Length);
	|                        var ymax = Math.Max(Start.Y, Start.Y + Length);
	|
	|                        if (ymin < y && ymax > y)
	|                        {
	|                            return new IntersectionDefinition(
	|                            new Point(x, y),
	|                            IntersectionType.PassOverVertical,
	|                            this
	|                            );
	|                        }
	|                    }
	|
	|                    return null;
	|                }
	|            }
	|
	|            private bool EndsAt(int x, int y)
	|            {
	|                if (Orientation == Orientation.Horizontal)
	|                {
	|                    return Start.X + Length == x && Start.Y == y;
	|                }
	|
	|                return Start.X == x && Start.Y + Length == y;
	|            }
	|
	|            private bool StartsAt(int x, int y)
	|            {
	|                return Start.X == x && Start.Y == y;
	|            }
	|
	|            private bool IsDot()
	|            {
	|                return Length == 0;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Direction of an element (horizontal or vertical)
	|    /// </summary>
	|    public enum Orientation
	|    {
	|
	|        /// <summary>
	|        /// Left to right 
	|        /// </summary>
	|        Horizontal,
	|
	|        /// <summary>
	|        /// Bottom to top
	|        /// </summary>
	|        Vertical
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Describes a series of data that can be rendered into a <see cref=""GraphView""/>>
	|    /// </summary>
	|    public interface ISeries
	|    {
	|
	|        /// <summary>
	|        /// Draws the <paramref name=""graphBounds""/> section of a series into the
	|        /// <paramref name=""graph""/> view <paramref name=""drawBounds""/>
	|        /// </summary>
	|        /// <param name=""graph"">Graph series is to be drawn onto</param>
	|        /// <param name=""drawBounds"">Visible area of the graph in Console Screen units (excluding margins)</param>
	|        /// <param name=""graphBounds"">Visible area of the graph in Graph space units</param>
	|        void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds);
	|    }
	|
	|
	|    /// <summary>
	|    /// Series composed of any number of discrete data points 
	|    /// </summary>
	|    public class ScatterSeries : ISeries
	|    {
	|        /// <summary>
	|        /// Collection of each discrete point in the series
	|        /// </summary>
	|        /// <returns></returns>
	|        public List<PointF> Points { get; set; } = new List<PointF>();
	|
	|        /// <summary>
	|        /// The color and character that will be rendered in the console
	|        /// when there are point(s) in the corresponding graph space.
	|        /// Defaults to uncolored 'x'
	|        /// </summary>
	|        public GraphCellToRender Fill { get; set; } = new GraphCellToRender('x');
	|
	|        /// <summary>
	|        /// Draws all points directly onto the graph
	|        /// </summary>
	|        public void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds)
	|        {
	|            if (Fill.Color.HasValue)
	|            {
	|                Application.Driver.SetAttribute(Fill.Color.Value);
	|            }
	|
	|            foreach (var p in Points.Where(p => graphBounds.Contains(p)))
	|            {
	|
	|                var screenPoint = graph.GraphSpaceToScreen(p);
	|                graph.AddRune(screenPoint.X, screenPoint.Y, Fill.Rune);
	|            }
	|
	|        }
	|
	|    }
	|
	|
	|    /// <summary>
	|    /// Collection of <see cref=""BarSeries""/> in which bars are clustered by category
	|    /// </summary>
	|    public class MultiBarSeries : ISeries
	|    {
	|
	|        BarSeries[] subSeries;
	|
	|        /// <summary>
	|        /// Sub collections.  Each series contains the bars for a different category.  Thus 
	|        /// SubSeries[0].Bars[0] is the first bar on the axis and SubSeries[1].Bars[0] is the
	|        /// second etc
	|        /// </summary>
	|        public IReadOnlyCollection<BarSeries> SubSeries { get => new ReadOnlyCollection<BarSeries>(subSeries); }
	|
	|        /// <summary>
	|        /// The number of units of graph space between bars.  Should be 
	|        /// less than <see cref=""BarSeries.BarEvery""/>
	|        /// </summary>
	|        public float Spacing { get; }
	|
	|        /// <summary>
	|        /// Creates a new series of clustered bars.
	|        /// </summary>
	|        /// <param name=""numberOfBarsPerCategory"">Each category has this many bars</param>
	|        /// <param name=""barsEvery"">How far appart to put each category (in graph space)</param>
	|        /// <param name=""spacing"">How much spacing between bars in a category (should be less than <paramref name=""barsEvery""/>/<paramref name=""numberOfBarsPerCategory""/>)</param>
	|        /// <param name=""colors"">Array of colors that define bar color in each category.  Length must match <paramref name=""numberOfBarsPerCategory""/></param>
	|        public MultiBarSeries(int numberOfBarsPerCategory, float barsEvery, float spacing, Attribute[] colors = null)
	|        {
	|            subSeries = new BarSeries[numberOfBarsPerCategory];
	|
	|            if (colors != null && colors.Length != numberOfBarsPerCategory)
	|            {
	|                throw new ArgumentException(""Number of colors must match the number of bars"", nameof(numberOfBarsPerCategory));
	|            }
	|
	|
	|            for (int i = 0; i < numberOfBarsPerCategory; i++)
	|            {
	|                subSeries[i] = new BarSeries();
	|                subSeries[i].BarEvery = barsEvery;
	|                subSeries[i].Offset = i * spacing;
	|
	|                // Only draw labels for the first bar in each category
	|                subSeries[i].DrawLabels = i == 0;
	|
	|                if (colors != null)
	|                {
	|                    subSeries[i].OverrideBarColor = colors[i];
	|                }
	|            }
	|            Spacing = spacing;
	|        }
	|
	|        /// <summary>
	|        /// Adds a new cluster of bars
	|        /// </summary>
	|        /// <param name=""label""></param>
	|        /// <param name=""fill""></param>
	|        /// <param name=""values"">Values for each bar in category, must match the number of bars per category</param>
	|        public void AddBars(string label, Rune fill, params float[] values)
	|        {
	|            if (values.Length != subSeries.Length)
	|            {
	|                throw new ArgumentException(""Number of values must match the number of bars per category"", nameof(values));
	|            }
	|
	|            for (int i = 0; i < values.Length; i++)
	|            {
	|                subSeries[i].Bars.Add(new BarSeries.Bar(label,
	|                    new GraphCellToRender(fill), values[i]));
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Draws all <see cref=""SubSeries""/>
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""drawBounds""></param>
	|        /// <param name=""graphBounds""></param>
	|        public void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds)
	|        {
	|            foreach (var bar in subSeries)
	|            {
	|                bar.DrawSeries(graph, drawBounds, graphBounds);
	|            }
	|
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Series of bars positioned at regular intervals
	|    /// </summary>
	|    public class BarSeries : ISeries
	|    {
	|
	|        /// <summary>
	|        /// Ordered collection of graph bars to position along axis
	|        /// </summary>
	|        public List<Bar> Bars { get; set; } = new List<Bar>();
	|
	|        /// <summary>
	|        /// Determines the spacing of bars along the axis. Defaults to 1 i.e. 
	|        /// every 1 unit of graph space a bar is rendered.  Note that you should
	|        /// also consider <see cref=""GraphView.CellSize""/> when changing this.
	|        /// </summary>
	|        public float BarEvery { get; set; } = 1;
	|
	|        /// <summary>
	|        /// Direction bars protrude from the corresponding axis.
	|        /// Defaults to vertical
	|        /// </summary>
	|        public Orientation Orientation { get; set; } = Orientation.Vertical;
	|
	|        /// <summary>
	|        /// The number of units of graph space along the axis before rendering the first bar
	|        /// (and subsequent bars - see <see cref=""BarEvery""/>).  Defaults to 0
	|        /// </summary>
	|        public float Offset { get; set; } = 0;
	|
	|        /// <summary>
	|        /// Overrides the <see cref=""Bar.Fill""/> with a fixed color
	|        /// </summary>
	|        public Attribute? OverrideBarColor { get; set; }
	|
	|        /// <summary>
	|        /// True to draw <see cref=""Bar.Text""/> along the axis under the bar.  Defaults
	|        /// to true.
	|        /// </summary>
	|        public bool DrawLabels { get; set; } = true;
	|
	|        /// <summary>
	|        /// Applies any color overriding
	|        /// </summary>
	|        /// <param name=""graphCellToRender""></param>
	|        /// <returns></returns>
	|        protected virtual GraphCellToRender AdjustColor(GraphCellToRender graphCellToRender)
	|        {
	|            if (OverrideBarColor.HasValue)
	|            {
	|                graphCellToRender.Color = OverrideBarColor;
	|            }
	|
	|            return graphCellToRender;
	|        }
	|
	|        /// <summary>
	|        /// Draws bars that are currently in the <paramref name=""drawBounds""/>
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""drawBounds"">Screen area of the graph excluding margins</param>
	|        /// <param name=""graphBounds"">Graph space area that should be drawn into <paramref name=""drawBounds""/></param>
	|        public virtual void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds)
	|        {
	|            for (int i = 0; i < Bars.Count; i++)
	|            {
	|
	|                float xStart = Orientation == Orientation.Horizontal ? 0 : Offset + ((i + 1) * BarEvery);
	|                float yStart = Orientation == Orientation.Horizontal ? Offset + ((i + 1) * BarEvery) : 0;
	|
	|                float endX = Orientation == Orientation.Horizontal ? Bars[i].Value : xStart;
	|                float endY = Orientation == Orientation.Horizontal ? yStart : Bars[i].Value;
	|
	|                // translate to screen positions
	|                var screenStart = graph.GraphSpaceToScreen(new PointF(xStart, yStart));
	|                var screenEnd = graph.GraphSpaceToScreen(new PointF(endX, endY));
	|
	|                // Start the bar from wherever the axis is
	|                if (Orientation == Orientation.Horizontal)
	|                {
	|
	|                    screenStart.X = graph.AxisY.GetAxisXPosition(graph);
	|
	|                    // dont draw bar off the right of the control
	|                    screenEnd.X = Math.Min(graph.Bounds.Width - 1, screenEnd.X);
	|
	|                    // if bar is off the screen
	|                    if (screenStart.Y < 0 || screenStart.Y > drawBounds.Height - graph.MarginBottom)
	|                    {
	|                        continue;
	|                    }
	|                }
	|                else
	|                {
	|
	|                    // Start the axis
	|                    screenStart.Y = graph.AxisX.GetAxisYPosition(graph);
	|
	|                    // dont draw bar up above top of control
	|                    screenEnd.Y = Math.Max(0, screenEnd.Y);
	|
	|                    // if bar is off the screen
	|                    if (screenStart.X < graph.MarginLeft || screenStart.X > graph.MarginLeft + drawBounds.Width - 1)
	|                    {
	|                        continue;
	|                    }
	|                }
	|
	|                // draw the bar unless it has no height
	|                if (Bars[i].Value != 0)
	|                {
	|                    DrawBarLine(graph, screenStart, screenEnd, Bars[i]);
	|                }
	|
	|                // If we are drawing labels and the bar has one
	|                if (DrawLabels && !string.IsNullOrWhiteSpace(Bars[i].Text))
	|                {
	|
	|                    // Add the label to the relevant axis
	|                    if (Orientation == Orientation.Horizontal)
	|                    {
	|
	|                        graph.AxisY.DrawAxisLabel(graph, screenStart.Y, Bars[i].Text);
	|                    }
	|                    else if (Orientation == Orientation.Vertical)
	|                    {
	|
	|                        graph.AxisX.DrawAxisLabel(graph, screenStart.X, Bars[i].Text);
	|                    }
	|                }
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Override to do custom drawing of the bar e.g. to apply varying color or changing the fill
	|        /// symbol mid bar.
	|        /// </summary>
	|        /// <param name=""graph""></param>
	|        /// <param name=""start"">Screen position of the start of the bar</param>
	|        /// <param name=""end"">Screen position of the end of the bar</param>
	|        /// <param name=""beingDrawn"">The Bar that occupies this space and is being drawn</param>
	|        protected virtual void DrawBarLine(GraphView graph, Point start, Point end, Bar beingDrawn)
	|        {
	|            var adjusted = AdjustColor(beingDrawn.Fill);
	|
	|            if (adjusted.Color.HasValue)
	|            {
	|                Application.Driver.SetAttribute(adjusted.Color.Value);
	|            }
	|
	|            graph.DrawLine(start, end, adjusted.Rune);
	|
	|            graph.SetDriverColorToGraphColor();
	|        }
	|
	|        /// <summary>
	|        /// A single bar in a <see cref=""BarSeries""/>
	|        /// </summary>
	|        public class Bar
	|        {
	|
	|            /// <summary>
	|            /// Optional text that describes the bar.  This will be rendered on the corresponding
	|            /// <see cref=""Axis""/> unless <see cref=""DrawLabels""/> is false
	|            /// </summary>
	|            public string Text { get; set; }
	|
	|            /// <summary>
	|            /// The color and character that will be rendered in the console
	|            /// when the bar extends over it
	|            /// </summary>
	|            public GraphCellToRender Fill { get; set; }
	|
	|            /// <summary>
	|            /// The value in graph space X/Y (depending on <see cref=""Orientation""/>) to which the bar extends.
	|            /// </summary>
	|            public float Value { get; }
	|
	|            /// <summary>
	|            /// Creates a new instance of a single bar rendered in the given <paramref name=""fill""/> that extends
	|            /// out <paramref name=""value""/> graph space units in the default <see cref=""Orientation""/>
	|            /// </summary>
	|            /// <param name=""text""></param>
	|            /// <param name=""fill""></param>
	|            /// <param name=""value""></param>
	|            public Bar(string text, GraphCellToRender fill, float value)
	|            {
	|                Text = text;
	|                Fill = fill;
	|                Value = value;
	|            }
	|        }
	|    }
	|}//namespace Terminal.Gui.Graphs
	|//=======================================================================
	|//
	|// Core.cs: The core engine for gui.cs
	|//
	|// Authors:
	|//   Miguel de Icaza (miguel@gnome.org)
	|//
	|// Pending:
	|//   - Check for NeedDisplay on the hierarchy and repaint
	|//   - Layout support
	|//   - ""Colors"" type or ""Attributes"" type?
	|//   - What to surface as ""BackgroundCOlor"" when clearing a window, an attribute or colors?
	|//
	|// Optimizations
	|//   - Add rendering limitation to the exposed area
	|
	|namespace Terminal.Gui
	|{
	|
	|    /// <summary>
	|    /// A static, singleton class providing the main application driver for Terminal.Gui apps. 
	|    /// </summary>
	|    /// <example>
	|    /// <code>
	|    /// // A simple Terminal.Gui app that creates a window with a frame and title with 
	|    /// // 5 rows/columns of padding.
	|    /// Application.Init();
	|    /// var win = new Window (""Hello World - CTRL-Q to quit"") {
	|    ///     X = 5,
	|    ///     Y = 5,
	|    ///     Width = Dim.Fill (5),
	|    ///     Height = Dim.Fill (5)
	|    /// };
	|    /// Application.Top.Add(win);
	|    /// Application.Run();
	|    /// Application.Shutdown();
	|    /// </code>
	|    /// </example>
	|    /// <remarks>
	|    ///   <para>
	|    ///     Creates a instance of <see cref=""Terminal.Gui.MainLoop""/> to process input events, handle timers and
	|    ///     other sources of data. It is accessible via the <see cref=""MainLoop""/> property.
	|    ///   </para>
	|    ///   <para>
	|    ///     You can hook up to the <see cref=""Iteration""/> event to have your method
	|    ///     invoked on each iteration of the <see cref=""Terminal.Gui.MainLoop""/>.
	|    ///   </para>
	|    ///   <para>
	|    ///     When invoked sets the SynchronizationContext to one that is tied
	|    ///     to the MainLoop, allowing user code to use async/await.
	|    ///   </para>
	|    /// </remarks>
	|    public static class Application
	|    {
	|        static readonly Stack<Toplevel> toplevels = new Stack<Toplevel>();
	|
	|        /// <summary>
	|        /// The current <see cref=""ConsoleDriver""/> in use.
	|        /// </summary>
	|        public static ConsoleDriver Driver;
	|
	|        /// <summary>
	|        /// Gets all the Mdi childes which represent all the not modal <see cref=""Toplevel""/> from the <see cref=""MdiTop""/>.
	|        /// </summary>
	|        public static List<Toplevel> MdiChildes
	|        {
	|            get
	|            {
	|                List<Toplevel> mdiChildes = new List<Toplevel>();
	|                if (MdiTop != null)
	|                {
	|                    foreach (var top in toplevels)
	|                    {
	|                        if (top != MdiTop && !top.Modal)
	|                        {
	|                            mdiChildes.Add(top);
	|                        }
	|                    }
	|                }
	|                return mdiChildes;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The <see cref=""Toplevel""/> object used for the application on startup which <see cref=""Toplevel.IsMdiContainer""/> is true.
	|        /// </summary>
	|        public static Toplevel MdiTop
	|        {
	|            get
	|            {
	|                if (Top?.IsMdiContainer == true)
	|                {
	|                    return Top;
	|                }
	|                return null;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The <see cref=""Toplevel""/> object used for the application on startup (<seealso cref=""Application.Top""/>)
	|        /// </summary>
	|        /// <value>The top.</value>
	|        public static Toplevel Top { get; private set; }
	|
	|        /// <summary>
	|        /// The current <see cref=""Toplevel""/> object. This is updated when <see cref=""Application.Run(Func{Exception, bool})""/> enters and leaves to point to the current <see cref=""Toplevel""/> .
	|        /// </summary>
	|        /// <value>The current.</value>
	|        public static Toplevel Current { get; private set; }
	|
	|        /// <summary>
	|        /// The current <see cref=""View""/> object that wants continuous mouse button pressed events.
	|        /// </summary>
	|        public static View WantContinuousButtonPressedView { get; private set; }
	|
	|        /// <summary>
	|        /// The current <see cref=""ConsoleDriver.EnableConsoleScrolling""/> used in the terminal.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        /// If <see langword=""false""/> (the default) the height of the Terminal.Gui application (<see cref=""ConsoleDriver.Rows""/>) 
	|        /// tracks to the height of the visible console view when the console is resized. In this case 
	|        /// scrolling in the console will be disabled and all <see cref=""ConsoleDriver.Rows""/> will remain visible.
	|        /// </para>
	|        /// <para>
	|        /// If <see langword=""true""/> then height of the Terminal.Gui application <see cref=""ConsoleDriver.Rows""/> only tracks 
	|        /// the height of the visible console view when the console is made larger (the application will only grow in height, never shrink). 
	|        /// In this case console scrolling is enabled and the contents (<see cref=""ConsoleDriver.Rows""/> high) will scroll
	|        /// as the console scrolls. 
	|        /// </para>
	|        /// <para>This API is deprecated and has no impact when enabled.</para>
	|        /// <para>This API was previously named 'HeightAsBuffer` but was renamed to make its purpose more clear.</para>
	|        /// </remarks>
	|        [Obsolete(""This API is deprecated and has no impact when enabled."", false)]
	|        public static bool EnableConsoleScrolling { get; set; }
	|
	|        /// <summary>
	|        /// This API is deprecated; use <see cref=""EnableConsoleScrolling""/> instead.
	|        /// </summary>
	|        [Obsolete(""This API is deprecated and has no impact when enabled."", false)]
	|        public static bool HeightAsBuffer { get; set; }
	|
	|        static Key alternateForwardKey = Key.PageDown | Key.CtrlMask;
	|
	|        /// <summary>
	|        /// Alternative key to navigate forwards through views. Ctrl+Tab is the primary key.
	|        /// </summary>
	|        public static Key AlternateForwardKey
	|        {
	|            get => alternateForwardKey;
	|            set
	|            {
	|                if (alternateForwardKey != value)
	|                {
	|                    var oldKey = alternateForwardKey;
	|                    alternateForwardKey = value;
	|                    OnAlternateForwardKeyChanged(oldKey);
	|                }
	|            }
	|        }
	|
	|        static void OnAlternateForwardKeyChanged(Key oldKey)
	|        {
	|            foreach (var top in toplevels.ToArray())
	|            {
	|                top.OnAlternateForwardKeyChanged(oldKey);
	|            }
	|        }
	|
	|        static Key alternateBackwardKey = Key.PageUp | Key.CtrlMask;
	|
	|        /// <summary>
	|        /// Alternative key to navigate backwards through views. Shift+Ctrl+Tab is the primary key.
	|        /// </summary>
	|        public static Key AlternateBackwardKey
	|        {
	|            get => alternateBackwardKey;
	|            set
	|            {
	|                if (alternateBackwardKey != value)
	|                {
	|                    var oldKey = alternateBackwardKey;
	|                    alternateBackwardKey = value;
	|                    OnAlternateBackwardKeyChanged(oldKey);
	|                }
	|            }
	|        }
	|
	|        static void OnAlternateBackwardKeyChanged(Key oldKey)
	|        {
	|            foreach (var top in toplevels.ToArray())
	|            {
	|                top.OnAlternateBackwardKeyChanged(oldKey);
	|            }
	|        }
	|
	|        static Key quitKey = Key.Q | Key.CtrlMask;
	|
	|        /// <summary>
	|        /// Gets or sets the key to quit the application.
	|        /// </summary>
	|        public static Key QuitKey
	|        {
	|            get => quitKey;
	|            set
	|            {
	|                if (quitKey != value)
	|                {
	|                    var oldKey = quitKey;
	|                    quitKey = value;
	|                    OnQuitKeyChanged(oldKey);
	|                }
	|            }
	|        }
	|
	|        private static List<CultureInfo> supportedCultures;
	|
	|        /// <summary>
	|        /// Gets all supported cultures by the application without the invariant language.
	|        /// </summary>
	|        public static List<CultureInfo> SupportedCultures => supportedCultures;
	|
	|        static void OnQuitKeyChanged(Key oldKey)
	|        {
	|            // Duplicate the list so if it changes during enumeration we're safe
	|            foreach (var top in toplevels.ToArray())
	|            {
	|                top.OnQuitKeyChanged(oldKey);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The <see cref=""MainLoop""/>  driver for the application
	|        /// </summary>
	|        /// <value>The main loop.</value>
	|        public static MainLoop MainLoop { get; private set; }
	|
	|        /// <summary>
	|        /// Disable or enable the mouse. The mouse is enabled by default.
	|        /// </summary>
	|        public static bool IsMouseDisabled { get; set; }
	|
	|        /// <summary>
	|        /// Set to true to cause the RunLoop method to exit after the first iterations.
	|        /// Set to false (the default) to cause the RunLoop to continue running until Application.RequestStop() is called.
	|        /// </summary>
	|        public static bool ExitRunLoopAfterFirstIteration { get; set; } = false;
	|
	|        /// <summary>
	|        /// Notify that a new <see cref=""RunState""/> was created (<see cref=""Begin(Toplevel)""/> was called). The token is created in 
	|        /// <see cref=""Begin(Toplevel)""/> and this event will be fired before that function exits.
	|        /// </summary>
	|        /// <remarks>
	|        ///	If <see cref=""ExitRunLoopAfterFirstIteration""/> is <see langword=""true""/> callers to
	|        ///	<see cref=""Begin(Toplevel)""/> must also subscribe to <see cref=""NotifyStopRunState""/>
	|        ///	and manually dispose of the <see cref=""RunState""/> token when the application is done.
	|        /// </remarks>
	|        public static event Action<RunState> NotifyNewRunState;
	|
	|        /// <summary>
	|        /// Notify that a existent <see cref=""RunState""/> is stopping (<see cref=""End(RunState)""/> was called).
	|        /// </summary>
	|        /// <remarks>
	|        ///	If <see cref=""ExitRunLoopAfterFirstIteration""/> is <see langword=""true""/> callers to
	|        ///	<see cref=""Begin(Toplevel)""/> must also subscribe to <see cref=""NotifyStopRunState""/>
	|        ///	and manually dispose of the <see cref=""RunState""/> token when the application is done.
	|        /// </remarks>
	|        public static event Action<Toplevel> NotifyStopRunState;
	|
	|        /// <summary>
	|        ///   This event is raised on each iteration of the <see cref=""MainLoop""/>. 
	|        /// </summary>
	|        /// <remarks>
	|        ///   See also <see cref=""Timeout""/>
	|        /// </remarks>
	|        public static Action Iteration;
	|
	|        /// <summary>
	|        /// Returns a rectangle that is centered in the screen for the provided size.
	|        /// </summary>
	|        /// <returns>The centered rect.</returns>
	|        /// <param name=""size"">Size for the rectangle.</param>
	|        public static Rect MakeCenteredRect(Size size)
	|        {
	|            return new Rect(new Point((Driver.Cols - size.Width) / 2, (Driver.Rows - size.Height) / 2), size);
	|        }
	|
	|        //
	|        // provides the sync context set while executing code in Terminal.Gui, to let
	|        // users use async/await on their code
	|        //
	|        class MainLoopSyncContext : SynchronizationContext
	|        {
	|            readonly MainLoop mainLoop;
	|
	|            public MainLoopSyncContext(MainLoop mainLoop)
	|            {
	|                this.mainLoop = mainLoop;
	|            }
	|
	|            public override SynchronizationContext CreateCopy()
	|            {
	|                return new MainLoopSyncContext(MainLoop);
	|            }
	|
	|            public override void Post(SendOrPostCallback d, object state)
	|            {
	|                mainLoop.AddIdle(() =>
	|                {
	|                    d(state);
	|                    return false;
	|                });
	|                //mainLoop.Driver.Wakeup ();
	|            }
	|
	|            public override void Send(SendOrPostCallback d, object state)
	|            {
	|                if (Thread.CurrentThread.ManagedThreadId == _mainThreadId)
	|                {
	|                    d(state);
	|                }
	|                else
	|                {
	|                    var wasExecuted = false;
	|                    mainLoop.Invoke(() =>
	|                    {
	|                        d(state);
	|                        wasExecuted = true;
	|                    });
	|                    while (!wasExecuted)
	|                    {
	|                        Thread.Sleep(15);
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// If <see langword=""true""/>, forces the use of the System.Console-based (see <see cref=""NetDriver""/>) driver. The default is <see langword=""false""/>.
	|        /// </summary>
	|        public static bool UseSystemConsole { get; set; } = false;
	|
	|        //*master//
	|        //// For Unit testing - ignores UseSystemConsole
	|        //internal static bool ForceFakeConsole;
	|        //master*//
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""Terminal.Gui""/> Application. 
	|        /// </summary>
	|        /// <para>
	|        /// Call this method once per instance (or after <see cref=""Shutdown""/> has been called).
	|        /// </para>
	|        /// <para>
	|        /// This function loads the right <see cref=""ConsoleDriver""/> for the platform, 
	|        /// Creates a <see cref=""Toplevel""/>. and assigns it to <see cref=""Top""/>
	|        /// </para>
	|        /// <para>
	|        /// <see cref=""Shutdown""/> must be called when the application is closing (typically after <see cref=""Run(Func{Exception, bool})""/> has 
	|        /// returned) to ensure resources are cleaned up and terminal settings restored.
	|        /// </para>
	|        /// <para>
	|        /// The <see cref=""Run{T}(Func{Exception, bool}, ConsoleDriver, IMainLoopDriver)""/> function 
	|        /// combines <see cref=""Init(ConsoleDriver, IMainLoopDriver)""/> and <see cref=""Run(Toplevel, Func{Exception, bool})""/>
	|        /// into a single call. An applciation cam use <see cref=""Run{T}(Func{Exception, bool}, ConsoleDriver, IMainLoopDriver)""/> 
	|        /// without explicitly calling <see cref=""Init(ConsoleDriver, IMainLoopDriver)""/>.
	|        /// </para>
	|        /// <param name=""driver"">
	|        /// The <see cref=""ConsoleDriver""/> to use. If not specified the default driver for the
	|        /// platform will be used (see <see cref=""WindowsDriver""/>, <see cref=""CursesDriver""/>, and <see cref=""NetDriver""/>).</param>
	|        /// <param name=""mainLoopDriver"">
	|        /// Specifies the <see cref=""MainLoop""/> to use. 
	|        /// Must not be <see langword=""null""/> if <paramref name=""driver""/> is not <see langword=""null""/>.
	|        /// </param>
	|        public static void Init(ConsoleDriver driver = null, IMainLoopDriver mainLoopDriver = null) => InternalInit(() => Toplevel.Create(), driver, mainLoopDriver);
	|
	|        internal static bool _initialized = false;
	|        internal static int _mainThreadId = -1;
	|
	|        // INTERNAL function for initializing an app with a Toplevel factory object, driver, and mainloop.
	|        //
	|        // Called from:
	|        // 
	|        // Init() - When the user wants to use the default Toplevel. calledViaRunT will be false, causing all state to be reset.
	|        // Run<T>() - When the user wants to use a custom Toplevel. calledViaRunT will be true, enabling Run<T>() to be called without calling Init first.
	|        // Unit Tests - To initialize the app with a custom Toplevel, using the FakeDriver. calledViaRunT will be false, causing all state to be reset.
	|        // 
	|        // calledViaRunT: If false (default) all state will be reset. If true the state will not be reset.
	|        internal static void InternalInit(Func<Toplevel> topLevelFactory, ConsoleDriver driver = null, IMainLoopDriver mainLoopDriver = null, bool calledViaRunT = false)
	|        {
	|            if (_initialized && driver == null) return;
	|
	|            if (_initialized)
	|            {
	|                throw new InvalidOperationException(""Init has already been called and must be bracketed by Shutdown."");
	|            }
	|
	|            // Note in this case, we don't verify the type of the Toplevel created by new T(). 
	|            // Used only for start debugging on Unix.
	|            //#if DEBUG
	|            //			while (!System.Diagnostics.Debugger.IsAttached) {
	|            //				System.Threading.Thread.Sleep (100);
	|            //			}
	|            //			System.Diagnostics.Debugger.Break ();
	|            //#endif
	|
	|            if (!calledViaRunT)
	|            {
	|                // Reset all class variables (Application is a singleton).
	|                ResetState();
	|            }
	|
	|            // For UnitTests
	|            if (driver != null)
	|            {
	|                //if (mainLoopDriver == null) {
	|                //	throw new ArgumentNullException (""InternalInit mainLoopDriver cannot be null if driver is provided."");
	|                //}
	|                //if (!(driver is FakeDriver)) {
	|                //	throw new InvalidOperationException (""InternalInit can only be called with FakeDriver."");
	|                //}
	|                Driver = driver;
	|            }
	|
	|            if (Driver == null)
	|            {
	|                var p = Environment.OSVersion.Platform;
	|                //if (ForceFakeConsole)
	|                //{
	|                //    // For Unit Testing only
	|                //    Driver = new FakeDriver();
	|                //}
	|                //else if (UseSystemConsole)
	|
	|                if (UseSystemConsole)
	|                {
	|                    Driver = new NetDriver();
	|                }
	|                else if (p == PlatformID.Win32NT || p == PlatformID.Win32S || p == PlatformID.Win32Windows)
	|                {
	|                    Driver = new WindowsDriver();
	|                }
	|                else
	|                {
	|                    Driver = new CursesDriver();
	|                }
	|                if (Driver == null)
	|                {
	|                    throw new InvalidOperationException(""Init could not determine the ConsoleDriver to use."");
	|                }
	|            }
	|
	|            if (mainLoopDriver == null)
	|            {
	|                // TODO: Move this logic into ConsoleDriver
	|                if (Driver is FakeDriver)
	|                {
	|                    mainLoopDriver = new FakeMainLoop(Driver);
	|                }
	|                else if (Driver is NetDriver)
	|                {
	|                    mainLoopDriver = new NetMainLoop(Driver);
	|                }
	|                else if (Driver is WindowsDriver)
	|                {
	|                    mainLoopDriver = new WindowsMainLoop(Driver);
	|                }
	|                else if (Driver is CursesDriver)
	|                {
	|                    mainLoopDriver = new UnixMainLoop(Driver);
	|                }
	|                if (mainLoopDriver == null)
	|                {
	|                    throw new InvalidOperationException(""Init could not determine the MainLoopDriver to use."");
	|                }
	|            }
	|
	|            MainLoop = new MainLoop(mainLoopDriver);
	|
	|            try
	|            {
	|                Driver.Init(TerminalResized);
	|            }
	|            catch (InvalidOperationException ex)
	|            {
	|                // This is a case where the driver is unable to initialize the console.
	|                // This can happen if the console is already in use by another process or
	|                // if running in unit tests.
	|                // In this case, we want to throw a more specific exception.
	|                throw new InvalidOperationException(""Unable to initialize the console. This can happen if the console is already in use by another process or in unit tests."", ex);
	|            }
	|
	|            SynchronizationContext.SetSynchronizationContext(new MainLoopSyncContext(MainLoop));
	|
	|            Top = topLevelFactory();
	|            Current = Top;
	|            supportedCultures = GetSupportedCultures();
	|            _mainThreadId = Thread.CurrentThread.ManagedThreadId;
	|            _initialized = true;
	|        }
	|
	|        /// <summary>
	|        /// Captures the execution state for the provided <see cref=""Toplevel""/> view.
	|        /// </summary>
	|        public class RunState : IDisposable
	|        {
	|            /// <summary>
	|            /// Initializes a new <see cref=""RunState""/> class.
	|            /// </summary>
	|            /// <param name=""view""></param>
	|            public RunState(Toplevel view)
	|            {
	|                Toplevel = view;
	|            }
	|            /// <summary>
	|            /// The <see cref=""Toplevel""/> belong to this <see cref=""RunState""/>.
	|            /// </summary>
	|            public Toplevel Toplevel { get; internal set; }
	|
	|#if DEBUG_IDISPOSABLE
	|			/// <summary>
	|			/// For debug purposes to verify objects are being disposed properly
	|			/// </summary>
	|			public bool WasDisposed = false;
	|			/// <summary>
	|			/// For debug purposes to verify objects are being disposed properly
	|			/// </summary>
	|			public int DisposedCount = 0;
	|			/// <summary>
	|			/// For debug purposes
	|			/// </summary>
	|			public static List<RunState> Instances = new List<RunState> ();
	|			/// <summary>
	|			/// For debug purposes
	|			/// </summary>
	|			public RunState ()
	|			{
	|				Instances.Add (this);
	|			}
	|#endif
	|
	|            /// <summary>
	|            /// Releases all resource used by the <see cref=""Application.RunState""/> object.
	|            /// </summary>
	|            /// <remarks>
	|            /// Call <see cref=""Dispose()""/> when you are finished using the <see cref=""Application.RunState""/>. 
	|            /// </remarks>
	|            /// <remarks>
	|            /// <see cref=""Dispose()""/> method leaves the <see cref=""Application.RunState""/> in an unusable state. After
	|            /// calling <see cref=""Dispose()""/>, you must release all references to the
	|            /// <see cref=""Application.RunState""/> so the garbage collector can reclaim the memory that the
	|            /// <see cref=""Application.RunState""/> was occupying.
	|            /// </remarks>
	|            public void Dispose()
	|            {
	|                Dispose(true);
	|                GC.SuppressFinalize(this);
	|#if DEBUG_IDISPOSABLE
	|				WasDisposed = true;
	|#endif
	|            }
	|
	|            /// <summary>
	|            /// Releases all resource used by the <see cref=""Application.RunState""/> object.
	|            /// </summary>
	|            /// <param name=""disposing"">If set to <see langword=""true""/> we are disposing and should dispose held objects.</param>
	|            protected virtual void Dispose(bool disposing)
	|            {
	|                if (Toplevel != null && disposing)
	|                {
	|                    Toplevel.Dispose();
	|                    Toplevel = null;
	|                }
	|            }
	|        }
	|
	|        static void ProcessKeyEvent(KeyEvent ke)
	|        {
	|            if (RootKeyEvent?.Invoke(ke) ?? false)
	|            {
	|                return;
	|            }
	|
	|            var chain = toplevels.Where(t => t.Visible).ToList();
	|            foreach (var topLevel in chain)
	|            {
	|                if (topLevel.ProcessHotKey(ke))
	|                {
	|                    EnsuresMdiTopOnFrontIfMdiTopMostFocused();
	|                    return;
	|                }
	|                if (topLevel.Modal)
	|                    break;
	|            }
	|
	|            foreach (var topLevel in chain)
	|            {
	|                if (topLevel.ProcessKey(ke))
	|                    return;
	|                if (topLevel.Modal)
	|                    break;
	|            }
	|
	|            foreach (var topLevel in chain)
	|            {
	|                // Process the key normally
	|                if (topLevel.ProcessColdKey(ke))
	|                    return;
	|                if (topLevel.Modal)
	|                    break;
	|            }
	|        }
	|
	|        static void ProcessKeyDownEvent(KeyEvent ke)
	|        {
	|            var chain = toplevels.ToList();
	|            foreach (var topLevel in chain)
	|            {
	|                if (topLevel.OnKeyDown(ke))
	|                    return;
	|                if (topLevel.Modal)
	|                    break;
	|            }
	|        }
	|
	|
	|        static void ProcessKeyUpEvent(KeyEvent ke)
	|        {
	|            var chain = toplevels.ToList();
	|            foreach (var topLevel in chain)
	|            {
	|                if (topLevel.OnKeyUp(ke))
	|                    return;
	|                if (topLevel.Modal)
	|                    break;
	|            }
	|        }
	|
	|        static View FindDeepestTop(Toplevel start, int x, int y, out int resx, out int resy)
	|        {
	|            var startFrame = start.Frame;
	|
	|            if (!startFrame.Contains(x, y))
	|            {
	|                resx = 0;
	|                resy = 0;
	|                return null;
	|            }
	|
	|            if (toplevels != null)
	|            {
	|                int count = toplevels.Count;
	|                if (count > 0)
	|                {
	|                    var rx = x - startFrame.X;
	|                    var ry = y - startFrame.Y;
	|                    foreach (var t in toplevels)
	|                    {
	|                        if (t != Current)
	|                        {
	|                            if (t != start && t.Visible && t.Frame.Contains(rx, ry))
	|                            {
	|                                start = t;
	|                                break;
	|                            }
	|                        }
	|                    }
	|                }
	|            }
	|            resx = x - startFrame.X;
	|            resy = y - startFrame.Y;
	|            return start;
	|        }
	|
	|        static View FindDeepestMdiView(View start, int x, int y, out int resx, out int resy)
	|        {
	|            if (start.GetType().BaseType != typeof(Toplevel)
	|                && !((Toplevel)start).IsMdiContainer)
	|            {
	|                resx = 0;
	|                resy = 0;
	|                return null;
	|            }
	|
	|            var startFrame = start.Frame;
	|
	|            if (!startFrame.Contains(x, y))
	|            {
	|                resx = 0;
	|                resy = 0;
	|                return null;
	|            }
	|
	|            int count = toplevels.Count;
	|            for (int i = count - 1; i >= 0; i--)
	|            {
	|                foreach (var top in toplevels)
	|                {
	|                    var rx = x - startFrame.X;
	|                    var ry = y - startFrame.Y;
	|                    if (top.Visible && top.Frame.Contains(rx, ry))
	|                    {
	|                        var deep = FindDeepestView(top, rx, ry, out resx, out resy);
	|                        if (deep == null)
	|                            return FindDeepestMdiView(top, rx, ry, out resx, out resy);
	|                        if (deep != MdiTop)
	|                            return deep;
	|                    }
	|                }
	|            }
	|            resx = x - startFrame.X;
	|            resy = y - startFrame.Y;
	|            return start;
	|        }
	|
	|        static View FindDeepestView(View start, int x, int y, out int resx, out int resy)
	|        {
	|            var startFrame = start.Frame;
	|
	|            if (!startFrame.Contains(x, y))
	|            {
	|                resx = 0;
	|                resy = 0;
	|                return null;
	|            }
	|
	|            if (start.InternalSubviews != null)
	|            {
	|                int count = start.InternalSubviews.Count;
	|                if (count > 0)
	|                {
	|                    var rx = x - startFrame.X;
	|                    var ry = y - startFrame.Y;
	|                    for (int i = count - 1; i >= 0; i--)
	|                    {
	|                        View v = start.InternalSubviews[i];
	|                        if (v.Visible && v.Frame.Contains(rx, ry))
	|                        {
	|                            var deep = FindDeepestView(v, rx, ry, out resx, out resy);
	|                            if (deep == null)
	|                                return v;
	|                            return deep;
	|                        }
	|                    }
	|                }
	|            }
	|            resx = x - startFrame.X;
	|            resy = y - startFrame.Y;
	|            return start;
	|        }
	|
	|        static View FindTopFromView(View view)
	|        {
	|            View top = view?.SuperView != null && view?.SuperView != Top
	|                ? view.SuperView : view;
	|
	|            while (top?.SuperView != null && top?.SuperView != Top)
	|            {
	|                top = top.SuperView;
	|            }
	|            return top;
	|        }
	|
	|        static View mouseGrabView;
	|
	|        /// <summary>
	|        /// The view that grabbed the mouse, to where will be routed all the mouse events.
	|        /// </summary>
	|        public static View MouseGrabView => mouseGrabView;
	|
	|        /// <summary>
	|        /// Invoked when a view wants to grab the mouse; can be canceled.
	|        /// </summary>
	|        public static event Func<View, bool> GrabbingMouse;
	|
	|        /// <summary>
	|        /// Invoked when a view wants ungrab the mouse; can be canceled.
	|        /// </summary>
	|        public static event Func<View, bool> UnGrabbingMouse;
	|
	|        /// <summary>
	|        /// Event to be invoked when a view grab the mouse.
	|        /// </summary>
	|        public static event Action<View> GrabbedMouse;
	|
	|        /// <summary>
	|        /// Event to be invoked when a view ungrab the mouse.
	|        /// </summary>
	|        public static event Action<View> UnGrabbedMouse;
	|
	|        /// <summary>
	|        /// Grabs the mouse, forcing all mouse events to be routed to the specified view until UngrabMouse is called.
	|        /// </summary>
	|        /// <returns>The grab.</returns>
	|        /// <param name=""view"">View that will receive all mouse events until UngrabMouse is invoked.</param>
	|        public static void GrabMouse(View view)
	|        {
	|            if (view == null)
	|                return;
	|            if (!OnGrabbingMouse(view))
	|            {
	|                OnGrabbedMouse(view);
	|                mouseGrabView = view;
	|                Driver.UncookMouse();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Releases the mouse grab, so mouse events will be routed to the view on which the mouse is.
	|        /// </summary>
	|        public static void UngrabMouse()
	|        {
	|            if (mouseGrabView == null)
	|                return;
	|            if (!OnUnGrabbingMouse(mouseGrabView))
	|            {
	|                OnUnGrabbedMouse(mouseGrabView);
	|                mouseGrabView = null;
	|                Driver.CookMouse();
	|            }
	|        }
	|
	|        static bool OnGrabbingMouse(View view)
	|        {
	|            if (view == null || GrabbingMouse == null)
	|                return false;
	|            return (bool)(GrabbingMouse?.Invoke(view));
	|        }
	|
	|        static bool OnUnGrabbingMouse(View view)
	|        {
	|            if (view == null || UnGrabbingMouse == null)
	|                return false;
	|            return (bool)(UnGrabbingMouse?.Invoke(view));
	|        }
	|
	|        static void OnGrabbedMouse(View view)
	|        {
	|            if (view == null)
	|                return;
	|            GrabbedMouse?.Invoke(view);
	|        }
	|
	|        static void OnUnGrabbedMouse(View view)
	|        {
	|            if (view == null)
	|                return;
	|            UnGrabbedMouse?.Invoke(view);
	|        }
	|
	|        /// <summary>
	|        /// Merely a debugging aid to see the raw mouse events
	|        /// </summary>
	|        public static Action<MouseEvent> RootMouseEvent;
	|
	|        /// <summary>
	|        /// <para>
	|        /// Called for new KeyPress events before any processing is performed or
	|        /// views evaluate.  Use for global key handling and/or debugging.
	|        /// </para>
	|        /// <para>Return true to suppress the KeyPress event</para>
	|        /// </summary>
	|        public static Func<KeyEvent, bool> RootKeyEvent;
	|
	|        static View lastMouseOwnerView;
	|
	|        static void ProcessMouseEvent(MouseEvent me)
	|        {
	|            if (IsMouseDisabled)
	|            {
	|                return;
	|            }
	|
	|            EnsuresMdiTopOnFrontIfMdiTopMostFocused();
	|            var view = FindDeepestView(Current, me.X, me.Y, out int rx, out int ry);
	|
	|            if (view != null && view.WantContinuousButtonPressed)
	|                WantContinuousButtonPressedView = view;
	|            else
	|                WantContinuousButtonPressedView = null;
	|            if (view != null)
	|            {
	|                me.View = view;
	|            }
	|            RootMouseEvent?.Invoke(me);
	|
	|            if (me.Handled)
	|            {
	|                return;
	|            }
	|
	|            if (mouseGrabView != null)
	|            {
	|                if (view == null)
	|                {
	|                    view = mouseGrabView;
	|                }
	|
	|                var newxy = mouseGrabView.ScreenToView(me.X, me.Y);
	|                var nme = new MouseEvent()
	|                {
	|                    X = newxy.X,
	|                    Y = newxy.Y,
	|                    Flags = me.Flags,
	|                    OfX = me.X - newxy.X,
	|                    OfY = me.Y - newxy.Y,
	|                    View = view
	|                };
	|                if (OutsideFrame(new Point(nme.X, nme.Y), mouseGrabView.Frame))
	|                {
	|                    lastMouseOwnerView?.OnMouseLeave(me);
	|                }
	|                //System.Diagnostics.Debug.WriteLine ($""{nme.Flags};{nme.X};{nme.Y};{mouseGrabView}"");
	|                if (mouseGrabView?.OnMouseEvent(nme) == true)
	|                {
	|                    return;
	|                }
	|            }
	|
	|            if ((view == null || view == MdiTop || view.SuperView == MdiTop) && !Current.Modal && MdiTop != null
	|                && me.Flags != MouseFlags.ReportMousePosition && me.Flags != 0)
	|            {
	|
	|                var top = FindDeepestTop(Top, me.X, me.Y, out _, out _);
	|                view = FindDeepestView(top, me.X, me.Y, out rx, out ry);
	|
	|                if (view != null && view != MdiTop && top != Current && top.MostFocused != null
	|                    && top.MostFocused.GetType().Name != ""ContentView"")
	|                {
	|
	|                    MoveCurrent((Toplevel)top);
	|                }
	|            }
	|
	|            if (view != null)
	|            {
	|                var nme = new MouseEvent()
	|                {
	|                    X = rx,
	|                    Y = ry,
	|                    Flags = me.Flags,
	|                    OfX = 0,
	|                    OfY = 0,
	|                    View = view
	|                };
	|
	|                if (lastMouseOwnerView == null)
	|                {
	|                    lastMouseOwnerView = view;
	|                    view.OnMouseEnter(nme);
	|                }
	|                else if (lastMouseOwnerView != view)
	|                {
	|                    lastMouseOwnerView.OnMouseLeave(nme);
	|                    view.OnMouseEnter(nme);
	|                    lastMouseOwnerView = view;
	|                }
	|
	|                if (!view.WantMousePositionReports && me.Flags == MouseFlags.ReportMousePosition)
	|                    return;
	|
	|                if (view.WantContinuousButtonPressed)
	|                    WantContinuousButtonPressedView = view;
	|                else
	|                    WantContinuousButtonPressedView = null;
	|
	|                // Should we bubbled up the event, if it is not handled?
	|                if (view.OnMouseEvent(nme))
	|                {
	|                    EnsuresMdiTopOnFrontIfMdiTopMostFocused();
	|                }
	|
	|                EnsuresTopOnFront();
	|            }
	|        }
	|
	|        static void EnsuresMdiTopOnFrontIfMdiTopMostFocused()
	|        {
	|            if (MdiTop != null && Current != MdiTop && MdiTop.MostFocused != null
	|                && MdiTop.MostFocused.GetType().Name != ""ContentView"")
	|            {
	|
	|                MoveCurrent(Top);
	|            }
	|        }
	|
	|        // Only return true if the Current has changed.
	|        static bool MoveCurrent(Toplevel top)
	|        {
	|            // The Current is modal and the top is not modal toplevel then
	|            // the Current must be moved above the first not modal toplevel.
	|            if (MdiTop != null && top != MdiTop && top != Current && Current?.Modal == true && !toplevels.Peek().Modal)
	|            {
	|                lock (toplevels)
	|                {
	|                    toplevels.MoveTo(Current, 0, new ToplevelEqualityComparer());
	|                }
	|                var index = 0;
	|                var savedToplevels = toplevels.ToArray();
	|                foreach (var t in savedToplevels)
	|                {
	|                    if (!t.Modal && t != Current && t != top && t != savedToplevels[index])
	|                    {
	|                        lock (toplevels)
	|                        {
	|                            toplevels.MoveTo(top, index, new ToplevelEqualityComparer());
	|                        }
	|                    }
	|                    index++;
	|                }
	|                return false;
	|            }
	|            // The Current and the top are both not running toplevel then
	|            // the top must be moved above the first not running toplevel.
	|            if (MdiTop != null && top != MdiTop && top != Current && Current?.Running == false && !top.Running)
	|            {
	|                lock (toplevels)
	|                {
	|                    toplevels.MoveTo(Current, 0, new ToplevelEqualityComparer());
	|                }
	|                var index = 0;
	|                foreach (var t in toplevels.ToArray())
	|                {
	|                    if (!t.Running && t != Current && index > 0)
	|                    {
	|                        lock (toplevels)
	|                        {
	|                            toplevels.MoveTo(top, index - 1, new ToplevelEqualityComparer());
	|                        }
	|                    }
	|                    index++;
	|                }
	|                return false;
	|            }
	|            if ((MdiTop != null && top?.Modal == true && toplevels.Peek() != top)
	|                || (MdiTop != null && Current != MdiTop && Current?.Modal == false && top == MdiTop)
	|                || (MdiTop != null && Current?.Modal == false && top != Current)
	|                || (MdiTop != null && Current?.Modal == true && top == MdiTop))
	|            {
	|                lock (toplevels)
	|                {
	|                    toplevels.MoveTo(top, 0, new ToplevelEqualityComparer());
	|                    Current = top;
	|                }
	|            }
	|            return true;
	|        }
	|
	|        static bool OutsideFrame(Point p, Rect r)
	|        {
	|            return p.X < 0 || p.X > r.Width - 1 || p.Y < 0 || p.Y > r.Height - 1;
	|        }
	|
	|        /// <summary>
	|        /// Building block API: Prepares the provided <see cref=""Toplevel""/>  for execution.
	|        /// </summary>
	|        /// <returns>The <see cref=""RunState""/> handle that needs to be passed to the <see cref=""End(RunState)""/> method upon completion.</returns>
	|        /// <param name=""toplevel"">The <see cref=""Toplevel""/> to prepare execution for.</param>
	|        /// <remarks>
	|        ///  This method prepares the provided toplevel for running with the focus,
	|        ///  it adds this to the list of toplevels, sets up the mainloop to process the
	|        ///  event, lays out the subviews, focuses the first element, and draws the
	|        ///  toplevel in the screen. This is usually followed by executing
	|        ///  the <see cref=""RunLoop""/> method, and then the <see cref=""End(RunState)""/> method upon termination which will
	|        ///   undo these changes.
	|        /// </remarks>
	|        public static RunState Begin(Toplevel toplevel)
	|        {
	|            if (toplevel == null)
	|            {
	|                throw new ArgumentNullException(nameof(toplevel));
	|            }
	|            else if (toplevel.IsMdiContainer && MdiTop != toplevel && MdiTop != null)
	|            {
	|                throw new InvalidOperationException(""Only one Mdi Container is allowed."");
	|            }
	|
	|            var rs = new RunState(toplevel);
	|
	|            if (toplevel is ISupportInitializeNotification initializableNotification &&
	|                !initializableNotification.IsInitialized)
	|            {
	|                initializableNotification.BeginInit();
	|                initializableNotification.EndInit();
	|            }
	|            else if (toplevel is ISupportInitialize initializable)
	|            {
	|                initializable.BeginInit();
	|                initializable.EndInit();
	|            }
	|
	|            lock (toplevels)
	|            {
	|                // If Top was already initialized with Init, and Begin has never been called
	|                // Top was not added to the toplevels Stack. It will thus never get disposed.
	|                // Clean it up here:
	|                if (Top != null && toplevel != Top && !toplevels.Contains(Top))
	|                {
	|                    Top.Dispose();
	|                    Top = null;
	|                }
	|                else if (Top != null && toplevel != Top && toplevels.Contains(Top))
	|                {
	|                    Top.OnLeave(toplevel);
	|                }
	|                if (string.IsNullOrEmpty(toplevel.Id.ToString()))
	|                {
	|                    var count = 1;
	|                    var id = (toplevels.Count + count).ToString();
	|                    while (toplevels.Count > 0 && toplevels.FirstOrDefault(x => x.Id.ToString() == id) != null)
	|                    {
	|                        count++;
	|                        id = (toplevels.Count + count).ToString();
	|                    }
	|                    toplevel.Id = (toplevels.Count + count).ToString();
	|
	|                    toplevels.Push(toplevel);
	|                }
	|                else
	|                {
	|                    var dup = toplevels.FirstOrDefault(x => x.Id.ToString() == toplevel.Id);
	|                    if (dup == null)
	|                    {
	|                        toplevels.Push(toplevel);
	|                    }
	|                }
	|
	|                if (toplevels.FindDuplicates(new ToplevelEqualityComparer()).Count > 0)
	|                {
	|                    throw new ArgumentException(""There are duplicates toplevels Id's"");
	|                }
	|            }
	|            // Fix $520 - Set Top = toplevel if Top == null
	|            if (Top == null || toplevel.IsMdiContainer)
	|            {
	|                Top = toplevel;
	|            }
	|
	|            var refreshDriver = true;
	|            if (MdiTop == null || toplevel.IsMdiContainer || (Current?.Modal == false && toplevel.Modal)
	|                || (Current?.Modal == false && !toplevel.Modal) || (Current?.Modal == true && toplevel.Modal))
	|            {
	|
	|                if (toplevel.Visible)
	|                {
	|                    Current = toplevel;
	|                    SetCurrentAsTop();
	|                }
	|                else
	|                {
	|                    refreshDriver = false;
	|                }
	|            }
	|            else if ((MdiTop != null && toplevel != MdiTop && Current?.Modal == true && !toplevels.Peek().Modal)
	|              || (MdiTop != null && toplevel != MdiTop && Current?.Running == false))
	|            {
	|                refreshDriver = false;
	|                MoveCurrent(toplevel);
	|            }
	|            else
	|            {
	|                refreshDriver = false;
	|                MoveCurrent(Current);
	|            }
	|
	|            Driver.PrepareToRun(MainLoop, ProcessKeyEvent, ProcessKeyDownEvent, ProcessKeyUpEvent, ProcessMouseEvent);
	|            if (toplevel.LayoutStyle == LayoutStyle.Computed)
	|                toplevel.SetRelativeLayout(new Rect(0, 0, Driver.Cols, Driver.Rows));
	|            toplevel.LayoutSubviews();
	|            toplevel.PositionToplevels();
	|            toplevel.WillPresent();
	|            EnsuresTopOnFront();
	|            if (refreshDriver)
	|            {
	|                MdiTop?.OnChildLoaded(toplevel);
	|                toplevel.OnLoaded();
	|                Refresh();
	|            }
	|
	|            NotifyNewRunState?.Invoke(rs);
	|            return rs;
	|        }
	|
	|        /// <summary>
	|        /// Building block API: completes the execution of a <see cref=""Toplevel""/> that was started with <see cref=""Begin(Toplevel)""/> .
	|        /// </summary>
	|        /// <param name=""runState"">The <see cref=""RunState""/> returned by the <see cref=""Begin(Toplevel)""/> method.</param>
	|        public static void End(RunState runState)
	|        {
	|            if (runState == null)
	|                throw new ArgumentNullException(nameof(runState));
	|
	|            if (MdiTop != null)
	|            {
	|                MdiTop.OnChildUnloaded(runState.Toplevel);
	|            }
	|            else
	|            {
	|                runState.Toplevel.OnUnloaded();
	|            }
	|
	|            // End the RunState.Toplevel 
	|            // First, take it off the toplevel Stack
	|            if (toplevels.Count > 0)
	|            {
	|                if (toplevels.Peek() != runState.Toplevel)
	|                {
	|                    // If there the top of the stack is not the RunState.Toplevel then
	|                    // this call to End is not balanced with the call to Begin that started the RunState
	|                    throw new ArgumentException(""End must be balanced with calls to Begin"");
	|                }
	|                toplevels.Pop();
	|            }
	|
	|            // Notify that it is closing
	|            runState.Toplevel?.OnClosed(runState.Toplevel);
	|
	|            // If there is a MdiTop that is not the RunState.Toplevel then runstate.TopLevel 
	|            // is a child of MidTop and we should notify the MdiTop that it is closing
	|            if (MdiTop != null && !(runState.Toplevel).Modal && runState.Toplevel != MdiTop)
	|            {
	|                MdiTop.OnChildClosed(runState.Toplevel);
	|            }
	|
	|            // Set Current and Top to the next TopLevel on the stack
	|            if (toplevels.Count == 0)
	|            {
	|                Current = null;
	|                Top = null;
	|            }
	|            else
	|            {
	|                Current = toplevels.Peek();
	|                if (toplevels.Count == 1 && Current == MdiTop)
	|                {
	|                    MdiTop.OnAllChildClosed();
	|                }
	|                else
	|                {
	|                    SetCurrentAsTop();
	|                    runState.Toplevel.OnLeave(Current);
	|                    Current.OnEnter(runState.Toplevel);
	|                }
	|                Refresh();
	|            }
	|
	|            runState.Dispose();
	|        }
	|
	|        /// <summary>
	|        /// Shutdown an application initialized with <see cref=""Init(ConsoleDriver, IMainLoopDriver)""/>.
	|        /// </summary>
	|        /// <remarks>
	|        /// Shutdown must be called for every call to <see cref=""Init(ConsoleDriver, IMainLoopDriver)""/> or <see cref=""Application.Run(Toplevel, Func{Exception, bool})""/>
	|        /// to ensure all resources are cleaned up (Disposed) and terminal settings are restored.
	|        /// </remarks>
	|        public static void Shutdown()
	|        {
	|            ResetState();
	|        }
	|
	|        // Encapsulate all setting of initial state for Application; Having
	|        // this in a function like this ensures we don't make mistakes in
	|        // guaranteeing that the state of this singleton is deterministic when Init
	|        // starts running and after Shutdown returns.
	|        static void ResetState()
	|        {
	|            // Shutdown is the bookend for Init. As such it needs to clean up all resources
	|            // Init created. Apps that do any threading will need to code defensively for this.
	|            // e.g. see Issue #537
	|            foreach (var t in toplevels)
	|            {
	|                t.Running = false;
	|                t.Dispose();
	|            }
	|            toplevels.Clear();
	|            Current = null;
	|            Top?.Dispose();
	|            Top = null;
	|
	|            // BUGBUG: MdiTop is not cleared here, but it should be?
	|
	|            Driver?.End();
	|            Driver = null;
	|            MainLoop = null;
	|            Iteration = null;
	|            RootMouseEvent = null;
	|            RootKeyEvent = null;
	|            Resized = null;
	|            _mainThreadId = -1;
	|            NotifyNewRunState = null;
	|            NotifyStopRunState = null;
	|            _initialized = false;
	|            mouseGrabView = null;
	|
	|            // Reset synchronization context to allow the user to run async/await,
	|            // as the main loop has been ended, the synchronization context from 
	|            // gui.cs does no longer process any callbacks. See #1084 for more details:
	|            // (https://github.com/gui-cs/Terminal.Gui/issues/1084).
	|            SynchronizationContext.SetSynchronizationContext(syncContext: null);
	|        }
	|
	|
	|        static void Redraw(View view)
	|        {
	|            view.Redraw(view.Bounds);
	|            Driver.Refresh();
	|        }
	|
	|        /// <summary>
	|        /// Triggers a refresh of the entire display.
	|        /// </summary>
	|        public static void Refresh()
	|        {
	|            Driver.UpdateOffScreen();
	|            View last = null;
	|            foreach (var v in toplevels.Reverse())
	|            {
	|                if (v.Visible)
	|                {
	|                    v.SetNeedsDisplay();
	|                    v.Redraw(v.Bounds);
	|                }
	|                last = v;
	|            }
	|            last?.PositionCursor();
	|            Driver.Refresh();
	|        }
	|
	|
	|
	|        /// <summary>
	|        ///   Building block API: Runs the <see cref=""MainLoop""/> for the created <see cref=""Toplevel""/>.
	|        /// </summary>
	|        /// <remarks>
	|        ///   Use the <paramref name=""wait""/> parameter to control whether this is a blocking or non-blocking call.
	|        /// </remarks>
	|        /// <param name=""state"">The state returned by the <see cref=""Begin(Toplevel)""/> method.</param>
	|        /// <param name=""wait"">By default this is <see langword=""true""/> which will execute the runloop waiting for events, 
	|        /// if set to <see langword=""false""/>, a single iteration will execute.</param>
	|        public static void RunLoop(RunState state, bool wait = true)
	|        {
	|            if (state == null)
	|                throw new ArgumentNullException(nameof(state));
	|            if (state.Toplevel == null)
	|                throw new ObjectDisposedException(""state"");
	|
	|            bool firstIteration = true;
	|            for (state.Toplevel.Running = true; state.Toplevel.Running;)
	|            {
	|                if (ExitRunLoopAfterFirstIteration && !firstIteration)
	|                {
	|                    return;
	|                }
	|                RunMainLoopIteration(ref state, wait, ref firstIteration);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Run one iteration of the <see cref=""MainLoop""/>.
	|        /// </summary>
	|        /// <param name=""state"">The state returned by <see cref=""Begin(Toplevel)""/>.</param>
	|        /// <param name=""wait"">If <see langword=""true""/> will execute the runloop waiting for events. If <see langword=""true""/>
	|        /// will return after a single iteration.</param>
	|        /// <param name=""firstIteration"">Set to <see langword=""true""/> if this is the first run loop iteration. Upon return,
	|        /// it will be set to <see langword=""false""/> if at least one iteration happened.</param>
	|        public static void RunMainLoopIteration(ref RunState state, bool wait, ref bool firstIteration)
	|        {
	|            if (MainLoop.EventsPending(wait))
	|            {
	|                // Notify Toplevel it's ready
	|                if (firstIteration)
	|                {
	|                    state.Toplevel.OnReady();
	|                }
	|
	|                MainLoop.MainIteration();
	|                Iteration?.Invoke();
	|
	|                EnsureModalOrVisibleAlwaysOnTop(state.Toplevel);
	|                if (!EnsuresNotModalNotRunningAndNotCurrent(state.Toplevel))
	|                {
	|                    EnsuresMdiChildOnFrontIfMdiTopNotMostFocused();
	|                }
	|                if ((state.Toplevel != Current && Current?.Modal == true)
	|                    || (state.Toplevel != Current && Current?.Modal == false))
	|                {
	|
	|                    MdiTop?.OnDeactivate(state.Toplevel);
	|                    state.Toplevel = Current;
	|                    MdiTop?.OnActivate(state.Toplevel);
	|                    Top.SetChildNeedsDisplay();
	|                    Refresh();
	|                }
	|                if (Driver.EnsureCursorVisibility())
	|                {
	|                    state.Toplevel.SetNeedsDisplay();
	|                }
	|            }
	|            else if (!wait)
	|            {
	|                return;
	|            }
	|            firstIteration = false;
	|
	|            if (state.Toplevel != Top
	|                && (!Top.NeedDisplay.IsEmpty || Top.ChildNeedsDisplay || Top.LayoutNeeded))
	|            {
	|                Top.Redraw(Top.Bounds);
	|                foreach (var top in toplevels.Reverse())
	|                {
	|                    if (top != Top && top != state.Toplevel)
	|                    {
	|                        top.SetNeedsDisplay();
	|                        top.Redraw(top.Bounds);
	|                    }
	|                }
	|                state.Toplevel.SetNeedsDisplay(state.Toplevel.Bounds);
	|            }
	|            if (!state.Toplevel.NeedDisplay.IsEmpty || state.Toplevel.ChildNeedsDisplay || state.Toplevel.LayoutNeeded
	|                || MdiChildNeedsDisplay())
	|            {
	|
	|                bool isTopNeedsDisplay;
	|                do
	|                {
	|                    state.Toplevel.Redraw(state.Toplevel.Bounds);
	|                    if (DebugDrawBounds)
	|                    {
	|                        DrawBounds(state.Toplevel);
	|                    }
	|                    state.Toplevel.PositionCursor();
	|                    Driver.Refresh();
	|                    isTopNeedsDisplay = IsTopNeedsDisplay(state.Toplevel);
	|                    if (isTopNeedsDisplay)
	|                    {
	|                        Top.Redraw(Top.Bounds);
	|                        state.Toplevel.SetNeedsDisplay();
	|                    }
	|                } while (isTopNeedsDisplay);
	|            }
	|            else
	|            {
	|                Driver.UpdateCursor();
	|            }
	|
	|            bool IsTopNeedsDisplay(Toplevel toplevel)
	|            {
	|                if (toplevel != Top && !toplevel.Modal
	|                    && (!Top.NeedDisplay.IsEmpty || Top.ChildNeedsDisplay || Top.LayoutNeeded))
	|                {
	|
	|                    return true;
	|                }
	|                return false;
	|            }
	|        }
	|
	|        static void EnsuresMdiChildOnFrontIfMdiTopNotMostFocused()
	|        {
	|            if (MdiTop != null && Current == MdiTop && (MdiTop.MostFocused == null
	|                || MdiTop.MostFocused.GetType().Name == ""ContentView""))
	|            {
	|
	|                MoveNext();
	|            }
	|        }
	|
	|        static void EnsureModalOrVisibleAlwaysOnTop(Toplevel toplevel)
	|        {
	|            if (!toplevel.Running || (toplevel == Current && toplevel.Visible) || MdiTop == null || toplevels.Peek().Modal)
	|            {
	|                return;
	|            }
	|
	|            foreach (var top in toplevels.Reverse())
	|            {
	|                if (top.Modal && top != Current)
	|                {
	|                    MoveCurrent(top);
	|                    return;
	|                }
	|            }
	|            if (!toplevel.Visible && toplevel == Current)
	|            {
	|                MoveNext();
	|            }
	|        }
	|
	|        static bool EnsuresNotModalNotRunningAndNotCurrent(Toplevel curRunStateTop)
	|        {
	|            if (MdiTop == null || !curRunStateTop.Running)
	|            {
	|                return false;
	|            }
	|
	|            foreach (var top in toplevels)
	|            {
	|                if (!top.IsMdiContainer && top?.Running == false && top != Current && top?.Modal == false)
	|                {
	|                    MoveCurrent(top);
	|                    return true;
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        static bool MdiChildNeedsDisplay()
	|        {
	|            if (MdiTop == null)
	|            {
	|                return false;
	|            }
	|
	|            foreach (var top in toplevels)
	|            {
	|                if (top != Current && top.Visible && (!top.NeedDisplay.IsEmpty || top.ChildNeedsDisplay || top.LayoutNeeded))
	|                {
	|                    MdiTop.SetChildNeedsDisplay();
	|                    return true;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        internal static bool DebugDrawBounds = false;
	|
	|        // Need to look into why this does not work properly.
	|        static void DrawBounds(View v)
	|        {
	|            v.DrawFrame(v.Frame, padding: 0, fill: false);
	|            if (v.InternalSubviews != null && v.InternalSubviews.Count > 0)
	|                foreach (var sub in v.InternalSubviews)
	|                    DrawBounds(sub);
	|        }
	|
	|        /// <summary>
	|        /// Runs the application by calling <see cref=""Run(Toplevel, Func{Exception, bool})""/> with the value of <see cref=""Top""/>.
	|        /// </summary>
	|        /// <remarks>
	|        /// See <see cref=""Run(Toplevel, Func{Exception, bool})""/> for more details.
	|        /// </remarks>
	|        public static void Run(Func<Exception, bool> errorHandler = null)
	|        {
	|            Run(Top, errorHandler);
	|        }
	|
	|        /// <summary>
	|        /// Runs the application by calling <see cref=""Run(Toplevel, Func{Exception, bool})""/> 
	|        /// with a new instance of the specified <see cref=""Toplevel""/>-derived class.
	|        /// <para>
	|        /// Calling <see cref=""Init(ConsoleDriver, IMainLoopDriver)""/> first is not needed as this function will initialze the application.
	|        /// </para>
	|        /// <para>
	|        /// <see cref=""Shutdown""/> must be called when the application is closing (typically after Run> has 
	|        /// returned) to ensure resources are cleaned up and terminal settings restored.
	|        /// </para>
	|        /// </summary>
	|        /// <remarks>
	|        /// See <see cref=""Run(Toplevel, Func{Exception, bool})""/> for more details.
	|        /// </remarks>
	|        /// <param name=""errorHandler""></param>
	|        /// <param name=""driver"">The <see cref=""ConsoleDriver""/> to use. If not specified the default driver for the
	|        /// platform will be used (<see cref=""WindowsDriver""/>, <see cref=""CursesDriver""/>, or <see cref=""NetDriver""/>).
	|        /// This parameteter must be <see langword=""null""/> if <see cref=""Init(ConsoleDriver, IMainLoopDriver)""/> has already been called. 
	|        /// </param>
	|        /// <param name=""mainLoopDriver"">Specifies the <see cref=""MainLoop""/> to use.</param>
	|        public static void Run<T>(Func<Exception, bool> errorHandler = null, ConsoleDriver driver = null, IMainLoopDriver mainLoopDriver = null) where T : Toplevel, new()
	|        {
	|            if (_initialized)
	|            {
	|                if (Driver != null)
	|                {
	|                    // Init() has been called and we have a driver, so just run the app.
	|                    var top = new T();
	|                    var type = top.GetType().BaseType;
	|                    while (type != typeof(Toplevel) && type != typeof(object))
	|                    {
	|                        type = type.BaseType;
	|                    }
	|                    if (type != typeof(Toplevel))
	|                    {
	|                        throw new ArgumentException($""{top.GetType().Name} must be derived from TopLevel"");
	|                    }
	|                    Run(top, errorHandler);
	|                }
	|                else
	|                {
	|                    // This codepath should be impossible because Init(null, null) will select the platform default driver
	|                    throw new InvalidOperationException(""Init() completed without a driver being set (this should be impossible); Run<T>() cannot be called."");
	|                }
	|            }
	|            else
	|            {
	|                // Init() has NOT been called.
	|                InternalInit(() => new T(), driver, mainLoopDriver, calledViaRunT: true);
	|                Run(Top, errorHandler);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Runs the main loop on the given <see cref=""Toplevel""/> container.
	|        /// </summary>
	|        /// <remarks>
	|        ///   <para>
	|        ///     This method is used to start processing events
	|        ///     for the main application, but it is also used to
	|        ///     run other modal <see cref=""View""/>s such as <see cref=""Dialog""/> boxes.
	|        ///   </para>
	|        ///   <para>
	|        ///     To make a <see cref=""Run(Toplevel, Func{Exception, bool})""/> stop execution, call <see cref=""Application.RequestStop""/>.
	|        ///   </para>
	|        ///   <para>
	|        ///     Calling <see cref=""Run(Toplevel, Func{Exception, bool})""/> is equivalent to calling <see cref=""Begin(Toplevel)""/>, followed by <see cref=""RunLoop(RunState, bool)""/>,
	|        ///     and then calling <see cref=""End(RunState)""/>.
	|        ///   </para>
	|        ///   <para>
	|        ///     Alternatively, to have a program control the main loop and 
	|        ///     process events manually, call <see cref=""Begin(Toplevel)""/> to set things up manually and then
	|        ///     repeatedly call <see cref=""RunLoop(RunState, bool)""/> with the wait parameter set to false. By doing this
	|        ///     the <see cref=""RunLoop(RunState, bool)""/> method will only process any pending events, timers, idle handlers and
	|        ///     then return control immediately.
	|        ///   </para>
	|        ///   <para>
	|        ///     RELEASE builds only: When <paramref name=""errorHandler""/> is <see langword=""null""/> any exeptions will be rethrown.  
	|        ///     Otheriwse, if <paramref name=""errorHandler""/> will be called. If <paramref name=""errorHandler""/> 
	|        ///     returns <see langword=""true""/> the <see cref=""RunLoop(RunState, bool)""/> will resume; otherwise 
	|        ///     this method will exit.
	|        ///   </para>
	|        /// </remarks>
	|        /// <param name=""view"">The <see cref=""Toplevel""/> to run modally.</param>
	|        /// <param name=""errorHandler"">RELEASE builds only: Handler for any unhandled exceptions (resumes when returns true, rethrows when null).</param>
	|        public static void Run(Toplevel view, Func<Exception, bool> errorHandler = null)
	|        {
	|            var resume = true;
	|            while (resume)
	|            {
	|#if !DEBUG
	|				try {
	|#endif
	|                resume = false;
	|                var runToken = Begin(view);
	|                // If ExitRunLoopAfterFirstIteration is true then the user must dispose of the runToken
	|                // by using NotifyStopRunState event.
	|                RunLoop(runToken);
	|                if (!ExitRunLoopAfterFirstIteration)
	|                {
	|                    End(runToken);
	|                }
	|#if !DEBUG
	|				}
	|				catch (Exception error)
	|				{
	|					if (errorHandler == null)
	|					{
	|						throw;
	|					}
	|					resume = errorHandler(error);
	|				}
	|#endif
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Stops running the most recent <see cref=""Toplevel""/> or the <paramref name=""top""/> if provided.
	|        /// </summary>
	|        /// <param name=""top"">The toplevel to request stop.</param>
	|        /// <remarks>
	|        ///   <para>
	|        ///   This will cause <see cref=""Application.Run(Func{Exception, bool})""/> to return.
	|        ///   </para>
	|        ///   <para>
	|        ///     Calling <see cref=""Application.RequestStop""/> is equivalent to setting the <see cref=""Toplevel.Running""/> property on the currently running <see cref=""Toplevel""/> to false.
	|        ///   </para>
	|        /// </remarks>
	|        public static void RequestStop(Toplevel top = null)
	|        {
	|            if (MdiTop == null || top == null || (MdiTop == null && top != null))
	|            {
	|                top = Current;
	|            }
	|
	|            if (MdiTop != null && top.IsMdiContainer && top?.Running == true
	|                && (Current?.Modal == false || (Current?.Modal == true && Current?.Running == false)))
	|            {
	|
	|                MdiTop.RequestStop();
	|            }
	|            else if (MdiTop != null && top != Current && Current?.Running == true && Current?.Modal == true
	|              && top.Modal && top.Running)
	|            {
	|
	|                var ev = new ToplevelClosingEventArgs(Current);
	|                Current.OnClosing(ev);
	|                if (ev.Cancel)
	|                {
	|                    return;
	|                }
	|                ev = new ToplevelClosingEventArgs(top);
	|                top.OnClosing(ev);
	|                if (ev.Cancel)
	|                {
	|                    return;
	|                }
	|                Current.Running = false;
	|                OnNotifyStopRunState(Current);
	|                top.Running = false;
	|                OnNotifyStopRunState(top);
	|            }
	|            else if ((MdiTop != null && top != MdiTop && top != Current && Current?.Modal == false
	|              && Current?.Running == true && !top.Running)
	|              || (MdiTop != null && top != MdiTop && top != Current && Current?.Modal == false
	|              && Current?.Running == false && !top.Running && toplevels.ToArray()[1].Running))
	|            {
	|
	|                MoveCurrent(top);
	|            }
	|            else if (MdiTop != null && Current != top && Current?.Running == true && !top.Running
	|              && Current?.Modal == true && top.Modal)
	|            {
	|                // The Current and the top are both modal so needed to set the Current.Running to false too.
	|                Current.Running = false;
	|                OnNotifyStopRunState(Current);
	|            }
	|            else if (MdiTop != null && Current == top && MdiTop?.Running == true && Current?.Running == true && top.Running
	|              && Current?.Modal == true && top.Modal)
	|            {
	|                // The MdiTop was requested to stop inside a modal toplevel which is the Current and top,
	|                // both are the same, so needed to set the Current.Running to false too.
	|                Current.Running = false;
	|                OnNotifyStopRunState(Current);
	|            }
	|            else
	|            {
	|                Toplevel currentTop;
	|                if (top == Current || (Current?.Modal == true && !top.Modal))
	|                {
	|                    currentTop = Current;
	|                }
	|                else
	|                {
	|                    currentTop = top;
	|                }
	|                if (!currentTop.Running)
	|                {
	|                    return;
	|                }
	|                var ev = new ToplevelClosingEventArgs(currentTop);
	|                currentTop.OnClosing(ev);
	|                if (ev.Cancel)
	|                {
	|                    return;
	|                }
	|                currentTop.Running = false;
	|                OnNotifyStopRunState(currentTop);
	|            }
	|        }
	|
	|        static void OnNotifyStopRunState(Toplevel top)
	|        {
	|            if (ExitRunLoopAfterFirstIteration)
	|            {
	|                NotifyStopRunState?.Invoke(top);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Event arguments for the <see cref=""Application.Resized""/> event.
	|        /// </summary>
	|        public class ResizedEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// The number of rows in the resized terminal.
	|            /// </summary>
	|            public int Rows { get; set; }
	|            /// <summary>
	|            /// The number of columns in the resized terminal.
	|            /// </summary>
	|            public int Cols { get; set; }
	|        }
	|
	|        /// <summary>
	|        /// Invoked when the terminal was resized. The new size of the terminal is provided.
	|        /// </summary>
	|        public static Action<ResizedEventArgs> Resized;
	|
	|        static void TerminalResized()
	|        {
	|            var full = new Rect(0, 0, Driver.Cols, Driver.Rows);
	|            SetToplevelsSize(full);
	|            Resized?.Invoke(new ResizedEventArgs() { Cols = full.Width, Rows = full.Height });
	|            Driver.Clip = full;
	|            foreach (var t in toplevels)
	|            {
	|                t.SetRelativeLayout(full);
	|                t.LayoutSubviews();
	|                t.PositionToplevels();
	|                t.OnResized(full.Size);
	|            }
	|            Refresh();
	|        }
	|
	|        static void SetToplevelsSize(Rect full)
	|        {
	|            if (MdiTop == null)
	|            {
	|                foreach (var t in toplevels)
	|                {
	|                    if (t?.SuperView == null && !t.Modal)
	|                    {
	|                        t.Frame = full;
	|                        t.Width = full.Width;
	|                        t.Height = full.Height;
	|                    }
	|                }
	|            }
	|            else
	|            {
	|                Top.Frame = full;
	|                Top.Width = full.Width;
	|                Top.Height = full.Height;
	|            }
	|        }
	|
	|        static bool SetCurrentAsTop()
	|        {
	|            if (MdiTop == null && Current != Top && Current?.SuperView == null && Current?.Modal == false)
	|            {
	|                if (Current.Frame != new Rect(0, 0, Driver.Cols, Driver.Rows))
	|                {
	|                    Current.Frame = new Rect(0, 0, Driver.Cols, Driver.Rows);
	|                }
	|                Top = Current;
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Move to the next Mdi child from the <see cref=""MdiTop""/>.
	|        /// </summary>
	|        public static void MoveNext()
	|        {
	|            if (MdiTop != null && !Current.Modal)
	|            {
	|                lock (toplevels)
	|                {
	|                    toplevels.MoveNext();
	|                    var isMdi = false;
	|                    while (toplevels.Peek() == MdiTop || !toplevels.Peek().Visible)
	|                    {
	|                        if (!isMdi && toplevels.Peek() == MdiTop)
	|                        {
	|                            isMdi = true;
	|                        }
	|                        else if (isMdi && toplevels.Peek() == MdiTop)
	|                        {
	|                            MoveCurrent(Top);
	|                            break;
	|                        }
	|                        toplevels.MoveNext();
	|                    }
	|                    Current = toplevels.Peek();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Move to the previous Mdi child from the <see cref=""MdiTop""/>.
	|        /// </summary>
	|        public static void MovePrevious()
	|        {
	|            if (MdiTop != null && !Current.Modal)
	|            {
	|                lock (toplevels)
	|                {
	|                    toplevels.MovePrevious();
	|                    var isMdi = false;
	|                    while (toplevels.Peek() == MdiTop || !toplevels.Peek().Visible)
	|                    {
	|                        if (!isMdi && toplevels.Peek() == MdiTop)
	|                        {
	|                            isMdi = true;
	|                        }
	|                        else if (isMdi && toplevels.Peek() == MdiTop)
	|                        {
	|                            MoveCurrent(Top);
	|                            break;
	|                        }
	|                        toplevels.MovePrevious();
	|                    }
	|                    Current = toplevels.Peek();
	|                }
	|            }
	|        }
	|
	|        internal static bool ShowChild(Toplevel top)
	|        {
	|            if (Current == top)
	|            {
	|                return false;
	|            }
	|
	|            if (top.Visible && MdiTop != null && Current?.Modal == false)
	|            {
	|                lock (toplevels)
	|                {
	|                    toplevels.MoveTo(top, 0, new ToplevelEqualityComparer());
	|                    Current = top;
	|                }
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Wakes up the mainloop that might be waiting on input, must be thread safe.
	|        /// </summary>
	|        public static void DoEvents()
	|        {
	|            MainLoop.Driver.Wakeup();
	|        }
	|
	|        /// <summary>
	|        /// Ensures that the superview of the most focused view is on front.
	|        /// </summary>
	|        public static void EnsuresTopOnFront()
	|        {
	|            if (MdiTop != null)
	|            {
	|                return;
	|            }
	|            var top = FindTopFromView(Top?.MostFocused);
	|            if (top != null && Top.Subviews.Count > 1 && Top.Subviews[Top.Subviews.Count - 1] != top)
	|            {
	|                Top.BringSubviewToFront(top);
	|            }
	|        }
	|
	|        internal static List<CultureInfo> GetSupportedCultures()
	|        {
	|            CultureInfo[] culture = CultureInfo.GetCultures(CultureTypes.AllCultures);
	|
	|            // Get the assembly
	|            Assembly assembly = Assembly.GetExecutingAssembly();
	|
	|            //Find the location of the assembly
	|            string assemblyLocation = AppDomain.CurrentDomain.BaseDirectory;
	|
	|            // Find the resource file name of the assembly
	|            string resourceFilename = $""{Path.GetFileNameWithoutExtension(assembly.Location)}.resources.dll"";
	|
	|            // Return all culture for which satellite folder found with culture code.
	|            return culture.Where(cultureInfo =>
	|                assemblyLocation != null &&
	|                Directory.Exists(Path.Combine(assemblyLocation, cultureInfo.Name)) &&
	|                File.Exists(Path.Combine(assemblyLocation, cultureInfo.Name, resourceFilename))
	|            ).ToList();
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Renders an overlay on another view at a given point that allows selecting
	|    /// from a range of 'autocomplete' options.
	|    /// </summary>
	|    public abstract class Autocomplete : IAutocomplete
	|    {
	|
	|        private class Popup : View
	|        {
	|            Autocomplete autocomplete;
	|
	|            public Popup(Autocomplete autocomplete)
	|            {
	|                this.autocomplete = autocomplete;
	|                CanFocus = true;
	|                WantMousePositionReports = true;
	|            }
	|
	|            public override Rect Frame
	|            {
	|                get => base.Frame;
	|                set
	|                {
	|                    base.Frame = value;
	|                    X = value.X;
	|                    Y = value.Y;
	|                    Width = value.Width;
	|                    Height = value.Height;
	|                }
	|            }
	|
	|            public override void Redraw(Rect bounds)
	|            {
	|                if (autocomplete.LastPopupPos == null)
	|                {
	|                    return;
	|                }
	|
	|                autocomplete.RenderOverlay((Point)autocomplete.LastPopupPos);
	|            }
	|
	|            public override bool MouseEvent(MouseEvent mouseEvent)
	|            {
	|                return autocomplete.MouseEvent(mouseEvent);
	|            }
	|        }
	|
	|        private View top, popup;
	|        private bool closed;
	|        int toRenderLength;
	|
	|        private Point? LastPopupPos { get; set; }
	|
	|        private ColorScheme colorScheme;
	|        private View hostControl;
	|
	|        /// <summary>
	|        /// The host control to handle.
	|        /// </summary>
	|        public virtual View HostControl
	|        {
	|            get => hostControl;
	|            set
	|            {
	|                hostControl = value;
	|                top = hostControl.SuperView;
	|                if (top != null)
	|                {
	|                    top.DrawContent += Top_DrawContent;
	|                    top.DrawContentComplete += Top_DrawContentComplete;
	|                    top.Removed += Top_Removed;
	|                }
	|            }
	|        }
	|
	|        private void Top_Removed(View obj)
	|        {
	|            Visible = false;
	|            ManipulatePopup();
	|        }
	|
	|        private void Top_DrawContentComplete(Rect obj)
	|        {
	|            ManipulatePopup();
	|        }
	|
	|        private void Top_DrawContent(Rect obj)
	|        {
	|            if (!closed)
	|            {
	|                ReopenSuggestions();
	|            }
	|            ManipulatePopup();
	|            if (Visible)
	|            {
	|                top.BringSubviewToFront(popup);
	|            }
	|        }
	|
	|        private void ManipulatePopup()
	|        {
	|            if (Visible && popup == null)
	|            {
	|                popup = new Popup(this)
	|                {
	|                    Frame = Rect.Empty
	|                };
	|                top?.Add(popup);
	|            }
	|
	|            if (!Visible && popup != null)
	|            {
	|                top.Remove(popup);
	|                popup.Dispose();
	|                popup = null;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets If the popup is displayed inside or outside the host limits.
	|        /// </summary>
	|        public bool PopupInsideContainer { get; set; } = true;
	|
	|        /// <summary>
	|        /// The maximum width of the autocomplete dropdown
	|        /// </summary>
	|        public virtual int MaxWidth { get; set; } = 10;
	|
	|        /// <summary>
	|        /// The maximum number of visible rows in the autocomplete dropdown to render
	|        /// </summary>
	|        public virtual int MaxHeight { get; set; } = 6;
	|
	|        /// <summary>
	|        /// True if the autocomplete should be considered open and visible
	|        /// </summary>
	|        public virtual bool Visible { get; set; }
	|
	|        /// <summary>
	|        /// The strings that form the current list of suggestions to render
	|        /// based on what the user has typed so far.
	|        /// </summary>
	|        public virtual ReadOnlyCollection<string> Suggestions { get; set; } = new ReadOnlyCollection<string>(new string[0]);
	|
	|        /// <summary>
	|        /// The full set of all strings that can be suggested.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual List<string> AllSuggestions { get; set; } = new List<string>();
	|
	|        /// <summary>
	|        /// The currently selected index into <see cref=""Suggestions""/> that the user has highlighted
	|        /// </summary>
	|        public virtual int SelectedIdx { get; set; }
	|
	|        /// <summary>
	|        /// When more suggestions are available than can be rendered the user
	|        /// can scroll down the dropdown list.  This indicates how far down they
	|        /// have gone
	|        /// </summary>
	|        public virtual int ScrollOffset { get; set; }
	|
	|        /// <summary>
	|        /// The colors to use to render the overlay.  Accessing this property before
	|        /// the Application has been initialized will cause an error
	|        /// </summary>
	|        public virtual ColorScheme ColorScheme
	|        {
	|            get
	|            {
	|                if (colorScheme == null)
	|                {
	|                    colorScheme = Colors.Menu;
	|                }
	|                return colorScheme;
	|            }
	|            set
	|            {
	|                colorScheme = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The key that the user must press to accept the currently selected autocomplete suggestion
	|        /// </summary>
	|        public virtual Key SelectionKey { get; set; } = Key.Enter;
	|
	|        /// <summary>
	|        /// The key that the user can press to close the currently popped autocomplete menu
	|        /// </summary>
	|        public virtual Key CloseKey { get; set; } = Key.Esc;
	|
	|        /// <summary>
	|        /// The key that the user can press to reopen the currently popped autocomplete menu
	|        /// </summary>
	|        public virtual Key Reopen { get; set; } = Key.Space | Key.CtrlMask | Key.AltMask;
	|
	|        /// <summary>
	|        /// Renders the autocomplete dialog inside or outside the given <see cref=""HostControl""/> at the
	|        /// given point.
	|        /// </summary>
	|        /// <param name=""renderAt""></param>
	|        public virtual void RenderOverlay(Point renderAt)
	|        {
	|            if (!Visible || HostControl?.HasFocus == false || Suggestions.Count == 0)
	|            {
	|                LastPopupPos = null;
	|                Visible = false;
	|                return;
	|            }
	|
	|            LastPopupPos = renderAt;
	|
	|            int height, width;
	|
	|            if (PopupInsideContainer)
	|            {
	|                // don't overspill vertically
	|                height = Math.Min(HostControl.Bounds.Height - renderAt.Y, MaxHeight);
	|                // There is no space below, lets see if can popup on top
	|                if (height < Suggestions.Count && HostControl.Bounds.Height - renderAt.Y >= height)
	|                {
	|                    // Verifies that the upper limit available is greater than the lower limit
	|                    if (renderAt.Y > HostControl.Bounds.Height - renderAt.Y)
	|                    {
	|                        renderAt.Y = Math.Max(renderAt.Y - Math.Min(Suggestions.Count + 1, MaxHeight + 1), 0);
	|                        height = Math.Min(Math.Min(Suggestions.Count, MaxHeight), LastPopupPos.Value.Y - 1);
	|                    }
	|                }
	|            }
	|            else
	|            {
	|                // don't overspill vertically
	|                height = Math.Min(Math.Min(top.Bounds.Height - HostControl.Frame.Bottom, MaxHeight), Suggestions.Count);
	|                // There is no space below, lets see if can popup on top
	|                if (height < Suggestions.Count && HostControl.Frame.Y - top.Frame.Y >= height)
	|                {
	|                    // Verifies that the upper limit available is greater than the lower limit
	|                    if (HostControl.Frame.Y > top.Bounds.Height - HostControl.Frame.Y)
	|                    {
	|                        renderAt.Y = Math.Max(HostControl.Frame.Y - Math.Min(Suggestions.Count, MaxHeight), 0);
	|                        height = Math.Min(Math.Min(Suggestions.Count, MaxHeight), HostControl.Frame.Y);
	|                    }
	|                }
	|                else
	|                {
	|                    renderAt.Y = HostControl.Frame.Bottom;
	|                }
	|            }
	|
	|            if (ScrollOffset > Suggestions.Count - height)
	|            {
	|                ScrollOffset = 0;
	|            }
	|            var toRender = Suggestions.Skip(ScrollOffset).Take(height).ToArray();
	|            toRenderLength = toRender.Length;
	|
	|            if (toRender.Length == 0)
	|            {
	|                return;
	|            }
	|
	|            width = Math.Min(MaxWidth, toRender.Max(s => s.Length));
	|
	|            if (PopupInsideContainer)
	|            {
	|                // don't overspill horizontally, let's see if can be displayed on the left
	|                if (width > HostControl.Bounds.Width - renderAt.X)
	|                {
	|                    // Verifies that the left limit available is greater than the right limit
	|                    if (renderAt.X > HostControl.Bounds.Width - renderAt.X)
	|                    {
	|                        renderAt.X -= Math.Min(width, LastPopupPos.Value.X);
	|                        width = Math.Min(width, LastPopupPos.Value.X);
	|                    }
	|                    else
	|                    {
	|                        width = Math.Min(width, HostControl.Bounds.Width - renderAt.X);
	|                    }
	|                }
	|            }
	|            else
	|            {
	|                // don't overspill horizontally, let's see if can be displayed on the left
	|                if (width > top.Bounds.Width - (renderAt.X + HostControl.Frame.X))
	|                {
	|                    // Verifies that the left limit available is greater than the right limit
	|                    if (renderAt.X + HostControl.Frame.X > top.Bounds.Width - (renderAt.X + HostControl.Frame.X))
	|                    {
	|                        renderAt.X -= Math.Min(width, LastPopupPos.Value.X);
	|                        width = Math.Min(width, LastPopupPos.Value.X);
	|                    }
	|                    else
	|                    {
	|                        width = Math.Min(width, top.Bounds.Width - renderAt.X);
	|                    }
	|                }
	|            }
	|
	|            if (PopupInsideContainer)
	|            {
	|                popup.Frame = new Rect(
	|                    new Point(HostControl.Frame.X + renderAt.X, HostControl.Frame.Y + renderAt.Y),
	|                    new Size(width, height));
	|            }
	|            else
	|            {
	|                popup.Frame = new Rect(
	|                    new Point(HostControl.Frame.X + renderAt.X, renderAt.Y),
	|                    new Size(width, height));
	|            }
	|
	|            popup.Move(0, 0);
	|
	|            for (int i = 0; i < toRender.Length; i++)
	|            {
	|
	|                if (i == SelectedIdx - ScrollOffset)
	|                {
	|                    Application.Driver.SetAttribute(ColorScheme.Focus);
	|                }
	|                else
	|                {
	|                    Application.Driver.SetAttribute(ColorScheme.Normal);
	|                }
	|
	|                popup.Move(0, i);
	|
	|                var text = TextFormatter.ClipOrPad(toRender[i], width);
	|
	|                Application.Driver.AddStr(text);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Updates <see cref=""SelectedIdx""/> to be a valid index within <see cref=""Suggestions""/>
	|        /// </summary>
	|        public virtual void EnsureSelectedIdxIsValid()
	|        {
	|            SelectedIdx = Math.Max(0, Math.Min(Suggestions.Count - 1, SelectedIdx));
	|
	|            // if user moved selection up off top of current scroll window
	|            if (SelectedIdx < ScrollOffset)
	|            {
	|                ScrollOffset = SelectedIdx;
	|            }
	|
	|            // if user moved selection down past bottom of current scroll window
	|            while (toRenderLength > 0 && SelectedIdx >= ScrollOffset + toRenderLength)
	|            {
	|                ScrollOffset++;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Handle key events before <see cref=""HostControl""/> e.g. to make key events like
	|        /// up/down apply to the autocomplete control instead of changing the cursor position in
	|        /// the underlying text view.
	|        /// </summary>
	|        /// <param name=""kb"">The key event.</param>
	|        /// <returns><c>true</c>if the key can be handled <c>false</c>otherwise.</returns>
	|        public virtual bool ProcessKey(KeyEvent kb)
	|        {
	|            if (IsWordChar((char)kb.Key))
	|            {
	|                Visible = true;
	|                closed = false;
	|                return false;
	|            }
	|
	|            if (kb.Key == Reopen)
	|            {
	|                return ReopenSuggestions();
	|            }
	|
	|            if (closed || Suggestions.Count == 0)
	|            {
	|                Visible = false;
	|                if (!closed)
	|                {
	|                    Close();
	|                }
	|                return false;
	|            }
	|
	|            if (kb.Key == Key.CursorDown)
	|            {
	|                MoveDown();
	|                return true;
	|            }
	|
	|            if (kb.Key == Key.CursorUp)
	|            {
	|                MoveUp();
	|                return true;
	|            }
	|
	|            if (kb.Key == Key.CursorLeft || kb.Key == Key.CursorRight)
	|            {
	|                GenerateSuggestions(kb.Key == Key.CursorLeft ? -1 : 1);
	|                if (Suggestions.Count == 0)
	|                {
	|                    Visible = false;
	|                    if (!closed)
	|                    {
	|                        Close();
	|                    }
	|                }
	|                return false;
	|            }
	|
	|            if (kb.Key == SelectionKey)
	|            {
	|                return Select();
	|            }
	|
	|            if (kb.Key == CloseKey)
	|            {
	|                Close();
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Handle mouse events before <see cref=""HostControl""/> e.g. to make mouse events like
	|        /// report/click apply to the autocomplete control instead of changing the cursor position in
	|        /// the underlying text view.
	|        /// </summary>
	|        /// <param name=""me"">The mouse event.</param>
	|        /// <param name=""fromHost"">If was called from the popup or from the host.</param>
	|        /// <returns><c>true</c>if the mouse can be handled <c>false</c>otherwise.</returns>
	|        public virtual bool MouseEvent(MouseEvent me, bool fromHost = false)
	|        {
	|            if (fromHost)
	|            {
	|                if (!Visible)
	|                {
	|                    return false;
	|                }
	|                GenerateSuggestions();
	|                if (Visible && Suggestions.Count == 0)
	|                {
	|                    Visible = false;
	|                    HostControl?.SetNeedsDisplay();
	|                    return true;
	|                }
	|                else if (!Visible && Suggestions.Count > 0)
	|                {
	|                    Visible = true;
	|                    HostControl?.SetNeedsDisplay();
	|                    Application.UngrabMouse();
	|                    return false;
	|                }
	|                else
	|                {
	|                    // not in the popup
	|                    if (Visible && HostControl != null)
	|                    {
	|                        Visible = false;
	|                        closed = false;
	|                    }
	|                    HostControl?.SetNeedsDisplay();
	|                }
	|                return false;
	|            }
	|
	|            if (popup == null || Suggestions.Count == 0)
	|            {
	|                ManipulatePopup();
	|                return false;
	|            }
	|
	|            if (me.Flags == MouseFlags.ReportMousePosition)
	|            {
	|                RenderSelectedIdxByMouse(me);
	|                return true;
	|            }
	|
	|            if (me.Flags == MouseFlags.Button1Clicked)
	|            {
	|                SelectedIdx = me.Y - ScrollOffset;
	|                return Select();
	|            }
	|
	|            if (me.Flags == MouseFlags.WheeledDown)
	|            {
	|                MoveDown();
	|                return true;
	|            }
	|
	|            if (me.Flags == MouseFlags.WheeledUp)
	|            {
	|                MoveUp();
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Render the current selection in the Autocomplete context menu by the mouse reporting.
	|        /// </summary>
	|        /// <param name=""me""></param>
	|        protected void RenderSelectedIdxByMouse(MouseEvent me)
	|        {
	|            if (SelectedIdx != me.Y - ScrollOffset)
	|            {
	|                SelectedIdx = me.Y - ScrollOffset;
	|                if (LastPopupPos != null)
	|                {
	|                    RenderOverlay((Point)LastPopupPos);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Clears <see cref=""Suggestions""/>
	|        /// </summary>
	|        public virtual void ClearSuggestions()
	|        {
	|            Suggestions = Enumerable.Empty<string>().ToList().AsReadOnly();
	|        }
	|
	|
	|        /// <summary>
	|        /// Populates <see cref=""Suggestions""/> with all strings in <see cref=""AllSuggestions""/> that
	|        /// match with the current cursor position/text in the <see cref=""HostControl""/>
	|        /// </summary>
	|        /// <param name=""columnOffset"">The column offset.</param>
	|        public virtual void GenerateSuggestions(int columnOffset = 0)
	|        {
	|            // if there is nothing to pick from
	|            if (AllSuggestions.Count == 0)
	|            {
	|                ClearSuggestions();
	|                return;
	|            }
	|
	|            var currentWord = GetCurrentWord(columnOffset);
	|
	|            if (string.IsNullOrWhiteSpace(currentWord))
	|            {
	|                ClearSuggestions();
	|            }
	|            else
	|            {
	|                Suggestions = AllSuggestions.Where(o =>
	|               o.StartsWith(currentWord, StringComparison.CurrentCultureIgnoreCase) &&
	|               !o.Equals(currentWord, StringComparison.CurrentCultureIgnoreCase)
	|                ).ToList().AsReadOnly();
	|
	|                EnsureSelectedIdxIsValid();
	|            }
	|        }
	|
	|
	|        /// <summary>
	|        /// Return true if the given symbol should be considered part of a word
	|        /// and can be contained in matches.  Base behavior is to use <see cref=""char.IsLetterOrDigit(char)""/>
	|        /// </summary>
	|        /// <param name=""rune""></param>
	|        /// <returns></returns>
	|        public virtual bool IsWordChar(Rune rune)
	|        {
	|            return Char.IsLetterOrDigit((char)rune);
	|        }
	|
	|        /// <summary>
	|        /// Completes the autocomplete selection process.  Called when user hits the <see cref=""SelectionKey""/>.
	|        /// </summary>
	|        /// <returns></returns>
	|        protected bool Select()
	|        {
	|            if (SelectedIdx >= 0 && SelectedIdx < Suggestions.Count)
	|            {
	|                var accepted = Suggestions[SelectedIdx];
	|
	|                return InsertSelection(accepted);
	|
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Called when the user confirms a selection at the current cursor location in
	|        /// the <see cref=""HostControl""/>.  The <paramref name=""accepted""/> string
	|        /// is the full autocomplete word to be inserted.  Typically a host will have to
	|        /// remove some characters such that the <paramref name=""accepted""/> string 
	|        /// completes the word instead of simply being appended.
	|        /// </summary>
	|        /// <param name=""accepted""></param>
	|        /// <returns>True if the insertion was possible otherwise false</returns>
	|        protected virtual bool InsertSelection(string accepted)
	|        {
	|            var typedSoFar = GetCurrentWord() ?? """";
	|
	|            if (typedSoFar.Length < accepted.Length)
	|            {
	|
	|                // delete the text
	|                for (int i = 0; i < typedSoFar.Length; i++)
	|                {
	|                    DeleteTextBackwards();
	|                }
	|
	|                InsertText(accepted);
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Returns the currently selected word from the <see cref=""HostControl""/>.
	|        /// <para>
	|        /// When overriding this method views can make use of <see cref=""IdxToWord(List{Rune}, int, int)""/>
	|        /// </para>
	|        /// </summary>
	|        /// <param name=""columnOffset"">The column offset.</param>
	|        /// <returns></returns>
	|        protected abstract string GetCurrentWord(int columnOffset = 0);
	|
	|        /// <summary>
	|        /// <para>
	|        /// Given a <paramref name=""line""/> of characters, returns the word which ends at <paramref name=""idx""/> 
	|        /// or null.  Also returns null if the <paramref name=""idx""/> is positioned in the middle of a word.
	|        /// </para>
	|        /// 
	|        /// <para>
	|        /// Use this method to determine whether autocomplete should be shown when the cursor is at
	|        /// a given point in a line and to get the word from which suggestions should be generated.
	|        /// Use the <paramref name=""columnOffset""/> to indicate if search the word at left (negative),
	|        /// at right (positive) or at the current column (zero) which is the default.
	|        /// </para>
	|        /// </summary>
	|        /// <param name=""line""></param>
	|        /// <param name=""idx""></param>
	|        /// <param name=""columnOffset""></param>
	|        /// <returns></returns>
	|        protected virtual string IdxToWord(List<Rune> line, int idx, int columnOffset = 0)
	|        {
	|            StringBuilder sb = new StringBuilder();
	|            var endIdx = idx;
	|
	|            // get the ending word index
	|            while (endIdx < line.Count)
	|            {
	|                if (IsWordChar(line[endIdx]))
	|                {
	|                    endIdx++;
	|                }
	|                else
	|                {
	|                    break;
	|                }
	|            }
	|
	|            // It isn't a word char then there is no way to autocomplete that word
	|            if (endIdx == idx && columnOffset != 0)
	|            {
	|                return null;
	|            }
	|
	|            // we are at the end of a word.  Work out what has been typed so far
	|            while (endIdx-- > 0)
	|            {
	|                if (IsWordChar(line[endIdx]))
	|                {
	|                    sb.Insert(0, (char)line[endIdx]);
	|                }
	|                else
	|                {
	|                    break;
	|                }
	|            }
	|            return sb.ToString();
	|        }
	|
	|        /// <summary>
	|        /// Deletes the text backwards before insert the selected text in the <see cref=""HostControl""/>.
	|        /// </summary>
	|        protected abstract void DeleteTextBackwards();
	|
	|        /// <summary>
	|        /// Inser the selected text in the <see cref=""HostControl""/>.
	|        /// </summary>
	|        /// <param name=""accepted""></param>
	|        protected abstract void InsertText(string accepted);
	|
	|        /// <summary>
	|        /// Closes the Autocomplete context menu if it is showing and <see cref=""ClearSuggestions""/>
	|        /// </summary>
	|        protected void Close()
	|        {
	|            ClearSuggestions();
	|            Visible = false;
	|            closed = true;
	|            HostControl?.SetNeedsDisplay();
	|            ManipulatePopup();
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection in the Autocomplete context menu up one
	|        /// </summary>
	|        protected void MoveUp()
	|        {
	|            SelectedIdx--;
	|            if (SelectedIdx < 0)
	|            {
	|                SelectedIdx = Suggestions.Count - 1;
	|            }
	|            EnsureSelectedIdxIsValid();
	|            HostControl?.SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection in the Autocomplete context menu down one
	|        /// </summary>
	|        protected void MoveDown()
	|        {
	|            SelectedIdx++;
	|            if (SelectedIdx > Suggestions.Count - 1)
	|            {
	|                SelectedIdx = 0;
	|            }
	|            EnsureSelectedIdxIsValid();
	|            HostControl?.SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Reopen the popup after it has been closed.
	|        /// </summary>
	|        /// <returns></returns>
	|        protected bool ReopenSuggestions()
	|        {
	|            GenerateSuggestions();
	|            if (Suggestions.Count > 0)
	|            {
	|                Visible = true;
	|                closed = false;
	|                HostControl?.SetNeedsDisplay();
	|                return true;
	|            }
	|            return false;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Specifies the border style for a <see cref=""View""/> and to be used by the <see cref=""Border""/> class.
	|    /// </summary>
	|    public enum BorderStyle
	|    {
	|        /// <summary>
	|        /// No border is drawn.
	|        /// </summary>
	|        None,
	|        /// <summary>
	|        /// The border is drawn with a single line limits.
	|        /// </summary>
	|        Single,
	|        /// <summary>
	|        /// The border is drawn with a double line limits.
	|        /// </summary>
	|        Double,
	|        /// <summary>
	|        /// The border is drawn with a single line and rounded corners limits.
	|        /// </summary>
	|        Rounded
	|    }
	|
	|    /// <summary>
	|    /// Describes the thickness of a frame around a rectangle. Four <see cref=""int""/> values describe
	|    ///  the <see cref=""Left""/>, <see cref=""Top""/>, <see cref=""Right""/>, and <see cref=""Bottom""/> sides
	|    ///  of the rectangle, respectively.
	|    /// </summary>
	|    public struct Thickness
	|    {
	|        /// <summary>
	|        /// Gets or sets the width, in integers, of the left side of the bounding rectangle.
	|        /// </summary>
	|        public int Left;
	|        /// <summary>
	|        /// Gets or sets the width, in integers, of the upper side of the bounding rectangle.
	|        /// </summary>
	|        public int Top;
	|        /// <summary>
	|        /// Gets or sets the width, in integers, of the right side of the bounding rectangle.
	|        /// </summary>
	|        public int Right;
	|        /// <summary>
	|        /// Gets or sets the width, in integers, of the lower side of the bounding rectangle.
	|        /// </summary>
	|        public int Bottom;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Thickness""/> structure that has the
	|        ///  specified uniform length on each side.
	|        /// </summary>
	|        /// <param name=""length""></param>
	|        public Thickness(int length)
	|        {
	|            if (length < 0)
	|            {
	|                throw new ArgumentException(""Invalid value for this property."");
	|            }
	|
	|            Left = Top = Right = Bottom = length;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Thickness""/> structure that has specific
	|        ///  lengths (supplied as a <see cref=""int""/>) applied to each side of the rectangle.
	|        /// </summary>
	|        /// <param name=""left""></param>
	|        /// <param name=""top""></param>
	|        /// <param name=""right""></param>
	|        /// <param name=""bottom""></param>
	|        public Thickness(int left, int top, int right, int bottom)
	|        {
	|            if (left < 0 || top < 0 || right < 0 || bottom < 0)
	|            {
	|                throw new ArgumentException(""Invalid value for this property."");
	|            }
	|
	|            Left = left;
	|            Top = top;
	|            Right = right;
	|            Bottom = bottom;
	|        }
	|
	|        /// <summary>Returns the fully qualified type name of this instance.</summary>
	|        /// <returns>The fully qualified type name.</returns>
	|        public override string ToString()
	|        {
	|            return $""(Left={Left},Top={Top},Right={Right},Bottom={Bottom})"";
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Draws a border, background, or both around another element.
	|    /// </summary>
	|    public class Border
	|    {
	|        private int marginFrame => DrawMarginFrame ? 1 : 0;
	|
	|        /// <summary>
	|        /// A sealed <see cref=""Toplevel""/> derived class to implement <see cref=""Border""/> feature.
	|        /// This is only a wrapper to get borders on a toplevel and is recommended using another
	|        /// derived, like <see cref=""Window""/> where is possible to have borders with or without
	|        /// border line or spacing around.
	|        /// </summary>
	|        public sealed class ToplevelContainer : Toplevel
	|        {
	|            /// <inheritdoc/>
	|            public override Border Border
	|            {
	|                get => base.Border;
	|                set
	|                {
	|                    if (base.Border != null && base.Border.Child != null && value.Child == null)
	|                    {
	|                        value.Child = base.Border.Child;
	|                    }
	|                    base.Border = value;
	|                    if (value == null)
	|                    {
	|                        return;
	|                    }
	|                    Rect frame;
	|                    if (Border.Child != null && (Border.Child.Width is Dim || Border.Child.Height is Dim))
	|                    {
	|                        frame = Rect.Empty;
	|                    }
	|                    else
	|                    {
	|                        frame = Frame;
	|                    }
	|                    AdjustContentView(frame);
	|
	|                    Border.BorderChanged += Border_BorderChanged;
	|                }
	|            }
	|
	|            void Border_BorderChanged(Border border)
	|            {
	|                Rect frame;
	|                if (Border.Child != null && (Border.Child.Width is Dim || Border.Child.Height is Dim))
	|                {
	|                    frame = Rect.Empty;
	|                }
	|                else
	|                {
	|                    frame = Frame;
	|                }
	|                AdjustContentView(frame);
	|            }
	|
	|            /// <summary>
	|            /// Initializes with default null values.
	|            /// </summary>
	|            public ToplevelContainer() : this(null, string.Empty) { }
	|
	|            /// <summary>
	|            /// Initializes a <see cref=""ToplevelContainer""/> with a <see cref=""LayoutStyle.Computed""/>
	|            /// </summary>
	|            /// <param name=""border"">The border.</param>
	|            /// <param name=""title"">The title.</param>
	|            public ToplevelContainer(Border border, string title = null)
	|            {
	|                Initialize(Rect.Empty, border, title ?? string.Empty);
	|            }
	|
	|            /// <summary>
	|            /// Initializes a <see cref=""ToplevelContainer""/> with a <see cref=""LayoutStyle.Absolute""/>
	|            /// </summary>
	|            /// <param name=""frame"">The frame.</param>
	|            /// <param name=""border"">The border.</param>
	|            /// <param name=""title"">The title.</param>
	|            public ToplevelContainer(Rect frame, Border border, string title = null) : base(frame)
	|            {
	|                Initialize(frame, border, title ?? string.Empty);
	|            }
	|
	|            private void Initialize(Rect frame, Border border, string title)
	|            {
	|                ColorScheme = Colors.TopLevel;
	|                if (border == null)
	|                {
	|                    Border = new Border()
	|                    {
	|                        BorderStyle = BorderStyle.Single,
	|                        Title = (ustring)title
	|                    };
	|                }
	|                else
	|                {
	|                    Border = border;
	|                }
	|                AdjustContentView(frame);
	|            }
	|
	|            void AdjustContentView(Rect frame)
	|            {
	|                var borderLength = Border.DrawMarginFrame ? 1 : 0;
	|                var sumPadding = Border.GetSumThickness();
	|                var wp = new Point();
	|                var wb = new Size();
	|                if (frame == Rect.Empty)
	|                {
	|                    wp.X = borderLength + sumPadding.Left;
	|                    wp.Y = borderLength + sumPadding.Top;
	|                    wb.Width = borderLength + sumPadding.Right;
	|                    wb.Height = borderLength + sumPadding.Bottom;
	|                    if (Border.Child == null)
	|                    {
	|                        Border.Child = new ChildContentView(this)
	|                        {
	|                            X = wp.X,
	|                            Y = wp.Y,
	|                            Width = Dim.Fill(wb.Width),
	|                            Height = Dim.Fill(wb.Height)
	|                        };
	|                    }
	|                    else
	|                    {
	|                        Border.Child.X = wp.X;
	|                        Border.Child.Y = wp.Y;
	|                        Border.Child.Width = Dim.Fill(wb.Width);
	|                        Border.Child.Height = Dim.Fill(wb.Height);
	|                    }
	|                }
	|                else
	|                {
	|                    wb.Width = (2 * borderLength) + sumPadding.Right + sumPadding.Left;
	|                    wb.Height = (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
	|                    var cFrame = new Rect(borderLength + sumPadding.Left, borderLength + sumPadding.Top, frame.Width - wb.Width, frame.Height - wb.Height);
	|                    if (Border.Child == null)
	|                    {
	|                        Border.Child = new ChildContentView(cFrame, this);
	|                    }
	|                    else
	|                    {
	|                        Border.Child.Frame = cFrame;
	|                    }
	|                }
	|                if (Subviews?.Count == 0)
	|                    base.Add(Border.Child);
	|                Border.ChildContainer = this;
	|            }
	|
	|            /// <inheritdoc/>
	|            public override void Add(View view)
	|            {
	|                Border.Child.Add(view);
	|                if (view.CanFocus)
	|                {
	|                    CanFocus = true;
	|                }
	|                AddMenuStatusBar(view);
	|            }
	|
	|            /// <inheritdoc/>
	|            public override void Remove(View view)
	|            {
	|                if (view == null)
	|                {
	|                    return;
	|                }
	|
	|                SetNeedsDisplay();
	|                var touched = view.Frame;
	|                if (view == Border.Child)
	|                {
	|                    base.Remove(view);
	|                }
	|                else
	|                {
	|                    Border.Child.Remove(view);
	|                }
	|
	|                if (Border.Child.InternalSubviews.Count < 1)
	|                {
	|                    CanFocus = false;
	|                }
	|                RemoveMenuStatusBar(view);
	|            }
	|
	|            /// <inheritdoc/>
	|            public override void RemoveAll()
	|            {
	|                Border.Child.RemoveAll();
	|            }
	|
	|            /// <inheritdoc/>
	|            public override void Redraw(Rect bounds)
	|            {
	|                if (!NeedDisplay.IsEmpty)
	|                {
	|                    Driver.SetAttribute(GetNormalColor());
	|                    Clear();
	|                }
	|                var savedClip = Border.Child.ClipToBounds();
	|                Border.Child.Redraw(Border.Child.Bounds);
	|                Driver.Clip = savedClip;
	|
	|                ClearLayoutNeeded();
	|                ClearNeedsDisplay();
	|
	|                Driver.SetAttribute(GetNormalColor());
	|                Border.DrawContent(this, false);
	|                if (HasFocus)
	|                    Driver.SetAttribute(ColorScheme.HotNormal);
	|                if (Border.DrawMarginFrame)
	|                {
	|                    if (!ustring.IsNullOrEmpty(Border.Title))
	|                        Border.DrawTitle(this);
	|                    else
	|                        Border.DrawTitle(this, Frame);
	|                }
	|                Driver.SetAttribute(GetNormalColor());
	|
	|                // Checks if there are any SuperView view which intersect with this window.
	|                if (SuperView != null)
	|                {
	|                    SuperView.SetNeedsLayout();
	|                    SuperView.SetNeedsDisplay();
	|                }
	|            }
	|
	|            /// <inheritdoc/>
	|            public override void OnCanFocusChanged()
	|            {
	|                if (Border?.Child != null)
	|                {
	|                    Border.Child.CanFocus = CanFocus;
	|                }
	|                base.OnCanFocusChanged();
	|            }
	|        }
	|
	|        private class ChildContentView : View
	|        {
	|            View instance;
	|
	|            public ChildContentView(Rect frame, View instance) : base(frame)
	|            {
	|                this.instance = instance;
	|            }
	|            public ChildContentView(View instance)
	|            {
	|                this.instance = instance;
	|            }
	|
	|            public override bool MouseEvent(MouseEvent mouseEvent)
	|            {
	|                return instance.MouseEvent(mouseEvent);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Invoked when any property of Border changes (except <see cref=""Child""/>).
	|        /// </summary>
	|        public event Action<Border> BorderChanged;
	|
	|        private BorderStyle borderStyle;
	|        private bool drawMarginFrame;
	|        private Thickness borderThickness;
	|        private Color? borderBrush;
	|        private Color? background;
	|        private Thickness padding;
	|        private bool effect3D;
	|        private Point effect3DOffset = new Point(1, 1);
	|        private Attribute? effect3DBrush;
	|        private ustring title = ustring.Empty;
	|        private View child;
	|
	|        /// <summary>
	|        /// Specifies the <see cref=""Gui.BorderStyle""/> for a view.
	|        /// </summary>
	|        public BorderStyle BorderStyle
	|        {
	|            get => borderStyle;
	|            set
	|            {
	|                if (value != BorderStyle.None && !drawMarginFrame)
	|                {
	|                    // Ensures drawn the border lines.
	|                    drawMarginFrame = true;
	|                }
	|                borderStyle = value;
	|                OnBorderChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets if a margin frame is drawn around the <see cref=""Child""/> regardless the <see cref=""BorderStyle""/>
	|        /// </summary>
	|        public bool DrawMarginFrame
	|        {
	|            get => drawMarginFrame;
	|            set
	|            {
	|                if (borderStyle != BorderStyle.None
	|                    && (!value || !drawMarginFrame))
	|                {
	|                    // Ensures drawn the border lines.
	|                    drawMarginFrame = true;
	|                }
	|                else
	|                {
	|                    drawMarginFrame = value;
	|                }
	|                OnBorderChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the relative <see cref=""Thickness""/> of a <see cref=""Border""/>.
	|        /// </summary>
	|        public Thickness BorderThickness
	|        {
	|            get => borderThickness;
	|            set
	|            {
	|                borderThickness = value;
	|                OnBorderChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the <see cref=""Color""/> that draws the outer border color.
	|        /// </summary>
	|        public Color BorderBrush
	|        {
	|            get => borderBrush != null ? (Color)borderBrush : (Color)(-1);
	|            set
	|            {
	|                if (Enum.IsDefined(typeof(Color), value))
	|                {
	|                    borderBrush = value;
	|                    OnBorderChanged();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the <see cref=""Color""/> that fills the area between the bounds of a <see cref=""Border""/>.
	|        /// </summary>
	|        public Color Background
	|        {
	|            get => background != null ? (Color)background : (Color)(-1);
	|            set
	|            {
	|                if (Enum.IsDefined(typeof(Color), value))
	|                {
	|                    background = value;
	|                    OnBorderChanged();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a <see cref=""Thickness""/> value that describes the amount of space between a
	|        ///  <see cref=""Border""/> and its child element.
	|        /// </summary>
	|        public Thickness Padding
	|        {
	|            get => padding;
	|            set
	|            {
	|                padding = value;
	|                OnBorderChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the rendered width of this element.
	|        /// </summary>
	|        public int ActualWidth
	|        {
	|            get
	|            {
	|                var driver = Application.Driver;
	|                if (Parent?.Border == null)
	|                {
	|                    return Math.Min(Child?.Frame.Width + (2 * marginFrame) + Padding.Right
	|                        + BorderThickness.Right + Padding.Left + BorderThickness.Left ?? 0, driver.Cols);
	|                }
	|                return Math.Min(Parent.Frame.Width, driver.Cols);
	|            }
	|        }
	|        /// <summary>
	|        /// Gets the rendered height of this element.
	|        /// </summary>
	|        public int ActualHeight
	|        {
	|            get
	|            {
	|                var driver = Application.Driver;
	|                if (Parent?.Border == null)
	|                {
	|                    return Math.Min(Child?.Frame.Height + (2 * marginFrame) + Padding.Bottom
	|                        + BorderThickness.Bottom + Padding.Top + BorderThickness.Top ?? 0, driver.Rows);
	|                }
	|                return Math.Min(Parent.Frame.Height, driver.Rows);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the single child element of a <see cref=""View""/>.
	|        /// </summary>
	|        public View Child
	|        {
	|            get => child;
	|            set
	|            {
	|                child = value;
	|                if (child != null && Parent != null)
	|                {
	|                    Parent.Removed += Parent_Removed;
	|                }
	|            }
	|        }
	|
	|        private void Parent_Removed(View obj)
	|        {
	|            if (borderBrush != null)
	|            {
	|                BorderBrush = default;
	|            }
	|            if (background != null)
	|            {
	|                Background = default;
	|            }
	|            child.Removed -= Parent_Removed;
	|        }
	|
	|        /// <summary>
	|        /// Gets the parent <see cref=""Child""/> parent if any.
	|        /// </summary>
	|        public View Parent { get => Child?.SuperView; }
	|
	|        /// <summary>
	|        /// Gets or private sets by the <see cref=""ToplevelContainer""/>
	|        /// </summary>
	|        public ToplevelContainer ChildContainer { get; private set; }
	|
	|        /// <summary>
	|        /// Gets or sets the 3D effect around the <see cref=""Border""/>.
	|        /// </summary>
	|        public bool Effect3D
	|        {
	|            get => effect3D;
	|            set
	|            {
	|                effect3D = value;
	|                OnBorderChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or sets the offset start position for the <see cref=""Effect3D""/>
	|        /// </summary>
	|        public Point Effect3DOffset
	|        {
	|            get => effect3DOffset;
	|            set
	|            {
	|                effect3DOffset = value;
	|                OnBorderChanged();
	|            }
	|        }
	|        /// <summary>
	|        /// Gets or sets the color for the <see cref=""Border""/>
	|        /// </summary>
	|        public Attribute? Effect3DBrush
	|        {
	|            get => effect3DBrush;
	|            set
	|            {
	|                effect3DBrush = value;
	|                OnBorderChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The title to be displayed for this view.
	|        /// </summary>
	|        public ustring Title
	|        {
	|            get => title;
	|            set
	|            {
	|                title = value;
	|                OnBorderChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Calculate the sum of the <see cref=""Padding""/> and the <see cref=""BorderThickness""/>
	|        /// </summary>
	|        /// <returns>The total of the <see cref=""Border""/> <see cref=""Thickness""/></returns>
	|        public Thickness GetSumThickness()
	|        {
	|            return new Thickness()
	|            {
	|                Left = Padding.Left + BorderThickness.Left,
	|                Top = Padding.Top + BorderThickness.Top,
	|                Right = Padding.Right + BorderThickness.Right,
	|                Bottom = Padding.Bottom + BorderThickness.Bottom
	|            };
	|        }
	|
	|        /// <summary>
	|        /// Drawn the <see cref=""BorderThickness""/> more the <see cref=""Padding""/>
	|        ///  more the <see cref=""Border.BorderStyle""/> and the <see cref=""Effect3D""/>.
	|        /// </summary>
	|        /// <param name=""view"">The view to draw.</param>
	|        /// <param name=""fill"">If it will clear or not the content area.</param>
	|        public void DrawContent(View view = null, bool fill = true)
	|        {
	|            if (Child == null)
	|            {
	|                Child = view;
	|            }
	|            if (Parent?.Border != null)
	|            {
	|                DrawParentBorder(Parent.ViewToScreen(Parent.Bounds), fill);
	|            }
	|            else
	|            {
	|                DrawChildBorder(Child.ViewToScreen(Child.Bounds), fill);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Same as <see cref=""DrawContent""/> but drawing full frames for all borders.
	|        /// </summary>
	|        public void DrawFullContent()
	|        {
	|            var borderThickness = BorderThickness;
	|            var padding = Padding;
	|            var marginFrame = DrawMarginFrame ? 1 : 0;
	|            var driver = Application.Driver;
	|            Rect scrRect;
	|            if (Parent?.Border != null)
	|            {
	|                scrRect = Parent.ViewToScreen(Parent.Bounds);
	|            }
	|            else
	|            {
	|                scrRect = Child.ViewToScreen(Child.Bounds);
	|            }
	|            Rect borderRect;
	|            if (Parent?.Border != null)
	|            {
	|                borderRect = scrRect;
	|            }
	|            else
	|            {
	|                borderRect = new Rect()
	|                {
	|                    X = scrRect.X - marginFrame - padding.Left - borderThickness.Left,
	|                    Y = scrRect.Y - marginFrame - padding.Top - borderThickness.Top,
	|                    Width = ActualWidth,
	|                    Height = ActualHeight
	|                };
	|            }
	|            var savedAttribute = driver.GetAttribute();
	|
	|            // Draw 3D effects
	|            if (Effect3D)
	|            {
	|                driver.SetAttribute(GetEffect3DBrush());
	|
	|                var effectBorder = new Rect()
	|                {
	|                    X = borderRect.X + Effect3DOffset.X,
	|                    Y = borderRect.Y + Effect3DOffset.Y,
	|                    Width = ActualWidth,
	|                    Height = ActualHeight
	|                };
	|                //Child.Clear (effectBorder);
	|                for (int r = effectBorder.Y; r < Math.Min(effectBorder.Bottom, driver.Rows); r++)
	|                {
	|                    for (int c = effectBorder.X; c < Math.Min(effectBorder.Right, driver.Cols); c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|            }
	|
	|            // Draw border thickness
	|            SetBorderBrush(driver);
	|
	|            Child.Clear(borderRect);
	|
	|            borderRect = new Rect()
	|            {
	|                X = borderRect.X + borderThickness.Left,
	|                Y = borderRect.Y + borderThickness.Top,
	|                Width = Math.Max(borderRect.Width - borderThickness.Right - borderThickness.Left, 0),
	|                Height = Math.Max(borderRect.Height - borderThickness.Bottom - borderThickness.Top, 0)
	|            };
	|            if (borderRect != scrRect)
	|            {
	|                // Draw padding
	|                driver.SetAttribute(new Attribute(Background));
	|                Child.Clear(borderRect);
	|            }
	|
	|            SetBorderBrushBackground(driver);
	|
	|            // Draw margin frame
	|            if (DrawMarginFrame)
	|            {
	|                if (Parent?.Border != null)
	|                {
	|                    var sumPadding = GetSumThickness();
	|                    borderRect = new Rect()
	|                    {
	|                        X = scrRect.X + sumPadding.Left,
	|                        Y = scrRect.Y + sumPadding.Top,
	|                        Width = Math.Max(scrRect.Width - sumPadding.Right - sumPadding.Left, 0),
	|                        Height = Math.Max(scrRect.Height - sumPadding.Bottom - sumPadding.Top, 0)
	|                    };
	|                }
	|                else
	|                {
	|                    borderRect = new Rect()
	|                    {
	|                        X = borderRect.X + padding.Left,
	|                        Y = borderRect.Y + padding.Top,
	|                        Width = Math.Max(borderRect.Width - padding.Right - padding.Left, 0),
	|                        Height = Math.Max(borderRect.Height - padding.Bottom - padding.Top, 0)
	|                    };
	|                }
	|                if (borderRect.Width > 0 && borderRect.Height > 0)
	|                {
	|                    driver.DrawWindowFrame(borderRect, 1, 1, 1, 1, BorderStyle != BorderStyle.None, fill: true, this);
	|                }
	|            }
	|            driver.SetAttribute(savedAttribute);
	|        }
	|
	|        private void DrawChildBorder(Rect frame, bool fill = true)
	|        {
	|            var drawMarginFrame = DrawMarginFrame ? 1 : 0;
	|            var sumThickness = GetSumThickness();
	|            var padding = Padding;
	|            var effect3DOffset = Effect3DOffset;
	|            var driver = Application.Driver;
	|
	|            var savedAttribute = driver.GetAttribute();
	|
	|            SetBorderBrush(driver);
	|
	|            // Draw the upper BorderThickness
	|            for (int r = frame.Y - drawMarginFrame - sumThickness.Top;
	|                r < frame.Y - drawMarginFrame - padding.Top; r++)
	|            {
	|                for (int c = frame.X - drawMarginFrame - sumThickness.Left;
	|                    c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the left BorderThickness
	|            for (int r = frame.Y - drawMarginFrame - padding.Top;
	|                r < Math.Min(frame.Bottom + drawMarginFrame + padding.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.X - drawMarginFrame - sumThickness.Left;
	|                    c < frame.X - drawMarginFrame - padding.Left; c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the right BorderThickness
	|            for (int r = frame.Y - drawMarginFrame - padding.Top;
	|                r < Math.Min(frame.Bottom + drawMarginFrame + padding.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.Right + drawMarginFrame + padding.Right;
	|                    c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the lower BorderThickness
	|            for (int r = frame.Bottom + drawMarginFrame + padding.Bottom;
	|                r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.X - drawMarginFrame - sumThickness.Left;
	|                    c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            SetBackground(driver);
	|
	|            // Draw the upper Padding
	|            for (int r = frame.Y - drawMarginFrame - padding.Top;
	|                r < frame.Y - drawMarginFrame; r++)
	|            {
	|                for (int c = frame.X - drawMarginFrame - padding.Left;
	|                    c < Math.Min(frame.Right + drawMarginFrame + padding.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the left Padding
	|            for (int r = frame.Y - drawMarginFrame;
	|                r < Math.Min(frame.Bottom + drawMarginFrame, driver.Rows); r++)
	|            {
	|                for (int c = frame.X - drawMarginFrame - padding.Left;
	|                    c < frame.X - drawMarginFrame; c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the right Padding
	|            for (int r = frame.Y - drawMarginFrame;
	|                r < Math.Min(frame.Bottom + drawMarginFrame, driver.Rows); r++)
	|            {
	|                for (int c = frame.Right + drawMarginFrame;
	|                    c < Math.Min(frame.Right + drawMarginFrame + padding.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the lower Padding
	|            for (int r = frame.Bottom + drawMarginFrame;
	|                r < Math.Min(frame.Bottom + drawMarginFrame + padding.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.X - drawMarginFrame - padding.Left;
	|                    c < Math.Min(frame.Right + drawMarginFrame + padding.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            SetBorderBrushBackground(driver);
	|
	|            // Draw the MarginFrame
	|            if (DrawMarginFrame)
	|            {
	|                var rect = new Rect()
	|                {
	|                    X = frame.X - drawMarginFrame,
	|                    Y = frame.Y - drawMarginFrame,
	|                    Width = frame.Width + (2 * drawMarginFrame),
	|                    Height = frame.Height + (2 * drawMarginFrame)
	|                };
	|                if (rect.Width > 0 && rect.Height > 0)
	|                {
	|                    driver.DrawWindowFrame(rect, 1, 1, 1, 1, BorderStyle != BorderStyle.None, fill, this);
	|                    DrawTitle(Child);
	|                }
	|            }
	|
	|            if (Effect3D)
	|            {
	|                driver.SetAttribute(GetEffect3DBrush());
	|
	|                // Draw the upper Effect3D
	|                for (int r = frame.Y - drawMarginFrame - sumThickness.Top + effect3DOffset.Y;
	|                    r >= 0 && r < frame.Y - drawMarginFrame - sumThickness.Top; r++)
	|                {
	|                    for (int c = frame.X - drawMarginFrame - sumThickness.Left + effect3DOffset.X;
	|                        c >= 0 && c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right + effect3DOffset.X, driver.Cols); c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|
	|                // Draw the left Effect3D
	|                for (int r = frame.Y - drawMarginFrame - sumThickness.Top + effect3DOffset.Y;
	|                    r >= 0 && r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom + effect3DOffset.Y, driver.Rows); r++)
	|                {
	|                    for (int c = frame.X - drawMarginFrame - sumThickness.Left + effect3DOffset.X;
	|                        c >= 0 && c < frame.X - drawMarginFrame - sumThickness.Left; c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|
	|                // Draw the right Effect3D
	|                for (int r = frame.Y - drawMarginFrame - sumThickness.Top + effect3DOffset.Y;
	|                    r >= 0 && r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom + effect3DOffset.Y, driver.Rows); r++)
	|                {
	|                    for (int c = frame.Right + drawMarginFrame + sumThickness.Right;
	|                        c >= 0 && c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right + effect3DOffset.X, driver.Cols); c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|
	|                // Draw the lower Effect3D
	|                for (int r = frame.Bottom + drawMarginFrame + sumThickness.Bottom;
	|                    r >= 0 && r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom + effect3DOffset.Y, driver.Rows); r++)
	|                {
	|                    for (int c = frame.X - drawMarginFrame - sumThickness.Left + effect3DOffset.X;
	|                        c >= 0 && c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right + effect3DOffset.X, driver.Cols); c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|            }
	|            driver.SetAttribute(savedAttribute);
	|        }
	|
	|        private void DrawParentBorder(Rect frame, bool fill = true)
	|        {
	|            var sumThickness = GetSumThickness();
	|            var borderThickness = BorderThickness;
	|            var effect3DOffset = Effect3DOffset;
	|            var driver = Application.Driver;
	|
	|            var savedAttribute = driver.GetAttribute();
	|
	|            SetBorderBrush(driver);
	|
	|            // Draw the upper BorderThickness
	|            for (int r = Math.Max(frame.Y, 0);
	|                r < Math.Min(frame.Y + borderThickness.Top, frame.Bottom); r++)
	|            {
	|                for (int c = frame.X;
	|                    c < Math.Min(frame.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the left BorderThickness
	|            for (int r = Math.Max(Math.Min(frame.Y + borderThickness.Top, frame.Bottom), 0);
	|                r < Math.Min(frame.Bottom - borderThickness.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.X;
	|                    c < Math.Min(frame.X + borderThickness.Left, frame.Right); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the right BorderThickness
	|            for (int r = Math.Max(Math.Min(frame.Y + borderThickness.Top, frame.Bottom), 0);
	|                r < Math.Min(frame.Bottom - borderThickness.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = Math.Max(frame.Right - borderThickness.Right, frame.X);
	|                    c < Math.Min(frame.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the lower BorderThickness
	|            for (int r = Math.Max(frame.Bottom - borderThickness.Bottom, frame.Y);
	|                r < Math.Min(frame.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.X;
	|                    c < Math.Min(frame.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            SetBackground(driver);
	|
	|            // Draw the upper Padding
	|            for (int r = Math.Max(frame.Y + borderThickness.Top, 0);
	|                r < Math.Min(frame.Y + sumThickness.Top, frame.Bottom - borderThickness.Bottom); r++)
	|            {
	|                for (int c = frame.X + borderThickness.Left;
	|                    c < Math.Min(frame.Right - borderThickness.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the left Padding
	|            for (int r = Math.Max(frame.Y + sumThickness.Top, 0);
	|                r < Math.Min(frame.Bottom - sumThickness.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.X + borderThickness.Left;
	|                    c < Math.Min(frame.X + sumThickness.Left, frame.Right - borderThickness.Right); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the right Padding
	|            for (int r = Math.Max(frame.Y + sumThickness.Top, 0);
	|                r < Math.Min(frame.Bottom - sumThickness.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = Math.Max(frame.Right - sumThickness.Right, frame.X + sumThickness.Left);
	|                    c < Math.Max(frame.Right - borderThickness.Right, frame.X + sumThickness.Left); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            // Draw the lower Padding
	|            for (int r = Math.Max(frame.Bottom - sumThickness.Bottom, frame.Y + borderThickness.Top);
	|                r < Math.Min(frame.Bottom - borderThickness.Bottom, driver.Rows); r++)
	|            {
	|                for (int c = frame.X + borderThickness.Left;
	|                    c < Math.Min(frame.Right - borderThickness.Right, driver.Cols); c++)
	|                {
	|
	|                    AddRuneAt(driver, c, r, ' ');
	|                }
	|            }
	|
	|            SetBorderBrushBackground(driver);
	|
	|            // Draw the MarginFrame
	|            if (DrawMarginFrame)
	|            {
	|                var rect = new Rect()
	|                {
	|                    X = frame.X + sumThickness.Left,
	|                    Y = frame.Y + sumThickness.Top,
	|                    Width = Math.Max(frame.Width - sumThickness.Right - sumThickness.Left, 0),
	|                    Height = Math.Max(frame.Height - sumThickness.Bottom - sumThickness.Top, 0)
	|                };
	|                if (rect.Width > 0 && rect.Height > 0)
	|                {
	|                    driver.DrawWindowFrame(rect, 1, 1, 1, 1, BorderStyle != BorderStyle.None, fill, this);
	|                    DrawTitle(Parent);
	|                }
	|            }
	|
	|            if (Effect3D)
	|            {
	|                driver.SetAttribute(GetEffect3DBrush());
	|
	|                // Draw the upper Effect3D
	|                for (int r = Math.Max(frame.Y + effect3DOffset.Y, 0);
	|                    r < frame.Y; r++)
	|                {
	|                    for (int c = Math.Max(frame.X + effect3DOffset.X, 0);
	|                        c < Math.Min(frame.Right + effect3DOffset.X, driver.Cols); c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|
	|                // Draw the left Effect3D
	|                for (int r = Math.Max(frame.Y + effect3DOffset.Y, 0);
	|                    r < Math.Min(frame.Bottom + effect3DOffset.Y, driver.Rows); r++)
	|                {
	|                    for (int c = Math.Max(frame.X + effect3DOffset.X, 0);
	|                        c < frame.X; c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|
	|                // Draw the right Effect3D
	|                for (int r = Math.Max(frame.Y + effect3DOffset.Y, 0);
	|                    r < Math.Min(frame.Bottom + effect3DOffset.Y, driver.Rows); r++)
	|                {
	|                    for (int c = frame.Right;
	|                        c < Math.Min(frame.Right + effect3DOffset.X, driver.Cols); c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|
	|                // Draw the lower Effect3D
	|                for (int r = frame.Bottom;
	|                    r < Math.Min(frame.Bottom + effect3DOffset.Y, driver.Rows); r++)
	|                {
	|                    for (int c = Math.Max(frame.X + effect3DOffset.X, 0);
	|                        c < Math.Min(frame.Right + effect3DOffset.X, driver.Cols); c++)
	|                    {
	|
	|                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
	|                    }
	|                }
	|            }
	|            driver.SetAttribute(savedAttribute);
	|        }
	|
	|        private void SetBorderBrushBackground(ConsoleDriver driver)
	|        {
	|            if (borderBrush != null && background != null)
	|            {
	|                driver.SetAttribute(new Attribute(BorderBrush, Background));
	|            }
	|            else if (borderBrush != null && background == null)
	|            {
	|                driver.SetAttribute(new Attribute(BorderBrush, Parent.ColorScheme.Normal.Background));
	|            }
	|            else if (borderBrush == null && background != null)
	|            {
	|                driver.SetAttribute(new Attribute(Parent.ColorScheme.Normal.Foreground, Background));
	|            }
	|            else
	|            {
	|                driver.SetAttribute(Parent.ColorScheme.Normal);
	|            }
	|        }
	|
	|        private void SetBackground(ConsoleDriver driver)
	|        {
	|            if (background != null)
	|            {
	|                driver.SetAttribute(new Attribute(Background));
	|            }
	|            else
	|            {
	|                driver.SetAttribute(new Attribute(Parent.ColorScheme.Normal.Background));
	|            }
	|        }
	|
	|        private void SetBorderBrush(ConsoleDriver driver)
	|        {
	|            if (borderBrush != null)
	|            {
	|                driver.SetAttribute(new Attribute(BorderBrush));
	|            }
	|            else
	|            {
	|                driver.SetAttribute(new Attribute(Parent.ColorScheme.Normal.Foreground));
	|            }
	|        }
	|
	|        private Attribute GetEffect3DBrush()
	|        {
	|            return Effect3DBrush == null
	|                ? new Attribute(Color.Gray, Color.DarkGray)
	|                : (Attribute)Effect3DBrush;
	|        }
	|
	|        private void AddRuneAt(ConsoleDriver driver, int col, int row, Rune ch)
	|        {
	|            if (col < driver.Cols && row < driver.Rows && col > 0 && driver.Contents[row, col, 2] == 0
	|                && Rune.ColumnWidth((char)driver.Contents[row, col - 1, 0]) > 1)
	|            {
	|
	|                driver.Contents[row, col, 1] = driver.GetAttribute();
	|                return;
	|            }
	|            driver.Move(col, row);
	|            driver.AddRune(ch);
	|        }
	|
	|        /// <summary>
	|        /// Draws the view <see cref=""Title""/> to the screen.
	|        /// </summary>
	|        /// <param name=""view"">The view.</param>
	|        public void DrawTitle(View view)
	|        {
	|            var driver = Application.Driver;
	|            if (DrawMarginFrame)
	|            {
	|                SetBorderBrushBackground(driver);
	|                SetHotNormalBackground(view, driver);
	|                var padding = view.Border.GetSumThickness();
	|                Rect scrRect;
	|                if (view == Child)
	|                {
	|                    scrRect = view.ViewToScreen(new Rect(0, 0, view.Frame.Width + 2, view.Frame.Height + 2));
	|                    scrRect = new Rect(scrRect.X - 1, scrRect.Y - 1, scrRect.Width, scrRect.Height);
	|                    driver.DrawWindowTitle(scrRect, Title, 0, 0, 0, 0);
	|                }
	|                else
	|                {
	|                    scrRect = view.ViewToScreen(new Rect(0, 0, view.Frame.Width, view.Frame.Height));
	|                    driver.DrawWindowTitle(scrRect, Parent.Border.Title,
	|                        padding.Left, padding.Top, padding.Right, padding.Bottom);
	|                }
	|            }
	|            driver.SetAttribute(Child.GetNormalColor());
	|        }
	|
	|        private void SetHotNormalBackground(View view, ConsoleDriver driver)
	|        {
	|            if (view.HasFocus)
	|            {
	|                if (background != null)
	|                {
	|                    driver.SetAttribute(new Attribute(Child.ColorScheme.HotNormal.Foreground, Background));
	|                }
	|                else
	|                {
	|                    driver.SetAttribute(Child.ColorScheme.HotNormal);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Draws the <see cref=""View.Text""/> to the screen.
	|        /// </summary>
	|        /// <param name=""view"">The view.</param>
	|        /// <param name=""rect"">The frame.</param>
	|        public void DrawTitle(View view, Rect rect)
	|        {
	|            var driver = Application.Driver;
	|            if (DrawMarginFrame)
	|            {
	|                SetBorderBrushBackground(driver);
	|                SetHotNormalBackground(view, driver);
	|                var padding = Parent.Border.GetSumThickness();
	|                var scrRect = Parent.ViewToScreen(new Rect(0, 0, rect.Width, rect.Height));
	|                driver.DrawWindowTitle(scrRect, view.Text,
	|                    padding.Left, padding.Top, padding.Right, padding.Bottom);
	|            }
	|            driver.SetAttribute(view.GetNormalColor());
	|        }
	|
	|        /// <summary>
	|        /// Invoke the <see cref=""BorderChanged""/> event.
	|        /// </summary>
	|        public virtual void OnBorderChanged()
	|        {
	|            BorderChanged?.Invoke(this);
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // Button.cs: Button control
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    ///   Button is a <see cref=""View""/> that provides an item that invokes an <see cref=""Action""/> when activated by the user.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   Provides a button showing text invokes an <see cref=""Action""/> when clicked on with a mouse
	|    ///   or when the user presses SPACE, ENTER, or hotkey. The hotkey is the first letter or digit following the first underscore ('_') 
	|    ///   in the button text. 
	|    /// </para>
	|    /// <para>
	|    ///   Use <see cref=""View.HotKeySpecifier""/> to change the hotkey specifier from the default of ('_'). 
	|    /// </para>
	|    /// <para>
	|    ///   If no hotkey specifier is found, the first uppercase letter encountered will be used as the hotkey.
	|    /// </para>
	|    /// <para>
	|    ///   When the button is configured as the default (<see cref=""IsDefault""/>) and the user presses
	|    ///   the ENTER key, if no other <see cref=""View""/> processes the <see cref=""KeyEvent""/>, the <see cref=""Button""/>'s
	|    ///   <see cref=""Action""/> will be invoked.
	|    /// </para>
	|    /// </remarks>
	|    public class Button : View
	|    {
	|        bool is_default;
	|        Rune _leftBracket;
	|        Rune _rightBracket;
	|        Rune _leftDefault;
	|        Rune _rightDefault;
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""Button""/> using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        ///   The width of the <see cref=""Button""/> is computed based on the
	|        ///   text length. The height will always be 1.
	|        /// </remarks>
	|        public Button() : this(text: string.Empty, is_default: false) { }
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""Button""/> using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        ///   The width of the <see cref=""Button""/> is computed based on the
	|        ///   text length. The height will always be 1.
	|        /// </remarks>
	|        /// <param name=""text"">The button's text</param>
	|        /// <param name=""is_default"">
	|        ///   If <c>true</c>, a special decoration is used, and the user pressing the enter key 
	|        ///   in a <see cref=""Dialog""/> will implicitly activate this button.
	|        /// </param>
	|        public Button(ustring text, bool is_default = false) : base(text)
	|        {
	|            Initialize(text, is_default);
	|        }
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""Button""/> using <see cref=""LayoutStyle.Absolute""/> layout, based on the given text
	|        /// </summary>
	|        /// <remarks>
	|        ///   The width of the <see cref=""Button""/> is computed based on the
	|        ///   text length. The height will always be 1.
	|        /// </remarks>
	|        /// <param name=""x"">X position where the button will be shown.</param>
	|        /// <param name=""y"">Y position where the button will be shown.</param>
	|        /// <param name=""text"">The button's text</param>
	|        public Button(int x, int y, ustring text) : this(x, y, text, false) { }
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""Button""/> using <see cref=""LayoutStyle.Absolute""/> layout, based on the given text.
	|        /// </summary>
	|        /// <remarks>
	|        ///   The width of the <see cref=""Button""/> is computed based on the
	|        ///   text length. The height will always be 1.
	|        /// </remarks>
	|        /// <param name=""x"">X position where the button will be shown.</param>
	|        /// <param name=""y"">Y position where the button will be shown.</param>
	|        /// <param name=""text"">The button's text</param>
	|        /// <param name=""is_default"">
	|        ///   If <c>true</c>, a special decoration is used, and the user pressing the enter key 
	|        ///   in a <see cref=""Dialog""/> will implicitly activate this button.
	|        /// </param>
	|        public Button(int x, int y, ustring text, bool is_default)
	|            : base(new Rect(x, y, text.RuneCount + 4 + (is_default ? 2 : 0), 1), text)
	|        {
	|            Initialize(text, is_default);
	|        }
	|
	|        void Initialize(ustring text, bool is_default)
	|        {
	|            TextAlignment = TextAlignment.Centered;
	|            VerticalTextAlignment = VerticalTextAlignment.Middle;
	|
	|            HotKeySpecifier = new Rune('_');
	|
	|            _leftBracket = new Rune(Driver != null ? Driver.LeftBracket : '[');
	|            _rightBracket = new Rune(Driver != null ? Driver.RightBracket : ']');
	|            _leftDefault = new Rune(Driver != null ? Driver.LeftDefaultIndicator : '<');
	|            _rightDefault = new Rune(Driver != null ? Driver.RightDefaultIndicator : '>');
	|
	|            CanFocus = true;
	|            AutoSize = true;
	|            this.is_default = is_default;
	|            Text = text ?? string.Empty;
	|            UpdateTextFormatterText();
	|            ProcessResizeView();
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.Accept, () => AcceptKey());
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.Enter, Command.Accept);
	|            AddKeyBinding(Key.Space, Command.Accept);
	|            if (HotKey != Key.Null)
	|            {
	|                AddKeyBinding(Key.Space | HotKey, Command.Accept);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets whether the <see cref=""Button""/> is the default action to activate in a dialog.
	|        /// </summary>
	|        /// <value><c>true</c> if is default; otherwise, <c>false</c>.</value>
	|        /// <remarks>
	|        /// If is <see langword=""true""/> the current focused view
	|        /// will remain focused if the window is not closed.
	|        /// </remarks>
	|        public bool IsDefault
	|        {
	|            get => is_default;
	|            set
	|            {
	|                is_default = value;
	|                UpdateTextFormatterText();
	|                ProcessResizeView();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override Key HotKey
	|        {
	|            get => base.HotKey;
	|            set
	|            {
	|                if (base.HotKey != value)
	|                {
	|                    var v = value == Key.Unknown ? Key.Null : value;
	|                    if (base.HotKey != Key.Null && ContainsKeyBinding(Key.Space | base.HotKey))
	|                    {
	|                        if (v == Key.Null)
	|                        {
	|                            ClearKeybinding(Key.Space | base.HotKey);
	|                        }
	|                        else
	|                        {
	|                            ReplaceKeyBinding(Key.Space | base.HotKey, Key.Space | v);
	|                        }
	|                    }
	|                    else if (v != Key.Null)
	|                    {
	|                        AddKeyBinding(Key.Space | v, Command.Accept);
	|                    }
	|                    base.HotKey = TextFormatter.HotKey = v;
	|                }
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        protected override void UpdateTextFormatterText()
	|        {
	|            if (IsDefault)
	|                TextFormatter.Text = ustring.Make(_leftBracket) + ustring.Make(_leftDefault) + "" "" + Text + "" "" + ustring.Make(_rightDefault) + ustring.Make(_rightBracket);
	|            else
	|                TextFormatter.Text = ustring.Make(_leftBracket) + "" "" + Text + "" "" + ustring.Make(_rightBracket);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessHotKey(KeyEvent kb)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            return ExecuteHotKey(kb);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessColdKey(KeyEvent kb)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            return ExecuteColdKey(kb);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            return base.ProcessKey(kb);
	|        }
	|
	|        bool ExecuteHotKey(KeyEvent ke)
	|        {
	|            if (ke.Key == (Key.AltMask | HotKey))
	|            {
	|                return AcceptKey();
	|            }
	|            return false;
	|        }
	|
	|        bool ExecuteColdKey(KeyEvent ke)
	|        {
	|            if (IsDefault && ke.KeyValue == '\n')
	|            {
	|                return AcceptKey();
	|            }
	|            return ExecuteHotKey(ke);
	|        }
	|
	|        bool AcceptKey()
	|        {
	|            if (!IsDefault && !HasFocus)
	|            {
	|                SetFocus();
	|            }
	|            OnClicked();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Virtual method to invoke the <see cref=""Clicked""/> event.
	|        /// </summary>
	|        public virtual void OnClicked()
	|        {
	|            Clicked?.Invoke();
	|        }
	|
	|        /// <summary>
	|        ///   Clicked <see cref=""Action""/>, raised when the user clicks the primary mouse button within the Bounds of this <see cref=""View""/>
	|        ///   or if the user presses the action key while this view is focused. (TODO: IsDefault)
	|        /// </summary>
	|        /// <remarks>
	|        ///   Client code can hook up to this event, it is
	|        ///   raised when the button is activated either with
	|        ///   the mouse or the keyboard.
	|        /// </remarks>
	|        public event Action Clicked;
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (me.Flags == MouseFlags.Button1Clicked)
	|            {
	|                if (CanFocus && Enabled)
	|                {
	|                    if (!HasFocus)
	|                    {
	|                        SetFocus();
	|                        SetNeedsDisplay();
	|                        Redraw(Bounds);
	|                    }
	|                    OnClicked();
	|                }
	|
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            if (HotKey == Key.Unknown && Text != """")
	|            {
	|                for (int i = 0; i < TextFormatter.Text.RuneCount; i++)
	|                {
	|                    if (TextFormatter.Text[i] == Text[0])
	|                    {
	|                        Move(i, 0);
	|                        return;
	|                    }
	|                }
	|            }
	|            base.PositionCursor();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // Checkbox.cs: Checkbox control
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    /// The <see cref=""CheckBox""/> <see cref=""View""/> shows an on/off toggle that the user can set
	|    /// </summary>
	|    public class CheckBox : View
	|    {
	|        Rune charChecked;
	|        Rune charUnChecked;
	|        bool @checked;
	|
	|        /// <summary>
	|        ///   Toggled event, raised when the <see cref=""CheckBox""/>  is toggled.
	|        /// </summary>
	|        /// <remarks>
	|        ///   Client code can hook up to this event, it is
	|        ///   raised when the <see cref=""CheckBox""/> is activated either with
	|        ///   the mouse or the keyboard. The passed <c>bool</c> contains the previous state. 
	|        /// </remarks>
	|        public event Action<bool> Toggled;
	|
	|        /// <summary>
	|        /// Called when the <see cref=""Checked""/> property changes. Invokes the <see cref=""Toggled""/> event.
	|        /// </summary>
	|        public virtual void OnToggled(bool previousChecked)
	|        {
	|            Toggled?.Invoke(previousChecked);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""CheckBox""/> based on the given text, using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        public CheckBox() : this(string.Empty) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""CheckBox""/> based on the given text, using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <param name=""s"">S.</param>
	|        /// <param name=""is_checked"">If set to <c>true</c> is checked.</param>
	|        public CheckBox(ustring s, bool is_checked = false) : base()
	|        {
	|            Initialize(s, is_checked);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""CheckBox""/> using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        ///   The size of <see cref=""CheckBox""/> is computed based on the
	|        ///   text length. This <see cref=""CheckBox""/> is not toggled.
	|        /// </remarks>
	|        public CheckBox(int x, int y, ustring s) : this(x, y, s, false)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""CheckBox""/> using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        ///   The size of <see cref=""CheckBox""/> is computed based on the
	|        ///   text length. 
	|        /// </remarks>
	|        public CheckBox(int x, int y, ustring s, bool is_checked) : base(new Rect(x, y, s.Length, 1))
	|        {
	|            Initialize(s, is_checked);
	|        }
	|
	|        void Initialize(ustring s, bool is_checked)
	|        {
	|            charChecked = new Rune(Driver != null ? Driver.Checked : '√');
	|            charUnChecked = new Rune(Driver != null ? Driver.UnChecked : '╴');
	|            Checked = is_checked;
	|            HotKeySpecifier = new Rune('_');
	|            CanFocus = true;
	|            AutoSize = true;
	|            Text = s;
	|            UpdateTextFormatterText();
	|            ProcessResizeView();
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.ToggleChecked, () => ToggleChecked());
	|
	|            // Default keybindings for this view
	|            AddKeyBinding((Key)' ', Command.ToggleChecked);
	|            AddKeyBinding(Key.Space, Command.ToggleChecked);
	|        }
	|
	|        /// <inheritdoc/>
	|        protected override void UpdateTextFormatterText()
	|        {
	|            switch (TextAlignment)
	|            {
	|                case TextAlignment.Left:
	|                case TextAlignment.Centered:
	|                case TextAlignment.Justified:
	|                    TextFormatter.Text = ustring.Make(Checked ? charChecked : charUnChecked) + "" "" + GetFormatterText();
	|                    break;
	|                case TextAlignment.Right:
	|                    TextFormatter.Text = GetFormatterText() + "" "" + ustring.Make(Checked ? charChecked : charUnChecked);
	|                    break;
	|            }
	|        }
	|
	|        ustring GetFormatterText()
	|        {
	|            if (AutoSize || ustring.IsNullOrEmpty(Text) || Frame.Width <= 2)
	|            {
	|                return Text;
	|            }
	|            return Text.RuneSubstring(0, Math.Min(Frame.Width - 2, Text.RuneCount));
	|        }
	|
	|        /// <summary>
	|        ///    The state of the <see cref=""CheckBox""/>
	|        /// </summary>
	|        public bool Checked
	|        {
	|            get => @checked;
	|            set
	|            {
	|                @checked = value;
	|                UpdateTextFormatterText();
	|                ProcessResizeView();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            Move(0, 0);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            return base.ProcessKey(kb);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessHotKey(KeyEvent kb)
	|        {
	|            if (kb.Key == (Key.AltMask | HotKey))
	|                return ToggleChecked();
	|
	|            return false;
	|        }
	|
	|        bool ToggleChecked()
	|        {
	|            if (!HasFocus)
	|            {
	|                SetFocus();
	|            }
	|            var previousChecked = Checked;
	|            Checked = !Checked;
	|            OnToggled(previousChecked);
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) || !CanFocus)
	|                return false;
	|
	|            SetFocus();
	|            var previousChecked = Checked;
	|            Checked = !Checked;
	|            OnToggled(previousChecked);
	|            SetNeedsDisplay();
	|
	|            return true;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Provides cut, copy, and paste support for the OS clipboard.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    /// On Windows, the <see cref=""Clipboard""/> class uses the Windows Clipboard APIs via P/Invoke.
	|    /// </para>
	|    /// <para>
	|    /// On Linux, when not running under Windows Subsystem for Linux (WSL),
	|    /// the <see cref=""Clipboard""/> class uses the xclip command line tool. If xclip is not installed,
	|    /// the clipboard will not work.
	|    /// </para>
	|    /// <para>
	|    /// On Linux, when running under Windows Subsystem for Linux (WSL),
	|    /// the <see cref=""Clipboard""/> class launches Windows' powershell.exe via WSL interop and uses the
	|    /// ""Set-Clipboard"" and ""Get-Clipboard"" Powershell CmdLets. 
	|    /// </para>
	|    /// <para>
	|    /// On the Mac, the <see cref=""Clipboard""/> class uses the MacO OS X pbcopy and pbpaste command line tools
	|    /// and the Mac clipboard APIs vai P/Invoke.
	|    /// </para>
	|    /// </remarks>
	|    public static class Clipboard
	|    {
	|        static ustring contents;
	|
	|        /// <summary>
	|        /// Gets (copies from) or sets (pastes to) the contents of the OS clipboard.
	|        /// </summary>
	|        public static ustring Contents
	|        {
	|            get
	|            {
	|                try
	|                {
	|                    if (IsSupported)
	|                    {
	|                        return contents = ustring.Make(Application.Driver.Clipboard.GetClipboardData());
	|                    }
	|                    else
	|                    {
	|                        return contents;
	|                    }
	|                }
	|                catch (Exception)
	|                {
	|                    return contents;
	|                }
	|            }
	|            set
	|            {
	|                try
	|                {
	|                    if (IsSupported)
	|                    {
	|                        if (value == null)
	|                        {
	|                            value = string.Empty;
	|                        }
	|                        Application.Driver.Clipboard.SetClipboardData(value.ToString());
	|                    }
	|                    contents = value;
	|                }
	|                catch (NotSupportedException)
	|                {
	|                    throw;
	|                }
	|                catch (Exception)
	|                {
	|                    contents = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the environmental dependencies are in place to interact with the OS clipboard.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public static bool IsSupported { get => Application.Driver.Clipboard.IsSupported; }
	|
	|        /// <summary>
	|        /// Copies the contents of the OS clipboard to <paramref name=""result""/> if possible.
	|        /// </summary>
	|        /// <param name=""result"">The contents of the OS clipboard if successful, <see cref=""string.Empty""/> if not.</param>
	|        /// <returns><see langword=""true""/> the OS clipboard was retrieved, <see langword=""false""/> otherwise.</returns>
	|        public static bool TryGetClipboardData(out string result)
	|        {
	|            if (IsSupported && Application.Driver.Clipboard.TryGetClipboardData(out result))
	|            {
	|                if (contents != result)
	|                {
	|                    contents = result;
	|                }
	|                return true;
	|            }
	|            result = string.Empty;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Pastes the <paramref name=""text""/> to the OS clipboard if possible.
	|        /// </summary>
	|        /// <param name=""text"">The text to paste to the OS clipboard.</param>
	|        /// <returns><see langword=""true""/> the OS clipboard was set, <see langword=""false""/> otherwise.</returns>
	|        public static bool TrySetClipboardData(string text)
	|        {
	|            if (IsSupported && Application.Driver.Clipboard.TrySetClipboardData(text))
	|            {
	|                contents = text;
	|                return true;
	|            }
	|            return false;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Shared abstract class to enforce rules from the implementation of the <see cref=""IClipboard""/> interface.
	|    /// </summary>
	|    public abstract class ClipboardBase : IClipboard
	|    {
	|        /// <summary>
	|        /// Returns true if the environmental dependencies are in place to interact with the OS clipboard
	|        /// </summary>
	|        public abstract bool IsSupported { get; }
	|
	|        /// <summary>
	|        /// Returns the contents of the OS clipboard if possible.
	|        /// </summary>
	|        /// <returns>The contents of the OS clipboard if successful.</returns>
	|        /// <exception cref=""NotSupportedException"">Thrown if it was not possible to copy from the OS clipboard.</exception>
	|        public string GetClipboardData()
	|        {
	|            try
	|            {
	|                return GetClipboardDataImpl();
	|            }
	|            catch (NotSupportedException ex)
	|            {
	|                throw new NotSupportedException(""Failed to copy from the OS clipboard."", ex);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the contents of the OS clipboard if possible. Implemented by <see cref=""ConsoleDriver""/>-specific subclasses.
	|        /// </summary>
	|        /// <returns>The contents of the OS clipboard if successful.</returns>
	|        /// <exception cref=""NotSupportedException"">Thrown if it was not possible to copy from the OS clipboard.</exception>
	|        protected abstract string GetClipboardDataImpl();
	|
	|        /// <summary>
	|        /// Pastes the <paramref name=""text""/> to the OS clipboard if possible.
	|        /// </summary>
	|        /// <param name=""text"">The text to paste to the OS clipboard.</param>
	|        /// <exception cref=""NotSupportedException"">Thrown if it was not possible to paste to the OS clipboard.</exception>
	|        public void SetClipboardData(string text)
	|        {
	|            try
	|            {
	|                SetClipboardDataImpl(text);
	|            }
	|            catch (NotSupportedException ex)
	|            {
	|                throw new NotSupportedException(""Failed to paste to the OS clipboard."", ex);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Pastes the <paramref name=""text""/> to the OS clipboard if possible. Implemented by <see cref=""ConsoleDriver""/>-specific subclasses.
	|        /// </summary>
	|        /// <param name=""text"">The text to paste to the OS clipboard.</param>
	|        /// <exception cref=""NotSupportedException"">Thrown if it was not possible to paste to the OS clipboard.</exception>
	|        protected abstract void SetClipboardDataImpl(string text);
	|
	|        /// <summary>
	|        /// Copies the contents of the OS clipboard to <paramref name=""result""/> if possible.
	|        /// </summary>
	|        /// <param name=""result"">The contents of the OS clipboard if successful, <see cref=""string.Empty""/> if not.</param>
	|        /// <returns><see langword=""true""/> the OS clipboard was retrieved, <see langword=""false""/> otherwise.</returns>
	|        public bool TryGetClipboardData(out string result)
	|        {
	|            // Don't even try to read because environment is not set up.
	|            if (!IsSupported)
	|            {
	|                result = null;
	|                return false;
	|            }
	|
	|            try
	|            {
	|                result = GetClipboardDataImpl();
	|                while (result == null)
	|                {
	|                    result = GetClipboardDataImpl();
	|                }
	|                return true;
	|            }
	|            catch (NotSupportedException ex)
	|            {
	|                System.Diagnostics.Debug.WriteLine($""TryGetClipboardData: {ex.Message}"");
	|                result = null;
	|                return false;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Pastes the <paramref name=""text""/> to the OS clipboard if possible.
	|        /// </summary>
	|        /// <param name=""text"">The text to paste to the OS clipboard.</param>
	|        /// <returns><see langword=""true""/> the OS clipboard was set, <see langword=""false""/> otherwise.</returns>
	|        public bool TrySetClipboardData(string text)
	|        {
	|            // Don't even try to set because environment is not set up
	|            if (!IsSupported)
	|            {
	|                return false;
	|            }
	|
	|            try
	|            {
	|                SetClipboardDataImpl(text);
	|                return true;
	|            }
	|            catch (NotSupportedException ex)
	|            {
	|                System.Diagnostics.Debug.WriteLine($""TrySetClipboardData: {ex.Message}"");
	|                return false;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Navigates a collection of items using keystrokes. The keystrokes are used to build a search string. 
	|    /// The <see cref=""SearchString""/> is used to find the next item in the collection that matches the search string
	|    /// when <see cref=""GetNextMatchingItem(int, char)""/> is called.
	|    /// <para>
	|    /// If the user types keystrokes that can't be found in the collection, 
	|    /// the search string is cleared and the next item is found that starts with the last keystroke.
	|    /// </para>
	|    /// <para>
	|    /// If the user pauses keystrokes for a short time (see <see cref=""TypingDelay""/>), the search string is cleared.
	|    /// </para>
	|    /// </summary>
	|    public class CollectionNavigator
	|    {
	|        /// <summary>
	|        /// Constructs a new CollectionNavigator.
	|        /// </summary>
	|        public CollectionNavigator() { }
	|
	|        /// <summary>
	|        /// Constructs a new CollectionNavigator for the given collection.
	|        /// </summary>
	|        /// <param name=""collection""></param>
	|        public CollectionNavigator(IEnumerable<object> collection) => Collection = collection;
	|
	|        DateTime lastKeystroke = DateTime.Now;
	|        /// <summary>
	|        /// Gets or sets the number of milliseconds to delay before clearing the search string. The delay is
	|        /// reset on each call to <see cref=""GetNextMatchingItem(int, char)""/>. The default is 500ms.
	|        /// </summary>
	|        public int TypingDelay { get; set; } = 500;
	|
	|        /// <summary>
	|        /// The compararer function to use when searching the collection.
	|        /// </summary>
	|        public StringComparer Comparer { get; set; } = StringComparer.InvariantCultureIgnoreCase;
	|
	|        /// <summary>
	|        /// The collection of objects to search. <see cref=""object.ToString()""/> is used to search the collection.
	|        /// </summary>
	|        public IEnumerable<object> Collection { get; set; }
	|
	|        /// <summary>
	|        /// Event arguments for the <see cref=""CollectionNavigator.SearchStringChanged""/> event.
	|        /// </summary>
	|        public class KeystrokeNavigatorEventArgs
	|        {
	|            /// <summary>
	|            /// he current <see cref=""SearchString""/>.
	|            /// </summary>
	|            public string SearchString { get; }
	|
	|            /// <summary>
	|            /// Initializes a new instance of <see cref=""KeystrokeNavigatorEventArgs""/>
	|            /// </summary>
	|            /// <param name=""searchString"">The current <see cref=""SearchString""/>.</param>
	|            public KeystrokeNavigatorEventArgs(string searchString)
	|            {
	|                SearchString = searchString;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This event is invoked when <see cref=""SearchString""/>  changes. Useful for debugging.
	|        /// </summary>
	|        public event Action<KeystrokeNavigatorEventArgs> SearchStringChanged;
	|
	|        private string _searchString = """";
	|        /// <summary>
	|        /// Gets the current search string. This includes the set of keystrokes that have been pressed
	|        /// since the last unsuccessful match or after <see cref=""TypingDelay""/>) milliseconds. Useful for debugging.
	|        /// </summary>
	|        public string SearchString
	|        {
	|            get => _searchString;
	|            private set
	|            {
	|                _searchString = value;
	|                OnSearchStringChanged(new KeystrokeNavigatorEventArgs(value));
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Invoked when the <see cref=""SearchString""/> changes. Useful for debugging. Invokes the <see cref=""SearchStringChanged""/> event.
	|        /// </summary>
	|        /// <param name=""e""></param>
	|        public virtual void OnSearchStringChanged(KeystrokeNavigatorEventArgs e)
	|        {
	|            SearchStringChanged?.Invoke(e);
	|        }
	|
	|        /// <summary>
	|        /// Gets the index of the next item in the collection that matches the current <see cref=""SearchString""/> plus the provided character (typically
	|        /// from a key press).
	|        /// </summary>
	|        /// <param name=""currentIndex"">The index in the collection to start the search from.</param>
	|        /// <param name=""keyStruck"">The character of the key the user pressed.</param>
	|        /// <returns>The index of the item that matches what the user has typed. 
	|        /// Returns <see langword=""-1""/> if no item in the collection matched.</returns>
	|        public int GetNextMatchingItem(int currentIndex, char keyStruck)
	|        {
	|            AssertCollectionIsNotNull();
	|            if (!char.IsControl(keyStruck))
	|            {
	|
	|                // maybe user pressed 'd' and now presses 'd' again.
	|                // a candidate search is things that begin with ""dd""
	|                // but if we find none then we must fallback on cycling
	|                // d instead and discard the candidate state
	|                string candidateState = """";
	|
	|                // is it a second or third (etc) keystroke within a short time
	|                if (SearchString.Length > 0 && DateTime.Now - lastKeystroke < TimeSpan.FromMilliseconds(TypingDelay))
	|                {
	|                    // ""dd"" is a candidate
	|                    candidateState = SearchString + keyStruck;
	|                }
	|                else
	|                {
	|                    // its a fresh keystroke after some time
	|                    // or its first ever key press
	|                    SearchString = new string(keyStruck, 1);
	|                }
	|
	|                var idxCandidate = GetNextMatchingItem(currentIndex, candidateState,
	|                    // prefer not to move if there are multiple characters e.g. ""ca"" + 'r' should stay on ""car"" and not jump to ""cart""
	|                    candidateState.Length > 1);
	|
	|                if (idxCandidate != -1)
	|                {
	|                    // found ""dd"" so candidate searchstring is accepted
	|                    lastKeystroke = DateTime.Now;
	|                    SearchString = candidateState;
	|                    return idxCandidate;
	|                }
	|
	|                //// nothing matches ""dd"" so discard it as a candidate
	|                //// and just cycle ""d"" instead
	|                lastKeystroke = DateTime.Now;
	|                idxCandidate = GetNextMatchingItem(currentIndex, candidateState);
	|
	|                // if a match wasn't found, the user typed a 'wrong' key in their search (""can"" + 'z'
	|                // instead of ""can"" + 'd').
	|                if (SearchString.Length > 1 && idxCandidate == -1)
	|                {
	|                    // ignore it since we're still within the typing delay
	|                    // don't add it to SearchString either
	|                    return currentIndex;
	|                }
	|
	|                // if no changes to current state manifested
	|                if (idxCandidate == currentIndex || idxCandidate == -1)
	|                {
	|                    // clear history and treat as a fresh letter
	|                    ClearSearchString();
	|
	|                    // match on the fresh letter alone
	|                    SearchString = new string(keyStruck, 1);
	|                    idxCandidate = GetNextMatchingItem(currentIndex, SearchString);
	|                    return idxCandidate == -1 ? currentIndex : idxCandidate;
	|                }
	|
	|                // Found another ""d"" or just leave index as it was
	|                return idxCandidate;
	|
	|            }
	|            else
	|            {
	|                // clear state because keypress was a control char
	|                ClearSearchString();
	|
	|                // control char indicates no selection
	|                return -1;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the index of the next item in the collection that matches <paramref name=""search""/>. 
	|        /// </summary>
	|        /// <param name=""currentIndex"">The index in the collection to start the search from.</param>
	|        /// <param name=""search"">The search string to use.</param>
	|        /// <param name=""minimizeMovement"">Set to <see langword=""true""/> to stop the search on the first match
	|        /// if there are multiple matches for <paramref name=""search""/>.
	|        /// e.g. ""ca"" + 'r' should stay on ""car"" and not jump to ""cart"". If <see langword=""false""/> (the default), 
	|        /// the next matching item will be returned, even if it is above in the collection.
	|        /// </param>
	|        /// <returns>The index of the next matching item or <see langword=""-1""/> if no match was found.</returns>
	|        internal int GetNextMatchingItem(int currentIndex, string search, bool minimizeMovement = false)
	|        {
	|            if (string.IsNullOrEmpty(search))
	|            {
	|                return -1;
	|            }
	|            AssertCollectionIsNotNull();
	|
	|            // find indexes of items that start with the search text
	|            int[] matchingIndexes = Collection.Select((item, idx) => (item, idx))
	|                  .Where(k => k.item?.ToString().StartsWith(search, StringComparison.InvariantCultureIgnoreCase) ?? false)
	|                  .Select(k => k.idx)
	|                  .ToArray();
	|
	|            // if there are items beginning with search
	|            if (matchingIndexes.Length > 0)
	|            {
	|                // is one of them currently selected?
	|                var currentlySelected = Array.IndexOf(matchingIndexes, currentIndex);
	|
	|                if (currentlySelected == -1)
	|                {
	|                    // we are not currently selecting any item beginning with the search
	|                    // so jump to first item in list that begins with the letter
	|                    return matchingIndexes[0];
	|                }
	|                else
	|                {
	|
	|                    // the current index is part of the matching collection
	|                    if (minimizeMovement)
	|                    {
	|                        // if we would rather not jump around (e.g. user is typing lots of text to get this match)
	|                        return matchingIndexes[currentlySelected];
	|                    }
	|
	|                    // cycle to next (circular)
	|                    return matchingIndexes[(currentlySelected + 1) % matchingIndexes.Length];
	|                }
	|            }
	|
	|            // nothing starts with the search
	|            return -1;
	|        }
	|
	|        private void AssertCollectionIsNotNull()
	|        {
	|            if (Collection == null)
	|            {
	|                throw new InvalidOperationException(""Collection is null"");
	|            }
	|        }
	|
	|        private void ClearSearchString()
	|        {
	|            SearchString = """";
	|            lastKeystroke = DateTime.Now;
	|        }
	|
	|        /// <summary>
	|        /// Returns true if <paramref name=""kb""/> is a searchable key
	|        /// (e.g. letters, numbers etc) that is valid to pass to to this
	|        /// class for search filtering.
	|        /// </summary>
	|        /// <param name=""kb""></param>
	|        /// <returns></returns>
	|        public static bool IsCompatibleKey(KeyEvent kb)
	|        {
	|            return !kb.IsAlt && !kb.IsCapslock && !kb.IsCtrl && !kb.IsScrolllock && !kb.IsNumlock;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// The <see cref=""ColorPicker""/> <see cref=""View""/> Color picker.
	|    /// </summary>
	|    public class ColorPicker : View
	|    {
	|        /// <summary>
	|        /// Number of colors on a line.
	|        /// </summary>
	|        private static readonly int colorsPerLine = 8;
	|
	|        /// <summary>
	|        /// Number of color lines.
	|        /// </summary>
	|        private static readonly int lineCount = 2;
	|
	|        /// <summary>
	|        /// Horizontal zoom.
	|        /// </summary>
	|        private static readonly int horizontalZoom = 4;
	|
	|        /// <summary>
	|        /// Vertical zoom.
	|        /// </summary>
	|        private static readonly int verticalZoom = 2;
	|
	|        // Cursor runes.
	|        private static readonly Rune[] cursorRunes = new Rune[]
	|        {
	|            0x250C, 0x2500, 0x2500, 0x2510,
	|            0x2514, 0x2500, 0x2500, 0x2518
	|        };
	|
	|        /// <summary>
	|        /// Cursor for the selected color.
	|        /// </summary>
	|        public Point Cursor
	|        {
	|            get
	|            {
	|                return new Point(selectColorIndex % colorsPerLine, selectColorIndex / colorsPerLine);
	|            }
	|
	|            set
	|            {
	|                var colorIndex = value.Y * colorsPerLine + value.X;
	|                SelectedColor = (Color)colorIndex;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Fired when a color is picked.
	|        /// </summary>
	|        public event Action ColorChanged;
	|
	|        private int selectColorIndex = (int)Color.Black;
	|
	|        /// <summary>
	|        /// Selected color.
	|        /// </summary>
	|        public Color SelectedColor
	|        {
	|            get
	|            {
	|                return (Color)selectColorIndex;
	|            }
	|
	|            set
	|            {
	|                selectColorIndex = (int)value;
	|                ColorChanged?.Invoke();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ColorPicker""/>.
	|        /// </summary>
	|        public ColorPicker() : base(""Color Picker"")
	|        {
	|            Initialize();
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ColorPicker""/>.
	|        /// </summary>
	|        /// <param name=""title"">Title.</param>
	|        public ColorPicker(ustring title) : base(title)
	|        {
	|            Initialize();
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ColorPicker""/>.
	|        /// </summary>
	|        /// <param name=""point"">Location point.</param>
	|        /// <param name=""title"">Title.</param>
	|        public ColorPicker(Point point, ustring title) : this(point.X, point.Y, title)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ColorPicker""/>.
	|        /// </summary>
	|        /// <param name=""x"">X location.</param>
	|        /// <param name=""y"">Y location.</param>
	|        /// <param name=""title"">Title</param>
	|        public ColorPicker(int x, int y, ustring title) : base(x, y, title)
	|        {
	|            Initialize();
	|        }
	|
	|        private void Initialize()
	|        {
	|            CanFocus = true;
	|            Width = colorsPerLine * horizontalZoom;
	|            Height = lineCount * verticalZoom + 1;
	|
	|            AddCommands();
	|            AddKeyBindings();
	|        }
	|
	|        /// <summary>
	|        /// Add the commands.
	|        /// </summary>
	|        private void AddCommands()
	|        {
	|            AddCommand(Command.Left, () => MoveLeft());
	|            AddCommand(Command.Right, () => MoveRight());
	|            AddCommand(Command.LineUp, () => MoveUp());
	|            AddCommand(Command.LineDown, () => MoveDown());
	|        }
	|
	|        /// <summary>
	|        /// Add the KeyBindinds.
	|        /// </summary>
	|        private void AddKeyBindings()
	|        {
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            base.Redraw(bounds);
	|
	|            Driver.SetAttribute(HasFocus ? ColorScheme.Focus : GetNormalColor());
	|            var colorIndex = 0;
	|
	|            for (var y = 0; y < (Height.Anchor(0) - 1) / verticalZoom; y++)
	|            {
	|                for (var x = 0; x < Width.Anchor(0) / horizontalZoom; x++)
	|                {
	|                    var foregroundColorIndex = y == 0 ? colorIndex + colorsPerLine : colorIndex - colorsPerLine;
	|                    Driver.SetAttribute(Driver.MakeAttribute((Color)foregroundColorIndex, (Color)colorIndex));
	|                    var selected = x == Cursor.X && y == Cursor.Y;
	|                    DrawColorBox(x, y, selected);
	|                    colorIndex++;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Draw a box for one color.
	|        /// </summary>
	|        /// <param name=""x"">X location.</param>
	|        /// <param name=""y"">Y location</param>
	|        /// <param name=""selected""></param>
	|        private void DrawColorBox(int x, int y, bool selected)
	|        {
	|            var index = 0;
	|
	|            for (var zommedY = 0; zommedY < verticalZoom; zommedY++)
	|            {
	|                for (var zommedX = 0; zommedX < horizontalZoom; zommedX++)
	|                {
	|                    Move(x * horizontalZoom + zommedX, y * verticalZoom + zommedY + 1);
	|
	|                    if (selected)
	|                    {
	|                        var character = cursorRunes[index];
	|                        Driver.AddRune(character);
	|                    }
	|                    else
	|                    {
	|                        Driver.AddRune(' ');
	|                    }
	|
	|                    index++;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Moves the selected item index to the previous column.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveLeft()
	|        {
	|            if (Cursor.X > 0) SelectedColor--;
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Moves the selected item index to the next column.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveRight()
	|        {
	|            if (Cursor.X < colorsPerLine - 1) SelectedColor++;
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Moves the selected item index to the previous row.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveUp()
	|        {
	|            if (Cursor.Y > 0) SelectedColor -= colorsPerLine;
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Moves the selected item index to the next row.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveDown()
	|        {
	|            if (Cursor.Y < lineCount - 1) SelectedColor += colorsPerLine;
	|            return true;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) || !CanFocus)
	|                return false;
	|
	|            SetFocus();
	|            Cursor = new Point(me.X / horizontalZoom, (me.Y - 1) / verticalZoom);
	|
	|            return true;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // ComboBox.cs: ComboBox control
	|    //
	|    // Authors:
	|    //   Ross Ferguson (ross.c.ferguson@btinternet.com)
	|    //
	|
	|    /// <summary>
	|    /// Provides a drop-down list of items the user can select from.
	|    /// </summary>
	|    public class ComboBox : View
	|    {
	|
	|        private class ComboListView : ListView
	|        {
	|            private int highlighted = -1;
	|            private bool isFocusing;
	|            private ComboBox container;
	|            private bool hideDropdownListOnClick;
	|
	|            public ComboListView(ComboBox container, bool hideDropdownListOnClick)
	|            {
	|                Initialize(container, hideDropdownListOnClick);
	|            }
	|
	|            public ComboListView(ComboBox container, Rect rect, IList source, bool hideDropdownListOnClick) : base(rect, source)
	|            {
	|                Initialize(container, hideDropdownListOnClick);
	|            }
	|
	|            public ComboListView(ComboBox container, IList source, bool hideDropdownListOnClick) : base(source)
	|            {
	|                Initialize(container, hideDropdownListOnClick);
	|            }
	|
	|            private void Initialize(ComboBox container, bool hideDropdownListOnClick)
	|            {
	|                this.container = container ?? throw new ArgumentNullException(nameof(container), ""ComboBox container cannot be null."");
	|                HideDropdownListOnClick = hideDropdownListOnClick;
	|            }
	|
	|            public bool HideDropdownListOnClick
	|            {
	|                get => hideDropdownListOnClick;
	|                set => hideDropdownListOnClick = WantContinuousButtonPressed = value;
	|            }
	|
	|            public override bool MouseEvent(MouseEvent me)
	|            {
	|                var res = false;
	|                var isMousePositionValid = IsMousePositionValid(me);
	|
	|                if (isMousePositionValid)
	|                {
	|                    res = base.MouseEvent(me);
	|                }
	|
	|                if (HideDropdownListOnClick && me.Flags == MouseFlags.Button1Clicked)
	|                {
	|                    if (!isMousePositionValid && !isFocusing)
	|                    {
	|                        container.isShow = false;
	|                        container.HideList();
	|                    }
	|                    else if (isMousePositionValid)
	|                    {
	|                        OnOpenSelectedItem();
	|                    }
	|                    else
	|                    {
	|                        isFocusing = false;
	|                    }
	|                    return true;
	|                }
	|                else if (me.Flags == MouseFlags.ReportMousePosition && HideDropdownListOnClick)
	|                {
	|                    if (isMousePositionValid)
	|                    {
	|                        highlighted = Math.Min(TopItem + me.Y, Source.Count);
	|                        SetNeedsDisplay();
	|                    }
	|                    isFocusing = false;
	|                    return true;
	|                }
	|
	|                return res;
	|            }
	|
	|            private bool IsMousePositionValid(MouseEvent me)
	|            {
	|                if (me.X >= 0 && me.X < Frame.Width && me.Y >= 0 && me.Y < Frame.Height)
	|                {
	|                    return true;
	|                }
	|                return false;
	|            }
	|
	|            public override void Redraw(Rect bounds)
	|            {
	|                var current = ColorScheme.Focus;
	|                Driver.SetAttribute(current);
	|                Move(0, 0);
	|                var f = Frame;
	|                var item = TopItem;
	|                bool focused = HasFocus;
	|                int col = AllowsMarking ? 2 : 0;
	|                int start = LeftItem;
	|
	|                for (int row = 0; row < f.Height; row++, item++)
	|                {
	|                    bool isSelected = item == container.SelectedItem;
	|                    bool isHighlighted = hideDropdownListOnClick && item == highlighted;
	|
	|                    Attribute newcolor;
	|                    if (isHighlighted || (isSelected && !hideDropdownListOnClick))
	|                    {
	|                        newcolor = focused ? ColorScheme.Focus : ColorScheme.HotNormal;
	|                    }
	|                    else if (isSelected && hideDropdownListOnClick)
	|                    {
	|                        newcolor = focused ? ColorScheme.HotFocus : ColorScheme.HotNormal;
	|                    }
	|                    else
	|                    {
	|                        newcolor = focused ? GetNormalColor() : GetNormalColor();
	|                    }
	|
	|                    if (newcolor != current)
	|                    {
	|                        Driver.SetAttribute(newcolor);
	|                        current = newcolor;
	|                    }
	|
	|                    Move(0, row);
	|                    if (Source == null || item >= Source.Count)
	|                    {
	|                        for (int c = 0; c < f.Width; c++)
	|                            Driver.AddRune(' ');
	|                    }
	|                    else
	|                    {
	|                        var rowEventArgs = new ListViewRowEventArgs(item);
	|                        OnRowRender(rowEventArgs);
	|                        if (rowEventArgs.RowAttribute != null && current != rowEventArgs.RowAttribute)
	|                        {
	|                            current = (Attribute)rowEventArgs.RowAttribute;
	|                            Driver.SetAttribute(current);
	|                        }
	|                        if (AllowsMarking)
	|                        {
	|                            Driver.AddRune(Source.IsMarked(item) ? (AllowsMultipleSelection ? Driver.Checked : Driver.Selected) : (AllowsMultipleSelection ? Driver.UnChecked : Driver.UnSelected));
	|                            Driver.AddRune(' ');
	|                        }
	|                        Source.Render(this, Driver, isSelected, item, col, row, f.Width - col, start);
	|                    }
	|                }
	|            }
	|
	|            public override bool OnEnter(View view)
	|            {
	|                if (hideDropdownListOnClick)
	|                {
	|                    isFocusing = true;
	|                    highlighted = container.SelectedItem;
	|                    Application.GrabMouse(this);
	|                }
	|
	|                return base.OnEnter(view);
	|            }
	|
	|            public override bool OnLeave(View view)
	|            {
	|                if (hideDropdownListOnClick)
	|                {
	|                    isFocusing = false;
	|                    highlighted = container.SelectedItem;
	|                    Application.UngrabMouse();
	|                }
	|
	|                return base.OnLeave(view);
	|            }
	|
	|            public override bool OnSelectedChanged()
	|            {
	|                var res = base.OnSelectedChanged();
	|
	|                highlighted = SelectedItem;
	|
	|                return res;
	|            }
	|        }
	|
	|        IListDataSource source;
	|        /// <summary>
	|        /// Gets or sets the <see cref=""IListDataSource""/> backing this <see cref=""ComboBox""/>, enabling custom rendering.
	|        /// </summary>
	|        /// <value>The source.</value>
	|        /// <remarks>
	|        ///  Use <see cref=""SetSource""/> to set a new <see cref=""IList""/> source.
	|        /// </remarks>
	|        public IListDataSource Source
	|        {
	|            get => source;
	|            set
	|            {
	|                source = value;
	|
	|                // Only need to refresh list if its been added to a container view
	|                if (SuperView != null && SuperView.Subviews.Contains(this))
	|                {
	|                    SelectedItem = -1;
	|                    search.Text = """";
	|                    Search_Changed("""");
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Sets the source of the <see cref=""ComboBox""/> to an <see cref=""IList""/>.
	|        /// </summary>
	|        /// <value>An object implementing the IList interface.</value>
	|        /// <remarks>
	|        ///  Use the <see cref=""Source""/> property to set a new <see cref=""IListDataSource""/> source and use custome rendering.
	|        /// </remarks>
	|        public void SetSource(IList source)
	|        {
	|            if (source == null)
	|            {
	|                Source = null;
	|            }
	|            else
	|            {
	|                listview.SetSource(source);
	|                Source = listview.Source;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This event is raised when the selected item in the <see cref=""ComboBox""/> has changed.
	|        /// </summary>
	|        public event Action<ListViewItemEventArgs> SelectedItemChanged;
	|
	|        /// <summary>
	|        /// This event is raised when the drop-down list is expanded.
	|        /// </summary>
	|        public event Action Expanded;
	|
	|        /// <summary>
	|        /// This event is raised when the drop-down list is collapsed.
	|        /// </summary>
	|        public event Action Collapsed;
	|
	|        /// <summary>
	|        /// This event is raised when the user Double Clicks on an item or presses ENTER to open the selected item.
	|        /// </summary>
	|        public event Action<ListViewItemEventArgs> OpenSelectedItem;
	|
	|        readonly IList searchset = new List<object>();
	|        ustring text = """";
	|        readonly TextField search;
	|        readonly ComboListView listview;
	|        bool autoHide = true;
	|        readonly int minimumHeight = 2;
	|
	|        /// <summary>
	|        /// Public constructor
	|        /// </summary>
	|        public ComboBox() : this(string.Empty)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Public constructor
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        public ComboBox(ustring text) : base()
	|        {
	|            search = new TextField("""");
	|            listview = new ComboListView(this, HideDropdownListOnClick) { LayoutStyle = LayoutStyle.Computed, CanFocus = true, TabStop = false };
	|
	|            Initialize();
	|            Text = text;
	|        }
	|
	|        /// <summary>
	|        /// Public constructor
	|        /// </summary>
	|        /// <param name=""rect""></param>
	|        /// <param name=""source""></param>
	|        public ComboBox(Rect rect, IList source) : base(rect)
	|        {
	|            search = new TextField("""") { Width = rect.Width };
	|            listview = new ComboListView(this, rect, source, HideDropdownListOnClick) { LayoutStyle = LayoutStyle.Computed, ColorScheme = Colors.Base };
	|
	|            Initialize();
	|            SetSource(source);
	|        }
	|
	|        /// <summary>
	|        /// Initialize with the source.
	|        /// </summary>
	|        /// <param name=""source"">The source.</param>
	|        public ComboBox(IList source) : this(string.Empty)
	|        {
	|            search = new TextField("""");
	|            listview = new ComboListView(this, source, HideDropdownListOnClick) { LayoutStyle = LayoutStyle.Computed, ColorScheme = Colors.Base };
	|
	|            Initialize();
	|            SetSource(source);
	|        }
	|
	|        private void Initialize()
	|        {
	|            if (Bounds.Height < minimumHeight && (Height == null || Height is Dim.DimAbsolute))
	|            {
	|                Height = minimumHeight;
	|            }
	|
	|            search.TextChanged += Search_Changed;
	|
	|            listview.Y = Pos.Bottom(search);
	|            listview.OpenSelectedItem += (ListViewItemEventArgs a) => Selected();
	|
	|            this.Add(search, listview);
	|
	|            // On resize
	|            LayoutComplete += (LayoutEventArgs a) =>
	|            {
	|                if ((!autoHide && Bounds.Width > 0 && search.Frame.Width != Bounds.Width) ||
	|                    (autoHide && Bounds.Width > 0 && search.Frame.Width != Bounds.Width - 1))
	|                {
	|                    search.Width = listview.Width = autoHide ? Bounds.Width - 1 : Bounds.Width;
	|                    listview.Height = CalculatetHeight();
	|                    search.SetRelativeLayout(Bounds);
	|                    listview.SetRelativeLayout(Bounds);
	|                }
	|            };
	|
	|            listview.SelectedItemChanged += (ListViewItemEventArgs e) =>
	|            {
	|
	|                if (!HideDropdownListOnClick && searchset.Count > 0)
	|                {
	|                    SetValue(searchset[listview.SelectedItem]);
	|                }
	|            };
	|
	|            Added += (View v) =>
	|            {
	|
	|                // Determine if this view is hosted inside a dialog and is the only control
	|                for (View view = this.SuperView; view != null; view = view.SuperView)
	|                {
	|                    if (view is Dialog && SuperView != null && SuperView.Subviews.Count == 1 && SuperView.Subviews[0] == this)
	|                    {
	|                        autoHide = false;
	|                        break;
	|                    }
	|                }
	|
	|                SetNeedsLayout();
	|                SetNeedsDisplay();
	|                Search_Changed(Text);
	|            };
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.Accept, () => ActivateSelected());
	|            AddCommand(Command.ToggleExpandCollapse, () => ExpandCollapse());
	|            AddCommand(Command.Expand, () => Expand());
	|            AddCommand(Command.Collapse, () => Collapse());
	|            AddCommand(Command.LineDown, () => MoveDown());
	|            AddCommand(Command.LineUp, () => MoveUp());
	|            AddCommand(Command.PageDown, () => PageDown());
	|            AddCommand(Command.PageUp, () => PageUp());
	|            AddCommand(Command.TopHome, () => MoveHome());
	|            AddCommand(Command.BottomEnd, () => MoveEnd());
	|            AddCommand(Command.Cancel, () => CancelSelected());
	|            AddCommand(Command.UnixEmulation, () => UnixEmulation());
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.Enter, Command.Accept);
	|            AddKeyBinding(Key.F4, Command.ToggleExpandCollapse);
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.PageDown, Command.PageDown);
	|            AddKeyBinding(Key.PageUp, Command.PageUp);
	|            AddKeyBinding(Key.Home, Command.TopHome);
	|            AddKeyBinding(Key.End, Command.BottomEnd);
	|            AddKeyBinding(Key.Esc, Command.Cancel);
	|            AddKeyBinding(Key.U | Key.CtrlMask, Command.UnixEmulation);
	|        }
	|
	|        private bool isShow = false;
	|        private int selectedItem = -1;
	|        private int lastSelectedItem = -1;
	|        private bool hideDropdownListOnClick;
	|
	|        /// <summary>
	|        /// Gets the index of the currently selected item in the <see cref=""Source""/>
	|        /// </summary>
	|        /// <value>The selected item or -1 none selected.</value>
	|        public int SelectedItem
	|        {
	|            get => selectedItem;
	|            set
	|            {
	|                if (selectedItem != value && (value == -1
	|                    || (source != null && value > -1 && value < source.Count)))
	|                {
	|
	|                    selectedItem = lastSelectedItem = value;
	|                    if (selectedItem != -1)
	|                    {
	|                        SetValue(source.ToList()[selectedItem].ToString(), true);
	|                    }
	|                    else
	|                    {
	|                        SetValue("""", true);
	|                    }
	|                    OnSelectedChanged();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the drop down list state, expanded or collapsed.
	|        /// </summary>
	|        public bool IsShow => isShow;
	|
	|        ///<inheritdoc/>
	|        public new ColorScheme ColorScheme
	|        {
	|            get
	|            {
	|                return base.ColorScheme;
	|            }
	|            set
	|            {
	|                listview.ColorScheme = value;
	|                base.ColorScheme = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        ///If set to true its not allow any changes in the text.
	|        /// </summary>
	|        public bool ReadOnly
	|        {
	|            get => search.ReadOnly;
	|            set
	|            {
	|                search.ReadOnly = value;
	|                if (search.ReadOnly)
	|                {
	|                    if (search.ColorScheme != null)
	|                    {
	|                        search.ColorScheme.Normal = search.ColorScheme.Focus;
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets if the drop-down list can be hide with a button click event.
	|        /// </summary>
	|        public bool HideDropdownListOnClick
	|        {
	|            get => hideDropdownListOnClick;
	|            set => hideDropdownListOnClick = listview.HideDropdownListOnClick = value;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (me.X == Bounds.Right - 1 && me.Y == Bounds.Top && me.Flags == MouseFlags.Button1Pressed
	|                && autoHide)
	|            {
	|
	|                if (isShow)
	|                {
	|                    isShow = false;
	|                    HideList();
	|                }
	|                else
	|                {
	|                    SetSearchSet();
	|
	|                    isShow = true;
	|                    ShowList();
	|                    FocusSelectedItem();
	|                }
	|
	|                return true;
	|            }
	|            else if (me.Flags == MouseFlags.Button1Pressed)
	|            {
	|                if (!search.HasFocus)
	|                {
	|                    search.SetFocus();
	|                }
	|
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        private void FocusSelectedItem()
	|        {
	|            listview.SelectedItem = SelectedItem > -1 ? SelectedItem : 0;
	|            listview.TabStop = true;
	|            listview.SetFocus();
	|            OnExpanded();
	|        }
	|
	|        /// <summary>
	|        /// Virtual method which invokes the <see cref=""Expanded""/> event.
	|        /// </summary>
	|        public virtual void OnExpanded()
	|        {
	|            Expanded?.Invoke();
	|        }
	|
	|        /// <summary>
	|        /// Virtual method which invokes the <see cref=""Collapsed""/> event.
	|        /// </summary>
	|        public virtual void OnCollapsed()
	|        {
	|            Collapsed?.Invoke();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            if (!search.HasFocus && !listview.HasFocus)
	|            {
	|                search.SetFocus();
	|            }
	|
	|            search.CursorPosition = search.Text.RuneCount;
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnLeave(View view)
	|        {
	|            if (source?.Count > 0 && selectedItem > -1 && selectedItem < source.Count - 1
	|                && text != source.ToList()[selectedItem].ToString())
	|            {
	|
	|                SetValue(source.ToList()[selectedItem].ToString());
	|            }
	|            if (autoHide && isShow && view != this && view != search && view != listview)
	|            {
	|                isShow = false;
	|                HideList();
	|            }
	|            else if (listview.TabStop)
	|            {
	|                listview.TabStop = false;
	|            }
	|
	|            return base.OnLeave(view);
	|        }
	|
	|        /// <summary>
	|        /// Invokes the SelectedChanged event if it is defined.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool OnSelectedChanged()
	|        {
	|            // Note: Cannot rely on ""listview.SelectedItem != lastSelectedItem"" because the list is dynamic. 
	|            // So we cannot optimize. Ie: Don't call if not changed
	|            SelectedItemChanged?.Invoke(new ListViewItemEventArgs(SelectedItem, search.Text));
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Invokes the OnOpenSelectedItem event if it is defined.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool OnOpenSelectedItem()
	|        {
	|            var value = search.Text;
	|            lastSelectedItem = SelectedItem;
	|            OpenSelectedItem?.Invoke(new ListViewItemEventArgs(SelectedItem, value));
	|
	|            return true;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            base.Redraw(bounds);
	|
	|            if (!autoHide)
	|            {
	|                return;
	|            }
	|
	|            Driver.SetAttribute(ColorScheme.Focus);
	|            Move(Bounds.Right - 1, 0);
	|            Driver.AddRune(Driver.DownArrow);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent e)
	|        {
	|            var result = InvokeKeybindings(e);
	|            if (result != null)
	|                return (bool)result;
	|
	|            return base.ProcessKey(e);
	|        }
	|
	|        bool UnixEmulation()
	|        {
	|            // Unix emulation
	|            Reset();
	|            return true;
	|        }
	|
	|        bool CancelSelected()
	|        {
	|            search.SetFocus();
	|            if (ReadOnly || HideDropdownListOnClick)
	|            {
	|                SelectedItem = lastSelectedItem;
	|                if (SelectedItem > -1 && listview.Source?.Count > 0)
	|                {
	|                    search.Text = text = listview.Source.ToList()[SelectedItem].ToString();
	|                }
	|            }
	|            else if (!ReadOnly)
	|            {
	|                search.Text = text = """";
	|                selectedItem = lastSelectedItem;
	|                OnSelectedChanged();
	|            }
	|            Collapse();
	|            return true;
	|        }
	|
	|        bool? MoveEnd()
	|        {
	|            if (!isShow && search.HasFocus)
	|            {
	|                return null;
	|            }
	|            if (HasItems())
	|            {
	|                listview.MoveEnd();
	|            }
	|            return true;
	|        }
	|
	|        bool? MoveHome()
	|        {
	|            if (!isShow && search.HasFocus)
	|            {
	|                return null;
	|            }
	|            if (HasItems())
	|            {
	|                listview.MoveHome();
	|            }
	|            return true;
	|        }
	|
	|        bool PageUp()
	|        {
	|            if (HasItems())
	|            {
	|                listview.MovePageUp();
	|            }
	|            return true;
	|        }
	|
	|        bool PageDown()
	|        {
	|            if (HasItems())
	|            {
	|                listview.MovePageDown();
	|            }
	|            return true;
	|        }
	|
	|        bool? MoveUp()
	|        {
	|            if (search.HasFocus)
	|            { // stop odd behavior on KeyUp when search has focus
	|                return true;
	|            }
	|
	|            if (listview.HasFocus && listview.SelectedItem == 0 && searchset?.Count > 0) // jump back to search
	|            {
	|                search.CursorPosition = search.Text.RuneCount;
	|                search.SetFocus();
	|                return true;
	|            }
	|            return null;
	|        }
	|
	|        bool? MoveDown()
	|        {
	|            if (search.HasFocus)
	|            { // jump to list
	|                if (searchset?.Count > 0)
	|                {
	|                    listview.TabStop = true;
	|                    listview.SetFocus();
	|                    SetValue(searchset[listview.SelectedItem]);
	|                }
	|                else
	|                {
	|                    listview.TabStop = false;
	|                    SuperView?.FocusNext();
	|                }
	|                return true;
	|            }
	|            return null;
	|        }
	|
	|        /// <summary>
	|        /// Toggles the expand/collapse state of the sublist in the combo box
	|        /// </summary>
	|        /// <returns></returns>
	|        bool ExpandCollapse()
	|        {
	|            if (search.HasFocus || listview.HasFocus)
	|            {
	|                if (!isShow)
	|                {
	|                    return Expand();
	|                }
	|                else
	|                {
	|                    return Collapse();
	|                }
	|            }
	|            return false;
	|        }
	|
	|        bool ActivateSelected()
	|        {
	|            if (HasItems())
	|            {
	|                Selected();
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        bool HasItems()
	|        {
	|            return Source?.Count > 0;
	|        }
	|
	|        /// <summary>
	|        /// Collapses the drop down list.  Returns true if the state chagned or false
	|        /// if it was already collapsed and no action was taken
	|        /// </summary>
	|        public virtual bool Collapse()
	|        {
	|            if (!isShow)
	|            {
	|                return false;
	|            }
	|
	|            isShow = false;
	|            HideList();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Expands the drop down list.  Returns true if the state chagned or false
	|        /// if it was already expanded and no action was taken
	|        /// </summary>
	|        public virtual bool Expand()
	|        {
	|            if (isShow)
	|            {
	|                return false;
	|            }
	|
	|            SetSearchSet();
	|            isShow = true;
	|            ShowList();
	|            FocusSelectedItem();
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// The currently selected list item
	|        /// </summary>
	|        public new ustring Text
	|        {
	|            get
	|            {
	|                return text;
	|            }
	|            set
	|            {
	|                SetSearchText(value);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Current search text 
	|        /// </summary>
	|        public ustring SearchText
	|        {
	|            get
	|            {
	|                return search.Text;
	|            }
	|            set
	|            {
	|                SetSearchText(value);
	|            }
	|        }
	|
	|        private void SetValue(object text, bool isFromSelectedItem = false)
	|        {
	|            search.TextChanged -= Search_Changed;
	|            this.text = search.Text = text.ToString();
	|            search.CursorPosition = 0;
	|            search.TextChanged += Search_Changed;
	|            if (!isFromSelectedItem)
	|            {
	|                selectedItem = GetSelectedItemFromSource(this.text);
	|                OnSelectedChanged();
	|            }
	|        }
	|
	|        private void Selected()
	|        {
	|            isShow = false;
	|            listview.TabStop = false;
	|
	|            if (listview.Source.Count == 0 || (searchset?.Count ?? 0) == 0)
	|            {
	|                text = """";
	|                HideList();
	|                return;
	|            }
	|
	|            SetValue(searchset[listview.SelectedItem]);
	|            search.CursorPosition = search.Text.ConsoleWidth;
	|            Search_Changed(search.Text);
	|            OnOpenSelectedItem();
	|            Reset(keepSearchText: true);
	|            HideList();
	|        }
	|
	|        private int GetSelectedItemFromSource(ustring value)
	|        {
	|            if (source == null)
	|            {
	|                return -1;
	|            }
	|            for (int i = 0; i < source.Count; i++)
	|            {
	|                if (source.ToList()[i].ToString() == value)
	|                {
	|                    return i;
	|                }
	|            }
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Reset to full original list
	|        /// </summary>
	|        private void Reset(bool keepSearchText = false)
	|        {
	|            if (!keepSearchText)
	|            {
	|                SetSearchText(string.Empty);
	|            }
	|
	|            ResetSearchSet();
	|
	|            listview.SetSource(searchset);
	|            listview.Height = CalculatetHeight();
	|
	|            if (HasFocus && Subviews.Count > 0)
	|            {
	|                search.SetFocus();
	|            }
	|        }
	|
	|        private void SetSearchText(ustring value)
	|        {
	|            search.Text = text = value;
	|        }
	|
	|        private void ResetSearchSet(bool noCopy = false)
	|        {
	|            searchset.Clear();
	|
	|            if (autoHide || noCopy)
	|                return;
	|            SetSearchSet();
	|        }
	|
	|        private void SetSearchSet()
	|        {
	|            if (Source == null) { return; }
	|            // force deep copy
	|            foreach (var item in Source.ToList())
	|            {
	|                searchset.Add(item);
	|            }
	|        }
	|
	|        private void Search_Changed(ustring text)
	|        {
	|            if (source == null)
	|            { // Object initialization		
	|                return;
	|            }
	|
	|            if (ustring.IsNullOrEmpty(search.Text) && ustring.IsNullOrEmpty(text))
	|            {
	|                ResetSearchSet();
	|            }
	|            else if (search.Text != text)
	|            {
	|                isShow = true;
	|                ResetSearchSet(noCopy: true);
	|
	|                foreach (var item in source.ToList())
	|                { // Iterate to preserver object type and force deep copy
	|                    if (item.ToString().StartsWith(search.Text.ToString(), StringComparison.CurrentCultureIgnoreCase))
	|                    {
	|                        searchset.Add(item);
	|                    }
	|                }
	|            }
	|
	|            if (HasFocus)
	|            {
	|                ShowList();
	|            }
	|            else if (autoHide)
	|            {
	|                isShow = false;
	|                HideList();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Show the search list
	|        /// </summary>
	|        /// 
	|        /// Consider making public
	|        private void ShowList()
	|        {
	|            listview.SetSource(searchset);
	|            listview.Clear(); // Ensure list shrinks in Dialog as you type
	|            listview.Height = CalculatetHeight();
	|            SuperView?.BringSubviewToFront(this);
	|        }
	|
	|        /// <summary>
	|        /// Hide the search list
	|        /// </summary>
	|        /// 
	|        /// Consider making public
	|        private void HideList()
	|        {
	|            if (lastSelectedItem != selectedItem)
	|            {
	|                OnOpenSelectedItem();
	|            }
	|            var rect = listview.ViewToScreen(listview.Bounds);
	|            Reset(keepSearchText: true);
	|            listview.Clear(rect);
	|            listview.TabStop = false;
	|            SuperView?.SendSubviewToBack(this);
	|            SuperView?.SetNeedsDisplay(rect);
	|            OnCollapsed();
	|        }
	|
	|        /// <summary>
	|        /// Internal height of dynamic search list
	|        /// </summary>
	|        /// <returns></returns>
	|        private int CalculatetHeight()
	|        {
	|            if (Bounds.Height == 0)
	|                return 0;
	|
	|            return Math.Min(Math.Max(Bounds.Height - 1, minimumHeight - 1), searchset?.Count > 0 ? searchset.Count : isShow ? Math.Max(Bounds.Height - 1, minimumHeight - 1) : 0);
	|        }
	|    }
	|    //=======================================================================
	|    // These classes use a keybinding system based on the design implemented in Scintilla.Net which is an MIT licensed open source project https://github.com/jacobslusser/ScintillaNET/blob/master/src/ScintillaNET/Command.cs
	|
	|    /// <summary>
	|    /// Actions which can be performed by the application or bound to keys in a <see cref=""View""/> control.
	|    /// </summary>
	|    public enum Command
	|    {
	|
	|        /// <summary>
	|        /// Moves down one item (cell, line, etc...).
	|        /// </summary>
	|        LineDown,
	|
	|        /// <summary>
	|        /// Extends the selection down one (cell, line, etc...).
	|        /// </summary>
	|        LineDownExtend,
	|
	|        /// <summary>
	|        /// Moves down to the last child node of the branch that holds the current selection.
	|        /// </summary>
	|        LineDownToLastBranch,
	|
	|        /// <summary>
	|        /// Scrolls down one (cell, line, etc...) (without changing the selection).
	|        /// </summary>
	|        ScrollDown,
	|
	|        // --------------------------------------------------------------------
	|
	|        /// <summary>
	|        /// Moves up one (cell, line, etc...).
	|        /// </summary>
	|        LineUp,
	|
	|        /// <summary>
	|        /// Extends the selection up one item (cell, line, etc...).
	|        /// </summary>
	|        LineUpExtend,
	|
	|        /// <summary>
	|        /// Moves up to the first child node of the branch that holds the current selection.
	|        /// </summary>
	|        LineUpToFirstBranch,
	|
	|        /// <summary>
	|        /// Scrolls up one item (cell, line, etc...) (without changing the selection).
	|        /// </summary>
	|        ScrollUp,
	|
	|        /// <summary>
	|        /// Moves the selection left one by the minimum increment supported by the <see cref=""View""/> e.g. single character, cell, item etc.
	|        /// </summary>
	|        Left,
	|
	|        /// <summary>
	|        /// Scrolls one item (cell, character, etc...) to the left
	|        /// </summary>
	|        ScrollLeft,
	|
	|        /// <summary>
	|        /// Extends the selection left one by the minimum increment supported by the view e.g. single character, cell, item etc.
	|        /// </summary>
	|        LeftExtend,
	|
	|        /// <summary>
	|        /// Moves the selection right one by the minimum increment supported by the view e.g. single character, cell, item etc.
	|        /// </summary>
	|        Right,
	|
	|        /// <summary>
	|        /// Scrolls one item (cell, character, etc...) to the right.
	|        /// </summary>
	|        ScrollRight,
	|
	|        /// <summary>
	|        /// Extends the selection right one by the minimum increment supported by the view e.g. single character, cell, item etc.
	|        /// </summary>
	|        RightExtend,
	|
	|        /// <summary>
	|        /// Moves the caret to the start of the previous word.
	|        /// </summary>
	|        WordLeft,
	|
	|        /// <summary>
	|        /// Extends the selection to the start of the previous word.
	|        /// </summary>
	|        WordLeftExtend,
	|
	|        /// <summary>
	|        /// Moves the caret to the start of the next word.
	|        /// </summary>
	|        WordRight,
	|
	|        /// <summary>
	|        /// Extends the selection to the start of the next word.
	|        /// </summary>
	|        WordRightExtend,
	|
	|        /// <summary>
	|        /// Cuts to the clipboard the characters from the current position to the end of the line.
	|        /// </summary>
	|        CutToEndLine,
	|
	|        /// <summary>
	|        /// Cuts to the clipboard the characters from the current position to the start of the line.
	|        /// </summary>
	|        CutToStartLine,
	|
	|        /// <summary>
	|        /// Deletes the characters forwards.
	|        /// </summary>
	|        KillWordForwards,
	|
	|        /// <summary>
	|        /// Deletes the characters backwards.
	|        /// </summary>
	|        KillWordBackwards,
	|
	|        /// <summary>
	|        /// Toggles overwrite mode such that newly typed text overwrites the text that is
	|        /// already there (typically associated with the Insert key).
	|        /// </summary>
	|        ToggleOverwrite,
	|
	|
	|        /// <summary>
	|        /// Enables overwrite mode such that newly typed text overwrites the text that is
	|        /// already there (typically associated with the Insert key).
	|        /// </summary>
	|        EnableOverwrite,
	|
	|        /// <summary>
	|        /// Disables overwrite mode (<see cref=""EnableOverwrite""/>)
	|        /// </summary>
	|        DisableOverwrite,
	|
	|        /// <summary>
	|        /// Move one page down.
	|        /// </summary>
	|        PageDown,
	|
	|        /// <summary>
	|        /// Move one page page extending the selection to cover revealed objects/characters.
	|        /// </summary>
	|        PageDownExtend,
	|
	|        /// <summary>
	|        /// Move one page up.
	|        /// </summary>
	|        PageUp,
	|
	|        /// <summary>
	|        /// Move one page up extending the selection to cover revealed objects/characters.
	|        /// </summary>
	|        PageUpExtend,
	|
	|        /// <summary>
	|        /// Moves to the top/home.
	|        /// </summary>
	|        TopHome,
	|
	|        /// <summary>
	|        /// Extends the selection to the top/home.
	|        /// </summary>
	|        TopHomeExtend,
	|
	|        /// <summary>
	|        /// Moves to the bottom/end.
	|        /// </summary>
	|        BottomEnd,
	|
	|        /// <summary>
	|        /// Extends the selection to the bottom/end.
	|        /// </summary>
	|        BottomEndExtend,
	|
	|        /// <summary>
	|        /// Open the selected item.
	|        /// </summary>
	|        OpenSelectedItem,
	|
	|        /// <summary>
	|        /// Toggle the checked state.
	|        /// </summary>
	|        ToggleChecked,
	|
	|        /// <summary>
	|        /// Accepts the current state (e.g. selection, button press etc).
	|        /// </summary>
	|        Accept,
	|
	|        /// <summary>
	|        /// Toggles the Expanded or collapsed state of a a list or item (with subitems).
	|        /// </summary>
	|        ToggleExpandCollapse,
	|
	|        /// <summary>
	|        /// Expands a list or item (with subitems).
	|        /// </summary>
	|        Expand,
	|
	|        /// <summary>
	|        /// Recursively Expands all child items and their child items (if any).
	|        /// </summary>
	|        ExpandAll,
	|
	|        /// <summary>
	|        /// Collapses a list or item (with subitems).
	|        /// </summary>
	|        Collapse,
	|
	|        /// <summary>
	|        /// Recursively collapses a list items of their children (if any).
	|        /// </summary>
	|        CollapseAll,
	|
	|        /// <summary>
	|        /// Cancels an action or any temporary states on the control e.g. expanding
	|        /// a combo list.
	|        /// </summary>
	|        Cancel,
	|
	|        /// <summary>
	|        /// Unix emulation.
	|        /// </summary>
	|        UnixEmulation,
	|
	|        /// <summary>
	|        /// Deletes the character on the right.
	|        /// </summary>
	|        DeleteCharRight,
	|
	|        /// <summary>
	|        /// Deletes the character on the left.
	|        /// </summary>
	|        DeleteCharLeft,
	|
	|        /// <summary>
	|        /// Selects all objects.
	|        /// </summary>
	|        SelectAll,
	|
	|        /// <summary>
	|        /// Deletes all objects.
	|        /// </summary>
	|        DeleteAll,
	|
	|        /// <summary>
	|        /// Moves the cursor to the start of line.
	|        /// </summary>
	|        StartOfLine,
	|
	|        /// <summary>
	|        /// Extends the selection to the start of line.
	|        /// </summary>
	|        StartOfLineExtend,
	|
	|        /// <summary>
	|        /// Moves the cursor to the end of line.
	|        /// </summary>
	|        EndOfLine,
	|
	|        /// <summary>
	|        /// Extends the selection to the end of line.
	|        /// </summary>
	|        EndOfLineExtend,
	|
	|        /// <summary>
	|        /// Moves the cursor to the top of page.
	|        /// </summary>
	|        StartOfPage,
	|
	|        /// <summary>
	|        /// Moves the cursor to the bottom of page.
	|        /// </summary>
	|        EndOfPage,
	|
	|        /// <summary>
	|        /// Moves to the left page.
	|        /// </summary>
	|        PageLeft,
	|
	|        /// <summary>
	|        /// Moves to the right page.
	|        /// </summary>
	|        PageRight,
	|
	|        /// <summary>
	|        /// Moves to the left begin.
	|        /// </summary>
	|        LeftHome,
	|
	|        /// <summary>
	|        /// Extends the selection to the left begin.
	|        /// </summary>
	|        LeftHomeExtend,
	|
	|        /// <summary>
	|        /// Moves to the right end.
	|        /// </summary>
	|        RightEnd,
	|
	|        /// <summary>
	|        /// Extends the selection to the right end.
	|        /// </summary>
	|        RightEndExtend,
	|
	|        /// <summary>
	|        /// Undo changes.
	|        /// </summary>
	|        Undo,
	|
	|        /// <summary>
	|        /// Redo changes.
	|        /// </summary>
	|        Redo,
	|
	|        /// <summary>
	|        /// Copies the current selection.
	|        /// </summary>
	|        Copy,
	|
	|        /// <summary>
	|        /// Cuts the current selection.
	|        /// </summary>
	|        Cut,
	|
	|        /// <summary>
	|        /// Pastes the current selection.
	|        /// </summary>
	|        Paste,
	|
	|        /// <summary>
	|        /// Quit a <see cref=""Toplevel""/>.
	|        /// </summary>
	|        QuitToplevel,
	|
	|        /// <summary>
	|        /// Suspend a application (used on Linux).
	|        /// </summary>
	|        Suspend,
	|
	|        /// <summary>
	|        /// Moves focus to the next view.
	|        /// </summary>
	|        NextView,
	|
	|        /// <summary>
	|        /// Moves focuss to the previous view.
	|        /// </summary>
	|        PreviousView,
	|
	|        /// <summary>
	|        /// Moves focus to the next view or toplevel (case of MDI).
	|        /// </summary>
	|        NextViewOrTop,
	|
	|        /// <summary>
	|        /// Moves focus to the next previous or toplevel (case of MDI).
	|        /// </summary>
	|        PreviousViewOrTop,
	|
	|        /// <summary>
	|        /// Refresh.
	|        /// </summary>
	|        Refresh,
	|
	|        /// <summary>
	|        /// Toggles the selection.
	|        /// </summary>
	|        ToggleExtend,
	|
	|        /// <summary>
	|        /// Inserts a new item.
	|        /// </summary>
	|        NewLine,
	|
	|        /// <summary>
	|        /// Tabs to the next item.
	|        /// </summary>
	|        Tab,
	|
	|        /// <summary>
	|        /// Tabs back to the previous item.
	|        /// </summary>
	|        BackTab
	|    }
	|    //=======================================================================
	|    //
	|    // ConsoleDriver.cs: Base class for Terminal.Gui ConsoleDriver implementations.
	|    //
	|
	|    /// <summary>
	|    /// Colors that can be used to set the foreground and background colors in console applications.
	|    /// </summary>
	|    /// <remarks>
	|    /// The <see cref=""Attribute.HasValidColors""/> value indicates either no-color has been set or the color is invalid.
	|    /// </remarks>
	|    public enum Color
	|    {
	|        /// <summary>
	|        /// The black color.
	|        /// </summary>
	|        Black,
	|        /// <summary>
	|        /// The blue color.
	|        /// </summary>
	|        Blue,
	|        /// <summary>
	|        /// The green color.
	|        /// </summary>
	|        Green,
	|        /// <summary>
	|        /// The cyan color.
	|        /// </summary>
	|        Cyan,
	|        /// <summary>
	|        /// The red color.
	|        /// </summary>
	|        Red,
	|        /// <summary>
	|        /// The magenta color.
	|        /// </summary>
	|        Magenta,
	|        /// <summary>
	|        /// The brown color.
	|        /// </summary>
	|        Brown,
	|        /// <summary>
	|        /// The gray color.
	|        /// </summary>
	|        Gray,
	|        /// <summary>
	|        /// The dark gray color.
	|        /// </summary>
	|        DarkGray,
	|        /// <summary>
	|        /// The bright bBlue color.
	|        /// </summary>
	|        BrightBlue,
	|        /// <summary>
	|        /// The bright green color.
	|        /// </summary>
	|        BrightGreen,
	|        /// <summary>
	|        /// The bright cyan color.
	|        /// </summary>
	|        BrightCyan,
	|        /// <summary>
	|        /// The bright red color.
	|        /// </summary>
	|        BrightRed,
	|        /// <summary>
	|        /// The bright magenta color.
	|        /// </summary>
	|        BrightMagenta,
	|        /// <summary>
	|        /// The bright yellow color.
	|        /// </summary>
	|        BrightYellow,
	|        /// <summary>
	|        /// The White color.
	|        /// </summary>
	|        White
	|    }
	|
	|    /// <summary>
	|    /// Indicates the RGB for true colors.
	|    /// </summary>
	|    public class TrueColor
	|    {
	|        /// <summary>
	|        /// Red color component.
	|        /// </summary>
	|        public int Red { get; }
	|        /// <summary>
	|        /// Green color component.
	|        /// </summary>
	|        public int Green { get; }
	|        /// <summary>
	|        /// Blue color component.
	|        /// </summary>
	|        public int Blue { get; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""TrueColor""/> struct.
	|        /// </summary>
	|        /// <param name=""red""></param>
	|        /// <param name=""green""></param>
	|        /// <param name=""blue""></param>
	|        public TrueColor(int red, int green, int blue)
	|        {
	|            Red = red;
	|            Green = green;
	|            Blue = blue;
	|        }
	|
	|        /// <summary>
	|        /// Converts true color to console color.
	|        /// </summary>
	|        /// <returns></returns>
	|        public Color ToConsoleColor()
	|        {
	|            var trueColorMap = new Dictionary<TrueColor, Color>() {
	|                { new TrueColor (0,0,0),Color.Black},
	|                { new TrueColor (0, 0, 0x80),Color.Blue},
	|                { new TrueColor (0, 0x80, 0),Color.Green},
	|                { new TrueColor (0, 0x80, 0x80),Color.Cyan},
	|                { new TrueColor (0x80, 0, 0),Color.Red},
	|                { new TrueColor (0x80, 0, 0x80),Color.Magenta},
	|                { new TrueColor (0xC1, 0x9C, 0x00),Color.Brown},  // TODO confirm this
	|				{ new TrueColor (0xC0, 0xC0, 0xC0),Color.Gray},
	|                { new TrueColor (0x80, 0x80, 0x80),Color.DarkGray},
	|                { new TrueColor (0, 0, 0xFF),Color.BrightBlue},
	|                { new TrueColor (0, 0xFF, 0),Color.BrightGreen},
	|                { new TrueColor (0, 0xFF, 0xFF),Color.BrightCyan},
	|                { new TrueColor (0xFF, 0, 0),Color.BrightRed},
	|                { new TrueColor (0xFF, 0, 0xFF),Color.BrightMagenta },
	|                { new TrueColor (0xFF, 0xFF, 0),Color.BrightYellow},
	|                { new TrueColor (0xFF, 0xFF, 0xFF),Color.White},
	|                };
	|            // Iterate over all colors in the map
	|            var distances = trueColorMap.Select(
	|                            k => Tuple.Create(
	|                                // the candidate we are considering matching against (RGB)
	|                                k.Key,
	|
	|                                CalculateDistance(k.Key, this)
	|                            ));
	|
	|            // get the closest
	|            var match = distances.OrderBy(t => t.Item2).First();
	|            return trueColorMap[match.Item1];
	|        }
	|
	|        private float CalculateDistance(TrueColor color1, TrueColor color2)
	|        {
	|            // use RGB distance
	|            return
	|                Math.Abs(color1.Red - color2.Red) +
	|                Math.Abs(color1.Green - color2.Green) +
	|                Math.Abs(color1.Blue - color2.Blue);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Attributes are used as elements that contain both a foreground and a background or platform specific features.
	|    /// </summary>
	|    /// <remarks>
	|    ///   <see cref=""Attribute""/>s are needed to map colors to terminal capabilities that might lack colors. 
	|    ///   They encode both the foreground and the background color and are used in the <see cref=""ColorScheme""/>
	|    ///   class to define color schemes that can be used in an application.
	|    /// </remarks>
	|    public struct Attribute
	|    {
	|        /// <summary>
	|        /// The <see cref=""ConsoleDriver""/>-specific color attribute value. If <see cref=""Initialized""/> is <see langword=""false""/> 
	|        /// the value of this property is invalid (typically because the Attribute was created before a driver was loaded)
	|        /// and the attribute should be re-made (see <see cref=""Make(Color, Color)""/>) before it is used.
	|        /// </summary>
	|        public int Value { get; }
	|
	|        /// <summary>
	|        /// The foreground color.
	|        /// </summary>
	|        public Color Foreground { get; }
	|
	|        /// <summary>
	|        /// The background color.
	|        /// </summary>
	|        public Color Background { get; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Attribute""/> struct with only the value passed to
	|        ///   and trying to get the colors if defined.
	|        /// </summary>
	|        /// <param name=""value"">Value.</param>
	|        public Attribute(int value)
	|        {
	|            Color foreground = default;
	|            Color background = default;
	|
	|            Initialized = false;
	|            if (Application.Driver != null)
	|            {
	|                Application.Driver.GetColors(value, out foreground, out background);
	|                Initialized = true;
	|            }
	|            Value = value;
	|            Foreground = foreground;
	|            Background = background;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Attribute""/> struct.
	|        /// </summary>
	|        /// <param name=""value"">Value.</param>
	|        /// <param name=""foreground"">Foreground</param>
	|        /// <param name=""background"">Background</param>
	|        public Attribute(int value, Color foreground, Color background)
	|        {
	|            Value = value;
	|            Foreground = foreground;
	|            Background = background;
	|            Initialized = true;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Attribute""/> struct.
	|        /// </summary>
	|        /// <param name=""foreground"">Foreground</param>
	|        /// <param name=""background"">Background</param>
	|        public Attribute(Color foreground = new Color(), Color background = new Color())
	|        {
	|            var make = Make(foreground, background);
	|            Initialized = make.Initialized;
	|            Value = make.Value;
	|            Foreground = foreground;
	|            Background = background;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Attribute""/> struct
	|        ///  with the same colors for the foreground and background.
	|        /// </summary>
	|        /// <param name=""color"">The color.</param>
	|        public Attribute(Color color) : this(color, color) { }
	|
	|        /// <summary>
	|        /// Implicit conversion from an <see cref=""Attribute""/> to the underlying, driver-specific, Int32 representation
	|        /// of the color.
	|        /// </summary>
	|        /// <returns>The driver-specific color value stored in the attribute.</returns>
	|        /// <param name=""c"">The attribute to convert</param>
	|        public static implicit operator int(Attribute c)
	|        {
	|            if (!c.Initialized) throw new InvalidOperationException(""Attribute: Attributes must be initialized by a driver before use."");
	|            return c.Value;
	|        }
	|
	|        /// <summary>
	|        /// Implicitly convert an driver-specific color value into an <see cref=""Attribute""/>
	|        /// </summary>
	|        /// <returns>An attribute with the specified driver-specific color value.</returns>
	|        /// <param name=""v"">value</param>
	|        public static implicit operator Attribute(int v) => new Attribute(v);
	|
	|        /// <summary>
	|        /// Creates an <see cref=""Attribute""/> from the specified foreground and background colors.
	|        /// </summary>
	|        /// <remarks>
	|        /// If a <see cref=""ConsoleDriver""/> has not been loaded (<c>Application.Driver == null</c>) this
	|        /// method will return an attribute with <see cref=""Initialized""/> set to  <see langword=""false""/>.
	|        /// </remarks>
	|        /// <returns>The new attribute.</returns>
	|        /// <param name=""foreground"">Foreground color to use.</param>
	|        /// <param name=""background"">Background color to use.</param>
	|        public static Attribute Make(Color foreground, Color background)
	|        {
	|            if (Application.Driver == null)
	|            {
	|                // Create the attribute, but show it's not been initialized
	|                return new Attribute(-1, foreground, background)
	|                {
	|                    Initialized = false
	|                };
	|            }
	|            return Application.Driver.MakeAttribute(foreground, background);
	|        }
	|
	|        /// <summary>
	|        /// Gets the current <see cref=""Attribute""/> from the driver.
	|        /// </summary>
	|        /// <returns>The current attribute.</returns>
	|        public static Attribute Get()
	|        {
	|            if (Application.Driver == null)
	|                throw new InvalidOperationException(""The Application has not been initialized"");
	|            return Application.Driver.GetAttribute();
	|        }
	|
	|        /// <summary>
	|        /// If <see langword=""true""/> the attribute has been initialized by a <see cref=""ConsoleDriver""/> and 
	|        /// thus has <see cref=""Value""/> that is valid for that driver. If <see langword=""false""/> the <see cref=""Foreground""/>
	|        /// and <see cref=""Background""/> colors may have been set '-1' but
	|        /// the attribute has not been mapped to a <see cref=""ConsoleDriver""/> specific color value.
	|        /// </summary>
	|        /// <remarks>
	|        /// Attributes that have not been initialized must eventually be initialized before being passed to a driver.
	|        /// </remarks>
	|        public bool Initialized { get; internal set; }
	|
	|        /// <summary>
	|        /// Returns <see langword=""true""/> if the Attribute is valid (both foreground and background have valid color values).
	|        /// </summary>
	|        /// <returns></returns>
	|        public bool HasValidColors { get => (int)Foreground > -1 && (int)Background > -1; }
	|    }
	|
	|    /// <summary>
	|    /// Defines the color <see cref=""Attribute""/>s for common visible elements in a <see cref=""View""/>. 
	|    /// Containers such as <see cref=""Window""/> and <see cref=""FrameView""/> use <see cref=""ColorScheme""/> to determine
	|    /// the colors used by sub-views.
	|    /// </summary>
	|    /// <remarks>
	|    /// See also: <see cref=""Colors.ColorSchemes""/>.
	|    /// </remarks>
	|    public class ColorScheme : IEquatable<ColorScheme>
	|    {
	|        Attribute _normal = new Attribute(Color.White, Color.Black);
	|        Attribute _focus = new Attribute(Color.White, Color.Black);
	|        Attribute _hotNormal = new Attribute(Color.White, Color.Black);
	|        Attribute _hotFocus = new Attribute(Color.White, Color.Black);
	|        Attribute _disabled = new Attribute(Color.White, Color.Black);
	|
	|        /// <summary>
	|        /// Used by <see cref=""Colors.SetColorScheme(ColorScheme, string)""/> and <see cref=""Colors.GetColorScheme(string)""/> to track which ColorScheme 
	|        /// is being accessed.
	|        /// </summary>
	|        internal string schemeBeingSet = """";
	|
	|        /// <summary>
	|        /// The foreground and background color for text when the view is not focused, hot, or disabled.
	|        /// </summary>
	|        public Attribute Normal
	|        {
	|            get { return _normal; }
	|            set
	|            {
	|                if (!value.HasValidColors)
	|                {
	|                    return;
	|                }
	|                _normal = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The foreground and background color for text when the view has the focus.
	|        /// </summary>
	|        public Attribute Focus
	|        {
	|            get { return _focus; }
	|            set
	|            {
	|                if (!value.HasValidColors)
	|                {
	|                    return;
	|                }
	|                _focus = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The foreground and background color for text when the view is highlighted (hot).
	|        /// </summary>
	|        public Attribute HotNormal
	|        {
	|            get { return _hotNormal; }
	|            set
	|            {
	|                if (!value.HasValidColors)
	|                {
	|                    return;
	|                }
	|                _hotNormal = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The foreground and background color for text when the view is highlighted (hot) and has focus.
	|        /// </summary>
	|        public Attribute HotFocus
	|        {
	|            get { return _hotFocus; }
	|            set
	|            {
	|                if (!value.HasValidColors)
	|                {
	|                    return;
	|                }
	|                _hotFocus = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The default foreground and background color for text, when the view is disabled.
	|        /// </summary>
	|        public Attribute Disabled
	|        {
	|            get { return _disabled; }
	|            set
	|            {
	|                if (!value.HasValidColors)
	|                {
	|                    return;
	|                }
	|                _disabled = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Compares two <see cref=""ColorScheme""/> objects for equality.
	|        /// </summary>
	|        /// <param name=""obj""></param>
	|        /// <returns>true if the two objects are equal</returns>
	|        public override bool Equals(object obj)
	|        {
	|            return Equals(obj as ColorScheme);
	|        }
	|
	|        /// <summary>
	|        /// Compares two <see cref=""ColorScheme""/> objects for equality.
	|        /// </summary>
	|        /// <param name=""other""></param>
	|        /// <returns>true if the two objects are equal</returns>
	|        public bool Equals(ColorScheme other)
	|        {
	|            return other != null &&
	|                   EqualityComparer<Attribute>.Default.Equals(_normal, other._normal) &&
	|                   EqualityComparer<Attribute>.Default.Equals(_focus, other._focus) &&
	|                   EqualityComparer<Attribute>.Default.Equals(_hotNormal, other._hotNormal) &&
	|                   EqualityComparer<Attribute>.Default.Equals(_hotFocus, other._hotFocus) &&
	|                   EqualityComparer<Attribute>.Default.Equals(_disabled, other._disabled);
	|        }
	|
	|        /// <summary>
	|        /// Returns a hashcode for this instance.
	|        /// </summary>
	|        /// <returns>hashcode for this instance</returns>
	|        public override int GetHashCode()
	|        {
	|            int hashCode = -1242460230;
	|            hashCode = hashCode * -1521134295 + _normal.GetHashCode();
	|            hashCode = hashCode * -1521134295 + _focus.GetHashCode();
	|            hashCode = hashCode * -1521134295 + _hotNormal.GetHashCode();
	|            hashCode = hashCode * -1521134295 + _hotFocus.GetHashCode();
	|            hashCode = hashCode * -1521134295 + _disabled.GetHashCode();
	|            return hashCode;
	|        }
	|
	|        /// <summary>
	|        /// Compares two <see cref=""ColorScheme""/> objects for equality.
	|        /// </summary>
	|        /// <param name=""left""></param>
	|        /// <param name=""right""></param>
	|        /// <returns><c>true</c> if the two objects are equivalent</returns>
	|        public static bool operator ==(ColorScheme left, ColorScheme right)
	|        {
	|            return EqualityComparer<ColorScheme>.Default.Equals(left, right);
	|        }
	|
	|        /// <summary>
	|        /// Compares two <see cref=""ColorScheme""/> objects for inequality.
	|        /// </summary>
	|        /// <param name=""left""></param>
	|        /// <param name=""right""></param>
	|        /// <returns><c>true</c> if the two objects are not equivalent</returns>
	|        public static bool operator !=(ColorScheme left, ColorScheme right)
	|        {
	|            return !(left == right);
	|        }
	|
	|        internal void Initialize()
	|        {
	|            // If the new scheme was created before a driver was loaded, we need to re-make
	|            // the attributes
	|            if (!_normal.Initialized)
	|            {
	|                _normal = new Attribute(_normal.Foreground, _normal.Background);
	|            }
	|            if (!_focus.Initialized)
	|            {
	|                _focus = new Attribute(_focus.Foreground, _focus.Background);
	|            }
	|            if (!_hotNormal.Initialized)
	|            {
	|                _hotNormal = new Attribute(_hotNormal.Foreground, _hotNormal.Background);
	|            }
	|            if (!_hotFocus.Initialized)
	|            {
	|                _hotFocus = new Attribute(_hotFocus.Foreground, _hotFocus.Background);
	|            }
	|            if (!_disabled.Initialized)
	|            {
	|                _disabled = new Attribute(_disabled.Foreground, _disabled.Background);
	|            }
	|        }
	|    }
	|
	|    /// <summary>
	|    /// The default <see cref=""ColorScheme""/>s for the application.
	|    /// </summary>
	|    /// <remarks>
	|    /// This property can be set in a Theme to change the default <see cref=""Colors""/> for the application.
	|    /// </remarks>
	|    public static class Colors
	|    {
	|        private class SchemeNameComparerIgnoreCase : IEqualityComparer<string>
	|        {
	|            public bool Equals(string x, string y)
	|            {
	|                if (x != null && y != null)
	|                {
	|                    return string.Equals(x, y, StringComparison.InvariantCultureIgnoreCase);
	|                }
	|                return false;
	|            }
	|
	|            public int GetHashCode(string obj)
	|            {
	|                return obj.ToLowerInvariant().GetHashCode();
	|            }
	|        }
	|
	|        static Colors()
	|        {
	|            ColorSchemes = Create();
	|        }
	|
	|        /// <summary>
	|        /// Creates a new dictionary of new <see cref=""ColorScheme""/> objects.
	|        /// </summary>
	|        public static Dictionary<string, ColorScheme> Create()
	|        {
	|            // Use reflection to dynamically create the default set of ColorSchemes from the list defined 
	|            // by the class. 
	|            return typeof(Colors).GetProperties()
	|                .Where(p => p.PropertyType == typeof(ColorScheme))
	|                .Select(p => new KeyValuePair<string, ColorScheme>(p.Name, new ColorScheme()))
	|                .ToDictionary(t => t.Key, t => t.Value, comparer: new SchemeNameComparerIgnoreCase());
	|        }
	|
	|        /// <summary>
	|        /// The application toplevel color scheme, for the default toplevel views.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///	This API will be deprecated in the future. Use <see cref=""Colors.ColorSchemes""/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes[""TopLevel""];</c>
	|        /// </para>
	|        /// </remarks>
	|        public static ColorScheme TopLevel { get => GetColorScheme(); set => SetColorScheme(value); }
	|
	|        /// <summary>
	|        /// The base color scheme, for the default toplevel views.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///	This API will be deprecated in the future. Use <see cref=""Colors.ColorSchemes""/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes[""Base""];</c>
	|        /// </para>
	|        /// </remarks>
	|        public static ColorScheme Base { get => GetColorScheme(); set => SetColorScheme(value); }
	|
	|        /// <summary>
	|        /// The dialog color scheme, for standard popup dialog boxes
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///	This API will be deprecated in the future. Use <see cref=""Colors.ColorSchemes""/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes[""Dialog""];</c>
	|        /// </para>
	|        /// </remarks>
	|        public static ColorScheme Dialog { get => GetColorScheme(); set => SetColorScheme(value); }
	|
	|        /// <summary>
	|        /// The menu bar color
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///	This API will be deprecated in the future. Use <see cref=""Colors.ColorSchemes""/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes[""Menu""];</c>
	|        /// </para>
	|        /// </remarks>
	|        public static ColorScheme Menu { get => GetColorScheme(); set => SetColorScheme(value); }
	|
	|        /// <summary>
	|        /// The color scheme for showing errors.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///	This API will be deprecated in the future. Use <see cref=""Colors.ColorSchemes""/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes[""Error""];</c>
	|        /// </para>
	|        /// </remarks>
	|        public static ColorScheme Error { get => GetColorScheme(); set => SetColorScheme(value); }
	|
	|        static ColorScheme GetColorScheme([CallerMemberName] string schemeBeingSet = null)
	|        {
	|            return ColorSchemes[schemeBeingSet];
	|        }
	|
	|        static void SetColorScheme(ColorScheme colorScheme, [CallerMemberName] string schemeBeingSet = null)
	|        {
	|            ColorSchemes[schemeBeingSet] = colorScheme;
	|            colorScheme.schemeBeingSet = schemeBeingSet;
	|        }
	|
	|        /// <summary>
	|        /// Provides the defined <see cref=""ColorScheme""/>s.
	|        /// </summary>
	|        public static Dictionary<string, ColorScheme> ColorSchemes { get; private set; }
	|    }
	|
	|    /// <summary>
	|    /// Cursors Visibility that are displayed
	|    /// </summary>
	|    // 
	|    // Hexa value are set as 0xAABBCCDD where :
	|    //
	|    //     AA stand for the TERMINFO DECSUSR parameter value to be used under Linux & MacOS
	|    //     BB stand for the NCurses curs_set parameter value to be used under Linux & MacOS
	|    //     CC stand for the CONSOLE_CURSOR_INFO.bVisible parameter value to be used under Windows
	|    //     DD stand for the CONSOLE_CURSOR_INFO.dwSize parameter value to be used under Windows
	|    //
	|    public enum CursorVisibility
	|    {
	|        /// <summary>
	|        ///	Cursor caret has default
	|        /// </summary>
	|        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref=""Underscore""/>. This default directly depends of the XTerm user configuration settings so it could be Block, I-Beam, Underline with possible blinking.</remarks>
	|        Default = 0x00010119,
	|
	|        /// <summary>
	|        ///	Cursor caret is hidden
	|        /// </summary>
	|        Invisible = 0x03000019,
	|
	|        /// <summary>
	|        ///	Cursor caret is normally shown as a blinking underline bar _
	|        /// </summary>
	|        Underline = 0x03010119,
	|
	|        /// <summary>
	|        ///	Cursor caret is normally shown as a underline bar _
	|        /// </summary>
	|        /// <remarks>Under Windows, this is equivalent to <see ref=""UnderscoreBlinking""/></remarks>
	|        UnderlineFix = 0x04010119,
	|
	|        /// <summary>
	|        ///	Cursor caret is displayed a blinking vertical bar |
	|        /// </summary>
	|        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref=""Underscore""/></remarks>
	|        Vertical = 0x05010119,
	|
	|        /// <summary>
	|        ///	Cursor caret is displayed a blinking vertical bar |
	|        /// </summary>
	|        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref=""Underscore""/></remarks>
	|        VerticalFix = 0x06010119,
	|
	|        /// <summary>
	|        ///	Cursor caret is displayed as a blinking block ▉
	|        /// </summary>
	|        Box = 0x01020164,
	|
	|        /// <summary>
	|        ///	Cursor caret is displayed a block ▉
	|        /// </summary>
	|        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref=""Block""/></remarks>
	|        BoxFix = 0x02020164,
	|    }
	|
	|    /// <summary>
	|    /// ConsoleDriver is an abstract class that defines the requirements for a console driver.  
	|    /// There are currently three implementations: <see cref=""CursesDriver""/> (for Unix and Mac), <see cref=""WindowsDriver""/>, and <see cref=""NetDriver""/> that uses the .NET Console API.
	|    /// </summary>
	|    public abstract class ConsoleDriver
	|    {
	|        /// <summary>
	|        /// The handler fired when the terminal is resized.
	|        /// </summary>
	|        protected Action TerminalResized;
	|
	|        /// <summary>
	|        /// The current number of columns in the terminal.
	|        /// </summary>
	|        public abstract int Cols { get; }
	|
	|        /// <summary>
	|        /// The current number of rows in the terminal.
	|        /// </summary>
	|        public abstract int Rows { get; }
	|
	|        /// <summary>
	|        /// The current left in the terminal.
	|        /// </summary>
	|        public abstract int Left { get; }
	|
	|        /// <summary>
	|        /// The current top in the terminal.
	|        /// </summary>
	|        public abstract int Top { get; }
	|
	|        /// <summary>
	|        /// Get the operation system clipboard.
	|        /// </summary>
	|        public abstract IClipboard Clipboard { get; }
	|
	|        /// <summary>
	|        /// <para>
	|        /// If <see langword=""false""/> (the default) the height of the Terminal.Gui application (<see cref=""Rows""/>) 
	|        /// tracks to the height of the visible console view when the console is resized. In this case 
	|        /// scrolling in the console will be disabled and all <see cref=""Rows""/> will remain visible.
	|        /// </para>
	|        /// <para>
	|        /// If <see langword=""true""/> then height of the Terminal.Gui application <see cref=""Rows""/> only tracks 
	|        /// the height of the visible console view when the console is made larger (the application will only grow in height, never shrink). 
	|        /// In this case console scrolling is enabled and the contents (<see cref=""Rows""/> high) will scroll
	|        /// as the console scrolls. 
	|        /// </para>
	|        /// </summary>
	|        /// <remarks>
	|        /// NOTE: Changes to Windows Terminal prevents this functionality from working. It only really worked on Windows 'conhost' previously.
	|        /// </remarks>
	|        [Obsolete(""This API is deprecated and has no impact when enabled."", false)]
	|        public abstract bool EnableConsoleScrolling { get; set; }
	|        /// <summary>
	|        /// This API is deprecated and has no impact when enabled.
	|        /// </summary>
	|        [Obsolete(""This API is deprecated and has no impact when enabled."", false)]
	|        public abstract bool HeightAsBuffer { get; set; }
	|
	|        /// <summary>
	|        /// The format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
	|        /// </summary>
	|        public virtual int[,,] Contents { get; }
	|
	|        /// <summary>
	|        /// Initializes the driver
	|        /// </summary>
	|        /// <param name=""terminalResized"">Method to invoke when the terminal is resized.</param>
	|        public abstract void Init(Action terminalResized);
	|        /// <summary>
	|        /// Moves the cursor to the specified column and row.
	|        /// </summary>
	|        /// <param name=""col"">Column to move the cursor to.</param>
	|        /// <param name=""row"">Row to move the cursor to.</param>
	|        public abstract void Move(int col, int row);
	|
	|        /// <summary>
	|        /// Adds the specified rune to the display at the current cursor position.
	|        /// </summary>
	|        /// <param name=""rune"">Rune to add.</param>
	|        public abstract void AddRune(Rune rune);
	|
	|        /// <summary>
	|        /// Ensures a Rune is not a control character and can be displayed by translating characters below 0x20
	|        /// to equivalent, printable, Unicode chars.
	|        /// </summary>
	|        /// <param name=""c"">Rune to translate</param>
	|        /// <returns></returns>
	|        public static Rune MakePrintable(Rune c)
	|        {
	|            if (c <= 0x1F || (c >= 0X7F && c <= 0x9F))
	|            {
	|                // ASCII (C0) control characters.
	|                // C1 control characters (https://www.aivosto.com/articles/control-characters.html#c1)
	|                return new Rune(c + 0x2400);
	|            }
	|
	|            return c;
	|        }
	|
	|        /// <summary>
	|        /// Ensures that the column and line are in a valid range from the size of the driver.
	|        /// </summary>
	|        /// <param name=""col"">The column.</param>
	|        /// <param name=""row"">The row.</param>
	|        /// <param name=""clip"">The clip.</param>
	|        /// <returns><c>true</c>if it's a valid range,<c>false</c>otherwise.</returns>
	|        public bool IsValidContent(int col, int row, Rect clip) =>
	|            col >= 0 && row >= 0 && col < Cols && row < Rows && clip.Contains(col, row);
	|
	|        /// <summary>
	|        /// Adds the <paramref name=""str""/> to the display at the cursor position.
	|        /// </summary>
	|        /// <param name=""str"">String.</param>
	|        public abstract void AddStr(ustring str);
	|
	|        /// <summary>
	|        /// Prepare the driver and set the key and mouse events handlers.
	|        /// </summary>
	|        /// <param name=""mainLoop"">The main loop.</param>
	|        /// <param name=""keyHandler"">The handler for ProcessKey</param>
	|        /// <param name=""keyDownHandler"">The handler for key down events</param>
	|        /// <param name=""keyUpHandler"">The handler for key up events</param>
	|        /// <param name=""mouseHandler"">The handler for mouse events</param>
	|        public abstract void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler);
	|
	|        /// <summary>
	|        /// Updates the screen to reflect all the changes that have been done to the display buffer
	|        /// </summary>
	|        public abstract void Refresh();
	|
	|        /// <summary>
	|        /// Updates the location of the cursor position
	|        /// </summary>
	|        public abstract void UpdateCursor();
	|
	|        /// <summary>
	|        /// Retreive the cursor caret visibility
	|        /// </summary>
	|        /// <param name=""visibility"">The current <see cref=""CursorVisibility""/></param>
	|        /// <returns>true upon success</returns>
	|        public abstract bool GetCursorVisibility(out CursorVisibility visibility);
	|
	|        /// <summary>
	|        /// Change the cursor caret visibility
	|        /// </summary>
	|        /// <param name=""visibility"">The wished <see cref=""CursorVisibility""/></param>
	|        /// <returns>true upon success</returns>
	|        public abstract bool SetCursorVisibility(CursorVisibility visibility);
	|
	|        /// <summary>
	|        /// Ensure the cursor visibility
	|        /// </summary>
	|        /// <returns>true upon success</returns>
	|        public abstract bool EnsureCursorVisibility();
	|
	|        /// <summary>
	|        /// Ends the execution of the console driver.
	|        /// </summary>
	|        public abstract void End();
	|
	|        /// <summary>
	|        /// Resizes the clip area when the screen is resized.
	|        /// </summary>
	|        public abstract void ResizeScreen();
	|
	|        /// <summary>
	|        /// Reset and recreate the contents and the driver buffer.
	|        /// </summary>
	|        public abstract void UpdateOffScreen();
	|
	|        /// <summary>
	|        /// Redraws the physical screen with the contents that have been queued up via any of the printing commands.
	|        /// </summary>
	|        public abstract void UpdateScreen();
	|
	|        /// <summary>
	|        /// The current attribute the driver is using. 
	|        /// </summary>
	|        public virtual Attribute CurrentAttribute
	|        {
	|            get => currentAttribute;
	|            set
	|            {
	|                if (!value.Initialized && value.HasValidColors && Application.Driver != null)
	|                {
	|                    CurrentAttribute = Application.Driver.MakeAttribute(value.Foreground, value.Background);
	|                    return;
	|                }
	|                if (!value.Initialized) Debug.WriteLine(""ConsoleDriver.CurrentAttribute: Attributes must be initialized before use."");
	|
	|                currentAttribute = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Selects the specified attribute as the attribute to use for future calls to AddRune and AddString.
	|        /// </summary>
	|        /// <remarks>
	|        /// Implementations should call <c>base.SetAttribute(c)</c>.
	|        /// </remarks>
	|        /// <param name=""c"">C.</param>
	|        public virtual void SetAttribute(Attribute c)
	|        {
	|            CurrentAttribute = c;
	|        }
	|
	|        /// <summary>
	|        /// Set Colors from limit sets of colors. Not implemented by any driver: See Issue #2300.
	|        /// </summary>
	|        /// <param name=""foreground"">Foreground.</param>
	|        /// <param name=""background"">Background.</param>
	|        public abstract void SetColors(ConsoleColor foreground, ConsoleColor background);
	|
	|        // Advanced uses - set colors to any pre-set pairs, you would need to init_color
	|        // that independently with the R, G, B values.
	|        /// <summary>
	|        /// Advanced uses - set colors to any pre-set pairs, you would need to init_color
	|        /// that independently with the R, G, B values. Not implemented by any driver: See Issue #2300.
	|        /// </summary>
	|        /// <param name=""foregroundColorId"">Foreground color identifier.</param>
	|        /// <param name=""backgroundColorId"">Background color identifier.</param>
	|        public abstract void SetColors(short foregroundColorId, short backgroundColorId);
	|
	|        /// <summary>
	|        /// Gets the foreground and background colors based on the value.
	|        /// </summary>
	|        /// <param name=""value"">The value.</param>
	|        /// <param name=""foreground"">The foreground.</param>
	|        /// <param name=""background"">The background.</param>
	|        /// <returns></returns>
	|        public abstract bool GetColors(int value, out Color foreground, out Color background);
	|
	|        /// <summary>
	|        /// Allows sending keys without typing on a keyboard.
	|        /// </summary>
	|        /// <param name=""keyChar"">The character key.</param>
	|        /// <param name=""key"">The key.</param>
	|        /// <param name=""shift"">If shift key is sending.</param>
	|        /// <param name=""alt"">If alt key is sending.</param>
	|        /// <param name=""control"">If control key is sending.</param>
	|        public abstract void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);
	|
	|        /// <summary>
	|        /// Set the handler when the terminal is resized.
	|        /// </summary>
	|        /// <param name=""terminalResized""></param>
	|        public void SetTerminalResized(Action terminalResized)
	|        {
	|            TerminalResized = terminalResized;
	|        }
	|
	|        /// <summary>
	|        /// Draws the title for a Window-style view incorporating padding. 
	|        /// </summary>
	|        /// <param name=""region"">Screen relative region where the frame will be drawn.</param>
	|        /// <param name=""title"">The title for the window. The title will only be drawn if <c>title</c> is not null or empty and paddingTop is greater than 0.</param>
	|        /// <param name=""paddingLeft"">Number of columns to pad on the left (if 0 the border will not appear on the left).</param>
	|        /// <param name=""paddingTop"">Number of rows to pad on the top (if 0 the border and title will not appear on the top).</param>
	|        /// <param name=""paddingRight"">Number of columns to pad on the right (if 0 the border will not appear on the right).</param>
	|        /// <param name=""paddingBottom"">Number of rows to pad on the bottom (if 0 the border will not appear on the bottom).</param>
	|        /// <param name=""textAlignment"">Not yet implemented.</param>
	|        /// <remarks></remarks>
	|        public virtual void DrawWindowTitle(Rect region, ustring title, int paddingLeft, int paddingTop, int paddingRight, int paddingBottom, TextAlignment textAlignment = TextAlignment.Left)
	|        {
	|            var width = region.Width - (paddingLeft + 2) * 2;
	|            if (!ustring.IsNullOrEmpty(title) && width > 4 && region.Y + paddingTop <= region.Y + paddingBottom)
	|            {
	|                Move(region.X + 1 + paddingLeft, region.Y + paddingTop);
	|                AddRune(' ');
	|                var str = title.Sum(r => Math.Max(Rune.ColumnWidth(r), 1)) >= width
	|                    ? TextFormatter.Format(title, width - 2, false, false)[0] : title;
	|                AddStr(str);
	|                AddRune(' ');
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Enables diagnostic functions
	|        /// </summary>
	|        [Flags]
	|        public enum DiagnosticFlags : uint
	|        {
	|            /// <summary>
	|            /// All diagnostics off
	|            /// </summary>
	|            Off = 0b_0000_0000,
	|            /// <summary>
	|            /// When enabled, <see cref=""DrawWindowFrame(Rect, int, int, int, int, bool, bool, Border)""/> will draw a 
	|            /// ruler in the frame for any side with a padding value greater than 0.
	|            /// </summary>
	|            FrameRuler = 0b_0000_0001,
	|            /// <summary>
	|            /// When Enabled, <see cref=""DrawWindowFrame(Rect, int, int, int, int, bool, bool, Border)""/> will use
	|            /// 'L', 'R', 'T', and 'B' for padding instead of ' '.
	|            /// </summary>
	|            FramePadding = 0b_0000_0010,
	|        }
	|
	|        /// <summary>
	|        /// Set flags to enable/disable <see cref=""ConsoleDriver""/> diagnostics.
	|        /// </summary>
	|        public static DiagnosticFlags Diagnostics { get; set; }
	|
	|        /// <summary>
	|        /// Draws a frame for a window with padding and an optional visible border inside the padding. 
	|        /// </summary>
	|        /// <param name=""region"">Screen relative region where the frame will be drawn.</param>
	|        /// <param name=""paddingLeft"">Number of columns to pad on the left (if 0 the border will not appear on the left).</param>
	|        /// <param name=""paddingTop"">Number of rows to pad on the top (if 0 the border and title will not appear on the top).</param>
	|        /// <param name=""paddingRight"">Number of columns to pad on the right (if 0 the border will not appear on the right).</param>
	|        /// <param name=""paddingBottom"">Number of rows to pad on the bottom (if 0 the border will not appear on the bottom).</param>
	|        /// <param name=""border"">If set to <c>true</c> and any padding dimension is > 0 the border will be drawn.</param>
	|        /// <param name=""fill"">If set to <c>true</c> it will clear the content area (the area inside the padding) with the current color, otherwise the content area will be left untouched.</param>
	|        /// <param name=""borderContent"">The <see cref=""Border""/> to be used if defined.</param>
	|        public virtual void DrawWindowFrame(Rect region, int paddingLeft = 0, int paddingTop = 0, int paddingRight = 0,
	|            int paddingBottom = 0, bool border = true, bool fill = false, Border borderContent = null)
	|        {
	|            char clearChar = ' ';
	|            char leftChar = clearChar;
	|            char rightChar = clearChar;
	|            char topChar = clearChar;
	|            char bottomChar = clearChar;
	|
	|            if ((Diagnostics & DiagnosticFlags.FramePadding) == DiagnosticFlags.FramePadding)
	|            {
	|                leftChar = 'L';
	|                rightChar = 'R';
	|                topChar = 'T';
	|                bottomChar = 'B';
	|                clearChar = 'C';
	|            }
	|
	|            void AddRuneAt(int col, int row, Rune ch)
	|            {
	|                Move(col, row);
	|                AddRune(ch);
	|            }
	|
	|            // fwidth is count of hLine chars
	|            int fwidth = (int)(region.Width - (paddingRight + paddingLeft));
	|
	|            // fheight is count of vLine chars
	|            int fheight = (int)(region.Height - (paddingBottom + paddingTop));
	|
	|            // fleft is location of left frame line
	|            int fleft = region.X + paddingLeft - 1;
	|
	|            // fright is location of right frame line
	|            int fright = fleft + fwidth + 1;
	|
	|            // ftop is location of top frame line
	|            int ftop = region.Y + paddingTop - 1;
	|
	|            // fbottom is location of bottom frame line
	|            int fbottom = ftop + fheight + 1;
	|
	|            var borderStyle = borderContent == null ? BorderStyle.Single : borderContent.BorderStyle;
	|
	|            Rune hLine = default, vLine = default,
	|                uRCorner = default, uLCorner = default, lLCorner = default, lRCorner = default;
	|
	|            if (border)
	|            {
	|                switch (borderStyle)
	|                {
	|                    case BorderStyle.None:
	|                        break;
	|                    case BorderStyle.Single:
	|                        hLine = HLine;
	|                        vLine = VLine;
	|                        uRCorner = URCorner;
	|                        uLCorner = ULCorner;
	|                        lLCorner = LLCorner;
	|                        lRCorner = LRCorner;
	|                        break;
	|                    case BorderStyle.Double:
	|                        hLine = HDLine;
	|                        vLine = VDLine;
	|                        uRCorner = URDCorner;
	|                        uLCorner = ULDCorner;
	|                        lLCorner = LLDCorner;
	|                        lRCorner = LRDCorner;
	|                        break;
	|                    case BorderStyle.Rounded:
	|                        hLine = HRLine;
	|                        vLine = VRLine;
	|                        uRCorner = URRCorner;
	|                        uLCorner = ULRCorner;
	|                        lLCorner = LLRCorner;
	|                        lRCorner = LRRCorner;
	|                        break;
	|                }
	|            }
	|            else
	|            {
	|                hLine = vLine = uRCorner = uLCorner = lLCorner = lRCorner = clearChar;
	|            }
	|
	|            // Outside top
	|            if (paddingTop > 1)
	|            {
	|                for (int r = region.Y; r < ftop; r++)
	|                {
	|                    for (int c = region.X; c < region.X + region.Width; c++)
	|                    {
	|                        AddRuneAt(c, r, topChar);
	|                    }
	|                }
	|            }
	|
	|            // Outside top-left
	|            for (int c = region.X; c < fleft; c++)
	|            {
	|                AddRuneAt(c, ftop, leftChar);
	|            }
	|
	|            // Frame top-left corner
	|            AddRuneAt(fleft, ftop, paddingTop >= 0 ? (paddingLeft >= 0 ? uLCorner : hLine) : leftChar);
	|
	|            // Frame top
	|            for (int c = fleft + 1; c < fleft + 1 + fwidth; c++)
	|            {
	|                AddRuneAt(c, ftop, paddingTop > 0 ? hLine : topChar);
	|            }
	|
	|            // Frame top-right corner
	|            if (fright > fleft)
	|            {
	|                AddRuneAt(fright, ftop, paddingTop >= 0 ? (paddingRight >= 0 ? uRCorner : hLine) : rightChar);
	|            }
	|
	|            // Outside top-right corner
	|            for (int c = fright + 1; c < fright + paddingRight; c++)
	|            {
	|                AddRuneAt(c, ftop, rightChar);
	|            }
	|
	|            // Left, Fill, Right
	|            if (fbottom > ftop)
	|            {
	|                for (int r = ftop + 1; r < fbottom; r++)
	|                {
	|                    // Outside left
	|                    for (int c = region.X; c < fleft; c++)
	|                    {
	|                        AddRuneAt(c, r, leftChar);
	|                    }
	|
	|                    // Frame left
	|                    AddRuneAt(fleft, r, paddingLeft > 0 ? vLine : leftChar);
	|
	|                    // Fill
	|                    if (fill)
	|                    {
	|                        for (int x = fleft + 1; x < fright; x++)
	|                        {
	|                            AddRuneAt(x, r, clearChar);
	|                        }
	|                    }
	|
	|                    // Frame right
	|                    if (fright > fleft)
	|                    {
	|                        var v = vLine;
	|                        if ((Diagnostics & DiagnosticFlags.FrameRuler) == DiagnosticFlags.FrameRuler)
	|                        {
	|                            v = (char)(((int)'0') + ((r - ftop) % 10)); // vLine;
	|                        }
	|                        AddRuneAt(fright, r, paddingRight > 0 ? v : rightChar);
	|                    }
	|
	|                    // Outside right
	|                    for (int c = fright + 1; c < fright + paddingRight; c++)
	|                    {
	|                        AddRuneAt(c, r, rightChar);
	|                    }
	|                }
	|
	|                // Outside Bottom
	|                for (int c = region.X; c < region.X + region.Width; c++)
	|                {
	|                    AddRuneAt(c, fbottom, leftChar);
	|                }
	|
	|                // Frame bottom-left
	|                AddRuneAt(fleft, fbottom, paddingLeft > 0 ? lLCorner : leftChar);
	|
	|                if (fright > fleft)
	|                {
	|                    // Frame bottom
	|                    for (int c = fleft + 1; c < fright; c++)
	|                    {
	|                        var h = hLine;
	|                        if ((Diagnostics & DiagnosticFlags.FrameRuler) == DiagnosticFlags.FrameRuler)
	|                        {
	|                            h = (char)(((int)'0') + ((c - fleft) % 10)); // hLine;
	|                        }
	|                        AddRuneAt(c, fbottom, paddingBottom > 0 ? h : bottomChar);
	|                    }
	|
	|                    // Frame bottom-right
	|                    AddRuneAt(fright, fbottom, paddingRight > 0 ? (paddingBottom > 0 ? lRCorner : hLine) : rightChar);
	|                }
	|
	|                // Outside right
	|                for (int c = fright + 1; c < fright + paddingRight; c++)
	|                {
	|                    AddRuneAt(c, fbottom, rightChar);
	|                }
	|            }
	|
	|            // Out bottom - ensure top is always drawn if we overlap
	|            if (paddingBottom > 0)
	|            {
	|                for (int r = fbottom + 1; r < fbottom + paddingBottom; r++)
	|                {
	|                    for (int c = region.X; c < region.X + region.Width; c++)
	|                    {
	|                        AddRuneAt(c, r, bottomChar);
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Draws a frame on the specified region with the specified padding around the frame.
	|        /// </summary>
	|        /// <param name=""region"">Screen relative region where the frame will be drawn.</param>
	|        /// <param name=""padding"">Padding to add on the sides.</param>
	|        /// <param name=""fill"">If set to <c>true</c> it will clear the contents with the current color, otherwise the contents will be left untouched.</param>
	|        /// <remarks>This API has been superseded by <see cref=""DrawWindowFrame(Rect, int, int, int, int, bool, bool, Border)""/>.</remarks>
	|        /// <remarks>This API is equivalent to calling <c>DrawWindowFrame(Rect, p - 1, p - 1, p - 1, p - 1)</c>. In other words,
	|        /// A padding value of 0 means there is actually a one cell border.
	|        /// </remarks>
	|        public virtual void DrawFrame(Rect region, int padding, bool fill)
	|        {
	|            // DrawFrame assumes the border is always at least one row/col thick
	|            // DrawWindowFrame assumes a padding of 0 means NO padding and no frame
	|            DrawWindowFrame(new Rect(region.X, region.Y, region.Width, region.Height),
	|                padding + 1, padding + 1, padding + 1, padding + 1, border: false, fill: fill);
	|        }
	|
	|
	|        /// <summary>
	|        /// Suspend the application, typically needs to save the state, suspend the app and upon return, reset the console driver.
	|        /// </summary>
	|        public abstract void Suspend();
	|
	|        Rect clip;
	|
	|        /// <summary>
	|        /// Controls the current clipping region that AddRune/AddStr is subject to.
	|        /// </summary>
	|        /// <value>The clip.</value>
	|        public Rect Clip
	|        {
	|            get => clip;
	|            set => this.clip = value;
	|        }
	|
	|        /// <summary>
	|        /// Start of mouse moves.
	|        /// </summary>
	|        public abstract void StartReportingMouseMoves();
	|
	|        /// <summary>
	|        /// Stop reporting mouses moves.
	|        /// </summary>
	|        public abstract void StopReportingMouseMoves();
	|
	|        /// <summary>
	|        /// Disables the cooked event processing from the mouse driver. 
	|        /// At startup, it is assumed mouse events are cooked. Not implemented by any driver: See Issue #2300.
	|        /// </summary>
	|        public abstract void UncookMouse();
	|
	|        /// <summary>
	|        /// Enables the cooked event processing from the mouse driver. Not implemented by any driver: See Issue #2300.
	|        /// </summary>
	|        public abstract void CookMouse();
	|
	|        /// <summary>
	|        /// Horizontal line character.
	|        /// </summary>
	|        public Rune HLine = '\u2500';
	|
	|        /// <summary>
	|        /// Vertical line character.
	|        /// </summary>
	|        public Rune VLine = '\u2502';
	|
	|        /// <summary>
	|        /// Stipple pattern
	|        /// </summary>
	|        public Rune Stipple = '\u2591';
	|
	|        /// <summary>
	|        /// Diamond character
	|        /// </summary>
	|        public Rune Diamond = '\u25ca';
	|
	|        /// <summary>
	|        /// Upper left corner
	|        /// </summary>
	|        public Rune ULCorner = '\u250C';
	|
	|        /// <summary>
	|        /// Lower left corner
	|        /// </summary>
	|        public Rune LLCorner = '\u2514';
	|
	|        /// <summary>
	|        /// Upper right corner
	|        /// </summary>
	|        public Rune URCorner = '\u2510';
	|
	|        /// <summary>
	|        /// Lower right corner
	|        /// </summary>
	|        public Rune LRCorner = '\u2518';
	|
	|        /// <summary>
	|        /// Left tee
	|        /// </summary>
	|        public Rune LeftTee = '\u251c';
	|
	|        /// <summary>
	|        /// Right tee
	|        /// </summary>
	|        public Rune RightTee = '\u2524';
	|
	|        /// <summary>
	|        /// Top tee
	|        /// </summary>
	|        public Rune TopTee = '\u252c';
	|
	|        /// <summary>
	|        /// The bottom tee.
	|        /// </summary>
	|        public Rune BottomTee = '\u2534';
	|
	|        /// <summary>
	|        /// Checkmark.
	|        /// </summary>
	|        public Rune Checked = '\u221a';
	|
	|        /// <summary>
	|        /// Un-checked checkmark.
	|        /// </summary>
	|        public Rune UnChecked = '\u2574';
	|
	|        /// <summary>
	|        /// Selected mark.
	|        /// </summary>
	|        public Rune Selected = '\u25cf';
	|
	|        /// <summary>
	|        /// Un-selected selected mark.
	|        /// </summary>
	|        public Rune UnSelected = '\u25cc';
	|
	|        /// <summary>
	|        /// Right Arrow.
	|        /// </summary>
	|        public Rune RightArrow = '\u25ba';
	|
	|        /// <summary>
	|        /// Left Arrow.
	|        /// </summary>
	|        public Rune LeftArrow = '\u25c4';
	|
	|        /// <summary>
	|        /// Down Arrow.
	|        /// </summary>
	|        public Rune DownArrow = '\u25bc';
	|
	|        /// <summary>
	|        /// Up Arrow.
	|        /// </summary>
	|        public Rune UpArrow = '\u25b2';
	|
	|        /// <summary>
	|        /// Left indicator for default action (e.g. for <see cref=""Button""/>).
	|        /// </summary>
	|        public Rune LeftDefaultIndicator = '\u25e6';
	|
	|        /// <summary>
	|        /// Right indicator for default action (e.g. for <see cref=""Button""/>).
	|        /// </summary>
	|        public Rune RightDefaultIndicator = '\u25e6';
	|
	|        /// <summary>
	|        /// Left frame/bracket (e.g. '[' for <see cref=""Button""/>).
	|        /// </summary>
	|        public Rune LeftBracket = '[';
	|
	|        /// <summary>
	|        /// Right frame/bracket (e.g. ']' for <see cref=""Button""/>).
	|        /// </summary>
	|        public Rune RightBracket = ']';
	|
	|        /// <summary>
	|        /// Blocks Segment indicator for meter views (e.g. <see cref=""ProgressBar""/>.
	|        /// </summary>
	|        public Rune BlocksMeterSegment = '\u258c';
	|
	|        /// <summary>
	|        /// Continuous Segment indicator for meter views (e.g. <see cref=""ProgressBar""/>.
	|        /// </summary>
	|        public Rune ContinuousMeterSegment = '\u2588';
	|
	|        /// <summary>
	|        /// Horizontal double line character.
	|        /// </summary>
	|        public Rune HDLine = '\u2550';
	|
	|        /// <summary>
	|        /// Vertical double line character.
	|        /// </summary>
	|        public Rune VDLine = '\u2551';
	|
	|        /// <summary>
	|        /// Upper left double corner
	|        /// </summary>
	|        public Rune ULDCorner = '\u2554';
	|
	|        /// <summary>
	|        /// Lower left double corner
	|        /// </summary>
	|        public Rune LLDCorner = '\u255a';
	|
	|        /// <summary>
	|        /// Upper right double corner
	|        /// </summary>
	|        public Rune URDCorner = '\u2557';
	|
	|        /// <summary>
	|        /// Lower right double corner
	|        /// </summary>
	|        public Rune LRDCorner = '\u255d';
	|
	|        /// <summary>
	|        /// Horizontal line character for rounded corners.
	|        /// </summary>
	|        public Rune HRLine = '\u2500';
	|
	|        /// <summary>
	|        /// Vertical line character for rounded corners.
	|        /// </summary>
	|        public Rune VRLine = '\u2502';
	|
	|        /// <summary>
	|        /// Upper left rounded corner
	|        /// </summary>
	|        public Rune ULRCorner = '\u256d';
	|
	|        /// <summary>
	|        /// Lower left rounded corner
	|        /// </summary>
	|        public Rune LLRCorner = '\u2570';
	|
	|        /// <summary>
	|        /// Upper right rounded corner
	|        /// </summary>
	|        public Rune URRCorner = '\u256e';
	|
	|        /// <summary>
	|        /// Lower right rounded corner
	|        /// </summary>
	|        public Rune LRRCorner = '\u256f';
	|        private Attribute currentAttribute;
	|
	|        /// <summary>
	|        /// Make the attribute for the foreground and background colors.
	|        /// </summary>
	|        /// <param name=""fore"">Foreground.</param>
	|        /// <param name=""back"">Background.</param>
	|        /// <returns></returns>
	|        public abstract Attribute MakeAttribute(Color fore, Color back);
	|
	|        /// <summary>
	|        /// Gets the current <see cref=""Attribute""/>.
	|        /// </summary>
	|        /// <returns>The current attribute.</returns>
	|        public Attribute GetAttribute() => CurrentAttribute;
	|
	|        /// <summary>
	|        /// Make the <see cref=""Colors""/> for the <see cref=""ColorScheme""/>.
	|        /// </summary>
	|        /// <param name=""foreground"">The foreground color.</param>
	|        /// <param name=""background"">The background color.</param>
	|        /// <returns>The attribute for the foreground and background colors.</returns>
	|        public abstract Attribute MakeColor(Color foreground, Color background);
	|
	|        /// <summary>
	|        /// Ensures all <see cref=""Attribute""/>s in <see cref=""Colors.ColorSchemes""/> are correctly 
	|        /// initialized by the driver.
	|        /// </summary>
	|        /// <param name=""supportsColors"">Flag indicating if colors are supported (not used).</param>
	|        public void InitalizeColorSchemes(bool supportsColors = true)
	|        {
	|            // Ensure all Attributes are initialized by the driver
	|            foreach (var s in Colors.ColorSchemes)
	|            {
	|                s.Value.Initialize();
	|            }
	|
	|            if (!supportsColors)
	|            {
	|                return;
	|            }
	|
	|
	|            // Define the default color theme only if the user has not defined one.
	|
	|            Colors.TopLevel.Normal = MakeColor(Color.BrightGreen, Color.Black);
	|            Colors.TopLevel.Focus = MakeColor(Color.White, Color.Cyan);
	|            Colors.TopLevel.HotNormal = MakeColor(Color.Brown, Color.Black);
	|            Colors.TopLevel.HotFocus = MakeColor(Color.Blue, Color.Cyan);
	|            Colors.TopLevel.Disabled = MakeColor(Color.DarkGray, Color.Black);
	|
	|            Colors.Base.Normal = MakeColor(Color.White, Color.Blue);
	|            Colors.Base.Focus = MakeColor(Color.Black, Color.Gray);
	|            Colors.Base.HotNormal = MakeColor(Color.BrightCyan, Color.Blue);
	|            Colors.Base.HotFocus = MakeColor(Color.BrightBlue, Color.Gray);
	|            Colors.Base.Disabled = MakeColor(Color.DarkGray, Color.Blue);
	|
	|            Colors.Dialog.Normal = MakeColor(Color.Black, Color.Gray);
	|            Colors.Dialog.Focus = MakeColor(Color.White, Color.DarkGray);
	|            Colors.Dialog.HotNormal = MakeColor(Color.Blue, Color.Gray);
	|            Colors.Dialog.HotFocus = MakeColor(Color.BrightYellow, Color.DarkGray);
	|            Colors.Dialog.Disabled = MakeColor(Color.Gray, Color.DarkGray);
	|
	|            Colors.Menu.Normal = MakeColor(Color.White, Color.DarkGray);
	|            Colors.Menu.Focus = MakeColor(Color.White, Color.Black);
	|            Colors.Menu.HotNormal = MakeColor(Color.BrightYellow, Color.DarkGray);
	|            Colors.Menu.HotFocus = MakeColor(Color.BrightYellow, Color.Black);
	|            Colors.Menu.Disabled = MakeColor(Color.Gray, Color.DarkGray);
	|
	|            Colors.Error.Normal = MakeColor(Color.Red, Color.White);
	|            Colors.Error.Focus = MakeColor(Color.Black, Color.BrightRed);
	|            Colors.Error.HotNormal = MakeColor(Color.Black, Color.White);
	|            Colors.Error.HotFocus = MakeColor(Color.White, Color.BrightRed);
	|            Colors.Error.Disabled = MakeColor(Color.DarkGray, Color.White);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Helper class for console drivers to invoke shell commands to interact with the clipboard.
	|    /// Used primarily by CursesDriver, but also used in Unit tests which is why it is in
	|    /// ConsoleDriver.cs.
	|    /// </summary>
	|    internal static class ClipboardProcessRunner
	|    {
	|        public static (int exitCode, string result) Bash(string commandLine, string inputText = """", bool waitForOutput = false)
	|        {
	|            var arguments = $""-c \""{commandLine}\"""";
	|            var (exitCode, result) = Process(""bash"", arguments, inputText, waitForOutput);
	|
	|            return (exitCode, result.TrimEnd());
	|        }
	|
	|        public static (int exitCode, string result) Process(string cmd, string arguments, string input = null, bool waitForOutput = true)
	|        {
	|            var output = string.Empty;
	|
	|            using (Process process = new Process
	|            {
	|                StartInfo = new ProcessStartInfo
	|                {
	|                    FileName = cmd,
	|                    Arguments = arguments,
	|                    RedirectStandardOutput = true,
	|                    RedirectStandardError = true,
	|                    RedirectStandardInput = true,
	|                    UseShellExecute = false,
	|                    CreateNoWindow = true,
	|                }
	|            })
	|            {
	|                var eventHandled = new TaskCompletionSource<bool>();
	|                process.Start();
	|                if (!string.IsNullOrEmpty(input))
	|                {
	|                    process.StandardInput.Write(input);
	|                    process.StandardInput.Close();
	|                }
	|
	|                if (!process.WaitForExit(10000))
	|                {
	|                    var timeoutError = $@""Process timed out. Command line: {process.StartInfo.FileName} {process.StartInfo.Arguments}."";
	|                    throw new TimeoutException(timeoutError);
	|                }
	|
	|                if (waitForOutput && process.StandardOutput.Peek() != -1)
	|                {
	|                    output = process.StandardOutput.ReadToEnd();
	|                }
	|
	|                if (process.ExitCode > 0)
	|                {
	|                    output = $@""Process failed to run. Command line: {cmd} {arguments}.
	|										Output: {output}
	|										Error: {process.StandardError.ReadToEnd()}"";
	|                }
	|
	|                return (process.ExitCode, output);
	|            }
	|        }
	|
	|        public static bool DoubleWaitForExit(this System.Diagnostics.Process process)
	|        {
	|            var result = process.WaitForExit(500);
	|            if (result)
	|            {
	|                process.WaitForExit();
	|            }
	|            return result;
	|        }
	|
	|        public static bool FileExists(this string value)
	|        {
	|            return !string.IsNullOrEmpty(value) && !value.Contains(""not found"");
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Helper class to handle the scan code and virtual key from a <see cref=""ConsoleKey""/>.
	|    /// </summary>
	|    public static class ConsoleKeyMapping
	|    {
	|        private class ScanCodeMapping : IEquatable<ScanCodeMapping>
	|        {
	|            public uint ScanCode;
	|            public uint VirtualKey;
	|            public ConsoleModifiers Modifiers;
	|            public uint UnicodeChar;
	|
	|            public ScanCodeMapping(uint scanCode, uint virtualKey, ConsoleModifiers modifiers, uint unicodeChar)
	|            {
	|                ScanCode = scanCode;
	|                VirtualKey = virtualKey;
	|                Modifiers = modifiers;
	|                UnicodeChar = unicodeChar;
	|            }
	|
	|            public bool Equals(ScanCodeMapping other)
	|            {
	|                return (this.ScanCode.Equals(other.ScanCode) &&
	|                    this.VirtualKey.Equals(other.VirtualKey) &&
	|                    this.Modifiers.Equals(other.Modifiers) &&
	|                    this.UnicodeChar.Equals(other.UnicodeChar));
	|            }
	|        }
	|
	|        private static ConsoleModifiers GetModifiers(uint unicodeChar, ConsoleModifiers modifiers, bool isConsoleKey)
	|        {
	|            if (modifiers.HasFlag(ConsoleModifiers.Shift) &&
	|                !modifiers.HasFlag(ConsoleModifiers.Alt) &&
	|                !modifiers.HasFlag(ConsoleModifiers.Control))
	|            {
	|
	|                return ConsoleModifiers.Shift;
	|            }
	|            else if (modifiers == (ConsoleModifiers.Alt | ConsoleModifiers.Control))
	|            {
	|                return modifiers;
	|            }
	|            else if ((!isConsoleKey || (isConsoleKey && (modifiers.HasFlag(ConsoleModifiers.Shift) ||
	|              modifiers.HasFlag(ConsoleModifiers.Alt) || modifiers.HasFlag(ConsoleModifiers.Control)))) &&
	|              unicodeChar >= 65 && unicodeChar <= 90)
	|            {
	|
	|                return ConsoleModifiers.Shift;
	|            }
	|            return 0;
	|        }
	|
	|        private static ScanCodeMapping GetScanCode(string propName, uint keyValue, ConsoleModifiers modifiers)
	|        {
	|            switch (propName)
	|            {
	|                case ""UnicodeChar"":
	|                    var sCode = scanCodes.FirstOrDefault((e) => e.UnicodeChar == keyValue && e.Modifiers == modifiers);
	|                    if (sCode == null && modifiers == (ConsoleModifiers.Alt | ConsoleModifiers.Control))
	|                    {
	|                        return scanCodes.FirstOrDefault((e) => e.UnicodeChar == keyValue && e.Modifiers == 0);
	|                    }
	|                    return sCode;
	|                case ""VirtualKey"":
	|                    sCode = scanCodes.FirstOrDefault((e) => e.VirtualKey == keyValue && e.Modifiers == modifiers);
	|                    if (sCode == null && modifiers == (ConsoleModifiers.Alt | ConsoleModifiers.Control))
	|                    {
	|                        return scanCodes.FirstOrDefault((e) => e.VirtualKey == keyValue && e.Modifiers == 0);
	|                    }
	|                    return sCode;
	|            }
	|
	|            return null;
	|        }
	|
	|        /// <summary>
	|        /// Get the <see cref=""ConsoleKey""/> from a <see cref=""Key""/>.
	|        /// </summary>
	|        /// <param name=""keyValue"">The key value.</param>
	|        /// <param name=""modifiers"">The modifiers keys.</param>
	|        /// <param name=""scanCode"">The resulting scan code.</param>
	|        /// <param name=""outputChar"">The resulting output character.</param>
	|        /// <returns>The <see cref=""ConsoleKey""/> or the <paramref name=""outputChar""/>.</returns>
	|        public static uint GetConsoleKeyFromKey(uint keyValue, ConsoleModifiers modifiers, out uint scanCode, out uint outputChar)
	|        {
	|            scanCode = 0;
	|            outputChar = keyValue;
	|            if (keyValue == 0)
	|            {
	|                return 0;
	|            }
	|
	|            uint consoleKey = MapKeyToConsoleKey(keyValue, out bool mappable);
	|            if (mappable)
	|            {
	|                var mod = GetModifiers(keyValue, modifiers, false);
	|                var scode = GetScanCode(""UnicodeChar"", keyValue, mod);
	|                if (scode != null)
	|                {
	|                    consoleKey = scode.VirtualKey;
	|                    scanCode = scode.ScanCode;
	|                    outputChar = scode.UnicodeChar;
	|                }
	|                else
	|                {
	|                    consoleKey = consoleKey < 0xff ? (uint)(consoleKey & 0xff | 0xff << 8) : consoleKey;
	|                }
	|            }
	|            else
	|            {
	|                var mod = GetModifiers(keyValue, modifiers, false);
	|                var scode = GetScanCode(""VirtualKey"", consoleKey, mod);
	|                if (scode != null)
	|                {
	|                    consoleKey = scode.VirtualKey;
	|                    scanCode = scode.ScanCode;
	|                    outputChar = scode.UnicodeChar;
	|                }
	|            }
	|
	|            return consoleKey;
	|        }
	|
	|        /// <summary>
	|        /// Get the output character from the <see cref=""ConsoleKey""/>.
	|        /// </summary>
	|        /// <param name=""unicodeChar"">The unicode character.</param>
	|        /// <param name=""modifiers"">The modifiers keys.</param>
	|        /// <param name=""consoleKey"">The resulting console key.</param>
	|        /// <param name=""scanCode"">The resulting scan code.</param>
	|        /// <returns>The output character or the <paramref name=""consoleKey""/>.</returns>
	|        public static uint GetKeyCharFromConsoleKey(uint unicodeChar, ConsoleModifiers modifiers, out uint consoleKey, out uint scanCode)
	|        {
	|            uint decodedChar = unicodeChar >> 8 == 0xff ? unicodeChar & 0xff : unicodeChar;
	|            uint keyChar = decodedChar;
	|            consoleKey = 0;
	|            var mod = GetModifiers(decodedChar, modifiers, true);
	|            scanCode = 0;
	|            var scode = unicodeChar != 0 && unicodeChar >> 8 != 0xff ? GetScanCode(""VirtualKey"", decodedChar, mod) : null;
	|            if (scode != null)
	|            {
	|                consoleKey = scode.VirtualKey;
	|                keyChar = scode.UnicodeChar;
	|                scanCode = scode.ScanCode;
	|            }
	|            if (scode == null)
	|            {
	|                scode = unicodeChar != 0 ? GetScanCode(""UnicodeChar"", decodedChar, mod) : null;
	|                if (scode != null)
	|                {
	|                    consoleKey = scode.VirtualKey;
	|                    keyChar = scode.UnicodeChar;
	|                    scanCode = scode.ScanCode;
	|                }
	|            }
	|            if (decodedChar != 0 && scanCode == 0 && char.IsLetter((char)decodedChar))
	|            {
	|                string stFormD = ((char)decodedChar).ToString().Normalize(System.Text.NormalizationForm.FormD);
	|                for (int i = 0; i < stFormD.Length; i++)
	|                {
	|                    UnicodeCategory uc = CharUnicodeInfo.GetUnicodeCategory(stFormD[i]);
	|                    if (uc != UnicodeCategory.NonSpacingMark && uc != UnicodeCategory.OtherLetter)
	|                    {
	|                        consoleKey = char.ToUpper(stFormD[i]);
	|                        scode = GetScanCode(""VirtualKey"", char.ToUpper(stFormD[i]), 0);
	|                        if (scode != null)
	|                        {
	|                            scanCode = scode.ScanCode;
	|                        }
	|                    }
	|                }
	|            }
	|
	|            return keyChar;
	|        }
	|
	|        /// <summary>
	|        /// Maps a <see cref=""Key""/> to a <see cref=""ConsoleKey""/>.
	|        /// </summary>
	|        /// <param name=""keyValue"">The key value.</param>
	|        /// <param name=""isMappable"">If <see langword=""true""/> is mapped to a valid character, otherwise <see langword=""false""/>.</param>
	|        /// <returns>The <see cref=""ConsoleKey""/> or the <paramref name=""keyValue""/>.</returns>
	|        public static uint MapKeyToConsoleKey(uint keyValue, out bool isMappable)
	|        {
	|            isMappable = false;
	|
	|            switch ((Key)keyValue)
	|            {
	|                case Key.Delete:
	|                    return (uint)ConsoleKey.Delete;
	|                case Key.CursorUp:
	|                    return (uint)ConsoleKey.UpArrow;
	|                case Key.CursorDown:
	|                    return (uint)ConsoleKey.DownArrow;
	|                case Key.CursorLeft:
	|                    return (uint)ConsoleKey.LeftArrow;
	|                case Key.CursorRight:
	|                    return (uint)ConsoleKey.RightArrow;
	|                case Key.PageUp:
	|                    return (uint)ConsoleKey.PageUp;
	|                case Key.PageDown:
	|                    return (uint)ConsoleKey.PageDown;
	|                case Key.Home:
	|                    return (uint)ConsoleKey.Home;
	|                case Key.End:
	|                    return (uint)ConsoleKey.End;
	|                case Key.InsertChar:
	|                    return (uint)ConsoleKey.Insert;
	|                case Key.DeleteChar:
	|                    return (uint)ConsoleKey.Delete;
	|                case Key.F1:
	|                    return (uint)ConsoleKey.F1;
	|                case Key.F2:
	|                    return (uint)ConsoleKey.F2;
	|                case Key.F3:
	|                    return (uint)ConsoleKey.F3;
	|                case Key.F4:
	|                    return (uint)ConsoleKey.F4;
	|                case Key.F5:
	|                    return (uint)ConsoleKey.F5;
	|                case Key.F6:
	|                    return (uint)ConsoleKey.F6;
	|                case Key.F7:
	|                    return (uint)ConsoleKey.F7;
	|                case Key.F8:
	|                    return (uint)ConsoleKey.F8;
	|                case Key.F9:
	|                    return (uint)ConsoleKey.F9;
	|                case Key.F10:
	|                    return (uint)ConsoleKey.F10;
	|                case Key.F11:
	|                    return (uint)ConsoleKey.F11;
	|                case Key.F12:
	|                    return (uint)ConsoleKey.F12;
	|                case Key.F13:
	|                    return (uint)ConsoleKey.F13;
	|                case Key.F14:
	|                    return (uint)ConsoleKey.F14;
	|                case Key.F15:
	|                    return (uint)ConsoleKey.F15;
	|                case Key.F16:
	|                    return (uint)ConsoleKey.F16;
	|                case Key.F17:
	|                    return (uint)ConsoleKey.F17;
	|                case Key.F18:
	|                    return (uint)ConsoleKey.F18;
	|                case Key.F19:
	|                    return (uint)ConsoleKey.F19;
	|                case Key.F20:
	|                    return (uint)ConsoleKey.F20;
	|                case Key.F21:
	|                    return (uint)ConsoleKey.F21;
	|                case Key.F22:
	|                    return (uint)ConsoleKey.F22;
	|                case Key.F23:
	|                    return (uint)ConsoleKey.F23;
	|                case Key.F24:
	|                    return (uint)ConsoleKey.F24;
	|                case Key.BackTab:
	|                    return (uint)ConsoleKey.Tab;
	|                case Key.Unknown:
	|                    isMappable = true;
	|                    return 0;
	|            }
	|            isMappable = true;
	|
	|            return keyValue;
	|        }
	|
	|        /// <summary>
	|        /// Maps a <see cref=""ConsoleKey""/> to a <see cref=""Key""/>.
	|        /// </summary>
	|        /// <param name=""consoleKey"">The console key.</param>
	|        /// <param name=""isMappable"">If <see langword=""true""/> is mapped to a valid character, otherwise <see langword=""false""/>.</param>
	|        /// <returns>The <see cref=""Key""/> or the <paramref name=""consoleKey""/>.</returns>
	|        public static Key MapConsoleKeyToKey(ConsoleKey consoleKey, out bool isMappable)
	|        {
	|            isMappable = false;
	|
	|            switch (consoleKey)
	|            {
	|                case ConsoleKey.Delete:
	|                    return Key.Delete;
	|                case ConsoleKey.UpArrow:
	|                    return Key.CursorUp;
	|                case ConsoleKey.DownArrow:
	|                    return Key.CursorDown;
	|                case ConsoleKey.LeftArrow:
	|                    return Key.CursorLeft;
	|                case ConsoleKey.RightArrow:
	|                    return Key.CursorRight;
	|                case ConsoleKey.PageUp:
	|                    return Key.PageUp;
	|                case ConsoleKey.PageDown:
	|                    return Key.PageDown;
	|                case ConsoleKey.Home:
	|                    return Key.Home;
	|                case ConsoleKey.End:
	|                    return Key.End;
	|                case ConsoleKey.Insert:
	|                    return Key.InsertChar;
	|                case ConsoleKey.F1:
	|                    return Key.F1;
	|                case ConsoleKey.F2:
	|                    return Key.F2;
	|                case ConsoleKey.F3:
	|                    return Key.F3;
	|                case ConsoleKey.F4:
	|                    return Key.F4;
	|                case ConsoleKey.F5:
	|                    return Key.F5;
	|                case ConsoleKey.F6:
	|                    return Key.F6;
	|                case ConsoleKey.F7:
	|                    return Key.F7;
	|                case ConsoleKey.F8:
	|                    return Key.F8;
	|                case ConsoleKey.F9:
	|                    return Key.F9;
	|                case ConsoleKey.F10:
	|                    return Key.F10;
	|                case ConsoleKey.F11:
	|                    return Key.F11;
	|                case ConsoleKey.F12:
	|                    return Key.F12;
	|                case ConsoleKey.F13:
	|                    return Key.F13;
	|                case ConsoleKey.F14:
	|                    return Key.F14;
	|                case ConsoleKey.F15:
	|                    return Key.F15;
	|                case ConsoleKey.F16:
	|                    return Key.F16;
	|                case ConsoleKey.F17:
	|                    return Key.F17;
	|                case ConsoleKey.F18:
	|                    return Key.F18;
	|                case ConsoleKey.F19:
	|                    return Key.F19;
	|                case ConsoleKey.F20:
	|                    return Key.F20;
	|                case ConsoleKey.F21:
	|                    return Key.F21;
	|                case ConsoleKey.F22:
	|                    return Key.F22;
	|                case ConsoleKey.F23:
	|                    return Key.F23;
	|                case ConsoleKey.F24:
	|                    return Key.F24;
	|                case ConsoleKey.Tab:
	|                    return Key.BackTab;
	|            }
	|            isMappable = true;
	|
	|            return (Key)consoleKey;
	|        }
	|
	|        /// <summary>
	|        /// Maps a <see cref=""ConsoleKeyInfo""/> to a <see cref=""Key""/>.
	|        /// </summary>
	|        /// <param name=""keyInfo"">The console key info.</param>
	|        /// <param name=""key"">The key.</param>
	|        /// <returns>The <see cref=""Key""/> with <see cref=""ConsoleModifiers""/> or the <paramref name=""key""/></returns>
	|        public static Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
	|        {
	|            Key keyMod = new Key();
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
	|                keyMod = Key.ShiftMask;
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
	|                keyMod |= Key.CtrlMask;
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
	|                keyMod |= Key.AltMask;
	|
	|            return keyMod != Key.Null ? keyMod | key : key;
	|        }
	|
	|        private static HashSet<ScanCodeMapping> scanCodes = new HashSet<ScanCodeMapping> {
	|            new ScanCodeMapping (1,27,0,27),	// Escape
	|			new ScanCodeMapping (1,27,ConsoleModifiers.Shift,27),
	|            new ScanCodeMapping (2,49,0,49),	// D1
	|			new ScanCodeMapping (2,49,ConsoleModifiers.Shift,33),
	|            new ScanCodeMapping (3,50,0,50),	// D2
	|			new ScanCodeMapping (3,50,ConsoleModifiers.Shift,34),
	|            new ScanCodeMapping (3,50,ConsoleModifiers.Alt | ConsoleModifiers.Control,64),
	|            new ScanCodeMapping (4,51,0,51),	// D3
	|			new ScanCodeMapping (4,51,ConsoleModifiers.Shift,35),
	|            new ScanCodeMapping (4,51,ConsoleModifiers.Alt | ConsoleModifiers.Control,163),
	|            new ScanCodeMapping (5,52,0,52),	// D4
	|			new ScanCodeMapping (5,52,ConsoleModifiers.Shift,36),
	|            new ScanCodeMapping (5,52,ConsoleModifiers.Alt | ConsoleModifiers.Control,167),
	|            new ScanCodeMapping (6,53,0,53),	// D5
	|			new ScanCodeMapping (6,53,ConsoleModifiers.Shift,37),
	|            new ScanCodeMapping (6,53,ConsoleModifiers.Alt | ConsoleModifiers.Control,8364),
	|            new ScanCodeMapping (7,54,0,54),	// D6
	|			new ScanCodeMapping (7,54,ConsoleModifiers.Shift,38),
	|            new ScanCodeMapping (8,55,0,55),	// D7
	|			new ScanCodeMapping (8,55,ConsoleModifiers.Shift,47),
	|            new ScanCodeMapping (8,55,ConsoleModifiers.Alt | ConsoleModifiers.Control,123),
	|            new ScanCodeMapping (9,56,0,56),	// D8
	|			new ScanCodeMapping (9,56,ConsoleModifiers.Shift,40),
	|            new ScanCodeMapping (9,56,ConsoleModifiers.Alt | ConsoleModifiers.Control,91),
	|            new ScanCodeMapping (10,57,0,57),	// D9
	|			new ScanCodeMapping (10,57,ConsoleModifiers.Shift,41),
	|            new ScanCodeMapping (10,57,ConsoleModifiers.Alt | ConsoleModifiers.Control,93),
	|            new ScanCodeMapping (11,48,0,48),	// D0
	|			new ScanCodeMapping (11,48,ConsoleModifiers.Shift,61),
	|            new ScanCodeMapping (11,48,ConsoleModifiers.Alt | ConsoleModifiers.Control,125),
	|            new ScanCodeMapping (12,219,0,39),	// Oem4
	|			new ScanCodeMapping (12,219,ConsoleModifiers.Shift,63),
	|            new ScanCodeMapping (13,221,0,171),	// Oem6
	|			new ScanCodeMapping (13,221,ConsoleModifiers.Shift,187),
	|            new ScanCodeMapping (14,8,0,8),		// Backspace
	|			new ScanCodeMapping (14,8,ConsoleModifiers.Shift,8),
	|            new ScanCodeMapping (15,9,0,9),		// Tab
	|			new ScanCodeMapping (15,9,ConsoleModifiers.Shift,15),
	|            new ScanCodeMapping (16,81,0,113),	// Q
	|			new ScanCodeMapping (16,81,ConsoleModifiers.Shift,81),
	|            new ScanCodeMapping (17,87,0,119),	// W
	|			new ScanCodeMapping (17,87,ConsoleModifiers.Shift,87),
	|            new ScanCodeMapping (18,69,0,101),	// E
	|			new ScanCodeMapping (18,69,ConsoleModifiers.Shift,69),
	|            new ScanCodeMapping (19,82,0,114),	// R
	|			new ScanCodeMapping (19,82,ConsoleModifiers.Shift,82),
	|            new ScanCodeMapping (20,84,0,116),	// T
	|			new ScanCodeMapping (20,84,ConsoleModifiers.Shift,84),
	|            new ScanCodeMapping (21,89,0,121),	// Y
	|			new ScanCodeMapping (21,89,ConsoleModifiers.Shift,89),
	|            new ScanCodeMapping (22,85,0,117),	// U
	|			new ScanCodeMapping (22,85,ConsoleModifiers.Shift,85),
	|            new ScanCodeMapping (23,73,0,105),	// I
	|			new ScanCodeMapping (23,73,ConsoleModifiers.Shift,73),
	|            new ScanCodeMapping (24,79,0,111),	// O
	|			new ScanCodeMapping (24,79,ConsoleModifiers.Shift,79),
	|            new ScanCodeMapping (25,80,0,112),	// P
	|			new ScanCodeMapping (25,80,ConsoleModifiers.Shift,80),
	|            new ScanCodeMapping (26,187,0,43),	// OemPlus
	|			new ScanCodeMapping (26,187,ConsoleModifiers.Shift,42),
	|            new ScanCodeMapping (26,187,ConsoleModifiers.Alt | ConsoleModifiers.Control,168),
	|            new ScanCodeMapping (27,186,0,180),	// Oem1
	|			new ScanCodeMapping (27,186,ConsoleModifiers.Shift,96),
	|            new ScanCodeMapping (28,13,0,13),	// Enter
	|			new ScanCodeMapping (28,13,ConsoleModifiers.Shift,13),
	|            new ScanCodeMapping (29,17,0,0),	// Control
	|			new ScanCodeMapping (29,17,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (30,65,0,97),	// A
	|			new ScanCodeMapping (30,65,ConsoleModifiers.Shift,65),
	|            new ScanCodeMapping (31,83,0,115),	// S
	|			new ScanCodeMapping (31,83,ConsoleModifiers.Shift,83),
	|            new ScanCodeMapping (32,68,0,100),	// D
	|			new ScanCodeMapping (32,68,ConsoleModifiers.Shift,68),
	|            new ScanCodeMapping (33,70,0,102),	// F
	|			new ScanCodeMapping (33,70,ConsoleModifiers.Shift,70),
	|            new ScanCodeMapping (34,71,0,103),	// G
	|			new ScanCodeMapping (34,71,ConsoleModifiers.Shift,71),
	|            new ScanCodeMapping (35,72,0,104),	// H
	|			new ScanCodeMapping (35,72,ConsoleModifiers.Shift,72),
	|            new ScanCodeMapping (36,74,0,106),	// J
	|			new ScanCodeMapping (36,74,ConsoleModifiers.Shift,74),
	|            new ScanCodeMapping (37,75,0,107),	// K
	|			new ScanCodeMapping (37,75,ConsoleModifiers.Shift,75),
	|            new ScanCodeMapping (38,76,0,108),	// L
	|			new ScanCodeMapping (38,76,ConsoleModifiers.Shift,76),
	|            new ScanCodeMapping (39,192,0,231),	// Oem3
	|			new ScanCodeMapping (39,192,ConsoleModifiers.Shift,199),
	|            new ScanCodeMapping (40,222,0,186),	// Oem7
	|			new ScanCodeMapping (40,222,ConsoleModifiers.Shift,170),
	|            new ScanCodeMapping (41,220,0,92),	// Oem5
	|			new ScanCodeMapping (41,220,ConsoleModifiers.Shift,124),
	|            new ScanCodeMapping (42,16,0,0),	// LShift
	|			new ScanCodeMapping (42,16,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (43,191,0,126),	// Oem2
	|			new ScanCodeMapping (43,191,ConsoleModifiers.Shift,94),
	|            new ScanCodeMapping (44,90,0,122),	// Z
	|			new ScanCodeMapping (44,90,ConsoleModifiers.Shift,90),
	|            new ScanCodeMapping (45,88,0,120),	// X
	|			new ScanCodeMapping (45,88,ConsoleModifiers.Shift,88),
	|            new ScanCodeMapping (46,67,0,99),	// C
	|			new ScanCodeMapping (46,67,ConsoleModifiers.Shift,67),
	|            new ScanCodeMapping (47,86,0,118),	// V
	|			new ScanCodeMapping (47,86,ConsoleModifiers.Shift,86),
	|            new ScanCodeMapping (48,66,0,98),	// B
	|			new ScanCodeMapping (48,66,ConsoleModifiers.Shift,66),
	|            new ScanCodeMapping (49,78,0,110),	// N
	|			new ScanCodeMapping (49,78,ConsoleModifiers.Shift,78),
	|            new ScanCodeMapping (50,77,0,109),	// M
	|			new ScanCodeMapping (50,77,ConsoleModifiers.Shift,77),
	|            new ScanCodeMapping (51,188,0,44),	// OemComma
	|			new ScanCodeMapping (51,188,ConsoleModifiers.Shift,59),
	|            new ScanCodeMapping (52,190,0,46),	// OemPeriod
	|			new ScanCodeMapping (52,190,ConsoleModifiers.Shift,58),
	|            new ScanCodeMapping (53,189,0,45),	// OemMinus
	|			new ScanCodeMapping (53,189,ConsoleModifiers.Shift,95),
	|            new ScanCodeMapping (54,16,0,0),	// RShift
	|			new ScanCodeMapping (54,16,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (55,44,0,0),	// PrintScreen
	|			new ScanCodeMapping (55,44,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (56,18,0,0),	// Alt
	|			new ScanCodeMapping (56,18,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (57,32,0,32),	// Spacebar
	|			new ScanCodeMapping (57,32,ConsoleModifiers.Shift,32),
	|            new ScanCodeMapping (58,20,0,0),	// Caps
	|			new ScanCodeMapping (58,20,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (59,112,0,0),	// F1
	|			new ScanCodeMapping (59,112,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (60,113,0,0),	// F2
	|			new ScanCodeMapping (60,113,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (61,114,0,0),	// F3
	|			new ScanCodeMapping (61,114,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (62,115,0,0),	// F4
	|			new ScanCodeMapping (62,115,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (63,116,0,0),	// F5
	|			new ScanCodeMapping (63,116,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (64,117,0,0),	// F6
	|			new ScanCodeMapping (64,117,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (65,118,0,0),	// F7
	|			new ScanCodeMapping (65,118,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (66,119,0,0),	// F8
	|			new ScanCodeMapping (66,119,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (67,120,0,0),	// F9
	|			new ScanCodeMapping (67,120,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (68,121,0,0),	// F10
	|			new ScanCodeMapping (68,121,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (69,144,0,0),	// Num
	|			new ScanCodeMapping (69,144,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (70,145,0,0),	// Scroll
	|			new ScanCodeMapping (70,145,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (71,36,0,0),	// Home
	|			new ScanCodeMapping (71,36,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (72,38,0,0),	// UpArrow
	|			new ScanCodeMapping (72,38,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (73,33,0,0),	// PageUp
	|			new ScanCodeMapping (73,33,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (74,109,0,45),	// Subtract
	|			new ScanCodeMapping (74,109,ConsoleModifiers.Shift,45),
	|            new ScanCodeMapping (75,37,0,0),	// LeftArrow
	|			new ScanCodeMapping (75,37,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (76,12,0,0),	// Center
	|			new ScanCodeMapping (76,12,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (77,39,0,0),	// RightArrow
	|			new ScanCodeMapping (77,39,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (78,107,0,43),	// Add
	|			new ScanCodeMapping (78,107,ConsoleModifiers.Shift,43),
	|            new ScanCodeMapping (79,35,0,0),	// End
	|			new ScanCodeMapping (79,35,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (80,40,0,0),	// DownArrow
	|			new ScanCodeMapping (80,40,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (81,34,0,0),	// PageDown
	|			new ScanCodeMapping (81,34,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (82,45,0,0),	// Insert
	|			new ScanCodeMapping (82,45,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (83,46,0,0),	// Delete
	|			new ScanCodeMapping (83,46,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (86,226,0,60),	// OEM 102
	|			new ScanCodeMapping (86,226,ConsoleModifiers.Shift,62),
	|            new ScanCodeMapping (87,122,0,0),	// F11
	|			new ScanCodeMapping (87,122,ConsoleModifiers.Shift,0),
	|            new ScanCodeMapping (88,123,0,0),	// F12
	|			new ScanCodeMapping (88,123,ConsoleModifiers.Shift,0)
	|        };
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// ContextMenu provides a pop-up menu that can be positioned anywhere within a <see cref=""View""/>. 
	|    /// ContextMenu is analogous to <see cref=""MenuBar""/> and, once activated, works like a sub-menu 
	|    /// of a <see cref=""MenuBarItem""/> (but can be positioned anywhere).
	|    /// <para>
	|    /// By default, a ContextMenu with sub-menus is displayed in a cascading manner, where each sub-menu pops out of the ContextMenu frame
	|    /// (either to the right or left, depending on where the ContextMenu is relative to the edge of the screen). By setting
	|    /// <see cref=""UseSubMenusSingleFrame""/> to <see langword=""true""/>, this behavior can be changed such that all sub-menus are
	|    /// drawn within the ContextMenu frame.
	|    /// </para>
	|    /// <para>
	|    /// ContextMenus can be activated using the Shift-F10 key (by default; use the <see cref=""Key""/> to change to another key).
	|    /// </para>
	|    /// <para>
	|    /// Callers can cause the ContextMenu to be activated on a right-mouse click (or other interaction) by calling <see cref=""Show()""/>.
	|    /// </para>
	|    /// <para>
	|    /// ContextMenus are located using screen using screen coordinates and appear above all other Views.
	|    /// </para>
	|    /// </summary>
	|    public sealed class ContextMenu : IDisposable
	|    {
	|        private static MenuBar menuBar;
	|        private Key key = Key.F10 | Key.ShiftMask;
	|        private MouseFlags mouseFlags = MouseFlags.Button3Clicked;
	|        private Toplevel container;
	|
	|        /// <summary>
	|        /// Initializes a context menu with no menu items.
	|        /// </summary>
	|        public ContextMenu() : this(0, 0, new MenuBarItem()) { }
	|
	|        /// <summary>
	|        /// Initializes a context menu, with a <see cref=""View""/> specifiying the parent/hose of the menu.
	|        /// </summary>
	|        /// <param name=""host"">The host view.</param>
	|        /// <param name=""menuItems"">The menu items for the context menu.</param>
	|        public ContextMenu(View host, MenuBarItem menuItems) :
	|            this(host.Frame.X, host.Frame.Y, menuItems)
	|        {
	|            Host = host;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a context menu with menu items at a specific screen location.
	|        /// </summary>
	|        /// <param name=""x"">The left position (screen relative).</param>
	|        /// <param name=""y"">The top position (screen relative).</param>
	|        /// <param name=""menuItems"">The menu items.</param>
	|        public ContextMenu(int x, int y, MenuBarItem menuItems)
	|        {
	|            if (IsShow)
	|            {
	|                if (menuBar.SuperView != null)
	|                {
	|                    Hide();
	|                }
	|                IsShow = false;
	|            }
	|            MenuItems = menuItems;
	|            Position = new Point(x, y);
	|        }
	|
	|        private void MenuBar_MenuAllClosed()
	|        {
	|            Dispose();
	|        }
	|
	|        /// <summary>
	|        /// Disposes the context menu object.
	|        /// </summary>
	|        public void Dispose()
	|        {
	|            if (IsShow)
	|            {
	|                menuBar.MenuAllClosed -= MenuBar_MenuAllClosed;
	|                menuBar.Dispose();
	|                menuBar = null;
	|                IsShow = false;
	|            }
	|            if (container != null)
	|            {
	|                container.Closing -= Container_Closing;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Shows (opens) the ContextMenu, displaying the <see cref=""MenuItem""/>s it contains.
	|        /// </summary>
	|        public void Show()
	|        {
	|            if (menuBar != null)
	|            {
	|                Hide();
	|            }
	|            container = Application.Current;
	|            container.Closing += Container_Closing;
	|            var frame = container.Frame;
	|            var position = Position;
	|            if (Host != null)
	|            {
	|                Host.ViewToScreen(container.Frame.X, container.Frame.Y, out int x, out int y);
	|                var pos = new Point(x, y);
	|                pos.Y += Host.Frame.Height - 1;
	|                if (position != pos)
	|                {
	|                    Position = position = pos;
	|                }
	|            }
	|            var rect = Menu.MakeFrame(position.X, position.Y, MenuItems.Children);
	|            if (rect.Right >= frame.Right)
	|            {
	|                if (frame.Right - rect.Width >= 0 || !ForceMinimumPosToZero)
	|                {
	|                    position.X = frame.Right - rect.Width;
	|                }
	|                else if (ForceMinimumPosToZero)
	|                {
	|                    position.X = 0;
	|                }
	|            }
	|            else if (ForceMinimumPosToZero && position.X < 0)
	|            {
	|                position.X = 0;
	|            }
	|            if (rect.Bottom >= frame.Bottom)
	|            {
	|                if (frame.Bottom - rect.Height - 1 >= 0 || !ForceMinimumPosToZero)
	|                {
	|                    if (Host == null)
	|                    {
	|                        position.Y = frame.Bottom - rect.Height - 1;
	|                    }
	|                    else
	|                    {
	|                        Host.ViewToScreen(container.Frame.X, container.Frame.Y, out int x, out int y);
	|                        var pos = new Point(x, y);
	|                        position.Y = pos.Y - rect.Height - 1;
	|                    }
	|                }
	|                else if (ForceMinimumPosToZero)
	|                {
	|                    position.Y = 0;
	|                }
	|            }
	|            else if (ForceMinimumPosToZero && position.Y < 0)
	|            {
	|                position.Y = 0;
	|            }
	|
	|            menuBar = new MenuBar(new[] { MenuItems })
	|            {
	|                X = position.X,
	|                Y = position.Y,
	|                Width = 0,
	|                Height = 0,
	|                UseSubMenusSingleFrame = UseSubMenusSingleFrame,
	|                Key = Key
	|            };
	|
	|            menuBar.isContextMenuLoading = true;
	|            menuBar.MenuAllClosed += MenuBar_MenuAllClosed;
	|            IsShow = true;
	|            menuBar.OpenMenu();
	|        }
	|
	|        private void Container_Closing(ToplevelClosingEventArgs obj)
	|        {
	|            Hide();
	|        }
	|
	|        /// <summary>
	|        /// Hides (closes) the ContextMenu.
	|        /// </summary>
	|        public void Hide()
	|        {
	|            menuBar?.CleanUp();
	|            Dispose();
	|        }
	|
	|        /// <summary>
	|        /// Event invoked when the <see cref=""ContextMenu.Key""/> is changed.
	|        /// </summary>
	|        public event Action<Key> KeyChanged;
	|
	|        /// <summary>
	|        /// Event invoked when the <see cref=""ContextMenu.MouseFlags""/> is changed.
	|        /// </summary>
	|        public event Action<MouseFlags> MouseFlagsChanged;
	|
	|        /// <summary>
	|        /// Gets or sets the menu position.
	|        /// </summary>
	|        public Point Position { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the menu items for this context menu.
	|        /// </summary>
	|        public MenuBarItem MenuItems { get; set; }
	|
	|        /// <summary>
	|        /// <see cref=""Gui.Key""/> specifies they keyboard key that will activate the context menu with the keyboard.
	|        /// </summary>
	|        public Key Key
	|        {
	|            get => key;
	|            set
	|            {
	|                var oldKey = key;
	|                key = value;
	|                KeyChanged?.Invoke(oldKey);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// <see cref=""Gui.MouseFlags""/> specifies the mouse action used to activate the context menu by mouse.
	|        /// </summary>
	|        public MouseFlags MouseFlags
	|        {
	|            get => mouseFlags;
	|            set
	|            {
	|                var oldFlags = mouseFlags;
	|                mouseFlags = value;
	|                MouseFlagsChanged?.Invoke(oldFlags);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets whether the ContextMenu is showing or not.
	|        /// </summary>
	|        public static bool IsShow { get; private set; }
	|
	|        /// <summary>
	|        /// The host <see cref=""View ""/> which position will be used,
	|        /// otherwise if it's null the container will be used.
	|        /// </summary>
	|        public View Host { get; set; }
	|
	|        /// <summary>
	|        /// Sets or gets whether the context menu be forced to the right, ensuring it is not clipped, if the x position 
	|        /// is less than zero. The default is <see langword=""true""/> which means the context menu will be forced to the right.
	|        /// If set to <see langword=""false""/>, the context menu will be clipped on the left if x is less than zero.
	|        /// </summary>
	|        public bool ForceMinimumPosToZero { get; set; } = true;
	|
	|        /// <summary>
	|        /// Gets the <see cref=""Gui.MenuBar""/> that is hosting this context menu.
	|        /// </summary>
	|        public MenuBar MenuBar { get => menuBar; }
	|
	|        /// <summary>
	|        /// Gets or sets if sub-menus will be displayed using a ""single frame"" menu style. If <see langword=""true""/>, the ContextMenu
	|        /// and any sub-menus that would normally cascade will be displayed within a single frame. If <see langword=""false""/> (the default),
	|        /// sub-menus will cascade using separate frames for each level of the menu hierarchy.
	|        /// </summary>
	|        public bool UseSubMenusSingleFrame { get; set; }
	|    }
	|    //=======================================================================
	|    //
	|    // Driver.cs: Curses-based Driver
	|    //
	|
	|    /// <summary>
	|    /// This is the Curses driver for the gui.cs/Terminal framework.
	|    /// </summary>
	|    internal class CursesDriver : ConsoleDriver
	|    {
	|        public override int Cols => Curses.Cols;
	|        public override int Rows => Curses.Lines;
	|        public override int Left => 0;
	|        public override int Top => 0;
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool EnableConsoleScrolling { get; set; }
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool HeightAsBuffer { get; set; }
	|        public override IClipboard Clipboard { get => clipboard; }
	|
	|        CursorVisibility? initialCursorVisibility = null;
	|        CursorVisibility? currentCursorVisibility = null;
	|        IClipboard clipboard;
	|        int[,,] contents;
	|
	|        public override int[,,] Contents => contents;
	|
	|        // Current row, and current col, tracked by Move/AddRune only
	|        int ccol, crow;
	|        bool needMove;
	|        public override void Move(int col, int row)
	|        {
	|            ccol = col;
	|            crow = row;
	|
	|            if (Clip.Contains(col, row))
	|            {
	|                Curses.move(row, col);
	|                needMove = false;
	|            }
	|            else
	|            {
	|                Curses.move(Clip.Y, Clip.X);
	|                needMove = true;
	|            }
	|        }
	|
	|        static bool sync = false;
	|        public override void AddRune(Rune rune)
	|        {
	|            rune = MakePrintable(rune);
	|            var runeWidth = Rune.ColumnWidth(rune);
	|            var validClip = IsValidContent(ccol, crow, Clip);
	|
	|            if (validClip)
	|            {
	|                if (needMove)
	|                {
	|                    Curses.move(crow, ccol);
	|                    needMove = false;
	|                }
	|                if (runeWidth == 0 && ccol > 0)
	|                {
	|                    var r = contents[crow, ccol - 1, 0];
	|                    var s = new string(new char[] { (char)r, (char)rune });
	|                    string sn;
	|                    if (!s.IsNormalized())
	|                    {
	|                        sn = s.Normalize();
	|                    }
	|                    else
	|                    {
	|                        sn = s;
	|                    }
	|                    var c = sn[0];
	|                    Curses.mvaddch(crow, ccol - 1, (int)(uint)c);
	|                    contents[crow, ccol - 1, 0] = c;
	|                    contents[crow, ccol - 1, 1] = CurrentAttribute;
	|                    contents[crow, ccol - 1, 2] = 1;
	|
	|                }
	|                else
	|                {
	|                    if (runeWidth < 2 && ccol > 0
	|                        && Rune.ColumnWidth((char)contents[crow, ccol - 1, 0]) > 1)
	|                    {
	|
	|                        var curAtttib = CurrentAttribute;
	|                        Curses.attrset(contents[crow, ccol - 1, 1]);
	|                        Curses.mvaddch(crow, ccol - 1, (int)(uint)' ');
	|                        contents[crow, ccol - 1, 0] = (int)(uint)' ';
	|                        Curses.move(crow, ccol);
	|                        Curses.attrset(curAtttib);
	|
	|                    }
	|                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
	|                      && Rune.ColumnWidth((char)contents[crow, ccol, 0]) > 1)
	|                    {
	|
	|                        var curAtttib = CurrentAttribute;
	|                        Curses.attrset(contents[crow, ccol + 1, 1]);
	|                        Curses.mvaddch(crow, ccol + 1, (int)(uint)' ');
	|                        contents[crow, ccol + 1, 0] = (int)(uint)' ';
	|                        Curses.move(crow, ccol);
	|                        Curses.attrset(curAtttib);
	|
	|                    }
	|                    if (runeWidth > 1 && ccol == Clip.Right - 1)
	|                    {
	|                        Curses.addch((int)(uint)' ');
	|                        contents[crow, ccol, 0] = (int)(uint)' ';
	|                    }
	|                    else
	|                    {
	|                        Curses.addch((int)(uint)rune);
	|                        contents[crow, ccol, 0] = (int)(uint)rune;
	|                    }
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 1;
	|                }
	|            }
	|            else
	|            {
	|                needMove = true;
	|            }
	|
	|            if (runeWidth < 0 || runeWidth > 0)
	|            {
	|                ccol++;
	|            }
	|
	|            if (runeWidth > 1)
	|            {
	|                if (validClip && ccol < Clip.Right)
	|                {
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 0;
	|                }
	|                ccol++;
	|            }
	|
	|            if (sync)
	|            {
	|                UpdateScreen();
	|            }
	|        }
	|
	|        public override void AddStr(ustring str)
	|        {
	|            // TODO; optimize this to determine if the str fits in the clip region, and if so, use Curses.addstr directly
	|            foreach (var rune in str)
	|                AddRune(rune);
	|        }
	|
	|        public override void Refresh()
	|        {
	|            Curses.raw();
	|            Curses.noecho();
	|            Curses.refresh();
	|            ProcessWinChange();
	|        }
	|
	|        private void ProcessWinChange()
	|        {
	|            if (Curses.CheckWinChange())
	|            {
	|                ResizeScreen();
	|                UpdateOffScreen();
	|                TerminalResized?.Invoke();
	|            }
	|        }
	|
	|        public override void UpdateCursor() => Refresh();
	|
	|        public override void End()
	|        {
	|            StopReportingMouseMoves();
	|            SetCursorVisibility(CursorVisibility.Default);
	|
	|            // throws away any typeahead that has been typed by
	|            // the user and has not yet been read by the program.
	|            Curses.flushinp();
	|
	|            Curses.endwin();
	|        }
	|
	|        public override void UpdateScreen() => window.redrawwin();
	|
	|        public override void SetAttribute(Attribute c)
	|        {
	|            base.SetAttribute(c);
	|            Curses.attrset(CurrentAttribute);
	|        }
	|
	|        public Curses.Window window;
	|
	|        //static short last_color_pair = 16;
	|
	|        /// <summary>
	|        /// Creates a curses color from the provided foreground and background colors
	|        /// </summary>
	|        /// <param name=""foreground"">Contains the curses attributes for the foreground (color, plus any attributes)</param>
	|        /// <param name=""background"">Contains the curses attributes for the background (color, plus any attributes)</param>
	|        /// <returns></returns>
	|        public static Attribute MakeColor(short foreground, short background)
	|        {
	|            var v = (short)((int)foreground | background << 4);
	|            //Curses.InitColorPair (++last_color_pair, foreground, background);
	|            Curses.InitColorPair(v, foreground, background);
	|            return new Attribute(
	|                //value: Curses.ColorPair (last_color_pair),
	|                value: Curses.ColorPair(v),
	|                //foreground: (Color)foreground,
	|                foreground: MapCursesColor(foreground),
	|                //background: (Color)background);
	|                background: MapCursesColor(background));
	|        }
	|
	|        public override Attribute MakeColor(Color fore, Color back)
	|        {
	|            return MakeColor((short)MapColor(fore), (short)MapColor(back));
	|        }
	|
	|        int[,] colorPairs = new int[16, 16];
	|
	|        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
	|        {
	|            // BUGBUG: This code is never called ?? See Issue #2300
	|            int f = (short)foreground;
	|            int b = (short)background;
	|            var v = colorPairs[f, b];
	|            if ((v & 0x10000) == 0)
	|            {
	|                b &= 0x7;
	|                bool bold = (f & 0x8) != 0;
	|                f &= 0x7;
	|
	|                v = MakeColor((short)f, (short)b) | (bold ? Curses.A_BOLD : 0);
	|                colorPairs[(int)foreground, (int)background] = v | 0x1000;
	|            }
	|            SetAttribute(v & 0xffff);
	|        }
	|
	|        Dictionary<int, int> rawPairs = new Dictionary<int, int>();
	|        public override void SetColors(short foreColorId, short backgroundColorId)
	|        {
	|            // BUGBUG: This code is never called ?? See Issue #2300
	|            int key = ((ushort)foreColorId << 16) | (ushort)backgroundColorId;
	|            if (!rawPairs.TryGetValue(key, out var v))
	|            {
	|                v = MakeColor(foreColorId, backgroundColorId);
	|                rawPairs[key] = v;
	|            }
	|            SetAttribute(v);
	|        }
	|
	|        static Key MapCursesKey(int cursesKey)
	|        {
	|            switch (cursesKey)
	|            {
	|                case Curses.KeyF1: return Key.F1;
	|                case Curses.KeyF2: return Key.F2;
	|                case Curses.KeyF3: return Key.F3;
	|                case Curses.KeyF4: return Key.F4;
	|                case Curses.KeyF5: return Key.F5;
	|                case Curses.KeyF6: return Key.F6;
	|                case Curses.KeyF7: return Key.F7;
	|                case Curses.KeyF8: return Key.F8;
	|                case Curses.KeyF9: return Key.F9;
	|                case Curses.KeyF10: return Key.F10;
	|                case Curses.KeyF11: return Key.F11;
	|                case Curses.KeyF12: return Key.F12;
	|                case Curses.KeyUp: return Key.CursorUp;
	|                case Curses.KeyDown: return Key.CursorDown;
	|                case Curses.KeyLeft: return Key.CursorLeft;
	|                case Curses.KeyRight: return Key.CursorRight;
	|                case Curses.KeyHome: return Key.Home;
	|                case Curses.KeyEnd: return Key.End;
	|                case Curses.KeyNPage: return Key.PageDown;
	|                case Curses.KeyPPage: return Key.PageUp;
	|                case Curses.KeyDeleteChar: return Key.DeleteChar;
	|                case Curses.KeyInsertChar: return Key.InsertChar;
	|                case Curses.KeyTab: return Key.Tab;
	|                case Curses.KeyBackTab: return Key.BackTab;
	|                case Curses.KeyBackspace: return Key.Backspace;
	|                case Curses.ShiftKeyUp: return Key.CursorUp | Key.ShiftMask;
	|                case Curses.ShiftKeyDown: return Key.CursorDown | Key.ShiftMask;
	|                case Curses.ShiftKeyLeft: return Key.CursorLeft | Key.ShiftMask;
	|                case Curses.ShiftKeyRight: return Key.CursorRight | Key.ShiftMask;
	|                case Curses.ShiftKeyHome: return Key.Home | Key.ShiftMask;
	|                case Curses.ShiftKeyEnd: return Key.End | Key.ShiftMask;
	|                case Curses.ShiftKeyNPage: return Key.PageDown | Key.ShiftMask;
	|                case Curses.ShiftKeyPPage: return Key.PageUp | Key.ShiftMask;
	|                case Curses.AltKeyUp: return Key.CursorUp | Key.AltMask;
	|                case Curses.AltKeyDown: return Key.CursorDown | Key.AltMask;
	|                case Curses.AltKeyLeft: return Key.CursorLeft | Key.AltMask;
	|                case Curses.AltKeyRight: return Key.CursorRight | Key.AltMask;
	|                case Curses.AltKeyHome: return Key.Home | Key.AltMask;
	|                case Curses.AltKeyEnd: return Key.End | Key.AltMask;
	|                case Curses.AltKeyNPage: return Key.PageDown | Key.AltMask;
	|                case Curses.AltKeyPPage: return Key.PageUp | Key.AltMask;
	|                case Curses.CtrlKeyUp: return Key.CursorUp | Key.CtrlMask;
	|                case Curses.CtrlKeyDown: return Key.CursorDown | Key.CtrlMask;
	|                case Curses.CtrlKeyLeft: return Key.CursorLeft | Key.CtrlMask;
	|                case Curses.CtrlKeyRight: return Key.CursorRight | Key.CtrlMask;
	|                case Curses.CtrlKeyHome: return Key.Home | Key.CtrlMask;
	|                case Curses.CtrlKeyEnd: return Key.End | Key.CtrlMask;
	|                case Curses.CtrlKeyNPage: return Key.PageDown | Key.CtrlMask;
	|                case Curses.CtrlKeyPPage: return Key.PageUp | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyUp: return Key.CursorUp | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyDown: return Key.CursorDown | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyLeft: return Key.CursorLeft | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyRight: return Key.CursorRight | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyHome: return Key.Home | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyEnd: return Key.End | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyNPage: return Key.PageDown | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftCtrlKeyPPage: return Key.PageUp | Key.ShiftMask | Key.CtrlMask;
	|                case Curses.ShiftAltKeyUp: return Key.CursorUp | Key.ShiftMask | Key.AltMask;
	|                case Curses.ShiftAltKeyDown: return Key.CursorDown | Key.ShiftMask | Key.AltMask;
	|                case Curses.ShiftAltKeyLeft: return Key.CursorLeft | Key.ShiftMask | Key.AltMask;
	|                case Curses.ShiftAltKeyRight: return Key.CursorRight | Key.ShiftMask | Key.AltMask;
	|                case Curses.ShiftAltKeyNPage: return Key.PageDown | Key.ShiftMask | Key.AltMask;
	|                case Curses.ShiftAltKeyPPage: return Key.PageUp | Key.ShiftMask | Key.AltMask;
	|                case Curses.ShiftAltKeyHome: return Key.Home | Key.ShiftMask | Key.AltMask;
	|                case Curses.ShiftAltKeyEnd: return Key.End | Key.ShiftMask | Key.AltMask;
	|                case Curses.AltCtrlKeyNPage: return Key.PageDown | Key.AltMask | Key.CtrlMask;
	|                case Curses.AltCtrlKeyPPage: return Key.PageUp | Key.AltMask | Key.CtrlMask;
	|                case Curses.AltCtrlKeyHome: return Key.Home | Key.AltMask | Key.CtrlMask;
	|                case Curses.AltCtrlKeyEnd: return Key.End | Key.AltMask | Key.CtrlMask;
	|                default: return Key.Unknown;
	|            }
	|        }
	|
	|        KeyModifiers keyModifiers;
	|
	|        KeyModifiers MapKeyModifiers(Key key)
	|        {
	|            if (keyModifiers == null)
	|                keyModifiers = new KeyModifiers();
	|
	|            if (!keyModifiers.Shift && (key & Key.ShiftMask) != 0)
	|                keyModifiers.Shift = true;
	|            if (!keyModifiers.Alt && (key & Key.AltMask) != 0)
	|                keyModifiers.Alt = true;
	|            if (!keyModifiers.Ctrl && (key & Key.CtrlMask) != 0)
	|                keyModifiers.Ctrl = true;
	|
	|            return keyModifiers;
	|        }
	|
	|        void ProcessInput()
	|        {
	|            int wch;
	|            var code = Curses.get_wch(out wch);
	|            //System.Diagnostics.Debug.WriteLine ($""code: {code}; wch: {wch}"");
	|            if (code == Curses.ERR)
	|                return;
	|
	|            keyModifiers = new KeyModifiers();
	|            Key k = Key.Null;
	|
	|            if (code == Curses.KEY_CODE_YES)
	|            {
	|                var lastWch = wch;
	|                while (code == Curses.KEY_CODE_YES && wch == Curses.KeyResize)
	|                {
	|                    ProcessWinChange();
	|                    code = Curses.get_wch(out wch);
	|                }
	|                if (wch == 0)
	|                {
	|                    return;
	|                }
	|                if (wch == Curses.KeyMouse)
	|                {
	|                    int wch2 = wch;
	|
	|                    while (wch2 == Curses.KeyMouse)
	|                    {
	|                        KeyEvent key = null;
	|                        ConsoleKeyInfo[] cki = new ConsoleKeyInfo[] {
	|                            new ConsoleKeyInfo ((char)Key.Esc, 0, false, false, false),
	|                            new ConsoleKeyInfo ('[', 0, false, false, false),
	|                            new ConsoleKeyInfo ('<', 0, false, false, false)
	|                        };
	|                        code = 0;
	|                        GetEscSeq(ref code, ref k, ref wch2, ref key, ref cki);
	|                    }
	|                    return;
	|                }
	|                k = MapCursesKey(wch);
	|                if (wch >= 277 && wch <= 288)
	|                { // Shift+(F1 - F12)
	|                    wch -= 12;
	|                    k = Key.ShiftMask | MapCursesKey(wch);
	|                }
	|                else if (wch >= 289 && wch <= 300)
	|                { // Ctrl+(F1 - F12)
	|                    wch -= 24;
	|                    k = Key.CtrlMask | MapCursesKey(wch);
	|                }
	|                else if (wch >= 301 && wch <= 312)
	|                { // Ctrl+Shift+(F1 - F12)
	|                    wch -= 36;
	|                    k = Key.CtrlMask | Key.ShiftMask | MapCursesKey(wch);
	|                }
	|                else if (wch >= 313 && wch <= 324)
	|                { // Alt+(F1 - F12)
	|                    wch -= 48;
	|                    k = Key.AltMask | MapCursesKey(wch);
	|                }
	|                else if (wch >= 325 && wch <= 327)
	|                { // Shift+Alt+(F1 - F3)
	|                    wch -= 60;
	|                    k = Key.ShiftMask | Key.AltMask | MapCursesKey(wch);
	|                }
	|                else
	|                {
	|                    code = Curses.get_wch(out wch);
	|                    if (code == 0)
	|                    {
	|                        switch (wch)
	|                        {
	|                            // Shift code.
	|                            case 16:
	|                                keyModifiers.Shift = true;
	|                                break;
	|                            default:
	|                                if (lastWch == Curses.KeyResize && wch == 91)
	|                                {
	|                                    // Returns this keys to the std input which is a CSI (\x1b[).
	|                                    Curses.ungetch(91); // [
	|                                    Curses.ungetch(27); // Esc
	|                                    return;
	|                                }
	|                                else
	|                                {
	|                                    throw new Exception();
	|                                }
	|                        }
	|                    }
	|                }
	|                keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                keyUpHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                return;
	|            }
	|
	|            // Special handling for ESC, we want to try to catch ESC+letter to simulate alt-letter as well as Alt-Fkey
	|            if (wch == 27)
	|            {
	|                code = Curses.get_wch(out int wch2);
	|
	|                if (code == Curses.KEY_CODE_YES)
	|                {
	|                    k = Key.AltMask | MapCursesKey(wch);
	|                }
	|                if (code == 0)
	|                {
	|                    KeyEvent key = null;
	|
	|                    // The ESC-number handling, debatable.
	|                    // Simulates the AltMask itself by pressing Alt + Space.
	|                    if (wch2 == (int)Key.Space)
	|                    {
	|                        k = Key.AltMask;
	|                    }
	|                    else if (wch2 - (int)Key.Space >= (uint)Key.A && wch2 - (int)Key.Space <= (uint)Key.Z)
	|                    {
	|                        k = (Key)((uint)Key.AltMask + (wch2 - (int)Key.Space));
	|                    }
	|                    else if (wch2 >= (uint)Key.A - 64 && wch2 <= (uint)Key.Z - 64)
	|                    {
	|                        k = (Key)((uint)(Key.AltMask | Key.CtrlMask) + (wch2 + 64));
	|                    }
	|                    else if (wch2 >= (uint)Key.D0 && wch2 <= (uint)Key.D9)
	|                    {
	|                        k = (Key)((uint)Key.AltMask + (uint)Key.D0 + (wch2 - (uint)Key.D0));
	|                    }
	|                    else if (wch2 == Curses.KeyCSI)
	|                    {
	|                        ConsoleKeyInfo[] cki = new ConsoleKeyInfo[] {
	|                            new ConsoleKeyInfo ((char)Key.Esc, 0, false, false, false),
	|                            new ConsoleKeyInfo ('[', 0, false, false, false)
	|                        };
	|                        GetEscSeq(ref code, ref k, ref wch2, ref key, ref cki);
	|                        return;
	|                    }
	|                    else
	|                    {
	|                        // Unfortunately there are no way to differentiate Ctrl+Alt+alfa and Ctrl+Shift+Alt+alfa.
	|                        if (((Key)wch2 & Key.CtrlMask) != 0)
	|                        {
	|                            keyModifiers.Ctrl = true;
	|                        }
	|                        if (wch2 == 0)
	|                        {
	|                            k = Key.CtrlMask | Key.AltMask | Key.Space;
	|                        }
	|                        else if (wch >= (uint)Key.A && wch <= (uint)Key.Z)
	|                        {
	|                            keyModifiers.Shift = true;
	|                            keyModifiers.Alt = true;
	|                        }
	|                        else if (wch2 == Curses.KeySS3)
	|                        {
	|                            while (code > -1)
	|                            {
	|                                code = Curses.get_wch(out wch2);
	|                                if (code == 0)
	|                                {
	|                                    switch (wch2)
	|                                    {
	|                                        case 16:
	|                                            keyModifiers.Shift = true;
	|                                            break;
	|                                        case 108:
	|                                            k = (Key)'+';
	|                                            break;
	|                                        case 109:
	|                                            k = (Key)'-';
	|                                            break;
	|                                        case 112:
	|                                            k = Key.InsertChar;
	|                                            break;
	|                                        case 113:
	|                                            k = Key.End;
	|                                            break;
	|                                        case 114:
	|                                            k = Key.CursorDown;
	|                                            break;
	|                                        case 115:
	|                                            k = Key.PageDown;
	|                                            break;
	|                                        case 116:
	|                                            k = Key.CursorLeft;
	|                                            break;
	|                                        case 117:
	|                                            k = Key.Clear;
	|                                            break;
	|                                        case 118:
	|                                            k = Key.CursorRight;
	|                                            break;
	|                                        case 119:
	|                                            k = Key.Home;
	|                                            break;
	|                                        case 120:
	|                                            k = Key.CursorUp;
	|                                            break;
	|                                        case 121:
	|                                            k = Key.PageUp;
	|                                            break;
	|                                        default:
	|                                            k = (Key)wch2;
	|                                            break;
	|                                    }
	|                                }
	|                            }
	|                        }
	|                        else if (wch2 < 256)
	|                        {
	|                            k = (Key)wch2;
	|                            keyModifiers.Alt = true;
	|                        }
	|                        else
	|                        {
	|                            k = (Key)((uint)(Key.AltMask | Key.CtrlMask) + wch2);
	|                        }
	|                    }
	|                    key = new KeyEvent(k, MapKeyModifiers(k));
	|                    keyDownHandler(key);
	|                    keyHandler(key);
	|                }
	|                else
	|                {
	|                    k = Key.Esc;
	|                    keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                    keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                }
	|            }
	|            else if (wch == Curses.KeyTab)
	|            {
	|                k = MapCursesKey(wch);
	|                keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|            }
	|            else
	|            {
	|                // Unfortunately there are no way to differentiate Ctrl+alfa and Ctrl+Shift+alfa.
	|                k = (Key)wch;
	|                if (wch == 0)
	|                {
	|                    k = Key.CtrlMask | Key.Space;
	|                }
	|                else if (wch >= (uint)Key.A - 64 && wch <= (uint)Key.Z - 64)
	|                {
	|                    if ((Key)(wch + 64) != Key.J)
	|                    {
	|                        k = Key.CtrlMask | (Key)(wch + 64);
	|                    }
	|                }
	|                else if (wch >= (uint)Key.A && wch <= (uint)Key.Z)
	|                {
	|                    keyModifiers.Shift = true;
	|                }
	|                keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|                keyUpHandler(new KeyEvent(k, MapKeyModifiers(k)));
	|            }
	|            // Cause OnKeyUp and OnKeyPressed. Note that the special handling for ESC above 
	|            // will not impact KeyUp.
	|            // This is causing ESC firing even if another keystroke was handled.
	|            //if (wch == Curses.KeyTab) {
	|            //	keyUpHandler (new KeyEvent (MapCursesKey (wch), keyModifiers));
	|            //} else {
	|            //	keyUpHandler (new KeyEvent ((Key)wch, keyModifiers));
	|            //}
	|        }
	|
	|        void GetEscSeq(ref int code, ref Key k, ref int wch2, ref KeyEvent key, ref ConsoleKeyInfo[] cki)
	|        {
	|            ConsoleKey ck = 0;
	|            ConsoleModifiers mod = 0;
	|            while (code == 0)
	|            {
	|                code = Curses.get_wch(out wch2);
	|                var consoleKeyInfo = new ConsoleKeyInfo((char)wch2, 0, false, false, false);
	|                if (wch2 == 0 || wch2 == 27 || wch2 == Curses.KeyMouse)
	|                {
	|                    EscSeqUtils.DecodeEscSeq(null, ref consoleKeyInfo, ref ck, cki, ref mod, out _, out _, out _, out _, out bool isKeyMouse, out List<MouseFlags> mouseFlags, out Point pos, out _, ProcessContinuousButtonPressed);
	|                    if (isKeyMouse)
	|                    {
	|                        foreach (var mf in mouseFlags)
	|                        {
	|                            ProcessMouseEvent(mf, pos);
	|                        }
	|                        cki = null;
	|                        if (wch2 == 27)
	|                        {
	|                            cki = EscSeqUtils.ResizeArray(new ConsoleKeyInfo((char)Key.Esc, 0,
	|                                false, false, false), cki);
	|                        }
	|                    }
	|                    else
	|                    {
	|                        k = ConsoleKeyMapping.MapConsoleKeyToKey(consoleKeyInfo.Key, out _);
	|                        k = ConsoleKeyMapping.MapKeyModifiers(consoleKeyInfo, k);
	|                        key = new KeyEvent(k, MapKeyModifiers(k));
	|                        keyDownHandler(key);
	|                        keyHandler(key);
	|                    }
	|                }
	|                else
	|                {
	|                    cki = EscSeqUtils.ResizeArray(consoleKeyInfo, cki);
	|                }
	|            }
	|        }
	|
	|        MouseFlags lastMouseFlags;
	|
	|        void ProcessMouseEvent(MouseFlags mouseFlag, Point pos)
	|        {
	|            bool WasButtonReleased(MouseFlags flag)
	|            {
	|                return flag.HasFlag(MouseFlags.Button1Released) ||
	|                    flag.HasFlag(MouseFlags.Button2Released) ||
	|                    flag.HasFlag(MouseFlags.Button3Released) ||
	|                    flag.HasFlag(MouseFlags.Button4Released);
	|            }
	|
	|            bool IsButtonNotPressed(MouseFlags flag)
	|            {
	|                return !flag.HasFlag(MouseFlags.Button1Pressed) &&
	|                    !flag.HasFlag(MouseFlags.Button2Pressed) &&
	|                    !flag.HasFlag(MouseFlags.Button3Pressed) &&
	|                    !flag.HasFlag(MouseFlags.Button4Pressed);
	|            }
	|
	|            bool IsButtonClickedOrDoubleClicked(MouseFlags flag)
	|            {
	|                return flag.HasFlag(MouseFlags.Button1Clicked) ||
	|                    flag.HasFlag(MouseFlags.Button2Clicked) ||
	|                    flag.HasFlag(MouseFlags.Button3Clicked) ||
	|                    flag.HasFlag(MouseFlags.Button4Clicked) ||
	|                    flag.HasFlag(MouseFlags.Button1DoubleClicked) ||
	|                    flag.HasFlag(MouseFlags.Button2DoubleClicked) ||
	|                    flag.HasFlag(MouseFlags.Button3DoubleClicked) ||
	|                    flag.HasFlag(MouseFlags.Button4DoubleClicked);
	|            }
	|
	|            if ((WasButtonReleased(mouseFlag) && IsButtonNotPressed(lastMouseFlags)) ||
	|                (IsButtonClickedOrDoubleClicked(mouseFlag) && lastMouseFlags == 0))
	|            {
	|                return;
	|            }
	|
	|            lastMouseFlags = mouseFlag;
	|            var me = new MouseEvent()
	|            {
	|                Flags = mouseFlag,
	|                X = pos.X,
	|                Y = pos.Y
	|            };
	|            mouseHandler(me);
	|        }
	|
	|        void ProcessContinuousButtonPressed(MouseFlags mouseFlag, Point pos)
	|        {
	|            ProcessMouseEvent(mouseFlag, pos);
	|        }
	|
	|        Action<KeyEvent> keyHandler;
	|        Action<KeyEvent> keyDownHandler;
	|        Action<KeyEvent> keyUpHandler;
	|        Action<MouseEvent> mouseHandler;
	|
	|        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
	|        {
	|            // Note: Curses doesn't support keydown/up events and thus any passed keyDown/UpHandlers will never be called
	|            this.keyHandler = keyHandler;
	|            this.keyDownHandler = keyDownHandler;
	|            this.keyUpHandler = keyUpHandler;
	|            this.mouseHandler = mouseHandler;
	|
	|            var mLoop = mainLoop.Driver as UnixMainLoop;
	|
	|            mLoop.AddWatch(0, UnixMainLoop.Condition.PollIn, x =>
	|            {
	|                ProcessInput();
	|                return true;
	|            });
	|
	|            mLoop.WinChanged += () => ProcessWinChange();
	|        }
	|
	|        public override void Init(Action terminalResized)
	|        {
	|            if (window != null)
	|                return;
	|
	|            try
	|            {
	|                window = Curses.initscr();
	|                Curses.set_escdelay(10);
	|                Curses.nodelay(window.Handle, true);
	|            }
	|            catch (Exception e)
	|            {
	|                throw new Exception($""Curses failed to initialize, the exception is: {e.Message}"");
	|            }
	|
	|            // Ensures that all procedures are performed at some previous closing.
	|            Curses.doupdate();
	|
	|            // 
	|            // We are setting Invisible as default so we could ignore XTerm DECSUSR setting
	|            //
	|            switch (Curses.curs_set(0))
	|            {
	|                case 0:
	|                    currentCursorVisibility = initialCursorVisibility = CursorVisibility.Invisible;
	|                    break;
	|
	|                case 1:
	|                    currentCursorVisibility = initialCursorVisibility = CursorVisibility.Underline;
	|                    Curses.curs_set(1);
	|                    break;
	|
	|                case 2:
	|                    currentCursorVisibility = initialCursorVisibility = CursorVisibility.Box;
	|                    Curses.curs_set(2);
	|                    break;
	|
	|                default:
	|                    currentCursorVisibility = initialCursorVisibility = null;
	|                    break;
	|            }
	|
	|            if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
	|            {
	|                clipboard = new MacOSXClipboard();
	|            }
	|            else
	|            {
	|                if (Is_WSL_Platform())
	|                {
	|                    clipboard = new WSLClipboard();
	|                }
	|                else
	|                {
	|                    clipboard = new CursesClipboard();
	|                }
	|            }
	|
	|            Curses.raw();
	|            Curses.noecho();
	|
	|            Curses.Window.Standard.keypad(true);
	|            TerminalResized = terminalResized;
	|            StartReportingMouseMoves();
	|
	|            CurrentAttribute = MakeColor(Color.White, Color.Black);
	|
	|            if (Curses.HasColors)
	|            {
	|                Curses.StartColor();
	|                Curses.UseDefaultColors();
	|
	|                InitalizeColorSchemes();
	|            }
	|            else
	|            {
	|                InitalizeColorSchemes(false);
	|
	|                // BUGBUG: This is a hack to make the colors work on the Mac?
	|                // The new Theme support overwrites these colors, so this is not needed?
	|                Colors.TopLevel.Normal = Curses.COLOR_GREEN;
	|                Colors.TopLevel.Focus = Curses.COLOR_WHITE;
	|                Colors.TopLevel.HotNormal = Curses.COLOR_YELLOW;
	|                Colors.TopLevel.HotFocus = Curses.COLOR_YELLOW;
	|                Colors.TopLevel.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
	|                Colors.Base.Normal = Curses.A_NORMAL;
	|                Colors.Base.Focus = Curses.A_REVERSE;
	|                Colors.Base.HotNormal = Curses.A_BOLD;
	|                Colors.Base.HotFocus = Curses.A_BOLD | Curses.A_REVERSE;
	|                Colors.Base.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
	|                Colors.Menu.Normal = Curses.A_REVERSE;
	|                Colors.Menu.Focus = Curses.A_NORMAL;
	|                Colors.Menu.HotNormal = Curses.A_BOLD;
	|                Colors.Menu.HotFocus = Curses.A_NORMAL;
	|                Colors.Menu.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
	|                Colors.Dialog.Normal = Curses.A_REVERSE;
	|                Colors.Dialog.Focus = Curses.A_NORMAL;
	|                Colors.Dialog.HotNormal = Curses.A_BOLD;
	|                Colors.Dialog.HotFocus = Curses.A_NORMAL;
	|                Colors.Dialog.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
	|                Colors.Error.Normal = Curses.A_BOLD;
	|                Colors.Error.Focus = Curses.A_BOLD | Curses.A_REVERSE;
	|                Colors.Error.HotNormal = Curses.A_BOLD | Curses.A_REVERSE;
	|                Colors.Error.HotFocus = Curses.A_REVERSE;
	|                Colors.Error.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
	|            }
	|
	|            ResizeScreen();
	|            UpdateOffScreen();
	|        }
	|
	|        public override void ResizeScreen()
	|        {
	|            Clip = new Rect(0, 0, Cols, Rows);
	|        }
	|
	|        public override void UpdateOffScreen()
	|        {
	|            contents = new int[Rows, Cols, 3];
	|            for (int row = 0; row < Rows; row++)
	|            {
	|                for (int col = 0; col < Cols; col++)
	|                {
	|                    Curses.move(row, col);
	|                    Curses.attrset(Colors.TopLevel.Normal);
	|                    Curses.addch((int)(uint)' ');
	|                    contents[row, col, 0] = ' ';
	|                    contents[row, col, 1] = Colors.TopLevel.Normal;
	|                    contents[row, col, 2] = 0;
	|                }
	|            }
	|        }
	|
	|        public static bool Is_WSL_Platform()
	|        {
	|            // xclip does not work on WSL, so we need to use the Windows clipboard vis Powershell
	|            //if (new CursesClipboard ().IsSupported) {
	|            //	// If xclip is installed on Linux under WSL, this will return true.
	|            //	return false;
	|            //}
	|            var (exitCode, result) = ClipboardProcessRunner.Bash(""uname -a"", waitForOutput: true);
	|            if (exitCode == 0 && result.Contains(""microsoft"") && result.Contains(""WSL""))
	|            {
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        static int MapColor(Color color)
	|        {
	|            switch (color)
	|            {
	|                case Color.Black:
	|                    return Curses.COLOR_BLACK;
	|                case Color.Blue:
	|                    return Curses.COLOR_BLUE;
	|                case Color.Green:
	|                    return Curses.COLOR_GREEN;
	|                case Color.Cyan:
	|                    return Curses.COLOR_CYAN;
	|                case Color.Red:
	|                    return Curses.COLOR_RED;
	|                case Color.Magenta:
	|                    return Curses.COLOR_MAGENTA;
	|                case Color.Brown:
	|                    return Curses.COLOR_YELLOW;
	|                case Color.Gray:
	|                    return Curses.COLOR_WHITE;
	|                case Color.DarkGray:
	|                    //return Curses.COLOR_BLACK | Curses.A_BOLD;
	|                    return Curses.COLOR_GRAY;
	|                case Color.BrightBlue:
	|                    return Curses.COLOR_BLUE | Curses.A_BOLD | Curses.COLOR_GRAY;
	|                case Color.BrightGreen:
	|                    return Curses.COLOR_GREEN | Curses.A_BOLD | Curses.COLOR_GRAY;
	|                case Color.BrightCyan:
	|                    return Curses.COLOR_CYAN | Curses.A_BOLD | Curses.COLOR_GRAY;
	|                case Color.BrightRed:
	|                    return Curses.COLOR_RED | Curses.A_BOLD | Curses.COLOR_GRAY;
	|                case Color.BrightMagenta:
	|                    return Curses.COLOR_MAGENTA | Curses.A_BOLD | Curses.COLOR_GRAY;
	|                case Color.BrightYellow:
	|                    return Curses.COLOR_YELLOW | Curses.A_BOLD | Curses.COLOR_GRAY;
	|                case Color.White:
	|                    return Curses.COLOR_WHITE | Curses.A_BOLD | Curses.COLOR_GRAY;
	|            }
	|            throw new ArgumentException(""Invalid color code"");
	|        }
	|
	|        static Color MapCursesColor(int color)
	|        {
	|            switch (color)
	|            {
	|                case Curses.COLOR_BLACK:
	|                    return Color.Black;
	|                case Curses.COLOR_BLUE:
	|                    return Color.Blue;
	|                case Curses.COLOR_GREEN:
	|                    return Color.Green;
	|                case Curses.COLOR_CYAN:
	|                    return Color.Cyan;
	|                case Curses.COLOR_RED:
	|                    return Color.Red;
	|                case Curses.COLOR_MAGENTA:
	|                    return Color.Magenta;
	|                case Curses.COLOR_YELLOW:
	|                    return Color.Brown;
	|                case Curses.COLOR_WHITE:
	|                    return Color.Gray;
	|                case Curses.COLOR_GRAY:
	|                    return Color.DarkGray;
	|                case Curses.COLOR_BLUE | Curses.COLOR_GRAY:
	|                    return Color.BrightBlue;
	|                case Curses.COLOR_GREEN | Curses.COLOR_GRAY:
	|                    return Color.BrightGreen;
	|                case Curses.COLOR_CYAN | Curses.COLOR_GRAY:
	|                    return Color.BrightCyan;
	|                case Curses.COLOR_RED | Curses.COLOR_GRAY:
	|                    return Color.BrightRed;
	|                case Curses.COLOR_MAGENTA | Curses.COLOR_GRAY:
	|                    return Color.BrightMagenta;
	|                case Curses.COLOR_YELLOW | Curses.COLOR_GRAY:
	|                    return Color.BrightYellow;
	|                case Curses.COLOR_WHITE | Curses.COLOR_GRAY:
	|                    return Color.White;
	|            }
	|            throw new ArgumentException(""Invalid curses color code"");
	|        }
	|
	|        public override Attribute MakeAttribute(Color fore, Color back)
	|        {
	|            var f = MapColor(fore);
	|            //return MakeColor ((short)(f & 0xffff), (short)MapColor (back)) | ((f & Curses.A_BOLD) != 0 ? Curses.A_BOLD : 0);
	|            return MakeColor((short)(f & 0xffff), (short)MapColor(back));
	|        }
	|
	|        public override void Suspend()
	|        {
	|            StopReportingMouseMoves();
	|            Platform.Suspend();
	|            Curses.Window.Standard.redrawwin();
	|            Curses.refresh();
	|            StartReportingMouseMoves();
	|        }
	|
	|        public override void StartReportingMouseMoves()
	|        {
	|            Console.Out.Write(EscSeqUtils.EnableMouseEvents);
	|        }
	|
	|        public override void StopReportingMouseMoves()
	|        {
	|            Console.Out.Write(EscSeqUtils.DisableMouseEvents);
	|        }
	|
	|        //int lastMouseInterval;
	|        //bool mouseGrabbed;
	|
	|        public override void UncookMouse()
	|        {
	|            //if (mouseGrabbed)
	|            //	return;
	|            //lastMouseInterval = Curses.mouseinterval (0);
	|            //mouseGrabbed = true;
	|        }
	|
	|        public override void CookMouse()
	|        {
	|            //mouseGrabbed = false;
	|            //Curses.mouseinterval (lastMouseInterval);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool GetCursorVisibility(out CursorVisibility visibility)
	|        {
	|            visibility = CursorVisibility.Invisible;
	|
	|            if (!currentCursorVisibility.HasValue)
	|                return false;
	|
	|            visibility = currentCursorVisibility.Value;
	|
	|            return true;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool SetCursorVisibility(CursorVisibility visibility)
	|        {
	|            if (initialCursorVisibility.HasValue == false)
	|                return false;
	|
	|            Curses.curs_set(((int)visibility >> 16) & 0x000000FF);
	|
	|            if (visibility != CursorVisibility.Invisible)
	|            {
	|                Console.Out.Write(""\x1b[{0} q"", ((int)visibility >> 24) & 0xFF);
	|            }
	|
	|            currentCursorVisibility = visibility;
	|
	|            return true;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool EnsureCursorVisibility()
	|        {
	|            return false;
	|        }
	|
	|        public override void SendKeys(char keyChar, ConsoleKey consoleKey, bool shift, bool alt, bool control)
	|        {
	|            Key key;
	|
	|            if (consoleKey == ConsoleKey.Packet)
	|            {
	|                ConsoleModifiers mod = new ConsoleModifiers();
	|                if (shift)
	|                {
	|                    mod |= ConsoleModifiers.Shift;
	|                }
	|                if (alt)
	|                {
	|                    mod |= ConsoleModifiers.Alt;
	|                }
	|                if (control)
	|                {
	|                    mod |= ConsoleModifiers.Control;
	|                }
	|                var kchar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(keyChar, mod, out uint ckey, out _);
	|                key = ConsoleKeyMapping.MapConsoleKeyToKey((ConsoleKey)ckey, out bool mappable);
	|                if (mappable)
	|                {
	|                    key = (Key)kchar;
	|                }
	|            }
	|            else
	|            {
	|                key = (Key)keyChar;
	|            }
	|
	|            KeyModifiers km = new KeyModifiers();
	|            if (shift)
	|            {
	|                if (keyChar == 0)
	|                {
	|                    key |= Key.ShiftMask;
	|                }
	|                km.Shift = shift;
	|            }
	|            if (alt)
	|            {
	|                key |= Key.AltMask;
	|                km.Alt = alt;
	|            }
	|            if (control)
	|            {
	|                key |= Key.CtrlMask;
	|                km.Ctrl = control;
	|            }
	|            keyDownHandler(new KeyEvent(key, km));
	|            keyHandler(new KeyEvent(key, km));
	|            keyUpHandler(new KeyEvent(key, km));
	|        }
	|
	|        public override bool GetColors(int value, out Color foreground, out Color background)
	|        {
	|            bool hasColor = false;
	|            foreground = default;
	|            background = default;
	|            int back = -1;
	|            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
	|                .OfType<ConsoleColor>()
	|                .Select(s => (int)s);
	|            if (values.Contains((value >> 12) & 0xffff))
	|            {
	|                hasColor = true;
	|                back = (value >> 12) & 0xffff;
	|                background = MapCursesColor(back);
	|            }
	|            if (values.Contains((value - (back << 12)) >> 8))
	|            {
	|                hasColor = true;
	|                foreground = MapCursesColor((value - (back << 12)) >> 8);
	|            }
	|            return hasColor;
	|        }
	|    }
	|
	|    internal static class Platform
	|    {
	|        [DllImport(""libc"")]
	|        static extern int uname(IntPtr buf);
	|
	|        [DllImport(""libc"")]
	|        static extern int killpg(int pgrp, int pid);
	|
	|        static int suspendSignal;
	|
	|        static int GetSuspendSignal()
	|        {
	|            if (suspendSignal != 0)
	|                return suspendSignal;
	|
	|            IntPtr buf = Marshal.AllocHGlobal(8192);
	|            if (uname(buf) != 0)
	|            {
	|                Marshal.FreeHGlobal(buf);
	|                suspendSignal = -1;
	|                return suspendSignal;
	|            }
	|            try
	|            {
	|                switch (Marshal.PtrToStringAnsi(buf))
	|                {
	|                    case ""Darwin"":
	|                    case ""DragonFly"":
	|                    case ""FreeBSD"":
	|                    case ""NetBSD"":
	|                    case ""OpenBSD"":
	|                        suspendSignal = 18;
	|                        break;
	|                    case ""Linux"":
	|                        // TODO: should fetch the machine name and
	|                        // if it is MIPS return 24
	|                        suspendSignal = 20;
	|                        break;
	|                    case ""Solaris"":
	|                        suspendSignal = 24;
	|                        break;
	|                    default:
	|                        suspendSignal = -1;
	|                        break;
	|                }
	|                return suspendSignal;
	|            }
	|            finally
	|            {
	|                Marshal.FreeHGlobal(buf);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Suspends the process by sending SIGTSTP to itself
	|        /// </summary>
	|        /// <returns>The suspend.</returns>
	|        static public bool Suspend()
	|        {
	|            int signal = GetSuspendSignal();
	|            if (signal == -1)
	|                return false;
	|            killpg(0, signal);
	|            return true;
	|        }
	|    }
	|
	|    /// <summary>
	|    ///  A clipboard implementation for Linux.
	|    ///  This implementation uses the xclip command to access the clipboard.
	|    /// </summary>	
	|    /// <remarks>
	|    /// If xclip is not installed, this implementation will not work.
	|    /// </remarks>
	|    class CursesClipboard : ClipboardBase
	|    {
	|        public CursesClipboard()
	|        {
	|            IsSupported = CheckSupport();
	|        }
	|
	|        string xclipPath = string.Empty;
	|        public override bool IsSupported { get; }
	|
	|        bool CheckSupport()
	|        {
	|#pragma warning disable RCS1075 // Avoid empty catch clause that catches System.Exception.
	|            try
	|            {
	|                var (exitCode, result) = ClipboardProcessRunner.Bash(""which xclip"", waitForOutput: true);
	|                if (exitCode == 0 && result.FileExists())
	|                {
	|                    xclipPath = result;
	|                    return true;
	|                }
	|            }
	|            catch (Exception)
	|            {
	|                // Permissions issue.
	|            }
	|#pragma warning restore RCS1075 // Avoid empty catch clause that catches System.Exception.
	|            return false;
	|        }
	|
	|        protected override string GetClipboardDataImpl()
	|        {
	|            var tempFileName = System.IO.Path.GetTempFileName();
	|            var xclipargs = ""-selection clipboard -o"";
	|
	|            try
	|            {
	|                var (exitCode, result) = ClipboardProcessRunner.Bash($""{xclipPath} {xclipargs} > {tempFileName}"", waitForOutput: false);
	|                if (exitCode == 0)
	|                {
	|                    if (Application.Driver is CursesDriver)
	|                    {
	|                        Curses.raw();
	|                        Curses.noecho();
	|                    }
	|                    return System.IO.File.ReadAllText(tempFileName);
	|                }
	|            }
	|            catch (Exception e)
	|            {
	|                throw new NotSupportedException($""\""{xclipPath} {xclipargs}\"" failed."", e);
	|            }
	|            finally
	|            {
	|                System.IO.File.Delete(tempFileName);
	|            }
	|            return string.Empty;
	|        }
	|
	|        protected override void SetClipboardDataImpl(string text)
	|        {
	|            var xclipargs = ""-selection clipboard -i"";
	|            try
	|            {
	|                var (exitCode, _) = ClipboardProcessRunner.Bash($""{xclipPath} {xclipargs}"", text, waitForOutput: false);
	|                if (exitCode == 0 && Application.Driver is CursesDriver)
	|                {
	|                    Curses.raw();
	|                    Curses.noecho();
	|                }
	|            }
	|            catch (Exception e)
	|            {
	|                throw new NotSupportedException($""\""{xclipPath} {xclipargs} < {text}\"" failed"", e);
	|            }
	|        }
	|    }
	|
	|    /// <summary>
	|    ///  A clipboard implementation for MacOSX. 
	|    ///  This implementation uses the Mac clipboard API (via P/Invoke) to copy/paste.
	|    ///  The existance of the Mac pbcopy and pbpaste commands 
	|    ///  is used to determine if copy/paste is supported.
	|    /// </summary>	
	|    class MacOSXClipboard : ClipboardBase
	|    {
	|        IntPtr nsString = objc_getClass(""NSString"");
	|        IntPtr nsPasteboard = objc_getClass(""NSPasteboard"");
	|        IntPtr utfTextType;
	|        IntPtr generalPasteboard;
	|        IntPtr initWithUtf8Register = sel_registerName(""initWithUTF8String:"");
	|        IntPtr allocRegister = sel_registerName(""alloc"");
	|        IntPtr setStringRegister = sel_registerName(""setString:forType:"");
	|        IntPtr stringForTypeRegister = sel_registerName(""stringForType:"");
	|        IntPtr utf8Register = sel_registerName(""UTF8String"");
	|        IntPtr nsStringPboardType;
	|        IntPtr generalPasteboardRegister = sel_registerName(""generalPasteboard"");
	|        IntPtr clearContentsRegister = sel_registerName(""clearContents"");
	|
	|        public MacOSXClipboard()
	|        {
	|            utfTextType = objc_msgSend(objc_msgSend(nsString, allocRegister), initWithUtf8Register, ""public.utf8-plain-text"");
	|            nsStringPboardType = objc_msgSend(objc_msgSend(nsString, allocRegister), initWithUtf8Register, ""NSStringPboardType"");
	|            generalPasteboard = objc_msgSend(nsPasteboard, generalPasteboardRegister);
	|            IsSupported = CheckSupport();
	|        }
	|
	|        public override bool IsSupported { get; }
	|
	|        bool CheckSupport()
	|        {
	|            var (exitCode, result) = ClipboardProcessRunner.Bash(""which pbcopy"", waitForOutput: true);
	|            if (exitCode != 0 || !result.FileExists())
	|            {
	|                return false;
	|            }
	|            (exitCode, result) = ClipboardProcessRunner.Bash(""which pbpaste"", waitForOutput: true);
	|            return exitCode == 0 && result.FileExists();
	|        }
	|
	|        protected override string GetClipboardDataImpl()
	|        {
	|            var ptr = objc_msgSend(generalPasteboard, stringForTypeRegister, nsStringPboardType);
	|            var charArray = objc_msgSend(ptr, utf8Register);
	|            return Marshal.PtrToStringAnsi(charArray);
	|        }
	|
	|        protected override void SetClipboardDataImpl(string text)
	|        {
	|            IntPtr str = default;
	|            try
	|            {
	|                str = objc_msgSend(objc_msgSend(nsString, allocRegister), initWithUtf8Register, text);
	|                objc_msgSend(generalPasteboard, clearContentsRegister);
	|                objc_msgSend(generalPasteboard, setStringRegister, str, utfTextType);
	|            }
	|            finally
	|            {
	|                if (str != default)
	|                {
	|                    objc_msgSend(str, sel_registerName(""release""));
	|                }
	|            }
	|        }
	|
	|        [DllImport(""/System/Library/Frameworks/AppKit.framework/AppKit"")]
	|        static extern IntPtr objc_getClass(string className);
	|
	|        [DllImport(""/System/Library/Frameworks/AppKit.framework/AppKit"")]
	|        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector);
	|
	|        [DllImport(""/System/Library/Frameworks/AppKit.framework/AppKit"")]
	|        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector, string arg1);
	|
	|        [DllImport(""/System/Library/Frameworks/AppKit.framework/AppKit"")]
	|        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector, IntPtr arg1);
	|
	|        [DllImport(""/System/Library/Frameworks/AppKit.framework/AppKit"")]
	|        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector, IntPtr arg1, IntPtr arg2);
	|
	|        [DllImport(""/System/Library/Frameworks/AppKit.framework/AppKit"")]
	|        static extern IntPtr sel_registerName(string selectorName);
	|    }
	|
	|    /// <summary>
	|    ///  A clipboard implementation for Linux, when running under WSL. 
	|    ///  This implementation uses the Windows clipboard to store the data, and uses Windows'
	|    ///  powershell.exe (launched via WSL interop services) to set/get the Windows
	|    ///  clipboard. 
	|    /// </summary>
	|    class WSLClipboard : ClipboardBase
	|    {
	|        bool isSupported = false;
	|        public WSLClipboard()
	|        {
	|            isSupported = CheckSupport();
	|        }
	|
	|        public override bool IsSupported
	|        {
	|            get
	|            {
	|                return isSupported = CheckSupport();
	|            }
	|        }
	|
	|        private static string powershellPath = string.Empty;
	|
	|        bool CheckSupport()
	|        {
	|            if (string.IsNullOrEmpty(powershellPath))
	|            {
	|                // Specify pwsh.exe (not pwsh) to ensure we get the Windows version (invoked via WSL)
	|                var (exitCode, result) = ClipboardProcessRunner.Bash(""which pwsh.exe"", waitForOutput: true);
	|                if (exitCode > 0)
	|                {
	|                    (exitCode, result) = ClipboardProcessRunner.Bash(""which powershell.exe"", waitForOutput: true);
	|                }
	|
	|                if (exitCode == 0)
	|                {
	|                    powershellPath = result;
	|                }
	|            }
	|            return !string.IsNullOrEmpty(powershellPath);
	|        }
	|
	|        protected override string GetClipboardDataImpl()
	|        {
	|            if (!IsSupported)
	|            {
	|                return string.Empty;
	|            }
	|
	|            var (exitCode, output) = ClipboardProcessRunner.Process(powershellPath, ""-noprofile -command \""Get-Clipboard\"""");
	|            if (exitCode == 0)
	|            {
	|                if (Application.Driver is CursesDriver)
	|                {
	|                    Curses.raw();
	|                    Curses.noecho();
	|                }
	|
	|                if (output.EndsWith(""\r\n""))
	|                {
	|                    output = output.Substring(0, output.Length - 2);
	|                }
	|                return output;
	|            }
	|            return string.Empty;
	|        }
	|
	|        protected override void SetClipboardDataImpl(string text)
	|        {
	|            if (!IsSupported)
	|            {
	|                return;
	|            }
	|
	|            var (exitCode, output) = ClipboardProcessRunner.Process(powershellPath, $""-noprofile -command \""Set-Clipboard -Value \\\""{text}\\\""\"""");
	|            if (exitCode == 0)
	|            {
	|                if (Application.Driver is CursesDriver)
	|                {
	|                    Curses.raw();
	|                    Curses.noecho();
	|                }
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // DateField.cs: text entry for date
	|    //
	|    // Author: Barry Nolte
	|    //
	|    // Licensed under the MIT license
	|    //
	|
	|    /// <summary>
	|    ///   Simple Date editing <see cref=""View""/>
	|    /// </summary>
	|    /// <remarks>
	|    ///   The <see cref=""DateField""/> <see cref=""View""/> provides date editing functionality with mouse support.
	|    /// </remarks>
	|    public class DateField : TextField
	|    {
	|        DateTime date;
	|        bool isShort;
	|        int longFieldLen = 10;
	|        int shortFieldLen = 8;
	|        string sepChar;
	|        string longFormat;
	|        string shortFormat;
	|
	|        int fieldLen => isShort ? shortFieldLen : longFieldLen;
	|        string format => isShort ? shortFormat : longFormat;
	|
	|        /// <summary>
	|        ///   DateChanged event, raised when the <see cref=""Date""/> property has changed.
	|        /// </summary>
	|        /// <remarks>
	|        ///   This event is raised when the <see cref=""Date""/> property changes.
	|        /// </remarks>
	|        /// <remarks>
	|        ///   The passed event arguments containing the old value, new value, and format string.
	|        /// </remarks>
	|        public event Action<DateTimeEventArgs<DateTime>> DateChanged;
	|
	|        /// <summary>
	|        ///    Initializes a new instance of <see cref=""DateField""/> using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <param name=""x"">The x coordinate.</param>
	|        /// <param name=""y"">The y coordinate.</param>
	|        /// <param name=""date"">Initial date contents.</param>
	|        /// <param name=""isShort"">If true, shows only two digits for the year.</param>
	|        public DateField(int x, int y, DateTime date, bool isShort = false) : base(x, y, isShort ? 10 : 12, """")
	|        {
	|            Initialize(date, isShort);
	|        }
	|
	|        /// <summary>
	|        ///  Initializes a new instance of <see cref=""DateField""/> using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        public DateField() : this(DateTime.MinValue) { }
	|
	|        /// <summary>
	|        ///  Initializes a new instance of <see cref=""DateField""/> using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <param name=""date""></param>
	|        public DateField(DateTime date) : base("""")
	|        {
	|            Width = fieldLen + 2;
	|            Initialize(date);
	|        }
	|
	|        void Initialize(DateTime date, bool isShort = false)
	|        {
	|            CultureInfo cultureInfo = CultureInfo.CurrentCulture;
	|            sepChar = cultureInfo.DateTimeFormat.DateSeparator;
	|            longFormat = GetLongFormat(cultureInfo.DateTimeFormat.ShortDatePattern);
	|            shortFormat = GetShortFormat(longFormat);
	|            this.isShort = isShort;
	|            Date = date;
	|            CursorPosition = 1;
	|            TextChanged += DateField_Changed;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.DeleteCharRight, () => { DeleteCharRight(); return true; });
	|            AddCommand(Command.DeleteCharLeft, () => { DeleteCharLeft(); return true; });
	|            AddCommand(Command.LeftHome, () => MoveHome());
	|            AddCommand(Command.Left, () => MoveLeft());
	|            AddCommand(Command.RightEnd, () => MoveEnd());
	|            AddCommand(Command.Right, () => MoveRight());
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
	|            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);
	|
	|            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
	|            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);
	|
	|            AddKeyBinding(Key.Home, Command.LeftHome);
	|            AddKeyBinding(Key.A | Key.CtrlMask, Command.LeftHome);
	|
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);
	|
	|            AddKeyBinding(Key.End, Command.RightEnd);
	|            AddKeyBinding(Key.E | Key.CtrlMask, Command.RightEnd);
	|
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);
	|        }
	|
	|        void DateField_Changed(ustring e)
	|        {
	|            try
	|            {
	|                if (!DateTime.TryParseExact(GetDate(Text).ToString(), GetInvarianteFormat(), CultureInfo.CurrentCulture, DateTimeStyles.None, out DateTime result))
	|                    Text = e;
	|            }
	|            catch (Exception)
	|            {
	|                Text = e;
	|            }
	|        }
	|
	|        string GetInvarianteFormat()
	|        {
	|            return $""MM{sepChar}dd{sepChar}yyyy"";
	|        }
	|
	|        string GetLongFormat(string lf)
	|        {
	|            ustring[] frm = ustring.Make(lf).Split(ustring.Make(sepChar));
	|            for (int i = 0; i < frm.Length; i++)
	|            {
	|                if (frm[i].Contains(""M"") && frm[i].RuneCount < 2)
	|                    lf = lf.Replace(""M"", ""MM"");
	|                if (frm[i].Contains(""d"") && frm[i].RuneCount < 2)
	|                    lf = lf.Replace(""d"", ""dd"");
	|                if (frm[i].Contains(""y"") && frm[i].RuneCount < 4)
	|                    lf = lf.Replace(""yy"", ""yyyy"");
	|            }
	|            return $"" {lf}"";
	|        }
	|
	|        string GetShortFormat(string lf)
	|        {
	|            return lf.Replace(""yyyy"", ""yy"");
	|        }
	|
	|        /// <summary>
	|        ///   Gets or sets the date of the <see cref=""DateField""/>.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public DateTime Date
	|        {
	|            get
	|            {
	|                return date;
	|            }
	|            set
	|            {
	|                if (ReadOnly)
	|                    return;
	|
	|                var oldData = date;
	|                date = value;
	|                this.Text = value.ToString(format);
	|                var args = new DateTimeEventArgs<DateTime>(oldData, value, format);
	|                if (oldData != value)
	|                {
	|                    OnDateChanged(args);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or set the date format for the widget.
	|        /// </summary>
	|        public bool IsShortFormat
	|        {
	|            get => isShort;
	|            set
	|            {
	|                isShort = value;
	|                if (isShort)
	|                    Width = 10;
	|                else
	|                    Width = 12;
	|                var ro = ReadOnly;
	|                if (ro)
	|                    ReadOnly = false;
	|                SetText(Text);
	|                ReadOnly = ro;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override int CursorPosition
	|        {
	|            get => base.CursorPosition;
	|            set
	|            {
	|                base.CursorPosition = Math.Max(Math.Min(value, fieldLen), 1);
	|            }
	|        }
	|
	|        bool SetText(Rune key)
	|        {
	|            var text = TextModel.ToRunes(Text);
	|            var newText = text.GetRange(0, CursorPosition);
	|            newText.Add(key);
	|            if (CursorPosition < fieldLen)
	|                newText = newText.Concat(text.GetRange(CursorPosition + 1, text.Count - (CursorPosition + 1))).ToList();
	|            return SetText(ustring.Make(newText));
	|        }
	|
	|        bool SetText(ustring text)
	|        {
	|            if (text.IsEmpty)
	|            {
	|                return false;
	|            }
	|
	|            ustring[] vals = text.Split(ustring.Make(sepChar));
	|            ustring[] frm = ustring.Make(format).Split(ustring.Make(sepChar));
	|            bool isValidDate = true;
	|            int idx = GetFormatIndex(frm, ""y"");
	|            int year = Int32.Parse(vals[idx].ToString());
	|            int month;
	|            int day;
	|            idx = GetFormatIndex(frm, ""M"");
	|            if (Int32.Parse(vals[idx].ToString()) < 1)
	|            {
	|                isValidDate = false;
	|                month = 1;
	|                vals[idx] = ""1"";
	|            }
	|            else if (Int32.Parse(vals[idx].ToString()) > 12)
	|            {
	|                isValidDate = false;
	|                month = 12;
	|                vals[idx] = ""12"";
	|            }
	|            else
	|                month = Int32.Parse(vals[idx].ToString());
	|            idx = GetFormatIndex(frm, ""d"");
	|            if (Int32.Parse(vals[idx].ToString()) < 1)
	|            {
	|                isValidDate = false;
	|                day = 1;
	|                vals[idx] = ""1"";
	|            }
	|            else if (Int32.Parse(vals[idx].ToString()) > 31)
	|            {
	|                isValidDate = false;
	|                day = DateTime.DaysInMonth(year, month);
	|                vals[idx] = day.ToString();
	|            }
	|            else
	|                day = Int32.Parse(vals[idx].ToString());
	|            string d = GetDate(month, day, year, frm);
	|
	|            if (!DateTime.TryParseExact(d, format, CultureInfo.CurrentCulture, DateTimeStyles.None, out DateTime result) ||
	|                !isValidDate)
	|                return false;
	|            Date = result;
	|            return true;
	|        }
	|
	|        string GetDate(int month, int day, int year, ustring[] fm)
	|        {
	|            string date = "" "";
	|            for (int i = 0; i < fm.Length; i++)
	|            {
	|                if (fm[i].Contains(""M""))
	|                {
	|                    date += $""{month,2:00}"";
	|                }
	|                else if (fm[i].Contains(""d""))
	|                {
	|                    date += $""{day,2:00}"";
	|                }
	|                else
	|                {
	|                    if (!isShort && year.ToString().Length == 2)
	|                    {
	|                        var y = DateTime.Now.Year.ToString();
	|                        date += y.Substring(0, 2) + year.ToString();
	|                    }
	|                    else if (isShort && year.ToString().Length == 4)
	|                    {
	|                        date += $""{year.ToString().Substring(2, 2)}"";
	|                    }
	|                    else
	|                    {
	|                        date += $""{year,2:00}"";
	|                    }
	|                }
	|                if (i < 2)
	|                    date += $""{sepChar}"";
	|            }
	|            return date;
	|        }
	|
	|        ustring GetDate(ustring text)
	|        {
	|            ustring[] vals = text.Split(ustring.Make(sepChar));
	|            ustring[] frm = ustring.Make(format).Split(ustring.Make(sepChar));
	|            ustring[] date = { null, null, null };
	|
	|            for (int i = 0; i < frm.Length; i++)
	|            {
	|                if (frm[i].Contains(""M""))
	|                {
	|                    date[0] = vals[i].TrimSpace();
	|                }
	|                else if (frm[i].Contains(""d""))
	|                {
	|                    date[1] = vals[i].TrimSpace();
	|                }
	|                else
	|                {
	|                    var year = vals[i].TrimSpace();
	|                    if (year.RuneCount == 2)
	|                    {
	|                        var y = DateTime.Now.Year.ToString();
	|                        date[2] = y.Substring(0, 2) + year.ToString();
	|                    }
	|                    else
	|                    {
	|                        date[2] = vals[i].TrimSpace();
	|                    }
	|                }
	|            }
	|            return date[0] + ustring.Make(sepChar) + date[1] + ustring.Make(sepChar) + date[2];
	|
	|        }
	|
	|        int GetFormatIndex(ustring[] fm, string t)
	|        {
	|            int idx = -1;
	|            for (int i = 0; i < fm.Length; i++)
	|            {
	|                if (fm[i].Contains(t))
	|                {
	|                    idx = i;
	|                    break;
	|                }
	|            }
	|            return idx;
	|        }
	|
	|        void IncCursorPosition()
	|        {
	|            if (CursorPosition == fieldLen)
	|                return;
	|            if (Text[++CursorPosition] == sepChar.ToCharArray()[0])
	|                CursorPosition++;
	|        }
	|
	|        void DecCursorPosition()
	|        {
	|            if (CursorPosition == 1)
	|                return;
	|            if (Text[--CursorPosition] == sepChar.ToCharArray()[0])
	|                CursorPosition--;
	|        }
	|
	|        void AdjCursorPosition()
	|        {
	|            if (Text[CursorPosition] == sepChar.ToCharArray()[0])
	|                CursorPosition++;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            // Ignore non-numeric characters.
	|            if (kb.Key < (Key)((int)'0') || kb.Key > (Key)((int)'9'))
	|                return false;
	|
	|            if (ReadOnly)
	|                return true;
	|
	|            if (SetText(TextModel.ToRunes(ustring.Make((uint)kb.Key)).First()))
	|                IncCursorPosition();
	|
	|            return true;
	|        }
	|
	|        bool MoveRight()
	|        {
	|            IncCursorPosition();
	|            return true;
	|        }
	|
	|        bool MoveEnd()
	|        {
	|            CursorPosition = fieldLen;
	|            return true;
	|        }
	|
	|        bool MoveLeft()
	|        {
	|            DecCursorPosition();
	|            return true;
	|        }
	|
	|        bool MoveHome()
	|        {
	|            // Home, C-A
	|            CursorPosition = 1;
	|            return true;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void DeleteCharLeft(bool useOldCursorPos = true)
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            SetText('0');
	|            DecCursorPosition();
	|            return;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void DeleteCharRight()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            SetText('0');
	|            return;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool MouseEvent(MouseEvent ev)
	|        {
	|            if (!ev.Flags.HasFlag(MouseFlags.Button1Clicked))
	|                return false;
	|            if (!HasFocus)
	|                SetFocus();
	|
	|            var point = ev.X;
	|            if (point > fieldLen)
	|                point = fieldLen;
	|            if (point < 1)
	|                point = 1;
	|            CursorPosition = point;
	|            AdjCursorPosition();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Event firing method for the <see cref=""DateChanged""/> event.
	|        /// </summary>
	|        /// <param name=""args"">Event arguments</param>
	|        public virtual void OnDateChanged(DateTimeEventArgs<DateTime> args)
	|        {
	|            DateChanged?.Invoke(args);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Defines the event arguments for <see cref=""DateField.DateChanged""/> and <see cref=""TimeField.TimeChanged""/> events.
	|    /// </summary>
	|    public class DateTimeEventArgs<T> : EventArgs
	|    {
	|        /// <summary>
	|        /// The old <see cref=""DateField""/> or <see cref=""TimeField""/> value.
	|        /// </summary>
	|        public T OldValue { get; }
	|
	|        /// <summary>
	|        /// The new <see cref=""DateField""/> or <see cref=""TimeField""/> value.
	|        /// </summary>
	|        public T NewValue { get; }
	|
	|        /// <summary>
	|        /// The <see cref=""DateField""/> or <see cref=""TimeField""/> format.
	|        /// </summary>
	|        public string Format { get; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""DateTimeEventArgs{T}""/>
	|        /// </summary>
	|        /// <param name=""oldValue"">The old <see cref=""DateField""/> or <see cref=""TimeField""/> value.</param>
	|        /// <param name=""newValue"">The new <see cref=""DateField""/> or <see cref=""TimeField""/> value.</param>
	|        /// <param name=""format"">The <see cref=""DateField""/> or <see cref=""TimeField""/> format string.</param>
	|        public DateTimeEventArgs(T oldValue, T newValue, string format)
	|        {
	|            OldValue = oldValue;
	|            NewValue = newValue;
	|            Format = format;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // Dialog.cs: Dialog box
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    /// The <see cref=""Dialog""/> <see cref=""View""/> is a <see cref=""Window""/> that by default is centered and contains one 
	|    /// or more <see cref=""Button""/>s. It defaults to the <see cref=""Colors.Dialog""/> color scheme and has a 1 cell padding around the edges.
	|    /// </summary>
	|    /// <remarks>
	|    ///  To run the <see cref=""Dialog""/> modally, create the <see cref=""Dialog""/>, and pass it to <see cref=""Application.Run(Func{Exception, bool})""/>. 
	|    ///  This will execute the dialog until it terminates via the [ESC] or [CTRL-Q] key, or when one of the views
	|    ///  or buttons added to the dialog calls <see cref=""Application.RequestStop""/>.
	|    /// </remarks>
	|    public class Dialog : Window
	|    {
	|        internal List<Button> buttons = new List<Button>();
	|        const int padding = 0;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Dialog""/> class using <see cref=""LayoutStyle.Computed""/> positioning 
	|        /// and an optional set of <see cref=""Button""/>s to display
	|        /// </summary>
	|        /// <param name=""title"">Title for the dialog.</param>
	|        /// <param name=""width"">Width for the dialog.</param>
	|        /// <param name=""height"">Height for the dialog.</param>
	|        /// <param name=""buttons"">Optional buttons to lay out at the bottom of the dialog.</param>
	|        /// <remarks>
	|        /// if <c>width</c> and <c>height</c> are both 0, the Dialog will be vertically and horizontally centered in the
	|        /// container and the size will be 85% of the container. 
	|        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> to override this with a location or size.
	|        /// </remarks>
	|        /// <remarks>
	|        /// Use the constructor that does not take a <c>width</c> and <c>height</c> instead.
	|        /// </remarks>
	|        public Dialog(ustring title, int width, int height, params Button[] buttons) : base(title, padding: padding)
	|        {
	|            X = Pos.Center();
	|            Y = Pos.Center();
	|
	|            if (width == 0 & height == 0)
	|            {
	|                Width = Dim.Percent(85);
	|                Height = Dim.Percent(85);
	|            }
	|            else
	|            {
	|                Width = width;
	|                Height = height;
	|            }
	|
	|            ColorScheme = Colors.Dialog;
	|            Modal = true;
	|            Border.Effect3D = true;
	|
	|            if (buttons != null)
	|            {
	|                foreach (var b in buttons)
	|                {
	|                    this.buttons.Add(b);
	|                    Add(b);
	|                }
	|            }
	|
	|            LayoutStarted += (args) =>
	|            {
	|                LayoutStartedHandler();
	|            };
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Dialog""/> class using <see cref=""LayoutStyle.Computed""/>.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        /// Te Dialog will be vertically and horizontally centered in the container and the size will be 85% of the container. 
	|        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> to override this with a location or size.
	|        /// </para>
	|        /// <para>
	|        /// Use <see cref=""AddButton(Button)""/> to add buttons to the dialog.
	|        /// </para>
	|        /// </remarks>
	|        public Dialog() : this(title: string.Empty, width: 0, height: 0, buttons: null) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Dialog""/> class using <see cref=""LayoutStyle.Computed""/> positioning 
	|        /// and with an optional set of <see cref=""Button""/>s to display
	|        /// </summary>
	|        /// <param name=""title"">Title for the dialog.</param>
	|        /// <param name=""buttons"">Optional buttons to lay out at the bottom of the dialog.</param>
	|        /// <remarks>
	|        /// Te Dialog will be vertically and horizontally centered in the container and the size will be 85% of the container. 
	|        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> to override this with a location or size.
	|        /// </remarks>
	|        public Dialog(ustring title, params Button[] buttons) : this(title: title, width: 0, height: 0, buttons: buttons) { }
	|
	|        /// <summary>
	|        /// Adds a <see cref=""Button""/> to the <see cref=""Dialog""/>, its layout will be controlled by the <see cref=""Dialog""/>
	|        /// </summary>
	|        /// <param name=""button"">Button to add.</param>
	|        public void AddButton(Button button)
	|        {
	|            if (button == null)
	|                return;
	|
	|            buttons.Add(button);
	|            Add(button);
	|            SetNeedsDisplay();
	|            LayoutSubviews();
	|        }
	|
	|        // Get the width of all buttons, not including any spacing
	|        internal int GetButtonsWidth()
	|        {
	|            if (buttons.Count == 0)
	|            {
	|                return 0;
	|            }
	|            return buttons.Select(b => b.Bounds.Width).Sum();
	|        }
	|        /// <summary>
	|        /// Determines the horizontal alignment of the Dialog buttons.
	|        /// </summary>
	|        public enum ButtonAlignments
	|        {
	|            /// <summary>
	|            /// Center-aligns the buttons (the default).
	|            /// </summary>
	|            Center = 0,
	|
	|            /// <summary>
	|            /// Justifies the buttons
	|            /// </summary>
	|            Justify,
	|
	|            /// <summary>
	|            /// Left-aligns the buttons
	|            /// </summary>
	|            Left,
	|
	|            /// <summary>
	|            /// Right-aligns the buttons
	|            /// </summary>
	|            Right
	|        }
	|
	|        private ButtonAlignments buttonAlignment = Dialog.ButtonAlignments.Center;
	|
	|        /// <summary>
	|        /// Determines how the <see cref=""Dialog""/> <see cref=""Button""/>s are aligned along the 
	|        /// bottom of the dialog. 
	|        /// </summary>
	|        public ButtonAlignments ButtonAlignment { get => buttonAlignment; set => buttonAlignment = value; }
	|
	|        void LayoutStartedHandler()
	|        {
	|            if (buttons.Count == 0 || !IsInitialized) return;
	|
	|            int shiftLeft = 0;
	|
	|            int buttonsWidth = GetButtonsWidth();
	|            switch (ButtonAlignment)
	|            {
	|                case ButtonAlignments.Center:
	|                    // Center Buttons
	|                    shiftLeft = (Bounds.Width - buttonsWidth - buttons.Count - 2) / 2 + 1;
	|                    for (int i = buttons.Count - 1; i >= 0; i--)
	|                    {
	|                        Button button = buttons[i];
	|                        shiftLeft += button.Frame.Width + (i == buttons.Count - 1 ? 0 : 1);
	|                        if (shiftLeft > -1)
	|                        {
	|                            button.X = Pos.AnchorEnd(shiftLeft);
	|                        }
	|                        else
	|                        {
	|                            button.X = Frame.Width - shiftLeft;
	|                        }
	|                        button.Y = Pos.AnchorEnd(1);
	|                    }
	|                    break;
	|
	|                case ButtonAlignments.Justify:
	|                    // Justify Buttons
	|                    // leftmost and rightmost buttons are hard against edges. The rest are evenly spaced.
	|
	|                    var spacing = (int)Math.Ceiling((double)(Bounds.Width - buttonsWidth - (Border.DrawMarginFrame ? 2 : 0)) / (buttons.Count - 1));
	|                    for (int i = buttons.Count - 1; i >= 0; i--)
	|                    {
	|                        Button button = buttons[i];
	|                        if (i == buttons.Count - 1)
	|                        {
	|                            shiftLeft += button.Frame.Width;
	|                            button.X = Pos.AnchorEnd(shiftLeft);
	|                        }
	|                        else
	|                        {
	|                            if (i == 0)
	|                            {
	|                                // first (leftmost) button - always hard flush left
	|                                var left = Bounds.Width - ((Border.DrawMarginFrame ? 2 : 0) + Border.BorderThickness.Left + Border.BorderThickness.Right);
	|                                button.X = Pos.AnchorEnd(Math.Max(left, 0));
	|                            }
	|                            else
	|                            {
	|                                shiftLeft += button.Frame.Width + (spacing);
	|                                button.X = Pos.AnchorEnd(shiftLeft);
	|                            }
	|                        }
	|                        button.Y = Pos.AnchorEnd(1);
	|                    }
	|                    break;
	|
	|                case ButtonAlignments.Left:
	|                    // Left Align Buttons
	|                    var prevButton = buttons[0];
	|                    prevButton.X = 0;
	|                    prevButton.Y = Pos.AnchorEnd(1);
	|                    for (int i = 1; i < buttons.Count; i++)
	|                    {
	|                        Button button = buttons[i];
	|                        button.X = Pos.Right(prevButton) + 1;
	|                        button.Y = Pos.AnchorEnd(1);
	|                        prevButton = button;
	|                    }
	|                    break;
	|
	|                case ButtonAlignments.Right:
	|                    // Right align buttons
	|                    shiftLeft = buttons[buttons.Count - 1].Frame.Width;
	|                    buttons[buttons.Count - 1].X = Pos.AnchorEnd(shiftLeft);
	|                    buttons[buttons.Count - 1].Y = Pos.AnchorEnd(1);
	|                    for (int i = buttons.Count - 2; i >= 0; i--)
	|                    {
	|                        Button button = buttons[i];
	|                        shiftLeft += button.Frame.Width + 1;
	|                        button.X = Pos.AnchorEnd(shiftLeft);
	|                        button.Y = Pos.AnchorEnd(1);
	|                    }
	|                    break;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            switch (kb.Key)
	|            {
	|                case Key.Esc:
	|                    Application.RequestStop(this);
	|                    return true;
	|            }
	|            return base.ProcessKey(kb);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Represents the state of an ANSI escape sequence request.
	|    /// </summary>
	|    /// <remarks>
	|    /// This is needed because there are some escape sequence requests responses that are equal
	|    /// with some normal escape sequences and thus, will be only considered the responses to the
	|    /// requests that were registered with this object.
	|    /// </remarks>
	|    public class EscSeqReqStatus
	|    {
	|        /// <summary>
	|        /// Gets the terminating.
	|        /// </summary>
	|        public string Terminating { get; }
	|        /// <summary>
	|        /// Gets the number of requests.
	|        /// </summary>
	|        public int NumRequests { get; }
	|        /// <summary>
	|        /// Gets information about unfinished requests.
	|        /// </summary>
	|        public int NumOutstanding { get; set; }
	|
	|        /// <summary>
	|        /// Creates a new state of escape sequence request.
	|        /// </summary>
	|        /// <param name=""terminating"">The terminating.</param>
	|        /// <param name=""numOfReq"">The number of requests.</param>
	|        public EscSeqReqStatus(string terminating, int numOfReq)
	|        {
	|            Terminating = terminating;
	|            NumRequests = NumOutstanding = numOfReq;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Manages a list of <see cref=""EscSeqReqStatus""/>.
	|    /// </summary>
	|    public class EscSeqReqProc
	|    {
	|        /// <summary>
	|        /// Gets the <see cref=""EscSeqReqStatus""/> list.
	|        /// </summary>
	|        public List<EscSeqReqStatus> EscSeqReqStats { get; } = new List<EscSeqReqStatus>();
	|
	|        /// <summary>
	|        /// Adds a new <see cref=""EscSeqReqStatus""/> instance to the <see cref=""EscSeqReqStats""/> list.
	|        /// </summary>
	|        /// <param name=""terminating"">The terminating.</param>
	|        /// <param name=""numOfReq"">The number of requests.</param>
	|        public void Add(string terminating, int numOfReq = 1)
	|        {
	|            lock (EscSeqReqStats)
	|            {
	|                var found = EscSeqReqStats.Find(x => x.Terminating == terminating);
	|                if (found == null)
	|                {
	|                    EscSeqReqStats.Add(new EscSeqReqStatus(terminating, numOfReq));
	|                }
	|                else if (found != null && found.NumOutstanding < found.NumRequests)
	|                {
	|                    found.NumOutstanding = Math.Min(found.NumOutstanding + numOfReq, found.NumRequests);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Removes a <see cref=""EscSeqReqStatus""/> instance from the <see cref=""EscSeqReqStats""/> list.
	|        /// </summary>
	|        /// <param name=""terminating"">The terminating string.</param>
	|        public void Remove(string terminating)
	|        {
	|            lock (EscSeqReqStats)
	|            {
	|                var found = EscSeqReqStats.Find(x => x.Terminating == terminating);
	|                if (found == null)
	|                {
	|                    return;
	|                }
	|                if (found != null && found.NumOutstanding == 0)
	|                {
	|                    EscSeqReqStats.Remove(found);
	|                }
	|                else if (found != null && found.NumOutstanding > 0)
	|                {
	|                    found.NumOutstanding--;
	|                    if (found.NumOutstanding == 0)
	|                    {
	|                        EscSeqReqStats.Remove(found);
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Indicates if a <see cref=""EscSeqReqStatus""/> with the <paramref name=""terminating""/> exist
	|        /// in the <see cref=""EscSeqReqStats""/> list.
	|        /// </summary>
	|        /// <param name=""terminating""></param>
	|        /// <returns><see langword=""true""/> if exist, <see langword=""false""/> otherwise.</returns>
	|        public bool Requested(string terminating)
	|        {
	|            lock (EscSeqReqStats)
	|            {
	|                var found = EscSeqReqStats.Find(x => x.Terminating == terminating);
	|                if (found == null)
	|                {
	|                    return false;
	|                }
	|                if (found != null && found.NumOutstanding > 0)
	|                {
	|                    return true;
	|                }
	|                else
	|                {
	|                    EscSeqReqStats.Remove(found);
	|                }
	|                return false;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Provides a platform-independent API for managing ANSI escape sequence codes.
	|    /// </summary>
	|    public static class EscSeqUtils
	|    {
	|        /// <summary>
	|        /// Represents the escape key.
	|        /// </summary>
	|        public static readonly char KeyEsc = (char)Key.Esc;
	|        /// <summary>
	|        /// Represents the CSI (Control Sequence Introducer).
	|        /// </summary>
	|        public static readonly string KeyCSI = $""{KeyEsc}["";
	|        /// <summary>
	|        /// Represents the CSI for enable any mouse event tracking.
	|        /// </summary>
	|        public static readonly string CSI_EnableAnyEventMouse = KeyCSI + ""?1003h"";
	|        /// <summary>
	|        /// Represents the CSI for enable SGR (Select Graphic Rendition).
	|        /// </summary>
	|        public static readonly string CSI_EnableSgrExtModeMouse = KeyCSI + ""?1006h"";
	|        /// <summary>
	|        /// Represents the CSI for enable URXVT (Unicode Extended Virtual Terminal).
	|        /// </summary>
	|        public static readonly string CSI_EnableUrxvtExtModeMouse = KeyCSI + ""?1015h"";
	|        /// <summary>
	|        /// Represents the CSI for disable any mouse event tracking.
	|        /// </summary>
	|        public static readonly string CSI_DisableAnyEventMouse = KeyCSI + ""?1003l"";
	|        /// <summary>
	|        /// Represents the CSI for disable SGR (Select Graphic Rendition).
	|        /// </summary>
	|        public static readonly string CSI_DisableSgrExtModeMouse = KeyCSI + ""?1006l"";
	|        /// <summary>
	|        /// Represents the CSI for disable URXVT (Unicode Extended Virtual Terminal).
	|        /// </summary>
	|        public static readonly string CSI_DisableUrxvtExtModeMouse = KeyCSI + ""?1015l"";
	|
	|        /// <summary>
	|        /// Control sequence for enable mouse events.
	|        /// </summary>
	|        public static string EnableMouseEvents { get; set; } =
	|            CSI_EnableAnyEventMouse + CSI_EnableUrxvtExtModeMouse + CSI_EnableSgrExtModeMouse;
	|        /// <summary>
	|        /// Control sequence for disable mouse events.
	|        /// </summary>
	|        public static string DisableMouseEvents { get; set; } =
	|            CSI_DisableAnyEventMouse + CSI_DisableUrxvtExtModeMouse + CSI_DisableSgrExtModeMouse;
	|
	|        /// <summary>
	|        /// Ensures a console key is mapped to one that works correctly with ANSI escape sequences.
	|        /// </summary>
	|        /// <param name=""consoleKeyInfo"">The <see cref=""ConsoleKeyInfo""/>.</param>
	|        /// <returns>The <see cref=""ConsoleKeyInfo""/> modified.</returns>
	|        public static ConsoleKeyInfo GetConsoleInputKey(ConsoleKeyInfo consoleKeyInfo)
	|        {
	|            ConsoleKeyInfo newConsoleKeyInfo = consoleKeyInfo;
	|            ConsoleKey key;
	|            var keyChar = consoleKeyInfo.KeyChar;
	|            switch ((uint)keyChar)
	|            {
	|                case 0:
	|                    if (consoleKeyInfo.Key == (ConsoleKey)64)
	|                    {    // Ctrl+Space in Windows.
	|                        newConsoleKeyInfo = new ConsoleKeyInfo(' ', ConsoleKey.Spacebar,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Control) != 0);
	|                    }
	|                    break;
	|                case uint n when (n >= '\u0001' && n <= '\u001a'):
	|                    if (consoleKeyInfo.Key == 0 && consoleKeyInfo.KeyChar == '\r')
	|                    {
	|                        key = ConsoleKey.Enter;
	|                        newConsoleKeyInfo = new ConsoleKeyInfo(consoleKeyInfo.KeyChar,
	|                            key,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Control) != 0);
	|                    }
	|                    else if (consoleKeyInfo.Key == 0)
	|                    {
	|                        key = (ConsoleKey)(char)(consoleKeyInfo.KeyChar + (uint)ConsoleKey.A - 1);
	|                        newConsoleKeyInfo = new ConsoleKeyInfo((char)key,
	|                            key,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
	|                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
	|                            true);
	|                    }
	|                    break;
	|                case 127:
	|                    newConsoleKeyInfo = new ConsoleKeyInfo(consoleKeyInfo.KeyChar, ConsoleKey.Backspace,
	|                        (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
	|                        (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
	|                        (consoleKeyInfo.Modifiers & ConsoleModifiers.Control) != 0);
	|                    break;
	|                default:
	|                    newConsoleKeyInfo = consoleKeyInfo;
	|                    break;
	|            }
	|
	|            return newConsoleKeyInfo;
	|        }
	|
	|        /// <summary>
	|        /// A helper to resize the <see cref=""ConsoleKeyInfo""/> as needed.
	|        /// </summary>
	|        /// <param name=""consoleKeyInfo"">The <see cref=""ConsoleKeyInfo""/>.</param>
	|        /// <param name=""cki"">The <see cref=""ConsoleKeyInfo""/> array to resize.</param>
	|        /// <returns>The <see cref=""ConsoleKeyInfo""/> resized.</returns>
	|        public static ConsoleKeyInfo[] ResizeArray(ConsoleKeyInfo consoleKeyInfo, ConsoleKeyInfo[] cki)
	|        {
	|            Array.Resize(ref cki, cki == null ? 1 : cki.Length + 1);
	|            cki[cki.Length - 1] = consoleKeyInfo;
	|            return cki;
	|        }
	|
	|        /// <summary>
	|        /// Decodes a escape sequence to been processed in the appropriate manner.
	|        /// </summary>
	|        /// <param name=""escSeqReqProc"">The <see cref=""EscSeqReqProc""/> which may contain a request.</param>
	|        /// <param name=""newConsoleKeyInfo"">The <see cref=""ConsoleKeyInfo""/> which may changes.</param>
	|        /// <param name=""key"">The <see cref=""ConsoleKey""/> which may changes.</param>
	|        /// <param name=""cki"">The <see cref=""ConsoleKeyInfo""/> array.</param>
	|        /// <param name=""mod"">The <see cref=""ConsoleModifiers""/> which may changes.</param>
	|        /// <param name=""c1Control"">The control returned by the <see cref=""GetC1ControlChar(char)""/> method.</param>
	|        /// <param name=""code"">The code returned by the <see cref=""GetEscapeResult(char[])""/> method.</param>
	|        /// <param name=""values"">The values returned by the <see cref=""GetEscapeResult(char[])""/> method.</param>
	|        /// <param name=""terminating"">The terminating returned by the <see cref=""GetEscapeResult(char[])""/> method.</param>
	|        /// <param name=""isKeyMouse"">Indicates if the escape sequence is a mouse key.</param>
	|        /// <param name=""buttonState"">The <see cref=""MouseFlags""/> button state.</param>
	|        /// <param name=""pos"">The <see cref=""MouseFlags""/> position.</param>
	|        /// <param name=""isReq"">Indicates if the escape sequence is a response to a request.</param>
	|        /// <param name=""continuousButtonPressedHandler"">The handler that will process the event.</param>
	|        public static void DecodeEscSeq(EscSeqReqProc escSeqReqProc, ref ConsoleKeyInfo newConsoleKeyInfo, ref ConsoleKey key, ConsoleKeyInfo[] cki, ref ConsoleModifiers mod, out string c1Control, out string code, out string[] values, out string terminating, out bool isKeyMouse, out List<MouseFlags> buttonState, out Point pos, out bool isReq, Action<MouseFlags, Point> continuousButtonPressedHandler)
	|        {
	|            char[] kChars = GetKeyCharArray(cki);
	|            (c1Control, code, values, terminating) = GetEscapeResult(kChars);
	|            isKeyMouse = false;
	|            buttonState = new List<MouseFlags>() { 0 };
	|            pos = default;
	|            isReq = false;
	|            switch (c1Control)
	|            {
	|                case ""ESC"":
	|                    if (values == null && string.IsNullOrEmpty(terminating))
	|                    {
	|                        key = ConsoleKey.Escape;
	|                        newConsoleKeyInfo = new ConsoleKeyInfo(cki[0].KeyChar, key,
	|                            (mod & ConsoleModifiers.Shift) != 0,
	|                            (mod & ConsoleModifiers.Alt) != 0,
	|                            (mod & ConsoleModifiers.Control) != 0);
	|                    }
	|                    else if ((uint)cki[1].KeyChar >= 1 && (uint)cki[1].KeyChar <= 26)
	|                    {
	|                        key = (ConsoleKey)(char)(cki[1].KeyChar + (uint)ConsoleKey.A - 1);
	|                        newConsoleKeyInfo = new ConsoleKeyInfo(cki[1].KeyChar,
	|                            key,
	|                            false,
	|                            true,
	|                            true);
	|                    }
	|                    else
	|                    {
	|                        if (cki[1].KeyChar >= 97 && cki[1].KeyChar <= 122)
	|                        {
	|                            key = (ConsoleKey)cki[1].KeyChar.ToString().ToUpper()[0];
	|                        }
	|                        else
	|                        {
	|                            key = (ConsoleKey)cki[1].KeyChar;
	|                        }
	|                        newConsoleKeyInfo = new ConsoleKeyInfo((char)key,
	|                            (ConsoleKey)Math.Min((uint)key, 255),
	|                            false,
	|                            true,
	|                            false);
	|                    }
	|                    break;
	|                case ""SS3"":
	|                    key = GetConsoleKey(terminating[0], values[0], ref mod);
	|                    newConsoleKeyInfo = new ConsoleKeyInfo('\0',
	|                        key,
	|                        (mod & ConsoleModifiers.Shift) != 0,
	|                        (mod & ConsoleModifiers.Alt) != 0,
	|                        (mod & ConsoleModifiers.Control) != 0);
	|                    break;
	|                case ""CSI"":
	|                    if (!string.IsNullOrEmpty(code) && code == ""<"")
	|                    {
	|                        GetMouse(cki, out buttonState, out pos, continuousButtonPressedHandler);
	|                        isKeyMouse = true;
	|                        return;
	|                    }
	|                    else if (escSeqReqProc != null && escSeqReqProc.Requested(terminating))
	|                    {
	|                        isReq = true;
	|                        escSeqReqProc.Remove(terminating);
	|                        return;
	|                    }
	|                    key = GetConsoleKey(terminating[0], values[0], ref mod);
	|                    if (key != 0 && values.Length > 1)
	|                    {
	|                        mod |= GetConsoleModifiers(values[1]);
	|                    }
	|                    newConsoleKeyInfo = new ConsoleKeyInfo('\0',
	|                        key,
	|                        (mod & ConsoleModifiers.Shift) != 0,
	|                        (mod & ConsoleModifiers.Alt) != 0,
	|                        (mod & ConsoleModifiers.Control) != 0);
	|                    break;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets all the needed information about a escape sequence.
	|        /// </summary>
	|        /// <param name=""kChar"">The array with all chars.</param>
	|        /// <returns>
	|        /// The c1Control returned by <see cref=""GetC1ControlChar(char)""/>, code, values and terminating.
	|        /// </returns>
	|        public static (string c1Control, string code, string[] values, string terminating) GetEscapeResult(char[] kChar)
	|        {
	|            if (kChar == null || kChar.Length == 0)
	|            {
	|                return (null, null, null, null);
	|            }
	|            if (kChar[0] != '\x1b')
	|            {
	|                throw new InvalidOperationException(""Invalid escape character!"");
	|            }
	|            if (kChar.Length == 1)
	|            {
	|                return (""ESC"", null, null, null);
	|            }
	|            if (kChar.Length == 2)
	|            {
	|                return (""ESC"", null, null, kChar[1].ToString());
	|            }
	|            string c1Control = GetC1ControlChar(kChar[1]);
	|            string code = null;
	|            int nSep = kChar.Count(x => x == ';') + 1;
	|            string[] values = new string[nSep];
	|            int valueIdx = 0;
	|            string terminating = """";
	|            for (int i = 2; i < kChar.Length; i++)
	|            {
	|                var c = kChar[i];
	|                if (char.IsDigit(c))
	|                {
	|                    values[valueIdx] += c.ToString();
	|                }
	|                else if (c == ';')
	|                {
	|                    valueIdx++;
	|                }
	|                else if (valueIdx == nSep - 1 || i == kChar.Length - 1)
	|                {
	|                    terminating += c.ToString();
	|                }
	|                else
	|                {
	|                    code += c.ToString();
	|                }
	|            }
	|
	|            return (c1Control, code, values, terminating);
	|        }
	|
	|        /// <summary>
	|        /// Gets the c1Control used in the called escape sequence.
	|        /// </summary>
	|        /// <param name=""c"">The char used.</param>
	|        /// <returns>The c1Control.</returns>
	|        public static string GetC1ControlChar(char c)
	|        {
	|            // These control characters are used in the vtXXX emulation.
	|            switch (c)
	|            {
	|                case 'D':
	|                    return ""IND""; // Index
	|                case 'E':
	|                    return ""NEL""; // Next Line
	|                case 'H':
	|                    return ""HTS""; // Tab Set
	|                case 'M':
	|                    return ""RI""; // Reverse Index
	|                case 'N':
	|                    return ""SS2""; // Single Shift Select of G2 Character Set: affects next character only
	|                case 'O':
	|                    return ""SS3""; // Single Shift Select of G3 Character Set: affects next character only
	|                case 'P':
	|                    return ""DCS""; // Device Control String
	|                case 'V':
	|                    return ""SPA""; // Start of Guarded Area
	|                case 'W':
	|                    return ""EPA""; // End of Guarded Area
	|                case 'X':
	|                    return ""SOS""; // Start of String
	|                case 'Z':
	|                    return ""DECID""; // Return Terminal ID Obsolete form of CSI c (DA)
	|                case '[':
	|                    return ""CSI""; // Control Sequence Introducer
	|                case '\\':
	|                    return ""ST""; // String Terminator
	|                case ']':
	|                    return ""OSC""; // Operating System Command
	|                case '^':
	|                    return ""PM""; // Privacy Message
	|                case '_':
	|                    return ""APC""; // Application Program Command
	|                default:
	|                    return """"; // Not supported
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the <see cref=""ConsoleModifiers""/> from the value.
	|        /// </summary>
	|        /// <param name=""value"">The value.</param>
	|        /// <returns>The <see cref=""ConsoleModifiers""/> or zero.</returns>
	|        public static ConsoleModifiers GetConsoleModifiers(string value)
	|        {
	|            switch (value)
	|            {
	|                case ""2"":
	|                    return ConsoleModifiers.Shift;
	|                case ""3"":
	|                    return ConsoleModifiers.Alt;
	|                case ""4"":
	|                    return ConsoleModifiers.Shift | ConsoleModifiers.Alt;
	|                case ""5"":
	|                    return ConsoleModifiers.Control;
	|                case ""6"":
	|                    return ConsoleModifiers.Shift | ConsoleModifiers.Control;
	|                case ""7"":
	|                    return ConsoleModifiers.Alt | ConsoleModifiers.Control;
	|                case ""8"":
	|                    return ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control;
	|                default:
	|                    return 0;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the <see cref=""ConsoleKey""/> depending on terminating and value.
	|        /// </summary>
	|        /// <param name=""terminating"">The terminating.</param>
	|        /// <param name=""value"">The value.</param>
	|        /// <param name=""mod"">The <see cref=""ConsoleModifiers""/> which may changes.</param>
	|        /// <returns>The <see cref=""ConsoleKey""/> and probably the <see cref=""ConsoleModifiers""/>.</returns>
	|        public static ConsoleKey GetConsoleKey(char terminating, string value, ref ConsoleModifiers mod)
	|        {
	|            ConsoleKey key;
	|            switch (terminating)
	|            {
	|                case 'A':
	|                    key = ConsoleKey.UpArrow;
	|                    break;
	|                case 'B':
	|                    key = ConsoleKey.DownArrow;
	|                    break;
	|                case 'C':
	|                    key = ConsoleKey.RightArrow;
	|                    break;
	|                case 'D':
	|                    key = ConsoleKey.LeftArrow;
	|                    break;
	|                case 'F':
	|                    key = ConsoleKey.End;
	|                    break;
	|                case 'H':
	|                    key = ConsoleKey.Home;
	|                    break;
	|                case 'P':
	|                    key = ConsoleKey.F1;
	|                    break;
	|                case 'Q':
	|                    key = ConsoleKey.F2;
	|                    break;
	|                case 'R':
	|                    key = ConsoleKey.F3;
	|                    break;
	|                case 'S':
	|                    key = ConsoleKey.F4;
	|                    break;
	|                case 'Z':
	|                    key = ConsoleKey.Tab;
	|                    mod |= ConsoleModifiers.Shift;
	|                    break;
	|                case '~':
	|                    switch (value)
	|                    {
	|                        case ""2"":
	|                            key = ConsoleKey.Insert;
	|                            break;
	|                        case ""3"":
	|                            key = ConsoleKey.Delete;
	|                            break;
	|                        case ""5"":
	|                            key = ConsoleKey.PageUp;
	|                            break;
	|                        case ""6"":
	|                            key = ConsoleKey.PageDown;
	|                            break;
	|                        case ""15"":
	|                            key = ConsoleKey.F5;
	|                            break;
	|                        case ""17"":
	|                            key = ConsoleKey.F6;
	|                            break;
	|                        case ""18"":
	|                            key = ConsoleKey.F7;
	|                            break;
	|                        case ""19"":
	|                            key = ConsoleKey.F8;
	|                            break;
	|                        case ""20"":
	|                            key = ConsoleKey.F9;
	|                            break;
	|                        case ""21"":
	|                            key = ConsoleKey.F10;
	|                            break;
	|                        case ""23"":
	|                            key = ConsoleKey.F11;
	|                            break;
	|                        case ""24"":
	|                            key = ConsoleKey.F12;
	|                            break;
	|                        default:
	|                            key = 0;
	|                            break;
	|                    }
	|                    break;
	|                default:
	|                    key = 0;
	|                    break;
	|            }
	|
	|            return key;
	|        }
	|
	|        /// <summary>
	|        /// A helper to get only the <see cref=""ConsoleKeyInfo.KeyChar""/> from the <see cref=""ConsoleKeyInfo""/> array.
	|        /// </summary>
	|        /// <param name=""cki""></param>
	|        /// <returns>The char array of the escape sequence.</returns>
	|        public static char[] GetKeyCharArray(ConsoleKeyInfo[] cki)
	|        {
	|            if (cki == null)
	|            {
	|                return null;
	|            }
	|            char[] kChar = new char[] { };
	|            var length = 0;
	|            foreach (var kc in cki)
	|            {
	|                length++;
	|                Array.Resize(ref kChar, length);
	|                kChar[length - 1] = kc.KeyChar;
	|            }
	|
	|            return kChar;
	|        }
	|
	|        private static MouseFlags? lastMouseButtonPressed;
	|        //private static MouseFlags? lastMouseButtonReleased;
	|        private static bool isButtonPressed;
	|        //private static bool isButtonReleased;
	|        private static bool isButtonClicked;
	|        private static bool isButtonDoubleClicked;
	|        private static bool isButtonTripleClicked;
	|        private static Point point;
	|
	|        /// <summary>
	|        /// Gets the <see cref=""MouseFlags""/> mouse button flags and the position.
	|        /// </summary>
	|        /// <param name=""cki"">The <see cref=""ConsoleKeyInfo""/> array.</param>
	|        /// <param name=""mouseFlags"">The mouse button flags.</param>
	|        /// <param name=""pos"">The mouse position.</param>
	|        /// <param name=""continuousButtonPressedHandler"">The handler that will process the event.</param>
	|        public static void GetMouse(ConsoleKeyInfo[] cki, out List<MouseFlags> mouseFlags, out Point pos, Action<MouseFlags, Point> continuousButtonPressedHandler)
	|        {
	|            MouseFlags buttonState = 0;
	|            pos = new Point();
	|            int buttonCode = 0;
	|            bool foundButtonCode = false;
	|            int foundPoint = 0;
	|            string value = """";
	|            var kChar = GetKeyCharArray(cki);
	|            //System.Diagnostics.Debug.WriteLine ($""kChar: {new string (kChar)}"");
	|            for (int i = 0; i < kChar.Length; i++)
	|            {
	|                var c = kChar[i];
	|                if (c == '<')
	|                {
	|                    foundButtonCode = true;
	|                }
	|                else if (foundButtonCode && c != ';')
	|                {
	|                    value += c.ToString();
	|                }
	|                else if (c == ';')
	|                {
	|                    if (foundButtonCode)
	|                    {
	|                        foundButtonCode = false;
	|                        buttonCode = int.Parse(value);
	|                    }
	|                    if (foundPoint == 1)
	|                    {
	|                        pos.X = int.Parse(value) - 1;
	|                    }
	|                    value = """";
	|                    foundPoint++;
	|                }
	|                else if (foundPoint > 0 && c != 'm' && c != 'M')
	|                {
	|                    value += c.ToString();
	|                }
	|                else if (c == 'm' || c == 'M')
	|                {
	|                    //pos.Y = int.Parse (value) + Console.WindowTop - 1;
	|                    pos.Y = int.Parse(value) - 1;
	|
	|                    switch (buttonCode)
	|                    {
	|                        case 0:
	|                        case 8:
	|                        case 16:
	|                        case 24:
	|                        case 32:
	|                        case 36:
	|                        case 40:
	|                        case 48:
	|                        case 56:
	|                            buttonState = c == 'M' ? MouseFlags.Button1Pressed
	|                                : MouseFlags.Button1Released;
	|                            break;
	|                        case 1:
	|                        case 9:
	|                        case 17:
	|                        case 25:
	|                        case 33:
	|                        case 37:
	|                        case 41:
	|                        case 45:
	|                        case 49:
	|                        case 53:
	|                        case 57:
	|                        case 61:
	|                            buttonState = c == 'M' ? MouseFlags.Button2Pressed
	|                                : MouseFlags.Button2Released;
	|                            break;
	|                        case 2:
	|                        case 10:
	|                        case 14:
	|                        case 18:
	|                        case 22:
	|                        case 26:
	|                        case 30:
	|                        case 34:
	|                        case 42:
	|                        case 46:
	|                        case 50:
	|                        case 54:
	|                        case 58:
	|                        case 62:
	|                            buttonState = c == 'M' ? MouseFlags.Button3Pressed
	|                                : MouseFlags.Button3Released;
	|                            break;
	|                        case 35:
	|                        //// Needed for Windows OS
	|                        //if (isButtonPressed && c == 'm'
	|                        //	&& (lastMouseEvent.ButtonState == MouseFlags.Button1Pressed
	|                        //	|| lastMouseEvent.ButtonState == MouseFlags.Button2Pressed
	|                        //	|| lastMouseEvent.ButtonState == MouseFlags.Button3Pressed)) {
	|
	|                        //	switch (lastMouseEvent.ButtonState) {
	|                        //	case MouseFlags.Button1Pressed:
	|                        //		buttonState = MouseFlags.Button1Released;
	|                        //		break;
	|                        //	case MouseFlags.Button2Pressed:
	|                        //		buttonState = MouseFlags.Button2Released;
	|                        //		break;
	|                        //	case MouseFlags.Button3Pressed:
	|                        //		buttonState = MouseFlags.Button3Released;
	|                        //		break;
	|                        //	}
	|                        //} else {
	|                        //	buttonState = MouseFlags.ReportMousePosition;
	|                        //}
	|                        //break;
	|                        case 39:
	|                        case 43:
	|                        case 47:
	|                        case 51:
	|                        case 55:
	|                        case 59:
	|                        case 63:
	|                            buttonState = MouseFlags.ReportMousePosition;
	|                            break;
	|                        case 64:
	|                            buttonState = MouseFlags.WheeledUp;
	|                            break;
	|                        case 65:
	|                            buttonState = MouseFlags.WheeledDown;
	|                            break;
	|                        case 68:
	|                        case 72:
	|                        case 80:
	|                            buttonState = MouseFlags.WheeledLeft;       // Shift/Ctrl+WheeledUp
	|                            break;
	|                        case 69:
	|                        case 73:
	|                        case 81:
	|                            buttonState = MouseFlags.WheeledRight;      // Shift/Ctrl+WheeledDown
	|                            break;
	|                    }
	|                    // Modifiers.
	|                    switch (buttonCode)
	|                    {
	|                        case 8:
	|                        case 9:
	|                        case 10:
	|                        case 43:
	|                            buttonState |= MouseFlags.ButtonAlt;
	|                            break;
	|                        case 14:
	|                        case 47:
	|                            buttonState |= MouseFlags.ButtonAlt | MouseFlags.ButtonShift;
	|                            break;
	|                        case 16:
	|                        case 17:
	|                        case 18:
	|                        case 51:
	|                            buttonState |= MouseFlags.ButtonCtrl;
	|                            break;
	|                        case 22:
	|                        case 55:
	|                            buttonState |= MouseFlags.ButtonCtrl | MouseFlags.ButtonShift;
	|                            break;
	|                        case 24:
	|                        case 25:
	|                        case 26:
	|                        case 59:
	|                            buttonState |= MouseFlags.ButtonCtrl | MouseFlags.ButtonAlt;
	|                            break;
	|                        case 30:
	|                        case 63:
	|                            buttonState |= MouseFlags.ButtonCtrl | MouseFlags.ButtonShift | MouseFlags.ButtonAlt;
	|                            break;
	|                        case 32:
	|                        case 33:
	|                        case 34:
	|                            buttonState |= MouseFlags.ReportMousePosition;
	|                            break;
	|                        case 36:
	|                        case 37:
	|                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonShift;
	|                            break;
	|                        case 39:
	|                        case 68:
	|                        case 69:
	|                            buttonState |= MouseFlags.ButtonShift;
	|                            break;
	|                        case 40:
	|                        case 41:
	|                        case 42:
	|                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonAlt;
	|                            break;
	|                        case 45:
	|                        case 46:
	|                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonAlt | MouseFlags.ButtonShift;
	|                            break;
	|                        case 48:
	|                        case 49:
	|                        case 50:
	|                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl;
	|                            break;
	|                        case 53:
	|                        case 54:
	|                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl | MouseFlags.ButtonShift;
	|                            break;
	|                        case 56:
	|                        case 57:
	|                        case 58:
	|                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl | MouseFlags.ButtonAlt;
	|                            break;
	|                        case 61:
	|                        case 62:
	|                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl | MouseFlags.ButtonShift | MouseFlags.ButtonAlt;
	|                            break;
	|                    }
	|                }
	|            }
	|
	|            mouseFlags = new List<MouseFlags>() { MouseFlags.AllEvents };
	|
	|            if (lastMouseButtonPressed != null && !isButtonPressed && !buttonState.HasFlag(MouseFlags.ReportMousePosition)
	|                && !buttonState.HasFlag(MouseFlags.Button1Released)
	|                && !buttonState.HasFlag(MouseFlags.Button2Released)
	|                && !buttonState.HasFlag(MouseFlags.Button3Released)
	|                && !buttonState.HasFlag(MouseFlags.Button4Released))
	|            {
	|
	|                lastMouseButtonPressed = null;
	|                isButtonPressed = false;
	|            }
	|
	|            if (!isButtonClicked && !isButtonDoubleClicked && ((buttonState == MouseFlags.Button1Pressed || buttonState == MouseFlags.Button2Pressed ||
	|                  buttonState == MouseFlags.Button3Pressed || buttonState == MouseFlags.Button4Pressed) && lastMouseButtonPressed == null) ||
	|                  isButtonPressed && lastMouseButtonPressed != null && buttonState.HasFlag(MouseFlags.ReportMousePosition))
	|            {
	|
	|                mouseFlags[0] = buttonState;
	|                lastMouseButtonPressed = buttonState;
	|                isButtonPressed = true;
	|
	|                if ((mouseFlags[0] & MouseFlags.ReportMousePosition) == 0)
	|                {
	|                    point = new Point()
	|                    {
	|                        X = pos.X,
	|                        Y = pos.Y
	|                    };
	|
	|                    Application.MainLoop.AddIdle(() =>
	|                    {
	|                        Task.Run(async () => await ProcessContinuousButtonPressedAsync(buttonState, continuousButtonPressedHandler));
	|                        return false;
	|                    });
	|                }
	|                else if (mouseFlags[0] == MouseFlags.ReportMousePosition)
	|                {
	|                    isButtonPressed = false;
	|                }
	|
	|            }
	|            else if (isButtonDoubleClicked && (buttonState == MouseFlags.Button1Pressed || buttonState == MouseFlags.Button2Pressed ||
	|              buttonState == MouseFlags.Button3Pressed || buttonState == MouseFlags.Button4Pressed))
	|            {
	|
	|                mouseFlags[0] = GetButtonTripleClicked(buttonState);
	|                isButtonDoubleClicked = false;
	|                isButtonTripleClicked = true;
	|
	|            }
	|            else if (isButtonClicked && (buttonState == MouseFlags.Button1Pressed || buttonState == MouseFlags.Button2Pressed ||
	|              buttonState == MouseFlags.Button3Pressed || buttonState == MouseFlags.Button4Pressed))
	|            {
	|
	|                mouseFlags[0] = GetButtonDoubleClicked(buttonState);
	|                isButtonClicked = false;
	|                isButtonDoubleClicked = true;
	|                Application.MainLoop.AddIdle(() =>
	|                {
	|                    Task.Run(async () => await ProcessButtonDoubleClickedAsync());
	|                    return false;
	|                });
	|
	|            }
	|            //else if (isButtonReleased && !isButtonClicked && buttonState == MouseFlags.ReportMousePosition) {
	|            //	mouseFlag [0] = GetButtonClicked ((MouseFlags)lastMouseButtonReleased);
	|            //	lastMouseButtonReleased = null;
	|            //	isButtonReleased = false;
	|            //	isButtonClicked = true;
	|            //	Application.MainLoop.AddIdle (() => {
	|            //		Task.Run (async () => await ProcessButtonClickedAsync ());
	|            //		return false;
	|            //	});
	|
	|            //} 
	|            else if (!isButtonClicked && !isButtonDoubleClicked && (buttonState == MouseFlags.Button1Released || buttonState == MouseFlags.Button2Released ||
	|                  buttonState == MouseFlags.Button3Released || buttonState == MouseFlags.Button4Released))
	|            {
	|
	|                mouseFlags[0] = buttonState;
	|                isButtonPressed = false;
	|
	|                if (isButtonTripleClicked)
	|                {
	|                    isButtonTripleClicked = false;
	|                }
	|                else if (pos.X == point.X && pos.Y == point.Y)
	|                {
	|                    mouseFlags.Add(GetButtonClicked(buttonState));
	|                    isButtonClicked = true;
	|                    Application.MainLoop.AddIdle(() =>
	|                    {
	|                        Task.Run(async () => await ProcessButtonClickedAsync());
	|                        return false;
	|                    });
	|                }
	|
	|                point = pos;
	|
	|                //if ((lastMouseButtonPressed & MouseFlags.ReportMousePosition) == 0) {
	|                //	lastMouseButtonReleased = buttonState;
	|                //	isButtonPressed = false;
	|                //	isButtonReleased = true;
	|                //} else {
	|                //	lastMouseButtonPressed = null;
	|                //	isButtonPressed = false;
	|                //}
	|
	|            }
	|            else if (buttonState == MouseFlags.WheeledUp)
	|            {
	|
	|                mouseFlags[0] = MouseFlags.WheeledUp;
	|
	|            }
	|            else if (buttonState == MouseFlags.WheeledDown)
	|            {
	|
	|                mouseFlags[0] = MouseFlags.WheeledDown;
	|
	|            }
	|            else if (buttonState == MouseFlags.WheeledLeft)
	|            {
	|
	|                mouseFlags[0] = MouseFlags.WheeledLeft;
	|
	|            }
	|            else if (buttonState == MouseFlags.WheeledRight)
	|            {
	|
	|                mouseFlags[0] = MouseFlags.WheeledRight;
	|
	|            }
	|            else if (buttonState == MouseFlags.ReportMousePosition)
	|            {
	|                mouseFlags[0] = MouseFlags.ReportMousePosition;
	|
	|            }
	|            else
	|            {
	|                mouseFlags[0] = buttonState;
	|                //foreach (var flag in buttonState.GetUniqueFlags()) {
	|                //	mouseFlag [0] |= flag;
	|                //}
	|            }
	|
	|            mouseFlags[0] = SetControlKeyStates(buttonState, mouseFlags[0]);
	|            //buttonState = mouseFlags;
	|
	|            //System.Diagnostics.Debug.WriteLine ($""buttonState: {buttonState} X: {pos.X} Y: {pos.Y}"");
	|            //foreach (var mf in mouseFlags) {
	|            //	System.Diagnostics.Debug.WriteLine ($""mouseFlags: {mf} X: {pos.X} Y: {pos.Y}"");
	|            //}
	|        }
	|
	|        private static async Task ProcessContinuousButtonPressedAsync(MouseFlags mouseFlag, Action<MouseFlags, Point> continuousButtonPressedHandler)
	|        {
	|            while (isButtonPressed)
	|            {
	|                await Task.Delay(100);
	|                //var me = new MouseEvent () {
	|                //	X = point.X,
	|                //	Y = point.Y,
	|                //	Flags = mouseFlag
	|                //};
	|
	|                var view = Application.WantContinuousButtonPressedView;
	|                if (view == null)
	|                    break;
	|                if (isButtonPressed && lastMouseButtonPressed != null && (mouseFlag & MouseFlags.ReportMousePosition) == 0)
	|                {
	|                    Application.MainLoop.Invoke(() => continuousButtonPressedHandler(mouseFlag, point));
	|                }
	|            }
	|        }
	|
	|        private static async Task ProcessButtonClickedAsync()
	|        {
	|            await Task.Delay(300);
	|            isButtonClicked = false;
	|        }
	|
	|        private static async Task ProcessButtonDoubleClickedAsync()
	|        {
	|            await Task.Delay(300);
	|            isButtonDoubleClicked = false;
	|        }
	|
	|        private static MouseFlags GetButtonClicked(MouseFlags mouseFlag)
	|        {
	|            MouseFlags mf = default;
	|            switch (mouseFlag)
	|            {
	|                case MouseFlags.Button1Released:
	|                    mf = MouseFlags.Button1Clicked;
	|                    break;
	|
	|                case MouseFlags.Button2Released:
	|                    mf = MouseFlags.Button2Clicked;
	|                    break;
	|
	|                case MouseFlags.Button3Released:
	|                    mf = MouseFlags.Button3Clicked;
	|                    break;
	|            }
	|            return mf;
	|        }
	|
	|        private static MouseFlags GetButtonDoubleClicked(MouseFlags mouseFlag)
	|        {
	|            MouseFlags mf = default;
	|            switch (mouseFlag)
	|            {
	|                case MouseFlags.Button1Pressed:
	|                    mf = MouseFlags.Button1DoubleClicked;
	|                    break;
	|
	|                case MouseFlags.Button2Pressed:
	|                    mf = MouseFlags.Button2DoubleClicked;
	|                    break;
	|
	|                case MouseFlags.Button3Pressed:
	|                    mf = MouseFlags.Button3DoubleClicked;
	|                    break;
	|            }
	|            return mf;
	|        }
	|
	|        private static MouseFlags GetButtonTripleClicked(MouseFlags mouseFlag)
	|        {
	|            MouseFlags mf = default;
	|            switch (mouseFlag)
	|            {
	|                case MouseFlags.Button1Pressed:
	|                    mf = MouseFlags.Button1TripleClicked;
	|                    break;
	|
	|                case MouseFlags.Button2Pressed:
	|                    mf = MouseFlags.Button2TripleClicked;
	|                    break;
	|
	|                case MouseFlags.Button3Pressed:
	|                    mf = MouseFlags.Button3TripleClicked;
	|                    break;
	|            }
	|            return mf;
	|        }
	|
	|        private static MouseFlags SetControlKeyStates(MouseFlags buttonState, MouseFlags mouseFlag)
	|        {
	|            if ((buttonState & MouseFlags.ButtonCtrl) != 0 && (mouseFlag & MouseFlags.ButtonCtrl) == 0)
	|                mouseFlag |= MouseFlags.ButtonCtrl;
	|
	|            if ((buttonState & MouseFlags.ButtonShift) != 0 && (mouseFlag & MouseFlags.ButtonShift) == 0)
	|                mouseFlag |= MouseFlags.ButtonShift;
	|
	|            if ((buttonState & MouseFlags.ButtonAlt) != 0 && (mouseFlag & MouseFlags.ButtonAlt) == 0)
	|                mouseFlag |= MouseFlags.ButtonAlt;
	|            return mouseFlag;
	|        }
	|
	|        /// <summary>
	|        /// Get the terminal that holds the console driver.
	|        /// </summary>
	|        /// <param name=""process"">The process.</param>
	|        /// <returns>If supported the executable console process, null otherwise.</returns>
	|        public static Process GetParentProcess(Process process)
	|        {
	|            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
	|            {
	|                return null;
	|            }
	|
	|            string query = ""SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = "" + process.Id;
	|            using (ManagementObjectSearcher mos = new ManagementObjectSearcher(query))
	|            {
	|                foreach (ManagementObject mo in mos.Get())
	|                {
	|                    if (mo[""ParentProcessId""] != null)
	|                    {
	|                        try
	|                        {
	|                            var id = Convert.ToInt32(mo[""ParentProcessId""]);
	|                            return Process.GetProcessById(id);
	|                        }
	|                        catch
	|                        {
	|                        }
	|                    }
	|                }
	|            }
	|            return null;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // Evemts.cs: Events, Key mappings
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    /// Identifies the state of the ""shift""-keys within a event.
	|    /// </summary>
	|    public class KeyModifiers
	|    {
	|        /// <summary>
	|        /// Check if the Shift key was pressed or not.
	|        /// </summary>
	|        public bool Shift;
	|        /// <summary>
	|        /// Check if the Alt key was pressed or not.
	|        /// </summary>
	|        public bool Alt;
	|        /// <summary>
	|        /// Check if the Ctrl key was pressed or not.
	|        /// </summary>
	|        public bool Ctrl;
	|        /// <summary>
	|        /// Check if the Caps lock key was pressed or not.
	|        /// </summary>
	|        public bool Capslock;
	|        /// <summary>
	|        /// Check if the Num lock key was pressed or not.
	|        /// </summary>
	|        public bool Numlock;
	|        /// <summary>
	|        /// Check if the Scroll lock key was pressed or not.
	|        /// </summary>
	|        public bool Scrolllock;
	|    }
	|
	|    /// <summary>
	|    /// The <see cref=""Key""/> enumeration contains special encoding for some keys, but can also
	|    /// encode all the unicode values that can be passed.   
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   If the <see cref=""SpecialMask""/> is set, then the value is that of the special mask,
	|    ///   otherwise, the value is the one of the lower bits (as extracted by <see cref=""CharMask""/>)
	|    /// <para>
	|    ///   Numerics keys are the values between 48 and 57 corresponding to 0 to 9
	|    /// </para>
	|    /// </para>
	|    /// <para>
	|    ///   Upper alpha keys are the values between 65 and 90 corresponding to A to Z
	|    /// </para>
	|    /// <para>
	|    ///   Unicode runes are also stored here, the letter 'A"" for example is encoded as a value 65 (not surfaced in the enum).
	|    /// </para>
	|    /// </remarks>
	|    [Flags]
	|    public enum Key : uint
	|    {
	|        /// <summary>
	|        /// Mask that indicates that this is a character value, values outside this range
	|        /// indicate special characters like Alt-key combinations or special keys on the
	|        /// keyboard like function keys, arrows keys and so on.
	|        /// </summary>
	|        CharMask = 0xfffff,
	|
	|        /// <summary>
	|        /// If the <see cref=""SpecialMask""/> is set, then the value is that of the special mask,
	|        /// otherwise, the value is the one of the lower bits (as extracted by <see cref=""CharMask""/>).
	|        /// </summary>
	|        SpecialMask = 0xfff00000,
	|
	|        /// <summary>
	|        /// The key code representing null or empty
	|        /// </summary>
	|        Null = '\0',
	|
	|        /// <summary>
	|        /// Backspace key.
	|        /// </summary>
	|        Backspace = 8,
	|
	|        /// <summary>
	|        /// The key code for the user pressing the tab key (forwards tab key).
	|        /// </summary>
	|        Tab = 9,
	|
	|        /// <summary>
	|        /// The key code for the user pressing the return key.
	|        /// </summary>
	|        Enter = '\n',
	|
	|        /// <summary>
	|        /// The key code for the user pressing the clear key.
	|        /// </summary>
	|        Clear = 12,
	|
	|        /// <summary>
	|        /// The key code for the user pressing the escape key
	|        /// </summary>
	|        Esc = 27,
	|
	|        /// <summary>
	|        /// The key code for the user pressing the space bar
	|        /// </summary>
	|        Space = 32,
	|
	|        /// <summary>
	|        /// Digit 0.
	|        /// </summary>
	|        D0 = 48,
	|        /// <summary>
	|        /// Digit 1.
	|        /// </summary>
	|        D1,
	|        /// <summary>
	|        /// Digit 2.
	|        /// </summary>
	|        D2,
	|        /// <summary>
	|        /// Digit 3.
	|        /// </summary>
	|        D3,
	|        /// <summary>
	|        /// Digit 4.
	|        /// </summary>
	|        D4,
	|        /// <summary>
	|        /// Digit 5.
	|        /// </summary>
	|        D5,
	|        /// <summary>
	|        /// Digit 6.
	|        /// </summary>
	|        D6,
	|        /// <summary>
	|        /// Digit 7.
	|        /// </summary>
	|        D7,
	|        /// <summary>
	|        /// Digit 8.
	|        /// </summary>
	|        D8,
	|        /// <summary>
	|        /// Digit 9.
	|        /// </summary>
	|        D9,
	|
	|        /// <summary>
	|        /// The key code for the user pressing Shift-A
	|        /// </summary>
	|        A = 65,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-B
	|        /// </summary>
	|        B,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-C
	|        /// </summary>
	|        C,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-D
	|        /// </summary>
	|        D,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-E
	|        /// </summary>
	|        E,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-F
	|        /// </summary>
	|        F,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-G
	|        /// </summary>
	|        G,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-H
	|        /// </summary>
	|        H,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-I
	|        /// </summary>
	|        I,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-J
	|        /// </summary>
	|        J,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-K
	|        /// </summary>
	|        K,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-L
	|        /// </summary>
	|        L,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-M
	|        /// </summary>
	|        M,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-N
	|        /// </summary>
	|        N,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-O
	|        /// </summary>
	|        O,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-P
	|        /// </summary>
	|        P,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-Q
	|        /// </summary>
	|        Q,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-R
	|        /// </summary>
	|        R,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-S
	|        /// </summary>
	|        S,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-T
	|        /// </summary>
	|        T,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-U
	|        /// </summary>
	|        U,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-V
	|        /// </summary>
	|        V,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-W
	|        /// </summary>
	|        W,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-X
	|        /// </summary>
	|        X,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-Y
	|        /// </summary>
	|        Y,
	|        /// <summary>
	|        /// The key code for the user pressing Shift-Z
	|        /// </summary>
	|        Z,
	|        /// <summary>
	|        /// The key code for the user pressing A
	|        /// </summary>
	|        a = 97,
	|        /// <summary>
	|        /// The key code for the user pressing B
	|        /// </summary>
	|        b,
	|        /// <summary>
	|        /// The key code for the user pressing C
	|        /// </summary>
	|        c,
	|        /// <summary>
	|        /// The key code for the user pressing D
	|        /// </summary>
	|        d,
	|        /// <summary>
	|        /// The key code for the user pressing E
	|        /// </summary>
	|        e,
	|        /// <summary>
	|        /// The key code for the user pressing F
	|        /// </summary>
	|        f,
	|        /// <summary>
	|        /// The key code for the user pressing G
	|        /// </summary>
	|        g,
	|        /// <summary>
	|        /// The key code for the user pressing H
	|        /// </summary>
	|        h,
	|        /// <summary>
	|        /// The key code for the user pressing I
	|        /// </summary>
	|        i,
	|        /// <summary>
	|        /// The key code for the user pressing J
	|        /// </summary>
	|        j,
	|        /// <summary>
	|        /// The key code for the user pressing K
	|        /// </summary>
	|        k,
	|        /// <summary>
	|        /// The key code for the user pressing L
	|        /// </summary>
	|        l,
	|        /// <summary>
	|        /// The key code for the user pressing M
	|        /// </summary>
	|        m,
	|        /// <summary>
	|        /// The key code for the user pressing N
	|        /// </summary>
	|        n,
	|        /// <summary>
	|        /// The key code for the user pressing O
	|        /// </summary>
	|        o,
	|        /// <summary>
	|        /// The key code for the user pressing P
	|        /// </summary>
	|        p,
	|        /// <summary>
	|        /// The key code for the user pressing Q
	|        /// </summary>
	|        q,
	|        /// <summary>
	|        /// The key code for the user pressing R
	|        /// </summary>
	|        r,
	|        /// <summary>
	|        /// The key code for the user pressing S
	|        /// </summary>
	|        s,
	|        /// <summary>
	|        /// The key code for the user pressing T
	|        /// </summary>
	|        t,
	|        /// <summary>
	|        /// The key code for the user pressing U
	|        /// </summary>
	|        u,
	|        /// <summary>
	|        /// The key code for the user pressing V
	|        /// </summary>
	|        v,
	|        /// <summary>
	|        /// The key code for the user pressing W
	|        /// </summary>
	|        w,
	|        /// <summary>
	|        /// The key code for the user pressing X
	|        /// </summary>
	|        x,
	|        /// <summary>
	|        /// The key code for the user pressing Y
	|        /// </summary>
	|        y,
	|        /// <summary>
	|        /// The key code for the user pressing Z
	|        /// </summary>
	|        z,
	|        /// <summary>
	|        /// The key code for the user pressing the delete key.
	|        /// </summary>
	|        Delete = 127,
	|
	|        /// <summary>
	|        /// When this value is set, the Key encodes the sequence Shift-KeyValue.
	|        /// </summary>
	|        ShiftMask = 0x10000000,
	|
	|        /// <summary>
	|        ///   When this value is set, the Key encodes the sequence Alt-KeyValue.
	|        ///   And the actual value must be extracted by removing the AltMask.
	|        /// </summary>
	|        AltMask = 0x80000000,
	|
	|        /// <summary>
	|        ///   When this value is set, the Key encodes the sequence Ctrl-KeyValue.
	|        ///   And the actual value must be extracted by removing the CtrlMask.
	|        /// </summary>
	|        CtrlMask = 0x40000000,
	|
	|        /// <summary>
	|        /// Cursor up key
	|        /// </summary>
	|        CursorUp = 0x100000,
	|        /// <summary>
	|        /// Cursor down key.
	|        /// </summary>
	|        CursorDown,
	|        /// <summary>
	|        /// Cursor left key.
	|        /// </summary>
	|        CursorLeft,
	|        /// <summary>
	|        /// Cursor right key.
	|        /// </summary>
	|        CursorRight,
	|        /// <summary>
	|        /// Page Up key.
	|        /// </summary>
	|        PageUp,
	|        /// <summary>
	|        /// Page Down key.
	|        /// </summary>
	|        PageDown,
	|        /// <summary>
	|        /// Home key.
	|        /// </summary>
	|        Home,
	|        /// <summary>
	|        /// End key.
	|        /// </summary>
	|        End,
	|
	|        /// <summary>
	|        /// Insert character key.
	|        /// </summary>
	|        InsertChar,
	|
	|        /// <summary>
	|        /// Delete character key.
	|        /// </summary>
	|        DeleteChar,
	|
	|        /// <summary>
	|        /// Shift-tab key (backwards tab key).
	|        /// </summary>
	|        BackTab,
	|
	|        /// <summary>
	|        /// Print screen character key.
	|        /// </summary>
	|        PrintScreen,
	|
	|        /// <summary>
	|        /// F1 key.
	|        /// </summary>
	|        F1,
	|        /// <summary>
	|        /// F2 key.
	|        /// </summary>
	|        F2,
	|        /// <summary>
	|        /// F3 key.
	|        /// </summary>
	|        F3,
	|        /// <summary>
	|        /// F4 key.
	|        /// </summary>
	|        F4,
	|        /// <summary>
	|        /// F5 key.
	|        /// </summary>
	|        F5,
	|        /// <summary>
	|        /// F6 key.
	|        /// </summary>
	|        F6,
	|        /// <summary>
	|        /// F7 key.
	|        /// </summary>
	|        F7,
	|        /// <summary>
	|        /// F8 key.
	|        /// </summary>
	|        F8,
	|        /// <summary>
	|        /// F9 key.
	|        /// </summary>
	|        F9,
	|        /// <summary>
	|        /// F10 key.
	|        /// </summary>
	|        F10,
	|        /// <summary>
	|        /// F11 key.
	|        /// </summary>
	|        F11,
	|        /// <summary>
	|        /// F12 key.
	|        /// </summary>
	|        F12,
	|        /// <summary>
	|        /// F13 key.
	|        /// </summary>
	|        F13,
	|        /// <summary>
	|        /// F14 key.
	|        /// </summary>
	|        F14,
	|        /// <summary>
	|        /// F15 key.
	|        /// </summary>
	|        F15,
	|        /// <summary>
	|        /// F16 key.
	|        /// </summary>
	|        F16,
	|        /// <summary>
	|        /// F17 key.
	|        /// </summary>
	|        F17,
	|        /// <summary>
	|        /// F18 key.
	|        /// </summary>
	|        F18,
	|        /// <summary>
	|        /// F19 key.
	|        /// </summary>
	|        F19,
	|        /// <summary>
	|        /// F20 key.
	|        /// </summary>
	|        F20,
	|        /// <summary>
	|        /// F21 key.
	|        /// </summary>
	|        F21,
	|        /// <summary>
	|        /// F22 key.
	|        /// </summary>
	|        F22,
	|        /// <summary>
	|        /// F23 key.
	|        /// </summary>
	|        F23,
	|        /// <summary>
	|        /// F24 key.
	|        /// </summary>
	|        F24,
	|
	|        /// <summary>
	|        /// A key with an unknown mapping was raised.
	|        /// </summary>
	|        Unknown
	|    }
	|
	|    /// <summary>
	|    /// Describes a keyboard event.
	|    /// </summary>
	|    public class KeyEvent
	|    {
	|        KeyModifiers keyModifiers;
	|
	|        /// <summary>
	|        /// Symbolic definition for the key.
	|        /// </summary>
	|        public Key Key;
	|
	|        /// <summary>
	|        ///   The key value cast to an integer, you will typical use this for
	|        ///   extracting the Unicode rune value out of a key, when none of the
	|        ///   symbolic options are in use.
	|        /// </summary>
	|        public int KeyValue => (int)Key;
	|
	|        /// <summary>
	|        /// Gets a value indicating whether the Shift key was pressed.
	|        /// </summary>
	|        /// <value><c>true</c> if is shift; otherwise, <c>false</c>.</value>
	|        public bool IsShift => keyModifiers.Shift || Key == Key.BackTab;
	|
	|        /// <summary>
	|        /// Gets a value indicating whether the Alt key was pressed (real or synthesized)
	|        /// </summary>
	|        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
	|        public bool IsAlt => keyModifiers.Alt;
	|
	|        /// <summary>
	|        /// Determines whether the value is a control key (and NOT just the ctrl key)
	|        /// </summary>
	|        /// <value><c>true</c> if is ctrl; otherwise, <c>false</c>.</value>
	|        //public bool IsCtrl => ((uint)Key >= 1) && ((uint)Key <= 26);
	|        public bool IsCtrl => keyModifiers.Ctrl;
	|
	|        /// <summary>
	|        /// Gets a value indicating whether the Caps lock key was pressed (real or synthesized)
	|        /// </summary>
	|        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
	|        public bool IsCapslock => keyModifiers.Capslock;
	|
	|        /// <summary>
	|        /// Gets a value indicating whether the Num lock key was pressed (real or synthesized)
	|        /// </summary>
	|        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
	|        public bool IsNumlock => keyModifiers.Numlock;
	|
	|        /// <summary>
	|        /// Gets a value indicating whether the Scroll lock key was pressed (real or synthesized)
	|        /// </summary>
	|        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
	|        public bool IsScrolllock => keyModifiers.Scrolllock;
	|
	|        /// <summary>
	|        /// Constructs a new <see cref=""KeyEvent""/>
	|        /// </summary>
	|        public KeyEvent()
	|        {
	|            Key = Key.Unknown;
	|            keyModifiers = new KeyModifiers();
	|        }
	|
	|        /// <summary>
	|        ///   Constructs a new <see cref=""KeyEvent""/> from the provided Key value - can be a rune cast into a Key value
	|        /// </summary>
	|        public KeyEvent(Key k, KeyModifiers km)
	|        {
	|            Key = k;
	|            keyModifiers = km;
	|        }
	|
	|        /// <summary>
	|        /// Pretty prints the KeyEvent
	|        /// </summary>
	|        /// <returns></returns>
	|        public override string ToString()
	|        {
	|            string msg = """";
	|            var key = this.Key;
	|            if (keyModifiers.Shift)
	|            {
	|                msg += ""Shift-"";
	|            }
	|            if (keyModifiers.Alt)
	|            {
	|                msg += ""Alt-"";
	|            }
	|            if (keyModifiers.Ctrl)
	|            {
	|                msg += ""Ctrl-"";
	|            }
	|            if (keyModifiers.Capslock)
	|            {
	|                msg += ""Capslock-"";
	|            }
	|            if (keyModifiers.Numlock)
	|            {
	|                msg += ""Numlock-"";
	|            }
	|            if (keyModifiers.Scrolllock)
	|            {
	|                msg += ""Scrolllock-"";
	|            }
	|
	|            msg += $""{((Key)KeyValue != Key.Unknown && ((uint)this.KeyValue & (uint)Key.CharMask) > 27 ? $""{(char)this.KeyValue}"" : $""{key}"")}"";
	|
	|            return msg;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Mouse flags reported in <see cref=""MouseEvent""/>.
	|    /// </summary>
	|    /// <remarks>
	|    /// They just happen to map to the ncurses ones.
	|    /// </remarks>
	|    [Flags]
	|    public enum MouseFlags
	|    {
	|        /// <summary>
	|        /// The first mouse button was pressed.
	|        /// </summary>
	|        Button1Pressed = unchecked((int)0x2),
	|        /// <summary>
	|        /// The first mouse button was released.
	|        /// </summary>
	|        Button1Released = unchecked((int)0x1),
	|        /// <summary>
	|        /// The first mouse button was clicked (press+release).
	|        /// </summary>
	|        Button1Clicked = unchecked((int)0x4),
	|        /// <summary>
	|        /// The first mouse button was double-clicked.
	|        /// </summary>
	|        Button1DoubleClicked = unchecked((int)0x8),
	|        /// <summary>
	|        /// The first mouse button was triple-clicked.
	|        /// </summary>
	|        Button1TripleClicked = unchecked((int)0x10),
	|        /// <summary>
	|        /// The second mouse button was pressed.
	|        /// </summary>
	|        Button2Pressed = unchecked((int)0x80),
	|        /// <summary>
	|        /// The second mouse button was released.
	|        /// </summary>
	|        Button2Released = unchecked((int)0x40),
	|        /// <summary>
	|        /// The second mouse button was clicked (press+release).
	|        /// </summary>
	|        Button2Clicked = unchecked((int)0x100),
	|        /// <summary>
	|        /// The second mouse button was double-clicked.
	|        /// </summary>
	|        Button2DoubleClicked = unchecked((int)0x200),
	|        /// <summary>
	|        /// The second mouse button was triple-clicked.
	|        /// </summary>
	|        Button2TripleClicked = unchecked((int)0x400),
	|        /// <summary>
	|        /// The third mouse button was pressed.
	|        /// </summary>
	|        Button3Pressed = unchecked((int)0x2000),
	|        /// <summary>
	|        /// The third mouse button was released.
	|        /// </summary>
	|        Button3Released = unchecked((int)0x1000),
	|        /// <summary>
	|        /// The third mouse button was clicked (press+release).
	|        /// </summary>
	|        Button3Clicked = unchecked((int)0x4000),
	|        /// <summary>
	|        /// The third mouse button was double-clicked.
	|        /// </summary>
	|        Button3DoubleClicked = unchecked((int)0x8000),
	|        /// <summary>
	|        /// The third mouse button was triple-clicked.
	|        /// </summary>
	|        Button3TripleClicked = unchecked((int)0x10000),
	|        /// <summary>
	|        /// The fourth mouse button was pressed.
	|        /// </summary>
	|        Button4Pressed = unchecked((int)0x80000),
	|        /// <summary>
	|        /// The fourth mouse button was released.
	|        /// </summary>
	|        Button4Released = unchecked((int)0x40000),
	|        /// <summary>
	|        /// The fourth button was clicked (press+release).
	|        /// </summary>
	|        Button4Clicked = unchecked((int)0x100000),
	|        /// <summary>
	|        /// The fourth button was double-clicked.
	|        /// </summary>
	|        Button4DoubleClicked = unchecked((int)0x200000),
	|        /// <summary>
	|        /// The fourth button was triple-clicked.
	|        /// </summary>
	|        Button4TripleClicked = unchecked((int)0x400000),
	|        /// <summary>
	|        /// Flag: the shift key was pressed when the mouse button took place.
	|        /// </summary>
	|        ButtonShift = unchecked((int)0x2000000),
	|        /// <summary>
	|        /// Flag: the ctrl key was pressed when the mouse button took place.
	|        /// </summary>
	|        ButtonCtrl = unchecked((int)0x1000000),
	|        /// <summary>
	|        /// Flag: the alt key was pressed when the mouse button took place.
	|        /// </summary>
	|        ButtonAlt = unchecked((int)0x4000000),
	|        /// <summary>
	|        /// The mouse position is being reported in this event.
	|        /// </summary>
	|        ReportMousePosition = unchecked((int)0x8000000),
	|        /// <summary>
	|        /// Vertical button wheeled up.
	|        /// </summary>
	|        WheeledUp = unchecked((int)0x10000000),
	|        /// <summary>
	|        /// Vertical button wheeled down.
	|        /// </summary>
	|        WheeledDown = unchecked((int)0x20000000),
	|        /// <summary>
	|        /// Vertical button wheeled up while pressing ButtonCtrl.
	|        /// </summary>
	|        WheeledLeft = ButtonCtrl | WheeledUp,
	|        /// <summary>
	|        /// Vertical button wheeled down while pressing ButtonCtrl.
	|        /// </summary>
	|        WheeledRight = ButtonCtrl | WheeledDown,
	|        /// <summary>
	|        /// Mask that captures all the events.
	|        /// </summary>
	|        AllEvents = unchecked((int)0x7ffffff),
	|    }
	|
	|    /// <summary>
	|    /// Low-level construct that conveys the details of mouse events, such
	|    /// as coordinates and button state, from ConsoleDrivers up to <see cref=""Application""/> and
	|    /// Views.
	|    /// </summary>
	|    /// <remarks>The <see cref=""Application""/> class includes the <see cref=""Application.RootMouseEvent""/>
	|    /// Action which takes a MouseEvent argument.</remarks>
	|    public class MouseEvent
	|    {
	|        /// <summary>
	|        /// The X (column) location for the mouse event.
	|        /// </summary>
	|        public int X { get; set; }
	|
	|        /// <summary>
	|        /// The Y (column) location for the mouse event.
	|        /// </summary>
	|        public int Y { get; set; }
	|
	|        /// <summary>
	|        /// Flags indicating the kind of mouse event that is being posted.
	|        /// </summary>
	|        public MouseFlags Flags { get; set; }
	|
	|        /// <summary>
	|        /// The offset X (column) location for the mouse event.
	|        /// </summary>
	|        public int OfX { get; set; }
	|
	|        /// <summary>
	|        /// The offset Y (column) location for the mouse event.
	|        /// </summary>
	|        public int OfY { get; set; }
	|
	|        /// <summary>
	|        /// The current view at the location for the mouse event.
	|        /// </summary>
	|        public View View { get; set; }
	|
	|        /// <summary>
	|        /// Indicates if the current mouse event has already been processed and the driver should stop notifying any other event subscriber.
	|        /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
	|        /// </summary>
	|        public bool Handled { get; set; }
	|
	|        /// <summary>
	|        /// Returns a <see cref=""T:System.String""/> that represents the current <see cref=""MouseEvent""/>.
	|        /// </summary>
	|        /// <returns>A <see cref=""T:System.String""/> that represents the current <see cref=""MouseEvent""/>.</returns>
	|        public override string ToString()
	|        {
	|            return $""({X},{Y}:{Flags}"";
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // FakeConsole.cs: A fake .NET Windows Console API implementation for unit tests.
	|    //
	|
	|#pragma warning disable RCS1138 // Add summary to documentation comment.
	|    /// <summary>
	|    /// 
	|    /// </summary>
	|    public static class FakeConsole
	|    {
	|#pragma warning restore RCS1138 // Add summary to documentation comment.
	|
	|        //
	|        // Summary:
	|        //	Gets or sets the width of the console window.
	|        //
	|        // Returns:
	|        //	The width of the console window measured in columns.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight
	|        //	property is less than or equal to 0.-or-The value of the System.Console.WindowHeight
	|        //	property plus the value of the System.Console.WindowTop property is greater than
	|        //	or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth
	|        //	property or the value of the System.Console.WindowHeight property is greater
	|        //	than the largest possible window width or height for the current screen resolution
	|        //	and console font.
	|        //
	|        //	T:System.IO.IOException:
	|        //	Error reading or writing information.
	|#pragma warning disable RCS1138 // Add summary to documentation comment.
	|
	|        /// <summary>
	|        /// Specifies the initial console width.
	|        /// </summary>
	|        public const int WIDTH = 80;
	|
	|        /// <summary>
	|        /// Specifies the initial console height.
	|        /// </summary>
	|        public const int HEIGHT = 25;
	|
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int WindowWidth { get; set; } = WIDTH;
	|        //
	|        // Summary:
	|        //	Gets a value that indicates whether output has been redirected from the standard
	|        //	output stream.
	|        //
	|        // Returns:
	|        //	true if output is redirected; otherwise, false.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool IsOutputRedirected { get; }
	|        //
	|        // Summary:
	|        //	Gets a value that indicates whether the error output stream has been redirected
	|        //	from the standard error stream.
	|        //
	|        // Returns:
	|        //	true if error output is redirected; otherwise, false.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool IsErrorRedirected { get; }
	|        //
	|        // Summary:
	|        //	Gets the standard input stream.
	|        //
	|        // Returns:
	|        //	A System.IO.TextReader that represents the standard input stream.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static TextReader In { get; }
	|        //
	|        // Summary:
	|        //	Gets the standard output stream.
	|        //
	|        // Returns:
	|        //	A System.IO.TextWriter that represents the standard output stream.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static TextWriter Out { get; }
	|        //
	|        // Summary:
	|        //	Gets the standard error output stream.
	|        //
	|        // Returns:
	|        //	A System.IO.TextWriter that represents the standard error output stream.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static TextWriter Error { get; }
	|        //
	|        // Summary:
	|        //	Gets or sets the encoding the console uses to read input.
	|        //
	|        // Returns:
	|        //	The encoding used to read console input.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentNullException:
	|        //	The property value in a set operation is null.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An error occurred during the execution of this operation.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	Your application does not have permission to perform this operation.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Encoding InputEncoding { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets the encoding the console uses to write output.
	|        //
	|        // Returns:
	|        //	The encoding used to write console output.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentNullException:
	|        //	The property value in a set operation is null.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An error occurred during the execution of this operation.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	Your application does not have permission to perform this operation.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Encoding OutputEncoding { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets the background color of the console.
	|        //
	|        // Returns:
	|        //	A value that specifies the background color of the console; that is, the color
	|        //	that appears behind each character. The default is black.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentException:
	|        //	The color specified in a set operation is not a valid member of System.ConsoleColor.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|
	|        static ConsoleColor _defaultBackgroundColor = ConsoleColor.Black;
	|
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static ConsoleColor BackgroundColor { get; set; } = _defaultBackgroundColor;
	|
	|        //
	|        // Summary:
	|        //	Gets or sets the foreground color of the console.
	|        //
	|        // Returns:
	|        //	A System.ConsoleColor that specifies the foreground color of the console; that
	|        //	is, the color of each character that is displayed. The default is gray.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentException:
	|        //	The color specified in a set operation is not a valid member of System.ConsoleColor.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|
	|        static ConsoleColor _defaultForegroundColor = ConsoleColor.Gray;
	|
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static ConsoleColor ForegroundColor { get; set; } = _defaultForegroundColor;
	|        //
	|        // Summary:
	|        //	Gets or sets the height of the buffer area.
	|        //
	|        // Returns:
	|        //	The current height, in rows, of the buffer area.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The value in a set operation is less than or equal to zero.-or- The value in
	|        //	a set operation is greater than or equal to System.Int16.MaxValue.-or- The value
	|        //	in a set operation is less than System.Console.WindowTop + System.Console.WindowHeight.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int BufferHeight { get; set; } = HEIGHT;
	|        //
	|        // Summary:
	|        //	Gets or sets the width of the buffer area.
	|        //
	|        // Returns:
	|        //	The current width, in columns, of the buffer area.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The value in a set operation is less than or equal to zero.-or- The value in
	|        //	a set operation is greater than or equal to System.Int16.MaxValue.-or- The value
	|        //	in a set operation is less than System.Console.WindowLeft + System.Console.WindowWidth.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int BufferWidth { get; set; } = WIDTH;
	|        //
	|        // Summary:
	|        //	Gets or sets the height of the console window area.
	|        //
	|        // Returns:
	|        //	The height of the console window measured in rows.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight
	|        //	property is less than or equal to 0.-or-The value of the System.Console.WindowHeight
	|        //	property plus the value of the System.Console.WindowTop property is greater than
	|        //	or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth
	|        //	property or the value of the System.Console.WindowHeight property is greater
	|        //	than the largest possible window width or height for the current screen resolution
	|        //	and console font.
	|        //
	|        //	T:System.IO.IOException:
	|        //	Error reading or writing information.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int WindowHeight { get; set; } = HEIGHT;
	|        //
	|        // Summary:
	|        //	Gets or sets a value indicating whether the combination of the System.ConsoleModifiers.Control
	|        //	modifier key and System.ConsoleKey.C console key (Ctrl+C) is treated as ordinary
	|        //	input or as an interruption that is handled by the operating system.
	|        //
	|        // Returns:
	|        //	true if Ctrl+C is treated as ordinary input; otherwise, false.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	Unable to get or set the input mode of the console input buffer.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool TreatControlCAsInput { get; set; }
	|        //
	|        // Summary:
	|        //	Gets the largest possible number of console window columns, based on the current
	|        //	font and screen resolution.
	|        //
	|        // Returns:
	|        //	The width of the largest possible console window measured in columns.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int LargestWindowWidth { get; }
	|        //
	|        // Summary:
	|        //	Gets the largest possible number of console window rows, based on the current
	|        //	font and screen resolution.
	|        //
	|        // Returns:
	|        //	The height of the largest possible console window measured in rows.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int LargestWindowHeight { get; }
	|        //
	|        // Summary:
	|        //	Gets or sets the leftmost position of the console window area relative to the
	|        //	screen buffer.
	|        //
	|        // Returns:
	|        //	The leftmost console window position measured in columns.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	In a set operation, the value to be assigned is less than zero.-or-As a result
	|        //	of the assignment, System.Console.WindowLeft plus System.Console.WindowWidth
	|        //	would exceed System.Console.BufferWidth.
	|        //
	|        //	T:System.IO.IOException:
	|        //	Error reading or writing information.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int WindowLeft { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets the top position of the console window area relative to the screen
	|        //	buffer.
	|        //
	|        // Returns:
	|        //	The uppermost console window position measured in rows.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	In a set operation, the value to be assigned is less than zero.-or-As a result
	|        //	of the assignment, System.Console.WindowTop plus System.Console.WindowHeight
	|        //	would exceed System.Console.BufferHeight.
	|        //
	|        //	T:System.IO.IOException:
	|        //	Error reading or writing information.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int WindowTop { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets the column position of the cursor within the buffer area.
	|        //
	|        // Returns:
	|        //	The current position, in columns, of the cursor.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The value in a set operation is less than zero.-or- The value in a set operation
	|        //	is greater than or equal to System.Console.BufferWidth.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int CursorLeft { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets the row position of the cursor within the buffer area.
	|        //
	|        // Returns:
	|        //	The current position, in rows, of the cursor.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The value in a set operation is less than zero.-or- The value in a set operation
	|        //	is greater than or equal to System.Console.BufferHeight.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int CursorTop { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets the height of the cursor within a character cell.
	|        //
	|        // Returns:
	|        //	The size of the cursor expressed as a percentage of the height of a character
	|        //	cell. The property value ranges from 1 to 100.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The value specified in a set operation is less than 1 or greater than 100.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int CursorSize { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets a value indicating whether the cursor is visible.
	|        //
	|        // Returns:
	|        //	true if the cursor is visible; otherwise, false.
	|        //
	|        // Exceptions:
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool CursorVisible { get; set; }
	|        //
	|        // Summary:
	|        //	Gets or sets the title to display in the console title bar.
	|        //
	|        // Returns:
	|        //	The string to be displayed in the title bar of the console. The maximum length
	|        //	of the title string is 24500 characters.
	|        //
	|        // Exceptions:
	|        //	T:System.InvalidOperationException:
	|        //	In a get operation, the retrieved title is longer than 24500 characters.
	|        //
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	In a set operation, the specified title is longer than 24500 characters.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	In a set operation, the specified title is null.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static string Title { get; set; }
	|        //
	|        // Summary:
	|        //	Gets a value indicating whether a key press is available in the input stream.
	|        //
	|        // Returns:
	|        //	true if a key press is available; otherwise, false.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.InvalidOperationException:
	|        //	Standard input is redirected to a file instead of the keyboard.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool KeyAvailable { get; }
	|        //
	|        // Summary:
	|        //	Gets a value indicating whether the NUM LOCK keyboard toggle is turned on or
	|        //	turned off.
	|        //
	|        // Returns:
	|        //	true if NUM LOCK is turned on; false if NUM LOCK is turned off.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool NumberLock { get; }
	|        //
	|        // Summary:
	|        //	Gets a value indicating whether the CAPS LOCK keyboard toggle is turned on or
	|        //	turned off.
	|        //
	|        // Returns:
	|        //	true if CAPS LOCK is turned on; false if CAPS LOCK is turned off.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool CapsLock { get; }
	|        //
	|        // Summary:
	|        //	Gets a value that indicates whether input has been redirected from the standard
	|        //	input stream.
	|        //
	|        // Returns:
	|        //	true if input is redirected; otherwise, false.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static bool IsInputRedirected { get; }
	|
	|        //
	|        // Summary:
	|        //	Plays the sound of a beep through the console speaker.
	|        //
	|        // Exceptions:
	|        //	T:System.Security.HostProtectionException:
	|        //	This method was executed on a server, such as SQL Server, that does not permit
	|        //	access to a user interface.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void Beep()
	|        {
	|            throw new NotImplementedException();
	|        }
	|        //
	|        // Summary:
	|        //	Plays the sound of a beep of a specified frequency and duration through the console
	|        //	speaker.
	|        //
	|        // Parameters:
	|        //	frequency:
	|        //	The frequency of the beep, ranging from 37 to 32767 hertz.
	|        //
	|        //	duration:
	|        //	The duration of the beep measured in milliseconds.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	frequency is less than 37 or more than 32767 hertz.-or- duration is less than
	|        //	or equal to zero.
	|        //
	|        //	T:System.Security.HostProtectionException:
	|        //	This method was executed on a server, such as SQL Server, that does not permit
	|        //	access to the console.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void Beep(int frequency, int duration)
	|        {
	|            throw new NotImplementedException();
	|        }
	|        //
	|        // Summary:
	|        //	Clears the console buffer and corresponding console window of display information.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|
	|        static char[,] _buffer = new char[WindowWidth, WindowHeight];
	|
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void Clear()
	|        {
	|            _buffer = new char[BufferWidth, BufferHeight];
	|            SetCursorPosition(0, 0);
	|        }
	|
	|        //
	|        // Summary:
	|        //	Copies a specified source area of the screen buffer to a specified destination
	|        //	area.
	|        //
	|        // Parameters:
	|        //	sourceLeft:
	|        //	The leftmost column of the source area.
	|        //
	|        //	sourceTop:
	|        //	The topmost row of the source area.
	|        //
	|        //	sourceWidth:
	|        //	The number of columns in the source area.
	|        //
	|        //	sourceHeight:
	|        //	The number of rows in the source area.
	|        //
	|        //	targetLeft:
	|        //	The leftmost column of the destination area.
	|        //
	|        //	targetTop:
	|        //	The topmost row of the destination area.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	One or more of the parameters is less than zero.-or- sourceLeft or targetLeft
	|        //	is greater than or equal to System.Console.BufferWidth.-or- sourceTop or targetTop
	|        //	is greater than or equal to System.Console.BufferHeight.-or- sourceTop + sourceHeight
	|        //	is greater than or equal to System.Console.BufferHeight.-or- sourceLeft + sourceWidth
	|        //	is greater than or equal to System.Console.BufferWidth.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Copies a specified source area of the screen buffer to a specified destination
	|        //	area.
	|        //
	|        // Parameters:
	|        //	sourceLeft:
	|        //	The leftmost column of the source area.
	|        //
	|        //	sourceTop:
	|        //	The topmost row of the source area.
	|        //
	|        //	sourceWidth:
	|        //	The number of columns in the source area.
	|        //
	|        //	sourceHeight:
	|        //	The number of rows in the source area.
	|        //
	|        //	targetLeft:
	|        //	The leftmost column of the destination area.
	|        //
	|        //	targetTop:
	|        //	The topmost row of the destination area.
	|        //
	|        //	sourceChar:
	|        //	The character used to fill the source area.
	|        //
	|        //	sourceForeColor:
	|        //	The foreground color used to fill the source area.
	|        //
	|        //	sourceBackColor:
	|        //	The background color used to fill the source area.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	One or more of the parameters is less than zero.-or- sourceLeft or targetLeft
	|        //	is greater than or equal to System.Console.BufferWidth.-or- sourceTop or targetTop
	|        //	is greater than or equal to System.Console.BufferHeight.-or- sourceTop + sourceHeight
	|        //	is greater than or equal to System.Console.BufferHeight.-or- sourceLeft + sourceWidth
	|        //	is greater than or equal to System.Console.BufferWidth.
	|        //
	|        //	T:System.ArgumentException:
	|        //	One or both of the color parameters is not a member of the System.ConsoleColor
	|        //	enumeration.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Acquires the standard error stream.
	|        //
	|        // Returns:
	|        //	The standard error stream.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Stream OpenStandardError()
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Acquires the standard error stream, which is set to a specified buffer size.
	|        //
	|        // Parameters:
	|        //	bufferSize:
	|        //	The internal stream buffer size.
	|        //
	|        // Returns:
	|        //	The standard error stream.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	bufferSize is less than or equal to zero.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Stream OpenStandardError(int bufferSize)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Acquires the standard input stream, which is set to a specified buffer size.
	|        //
	|        // Parameters:
	|        //	bufferSize:
	|        //	The internal stream buffer size.
	|        //
	|        // Returns:
	|        //	The standard input stream.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	bufferSize is less than or equal to zero.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Stream OpenStandardInput(int bufferSize)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Acquires the standard input stream.
	|        //
	|        // Returns:
	|        //	The standard input stream.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Stream OpenStandardInput()
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Acquires the standard output stream, which is set to a specified buffer size.
	|        //
	|        // Parameters:
	|        //	bufferSize:
	|        //	The internal stream buffer size.
	|        //
	|        // Returns:
	|        //	The standard output stream.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	bufferSize is less than or equal to zero.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Stream OpenStandardOutput(int bufferSize)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Acquires the standard output stream.
	|        //
	|        // Returns:
	|        //	The standard output stream.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Stream OpenStandardOutput()
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Reads the next character from the standard input stream.
	|        //
	|        // Returns:
	|        //	The next character from the input stream, or negative one (-1) if there are currently
	|        //	no more characters to be read.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static int Read()
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Obtains the next character or function key pressed by the user. The pressed key
	|        //	is optionally displayed in the console window.
	|        //
	|        // Parameters:
	|        //	intercept:
	|        //	Determines whether to display the pressed key in the console window. true to
	|        //	not display the pressed key; otherwise, false.
	|        //
	|        // Returns:
	|        //	An object that describes the System.ConsoleKey constant and Unicode character,
	|        //	if any, that correspond to the pressed console key. The System.ConsoleKeyInfo
	|        //	object also describes, in a bitwise combination of System.ConsoleModifiers values,
	|        //	whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously
	|        //	with the console key.
	|        //
	|        // Exceptions:
	|        //	T:System.InvalidOperationException:
	|        //	The System.Console.In property is redirected from some stream other than the
	|        //	console.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static ConsoleKeyInfo ReadKey(bool intercept)
	|        {
	|            if (MockKeyPresses.Count > 0)
	|            {
	|                return MockKeyPresses.Pop();
	|            }
	|            else
	|            {
	|                return new ConsoleKeyInfo('\0', (ConsoleKey)'\0', false, false, false);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static Stack<ConsoleKeyInfo> MockKeyPresses = new Stack<ConsoleKeyInfo>();
	|
	|        //
	|        // Summary:
	|        //	Obtains the next character or function key pressed by the user. The pressed key
	|        //	is displayed in the console window.
	|        //
	|        // Returns:
	|        //	An object that describes the System.ConsoleKey constant and Unicode character,
	|        //	if any, that correspond to the pressed console key. The System.ConsoleKeyInfo
	|        //	object also describes, in a bitwise combination of System.ConsoleModifiers values,
	|        //	whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously
	|        //	with the console key.
	|        //
	|        // Exceptions:
	|        //	T:System.InvalidOperationException:
	|        //	The System.Console.In property is redirected from some stream other than the
	|        //	console.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static ConsoleKeyInfo ReadKey()
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Reads the next line of characters from the standard input stream.
	|        //
	|        // Returns:
	|        //	The next line of characters from the input stream, or null if no more lines are
	|        //	available.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.OutOfMemoryException:
	|        //	There is insufficient memory to allocate a buffer for the returned string.
	|        //
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	The number of characters in the next line of characters is greater than System.Int32.MaxValue.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static string ReadLine()
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the foreground and background console colors to their defaults.
	|        //
	|        // Exceptions:
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void ResetColor()
	|        {
	|            BackgroundColor = _defaultBackgroundColor;
	|            ForegroundColor = _defaultForegroundColor;
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the height and width of the screen buffer area to the specified values.
	|        //
	|        // Parameters:
	|        //	width:
	|        //	The width of the buffer area measured in columns.
	|        //
	|        //	height:
	|        //	The height of the buffer area measured in rows.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	height or width is less than or equal to zero.-or- height or width is greater
	|        //	than or equal to System.Int16.MaxValue.-or- width is less than System.Console.WindowLeft
	|        //	+ System.Console.WindowWidth.-or- height is less than System.Console.WindowTop
	|        //	+ System.Console.WindowHeight.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void SetBufferSize(int width, int height)
	|        {
	|            BufferWidth = width;
	|            BufferHeight = height;
	|            _buffer = new char[BufferWidth, BufferHeight];
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the position of the cursor.
	|        //
	|        // Parameters:
	|        //	left:
	|        //	The column position of the cursor. Columns are numbered from left to right starting
	|        //	at 0.
	|        //
	|        //	top:
	|        //	The row position of the cursor. Rows are numbered from top to bottom starting
	|        //	at 0.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	left or top is less than zero.-or- left is greater than or equal to System.Console.BufferWidth.-or-
	|        //	top is greater than or equal to System.Console.BufferHeight.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void SetCursorPosition(int left, int top)
	|        {
	|            CursorLeft = left;
	|            CursorTop = top;
	|            WindowLeft = Math.Max(Math.Min(left, BufferWidth - WindowWidth), 0);
	|            WindowTop = Math.Max(Math.Min(top, BufferHeight - WindowHeight), 0);
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the System.Console.Error property to the specified System.IO.TextWriter
	|        //	object.
	|        //
	|        // Parameters:
	|        //	newError:
	|        //	A stream that is the new standard error output.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentNullException:
	|        //	newError is null.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The caller does not have the required permission.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void SetError(TextWriter newError)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the System.Console.In property to the specified System.IO.TextReader object.
	|        //
	|        // Parameters:
	|        //	newIn:
	|        //	A stream that is the new standard input.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentNullException:
	|        //	newIn is null.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The caller does not have the required permission.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void SetIn(TextReader newIn)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the System.Console.Out property to the specified System.IO.TextWriter object.
	|        //
	|        // Parameters:
	|        //	newOut:
	|        //	A stream that is the new standard output.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentNullException:
	|        //	newOut is null.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The caller does not have the required permission.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""newOut""></param>
	|        public static void SetOut(TextWriter newOut)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the position of the console window relative to the screen buffer.
	|        //
	|        // Parameters:
	|        //	left:
	|        //	The column position of the upper left corner of the console window.
	|        //
	|        //	top:
	|        //	The row position of the upper left corner of the console window.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	left or top is less than zero.-or- left + System.Console.WindowWidth is greater
	|        //	than System.Console.BufferWidth.-or- top + System.Console.WindowHeight is greater
	|        //	than System.Console.BufferHeight.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""left""></param>
	|        /// <param name=""top""></param>
	|        public static void SetWindowPosition(int left, int top)
	|        {
	|            WindowLeft = left;
	|            WindowTop = top;
	|        }
	|
	|        //
	|        // Summary:
	|        //	Sets the height and width of the console window to the specified values.
	|        //
	|        // Parameters:
	|        //	width:
	|        //	The width of the console window measured in columns.
	|        //
	|        //	height:
	|        //	The height of the console window measured in rows.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	width or height is less than or equal to zero.-or- width plus System.Console.WindowLeft
	|        //	or height plus System.Console.WindowTop is greater than or equal to System.Int16.MaxValue.
	|        //	-or- width or height is greater than the largest possible window width or height
	|        //	for the current screen resolution and console font.
	|        //
	|        //	T:System.Security.SecurityException:
	|        //	The user does not have permission to perform this action.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[SecuritySafeCritical]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""width""></param>
	|        /// <param name=""height""></param>
	|        public static void SetWindowSize(int width, int height)
	|        {
	|            WindowWidth = width;
	|            WindowHeight = height;
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified string value to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(string value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified object to the standard output
	|        //	stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write, or null.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(object value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 64-bit unsigned integer value
	|        //	to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[CLSCompliant (false)]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(ulong value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 64-bit signed integer value to
	|        //	the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(long value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified objects to the standard output
	|        //	stream using the specified format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg0:
	|        //	The first object to write using format.
	|        //
	|        //	arg1:
	|        //	The second object to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        /// <param name=""arg1""></param>
	|        public static void Write(string format, object arg0, object arg1)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 32-bit signed integer value to
	|        //	the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(int value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified object to the standard output
	|        //	stream using the specified format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg0:
	|        //	An object to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        public static void Write(string format, object arg0)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 32-bit unsigned integer value
	|        //	to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[CLSCompliant (false)]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(uint value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //[CLSCompliant (false)]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        /// <param name=""arg1""></param>
	|        /// <param name=""arg2""></param>
	|        /// <param name=""arg3""></param>
	|        public static void Write(string format, object arg0, object arg1, object arg2, object arg3)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified array of objects to the standard
	|        //	output stream using the specified format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg:
	|        //	An array of objects to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format or arg is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg""></param>
	|        public static void Write(string format, params object[] arg)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified Boolean value to the standard
	|        //	output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(bool value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified Unicode character value to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(char value)
	|        {
	|            _buffer[CursorLeft, CursorTop] = value;
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified array of Unicode characters to the standard output stream.
	|        //
	|        // Parameters:
	|        //	buffer:
	|        //	A Unicode character array.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""buffer""></param>
	|        public static void Write(char[] buffer)
	|        {
	|            _buffer[CursorLeft, CursorTop] = (char)0;
	|            foreach (var ch in buffer)
	|            {
	|                _buffer[CursorLeft, CursorTop] += ch;
	|            }
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified subarray of Unicode characters to the standard output stream.
	|        //
	|        // Parameters:
	|        //	buffer:
	|        //	An array of Unicode characters.
	|        //
	|        //	index:
	|        //	The starting position in buffer.
	|        //
	|        //	count:
	|        //	The number of characters to write.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentNullException:
	|        //	buffer is null.
	|        //
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	index or count is less than zero.
	|        //
	|        //	T:System.ArgumentException:
	|        //	index plus count specify a position that is not within buffer.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""buffer""></param>
	|        /// <param name=""index""></param>
	|        /// <param name=""count""></param>
	|        public static void Write(char[] buffer, int index, int count)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified objects to the standard output
	|        //	stream using the specified format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg0:
	|        //	The first object to write using format.
	|        //
	|        //	arg1:
	|        //	The second object to write using format.
	|        //
	|        //	arg2:
	|        //	The third object to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        /// <param name=""arg1""></param>
	|        /// <param name=""arg2""></param>
	|        public static void Write(string format, object arg0, object arg1, object arg2)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified System.Decimal value to the standard
	|        //	output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(decimal value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified single-precision floating-point
	|        //	value to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(float value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified double-precision floating-point
	|        //	value to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void Write(double value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the current line terminator to the standard output stream.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        public static void WriteLine()
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified single-precision floating-point
	|        //	value, followed by the current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(float value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 32-bit signed integer value,
	|        //	followed by the current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(int value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 32-bit unsigned integer value,
	|        //	followed by the current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[CLSCompliant (false)]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(uint value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 64-bit signed integer value,
	|        //	followed by the current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(long value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified 64-bit unsigned integer value,
	|        //	followed by the current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //[CLSCompliant (false)]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(ulong value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified object, followed by the current
	|        //	line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(object value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified string value, followed by the current line terminator, to
	|        //	the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(string value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified object, followed by the current
	|        //	line terminator, to the standard output stream using the specified format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg0:
	|        //	An object to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        public static void WriteLine(string format, object arg0)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified objects, followed by the current
	|        //	line terminator, to the standard output stream using the specified format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg0:
	|        //	The first object to write using format.
	|        //
	|        //	arg1:
	|        //	The second object to write using format.
	|        //
	|        //	arg2:
	|        //	The third object to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        /// <param name=""arg1""></param>
	|        /// <param name=""arg2""></param>
	|        public static void WriteLine(string format, object arg0, object arg1, object arg2)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //[CLSCompliant (false)]
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        /// <param name=""arg1""></param>
	|        /// <param name=""arg2""></param>
	|        /// <param name=""arg3""></param>
	|        public static void WriteLine(string format, object arg0, object arg1, object arg2, object arg3)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified array of objects, followed by
	|        //	the current line terminator, to the standard output stream using the specified
	|        //	format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg:
	|        //	An array of objects to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format or arg is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg""></param>
	|        public static void WriteLine(string format, params object[] arg)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified subarray of Unicode characters, followed by the current
	|        //	line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	buffer:
	|        //	An array of Unicode characters.
	|        //
	|        //	index:
	|        //	The starting position in buffer.
	|        //
	|        //	count:
	|        //	The number of characters to write.
	|        //
	|        // Exceptions:
	|        //	T:System.ArgumentNullException:
	|        //	buffer is null.
	|        //
	|        //	T:System.ArgumentOutOfRangeException:
	|        //	index or count is less than zero.
	|        //
	|        //	T:System.ArgumentException:
	|        //	index plus count specify a position that is not within buffer.
	|        //
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""buffer""></param>
	|        /// <param name=""index""></param>
	|        /// <param name=""count""></param>
	|        public static void WriteLine(char[] buffer, int index, int count)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified System.Decimal value, followed
	|        //	by the current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(decimal value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified array of Unicode characters, followed by the current line
	|        //	terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	buffer:
	|        //	A Unicode character array.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""buffer""></param>
	|        public static void WriteLine(char[] buffer)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the specified Unicode character, followed by the current line terminator,
	|        //	value to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(char value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified Boolean value, followed by the
	|        //	current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(bool value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified objects, followed by the current
	|        //	line terminator, to the standard output stream using the specified format information.
	|        //
	|        // Parameters:
	|        //	format:
	|        //	A composite format string (see Remarks).
	|        //
	|        //	arg0:
	|        //	The first object to write using format.
	|        //
	|        //	arg1:
	|        //	The second object to write using format.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        //
	|        //	T:System.ArgumentNullException:
	|        //	format is null.
	|        //
	|        //	T:System.FormatException:
	|        //	The format specification in format is invalid.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""format""></param>
	|        /// <param name=""arg0""></param>
	|        /// <param name=""arg1""></param>
	|        public static void WriteLine(string format, object arg0, object arg1)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        //
	|        // Summary:
	|        //	Writes the text representation of the specified double-precision floating-point
	|        //	value, followed by the current line terminator, to the standard output stream.
	|        //
	|        // Parameters:
	|        //	value:
	|        //	The value to write.
	|        //
	|        // Exceptions:
	|        //	T:System.IO.IOException:
	|        //	An I/O error occurred.
	|        /// <summary>
	|        /// 
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        public static void WriteLine(double value)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|    }
	|    //=======================================================================
	|    //
	|    // FakeDriver.cs: A fake ConsoleDriver for unit tests. 
	|    //
	|
	|    /// <summary>
	|    /// Implements a mock ConsoleDriver for unit testing
	|    /// </summary>
	|    public class FakeDriver : ConsoleDriver
	|    {
	|#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
	|
	|        public class Behaviors
	|        {
	|
	|            public bool UseFakeClipboard { get; internal set; }
	|            public bool FakeClipboardAlwaysThrowsNotSupportedException { get; internal set; }
	|            public bool FakeClipboardIsSupportedAlwaysFalse { get; internal set; }
	|
	|            public Behaviors(bool useFakeClipboard = false, bool fakeClipboardAlwaysThrowsNotSupportedException = false, bool fakeClipboardIsSupportedAlwaysTrue = false)
	|            {
	|                UseFakeClipboard = useFakeClipboard;
	|                FakeClipboardAlwaysThrowsNotSupportedException = fakeClipboardAlwaysThrowsNotSupportedException;
	|                FakeClipboardIsSupportedAlwaysFalse = fakeClipboardIsSupportedAlwaysTrue;
	|
	|                // double check usage is correct
	|                Debug.Assert(useFakeClipboard == false && fakeClipboardAlwaysThrowsNotSupportedException == false);
	|                Debug.Assert(useFakeClipboard == false && fakeClipboardIsSupportedAlwaysTrue == false);
	|            }
	|        }
	|
	|        public static FakeDriver.Behaviors FakeBehaviors = new Behaviors();
	|
	|        int cols, rows, left, top;
	|        public override int Cols => cols;
	|        public override int Rows => rows;
	|        // Only handling left here because not all terminals has a horizontal scroll bar.
	|        public override int Left => 0;
	|        public override int Top => 0;
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool EnableConsoleScrolling { get; set; }
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool HeightAsBuffer { get; set; }
	|        private IClipboard clipboard = null;
	|        public override IClipboard Clipboard => clipboard;
	|
	|        // The format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
	|        int[,,] contents;
	|        bool[] dirtyLine;
	|
	|        /// <summary>
	|        /// Assists with testing, the format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
	|        /// </summary>
	|        public override int[,,] Contents => contents;
	|
	|        //void UpdateOffscreen ()
	|        //{
	|        //	int cols = Cols;
	|        //	int rows = Rows;
	|
	|        //	contents = new int [rows, cols, 3];
	|        //	for (int r = 0; r < rows; r++) {
	|        //		for (int c = 0; c < cols; c++) {
	|        //			contents [r, c, 0] = ' ';
	|        //			contents [r, c, 1] = MakeColor (ConsoleColor.Gray, ConsoleColor.Black);
	|        //			contents [r, c, 2] = 0;
	|        //		}
	|        //	}
	|        //	dirtyLine = new bool [rows];
	|        //	for (int row = 0; row < rows; row++)
	|        //		dirtyLine [row] = true;
	|        //}
	|
	|        static bool sync = false;
	|
	|        public FakeDriver()
	|        {
	|            if (FakeBehaviors.UseFakeClipboard)
	|            {
	|                clipboard = new FakeClipboard(FakeBehaviors.FakeClipboardAlwaysThrowsNotSupportedException, FakeBehaviors.FakeClipboardIsSupportedAlwaysFalse);
	|            }
	|            else
	|            {
	|                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
	|                {
	|                    clipboard = new WindowsClipboard();
	|                }
	|                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
	|                {
	|                    clipboard = new MacOSXClipboard();
	|                }
	|                else
	|                {
	|                    if (CursesDriver.Is_WSL_Platform())
	|                    {
	|                        clipboard = new WSLClipboard();
	|                    }
	|                    else
	|                    {
	|                        clipboard = new CursesClipboard();
	|                    }
	|                }
	|            }
	|        }
	|
	|        bool needMove;
	|        // Current row, and current col, tracked by Move/AddCh only
	|        int ccol, crow;
	|        public override void Move(int col, int row)
	|        {
	|            ccol = col;
	|            crow = row;
	|
	|            if (Clip.Contains(col, row))
	|            {
	|                FakeConsole.CursorTop = row;
	|                FakeConsole.CursorLeft = col;
	|                needMove = false;
	|            }
	|            else
	|            {
	|                FakeConsole.CursorTop = Clip.Y;
	|                FakeConsole.CursorLeft = Clip.X;
	|                needMove = true;
	|            }
	|        }
	|
	|        public override void AddRune(Rune rune)
	|        {
	|            rune = MakePrintable(rune);
	|            var runeWidth = Rune.ColumnWidth(rune);
	|            var validClip = IsValidContent(ccol, crow, Clip);
	|
	|            if (validClip)
	|            {
	|                if (needMove)
	|                {
	|                    //MockConsole.CursorLeft = ccol;
	|                    //MockConsole.CursorTop = crow;
	|                    needMove = false;
	|                }
	|                if (runeWidth == 0 && ccol > 0)
	|                {
	|                    var r = contents[crow, ccol - 1, 0];
	|                    var s = new string(new char[] { (char)r, (char)rune });
	|                    string sn;
	|                    if (!s.IsNormalized())
	|                    {
	|                        sn = s.Normalize();
	|                    }
	|                    else
	|                    {
	|                        sn = s;
	|                    }
	|                    var c = sn[0];
	|                    contents[crow, ccol - 1, 0] = c;
	|                    contents[crow, ccol - 1, 1] = CurrentAttribute;
	|                    contents[crow, ccol - 1, 2] = 1;
	|
	|                }
	|                else
	|                {
	|                    if (runeWidth < 2 && ccol > 0
	|                    && Rune.ColumnWidth((Rune)contents[crow, ccol - 1, 0]) > 1)
	|                    {
	|
	|                        contents[crow, ccol - 1, 0] = (int)(uint)' ';
	|
	|                    }
	|                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
	|                      && Rune.ColumnWidth((Rune)contents[crow, ccol, 0]) > 1)
	|                    {
	|
	|                        contents[crow, ccol + 1, 0] = (int)(uint)' ';
	|                        contents[crow, ccol + 1, 2] = 1;
	|
	|                    }
	|                    if (runeWidth > 1 && ccol == Clip.Right - 1)
	|                    {
	|                        contents[crow, ccol, 0] = (int)(uint)' ';
	|                    }
	|                    else
	|                    {
	|                        contents[crow, ccol, 0] = (int)(uint)rune;
	|                    }
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 1;
	|
	|                    dirtyLine[crow] = true;
	|                }
	|            }
	|            else
	|            {
	|                needMove = true;
	|            }
	|
	|            if (runeWidth < 0 || runeWidth > 0)
	|            {
	|                ccol++;
	|            }
	|
	|            if (runeWidth > 1)
	|            {
	|                if (validClip && ccol < Clip.Right)
	|                {
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 0;
	|                }
	|                ccol++;
	|            }
	|
	|            //if (ccol == Cols) {
	|            //	ccol = 0;
	|            //	if (crow + 1 < Rows)
	|            //		crow++;
	|            //}
	|            if (sync)
	|            {
	|                UpdateScreen();
	|            }
	|        }
	|
	|        public override void AddStr(ustring str)
	|        {
	|            foreach (var rune in str)
	|                AddRune(rune);
	|        }
	|
	|        public override void End()
	|        {
	|            FakeConsole.ResetColor();
	|            FakeConsole.Clear();
	|        }
	|
	|        public override Attribute MakeColor(Color foreground, Color background)
	|        {
	|            return MakeColor((ConsoleColor)foreground, (ConsoleColor)background);
	|        }
	|
	|        static Attribute MakeColor(ConsoleColor f, ConsoleColor b)
	|        {
	|            // Encode the colors into the int value.
	|            return new Attribute(
	|                value: ((((int)f) & 0xffff) << 16) | (((int)b) & 0xffff),
	|                foreground: (Color)f,
	|                background: (Color)b
	|                );
	|        }
	|
	|        public override void Init(Action terminalResized)
	|        {
	|            TerminalResized = terminalResized;
	|
	|            cols = FakeConsole.WindowWidth = FakeConsole.BufferWidth = FakeConsole.WIDTH;
	|            rows = FakeConsole.WindowHeight = FakeConsole.BufferHeight = FakeConsole.HEIGHT;
	|            FakeConsole.Clear();
	|            ResizeScreen();
	|            // Call InitalizeColorSchemes before UpdateOffScreen as it references Colors
	|            CurrentAttribute = MakeColor(Color.White, Color.Black);
	|            InitalizeColorSchemes();
	|            UpdateOffScreen();
	|        }
	|
	|        public override Attribute MakeAttribute(Color fore, Color back)
	|        {
	|            return MakeColor((ConsoleColor)fore, (ConsoleColor)back);
	|        }
	|
	|        int redrawColor = -1;
	|        void SetColor(int color)
	|        {
	|            redrawColor = color;
	|            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
	|                .OfType<ConsoleColor>()
	|                .Select(s => (int)s);
	|            if (values.Contains(color & 0xffff))
	|            {
	|                FakeConsole.BackgroundColor = (ConsoleColor)(color & 0xffff);
	|            }
	|            if (values.Contains((color >> 16) & 0xffff))
	|            {
	|                FakeConsole.ForegroundColor = (ConsoleColor)((color >> 16) & 0xffff);
	|            }
	|        }
	|
	|        public override void UpdateScreen()
	|        {
	|            int top = Top;
	|            int left = Left;
	|            int rows = Math.Min(FakeConsole.WindowHeight + top, Rows);
	|            int cols = Cols;
	|
	|            var savedRow = FakeConsole.CursorTop;
	|            var savedCol = FakeConsole.CursorLeft;
	|            var savedCursorVisible = FakeConsole.CursorVisible;
	|            for (int row = top; row < rows; row++)
	|            {
	|                if (!dirtyLine[row])
	|                    continue;
	|                dirtyLine[row] = false;
	|                for (int col = left; col < cols; col++)
	|                {
	|                    FakeConsole.CursorTop = row;
	|                    FakeConsole.CursorLeft = col;
	|                    for (; col < cols; col++)
	|                    {
	|                        if (contents[row, col, 2] == 0)
	|                        {
	|                            FakeConsole.CursorLeft++;
	|                            continue;
	|                        }
	|
	|                        var color = contents[row, col, 1];
	|                        if (color != redrawColor)
	|                            SetColor(color);
	|
	|                        Rune rune = contents[row, col, 0];
	|                        if (Rune.DecodeSurrogatePair(rune, out char[] spair))
	|                        {
	|                            FakeConsole.Write(spair);
	|                        }
	|                        else
	|                        {
	|                            FakeConsole.Write((char)rune);
	|                        }
	|                        contents[row, col, 2] = 0;
	|                    }
	|                }
	|            }
	|            FakeConsole.CursorTop = savedRow;
	|            FakeConsole.CursorLeft = savedCol;
	|            FakeConsole.CursorVisible = savedCursorVisible;
	|        }
	|
	|        public override void Refresh()
	|        {
	|            UpdateScreen();
	|            UpdateCursor();
	|        }
	|
	|        public override void SetAttribute(Attribute c)
	|        {
	|            base.SetAttribute(c);
	|        }
	|
	|        public ConsoleKeyInfo FromVKPacketToKConsoleKeyInfo(ConsoleKeyInfo consoleKeyInfo)
	|        {
	|            if (consoleKeyInfo.Key != ConsoleKey.Packet)
	|            {
	|                return consoleKeyInfo;
	|            }
	|
	|            var mod = consoleKeyInfo.Modifiers;
	|            var shift = (mod & ConsoleModifiers.Shift) != 0;
	|            var alt = (mod & ConsoleModifiers.Alt) != 0;
	|            var control = (mod & ConsoleModifiers.Control) != 0;
	|
	|            var keyChar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(consoleKeyInfo.KeyChar, consoleKeyInfo.Modifiers, out uint virtualKey, out _);
	|
	|            return new ConsoleKeyInfo((char)keyChar, (ConsoleKey)virtualKey, shift, alt, control);
	|        }
	|
	|        Key MapKey(ConsoleKeyInfo keyInfo)
	|        {
	|            switch (keyInfo.Key)
	|            {
	|                case ConsoleKey.Escape:
	|                    return MapKeyModifiers(keyInfo, Key.Esc);
	|                case ConsoleKey.Tab:
	|                    return keyInfo.Modifiers == ConsoleModifiers.Shift ? Key.BackTab : Key.Tab;
	|                case ConsoleKey.Clear:
	|                    return MapKeyModifiers(keyInfo, Key.Clear);
	|                case ConsoleKey.Home:
	|                    return MapKeyModifiers(keyInfo, Key.Home);
	|                case ConsoleKey.End:
	|                    return MapKeyModifiers(keyInfo, Key.End);
	|                case ConsoleKey.LeftArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorLeft);
	|                case ConsoleKey.RightArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorRight);
	|                case ConsoleKey.UpArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorUp);
	|                case ConsoleKey.DownArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorDown);
	|                case ConsoleKey.PageUp:
	|                    return MapKeyModifiers(keyInfo, Key.PageUp);
	|                case ConsoleKey.PageDown:
	|                    return MapKeyModifiers(keyInfo, Key.PageDown);
	|                case ConsoleKey.Enter:
	|                    return MapKeyModifiers(keyInfo, Key.Enter);
	|                case ConsoleKey.Spacebar:
	|                    return MapKeyModifiers(keyInfo, keyInfo.KeyChar == 0 ? Key.Space : (Key)keyInfo.KeyChar);
	|                case ConsoleKey.Backspace:
	|                    return MapKeyModifiers(keyInfo, Key.Backspace);
	|                case ConsoleKey.Delete:
	|                    return MapKeyModifiers(keyInfo, Key.DeleteChar);
	|                case ConsoleKey.Insert:
	|                    return MapKeyModifiers(keyInfo, Key.InsertChar);
	|                case ConsoleKey.PrintScreen:
	|                    return MapKeyModifiers(keyInfo, Key.PrintScreen);
	|
	|                case ConsoleKey.Oem1:
	|                case ConsoleKey.Oem2:
	|                case ConsoleKey.Oem3:
	|                case ConsoleKey.Oem4:
	|                case ConsoleKey.Oem5:
	|                case ConsoleKey.Oem6:
	|                case ConsoleKey.Oem7:
	|                case ConsoleKey.Oem8:
	|                case ConsoleKey.Oem102:
	|                case ConsoleKey.OemPeriod:
	|                case ConsoleKey.OemComma:
	|                case ConsoleKey.OemPlus:
	|                case ConsoleKey.OemMinus:
	|                    if (keyInfo.KeyChar == 0)
	|                        return Key.Unknown;
	|
	|                    return (Key)((uint)keyInfo.KeyChar);
	|            }
	|
	|            var key = keyInfo.Key;
	|            if (key >= ConsoleKey.A && key <= ConsoleKey.Z)
	|            {
	|                var delta = key - ConsoleKey.A;
	|                if (keyInfo.Modifiers == ConsoleModifiers.Control)
	|                {
	|                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.A + delta));
	|                }
	|                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
	|                {
	|                    return (Key)(((uint)Key.AltMask) | ((uint)Key.A + delta));
	|                }
	|                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
	|                {
	|                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
	|                }
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    if (keyInfo.KeyChar == 0)
	|                    {
	|                        return (Key)(((uint)Key.AltMask | (uint)Key.CtrlMask) | ((uint)Key.A + delta));
	|                    }
	|                    else
	|                    {
	|                        return (Key)((uint)keyInfo.KeyChar);
	|                    }
	|                }
	|                return (Key)((uint)keyInfo.KeyChar);
	|            }
	|            if (key >= ConsoleKey.D0 && key <= ConsoleKey.D9)
	|            {
	|                var delta = key - ConsoleKey.D0;
	|                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
	|                {
	|                    return (Key)(((uint)Key.AltMask) | ((uint)Key.D0 + delta));
	|                }
	|                if (keyInfo.Modifiers == ConsoleModifiers.Control)
	|                {
	|                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.D0 + delta));
	|                }
	|                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
	|                {
	|                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
	|                }
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    if (keyInfo.KeyChar == 0 || keyInfo.KeyChar == 30)
	|                    {
	|                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
	|                    }
	|                }
	|                return (Key)((uint)keyInfo.KeyChar);
	|            }
	|            if (key >= ConsoleKey.F1 && key <= ConsoleKey.F12)
	|            {
	|                var delta = key - ConsoleKey.F1;
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.F1 + delta));
	|                }
	|
	|                return (Key)((uint)Key.F1 + delta);
	|            }
	|            if (keyInfo.KeyChar != 0)
	|            {
	|                return MapKeyModifiers(keyInfo, (Key)((uint)keyInfo.KeyChar));
	|            }
	|
	|            return (Key)(0xffffffff);
	|        }
	|
	|        KeyModifiers keyModifiers;
	|
	|        private Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
	|        {
	|            Key keyMod = new Key();
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
	|                keyMod = Key.ShiftMask;
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
	|                keyMod |= Key.CtrlMask;
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
	|                keyMod |= Key.AltMask;
	|
	|            return keyMod != Key.Null ? keyMod | key : key;
	|        }
	|
	|        Action<KeyEvent> keyDownHandler;
	|        Action<KeyEvent> keyHandler;
	|        Action<KeyEvent> keyUpHandler;
	|        private CursorVisibility savedCursorVisibility;
	|
	|        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
	|        {
	|            this.keyDownHandler = keyDownHandler;
	|            this.keyHandler = keyHandler;
	|            this.keyUpHandler = keyUpHandler;
	|
	|            // Note: Net doesn't support keydown/up events and thus any passed keyDown/UpHandlers will never be called
	|            (mainLoop.Driver as FakeMainLoop).KeyPressed += (consoleKey) => ProcessInput(consoleKey);
	|        }
	|
	|        void ProcessInput(ConsoleKeyInfo consoleKey)
	|        {
	|            if (consoleKey.Key == ConsoleKey.Packet)
	|            {
	|                consoleKey = FromVKPacketToKConsoleKeyInfo(consoleKey);
	|            }
	|            keyModifiers = new KeyModifiers();
	|            if (consoleKey.Modifiers.HasFlag(ConsoleModifiers.Shift))
	|            {
	|                keyModifiers.Shift = true;
	|            }
	|            if (consoleKey.Modifiers.HasFlag(ConsoleModifiers.Alt))
	|            {
	|                keyModifiers.Alt = true;
	|            }
	|            if (consoleKey.Modifiers.HasFlag(ConsoleModifiers.Control))
	|            {
	|                keyModifiers.Ctrl = true;
	|            }
	|            var map = MapKey(consoleKey);
	|            if (map == (Key)0xffffffff)
	|            {
	|                if ((consoleKey.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    keyDownHandler(new KeyEvent(map, keyModifiers));
	|                    keyUpHandler(new KeyEvent(map, keyModifiers));
	|                }
	|                return;
	|            }
	|
	|            keyDownHandler(new KeyEvent(map, keyModifiers));
	|            keyHandler(new KeyEvent(map, keyModifiers));
	|            keyUpHandler(new KeyEvent(map, keyModifiers));
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool GetCursorVisibility(out CursorVisibility visibility)
	|        {
	|            visibility = FakeConsole.CursorVisible
	|                ? CursorVisibility.Default
	|                : CursorVisibility.Invisible;
	|
	|            return FakeConsole.CursorVisible;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool SetCursorVisibility(CursorVisibility visibility)
	|        {
	|            savedCursorVisibility = visibility;
	|            return FakeConsole.CursorVisible = visibility == CursorVisibility.Default;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool EnsureCursorVisibility()
	|        {
	|            if (!(ccol >= 0 && crow >= 0 && ccol < Cols && crow < Rows))
	|            {
	|                GetCursorVisibility(out CursorVisibility cursorVisibility);
	|                savedCursorVisibility = cursorVisibility;
	|                SetCursorVisibility(CursorVisibility.Invisible);
	|                return false;
	|            }
	|
	|            SetCursorVisibility(savedCursorVisibility);
	|            return FakeConsole.CursorVisible;
	|        }
	|
	|        public override void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
	|        {
	|            ProcessInput(new ConsoleKeyInfo(keyChar, key, shift, alt, control));
	|        }
	|
	|        public void SetBufferSize(int width, int height)
	|        {
	|            FakeConsole.SetBufferSize(width, height);
	|            cols = width;
	|            rows = height;
	|            SetWindowSize(width, height);
	|            ProcessResize();
	|        }
	|
	|        public void SetWindowSize(int width, int height)
	|        {
	|            FakeConsole.SetWindowSize(width, height);
	|            if (width != cols || height != rows)
	|            {
	|                SetBufferSize(width, height);
	|                cols = width;
	|                rows = height;
	|            }
	|            ProcessResize();
	|        }
	|
	|        public void SetWindowPosition(int left, int top)
	|        {
	|            if (this.left > 0 || this.top > 0)
	|            {
	|                this.left = 0;
	|                this.top = 0;
	|            }
	|            FakeConsole.SetWindowPosition(this.left, this.top);
	|        }
	|
	|        void ProcessResize()
	|        {
	|            ResizeScreen();
	|            UpdateOffScreen();
	|            TerminalResized?.Invoke();
	|        }
	|
	|        public override void ResizeScreen()
	|        {
	|            if (FakeConsole.WindowHeight > 0)
	|            {
	|                // Can raise an exception while is still resizing.
	|                try
	|                {
	|#pragma warning disable CA1416
	|                    FakeConsole.CursorTop = 0;
	|                    FakeConsole.CursorLeft = 0;
	|                    FakeConsole.WindowTop = 0;
	|                    FakeConsole.WindowLeft = 0;
	|#pragma warning restore CA1416
	|                }
	|                catch (System.IO.IOException)
	|                {
	|                    return;
	|                }
	|                catch (ArgumentOutOfRangeException)
	|                {
	|                    return;
	|                }
	|            }
	|
	|            Clip = new Rect(0, 0, Cols, Rows);
	|        }
	|
	|        public override void UpdateOffScreen()
	|        {
	|            contents = new int[Rows, Cols, 3];
	|            dirtyLine = new bool[Rows];
	|
	|            // Can raise an exception while is still resizing.
	|            try
	|            {
	|                for (int row = 0; row < rows; row++)
	|                {
	|                    for (int c = 0; c < cols; c++)
	|                    {
	|                        contents[row, c, 0] = ' ';
	|                        contents[row, c, 1] = (ushort)Colors.TopLevel.Normal;
	|                        contents[row, c, 2] = 0;
	|                        dirtyLine[row] = true;
	|                    }
	|                }
	|            }
	|            catch (IndexOutOfRangeException) { }
	|        }
	|
	|        public override bool GetColors(int value, out Color foreground, out Color background)
	|        {
	|            bool hasColor = false;
	|            foreground = default;
	|            background = default;
	|            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
	|                .OfType<ConsoleColor>()
	|                .Select(s => (int)s);
	|            if (values.Contains(value & 0xffff))
	|            {
	|                hasColor = true;
	|                background = (Color)(ConsoleColor)(value & 0xffff);
	|            }
	|            if (values.Contains((value >> 16) & 0xffff))
	|            {
	|                hasColor = true;
	|                foreground = (Color)(ConsoleColor)((value >> 16) & 0xffff);
	|            }
	|            return hasColor;
	|        }
	|
	|        #region Unused
	|        public override void UpdateCursor()
	|        {
	|            if (!EnsureCursorVisibility())
	|                return;
	|
	|            // Prevents the exception of size changing during resizing.
	|            try
	|            {
	|                if (ccol >= 0 && ccol < FakeConsole.BufferWidth && crow >= 0 && crow < FakeConsole.BufferHeight)
	|                {
	|                    FakeConsole.SetCursorPosition(ccol, crow);
	|                }
	|            }
	|            catch (System.IO.IOException)
	|            {
	|            }
	|            catch (ArgumentOutOfRangeException)
	|            {
	|            }
	|        }
	|
	|        public override void StartReportingMouseMoves()
	|        {
	|        }
	|
	|        public override void StopReportingMouseMoves()
	|        {
	|        }
	|
	|        public override void Suspend()
	|        {
	|        }
	|
	|        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
	|        {
	|        }
	|
	|        public override void SetColors(short foregroundColorId, short backgroundColorId)
	|        {
	|            throw new NotImplementedException();
	|        }
	|
	|        public override void CookMouse()
	|        {
	|        }
	|
	|        public override void UncookMouse()
	|        {
	|        }
	|
	|        #endregion
	|
	|        public class FakeClipboard : ClipboardBase
	|        {
	|            public Exception FakeException = null;
	|
	|            string contents = string.Empty;
	|
	|            bool isSupportedAlwaysFalse = false;
	|
	|            public override bool IsSupported => !isSupportedAlwaysFalse;
	|
	|            public FakeClipboard(bool fakeClipboardThrowsNotSupportedException = false, bool isSupportedAlwaysFalse = false)
	|            {
	|                this.isSupportedAlwaysFalse = isSupportedAlwaysFalse;
	|                if (fakeClipboardThrowsNotSupportedException)
	|                {
	|                    FakeException = new NotSupportedException(""Fake clipboard exception"");
	|                }
	|            }
	|
	|            protected override string GetClipboardDataImpl()
	|            {
	|                if (FakeException != null)
	|                {
	|                    throw FakeException;
	|                }
	|                return contents;
	|            }
	|
	|            protected override void SetClipboardDataImpl(string text)
	|            {
	|                if (FakeException != null)
	|                {
	|                    throw FakeException;
	|                }
	|                contents = text;
	|            }
	|        }
	|
	|#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	|    }
	|    //=======================================================================
	|    internal class FakeMainLoop : IMainLoopDriver
	|    {
	|
	|        public Action<ConsoleKeyInfo> KeyPressed;
	|
	|        public FakeMainLoop(ConsoleDriver consoleDriver = null)
	|        {
	|            // consoleDriver is not needed/used in FakeConsole
	|        }
	|
	|        public void Setup(MainLoop mainLoop)
	|        {
	|        }
	|
	|        public void Wakeup()
	|        {
	|            // No implementation needed for FakeMainLoop
	|        }
	|
	|        public bool EventsPending(bool wait)
	|        {
	|            // Always return true for FakeMainLoop
	|            return true;
	|        }
	|
	|        public void MainIteration()
	|        {
	|            if (FakeConsole.MockKeyPresses.Count > 0)
	|            {
	|                KeyPressed?.Invoke(FakeConsole.MockKeyPresses.Pop());
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    // 
	|    // FileDialog.cs: File system dialogs for open and save
	|    //
	|    // TODO:
	|    //   * Add directory selector
	|    //   * Implement subclasses
	|    //   * Figure out why message text does not show
	|    //   * Remove the extra space when message does not show
	|    //   * Use a line separator to show the file listing, so we can use same colors as the rest
	|    //   * DirListView: Add mouse support
	|
	|    internal class DirListView : View
	|    {
	|        int top, selected;
	|        DirectoryInfo dirInfo;
	|        FileSystemWatcher watcher;
	|        List<(string, bool, bool)> infos;
	|        internal bool canChooseFiles = true;
	|        internal bool canChooseDirectories = false;
	|        internal bool allowsMultipleSelection = false;
	|        FileDialog host;
	|
	|        public DirListView(FileDialog host)
	|        {
	|            infos = new List<(string, bool, bool)>();
	|            CanFocus = true;
	|            this.host = host;
	|        }
	|
	|        bool IsAllowed(FileSystemInfo fsi)
	|        {
	|            if (fsi.Attributes.HasFlag(FileAttributes.Directory))
	|                return true;
	|            if (allowedFileTypes == null)
	|                return true;
	|            foreach (var ft in allowedFileTypes)
	|                if (fsi.Name.EndsWith(ft, StringComparison.InvariantCultureIgnoreCase) || ft == "".*"")
	|                    return true;
	|            return false;
	|        }
	|
	|        internal bool Reload(ustring value = null)
	|        {
	|            bool valid = false;
	|            try
	|            {
	|                dirInfo = new DirectoryInfo(value == null ? directory.ToString() : value.ToString());
	|
	|                // Dispose of the old watcher
	|                watcher?.Dispose();
	|
	|                watcher = new FileSystemWatcher(dirInfo.FullName);
	|                watcher.NotifyFilter = NotifyFilters.Attributes
	|                 | NotifyFilters.CreationTime
	|                 | NotifyFilters.DirectoryName
	|                 | NotifyFilters.FileName
	|                 | NotifyFilters.LastAccess
	|                 | NotifyFilters.LastWrite
	|                 | NotifyFilters.Security
	|                 | NotifyFilters.Size;
	|                watcher.Changed += Watcher_Changed;
	|                watcher.Created += Watcher_Changed;
	|                watcher.Deleted += Watcher_Changed;
	|                watcher.Renamed += Watcher_Changed;
	|                watcher.Error += Watcher_Error;
	|                watcher.EnableRaisingEvents = true;
	|                infos = (from x in dirInfo.GetFileSystemInfos()
	|                         where IsAllowed(x) && (!canChooseFiles ? x.Attributes.HasFlag(FileAttributes.Directory) : true)
	|                         orderby (!x.Attributes.HasFlag(FileAttributes.Directory)) + x.Name
	|                         select (x.Name, x.Attributes.HasFlag(FileAttributes.Directory), false)).ToList();
	|                infos.Insert(0, ("".."", true, false));
	|                top = 0;
	|                selected = 0;
	|                valid = true;
	|            }
	|            catch (Exception ex)
	|            {
	|                switch (ex)
	|                {
	|                    case DirectoryNotFoundException _:
	|                    case ArgumentException _:
	|                        dirInfo = null;
	|                        watcher?.Dispose();
	|                        watcher = null;
	|                        infos.Clear();
	|                        valid = true;
	|                        break;
	|                    default:
	|                        valid = false;
	|                        break;
	|                }
	|            }
	|            finally
	|            {
	|                if (valid)
	|                {
	|                    SetNeedsDisplay();
	|                }
	|            }
	|            return valid;
	|        }
	|
	|        private bool _disposedValue;
	|        protected override void Dispose(bool disposing)
	|        {
	|            if (!_disposedValue)
	|            {
	|                if (disposing)
	|                {
	|                    if (watcher != null)
	|                    {
	|                        watcher.Changed -= Watcher_Changed;
	|                        watcher.Created -= Watcher_Changed;
	|                        watcher.Deleted -= Watcher_Changed;
	|                        watcher.Renamed -= Watcher_Changed;
	|                        watcher.Error -= Watcher_Error;
	|                    }
	|                    watcher?.Dispose();
	|                    watcher = null;
	|                }
	|
	|                _disposedValue = true;
	|            }
	|
	|            // Call base class implementation.
	|            base.Dispose(disposing);
	|        }
	|
	|        void Watcher_Error(object sender, ErrorEventArgs e)
	|        {
	|            if (Application.MainLoop == null)
	|                return;
	|
	|            Application.MainLoop.Invoke(() => Reload());
	|        }
	|
	|        void Watcher_Changed(object sender, FileSystemEventArgs e)
	|        {
	|            if (Application.MainLoop == null)
	|                return;
	|
	|            Application.MainLoop.Invoke(() => Reload());
	|        }
	|
	|        ustring directory;
	|        public ustring Directory
	|        {
	|            get => directory;
	|            set
	|            {
	|                if (directory == value)
	|                {
	|                    return;
	|                }
	|                if (Reload(value))
	|                {
	|                    directory = value;
	|                }
	|            }
	|        }
	|
	|        public override void PositionCursor()
	|        {
	|            Move(0, selected - top);
	|        }
	|
	|        int lastSelected;
	|        bool shiftOnWheel;
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if ((me.Flags & (MouseFlags.Button1Clicked | MouseFlags.Button1DoubleClicked |
	|                MouseFlags.WheeledUp | MouseFlags.WheeledDown)) == 0)
	|                return false;
	|
	|            if (!HasFocus)
	|                SetFocus();
	|
	|            if (infos == null)
	|                return false;
	|
	|            if (me.Y + top >= infos.Count)
	|                return true;
	|
	|            int lastSelectedCopy = shiftOnWheel ? lastSelected : selected;
	|
	|            switch (me.Flags)
	|            {
	|                case MouseFlags.Button1Clicked:
	|                    SetSelected(me);
	|                    OnSelectionChanged();
	|                    SetNeedsDisplay();
	|                    break;
	|                case MouseFlags.Button1DoubleClicked:
	|                    UnMarkAll();
	|                    SetSelected(me);
	|                    if (ExecuteSelection())
	|                    {
	|                        host.canceled = false;
	|                        Application.RequestStop();
	|                    }
	|                    return true;
	|                case MouseFlags.Button1Clicked | MouseFlags.ButtonShift:
	|                    SetSelected(me);
	|                    if (shiftOnWheel)
	|                        lastSelected = lastSelectedCopy;
	|                    shiftOnWheel = false;
	|                    PerformMultipleSelection(lastSelected);
	|                    return true;
	|                case MouseFlags.Button1Clicked | MouseFlags.ButtonCtrl:
	|                    SetSelected(me);
	|                    PerformMultipleSelection();
	|                    return true;
	|                case MouseFlags.WheeledUp:
	|                    SetSelected(me);
	|                    selected = lastSelected;
	|                    MoveUp();
	|                    return true;
	|                case MouseFlags.WheeledDown:
	|                    SetSelected(me);
	|                    selected = lastSelected;
	|                    MoveDown();
	|                    return true;
	|                case MouseFlags.WheeledUp | MouseFlags.ButtonShift:
	|                    SetSelected(me);
	|                    selected = lastSelected;
	|                    lastSelected = lastSelectedCopy;
	|                    shiftOnWheel = true;
	|                    MoveUp();
	|                    return true;
	|                case MouseFlags.WheeledDown | MouseFlags.ButtonShift:
	|                    SetSelected(me);
	|                    selected = lastSelected;
	|                    lastSelected = lastSelectedCopy;
	|                    shiftOnWheel = true;
	|                    MoveDown();
	|                    return true;
	|            }
	|
	|            return true;
	|        }
	|
	|        void UnMarkAll()
	|        {
	|            for (int i = 0; i < infos.Count; i++)
	|            {
	|                if (infos[i].Item3)
	|                {
	|                    infos[i] = (infos[i].Item1, infos[i].Item2, false);
	|                }
	|            }
	|        }
	|
	|        void SetSelected(MouseEvent me)
	|        {
	|            lastSelected = selected;
	|            selected = top + me.Y;
	|        }
	|
	|        void DrawString(int line, string str)
	|        {
	|            var f = Frame;
	|            var width = f.Width;
	|            var ustr = ustring.Make(str);
	|
	|            Move(allowsMultipleSelection ? 3 : 2, line);
	|            int byteLen = ustr.Length;
	|            int used = allowsMultipleSelection ? 2 : 1;
	|            for (int i = 0; i < byteLen;)
	|            {
	|                (var rune, var size) = Utf8.DecodeRune(ustr, i, i - byteLen);
	|                var count = Rune.ColumnWidth(rune);
	|                if (used + count >= width)
	|                    break;
	|                Driver.AddRune(rune);
	|                used += count;
	|                i += size;
	|            }
	|            for (; used < width - 1; used++)
	|            {
	|                Driver.AddRune(' ');
	|            }
	|        }
	|
	|        public override void Redraw(Rect bounds)
	|        {
	|            var current = ColorScheme.Focus;
	|            Driver.SetAttribute(current);
	|            Move(0, 0);
	|            var f = Frame;
	|            var item = top;
	|            bool focused = HasFocus;
	|            var width = bounds.Width;
	|
	|            for (int row = 0; row < f.Height; row++, item++)
	|            {
	|                bool isSelected = item == selected;
	|                Move(0, row);
	|                var newcolor = focused ? (isSelected ? ColorScheme.HotNormal : ColorScheme.Focus)
	|                    : Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
	|                if (newcolor != current)
	|                {
	|                    Driver.SetAttribute(newcolor);
	|                    current = newcolor;
	|                }
	|                if (item >= infos.Count)
	|                {
	|                    for (int c = 0; c < f.Width; c++)
	|                        Driver.AddRune(' ');
	|                    continue;
	|                }
	|                var fi = infos[item];
	|
	|                Driver.AddRune(isSelected ? '>' : ' ');
	|
	|                if (allowsMultipleSelection)
	|                    Driver.AddRune(fi.Item3 ? '*' : ' ');
	|
	|                if (fi.Item2)
	|                    Driver.AddRune('/');
	|                else
	|                    Driver.AddRune(' ');
	|                DrawString(row, fi.Item1);
	|            }
	|        }
	|
	|        public Action<(string, bool)> SelectedChanged { get; set; }
	|        public Action<ustring> DirectoryChanged { get; set; }
	|        public Action<ustring> FileChanged { get; set; }
	|
	|        string splitString = "","";
	|
	|        void OnSelectionChanged()
	|        {
	|            if (allowsMultipleSelection)
	|            {
	|                if (FilePaths.Count > 0)
	|                {
	|                    FileChanged?.Invoke(string.Join(splitString, GetFilesName(FilePaths)));
	|                }
	|                else
	|                {
	|                    FileChanged?.Invoke(infos[selected].Item2 && !canChooseDirectories ? """" : Path.GetFileName(infos[selected].Item1));
	|                }
	|            }
	|            else
	|            {
	|                var sel = infos[selected];
	|                SelectedChanged?.Invoke((sel.Item1, sel.Item2));
	|            }
	|        }
	|
	|        List<string> GetFilesName(IReadOnlyList<string> files)
	|        {
	|            List<string> filesName = new List<string>();
	|
	|            foreach (var file in files)
	|            {
	|                filesName.Add(Path.GetFileName(file));
	|            }
	|
	|            return filesName;
	|        }
	|
	|        public bool GetValidFilesName(string files, out string result)
	|        {
	|            result = string.Empty;
	|            if (infos?.Count == 0)
	|            {
	|                return false;
	|            }
	|
	|            var valid = true;
	|            IReadOnlyList<string> filesList = new List<string>(files.Split(splitString.ToArray(), StringSplitOptions.None));
	|            var filesName = new List<string>();
	|            UnMarkAll();
	|
	|            foreach (var file in filesList)
	|            {
	|                if (!allowsMultipleSelection && filesName.Count > 0)
	|                {
	|                    break;
	|                }
	|                var idx = infos.IndexOf(x => x.Item1.IndexOf(file, StringComparison.OrdinalIgnoreCase) >= 0);
	|                if (idx > -1 && string.Equals(infos[idx].Item1, file, StringComparison.OrdinalIgnoreCase))
	|                {
	|                    if (canChooseDirectories && !canChooseFiles && !infos[idx].Item2)
	|                    {
	|                        valid = false;
	|                    }
	|                    if (allowsMultipleSelection && !infos[idx].Item3)
	|                    {
	|                        infos[idx] = (infos[idx].Item1, infos[idx].Item2, true);
	|                    }
	|                    if (!allowsMultipleSelection)
	|                    {
	|                        selected = idx;
	|                    }
	|                    filesName.Add(Path.GetFileName(infos[idx].Item1));
	|                }
	|                else if (idx > -1)
	|                {
	|                    valid = false;
	|                    filesName.Add(Path.GetFileName(file));
	|                }
	|            }
	|            result = string.Join(splitString, filesName);
	|            if (string.IsNullOrEmpty(result))
	|            {
	|                valid = false;
	|            }
	|            return valid;
	|        }
	|
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            switch (keyEvent.Key)
	|            {
	|                case Key.CursorUp:
	|                case Key.P | Key.CtrlMask:
	|                    MoveUp();
	|                    return true;
	|
	|                case Key.CursorDown:
	|                case Key.N | Key.CtrlMask:
	|                    MoveDown();
	|                    return true;
	|
	|                case Key.V | Key.CtrlMask:
	|                case Key.PageDown:
	|                    var n = (selected + Frame.Height);
	|                    if (n > infos.Count)
	|                        n = infos.Count - 1;
	|                    if (n != selected)
	|                    {
	|                        selected = n;
	|                        if (infos.Count >= Frame.Height)
	|                            top = selected;
	|                        else
	|                            top = 0;
	|                        OnSelectionChanged();
	|
	|                        SetNeedsDisplay();
	|                    }
	|                    return true;
	|
	|                case Key.Enter:
	|                    UnMarkAll();
	|                    if (ExecuteSelection())
	|                        return false;
	|                    else
	|                        return true;
	|
	|                case Key.PageUp:
	|                    n = (selected - Frame.Height);
	|                    if (n < 0)
	|                        n = 0;
	|                    if (n != selected)
	|                    {
	|                        selected = n;
	|                        top = selected;
	|                        OnSelectionChanged();
	|                        SetNeedsDisplay();
	|                    }
	|                    return true;
	|
	|                case Key.Space:
	|                case Key.T | Key.CtrlMask:
	|                    PerformMultipleSelection();
	|                    return true;
	|
	|                case Key.Home:
	|                    MoveFirst();
	|                    return true;
	|
	|                case Key.End:
	|                    MoveLast();
	|                    return true;
	|            }
	|            return base.ProcessKey(keyEvent);
	|        }
	|
	|        void MoveLast()
	|        {
	|            selected = infos.Count - 1;
	|            top = infos.Count() - 1;
	|            OnSelectionChanged();
	|            SetNeedsDisplay();
	|        }
	|
	|        void MoveFirst()
	|        {
	|            selected = 0;
	|            top = 0;
	|            OnSelectionChanged();
	|            SetNeedsDisplay();
	|        }
	|
	|        void MoveDown()
	|        {
	|            if (selected + 1 < infos.Count)
	|            {
	|                selected++;
	|                if (selected >= top + Frame.Height)
	|                    top++;
	|                OnSelectionChanged();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        void MoveUp()
	|        {
	|            if (selected > 0)
	|            {
	|                selected--;
	|                if (selected < top)
	|                    top = selected;
	|                OnSelectionChanged();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        internal bool ExecuteSelection(bool navigateFolder = true)
	|        {
	|            if (infos.Count == 0)
	|            {
	|                return false;
	|            }
	|            var isDir = infos[selected].Item2;
	|
	|            if (isDir)
	|            {
	|                Directory = Path.GetFullPath(Path.Combine(Path.GetFullPath(Directory.ToString()), infos[selected].Item1));
	|                DirectoryChanged?.Invoke(Directory);
	|                if (canChooseDirectories && !navigateFolder)
	|                {
	|                    return true;
	|                }
	|            }
	|            else
	|            {
	|                OnSelectionChanged();
	|                if (canChooseFiles)
	|                {
	|                    // Ensures that at least one file is selected.
	|                    if (FilePaths.Count == 0)
	|                        PerformMultipleSelection();
	|                    // Let the OK handler take it over
	|                    return true;
	|                }
	|                // No files allowed, do not let the default handler take it.
	|            }
	|            return false;
	|        }
	|
	|        void PerformMultipleSelection(int? firstSelected = null)
	|        {
	|            if (allowsMultipleSelection)
	|            {
	|                int first = Math.Min(firstSelected ?? selected, selected);
	|                int last = Math.Max(selected, firstSelected ?? selected);
	|                for (int i = first; i <= last; i++)
	|                {
	|                    if ((canChooseFiles && infos[i].Item2 == false) ||
	|                        (canChooseDirectories && infos[i].Item2 &&
	|                         infos[i].Item1 != ""..""))
	|                    {
	|                        infos[i] = (infos[i].Item1, infos[i].Item2, !infos[i].Item3);
	|                    }
	|                }
	|                OnSelectionChanged();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        string[] allowedFileTypes;
	|        public string[] AllowedFileTypes
	|        {
	|            get => allowedFileTypes;
	|            set
	|            {
	|                allowedFileTypes = value;
	|                Reload();
	|            }
	|        }
	|
	|        public string MakePath(string relativePath)
	|        {
	|            var dir = Directory.ToString();
	|            return string.IsNullOrEmpty(dir) ? """" : Path.GetFullPath(Path.Combine(dir, relativePath));
	|        }
	|
	|        public IReadOnlyList<string> FilePaths
	|        {
	|            get
	|            {
	|                if (allowsMultipleSelection)
	|                {
	|                    var res = new List<string>();
	|                    foreach (var item in infos)
	|                    {
	|                        if (item.Item3)
	|                            res.Add(MakePath(item.Item1));
	|                    }
	|                    if (res.Count == 0 && infos.Count > 0 && infos[selected].Item1 != "".."")
	|                    {
	|                        res.Add(MakePath(infos[selected].Item1));
	|                    }
	|                    return res;
	|                }
	|                else
	|                {
	|                    if (infos.Count == 0)
	|                    {
	|                        return null;
	|                    }
	|                    if (infos[selected].Item2)
	|                    {
	|                        if (canChooseDirectories)
	|                        {
	|                            var sel = infos[selected].Item1;
	|                            return sel == "".."" ? new List<string>() : new List<string>() { MakePath(infos[selected].Item1) };
	|                        }
	|                        return Array.Empty<string>();
	|                    }
	|                    else
	|                    {
	|                        if (canChooseFiles)
	|                        {
	|                            return new List<string>() { MakePath(infos[selected].Item1) };
	|                        }
	|                        return Array.Empty<string>();
	|                    }
	|                }
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Base class for the <see cref=""OpenDialog""/> and the <see cref=""SaveDialog""/>
	|    /// </summary>
	|    public class FileDialog : Dialog
	|    {
	|        Button prompt, cancel;
	|        Label nameFieldLabel, message, nameDirLabel;
	|        TextField dirEntry, nameEntry;
	|        internal DirListView dirListView;
	|        ComboBox cmbAllowedTypes;
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""FileDialog""/>.
	|        /// </summary>
	|        public FileDialog() : this(title: string.Empty, prompt: string.Empty,
	|            nameFieldLabel: string.Empty, message: string.Empty)
	|        { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""FileDialog""/>
	|        /// </summary>
	|        /// <param name=""title"">The title.</param>
	|        /// <param name=""prompt"">The prompt.</param>
	|        /// <param name=""nameFieldLabel"">The name of the file field label..</param>
	|        /// <param name=""message"">The message.</param>
	|        /// <param name=""allowedTypes"">The allowed types.</param>
	|        public FileDialog(ustring title, ustring prompt, ustring nameFieldLabel, ustring message, List<string> allowedTypes = null)
	|            : this(title, prompt, ustring.Empty, nameFieldLabel, message, allowedTypes) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""FileDialog""/>
	|        /// </summary>
	|        /// <param name=""title"">The title.</param>
	|        /// <param name=""prompt"">The prompt.</param>
	|        /// <param name=""message"">The message.</param>
	|        /// <param name=""allowedTypes"">The allowed types.</param>
	|        public FileDialog(ustring title, ustring prompt, ustring message, List<string> allowedTypes)
	|            : this(title, prompt, ustring.Empty, message, allowedTypes) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""FileDialog""/>
	|        /// </summary>
	|        /// <param name=""title"">The title.</param>
	|        /// <param name=""prompt"">The prompt.</param>
	|        /// <param name=""nameDirLabel"">The name of the directory field label.</param>
	|        /// <param name=""nameFieldLabel"">The name of the file field label..</param>
	|        /// <param name=""message"">The message.</param>
	|        /// <param name=""allowedTypes"">The allowed types.</param>
	|        public FileDialog(ustring title, ustring prompt, ustring nameDirLabel, ustring nameFieldLabel, ustring message,
	|            List<string> allowedTypes = null) : base(title)//, Driver.Cols - 20, Driver.Rows - 5, null)
	|        {
	|            this.message = new Label(message)
	|            {
	|                X = 1,
	|                Y = 0,
	|            };
	|            Add(this.message);
	|            var msgLines = TextFormatter.MaxLines(message, Driver.Cols - 20);
	|
	|            this.nameDirLabel = new Label(nameDirLabel.IsEmpty ? $""{Strings.fdDirectory}: "" : $""{nameDirLabel}: "")
	|            {
	|                X = 1,
	|                Y = 1 + msgLines,
	|                AutoSize = true
	|            };
	|
	|            dirEntry = new TextField("""")
	|            {
	|                X = Pos.Right(this.nameDirLabel),
	|                Y = 1 + msgLines,
	|                Width = Dim.Fill() - 1,
	|            };
	|            dirEntry.TextChanged += (e) =>
	|            {
	|                DirectoryPath = dirEntry.Text;
	|                nameEntry.Text = ustring.Empty;
	|            };
	|            Add(this.nameDirLabel, dirEntry);
	|
	|            this.nameFieldLabel = new Label(nameFieldLabel.IsEmpty ? $""{Strings.fdFile}: "" : $""{nameFieldLabel}: "")
	|            {
	|                X = 1,
	|                Y = 3 + msgLines,
	|                AutoSize = true
	|            };
	|            nameEntry = new TextField("""")
	|            {
	|                X = Pos.Left(dirEntry),
	|                Y = 3 + msgLines,
	|                Width = Dim.Percent(70, true)
	|            };
	|            Add(this.nameFieldLabel, nameEntry);
	|
	|            cmbAllowedTypes = new ComboBox()
	|            {
	|                X = Pos.Right(nameEntry) + 2,
	|                Y = Pos.Top(nameEntry),
	|                Width = Dim.Fill(1),
	|                Height = SetComboBoxHeight(allowedTypes),
	|                Text = allowedTypes?.Count > 0 ? allowedTypes[0] : string.Empty,
	|                SelectedItem = allowedTypes?.Count > 0 ? 0 : -1,
	|                ReadOnly = true,
	|                HideDropdownListOnClick = true
	|            };
	|            cmbAllowedTypes.SetSource(allowedTypes ?? new List<string>());
	|            cmbAllowedTypes.OpenSelectedItem += (e) =>
	|            {
	|                dirListView.AllowedFileTypes = cmbAllowedTypes.Text.ToString().Split(';');
	|                dirListView.Reload();
	|            };
	|            Add(cmbAllowedTypes);
	|
	|            dirListView = new DirListView(this)
	|            {
	|                X = 1,
	|                Y = 3 + msgLines + 2,
	|                Width = Dim.Fill() - 1,
	|                Height = Dim.Fill() - 2,
	|            };
	|            DirectoryPath = Path.GetFullPath(Environment.CurrentDirectory);
	|            Add(dirListView);
	|
	|            AllowedFileTypes = allowedTypes?.Count > 0 ? allowedTypes?.ToArray() : null;
	|            dirListView.DirectoryChanged = (dir) => { nameEntry.Text = ustring.Empty; dirEntry.Text = dir; };
	|            dirListView.FileChanged = (file) => nameEntry.Text = file == "".."" ? """" : file;
	|            dirListView.SelectedChanged = (file) => nameEntry.Text = file.Item1 == "".."" ? """" : file.Item1;
	|            this.cancel = new Button(""Cancel"");
	|            this.cancel.Clicked += () =>
	|            {
	|                Cancel();
	|            };
	|            AddButton(cancel);
	|
	|            this.prompt = new Button(prompt.IsEmpty ? ""Ok"" : prompt)
	|            {
	|                IsDefault = true,
	|                Enabled = nameEntry.Text.IsEmpty ? false : true
	|            };
	|            this.prompt.Clicked += () =>
	|            {
	|                if (this is OpenDialog)
	|                {
	|                    if (!dirListView.GetValidFilesName(nameEntry.Text.ToString(), out string res))
	|                    {
	|                        nameEntry.Text = res;
	|                        dirListView.SetNeedsDisplay();
	|                        return;
	|                    }
	|                    if (!dirListView.canChooseDirectories && !dirListView.ExecuteSelection(false))
	|                    {
	|                        return;
	|                    }
	|                }
	|                else if (this is SaveDialog)
	|                {
	|                    var name = nameEntry.Text.ToString();
	|                    if (FilePath.IsEmpty || name.Split(',').Length > 1)
	|                    {
	|                        return;
	|                    }
	|                    var ext = name.EndsWith(cmbAllowedTypes.Text.ToString())
	|                        ? """" : cmbAllowedTypes.Text.ToString();
	|                    FilePath = Path.Combine(FilePath.ToString(), $""{name}{ext}"");
	|                }
	|                canceled = false;
	|                Application.RequestStop();
	|            };
	|            AddButton(this.prompt);
	|
	|            nameEntry.TextChanged += (e) =>
	|            {
	|                if (nameEntry.Text.IsEmpty)
	|                {
	|                    this.prompt.Enabled = false;
	|                }
	|                else
	|                {
	|                    this.prompt.Enabled = true;
	|                }
	|            };
	|
	|            Width = Dim.Percent(80);
	|            Height = Dim.Percent(80);
	|
	|            // On success, we will set this to false.
	|            canceled = true;
	|
	|            KeyPress += (e) =>
	|            {
	|                if (e.KeyEvent.Key == Key.Esc)
	|                {
	|                    Cancel();
	|                    e.Handled = true;
	|                }
	|            };
	|            void Cancel()
	|            {
	|                canceled = true;
	|                Application.RequestStop();
	|            }
	|        }
	|
	|        private static int SetComboBoxHeight(List<string> allowedTypes)
	|        {
	|            return allowedTypes != null ? Math.Min(allowedTypes.Count + 1, 8) : 8;
	|        }
	|
	|        internal bool canceled;
	|
	|        ///<inheritdoc/>
	|        public override void WillPresent()
	|        {
	|            base.WillPresent();
	|            dirListView.SetFocus();
	|        }
	|
	|        //protected override void Dispose (bool disposing)
	|        //{
	|        //	message?.Dispose ();
	|        //	base.Dispose (disposing);
	|        //}
	|
	|        /// <summary>
	|        /// Gets or sets the prompt label for the <see cref=""Button""/> displayed to the user
	|        /// </summary>
	|        /// <value>The prompt.</value>
	|        public ustring Prompt
	|        {
	|            get => prompt.Text;
	|            set
	|            {
	|                prompt.Text = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the name of the directory field label.
	|        /// </summary>
	|        /// <value>The name of the directory field label.</value>
	|        public ustring NameDirLabel
	|        {
	|            get => nameDirLabel.Text;
	|            set
	|            {
	|                nameDirLabel.Text = $""{value}: "";
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the name field label.
	|        /// </summary>
	|        /// <value>The name field label.</value>
	|        public ustring NameFieldLabel
	|        {
	|            get => nameFieldLabel.Text;
	|            set
	|            {
	|                nameFieldLabel.Text = $""{value}: "";
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the message displayed to the user, defaults to nothing
	|        /// </summary>
	|        /// <value>The message.</value>
	|        public ustring Message
	|        {
	|            get => message.Text;
	|            set
	|            {
	|                message.Text = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""FileDialog""/> can create directories.
	|        /// </summary>
	|        /// <value><c>true</c> if can create directories; otherwise, <c>false</c>.</value>
	|        public bool CanCreateDirectories { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""FileDialog""/> is extension hidden.
	|        /// </summary>
	|        /// <value><c>true</c> if is extension hidden; otherwise, <c>false</c>.</value>
	|        public bool IsExtensionHidden { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the directory path for this panel
	|        /// </summary>
	|        /// <value>The directory path.</value>
	|        public ustring DirectoryPath
	|        {
	|            get => dirEntry.Text;
	|            set
	|            {
	|                dirEntry.Text = value;
	|                dirListView.Directory = value;
	|            }
	|        }
	|
	|        private string[] allowedFileTypes;
	|
	|        /// <summary>
	|        /// The array of filename extensions allowed, or null if all file extensions are allowed.
	|        /// </summary>
	|        /// <value>The allowed file types.</value>
	|        public string[] AllowedFileTypes
	|        {
	|            get => allowedFileTypes;
	|            set
	|            {
	|                allowedFileTypes = value;
	|                var selected = cmbAllowedTypes.SelectedItem;
	|                cmbAllowedTypes.SetSource(value);
	|                cmbAllowedTypes.SelectedItem = selected > -1 ? selected : 0;
	|                SetComboBoxHeight(value?.ToList());
	|                dirListView.AllowedFileTypes = value != null
	|                    ? value[cmbAllowedTypes.SelectedItem].Split(';')
	|                    : null;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""FileDialog""/> allows the file to be saved with a different extension
	|        /// </summary>
	|        /// <value><c>true</c> if allows other file types; otherwise, <c>false</c>.</value>
	|        public bool AllowsOtherFileTypes { get; set; }
	|
	|        /// <summary>
	|        /// The File path that is currently shown on the panel
	|        /// </summary>
	|        /// <value>The absolute file path for the file path entered.</value>
	|        public ustring FilePath
	|        {
	|            get => dirListView.MakePath(nameEntry.Text.ToString());
	|            set
	|            {
	|                nameEntry.Text = Path.GetFileName(value.ToString());
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Check if the dialog was or not canceled.
	|        /// </summary>
	|        public bool Canceled { get => canceled; }
	|    }
	|
	|    /// <summary>
	|    ///  The <see cref=""SaveDialog""/> provides an interactive dialog box for users to pick a file to 
	|    ///  save.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   To use, create an instance of <see cref=""SaveDialog""/>, and pass it to
	|    ///   <see cref=""Application.Run(Func{Exception, bool})""/>. This will run the dialog modally,
	|    ///   and when this returns, the <see cref=""FileName""/>property will contain the selected file name or 
	|    ///   null if the user canceled. 
	|    /// </para>
	|    /// </remarks>
	|    public class SaveDialog : FileDialog
	|    {
	|        /// <summary>
	|        /// Initializes a new <see cref=""SaveDialog""/>.
	|        /// </summary>
	|        public SaveDialog() : this(title: string.Empty, message: string.Empty) { }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""SaveDialog""/>.
	|        /// </summary>
	|        /// <param name=""title"">The title.</param>
	|        /// <param name=""message"">The message.</param>
	|        /// <param name=""allowedTypes"">The allowed types.</param>
	|        public SaveDialog(ustring title, ustring message, List<string> allowedTypes = null)
	|            : base(title, prompt: Strings.fdSave, nameFieldLabel: $""{Strings.fdSaveAs}"", message: message, allowedTypes) { }
	|
	|        /// <summary>
	|        /// Gets the name of the file the user selected for saving, or null
	|        /// if the user canceled the <see cref=""SaveDialog""/>.
	|        /// </summary>
	|        /// <value>The name of the file.</value>
	|        public ustring FileName
	|        {
	|            get
	|            {
	|                if (canceled)
	|                    return null;
	|                return Path.GetFileName(FilePath.ToString());
	|            }
	|        }
	|    }
	|
	|    /// <summary>
	|    /// The <see cref=""OpenDialog""/>provides an interactive dialog box for users to select files or directories.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   The open dialog can be used to select files for opening, it can be configured to allow
	|    ///   multiple items to be selected (based on the AllowsMultipleSelection) variable and
	|    ///   you can control whether this should allow files or directories to be selected.
	|    /// </para>
	|    /// <para>
	|    ///   To use, create an instance of <see cref=""OpenDialog""/>, and pass it to
	|    ///   <see cref=""Application.Run(Func{Exception, bool})""/>. This will run the dialog modally,
	|    ///   and when this returns, the list of files will be available on the <see cref=""FilePaths""/> property.
	|    /// </para>
	|    /// <para>
	|    /// To select more than one file, users can use the spacebar, or control-t.
	|    /// </para>
	|    /// </remarks>
	|    public class OpenDialog : FileDialog
	|    {
	|        OpenMode openMode;
	|
	|        /// <summary>
	|        /// Determine which <see cref=""System.IO""/> type to open.
	|        /// </summary>
	|        public enum OpenMode
	|        {
	|            /// <summary>
	|            /// Opens only file or files.
	|            /// </summary>
	|            File,
	|            /// <summary>
	|            /// Opens only directory or directories.
	|            /// </summary>
	|            Directory,
	|            /// <summary>
	|            /// Opens files and directories.
	|            /// </summary>
	|            Mixed
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""OpenDialog""/>.
	|        /// </summary>
	|        public OpenDialog() : this(title: string.Empty, message: string.Empty) { }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""OpenDialog""/>.
	|        /// </summary>
	|        /// <param name=""title"">The title.</param>
	|        /// <param name=""message"">The message.</param>
	|        /// <param name=""allowedTypes"">The allowed types.</param>
	|        /// <param name=""openMode"">The open mode.</param>
	|        public OpenDialog(ustring title, ustring message, List<string> allowedTypes = null, OpenMode openMode = OpenMode.File) : base(title,
	|            prompt: openMode == OpenMode.File ? Strings.fdOpen : openMode == OpenMode.Directory ? Strings.fdSelectFolder : Strings.fdSelectMixed,
	|            nameFieldLabel: Strings.fdOpen, message: message, allowedTypes)
	|        {
	|            this.openMode = openMode;
	|            switch (openMode)
	|            {
	|                case OpenMode.File:
	|                    CanChooseFiles = true;
	|                    CanChooseDirectories = false;
	|                    break;
	|                case OpenMode.Directory:
	|                    CanChooseFiles = false;
	|                    CanChooseDirectories = true;
	|                    break;
	|                case OpenMode.Mixed:
	|                    CanChooseFiles = true;
	|                    CanChooseDirectories = true;
	|                    AllowsMultipleSelection = true;
	|                    break;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""Terminal.Gui.OpenDialog""/> can choose files.
	|        /// </summary>
	|        /// <value><c>true</c> if can choose files; otherwise, <c>false</c>.  Defaults to <c>true</c></value>
	|        public bool CanChooseFiles
	|        {
	|            get => dirListView.canChooseFiles;
	|            set
	|            {
	|                dirListView.canChooseFiles = value;
	|                dirListView.Reload();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""OpenDialog""/> can choose directories.
	|        /// </summary>
	|        /// <value><c>true</c> if can choose directories; otherwise, <c>false</c> defaults to <c>false</c>.</value>
	|        public bool CanChooseDirectories
	|        {
	|            get => dirListView.canChooseDirectories;
	|            set
	|            {
	|                dirListView.canChooseDirectories = value;
	|                dirListView.Reload();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""OpenDialog""/> allows multiple selection.
	|        /// </summary>
	|        /// <value><c>true</c> if allows multiple selection; otherwise, <c>false</c>, defaults to false.</value>
	|        public bool AllowsMultipleSelection
	|        {
	|            get => dirListView.allowsMultipleSelection;
	|            set
	|            {
	|                if (!value && openMode == OpenMode.Mixed)
	|                {
	|                    return;
	|                }
	|                dirListView.allowsMultipleSelection = value;
	|                dirListView.Reload();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the selected files, or an empty list if nothing has been selected
	|        /// </summary>
	|        /// <value>The file paths.</value>
	|        public IReadOnlyList<string> FilePaths
	|        {
	|            get => dirListView.FilePaths;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|    // NOTE: FrameView is functionally identical to Window with the following exceptions. 
	|    //  - Is not a Toplevel
	|    //  - Does not support mouse dragging
	|    //  - Does not support padding (but should)
	|    //  - Does not support IEnumerable
	|    // Any udpates done here should probably be done in Window as well; TODO: Merge these classes
	|
	|    /// <summary>
	|    /// The FrameView is a container frame that draws a frame around the contents. It is similar to
	|    /// a GroupBox in Windows.
	|    /// </summary>
	|    public class FrameView : View
	|    {
	|        View contentView;
	|        ustring title;
	|
	|        /// <summary>
	|        /// The title to be displayed for this <see cref=""FrameView""/>.
	|        /// </summary>
	|        /// <value>The title.</value>
	|        public ustring Title
	|        {
	|            get => title;
	|            set
	|            {
	|                title = value;
	|                if (Border != null)
	|                {
	|                    Border.Title = title;
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override Border Border
	|        {
	|            get => base.Border;
	|            set
	|            {
	|                if (base.Border != null && base.Border.Child != null && value.Child == null)
	|                {
	|                    value.Child = base.Border.Child;
	|                }
	|                base.Border = value;
	|                if (value == null)
	|                {
	|                    return;
	|                }
	|                Rect frame;
	|                if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
	|                {
	|                    frame = Rect.Empty;
	|                }
	|                else
	|                {
	|                    frame = Frame;
	|                }
	|                AdjustContentView(frame);
	|
	|                Border.BorderChanged += Border_BorderChanged;
	|            }
	|        }
	|
	|        void Border_BorderChanged(Border border)
	|        {
	|            Rect frame;
	|            if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
	|            {
	|                frame = Rect.Empty;
	|            }
	|            else
	|            {
	|                frame = Frame;
	|            }
	|            AdjustContentView(frame);
	|        }
	|
	|        /// <summary>
	|        /// ContentView is an internal implementation detail of Window. It is used to host Views added with <see cref=""Add(View)""/>. 
	|        /// Its ONLY reason for being is to provide a simple way for Window to expose to those SubViews that the Window's Bounds 
	|        /// are actually deflated due to the border. 
	|        /// </summary>
	|        class ContentView : View
	|        {
	|            public ContentView(Rect frame) : base(frame) { }
	|            public ContentView() : base() { }
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.FrameView""/> class using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <param name=""frame"">Frame.</param>
	|        /// <param name=""title"">Title.</param>
	|        /// <param name=""views"">Views.</param>
	|        /// <param name=""border"">The <see cref=""Border""/>.</param>
	|        public FrameView(Rect frame, ustring title = null, View[] views = null, Border border = null) : base(frame)
	|        {
	|            //var cFrame = new Rect (1, 1, Math.Max (frame.Width - 2, 0), Math.Max (frame.Height - 2, 0));
	|            Initialize(frame, title, views, border);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.FrameView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <param name=""title"">Title.</param>
	|        /// <param name=""border"">The <see cref=""Border""/>.</param>
	|        public FrameView(ustring title, Border border = null)
	|        {
	|            Initialize(Rect.Empty, title, null, border);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.FrameView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        public FrameView() : this(title: string.Empty) { }
	|
	|        void Initialize(Rect frame, ustring title, View[] views = null, Border border = null)
	|        {
	|            if (title == null) title = ustring.Empty;
	|            this.Title = title;
	|            if (border == null)
	|            {
	|                Border = new Border()
	|                {
	|                    BorderStyle = BorderStyle.Single,
	|                    Title = title
	|                };
	|            }
	|            else
	|            {
	|                Border = border;
	|                if (ustring.IsNullOrEmpty(border.Title))
	|                {
	|                    border.Title = title;
	|                }
	|            }
	|            AdjustContentView(frame, views);
	|        }
	|
	|        void AdjustContentView(Rect frame, View[] views = null)
	|        {
	|            var borderLength = Border.DrawMarginFrame ? 1 : 0;
	|            var sumPadding = Border.GetSumThickness();
	|            var wp = new Point();
	|            var wb = new Size();
	|            if (frame == Rect.Empty)
	|            {
	|                wp.X = borderLength + sumPadding.Left;
	|                wp.Y = borderLength + sumPadding.Top;
	|                wb.Width = borderLength + sumPadding.Right;
	|                wb.Height = borderLength + sumPadding.Bottom;
	|                if (contentView == null)
	|                {
	|                    contentView = new ContentView()
	|                    {
	|                        X = wp.X,
	|                        Y = wp.Y,
	|                        Width = Dim.Fill(wb.Width),
	|                        Height = Dim.Fill(wb.Height)
	|                    };
	|                }
	|                else
	|                {
	|                    contentView.X = wp.X;
	|                    contentView.Y = wp.Y;
	|                    contentView.Width = Dim.Fill(wb.Width);
	|                    contentView.Height = Dim.Fill(wb.Height);
	|                }
	|            }
	|            else
	|            {
	|                wb.Width = (2 * borderLength) + sumPadding.Right + sumPadding.Left;
	|                wb.Height = (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
	|                var cFrame = new Rect(borderLength + sumPadding.Left, borderLength + sumPadding.Top, frame.Width - wb.Width, frame.Height - wb.Height);
	|                if (contentView == null)
	|                {
	|                    contentView = new ContentView(cFrame);
	|                }
	|                else
	|                {
	|                    contentView.Frame = cFrame;
	|                }
	|            }
	|            if (views != null)
	|            {
	|                foreach (var view in views)
	|                {
	|                    contentView.Add(view);
	|                }
	|            }
	|            if (Subviews?.Count == 0)
	|            {
	|                base.Add(contentView);
	|                contentView.Text = base.Text;
	|            }
	|            Border.Child = contentView;
	|        }
	|
	|        void DrawFrame()
	|        {
	|            DrawFrame(new Rect(0, 0, Frame.Width, Frame.Height), 0, fill: true);
	|        }
	|
	|        /// <summary>
	|        /// Add the specified <see cref=""View""/> to this container.
	|        /// </summary>
	|        /// <param name=""view""><see cref=""View""/> to add to this container</param>
	|        public override void Add(View view)
	|        {
	|            contentView.Add(view);
	|            if (view.CanFocus)
	|                CanFocus = true;
	|        }
	|
	|
	|        /// <summary>
	|        ///   Removes a <see cref=""View""/> from this container.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public override void Remove(View view)
	|        {
	|            if (view == null)
	|                return;
	|
	|            SetNeedsDisplay();
	|            var touched = view.Frame;
	|            if (view == contentView)
	|            {
	|                base.Remove(view);
	|            }
	|            else
	|            {
	|                contentView.Remove(view);
	|            }
	|
	|            if (contentView.InternalSubviews.Count < 1)
	|                this.CanFocus = false;
	|        }
	|
	|        /// <summary>
	|        ///   Removes all <see cref=""View""/>s from this container.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public override void RemoveAll()
	|        {
	|            contentView.RemoveAll();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            if (!NeedDisplay.IsEmpty)
	|            {
	|                Driver.SetAttribute(GetNormalColor());
	|                Clear();
	|            }
	|
	|            var savedClip = contentView.ClipToBounds();
	|            contentView.Redraw(!NeedDisplay.IsEmpty ? contentView.Bounds : bounds);
	|            Driver.Clip = savedClip;
	|
	|            ClearLayoutNeeded();
	|            ClearNeedsDisplay();
	|
	|            Driver.SetAttribute(GetNormalColor());
	|            Border.DrawContent(this, false);
	|        }
	|
	|        /// <summary>
	|        ///   The text displayed by the <see cref=""Label""/>.
	|        /// </summary>
	|        public override ustring Text
	|        {
	|            get => contentView?.Text;
	|            set
	|            {
	|                base.Text = value;
	|                if (contentView != null)
	|                {
	|                    contentView.Text = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Controls the text-alignment property of the label, changing it will redisplay the <see cref=""Label""/>.
	|        /// </summary>
	|        /// <value>The text alignment.</value>
	|        public override TextAlignment TextAlignment
	|        {
	|            get => contentView.TextAlignment;
	|            set
	|            {
	|                base.TextAlignment = contentView.TextAlignment = value;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            if (Subviews.Count == 0 || !Subviews.Any(subview => subview.CanFocus))
	|            {
	|                Application.Driver?.SetCursorVisibility(CursorVisibility.Invisible);
	|            }
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void OnCanFocusChanged()
	|        {
	|            if (contentView != null)
	|            {
	|                contentView.CanFocus = CanFocus;
	|            }
	|            base.OnCanFocusChanged();
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Control for rendering graphs (bar, scatter etc)
	|    /// </summary>
	|    public class GraphView : View
	|    {
	|
	|        /// <summary>
	|        /// Horizontal axis
	|        /// </summary>
	|        /// <value></value>
	|        public HorizontalAxis AxisX { get; set; }
	|
	|        /// <summary>
	|        /// Vertical axis
	|        /// </summary>
	|        /// <value></value>
	|        public VerticalAxis AxisY { get; set; }
	|
	|        /// <summary>
	|        /// Collection of data series that are rendered in the graph
	|        /// </summary>
	|        public List<ISeries> Series { get; } = new List<ISeries>();
	|
	|
	|        /// <summary>
	|        /// Elements drawn into graph after series have been drawn e.g. Legends etc
	|        /// </summary>
	|        public List<IAnnotation> Annotations { get; } = new List<IAnnotation>();
	|
	|        /// <summary>
	|        /// Amount of space to leave on left of control.  Graph content (<see cref=""Series""/>)
	|        /// will not be rendered in margins but axis labels may be
	|        /// </summary>
	|        public uint MarginLeft { get; set; }
	|
	|        /// <summary>
	|        /// Amount of space to leave on bottom of control.  Graph content (<see cref=""Series""/>)
	|        /// will not be rendered in margins but axis labels may be
	|        /// </summary>
	|        public uint MarginBottom { get; set; }
	|
	|        /// <summary>
	|        /// The graph space position of the bottom left of the control.
	|        /// Changing this scrolls the viewport around in the graph
	|        /// </summary>
	|        /// <value></value>
	|        public PointF ScrollOffset { get; set; } = new PointF(0, 0);
	|
	|        /// <summary>
	|        /// Translates console width/height into graph space. Defaults
	|        /// to 1 row/col of console space being 1 unit of graph space. 
	|        /// </summary>
	|        /// <returns></returns>
	|        public PointF CellSize { get; set; } = new PointF(1, 1);
	|
	|        /// <summary>
	|        /// The color of the background of the graph and axis/labels
	|        /// </summary>
	|        public Attribute? GraphColor { get; set; }
	|
	|        /// <summary>
	|        /// Creates a new graph with a 1 to 1 graph space with absolute layout
	|        /// </summary>
	|        public GraphView()
	|        {
	|            CanFocus = true;
	|
	|            AxisX = new HorizontalAxis();
	|            AxisY = new VerticalAxis();
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.ScrollUp, () => { Scroll(0, CellSize.Y); return true; });
	|            AddCommand(Command.ScrollDown, () => { Scroll(0, -CellSize.Y); return true; });
	|            AddCommand(Command.ScrollRight, () => { Scroll(CellSize.X, 0); return true; });
	|            AddCommand(Command.ScrollLeft, () => { Scroll(-CellSize.X, 0); return true; });
	|            AddCommand(Command.PageUp, () => { PageUp(); return true; });
	|            AddCommand(Command.PageDown, () => { PageDown(); return true; });
	|
	|            AddKeyBinding(Key.CursorRight, Command.ScrollRight);
	|            AddKeyBinding(Key.CursorLeft, Command.ScrollLeft);
	|            AddKeyBinding(Key.CursorUp, Command.ScrollUp);
	|            AddKeyBinding(Key.CursorDown, Command.ScrollDown);
	|
	|            // Not bound by default (preserves backwards compatibility)
	|            //AddKeyBinding (Key.PageUp, Command.PageUp);
	|            //AddKeyBinding (Key.PageDown, Command.PageDown);
	|        }
	|
	|        /// <summary>
	|        /// Clears all settings configured on the graph and resets all properties
	|        /// to default values (<see cref=""CellSize""/>, <see cref=""ScrollOffset""/> etc) 
	|        /// </summary>
	|        public void Reset()
	|        {
	|            ScrollOffset = new PointF(0, 0);
	|            CellSize = new PointF(1, 1);
	|            AxisX.Reset();
	|            AxisY.Reset();
	|            Series.Clear();
	|            Annotations.Clear();
	|            GraphColor = null;
	|            SetNeedsDisplay();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            if (CellSize.X == 0 || CellSize.Y == 0)
	|            {
	|                throw new Exception($""{nameof(CellSize)} cannot be 0"");
	|            }
	|
	|            SetDriverColorToGraphColor();
	|
	|            Move(0, 0);
	|
	|            // clear all old content
	|            for (int i = 0; i < Bounds.Height; i++)
	|            {
	|                Move(0, i);
	|                Driver.AddStr(new string(' ', Bounds.Width));
	|            }
	|
	|            // If there is no data do not display a graph
	|            if (!Series.Any() && !Annotations.Any())
	|            {
	|                return;
	|            }
	|
	|            // The drawable area of the graph (anything that isn't in the margins)
	|            var graphScreenWidth = Bounds.Width - ((int)MarginLeft);
	|            var graphScreenHeight = Bounds.Height - (int)MarginBottom;
	|
	|            // if the margins take up the full draw bounds don't render
	|            if (graphScreenWidth < 0 || graphScreenHeight < 0)
	|            {
	|                return;
	|            }
	|
	|            // Draw 'before' annotations
	|            foreach (var a in Annotations.ToArray().Where(a => a.BeforeSeries))
	|            {
	|                a.Render(this);
	|            }
	|
	|            SetDriverColorToGraphColor();
	|
	|            AxisY.DrawAxisLine(this);
	|            AxisX.DrawAxisLine(this);
	|
	|            AxisY.DrawAxisLabels(this);
	|            AxisX.DrawAxisLabels(this);
	|
	|            // Draw a cross where the two axis cross
	|            var axisIntersection = new Point(AxisY.GetAxisXPosition(this), AxisX.GetAxisYPosition(this));
	|
	|            if (AxisX.Visible && AxisY.Visible)
	|            {
	|                Move(axisIntersection.X, axisIntersection.Y);
	|                AddRune(axisIntersection.X, axisIntersection.Y, '\u253C');
	|            }
	|
	|            SetDriverColorToGraphColor();
	|
	|
	|            Rect drawBounds = new Rect((int)MarginLeft, 0, graphScreenWidth, graphScreenHeight);
	|
	|            RectangleF graphSpace = ScreenToGraphSpace(drawBounds);
	|
	|            foreach (var s in Series.ToArray())
	|            {
	|
	|                s.DrawSeries(this, drawBounds, graphSpace);
	|
	|                // If a series changes the graph color reset it
	|                SetDriverColorToGraphColor();
	|            }
	|
	|            SetDriverColorToGraphColor();
	|
	|            // Draw 'after' annotations
	|            foreach (var a in Annotations.ToArray().Where(a => !a.BeforeSeries))
	|            {
	|                a.Render(this);
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Sets the color attribute of <see cref=""Application.Driver""/> to the <see cref=""GraphColor""/>
	|        /// (if defined) or <see cref=""ColorScheme""/> otherwise.
	|        /// </summary>
	|        public void SetDriverColorToGraphColor()
	|        {
	|            Driver.SetAttribute(GraphColor ?? (GetNormalColor()));
	|        }
	|
	|        /// <summary>
	|        /// Returns the section of the graph that is represented by the given
	|        /// screen position
	|        /// </summary>
	|        /// <param name=""col""></param>
	|        /// <param name=""row""></param>
	|        /// <returns></returns>
	|        public RectangleF ScreenToGraphSpace(int col, int row)
	|        {
	|            return new RectangleF(
	|                ScrollOffset.X + ((col - MarginLeft) * CellSize.X),
	|                ScrollOffset.Y + ((Bounds.Height - (row + MarginBottom + 1)) * CellSize.Y),
	|                CellSize.X, CellSize.Y);
	|        }
	|
	|
	|        /// <summary>
	|        /// Returns the section of the graph that is represented by the screen area
	|        /// </summary>
	|        /// <param name=""screenArea""></param>
	|        /// <returns></returns>
	|        public RectangleF ScreenToGraphSpace(Rect screenArea)
	|        {
	|            // get position of the bottom left
	|            var pos = ScreenToGraphSpace(screenArea.Left, screenArea.Bottom - 1);
	|
	|            return new RectangleF(pos.X, pos.Y, screenArea.Width * CellSize.X, screenArea.Height * CellSize.Y);
	|        }
	|        /// <summary>
	|        /// Calculates the screen location for a given point in graph space.
	|        /// Bear in mind these be off screen
	|        /// </summary>
	|        /// <param name=""location"">Point in graph space that may or may not be represented in the
	|        /// visible area of graph currently presented.  E.g. 0,0 for origin</param>
	|        /// <returns>Screen position (Column/Row) which would be used to render the graph <paramref name=""location""/>.
	|        /// Note that this can be outside the current client area of the control</returns>
	|        public Point GraphSpaceToScreen(PointF location)
	|        {
	|            return new Point(
	|
	|                (int)((location.X - ScrollOffset.X) / CellSize.X) + (int)MarginLeft,
	|                 // screen coordinates are top down while graph coordinates are bottom up
	|                 (Bounds.Height - 1) - (int)MarginBottom - (int)((location.Y - ScrollOffset.Y) / CellSize.Y)
	|                );
	|        }
	|
	|        /// <inheritdoc/>
	|        /// <remarks>Also ensures that cursor is invisible after entering the <see cref=""GraphView""/>.</remarks>
	|        public override bool OnEnter(View view)
	|        {
	|            Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|            return base.OnEnter(view);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            if (HasFocus && CanFocus)
	|            {
	|                var result = InvokeKeybindings(keyEvent);
	|                if (result != null)
	|                    return (bool)result;
	|            }
	|
	|            return base.ProcessKey(keyEvent);
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the graph up 1 page
	|        /// </summary>
	|        public void PageUp()
	|        {
	|            Scroll(0, CellSize.Y * Bounds.Height);
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the graph down 1 page
	|        /// </summary>
	|        public void PageDown()
	|        {
	|            Scroll(0, -1 * CellSize.Y * Bounds.Height);
	|        }
	|        /// <summary>
	|        /// Scrolls the view by a given number of units in graph space.
	|        /// See <see cref=""CellSize""/> to translate this into rows/cols
	|        /// </summary>
	|        /// <param name=""offsetX""></param>
	|        /// <param name=""offsetY""></param>
	|        public void Scroll(float offsetX, float offsetY)
	|        {
	|            ScrollOffset = new PointF(
	|                ScrollOffset.X + offsetX,
	|                ScrollOffset.Y + offsetY);
	|
	|            SetNeedsDisplay();
	|        }
	|
	|
	|        #region Bresenham's line algorithm
	|        // https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C.23
	|
	|        int ipart(decimal x) { return (int)x; }
	|
	|
	|        decimal fpart(decimal x)
	|        {
	|            if (x < 0) return (1 - (x - Math.Floor(x)));
	|            return (x - Math.Floor(x));
	|        }
	|
	|        /// <summary>
	|        /// Draws a line between two points in screen space.  Can be diagonals.
	|        /// </summary>
	|        /// <param name=""start""></param>
	|        /// <param name=""end""></param>
	|        /// <param name=""symbol"">The symbol to use for the line</param>
	|        public void DrawLine(Point start, Point end, Rune symbol)
	|        {
	|            if (Equals(start, end))
	|            {
	|                return;
	|            }
	|
	|            int x0 = start.X;
	|            int y0 = start.Y;
	|            int x1 = end.X;
	|            int y1 = end.Y;
	|
	|            int dx = Math.Abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
	|            int dy = Math.Abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
	|            int err = (dx > dy ? dx : -dy) / 2, e2;
	|
	|            while (true)
	|            {
	|
	|                AddRune(x0, y0, symbol);
	|
	|                if (x0 == x1 && y0 == y1) break;
	|                e2 = err;
	|                if (e2 > -dx) { err -= dy; x0 += sx; }
	|                if (e2 < dy) { err += dx; y0 += sy; }
	|            }
	|        }
	|
	|        #endregion
	|    }
	|    //=======================================================================
	|    //
	|    // HexView.cs: A hexadecimal viewer
	|    //
	|    // TODO:
	|    // - Support searching and highlighting of the search result
	|    // - Bug showing the last line
	|    // 
	|
	|    /// <summary>
	|    /// An hex viewer and editor <see cref=""View""/> over a <see cref=""System.IO.Stream""/>
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    /// <see cref=""HexView""/> provides a hex editor on top of a seekable <see cref=""Stream""/> with the left side showing an hex
	|    /// dump of the values in the <see cref=""Stream""/> and the right side showing the contents (filtered to 
	|    /// non-control sequence ASCII characters).    
	|    /// </para>
	|    /// <para>
	|    /// Users can switch from one side to the other by using the tab key.  
	|    /// </para>
	|    /// <para>
	|    /// To enable editing, set <see cref=""AllowEdits""/> to true. When <see cref=""AllowEdits""/> is true 
	|    /// the user can make changes to the hexadecimal values of the <see cref=""Stream""/>. Any changes are tracked
	|    /// in the <see cref=""Edits""/> property (a <see cref=""SortedDictionary{TKey, TValue}""/>) indicating 
	|    /// the position where the changes were made and the new values. A convenience method, <see cref=""ApplyEdits""/>
	|    /// will apply the edits to the <see cref=""Stream""/>.
	|    /// </para>
	|    /// <para>
	|    /// Control the first byte shown by setting the <see cref=""DisplayStart""/> property 
	|    /// to an offset in the stream.
	|    /// </para>
	|    /// </remarks>
	|    public class HexView : View
	|    {
	|        SortedDictionary<long, byte> edits = new SortedDictionary<long, byte>();
	|        Stream source;
	|        long displayStart, pos;
	|        bool firstNibble, leftSide;
	|
	|        private long position
	|        {
	|            get => pos;
	|            set
	|            {
	|                pos = value;
	|                OnPositionChanged();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Initializes a <see cref=""HexView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <param name=""source"">The <see cref=""Stream""/> to view and edit as hex, this <see cref=""Stream""/> must support seeking, or an exception will be thrown.</param>
	|        public HexView(Stream source) : base()
	|        {
	|            Source = source;
	|            CanFocus = true;
	|            leftSide = true;
	|            firstNibble = true;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.Left, () => MoveLeft());
	|            AddCommand(Command.Right, () => MoveRight());
	|            AddCommand(Command.LineDown, () => MoveDown(bytesPerLine));
	|            AddCommand(Command.LineUp, () => MoveUp(bytesPerLine));
	|            AddCommand(Command.ToggleChecked, () => ToggleSide());
	|            AddCommand(Command.PageUp, () => MoveUp(bytesPerLine * Frame.Height));
	|            AddCommand(Command.PageDown, () => MoveDown(bytesPerLine * Frame.Height));
	|            AddCommand(Command.TopHome, () => MoveHome());
	|            AddCommand(Command.BottomEnd, () => MoveEnd());
	|            AddCommand(Command.StartOfLine, () => MoveStartOfLine());
	|            AddCommand(Command.EndOfLine, () => MoveEndOfLine());
	|            AddCommand(Command.StartOfPage, () => MoveUp(bytesPerLine * ((int)(position - displayStart) / bytesPerLine)));
	|            AddCommand(Command.EndOfPage, () => MoveDown(bytesPerLine * (Frame.Height - 1 - ((int)(position - displayStart) / bytesPerLine))));
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.Enter, Command.ToggleChecked);
	|
	|            AddKeyBinding('v' + Key.AltMask, Command.PageUp);
	|            AddKeyBinding(Key.PageUp, Command.PageUp);
	|
	|            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);
	|            AddKeyBinding(Key.PageDown, Command.PageDown);
	|
	|            AddKeyBinding(Key.Home, Command.TopHome);
	|            AddKeyBinding(Key.End, Command.BottomEnd);
	|            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.StartOfLine);
	|            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.EndOfLine);
	|            AddKeyBinding(Key.CursorUp | Key.CtrlMask, Command.StartOfPage);
	|            AddKeyBinding(Key.CursorDown | Key.CtrlMask, Command.EndOfPage);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a <see cref=""HexView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        public HexView() : this(source: new MemoryStream()) { }
	|
	|        /// <summary>
	|        /// Event to be invoked when an edit is made on the <see cref=""Stream""/>.
	|        /// </summary>
	|        public event Action<KeyValuePair<long, byte>> Edited;
	|
	|        /// <summary>
	|        /// Event to be invoked when the position and cursor position changes.
	|        /// </summary>
	|        public event Action<HexViewEventArgs> PositionChanged;
	|
	|        /// <summary>
	|        /// Sets or gets the <see cref=""Stream""/> the <see cref=""HexView""/> is operating on; the stream must support seeking (<see cref=""Stream.CanSeek""/> == true).
	|        /// </summary>
	|        /// <value>The source.</value>
	|        public Stream Source
	|        {
	|            get => source;
	|            set
	|            {
	|                if (value == null)
	|                    throw new ArgumentNullException(""source"");
	|                if (!value.CanSeek)
	|                    throw new ArgumentException(""The source stream must be seekable (CanSeek property)"", ""source"");
	|                source = value;
	|
	|                if (displayStart > source.Length)
	|                    DisplayStart = 0;
	|                if (position > source.Length)
	|                    position = 0;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        internal void SetDisplayStart(long value)
	|        {
	|            if (value > 0 && value >= source.Length)
	|                displayStart = source.Length - 1;
	|            else if (value < 0)
	|                displayStart = 0;
	|            else
	|                displayStart = value;
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Sets or gets the offset into the <see cref=""Stream""/> that will displayed at the top of the <see cref=""HexView""/>
	|        /// </summary>
	|        /// <value>The display start.</value>
	|        public long DisplayStart
	|        {
	|            get => displayStart;
	|            set
	|            {
	|                position = value;
	|
	|                SetDisplayStart(value);
	|            }
	|        }
	|
	|        const int displayWidth = 9;
	|        const int bsize = 4;
	|        int bpl;
	|        private int bytesPerLine
	|        {
	|            get => bpl;
	|            set
	|            {
	|                bpl = value;
	|                OnPositionChanged();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override Rect Frame
	|        {
	|            get => base.Frame;
	|            set
	|            {
	|                base.Frame = value;
	|
	|                // Small buffers will just show the position, with the bsize field value (4 bytes)
	|                bytesPerLine = bsize;
	|                if (value.Width - displayWidth > 17)
	|                    bytesPerLine = bsize * ((value.Width - displayWidth) / 18);
	|            }
	|        }
	|
	|        //
	|        // This is used to support editing of the buffer on a peer List<>, 
	|        // the offset corresponds to an offset relative to DisplayStart, and
	|        // the buffer contains the contents of a screenful of data, so the 
	|        // offset is relative to the buffer.
	|        //
	|        // 
	|        byte GetData(byte[] buffer, int offset, out bool edited)
	|        {
	|            var pos = DisplayStart + offset;
	|            if (edits.TryGetValue(pos, out byte v))
	|            {
	|                edited = true;
	|                return v;
	|            }
	|            edited = false;
	|            return buffer[offset];
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            Attribute currentAttribute;
	|            var current = ColorScheme.Focus;
	|            Driver.SetAttribute(current);
	|            Move(0, 0);
	|
	|            var frame = Frame;
	|
	|            var nblocks = bytesPerLine / bsize;
	|            var data = new byte[nblocks * bsize * frame.Height];
	|            Source.Position = displayStart;
	|            var n = source.Read(data, 0, data.Length);
	|
	|            int activeColor = ColorScheme.HotNormal;
	|            int trackingColor = ColorScheme.HotFocus;
	|
	|            for (int line = 0; line < frame.Height; line++)
	|            {
	|                var lineRect = new Rect(0, line, frame.Width, 1);
	|                if (!bounds.Contains(lineRect))
	|                    continue;
	|
	|                Move(0, line);
	|                Driver.SetAttribute(ColorScheme.HotNormal);
	|                Driver.AddStr(string.Format(""{0:x8} "", displayStart + line * nblocks * bsize));
	|
	|                currentAttribute = ColorScheme.HotNormal;
	|                SetAttribute(GetNormalColor());
	|
	|                for (int block = 0; block < nblocks; block++)
	|                {
	|                    for (int b = 0; b < bsize; b++)
	|                    {
	|                        var offset = (line * nblocks * bsize) + block * bsize + b;
	|                        var value = GetData(data, offset, out bool edited);
	|                        if (offset + displayStart == position || edited)
	|                            SetAttribute(leftSide ? activeColor : trackingColor);
	|                        else
	|                            SetAttribute(GetNormalColor());
	|
	|                        Driver.AddStr(offset >= n && !edited ? ""  "" : string.Format(""{0:x2}"", value));
	|                        SetAttribute(GetNormalColor());
	|                        Driver.AddRune(' ');
	|                    }
	|                    Driver.AddStr(block + 1 == nblocks ? "" "" : ""| "");
	|                }
	|
	|                for (int bitem = 0; bitem < nblocks * bsize; bitem++)
	|                {
	|                    var offset = line * nblocks * bsize + bitem;
	|                    var b = GetData(data, offset, out bool edited);
	|                    Rune c;
	|                    if (offset >= n && !edited)
	|                        c = ' ';
	|                    else
	|                    {
	|                        if (b < 32)
	|                            c = '.';
	|                        else if (b > 127)
	|                            c = '.';
	|                        else
	|                            c = b;
	|                    }
	|                    if (offset + displayStart == position || edited)
	|                        SetAttribute(leftSide ? trackingColor : activeColor);
	|                    else
	|                        SetAttribute(GetNormalColor());
	|
	|                    Driver.AddRune(c);
	|                }
	|            }
	|
	|            void SetAttribute(Attribute attribute)
	|            {
	|                if (currentAttribute != attribute)
	|                {
	|                    currentAttribute = attribute;
	|                    Driver.SetAttribute(attribute);
	|                }
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            var delta = (int)(position - displayStart);
	|            var line = delta / bytesPerLine;
	|            var item = delta % bytesPerLine;
	|            var block = item / bsize;
	|            var column = (item % bsize) * 3;
	|
	|            if (leftSide)
	|                Move(displayWidth + block * 14 + column + (firstNibble ? 0 : 1), line);
	|            else
	|                Move(displayWidth + (bytesPerLine / bsize) * 14 + item - 1, line);
	|        }
	|
	|        void RedisplayLine(long pos)
	|        {
	|            var delta = (int)(pos - DisplayStart);
	|            var line = delta / bytesPerLine;
	|
	|            SetNeedsDisplay(new Rect(0, line, Frame.Width, 1));
	|        }
	|
	|        bool MoveEndOfLine()
	|        {
	|            position = Math.Min((position / bytesPerLine * bytesPerLine) + bytesPerLine - 1, source.Length);
	|            SetNeedsDisplay();
	|
	|            return true;
	|        }
	|
	|        bool MoveStartOfLine()
	|        {
	|            position = position / bytesPerLine * bytesPerLine;
	|            SetNeedsDisplay();
	|
	|            return true;
	|        }
	|
	|        bool MoveEnd()
	|        {
	|            position = source.Length;
	|            if (position >= (DisplayStart + bytesPerLine * Frame.Height))
	|            {
	|                SetDisplayStart(position);
	|                SetNeedsDisplay();
	|            }
	|            else
	|                RedisplayLine(position);
	|
	|            return true;
	|        }
	|
	|        bool MoveHome()
	|        {
	|            DisplayStart = 0;
	|            SetNeedsDisplay();
	|
	|            return true;
	|        }
	|
	|        bool ToggleSide()
	|        {
	|            leftSide = !leftSide;
	|            RedisplayLine(position);
	|            firstNibble = true;
	|
	|            return true;
	|        }
	|
	|        bool MoveLeft()
	|        {
	|            RedisplayLine(position);
	|            if (leftSide)
	|            {
	|                if (!firstNibble)
	|                {
	|                    firstNibble = true;
	|                    return true;
	|                }
	|                firstNibble = false;
	|            }
	|            if (position == 0)
	|                return true;
	|            if (position - 1 < DisplayStart)
	|            {
	|                SetDisplayStart(displayStart - bytesPerLine);
	|                SetNeedsDisplay();
	|            }
	|            else
	|                RedisplayLine(position);
	|            position--;
	|
	|            return true;
	|        }
	|
	|        bool MoveRight()
	|        {
	|            RedisplayLine(position);
	|            if (leftSide)
	|            {
	|                if (firstNibble)
	|                {
	|                    firstNibble = false;
	|                    return true;
	|                }
	|                else
	|                    firstNibble = true;
	|            }
	|            if (position < source.Length)
	|                position++;
	|            if (position >= (DisplayStart + bytesPerLine * Frame.Height))
	|            {
	|                SetDisplayStart(DisplayStart + bytesPerLine);
	|                SetNeedsDisplay();
	|            }
	|            else
	|                RedisplayLine(position);
	|
	|            return true;
	|        }
	|
	|        bool MoveUp(int bytes)
	|        {
	|            RedisplayLine(position);
	|            if (position - bytes > -1)
	|                position -= bytes;
	|            if (position < DisplayStart)
	|            {
	|                SetDisplayStart(DisplayStart - bytes);
	|                SetNeedsDisplay();
	|            }
	|            else
	|                RedisplayLine(position);
	|
	|            return true;
	|        }
	|
	|        bool MoveDown(int bytes)
	|        {
	|            RedisplayLine(position);
	|            if (position + bytes < source.Length)
	|                position += bytes;
	|            else if ((bytes == bytesPerLine * Frame.Height && source.Length >= (DisplayStart + bytesPerLine * Frame.Height))
	|                || (bytes <= (bytesPerLine * Frame.Height - bytesPerLine) && source.Length <= (DisplayStart + bytesPerLine * Frame.Height)))
	|            {
	|                var p = position;
	|                while (p + bytesPerLine < source.Length)
	|                {
	|                    p += bytesPerLine;
	|                }
	|                position = p;
	|            }
	|            if (position >= (DisplayStart + bytesPerLine * Frame.Height))
	|            {
	|                SetDisplayStart(DisplayStart + bytes);
	|                SetNeedsDisplay();
	|            }
	|            else
	|                RedisplayLine(position);
	|
	|            return true;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            var result = InvokeKeybindings(keyEvent);
	|            if (result != null)
	|                return (bool)result;
	|
	|            if (!AllowEdits)
	|                return false;
	|
	|            // Ignore control characters and other special keys
	|            if (keyEvent.Key < Key.Space || keyEvent.Key > Key.CharMask)
	|                return false;
	|
	|            if (leftSide)
	|            {
	|                int value;
	|                var k = (char)keyEvent.Key;
	|                if (k >= 'A' && k <= 'F')
	|                    value = k - 'A' + 10;
	|                else if (k >= 'a' && k <= 'f')
	|                    value = k - 'a' + 10;
	|                else if (k >= '0' && k <= '9')
	|                    value = k - '0';
	|                else
	|                    return false;
	|
	|                byte b;
	|                if (!edits.TryGetValue(position, out b))
	|                {
	|                    source.Position = position;
	|                    b = (byte)source.ReadByte();
	|                }
	|                RedisplayLine(position);
	|                if (firstNibble)
	|                {
	|                    firstNibble = false;
	|                    b = (byte)(b & 0xf | (value << bsize));
	|                    edits[position] = b;
	|                    OnEdited(new KeyValuePair<long, byte>(position, edits[position]));
	|                }
	|                else
	|                {
	|                    b = (byte)(b & 0xf0 | value);
	|                    edits[position] = b;
	|                    OnEdited(new KeyValuePair<long, byte>(position, edits[position]));
	|                    MoveRight();
	|                }
	|                return true;
	|            }
	|            else
	|                return false;
	|        }
	|
	|        /// <summary>
	|        /// Method used to invoke the <see cref=""Edited""/> event passing the <see cref=""KeyValuePair{TKey, TValue}""/>.
	|        /// </summary>
	|        /// <param name=""keyValuePair"">The key value pair.</param>
	|        public virtual void OnEdited(KeyValuePair<long, byte> keyValuePair)
	|        {
	|            Edited?.Invoke(keyValuePair);
	|        }
	|
	|        /// <summary>
	|        /// Method used to invoke the <see cref=""PositionChanged""/> event passing the <see cref=""HexViewEventArgs""/> arguments.
	|        /// </summary>
	|        public virtual void OnPositionChanged()
	|        {
	|            PositionChanged?.Invoke(new HexViewEventArgs(Position, CursorPosition, BytesPerLine));
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) && !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked)
	|                && !me.Flags.HasFlag(MouseFlags.WheeledDown) && !me.Flags.HasFlag(MouseFlags.WheeledUp))
	|                return false;
	|
	|            if (!HasFocus)
	|                SetFocus();
	|
	|            if (me.Flags == MouseFlags.WheeledDown)
	|            {
	|                DisplayStart = Math.Min(DisplayStart + bytesPerLine, source.Length);
	|                return true;
	|            }
	|
	|            if (me.Flags == MouseFlags.WheeledUp)
	|            {
	|                DisplayStart = Math.Max(DisplayStart - bytesPerLine, 0);
	|                return true;
	|            }
	|
	|            if (me.X < displayWidth)
	|                return true;
	|            var nblocks = bytesPerLine / bsize;
	|            var blocksSize = nblocks * 14;
	|            var blocksRightOffset = displayWidth + blocksSize - 1;
	|            if (me.X > blocksRightOffset + bytesPerLine - 1)
	|                return true;
	|            leftSide = me.X >= blocksRightOffset;
	|            var lineStart = (me.Y * bytesPerLine) + displayStart;
	|            var x = me.X - displayWidth + 1;
	|            var block = x / 14;
	|            x -= block * 2;
	|            var empty = x % 3;
	|            var item = x / 3;
	|            if (!leftSide && item > 0 && (empty == 0 || x == (block * 14) + 14 - 1 - (block * 2)))
	|                return true;
	|            firstNibble = true;
	|            if (leftSide)
	|                position = Math.Min(lineStart + me.X - blocksRightOffset, source.Length);
	|            else
	|                position = Math.Min(lineStart + item, source.Length);
	|
	|            if (me.Flags == MouseFlags.Button1DoubleClicked)
	|            {
	|                leftSide = !leftSide;
	|                if (leftSide)
	|                    firstNibble = empty == 1;
	|                else
	|                    firstNibble = true;
	|            }
	|            SetNeedsDisplay();
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets whether this <see cref=""HexView""/> allow editing of the <see cref=""Stream""/> 
	|        /// of the underlying <see cref=""Stream""/>.
	|        /// </summary>
	|        /// <value><c>true</c> if allow edits; otherwise, <c>false</c>.</value>
	|        public bool AllowEdits { get; set; } = true;
	|
	|        /// <summary>
	|        /// Gets a <see cref=""SortedDictionary{TKey, TValue}""/> describing the edits done to the <see cref=""HexView""/>. 
	|        /// Each Key indicates an offset where an edit was made and the Value is the changed byte.
	|        /// </summary>
	|        /// <value>The edits.</value>
	|        public IReadOnlyDictionary<long, byte> Edits => edits;
	|
	|        /// <summary>
	|        /// Gets the current character position starting at one, related to the <see cref=""Stream""/>.
	|        /// </summary>
	|        public long Position => position + 1;
	|
	|        /// <summary>
	|        /// Gets the current cursor position starting at one for both, line and column.
	|        /// </summary>
	|        public Point CursorPosition
	|        {
	|            get
	|            {
	|                var delta = (int)position;
	|                var line = delta / bytesPerLine + 1;
	|                var item = delta % bytesPerLine + 1;
	|
	|                return new Point(item, line);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The bytes length per line.
	|        /// </summary>
	|        public int BytesPerLine => bytesPerLine;
	|
	|        /// <summary>
	|        /// This method applies and edits made to the <see cref=""Stream""/> and resets the 
	|        /// contents of the <see cref=""Edits""/> property.
	|        /// </summary>
	|        /// <param name=""stream"">If provided also applies the changes to the passed <see cref=""Stream""/></param>.
	|        public void ApplyEdits(Stream stream = null)
	|        {
	|            foreach (var kv in edits)
	|            {
	|                source.Position = kv.Key;
	|                source.WriteByte(kv.Value);
	|                source.Flush();
	|                if (stream != null)
	|                {
	|                    stream.Position = kv.Key;
	|                    stream.WriteByte(kv.Value);
	|                    stream.Flush();
	|                }
	|            }
	|            edits = new SortedDictionary<long, byte>();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// This method discards the edits made to the <see cref=""Stream""/> by resetting the 
	|        /// contents of the <see cref=""Edits""/> property.
	|        /// </summary>
	|        public void DiscardEdits()
	|        {
	|            edits = new SortedDictionary<long, byte>();
	|        }
	|
	|        private CursorVisibility desiredCursorVisibility = CursorVisibility.Default;
	|
	|        /// <summary>
	|        /// Get / Set the wished cursor when the field is focused
	|        /// </summary>
	|        public CursorVisibility DesiredCursorVisibility
	|        {
	|            get => desiredCursorVisibility;
	|            set
	|            {
	|                if (desiredCursorVisibility != value && HasFocus)
	|                {
	|                    Application.Driver.SetCursorVisibility(value);
	|                }
	|
	|                desiredCursorVisibility = value;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        /// <summary>
	|        /// Defines the event arguments for <see cref=""PositionChanged""/> event.
	|        /// </summary>
	|        public class HexViewEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// Gets the current character position starting at one, related to the <see cref=""Stream""/>.
	|            /// </summary>
	|            public long Position { get; private set; }
	|            /// <summary>
	|            /// Gets the current cursor position starting at one for both, line and column.
	|            /// </summary>
	|            public Point CursorPosition { get; private set; }
	|
	|            /// <summary>
	|            /// The bytes length per line.
	|            /// </summary>
	|            public int BytesPerLine { get; private set; }
	|
	|            /// <summary>
	|            /// Initializes a new instance of <see cref=""HexViewEventArgs""/>
	|            /// </summary>
	|            /// <param name=""pos"">The character position.</param>
	|            /// <param name=""cursor"">The cursor position.</param>
	|            /// <param name=""lineLength"">Line bytes length.</param>
	|            public HexViewEventArgs(long pos, Point cursor, int lineLength)
	|            {
	|                Position = pos;
	|                CursorPosition = cursor;
	|                BytesPerLine = lineLength;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Renders an overlay on another view at a given point that allows selecting
	|    /// from a range of 'autocomplete' options.
	|    /// </summary>
	|    public interface IAutocomplete
	|    {
	|
	|        /// <summary>
	|        /// The host control that will use autocomplete.
	|        /// </summary>
	|        View HostControl { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets where the popup will be displayed.
	|        /// </summary>
	|        bool PopupInsideContainer { get; set; }
	|
	|        /// <summary>
	|        /// The maximum width of the autocomplete dropdown
	|        /// </summary>
	|        int MaxWidth { get; set; }
	|
	|        /// <summary>
	|        /// The maximum number of visible rows in the autocomplete dropdown to render
	|        /// </summary>
	|        int MaxHeight { get; set; }
	|
	|        /// <summary>
	|        /// True if the autocomplete should be considered open and visible
	|        /// </summary>
	|        bool Visible { get; set; }
	|
	|        /// <summary>
	|        /// The strings that form the current list of suggestions to render
	|        /// based on what the user has typed so far.
	|        /// </summary>
	|        ReadOnlyCollection<string> Suggestions { get; set; }
	|
	|        /// <summary>
	|        /// The full set of all strings that can be suggested.
	|        /// </summary>
	|        List<string> AllSuggestions { get; set; }
	|
	|        /// <summary>
	|        /// The currently selected index into <see cref=""Suggestions""/> that the user has highlighted
	|        /// </summary>
	|        int SelectedIdx { get; set; }
	|
	|        /// <summary>
	|        /// The colors to use to render the overlay.  Accessing this property before
	|        /// the Application has been initialized will cause an error
	|        /// </summary>
	|        ColorScheme ColorScheme { get; set; }
	|
	|        /// <summary>
	|        /// The key that the user must press to accept the currently selected autocomplete suggestion
	|        /// </summary>
	|        Key SelectionKey { get; set; }
	|
	|        /// <summary>
	|        /// The key that the user can press to close the currently popped autocomplete menu
	|        /// </summary>
	|        Key CloseKey { get; set; }
	|
	|        /// <summary>
	|        /// The key that the user can press to reopen the currently popped autocomplete menu
	|        /// </summary>
	|        Key Reopen { get; set; }
	|
	|        /// <summary>
	|        /// Renders the autocomplete dialog inside the given <see cref=""HostControl""/> at the
	|        /// given point.
	|        /// </summary>
	|        /// <param name=""renderAt""></param>
	|        void RenderOverlay(Point renderAt);
	|
	|
	|        /// <summary>
	|        /// Handle key events before <see cref=""HostControl""/> e.g. to make key events like
	|        /// up/down apply to the autocomplete control instead of changing the cursor position in
	|        /// the underlying text view.
	|        /// </summary>
	|        /// <param name=""kb"">The key event.</param>
	|        /// <returns><c>true</c>if the key can be handled <c>false</c>otherwise.</returns>
	|        bool ProcessKey(KeyEvent kb);
	|
	|        /// <summary>
	|        /// Handle mouse events before <see cref=""HostControl""/> e.g. to make mouse events like
	|        /// report/click apply to the autocomplete control instead of changing the cursor position in
	|        /// the underlying text view.
	|        /// </summary>
	|        /// <param name=""me"">The mouse event.</param>
	|        /// <param name=""fromHost"">If was called from the popup or from the host.</param>
	|        /// <returns><c>true</c>if the mouse can be handled <c>false</c>otherwise.</returns>
	|        bool MouseEvent(MouseEvent me, bool fromHost = false);
	|
	|        /// <summary>
	|        /// Clears <see cref=""Suggestions""/>
	|        /// </summary>
	|        void ClearSuggestions();
	|
	|        /// <summary>
	|        /// Populates <see cref=""Suggestions""/> with all strings in <see cref=""AllSuggestions""/> that
	|        /// match with the current cursor position/text in the <see cref=""HostControl""/>.
	|        /// </summary>
	|        /// <param name=""columnOffset"">The column offset. Current (zero - default), left (negative), right (positive).</param>
	|        void GenerateSuggestions(int columnOffset = 0);
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Definition to interact with the OS clipboard.
	|    /// </summary>
	|    public interface IClipboard
	|    {
	|        /// <summary>
	|        /// Returns true if the environmental dependencies are in place to interact with the OS clipboard.
	|        /// </summary>
	|        bool IsSupported { get; }
	|
	|        /// <summary>
	|        /// Get the operation system clipboard.
	|        /// </summary>
	|        /// <exception cref=""NotSupportedException"">Thrown if it was not possible to read the clipboard contents.</exception>
	|        string GetClipboardData();
	|
	|        /// <summary>
	|        /// Gets the operation system clipboard if possible.
	|        /// </summary>
	|        /// <param name=""result"">Clipboard contents read</param>
	|        /// <returns>true if it was possible to read the OS clipboard.</returns>
	|        bool TryGetClipboardData(out string result);
	|
	|        /// <summary>
	|        /// Sets the operation system clipboard.
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        /// <exception cref=""NotSupportedException"">Thrown if it was not possible to set the clipboard contents.</exception>
	|        void SetClipboardData(string text);
	|
	|        /// <summary>
	|        /// Sets the operation system clipboard if possible.
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        /// <returns>True if the clipboard content was set successfully.</returns>
	|        bool TrySetClipboardData(string text);
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Provides filtering for a <see cref=""TreeView""/>.
	|    /// </summary>
	|    public interface ITreeViewFilter<T> where T : class
	|    {
	|
	|        /// <summary>
	|        /// Return <see langword=""true""/> if the <paramref name=""model""/> should
	|        /// be included in the tree.
	|        /// </summary>
	|        bool IsMatch(T model);
	|    }
	|    //=======================================================================
	|    //
	|    // Label.cs: Label control
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    /// The Label <see cref=""View""/> displays a string at a given position and supports multiple lines separated by newline characters.
	|    /// Multi-line Labels support word wrap.
	|    /// </summary>
	|    /// <remarks>
	|    /// The <see cref=""Label""/> view is functionality identical to <see cref=""View""/> and is included for API backwards compatibility.
	|    /// </remarks>
	|    public class Label : View
	|    {
	|        /// <inheritdoc/>
	|        public Label()
	|        {
	|            Initialize();
	|        }
	|
	|        /// <inheritdoc/>
	|        public Label(Rect frame, bool autosize = false) : base(frame)
	|        {
	|            Initialize(autosize);
	|        }
	|
	|        /// <inheritdoc/>
	|        public Label(ustring text, bool autosize = true) : base(text)
	|        {
	|            Initialize(autosize);
	|        }
	|
	|        /// <inheritdoc/>
	|        public Label(Rect rect, ustring text, bool autosize = false) : base(rect, text)
	|        {
	|            Initialize(autosize);
	|        }
	|
	|        /// <inheritdoc/>
	|        public Label(int x, int y, ustring text, bool autosize = true) : base(x, y, text)
	|        {
	|            Initialize(autosize);
	|        }
	|
	|        /// <inheritdoc/>
	|        public Label(ustring text, TextDirection direction, bool autosize = true)
	|            : base(text, direction)
	|        {
	|            Initialize(autosize);
	|        }
	|
	|        void Initialize(bool autosize = true)
	|        {
	|            AutoSize = autosize;
	|        }
	|
	|        /// <summary>
	|        ///   Clicked <see cref=""Action""/>, raised when the user clicks the primary mouse button within the Bounds of this <see cref=""View""/>
	|        ///   or if the user presses the action key while this view is focused. (TODO: IsDefault)
	|        /// </summary>
	|        /// <remarks>
	|        ///   Client code can hook up to this event, it is
	|        ///   raised when the button is activated either with
	|        ///   the mouse or the keyboard.
	|        /// </remarks>
	|        public event Action Clicked;
	|
	|        ///// <inheritdoc/>
	|        //public new ustring Text {
	|        //	get => base.Text;
	|        //	set {
	|        //		base.Text = value;
	|        //		// This supports Label auto-sizing when Text changes (preserving backwards compat behavior)
	|        //		if (Frame.Height == 1 && !ustring.IsNullOrEmpty (value)) {
	|        //			int w = Text.RuneCount;
	|        //			Width = w;
	|        //			Frame = new Rect (Frame.Location, new Size (w, Frame.Height));
	|        //		}
	|        //		SetNeedsDisplay ();
	|        //	}
	|        //}
	|
	|        /// <summary>
	|        /// Method invoked when a mouse event is generated
	|        /// </summary>
	|        /// <param name=""mouseEvent""></param>
	|        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
	|        public override bool OnMouseEvent(MouseEvent mouseEvent)
	|        {
	|            MouseEventArgs args = new MouseEventArgs(mouseEvent);
	|            if (OnMouseClick(args))
	|                return true;
	|            if (MouseEvent(mouseEvent))
	|                return true;
	|
	|            if (mouseEvent.Flags == MouseFlags.Button1Clicked)
	|            {
	|                if (!HasFocus && SuperView != null)
	|                {
	|                    if (!SuperView.HasFocus)
	|                    {
	|                        SuperView.SetFocus();
	|                    }
	|                    SetFocus();
	|                    SetNeedsDisplay();
	|                }
	|
	|                OnClicked();
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessHotKey(KeyEvent ke)
	|        {
	|            if (ke.Key == (Key.AltMask | HotKey))
	|            {
	|                if (!HasFocus)
	|                {
	|                    SetFocus();
	|                }
	|                OnClicked();
	|                return true;
	|            }
	|            return base.ProcessHotKey(ke);
	|        }
	|
	|        /// <summary>
	|        /// Virtual method to invoke the <see cref=""Clicked""/> event.
	|        /// </summary>
	|        public virtual void OnClicked()
	|        {
	|            Clicked?.Invoke();
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// A straight line control either horizontal or vertical
	|    /// </summary>
	|    public class LineView : View
	|    {
	|
	|        /// <summary>
	|        /// The rune to display at the start of the line (left end of horizontal line or top end of vertical)
	|        /// If not specified then <see cref=""LineRune""/> is used
	|        /// </summary>
	|        public Rune? StartingAnchor { get; set; }
	|
	|        /// <summary>
	|        /// The rune to display at the end of the line (right end of horizontal line or bottom end of vertical).
	|        /// If not specified then <see cref=""LineRune""/> is used
	|        /// </summary>
	|        public Rune? EndingAnchor { get; set; }
	|
	|        /// <summary>
	|        /// The symbol to use for drawing the line
	|        /// </summary>
	|        public Rune LineRune { get; set; }
	|
	|        /// <summary>
	|        /// The direction of the line.  If you change this you will need to manually update the Width/Height
	|        /// of the control to cover a relevant area based on the new direction.
	|        /// </summary>
	|        public Orientation Orientation { get; set; }
	|
	|        /// <summary>
	|        /// Creates a horizontal line
	|        /// </summary>
	|        public LineView() : this(Orientation.Horizontal)
	|        {
	|
	|        }
	|
	|        /// <summary>
	|        /// Creates a horizontal or vertical line based on <paramref name=""orientation""/>
	|        /// </summary>
	|        public LineView(Orientation orientation)
	|        {
	|            CanFocus = false;
	|
	|            switch (orientation)
	|            {
	|                case Orientation.Horizontal:
	|                    Height = 1;
	|                    Width = Dim.Fill();
	|                    LineRune = Driver.HLine;
	|
	|                    break;
	|                case Orientation.Vertical:
	|                    Height = Dim.Fill();
	|                    Width = 1;
	|                    LineRune = Driver.VLine;
	|                    break;
	|                default:
	|                    throw new ArgumentException($""Unknown Orientation {orientation}"");
	|            }
	|            Orientation = orientation;
	|        }
	|
	|        /// <summary>
	|        /// Draws the line including any starting/ending anchors
	|        /// </summary>
	|        /// <param name=""bounds""></param>
	|        public override void Redraw(Rect bounds)
	|        {
	|            base.Redraw(bounds);
	|
	|            Move(0, 0);
	|            Driver.SetAttribute(GetNormalColor());
	|
	|            var hLineWidth = Math.Max(1, Rune.ColumnWidth(Driver.HLine));
	|
	|            var dEnd = Orientation == Orientation.Horizontal ?
	|                bounds.Width :
	|                bounds.Height;
	|
	|            for (int d = 0; d < dEnd; d += hLineWidth)
	|            {
	|
	|                if (Orientation == Orientation.Horizontal)
	|                {
	|                    Move(d, 0);
	|                }
	|                else
	|                {
	|                    Move(0, d);
	|                }
	|
	|                Rune rune = LineRune;
	|
	|                if (d == 0)
	|                {
	|                    rune = StartingAnchor ?? LineRune;
	|                }
	|                else
	|                if (d == dEnd - 1)
	|                {
	|                    rune = EndingAnchor ?? LineRune;
	|                }
	|
	|                Driver.AddRune(rune);
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Implement <see cref=""IListDataSource""/> to provide custom rendering for a <see cref=""ListView""/>.
	|    /// </summary>
	|    public interface IListDataSource
	|    {
	|        /// <summary>
	|        /// Returns the number of elements to display
	|        /// </summary>
	|        int Count { get; }
	|
	|        /// <summary>
	|        /// Returns the maximum length of elements to display
	|        /// </summary>
	|        int Length { get; }
	|
	|        /// <summary>
	|        /// This method is invoked to render a specified item, the method should cover the entire provided width.
	|        /// </summary>
	|        /// <returns>The render.</returns>
	|        /// <param name=""container"">The list view to render.</param>
	|        /// <param name=""driver"">The console driver to render.</param>
	|        /// <param name=""selected"">Describes whether the item being rendered is currently selected by the user.</param>
	|        /// <param name=""item"">The index of the item to render, zero for the first item and so on.</param>
	|        /// <param name=""col"">The column where the rendering will start</param>
	|        /// <param name=""line"">The line where the rendering will be done.</param>
	|        /// <param name=""width"">The width that must be filled out.</param>
	|        /// <param name=""start"">The index of the string to be displayed.</param>
	|        /// <remarks>
	|        ///   The default color will be set before this method is invoked, and will be based on whether the item is selected or not.
	|        /// </remarks>
	|        void Render(ListView container, ConsoleDriver driver, bool selected, int item, int col, int line, int width, int start = 0);
	|
	|        /// <summary>
	|        /// Should return whether the specified item is currently marked.
	|        /// </summary>
	|        /// <returns><see langword=""true""/>, if marked, <see langword=""false""/> otherwise.</returns>
	|        /// <param name=""item"">Item index.</param>
	|        bool IsMarked(int item);
	|
	|        /// <summary>
	|        /// Flags the item as marked.
	|        /// </summary>
	|        /// <param name=""item"">Item index.</param>
	|        /// <param name=""value"">If set to <see langword=""true""/> value.</param>
	|        void SetMark(int item, bool value);
	|
	|        /// <summary>
	|        /// Return the source as IList.
	|        /// </summary>
	|        /// <returns></returns>
	|        IList ToList();
	|    }
	|
	|    /// <summary>
	|    /// ListView <see cref=""View""/> renders a scrollable list of data where each item can be activated to perform an action.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   The <see cref=""ListView""/> displays lists of data and allows the user to scroll through the data.
	|    ///   Items in the can be activated firing an event (with the ENTER key or a mouse double-click). 
	|    ///   If the <see cref=""AllowsMarking""/> property is true, elements of the list can be marked by the user.
	|    /// </para>
	|    /// <para>
	|    ///   By default <see cref=""ListView""/> uses <see cref=""object.ToString""/> to render the items of any
	|    ///   <see cref=""IList""/> object (e.g. arrays, <see cref=""List{T}""/>,
	|    ///   and other collections). Alternatively, an object that implements <see cref=""IListDataSource""/>
	|    ///   can be provided giving full control of what is rendered.
	|    /// </para>
	|    /// <para>
	|    ///   <see cref=""ListView""/> can display any object that implements the <see cref=""IList""/> interface.
	|    ///   <see cref=""string""/> values are converted into <see cref=""ustring""/> values before rendering, and other values are
	|    ///   converted into <see cref=""string""/> by calling <see cref=""object.ToString""/> and then converting to <see cref=""ustring""/> .
	|    /// </para>
	|    /// <para>
	|    ///   To change the contents of the ListView, set the <see cref=""Source""/> property (when 
	|    ///   providing custom rendering via <see cref=""IListDataSource""/>) or call <see cref=""SetSource""/>
	|    ///   an <see cref=""IList""/> is being used.
	|    /// </para>
	|    /// <para>
	|    ///   When <see cref=""AllowsMarking""/> is set to true the rendering will prefix the rendered items with
	|    ///   [x] or [ ] and bind the SPACE key to toggle the selection. To implement a different
	|    ///   marking style set <see cref=""AllowsMarking""/> to false and implement custom rendering.
	|    /// </para>
	|    /// <para>
	|    ///   Searching the ListView with the keyboard is supported. Users type the
	|    ///   first characters of an item, and the first item that starts with what the user types will be selected.
	|    /// </para>
	|    /// </remarks>
	|    public class ListView : View
	|    {
	|        int top, left;
	|        int selected;
	|
	|        IListDataSource source;
	|        /// <summary>
	|        /// Gets or sets the <see cref=""IListDataSource""/> backing this <see cref=""ListView""/>, enabling custom rendering.
	|        /// </summary>
	|        /// <value>The source.</value>
	|        /// <remarks>
	|        ///  Use <see cref=""SetSource""/> to set a new <see cref=""IList""/> source.
	|        /// </remarks>
	|        public IListDataSource Source
	|        {
	|            get => source;
	|            set
	|            {
	|                source = value;
	|                KeystrokeNavigator.Collection = source?.ToList()?.Cast<object>();
	|                top = 0;
	|                selected = 0;
	|                lastSelectedItem = -1;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Sets the source of the <see cref=""ListView""/> to an <see cref=""IList""/>.
	|        /// </summary>
	|        /// <value>An object implementing the IList interface.</value>
	|        /// <remarks>
	|        ///  Use the <see cref=""Source""/> property to set a new <see cref=""IListDataSource""/> source and use custome rendering.
	|        /// </remarks>
	|        public void SetSource(IList source)
	|        {
	|            if (source == null && (Source == null || !(Source is ListWrapper)))
	|                Source = null;
	|            else
	|            {
	|                Source = MakeWrapper(source);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Sets the source to an <see cref=""IList""/> value asynchronously.
	|        /// </summary>
	|        /// <value>An item implementing the IList interface.</value>
	|        /// <remarks>
	|        ///  Use the <see cref=""Source""/> property to set a new <see cref=""IListDataSource""/> source and use custom rendering.
	|        /// </remarks>
	|        public Task SetSourceAsync(IList source)
	|        {
	|            return Task.Factory.StartNew(() =>
	|            {
	|                if (source == null && (Source == null || !(Source is ListWrapper)))
	|                    Source = null;
	|                else
	|                    Source = MakeWrapper(source);
	|                return source;
	|            }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);
	|        }
	|
	|        bool allowsMarking;
	|        /// <summary>
	|        /// Gets or sets whether this <see cref=""ListView""/> allows items to be marked.
	|        /// </summary>
	|        /// <value>Set to <see langword=""true""/> to allow marking elements of the list.</value>
	|        /// <remarks>
	|        /// If set to <see langword=""true""/>, <see cref=""ListView""/> will render items marked items with ""[x]"", and unmarked items with ""[ ]""
	|        /// spaces. SPACE key will toggle marking. The default is <see langword=""false""/>.
	|        /// </remarks>
	|        public bool AllowsMarking
	|        {
	|            get => allowsMarking;
	|            set
	|            {
	|                allowsMarking = value;
	|                if (allowsMarking)
	|                {
	|                    AddKeyBinding(Key.Space, Command.ToggleChecked);
	|                }
	|                else
	|                {
	|                    ClearKeybinding(Key.Space);
	|                }
	|
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// If set to <see langword=""true""/> more than one item can be selected. If <see langword=""false""/> selecting
	|        /// an item will cause all others to be un-selected. The default is <see langword=""false""/>.
	|        /// </summary>
	|        public bool AllowsMultipleSelection
	|        {
	|            get => allowsMultipleSelection;
	|            set
	|            {
	|                allowsMultipleSelection = value;
	|                if (Source != null && !allowsMultipleSelection)
	|                {
	|                    // Clear all selections except selected 
	|                    for (int i = 0; i < Source.Count; i++)
	|                    {
	|                        if (Source.IsMarked(i) && i != selected)
	|                        {
	|                            Source.SetMark(i, false);
	|                        }
	|                    }
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the item that is displayed at the top of the <see cref=""ListView""/>.
	|        /// </summary>
	|        /// <value>The top item.</value>
	|        public int TopItem
	|        {
	|            get => top;
	|            set
	|            {
	|                if (source == null)
	|                    return;
	|
	|                if (value < 0 || (source.Count > 0 && value >= source.Count))
	|                    throw new ArgumentException(""value"");
	|                top = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the leftmost column that is currently visible (when scrolling horizontally).
	|        /// </summary>
	|        /// <value>The left position.</value>
	|        public int LeftItem
	|        {
	|            get => left;
	|            set
	|            {
	|                if (source == null)
	|                    return;
	|
	|                if (value < 0 || (Maxlength > 0 && value >= Maxlength))
	|                    throw new ArgumentException(""value"");
	|                left = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the widest item in the list.
	|        /// </summary>
	|        public int Maxlength => (source?.Length) ?? 0;
	|
	|        /// <summary>
	|        /// Gets or sets the index of the currently selected item.
	|        /// </summary>
	|        /// <value>The selected item.</value>
	|        public int SelectedItem
	|        {
	|            get => selected;
	|            set
	|            {
	|                if (source == null || source.Count == 0)
	|                {
	|                    return;
	|                }
	|                if (value < 0 || value >= source.Count)
	|                {
	|                    throw new ArgumentException(""value"");
	|                }
	|                selected = value;
	|                OnSelectedChanged();
	|            }
	|        }
	|
	|        static IListDataSource MakeWrapper(IList source)
	|        {
	|            return new ListWrapper(source);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ListView""/> that will display the 
	|        /// contents of the object implementing the <see cref=""IList""/> interface, 
	|        /// with relative positioning.
	|        /// </summary>
	|        /// <param name=""source"">An <see cref=""IList""/> data source, if the elements are strings or ustrings, 
	|        /// the string is rendered, otherwise the ToString() method is invoked on the result.</param>
	|        public ListView(IList source) : this(MakeWrapper(source))
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ListView""/> that will display the provided data source, using relative positioning.
	|        /// </summary>
	|        /// <param name=""source""><see cref=""IListDataSource""/> object that provides a mechanism to render the data. 
	|        /// The number of elements on the collection should not change, if you must change, set 
	|        /// the ""Source"" property to reset the internal settings of the ListView.</param>
	|        public ListView(IListDataSource source) : base()
	|        {
	|            this.source = source;
	|            Initialize();
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ListView""/>. Set the <see cref=""Source""/> property to display something.
	|        /// </summary>
	|        public ListView() : base()
	|        {
	|            Initialize();
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ListView""/> that will display the contents of the object implementing the <see cref=""IList""/> interface with an absolute position.
	|        /// </summary>
	|        /// <param name=""rect"">Frame for the listview.</param>
	|        /// <param name=""source"">An IList data source, if the elements of the IList are strings or ustrings, 
	|        /// the string is rendered, otherwise the ToString() method is invoked on the result.</param>
	|        public ListView(Rect rect, IList source) : this(rect, MakeWrapper(source))
	|        {
	|            Initialize();
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ListView""/> with the provided data source and an absolute position
	|        /// </summary>
	|        /// <param name=""rect"">Frame for the listview.</param>
	|        /// <param name=""source"">IListDataSource object that provides a mechanism to render the data. 
	|        /// The number of elements on the collection should not change, if you must change, 
	|        /// set the ""Source"" property to reset the internal settings of the ListView.</param>
	|        public ListView(Rect rect, IListDataSource source) : base(rect)
	|        {
	|            this.source = source;
	|            Initialize();
	|        }
	|
	|        void Initialize()
	|        {
	|            Source = source;
	|            CanFocus = true;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.LineUp, () => MoveUp());
	|            AddCommand(Command.LineDown, () => MoveDown());
	|            AddCommand(Command.ScrollUp, () => ScrollUp(1));
	|            AddCommand(Command.ScrollDown, () => ScrollDown(1));
	|            AddCommand(Command.PageUp, () => MovePageUp());
	|            AddCommand(Command.PageDown, () => MovePageDown());
	|            AddCommand(Command.TopHome, () => MoveHome());
	|            AddCommand(Command.BottomEnd, () => MoveEnd());
	|            AddCommand(Command.OpenSelectedItem, () => OnOpenSelectedItem());
	|            AddCommand(Command.ToggleChecked, () => MarkUnmarkRow());
	|
	|            // Default keybindings for all ListViews
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.P | Key.CtrlMask, Command.LineUp);
	|
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|            AddKeyBinding(Key.N | Key.CtrlMask, Command.LineDown);
	|
	|            AddKeyBinding(Key.PageUp, Command.PageUp);
	|
	|            AddKeyBinding(Key.PageDown, Command.PageDown);
	|            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);
	|
	|            AddKeyBinding(Key.Home, Command.TopHome);
	|
	|            AddKeyBinding(Key.End, Command.BottomEnd);
	|
	|            AddKeyBinding(Key.Enter, Command.OpenSelectedItem);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            var current = ColorScheme.Focus;
	|            Driver.SetAttribute(current);
	|            Move(0, 0);
	|            var f = Frame;
	|            var item = top;
	|            bool focused = HasFocus;
	|            int col = allowsMarking ? 2 : 0;
	|            int start = left;
	|
	|            for (int row = 0; row < f.Height; row++, item++)
	|            {
	|                bool isSelected = item == selected;
	|
	|                var newcolor = focused ? (isSelected ? ColorScheme.Focus : GetNormalColor())
	|                               : (isSelected ? ColorScheme.HotNormal : GetNormalColor());
	|
	|                if (newcolor != current)
	|                {
	|                    Driver.SetAttribute(newcolor);
	|                    current = newcolor;
	|                }
	|
	|                Move(0, row);
	|                if (source == null || item >= source.Count)
	|                {
	|                    for (int c = 0; c < f.Width; c++)
	|                        Driver.AddRune(' ');
	|                }
	|                else
	|                {
	|                    var rowEventArgs = new ListViewRowEventArgs(item);
	|                    OnRowRender(rowEventArgs);
	|                    if (rowEventArgs.RowAttribute != null && current != rowEventArgs.RowAttribute)
	|                    {
	|                        current = (Attribute)rowEventArgs.RowAttribute;
	|                        Driver.SetAttribute(current);
	|                    }
	|                    if (allowsMarking)
	|                    {
	|                        Driver.AddRune(source.IsMarked(item) ? (AllowsMultipleSelection ? Driver.Checked : Driver.Selected) :
	|                            (AllowsMultipleSelection ? Driver.UnChecked : Driver.UnSelected));
	|                        Driver.AddRune(' ');
	|                    }
	|                    Source.Render(this, Driver, isSelected, item, col, row, f.Width - col, start);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This event is raised when the selected item in the <see cref=""ListView""/> has changed.
	|        /// </summary>
	|        public event Action<ListViewItemEventArgs> SelectedItemChanged;
	|
	|        /// <summary>
	|        /// This event is raised when the user Double Clicks on an item or presses ENTER to open the selected item.
	|        /// </summary>
	|        public event Action<ListViewItemEventArgs> OpenSelectedItem;
	|
	|        /// <summary>
	|        /// This event is invoked when this <see cref=""ListView""/> is being drawn before rendering.
	|        /// </summary>
	|        public event Action<ListViewRowEventArgs> RowRender;
	|
	|        /// <summary>
	|        /// Gets the <see cref=""CollectionNavigator""/> that searches the <see cref=""ListView.Source""/> collection as
	|        /// the user types.
	|        /// </summary>
	|        public CollectionNavigator KeystrokeNavigator { get; private set; } = new CollectionNavigator();
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            if (source == null)
	|            {
	|                return base.ProcessKey(kb);
	|            }
	|
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|            {
	|                return (bool)result;
	|            }
	|
	|            // Enable user to find & select an item by typing text
	|            if (CollectionNavigator.IsCompatibleKey(kb))
	|            {
	|                var newItem = KeystrokeNavigator?.GetNextMatchingItem(SelectedItem, (char)kb.KeyValue);
	|                if (newItem is int && newItem != -1)
	|                {
	|                    SelectedItem = (int)newItem;
	|                    EnsureSelectedItemVisible();
	|                    SetNeedsDisplay();
	|                    return true;
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// If <see cref=""AllowsMarking""/> and <see cref=""AllowsMultipleSelection""/> are both <see langword=""true""/>,
	|        /// unmarks all marked items other than the currently selected. 
	|        /// </summary>
	|        /// <returns><see langword=""true""/> if unmarking was successful.</returns>
	|        public virtual bool AllowsAll()
	|        {
	|            if (!allowsMarking)
	|                return false;
	|            if (!AllowsMultipleSelection)
	|            {
	|                for (int i = 0; i < Source.Count; i++)
	|                {
	|                    if (Source.IsMarked(i) && i != selected)
	|                    {
	|                        Source.SetMark(i, false);
	|                        return true;
	|                    }
	|                }
	|            }
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Marks the <see cref=""SelectedItem""/> if it is not already marked.
	|        /// </summary>
	|        /// <returns><see langword=""true""/> if the <see cref=""SelectedItem""/> was marked.</returns>
	|        public virtual bool MarkUnmarkRow()
	|        {
	|            if (AllowsAll())
	|            {
	|                Source.SetMark(SelectedItem, !Source.IsMarked(SelectedItem));
	|                SetNeedsDisplay();
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedItem""/> to the item at the top of the visible list.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MovePageUp()
	|        {
	|            int n = (selected - Frame.Height);
	|            if (n < 0)
	|                n = 0;
	|            if (n != selected)
	|            {
	|                selected = n;
	|                top = selected;
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedItem""/> to the item just below the bottom 
	|        /// of the visible list, scrolling if needed.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MovePageDown()
	|        {
	|            var n = (selected + Frame.Height);
	|            if (n >= source.Count)
	|                n = source.Count - 1;
	|            if (n != selected)
	|            {
	|                selected = n;
	|                if (source.Count >= Frame.Height)
	|                    top = selected;
	|                else
	|                    top = 0;
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedItem""/> to the next item in the list, 
	|        /// scrolling the list if needed.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveDown()
	|        {
	|            if (source.Count == 0)
	|            {
	|                // Do we set lastSelectedItem to -1 here?
	|                return false; //Nothing for us to move to
	|            }
	|            if (selected >= source.Count)
	|            {
	|                // If for some reason we are currently outside of the
	|                // valid values range, we should select the bottommost valid value.
	|                // This can occur if the backing data source changes.
	|                selected = source.Count - 1;
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|            else if (selected + 1 < source.Count)
	|            { //can move by down by one.
	|                selected++;
	|
	|                if (selected >= top + Frame.Height)
	|                {
	|                    top++;
	|                }
	|                else if (selected < top)
	|                {
	|                    top = selected;
	|                }
	|                else if (selected < top)
	|                {
	|                    top = selected;
	|                }
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|            else if (selected == 0)
	|            {
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|            else if (selected >= top + Frame.Height)
	|            {
	|                top = source.Count - Frame.Height;
	|                SetNeedsDisplay();
	|            }
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedItem""/> to the previous item in the list, 
	|        /// scrolling the list if needed.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveUp()
	|        {
	|            if (source.Count == 0)
	|            {
	|                // Do we set lastSelectedItem to -1 here?
	|                return false; //Nothing for us to move to
	|            }
	|            if (selected >= source.Count)
	|            {
	|                // If for some reason we are currently outside of the
	|                // valid values range, we should select the bottommost valid value.
	|                // This can occur if the backing data source changes.
	|                selected = source.Count - 1;
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|            else if (selected > 0)
	|            {
	|                selected--;
	|                if (selected > Source.Count)
	|                {
	|                    selected = Source.Count - 1;
	|                }
	|                if (selected < top)
	|                {
	|                    top = selected;
	|                }
	|                else if (selected > top + Frame.Height)
	|                {
	|                    top = Math.Max(selected - Frame.Height + 1, 0);
	|                }
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|            else if (selected < top)
	|            {
	|                top = selected;
	|                SetNeedsDisplay();
	|            }
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedItem""/> to last item in the list, 
	|        /// scrolling the list if needed.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveEnd()
	|        {
	|            if (source?.Count > 0 && selected != source.Count - 1)
	|            {
	|                selected = source.Count - 1;
	|                if (top + selected > Frame.Height - 1)
	|                {
	|                    top = selected < Frame.Height - 1
	|                        ? Math.Max(Frame.Height - selected + 1, 0)
	|                        : Math.Max(selected - Frame.Height + 1, 0);
	|                }
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedItem""/> to the first item in the list, 
	|        /// scrolling the list if needed.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool MoveHome()
	|        {
	|            if (selected != 0)
	|            {
	|                selected = 0;
	|                top = selected;
	|                OnSelectedChanged();
	|                SetNeedsDisplay();
	|            }
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view down by <paramref name=""items""/> items.
	|        /// </summary>
	|        /// <param name=""items"">Number of items to scroll down.</param>
	|        public virtual bool ScrollDown(int items)
	|        {
	|            top = Math.Max(Math.Min(top + items, source.Count - 1), 0);
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view up by <paramref name=""items""/> items.
	|        /// </summary>
	|        /// <param name=""items"">Number of items to scroll up.</param>
	|        public virtual bool ScrollUp(int items)
	|        {
	|            top = Math.Max(top - items, 0);
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view right.
	|        /// </summary>
	|        /// <param name=""cols"">Number of columns to scroll right.</param>
	|        public virtual bool ScrollRight(int cols)
	|        {
	|            left = Math.Max(Math.Min(left + cols, Maxlength - 1), 0);
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view left.
	|        /// </summary>
	|        /// <param name=""cols"">Number of columns to scroll left.</param>
	|        public virtual bool ScrollLeft(int cols)
	|        {
	|            left = Math.Max(left - cols, 0);
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        int lastSelectedItem = -1;
	|        private bool allowsMultipleSelection = true;
	|
	|        /// <summary>
	|        /// Invokes the <see cref=""SelectedItemChanged""/> event if it is defined.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool OnSelectedChanged()
	|        {
	|            if (selected != lastSelectedItem)
	|            {
	|                var value = source?.Count > 0 ? source.ToList()[selected] : null;
	|                SelectedItemChanged?.Invoke(new ListViewItemEventArgs(selected, value));
	|                if (HasFocus)
	|                {
	|                    lastSelectedItem = selected;
	|                }
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Invokes the <see cref=""OpenSelectedItem""/> event if it is defined.
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual bool OnOpenSelectedItem()
	|        {
	|            if (source.Count <= selected || selected < 0 || OpenSelectedItem == null)
	|            {
	|                return false;
	|            }
	|
	|            var value = source.ToList()[selected];
	|
	|            OpenSelectedItem?.Invoke(new ListViewItemEventArgs(selected, value));
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Virtual method that will invoke the <see cref=""RowRender""/>.
	|        /// </summary>
	|        /// <param name=""rowEventArgs""></param>
	|        public virtual void OnRowRender(ListViewRowEventArgs rowEventArgs)
	|        {
	|            RowRender?.Invoke(rowEventArgs);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            if (lastSelectedItem == -1)
	|            {
	|                EnsureSelectedItemVisible();
	|            }
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnLeave(View view)
	|        {
	|            if (lastSelectedItem > -1)
	|            {
	|                lastSelectedItem = -1;
	|            }
	|
	|            return base.OnLeave(view);
	|        }
	|
	|        /// <summary>
	|        /// Ensures the selected item is always visible on the screen.
	|        /// </summary>
	|        public void EnsureSelectedItemVisible()
	|        {
	|            SuperView?.LayoutSubviews();
	|            // If last item is selected and is removed, ensures a valid selected item
	|            if (Source != null && selected > Source.Count - 1)
	|            {
	|                SelectedItem = Source.Count - 1;
	|                SetNeedsDisplay();
	|            }
	|            if (selected < top)
	|            {
	|                top = selected;
	|            }
	|            else if (Frame.Height > 0 && selected >= top + Frame.Height)
	|            {
	|                top = Math.Max(selected - Frame.Height + 1, 0);
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            if (allowsMarking)
	|                Move(0, selected - top);
	|            else
	|                Move(Bounds.Width - 1, selected - top);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) && !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
	|                me.Flags != MouseFlags.WheeledDown && me.Flags != MouseFlags.WheeledUp &&
	|                me.Flags != MouseFlags.WheeledRight && me.Flags != MouseFlags.WheeledLeft)
	|                return false;
	|
	|            if (!HasFocus && CanFocus)
	|            {
	|                SetFocus();
	|            }
	|
	|            if (source == null)
	|            {
	|                return false;
	|            }
	|
	|            if (me.Flags == MouseFlags.WheeledDown)
	|            {
	|                ScrollDown(1);
	|                return true;
	|            }
	|            else if (me.Flags == MouseFlags.WheeledUp)
	|            {
	|                ScrollUp(1);
	|                return true;
	|            }
	|            else if (me.Flags == MouseFlags.WheeledRight)
	|            {
	|                ScrollRight(1);
	|                return true;
	|            }
	|            else if (me.Flags == MouseFlags.WheeledLeft)
	|            {
	|                ScrollLeft(1);
	|                return true;
	|            }
	|
	|            if (me.Y + top >= source.Count)
	|            {
	|                return true;
	|            }
	|
	|            selected = top + me.Y;
	|            if (AllowsAll())
	|            {
	|                Source.SetMark(SelectedItem, !Source.IsMarked(SelectedItem));
	|            }
	|            OnSelectedChanged();
	|            SetNeedsDisplay();
	|            if (me.Flags == MouseFlags.Button1DoubleClicked)
	|            {
	|                OnOpenSelectedItem();
	|            }
	|
	|            return true;
	|        }
	|    }
	|
	|    /// <inheritdoc/>
	|    public class ListWrapper : IListDataSource
	|    {
	|        IList src;
	|        BitArray marks;
	|        int count, len;
	|
	|        /// <inheritdoc/>
	|        public ListWrapper(IList source)
	|        {
	|            if (source != null)
	|            {
	|                count = source.Count;
	|                marks = new BitArray(count);
	|                src = source;
	|                len = GetMaxLengthItem();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public int Count
	|        {
	|            get
	|            {
	|                CheckAndResizeMarksIfRequired();
	|                return src?.Count ?? 0;
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public int Length => len;
	|
	|        void CheckAndResizeMarksIfRequired()
	|        {
	|            if (src != null && count != src.Count)
	|            {
	|                count = src.Count;
	|                BitArray newMarks = new BitArray(count);
	|                for (var i = 0; i < Math.Min(marks.Length, newMarks.Length); i++)
	|                {
	|                    newMarks[i] = marks[i];
	|                }
	|                marks = newMarks;
	|
	|                len = GetMaxLengthItem();
	|            }
	|        }
	|
	|        int GetMaxLengthItem()
	|        {
	|            if (src == null || src?.Count == 0)
	|            {
	|                return 0;
	|            }
	|
	|            int maxLength = 0;
	|            for (int i = 0; i < src.Count; i++)
	|            {
	|                var t = src[i];
	|                int l;
	|                if (t is ustring u)
	|                {
	|                    l = TextFormatter.GetTextWidth(u);
	|                }
	|                else if (t is string s)
	|                {
	|                    l = s.Length;
	|                }
	|                else
	|                {
	|                    l = t.ToString().Length;
	|                }
	|
	|                if (l > maxLength)
	|                {
	|                    maxLength = l;
	|                }
	|            }
	|
	|            return maxLength;
	|        }
	|
	|        void RenderUstr(ConsoleDriver driver, ustring ustr, int col, int line, int width, int start = 0)
	|        {
	|            ustring str = start > ustr.ConsoleWidth ? string.Empty : ustr.Substring(Math.Min(start, ustr.ToRunes().Length - 1));
	|            ustring u = TextFormatter.ClipAndJustify(str, width, TextAlignment.Left);
	|            driver.AddStr(u);
	|            width -= TextFormatter.GetTextWidth(u);
	|            while (width-- + start > 0)
	|            {
	|                driver.AddRune(' ');
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public void Render(ListView container, ConsoleDriver driver, bool marked, int item, int col, int line, int width, int start = 0)
	|        {
	|            var savedClip = container.ClipToBounds();
	|            container.Move(Math.Max(col - start, 0), line);
	|            var t = src?[item];
	|            if (t == null)
	|            {
	|                RenderUstr(driver, ustring.Make(""""), col, line, width);
	|            }
	|            else
	|            {
	|                if (t is ustring u)
	|                {
	|                    RenderUstr(driver, u, col, line, width, start);
	|                }
	|                else if (t is string s)
	|                {
	|                    RenderUstr(driver, s, col, line, width, start);
	|                }
	|                else
	|                {
	|                    RenderUstr(driver, t.ToString(), col, line, width, start);
	|                }
	|            }
	|            driver.Clip = savedClip;
	|        }
	|
	|        /// <inheritdoc/>
	|        public bool IsMarked(int item)
	|        {
	|            if (item >= 0 && item < Count)
	|                return marks[item];
	|            return false;
	|        }
	|
	|        /// <inheritdoc/>
	|        public void SetMark(int item, bool value)
	|        {
	|            if (item >= 0 && item < Count)
	|                marks[item] = value;
	|        }
	|
	|        /// <inheritdoc/>
	|        public IList ToList()
	|        {
	|            return src;
	|        }
	|
	|        /// <inheritdoc/>
	|        public int StartsWith(string search)
	|        {
	|            if (src == null || src?.Count == 0)
	|            {
	|                return -1;
	|            }
	|
	|            for (int i = 0; i < src.Count; i++)
	|            {
	|                var t = src[i];
	|                if (t is ustring u)
	|                {
	|                    if (u.ToUpper().StartsWith(search.ToUpperInvariant()))
	|                    {
	|                        return i;
	|                    }
	|                }
	|                else if (t is string s)
	|                {
	|                    if (s.StartsWith(search, StringComparison.InvariantCultureIgnoreCase))
	|                    {
	|                        return i;
	|                    }
	|                }
	|            }
	|            return -1;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// <see cref=""EventArgs""/> for <see cref=""ListView""/> events.
	|    /// </summary>
	|    public class ListViewItemEventArgs : EventArgs
	|    {
	|        /// <summary>
	|        /// The index of the <see cref=""ListView""/> item.
	|        /// </summary>
	|        public int Item { get; }
	|        /// <summary>
	|        /// The <see cref=""ListView""/> item.
	|        /// </summary>
	|        public object Value { get; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""ListViewItemEventArgs""/>
	|        /// </summary>
	|        /// <param name=""item"">The index of the <see cref=""ListView""/> item.</param>
	|        /// <param name=""value"">The <see cref=""ListView""/> item</param>
	|        public ListViewItemEventArgs(int item, object value)
	|        {
	|            Item = item;
	|            Value = value;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// <see cref=""EventArgs""/> used by the <see cref=""ListView.RowRender""/> event.
	|    /// </summary>
	|    public class ListViewRowEventArgs : EventArgs
	|    {
	|        /// <summary>
	|        /// The current row being rendered.
	|        /// </summary>
	|        public int Row { get; }
	|        /// <summary>
	|        /// The <see cref=""Attribute""/> used by current row or
	|        /// null to maintain the current attribute.
	|        /// </summary>
	|        public Attribute? RowAttribute { get; set; }
	|
	|        /// <summary>
	|        /// Initializes with the current row.
	|        /// </summary>
	|        /// <param name=""row""></param>
	|        public ListViewRowEventArgs(int row)
	|        {
	|            Row = row;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // MainLoop.cs: IMainLoopDriver and MainLoop for Terminal.Gui
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    /// Public interface to create your own platform specific main loop driver.
	|    /// </summary>
	|    public interface IMainLoopDriver
	|    {
	|        /// <summary>
	|        /// Initializes the main loop driver, gets the calling main loop for the initialization.
	|        /// </summary>
	|        /// <param name=""mainLoop"">Main loop.</param>
	|        void Setup(MainLoop mainLoop);
	|
	|        /// <summary>
	|        /// Wakes up the mainloop that might be waiting on input, must be thread safe.
	|        /// </summary>
	|        void Wakeup();
	|
	|        /// <summary>
	|        /// Must report whether there are any events pending, or even block waiting for events.
	|        /// </summary>
	|        /// <returns><c>true</c>, if there were pending events, <c>false</c> otherwise.</returns>
	|        /// <param name=""wait"">If set to <c>true</c> wait until an event is available, otherwise return immediately.</param>
	|        bool EventsPending(bool wait);
	|
	|        /// <summary>
	|        /// The iteration function.
	|        /// </summary>
	|        void MainIteration();
	|    }
	|
	|    /// <summary>
	|    ///   Simple main loop implementation that can be used to monitor
	|    ///   file descriptor, run timers and idle handlers.
	|    /// </summary>
	|    /// <remarks>
	|    ///   Monitoring of file descriptors is only available on Unix, there
	|    ///   does not seem to be a way of supporting this on Windows.
	|    /// </remarks>
	|    public class MainLoop
	|    {
	|        /// <summary>
	|        /// Provides data for timers running manipulation.
	|        /// </summary>
	|        public sealed class Timeout
	|        {
	|            /// <summary>
	|            /// Time to wait before invoke the callback.
	|            /// </summary>
	|            public TimeSpan Span;
	|            /// <summary>
	|            /// The function that will be invoked.
	|            /// </summary>
	|            public Func<MainLoop, bool> Callback;
	|        }
	|
	|        internal SortedList<long, Timeout> timeouts = new SortedList<long, Timeout>();
	|        object timeoutsLockToken = new object();
	|
	|        /// <summary>
	|        /// The idle handlers and lock that must be held while manipulating them
	|        /// </summary>
	|        object idleHandlersLock = new object();
	|        internal List<Func<bool>> idleHandlers = new List<Func<bool>>();
	|
	|        /// <summary>
	|        /// Gets the list of all timeouts sorted by the <see cref=""TimeSpan""/> time ticks./>.
	|        /// A shorter limit time can be added at the end, but it will be called before an
	|        ///  earlier addition that has a longer limit time.
	|        /// </summary>
	|        public SortedList<long, Timeout> Timeouts => timeouts;
	|
	|        /// <summary>
	|        /// Gets a copy of the list of all idle handlers.
	|        /// </summary>
	|        public ReadOnlyCollection<Func<bool>> IdleHandlers
	|        {
	|            get
	|            {
	|                lock (idleHandlersLock)
	|                {
	|                    return new List<Func<bool>>(idleHandlers).AsReadOnly();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The current IMainLoopDriver in use.
	|        /// </summary>
	|        /// <value>The driver.</value>
	|        public IMainLoopDriver Driver { get; }
	|
	|        /// <summary>
	|        /// Invoked when a new timeout is added. To be used in the case
	|        /// when <see cref=""Application.ExitRunLoopAfterFirstIteration""/> is <see langword=""true""/>.
	|        /// </summary>
	|        public event Action<long> TimeoutAdded;
	|
	|        /// <summary>
	|        ///  Creates a new Mainloop. 
	|        /// </summary>
	|        /// <param name=""driver"">Should match the <see cref=""ConsoleDriver""/> 
	|        /// (one of the implementations FakeMainLoop, UnixMainLoop, NetMainLoop or WindowsMainLoop).</param>
	|        public MainLoop(IMainLoopDriver driver)
	|        {
	|            Driver = driver;
	|            driver.Setup(this);
	|        }
	|
	|        /// <summary>
	|        ///   Runs <c>action</c> on the thread that is processing events
	|        /// </summary>
	|        /// <param name=""action"">the action to be invoked on the main processing thread.</param>
	|        public void Invoke(Action action)
	|        {
	|            AddIdle(() =>
	|            {
	|                action();
	|                return false;
	|            });
	|        }
	|
	|        /// <summary>
	|        ///   Adds specified idle handler function to mainloop processing. The handler function will be called once per iteration of the main loop after other events have been handled.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///   Remove an idle hander by calling <see cref=""RemoveIdle(Func{bool})""/> with the token this method returns.
	|        /// </para>
	|        /// <para>
	|        ///   If the <c>idleHandler</c> returns <c>false</c> it will be removed and not called subsequently.
	|        /// </para>
	|        /// </remarks>
	|        /// <param name=""idleHandler"">Token that can be used to remove the idle handler with <see cref=""RemoveIdle(Func{bool})""/> .</param>
	|        public Func<bool> AddIdle(Func<bool> idleHandler)
	|        {
	|            lock (idleHandlersLock)
	|            {
	|                idleHandlers.Add(idleHandler);
	|            }
	|
	|            Driver.Wakeup();
	|            return idleHandler;
	|        }
	|
	|        /// <summary>
	|        ///   Removes an idle handler added with <see cref=""AddIdle(Func{bool})""/> from processing.
	|        /// </summary>
	|        /// <param name=""token"">A token returned by <see cref=""AddIdle(Func{bool})""/></param>
	|        /// Returns <c>true</c>if the idle handler is successfully removed; otherwise, <c>false</c>.
	|        ///  This method also returns <c>false</c> if the idle handler is not found.
	|        public bool RemoveIdle(Func<bool> token)
	|        {
	|            lock (idleHandlersLock)
	|                return idleHandlers.Remove(token);
	|        }
	|
	|        void AddTimeout(TimeSpan time, Timeout timeout)
	|        {
	|            lock (timeoutsLockToken)
	|            {
	|                var k = (DateTime.UtcNow + time).Ticks;
	|                timeouts.Add(NudgeToUniqueKey(k), timeout);
	|                TimeoutAdded?.Invoke(k);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Adds a timeout to the mainloop.
	|        /// </summary>
	|        /// <remarks>
	|        ///   When time specified passes, the callback will be invoked.
	|        ///   If the callback returns true, the timeout will be reset, repeating
	|        ///   the invocation. If it returns false, the timeout will stop and be removed.
	|        ///
	|        ///   The returned value is a token that can be used to stop the timeout
	|        ///   by calling <see cref=""RemoveTimeout(object)""/>.
	|        /// </remarks>
	|        public object AddTimeout(TimeSpan time, Func<MainLoop, bool> callback)
	|        {
	|            if (callback == null)
	|                throw new ArgumentNullException(nameof(callback));
	|            var timeout = new Timeout()
	|            {
	|                Span = time,
	|                Callback = callback
	|            };
	|            AddTimeout(time, timeout);
	|            return timeout;
	|        }
	|
	|        /// <summary>
	|        ///   Removes a previously scheduled timeout
	|        /// </summary>
	|        /// <remarks>
	|        ///   The token parameter is the value returned by AddTimeout.
	|        /// </remarks>
	|        /// Returns <c>true</c>if the timeout is successfully removed; otherwise, <c>false</c>.
	|        /// This method also returns <c>false</c> if the timeout is not found.
	|        public bool RemoveTimeout(object token)
	|        {
	|            lock (timeoutsLockToken)
	|            {
	|                var idx = timeouts.IndexOfValue(token as Timeout);
	|                if (idx == -1)
	|                    return false;
	|                timeouts.RemoveAt(idx);
	|            }
	|            return true;
	|        }
	|
	|        void RunTimers()
	|        {
	|            long now = DateTime.UtcNow.Ticks;
	|            SortedList<long, Timeout> copy;
	|
	|            // lock prevents new timeouts being added
	|            // after we have taken the copy but before
	|            // we have allocated a new list (which would
	|            // result in lost timeouts or errors during enumeration)
	|            lock (timeoutsLockToken)
	|            {
	|                copy = timeouts;
	|                timeouts = new SortedList<long, Timeout>();
	|            }
	|
	|            foreach (var t in copy)
	|            {
	|                var k = t.Key;
	|                var timeout = t.Value;
	|                if (k < now)
	|                {
	|                    if (timeout.Callback(this))
	|                        AddTimeout(timeout.Span, timeout);
	|                }
	|                else
	|                {
	|                    lock (timeoutsLockToken)
	|                    {
	|                        timeouts.Add(NudgeToUniqueKey(k), timeout);
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Finds the closest number to <paramref name=""k""/> that is not
	|        /// present in <see cref=""timeouts""/> (incrementally).
	|        /// </summary>
	|        /// <param name=""k""></param>
	|        /// <returns></returns>
	|        private long NudgeToUniqueKey(long k)
	|        {
	|            lock (timeoutsLockToken)
	|            {
	|                while (timeouts.ContainsKey(k))
	|                {
	|                    k++;
	|                }
	|            }
	|
	|            return k;
	|        }
	|
	|        void RunIdle()
	|        {
	|            List<Func<bool>> iterate;
	|            lock (idleHandlersLock)
	|            {
	|                iterate = idleHandlers;
	|                idleHandlers = new List<Func<bool>>();
	|            }
	|
	|            foreach (var idle in iterate)
	|            {
	|                if (idle())
	|                    lock (idleHandlersLock)
	|                        idleHandlers.Add(idle);
	|            }
	|        }
	|
	|        bool running;
	|
	|        /// <summary>
	|        ///   Stops the mainloop.
	|        /// </summary>
	|        public void Stop()
	|        {
	|            running = false;
	|            Driver.Wakeup();
	|        }
	|
	|        /// <summary>
	|        ///   Determines whether there are pending events to be processed.
	|        /// </summary>
	|        /// <remarks>
	|        ///   You can use this method if you want to probe if events are pending.
	|        ///   Typically used if you need to flush the input queue while still
	|        ///   running some of your own code in your main thread.
	|        /// </remarks>
	|        public bool EventsPending(bool wait = false)
	|        {
	|            return Driver.EventsPending(wait);
	|        }
	|
	|        /// <summary>
	|        ///   Runs one iteration of timers and file watches
	|        /// </summary>
	|        /// <remarks>
	|        ///   You use this to process all pending events (timers, idle handlers and file watches).
	|        ///
	|        ///   You can use it like this:
	|        ///     while (main.EvensPending ()) MainIteration ();
	|        /// </remarks>
	|        public void MainIteration()
	|        {
	|            if (timeouts.Count > 0)
	|                RunTimers();
	|
	|            Driver.MainIteration();
	|
	|            bool runIdle = false;
	|            lock (idleHandlersLock)
	|            {
	|                runIdle = idleHandlers.Count > 0;
	|            }
	|            if (runIdle)
	|            {
	|                RunIdle();
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Runs the mainloop.
	|        /// </summary>
	|        public void Run()
	|        {
	|            bool prev = running;
	|            running = true;
	|            while (running)
	|            {
	|                EventsPending(true);
	|                MainIteration();
	|            }
	|            running = prev;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Specifies how a <see cref=""MenuItem""/> shows selection state. 
	|    /// </summary>
	|    [Flags]
	|    public enum MenuItemCheckStyle
	|    {
	|        /// <summary>
	|        /// The menu item will be shown normally, with no check indicator. The default.
	|        /// </summary>
	|        NoCheck = 0b_0000_0000,
	|
	|        /// <summary>
	|        /// The menu item will indicate checked/un-checked state (see <see cref=""Checked""/>).
	|        /// </summary>
	|        Checked = 0b_0000_0001,
	|
	|        /// <summary>
	|        /// The menu item is part of a menu radio group (see <see cref=""Checked""/>) and will indicate selected state.
	|        /// </summary>
	|        Radio = 0b_0000_0010,
	|    };
	|
	|    /// <summary>
	|    /// A <see cref=""MenuItem""/> has title, an associated help text, and an action to execute on activation. 
	|    /// MenuItems can also have a checked indicator (see <see cref=""Checked""/>).
	|    /// </summary>
	|    public class MenuItem
	|    {
	|        //*master//
	|        public ScriptEngine.Machine.IValue Tag { get; set; }
	|        //master*//
	|
	|        ustring title;
	|        ShortcutHelper shortcutHelper;
	|        internal int TitleLength => GetMenuBarItemLength(Title);
	|
	|        /// <summary>
	|        /// Gets or sets arbitrary data for the menu item.
	|        /// </summary>
	|        /// <remarks>This property is not used internally.</remarks>
	|        public object Data { get; set; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""MenuItem""/>
	|        /// </summary>
	|        public MenuItem(Key shortcut = Key.Null) : this("""", """", null, null, null, shortcut) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""MenuItem""/>.
	|        /// </summary>
	|        /// <param name=""title"">Title for the menu item.</param>
	|        /// <param name=""help"">Help text to display.</param>
	|        /// <param name=""action"">Action to invoke when the menu item is activated.</param>
	|        /// <param name=""canExecute"">Function to determine if the action can currently be executed.</param>
	|        /// <param name=""parent"">The <see cref=""Parent""/> of this menu item.</param>
	|        /// <param name=""shortcut"">The <see cref=""Shortcut""/> keystroke combination.</param>
	|        public MenuItem(ustring title, ustring help, Action action, Func<bool> canExecute = null, MenuItem parent = null, Key shortcut = Key.Null)
	|        {
	|            Title = title ?? """";
	|            Help = help ?? """";
	|            Action = action;
	|            CanExecute = canExecute;
	|            Parent = parent;
	|            shortcutHelper = new ShortcutHelper();
	|            if (shortcut != Key.Null)
	|            {
	|                shortcutHelper.Shortcut = shortcut;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The HotKey is used to activate a <see cref=""MenuItem""/> with the keyboard. HotKeys are defined by prefixing the <see cref=""Title""/>
	|        /// of a MenuItem with an underscore ('_'). 
	|        /// <para>
	|        /// Pressing Alt-Hotkey for a <see cref=""MenuBarItem""/> (menu items on the menu bar) works even if the menu is not active). 
	|        /// Once a menu has focus and is active, pressing just the HotKey will activate the MenuItem.
	|        /// </para>
	|        /// <para>
	|        /// For example for a MenuBar with a ""_File"" MenuBarItem that contains a ""_New"" MenuItem, Alt-F will open the File menu.
	|        /// Pressing the N key will then activate the New MenuItem.
	|        /// </para>
	|        /// <para>
	|        /// See also <see cref=""Shortcut""/> which enable global key-bindings to menu items.
	|        /// </para>
	|        /// </summary>
	|        public Rune HotKey;
	|
	|        /// <summary>
	|        /// Shortcut defines a key binding to the MenuItem that will invoke the MenuItem's action globally for the <see cref=""View""/> that is
	|        /// the parent of the <see cref=""MenuBar""/> or <see cref=""ContextMenu""/> this <see cref=""MenuItem""/>.
	|        /// <para>
	|        /// The <see cref=""Key""/> will be drawn on the MenuItem to the right of the <see cref=""Title""/> and <see cref=""Help""/> text. See <see cref=""ShortcutTag""/>.
	|        /// </para>
	|        /// </summary>
	|        public Key Shortcut
	|        {
	|            get => shortcutHelper.Shortcut;
	|            set
	|            {
	|                if (shortcutHelper.Shortcut != value && (ShortcutHelper.PostShortcutValidation(value) || value == Key.Null))
	|                {
	|                    shortcutHelper.Shortcut = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the text describing the keystroke combination defined by <see cref=""Shortcut""/>.
	|        /// </summary>
	|        public ustring ShortcutTag => ShortcutHelper.GetShortcutTag(shortcutHelper.Shortcut);
	|
	|        /// <summary>
	|        /// Gets or sets the title of the menu item .
	|        /// </summary>
	|        /// <value>The title.</value>
	|        public ustring Title
	|        {
	|            get { return title; }
	|            set
	|            {
	|                if (title != value)
	|                {
	|                    title = value;
	|                    GetHotKey();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the help text for the menu item. The help text is drawn to the right of the <see cref=""Title""/>.
	|        /// </summary>
	|        /// <value>The help text.</value>
	|        public ustring Help { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the action to be invoked when the menu item is triggered.
	|        /// </summary>
	|        /// <value>Method to invoke.</value>
	|        public Action Action { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the action to be invoked to determine if the menu can be triggered. If <see cref=""CanExecute""/> returns <see langword=""true""/>
	|        /// the menu item will be enabled. Otherwise, it will be disabled. 
	|        /// </summary>
	|        /// <value>Function to determine if the action is can be executed or not.</value>
	|        public Func<bool> CanExecute { get; set; }
	|
	|        /// <summary>
	|        /// Returns <see langword=""true""/> if the menu item is enabled. This method is a wrapper around <see cref=""CanExecute""/>.
	|        /// </summary>
	|        public bool IsEnabled()
	|        {
	|            return CanExecute == null ? true : CanExecute();
	|        }
	|
	|        // 
	|        // ┌─────────────────────────────┐
	|        // │ Quit  Quit UI Catalog  Ctrl+Q │
	|        // └─────────────────────────────┘
	|        // ┌─────────────────┐
	|        // │ ◌ TopLevel Alt+T │
	|        // └─────────────────┘
	|        // TODO: Replace the `2` literals with named constants 
	|        internal int Width => 1 + // space before Title
	|            TitleLength +
	|            2 + // space after Title - BUGBUG: This should be 1 
	|            (Checked || CheckType.HasFlag(MenuItemCheckStyle.Checked) || CheckType.HasFlag(MenuItemCheckStyle.Radio) ? 2 : 0) + // check glyph + space 
	|            (Help.ConsoleWidth > 0 ? 2 + Help.ConsoleWidth : 0) + // Two spaces before Help
	|            (ShortcutTag.ConsoleWidth > 0 ? 2 + ShortcutTag.ConsoleWidth : 0); // Pad two spaces before shortcut tag (which are also aligned right)
	|
	|        /// <summary>
	|        /// Sets or gets whether the <see cref=""MenuItem""/> shows a check indicator or not. See <see cref=""MenuItemCheckStyle""/>.
	|        /// </summary>
	|        public bool Checked { set; get; }
	|
	|        /// <summary>
	|        /// Sets or gets the <see cref=""MenuItemCheckStyle""/> of a menu item where <see cref=""Checked""/> is set to <see langword=""true""/>.
	|        /// </summary>
	|        public MenuItemCheckStyle CheckType { get; set; }
	|
	|        /// <summary>
	|        /// Gets the parent for this <see cref=""MenuItem""/>.
	|        /// </summary>
	|        /// <value>The parent.</value>
	|        public MenuItem Parent { get; internal set; }
	|
	|        /// <summary>
	|        /// Gets if this <see cref=""MenuItem""/> is from a sub-menu.
	|        /// </summary>
	|        internal bool IsFromSubMenu { get { return Parent != null; } }
	|
	|        /// <summary>
	|        /// Merely a debugging aid to see the interaction with main.
	|        /// </summary>
	|        public MenuItem GetMenuItem()
	|        {
	|            return this;
	|        }
	|
	|        /// <summary>
	|        /// Merely a debugging aid to see the interaction with main.
	|        /// </summary>
	|        public bool GetMenuBarItem()
	|        {
	|            return IsFromSubMenu;
	|        }
	|
	|        void GetHotKey()
	|        {
	|            bool nextIsHot = false;
	|            foreach (var x in title)
	|            {
	|                if (x == MenuBar.HotKeySpecifier)
	|                {
	|                    nextIsHot = true;
	|                }
	|                else
	|                {
	|                    if (nextIsHot)
	|                    {
	|                        HotKey = Char.ToUpper((char)x);
	|                        break;
	|                    }
	|                    nextIsHot = false;
	|                    HotKey = default;
	|                }
	|            }
	|        }
	|
	|        int GetMenuBarItemLength(ustring title)
	|        {
	|            int len = 0;
	|            foreach (var ch in title)
	|            {
	|                if (ch == MenuBar.HotKeySpecifier)
	|                    continue;
	|                len += Math.Max(Rune.ColumnWidth(ch), 1);
	|            }
	|
	|            return len;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// <see cref=""MenuBarItem""/> is a menu item on an app's <see cref=""MenuBar""/>. 
	|    /// MenuBarItems do not support <see cref=""MenuItem.Shortcut""/>.
	|    /// </summary>
	|    public class MenuBarItem : MenuItem
	|    {
	|        /// <summary>
	|        /// Initializes a new <see cref=""MenuBarItem""/> as a <see cref=""MenuItem""/>.
	|        /// </summary>
	|        /// <param name=""title"">Title for the menu item.</param>
	|        /// <param name=""help"">Help text to display. Will be displayed next to the Title surrounded by parentheses.</param>
	|        /// <param name=""action"">Action to invoke when the menu item is activated.</param>
	|        /// <param name=""canExecute"">Function to determine if the action can currently be executed.</param>
	|        /// <param name=""parent"">The parent <see cref=""MenuItem""/> of this if exist, otherwise is null.</param>
	|        public MenuBarItem(ustring title, ustring help, Action action, Func<bool> canExecute = null, MenuItem parent = null) : base(title, help, action, canExecute, parent)
	|        {
	|            Initialize(title, null, null, true);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""MenuBarItem""/>.
	|        /// </summary>
	|        /// <param name=""title"">Title for the menu item.</param>
	|        /// <param name=""children"">The items in the current menu.</param>
	|        /// <param name=""parent"">The parent <see cref=""MenuItem""/> of this if exist, otherwise is null.</param>
	|        public MenuBarItem(ustring title, MenuItem[] children, MenuItem parent = null)
	|        {
	|            Initialize(title, children, parent);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""MenuBarItem""/> with separate list of items.
	|        /// </summary>
	|        /// <param name=""title"">Title for the menu item.</param>
	|        /// <param name=""children"">The list of items in the current menu.</param>
	|        /// <param name=""parent"">The parent <see cref=""MenuItem""/> of this if exist, otherwise is null.</param>
	|        public MenuBarItem(ustring title, List<MenuItem[]> children, MenuItem parent = null)
	|        {
	|            Initialize(title, children, parent);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""MenuBarItem""/>.
	|        /// </summary>
	|        /// <param name=""children"">The items in the current menu.</param>
	|        public MenuBarItem(MenuItem[] children) : this("""", children) { }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""MenuBarItem""/>.
	|        /// </summary>
	|        public MenuBarItem() : this(children: new MenuItem[] { }) { }
	|
	|        void Initialize(ustring title, object children, MenuItem parent = null, bool isTopLevel = false)
	|        {
	|            if (!isTopLevel && children == null)
	|            {
	|                throw new ArgumentNullException(nameof(children), ""The parameter cannot be null. Use an empty array instead."");
	|            }
	|            SetTitle(title ?? """");
	|            if (parent != null)
	|            {
	|                Parent = parent;
	|            }
	|            if (children is List<MenuItem[]>)
	|            {
	|                MenuItem[] childrens = new MenuItem[] { };
	|                foreach (var item in (List<MenuItem[]>)children)
	|                {
	|                    for (int i = 0; i < item.Length; i++)
	|                    {
	|                        SetChildrensParent(item);
	|                        Array.Resize(ref childrens, childrens.Length + 1);
	|                        childrens[childrens.Length - 1] = item[i];
	|                    }
	|                }
	|                Children = childrens;
	|            }
	|            else if (children is MenuItem[])
	|            {
	|                SetChildrensParent((MenuItem[])children);
	|                Children = (MenuItem[])children;
	|            }
	|            else
	|            {
	|                Children = null;
	|            }
	|        }
	|
	|        void SetChildrensParent(MenuItem[] childrens)
	|        {
	|            foreach (var child in childrens)
	|            {
	|                if (child != null && child.Parent == null)
	|                {
	|                    child.Parent = this;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Check if the children parameter is a <see cref=""MenuBarItem""/>.
	|        /// </summary>
	|        /// <param name=""children""></param>
	|        /// <returns>Returns a <see cref=""MenuBarItem""/> or null otherwise.</returns>
	|        public MenuBarItem SubMenu(MenuItem children)
	|        {
	|            return children as MenuBarItem;
	|        }
	|
	|        /// <summary>
	|        /// Check if the <see cref=""MenuItem""/> parameter is a child of this.
	|        /// </summary>
	|        /// <param name=""menuItem""></param>
	|        /// <returns>Returns <c>true</c> if it is a child of this. <c>false</c> otherwise.</returns>
	|        public bool IsSubMenuOf(MenuItem menuItem)
	|        {
	|            foreach (var child in Children)
	|            {
	|                if (child == menuItem && child.Parent == menuItem.Parent)
	|                {
	|                    return true;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Get the index of the <see cref=""MenuItem""/> parameter.
	|        /// </summary>
	|        /// <param name=""children""></param>
	|        /// <returns>Returns a value bigger than -1 if the <see cref=""MenuItem""/> is a child of this.</returns>
	|        public int GetChildrenIndex(MenuItem children)
	|        {
	|            if (Children?.Length == 0)
	|            {
	|                return -1;
	|            }
	|            int i = 0;
	|            foreach (var child in Children)
	|            {
	|                if (child == children)
	|                {
	|                    return i;
	|                }
	|                i++;
	|            }
	|            return -1;
	|        }
	|
	|        void SetTitle(ustring title)
	|        {
	|            if (title == null)
	|                title = ustring.Empty;
	|            Title = title;
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets an array of <see cref=""MenuItem""/> objects that are the children of this <see cref=""MenuBarItem""/>
	|        /// </summary>
	|        /// <value>The children.</value>
	|        public MenuItem[] Children { get; set; }
	|
	|        internal bool IsTopLevel { get => Parent == null && (Children == null || Children.Length == 0) && Action != null; }
	|    }
	|
	|    class Menu : View
	|    {
	|        internal MenuBarItem barItems;
	|        internal MenuBar host;
	|        internal int current;
	|        internal View previousSubFocused;
	|
	|        internal static Rect MakeFrame(int x, int y, MenuItem[] items, Menu parent = null)
	|        {
	|            if (items == null || items.Length == 0)
	|            {
	|                return new Rect();
	|            }
	|            int minX = x;
	|            int minY = y;
	|            int maxW = (items.Max(z => z?.Width) ?? 0) + 2; // This 2 is frame border?
	|            int maxH = items.Length + 2; // This 2 is frame border?
	|            if (parent != null && x + maxW > Driver.Cols)
	|            {
	|                minX = Math.Max(parent.Frame.Right - parent.Frame.Width - maxW, 0);
	|            }
	|            if (y + maxH > Driver.Rows)
	|            {
	|                minY = Math.Max(Driver.Rows - maxH, 0);
	|            }
	|            return new Rect(minX, minY, maxW, maxH);
	|        }
	|
	|        public Menu(MenuBar host, int x, int y, MenuBarItem barItems, Menu parent = null)
	|            : base(MakeFrame(x, y, barItems.Children, parent))
	|        {
	|            this.barItems = barItems;
	|            this.host = host;
	|            if (barItems.IsTopLevel)
	|            {
	|                // This is a standalone MenuItem on a MenuBar
	|                ColorScheme = host.ColorScheme;
	|                CanFocus = true;
	|            }
	|            else
	|            {
	|
	|                current = -1;
	|                for (int i = 0; i < barItems.Children?.Length; i++)
	|                {
	|                    if (barItems.Children[i]?.IsEnabled() == true)
	|                    {
	|                        current = i;
	|                        break;
	|                    }
	|                }
	|                ColorScheme = host.ColorScheme;
	|                CanFocus = true;
	|                WantMousePositionReports = host.WantMousePositionReports;
	|            }
	|
	|            if (Application.Current != null)
	|            {
	|                Application.Current.Resized += Current_Resized;
	|            }
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.LineUp, () => MoveUp());
	|            AddCommand(Command.LineDown, () => MoveDown());
	|            AddCommand(Command.Left, () => { this.host.PreviousMenu(true); return true; });
	|            AddCommand(Command.Right, () =>
	|            {
	|                this.host.NextMenu(!this.barItems.IsTopLevel || (this.barItems.Children != null
	|                    && this.barItems.Children.Length > 0 && current > -1
	|                    && current < this.barItems.Children.Length && this.barItems.Children[current].IsFromSubMenu),
	|                    this.barItems.Children != null && this.barItems.Children.Length > 0 && current > -1
	|                    && host.UseSubMenusSingleFrame && this.barItems.SubMenu(this.barItems.Children[current]) != null);
	|
	|                return true;
	|            });
	|            AddCommand(Command.Cancel, () => { CloseAllMenus(); return true; });
	|            AddCommand(Command.Accept, () => { RunSelected(); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.Esc, Command.Cancel);
	|            AddKeyBinding(Key.Enter, Command.Accept);
	|        }
	|
	|        private void Current_Resized(Size obj)
	|        {
	|            if (host.IsMenuOpen)
	|            {
	|                host.CloseAllMenus();
	|            }
	|        }
	|
	|        internal Attribute DetermineColorSchemeFor(MenuItem item, int index)
	|        {
	|            if (item != null)
	|            {
	|                if (index == current) return ColorScheme.Focus;
	|                if (!item.IsEnabled()) return ColorScheme.Disabled;
	|            }
	|            return GetNormalColor();
	|        }
	|
	|        // Draws the Menu, within the Frame
	|        public override void Redraw(Rect bounds)
	|        {
	|            Driver.SetAttribute(GetNormalColor());
	|            DrawFrame(Bounds, padding: 0, fill: true);
	|
	|            for (int i = Bounds.Y; i < barItems.Children.Length; i++)
	|            {
	|                if (i < 0)
	|                    continue;
	|                var item = barItems.Children[i];
	|                Driver.SetAttribute(item == null ? GetNormalColor()
	|                    : i == current ? ColorScheme.Focus : GetNormalColor());
	|                if (item == null)
	|                {
	|                    Move(0, i + 1);
	|                    Driver.AddRune(Driver.LeftTee);
	|                }
	|                else if (Frame.X + 1 < Driver.Cols)
	|                    Move(1, i + 1);
	|
	|                Driver.SetAttribute(DetermineColorSchemeFor(item, i));
	|                for (int p = Bounds.X; p < Frame.Width - 2; p++)
	|                { // This - 2 is for the border
	|                    if (p < 0)
	|                        continue;
	|                    if (item == null)
	|                        Driver.AddRune(Driver.HLine);
	|                    else if (i == 0 && p == 0 && host.UseSubMenusSingleFrame && item.Parent.Parent != null)
	|                        Driver.AddRune(Driver.LeftArrow);
	|                    // This `- 3` is left border + right border + one row in from right
	|                    else if (p == Frame.Width - 3 && barItems.SubMenu(barItems.Children[i]) != null)
	|                        Driver.AddRune(Driver.RightArrow);
	|                    else
	|                        Driver.AddRune(' ');
	|                }
	|
	|                if (item == null)
	|                {
	|                    if (SuperView?.Frame.Right - Frame.X > Frame.Width - 1)
	|                    {
	|                        Move(Frame.Width - 1, i + 1);
	|                        Driver.AddRune(Driver.RightTee);
	|                    }
	|                    continue;
	|                }
	|
	|                ustring textToDraw;
	|                var checkChar = Driver.Selected;
	|                var uncheckedChar = Driver.UnSelected;
	|
	|                if (item.CheckType.HasFlag(MenuItemCheckStyle.Checked))
	|                {
	|                    checkChar = Driver.Checked;
	|                    uncheckedChar = Driver.UnChecked;
	|                }
	|
	|                // Support Checked even though CheckType wasn't set
	|                if (item.Checked)
	|                {
	|                    textToDraw = ustring.Make(new Rune[] { checkChar, ' ' }) + item.Title;
	|                }
	|                else if (item.CheckType.HasFlag(MenuItemCheckStyle.Checked) || item.CheckType.HasFlag(MenuItemCheckStyle.Radio))
	|                {
	|                    textToDraw = ustring.Make(new Rune[] { uncheckedChar, ' ' }) + item.Title;
	|                }
	|                else
	|                {
	|                    textToDraw = item.Title;
	|                }
	|
	|                ViewToScreen(2, i + 1, out int vtsCol, out _, false);
	|                if (vtsCol < Driver.Cols)
	|                {
	|                    Move(2, i + 1);
	|                    if (!item.IsEnabled())
	|                    {
	|                        DrawHotString(textToDraw, ColorScheme.Disabled, ColorScheme.Disabled);
	|                    }
	|                    else if (i == 0 && host.UseSubMenusSingleFrame && item.Parent.Parent != null)
	|                    {
	|                        var tf = new TextFormatter()
	|                        {
	|                            Alignment = TextAlignment.Centered,
	|                            HotKeySpecifier = MenuBar.HotKeySpecifier,
	|                            Text = textToDraw
	|                        };
	|                        // The -3 is left/right border + one space (not sure what for)
	|                        tf.Draw(ViewToScreen(new Rect(2, i + 1, Frame.Width - 3, 1)),
	|                            i == current ? ColorScheme.Focus : GetNormalColor(),
	|                            i == current ? ColorScheme.HotFocus : ColorScheme.HotNormal,
	|                            SuperView == null ? default : SuperView.ViewToScreen(SuperView.Bounds));
	|                    }
	|                    else
	|                    {
	|                        DrawHotString(textToDraw,
	|                            i == current ? ColorScheme.HotFocus : ColorScheme.HotNormal,
	|                            i == current ? ColorScheme.Focus : GetNormalColor());
	|                    }
	|
	|                    // The help string
	|                    var l = item.ShortcutTag.ConsoleWidth == 0 ? item.Help.ConsoleWidth : item.Help.ConsoleWidth + item.ShortcutTag.ConsoleWidth + 2;
	|                    var col = Frame.Width - l - 2;
	|                    ViewToScreen(col, i + 1, out vtsCol, out _, false);
	|                    if (vtsCol < Driver.Cols)
	|                    {
	|                        Move(col, 1 + i);
	|                        Driver.AddStr(item.Help);
	|
	|                        // The shortcut tag string
	|                        if (!item.ShortcutTag.IsEmpty)
	|                        {
	|                            l = item.ShortcutTag.ConsoleWidth;
	|                            Move(Frame.Width - l - 2, 1 + i);
	|                            Driver.AddStr(item.ShortcutTag);
	|                        }
	|                    }
	|                }
	|            }
	|            PositionCursor();
	|        }
	|
	|        public override void PositionCursor()
	|        {
	|            if (host == null || host.IsMenuOpen)
	|                if (barItems.IsTopLevel)
	|                {
	|                    host.PositionCursor();
	|                }
	|                else
	|                    Move(2, 1 + current);
	|            else
	|                host.PositionCursor();
	|        }
	|
	|        public void Run(Action action)
	|        {
	|            if (action == null || host == null)
	|                return;
	|
	|            Application.UngrabMouse();
	|            host.CloseAllMenus();
	|            Application.Refresh();
	|
	|            host.Run(action);
	|        }
	|
	|        public override bool OnLeave(View view)
	|        {
	|            return host.OnLeave(view);
	|        }
	|
	|        public override bool OnKeyDown(KeyEvent keyEvent)
	|        {
	|            if (keyEvent.IsAlt)
	|            {
	|                host.CloseAllMenus();
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        public override bool ProcessHotKey(KeyEvent keyEvent)
	|        {
	|            // To ncurses simulate a AltMask key pressing Alt+Space because
	|            // it can�t detect an alone special key down was pressed.
	|            if (keyEvent.IsAlt && keyEvent.Key == Key.AltMask)
	|            {
	|                OnKeyDown(keyEvent);
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            // TODO: rune-ify
	|            if (barItems.Children != null && Char.IsLetterOrDigit((char)kb.KeyValue))
	|            {
	|                var x = Char.ToUpper((char)kb.KeyValue);
	|                var idx = -1;
	|                foreach (var item in barItems.Children)
	|                {
	|                    idx++;
	|                    if (item == null) continue;
	|                    if (item.IsEnabled() && item.HotKey == x)
	|                    {
	|                        current = idx;
	|                        RunSelected();
	|                        return true;
	|                    }
	|                }
	|            }
	|            return host.ProcessHotKey(kb);
	|        }
	|
	|        void RunSelected()
	|        {
	|            if (barItems.IsTopLevel)
	|            {
	|                Run(barItems.Action);
	|            }
	|            else if (current > -1 && barItems.Children[current].Action != null)
	|            {
	|                Run(barItems.Children[current].Action);
	|            }
	|            else if (current == 0 && host.UseSubMenusSingleFrame
	|              && barItems.Children[current].Parent.Parent != null)
	|            {
	|
	|                host.PreviousMenu(barItems.Children[current].Parent.IsFromSubMenu, true);
	|            }
	|            else if (current > -1 && barItems.SubMenu(barItems.Children[current]) != null)
	|            {
	|
	|                CheckSubMenu();
	|            }
	|        }
	|
	|        void CloseAllMenus()
	|        {
	|            Application.UngrabMouse();
	|            host.CloseAllMenus();
	|        }
	|
	|        bool MoveDown()
	|        {
	|            if (barItems.IsTopLevel)
	|            {
	|                return true;
	|            }
	|            bool disabled;
	|            do
	|            {
	|                current++;
	|                if (current >= barItems.Children.Length)
	|                {
	|                    current = 0;
	|                }
	|                if (this != host.openCurrentMenu && barItems.Children[current]?.IsFromSubMenu == true && host.selectedSub > -1)
	|                {
	|                    host.PreviousMenu(true);
	|                    host.SelectEnabledItem(barItems.Children, current, out current);
	|                    host.openCurrentMenu = this;
	|                }
	|                var item = barItems.Children[current];
	|                if (item?.IsEnabled() != true)
	|                {
	|                    disabled = true;
	|                }
	|                else
	|                {
	|                    disabled = false;
	|                }
	|                if (!host.UseSubMenusSingleFrame && host.UseKeysUpDownAsKeysLeftRight && barItems.SubMenu(barItems.Children[current]) != null &&
	|                    !disabled && host.IsMenuOpen)
	|                {
	|                    if (!CheckSubMenu())
	|                        return false;
	|                    break;
	|                }
	|                if (!host.IsMenuOpen)
	|                {
	|                    host.OpenMenu(host.selected);
	|                }
	|            } while (barItems.Children[current] == null || disabled);
	|            SetNeedsDisplay();
	|            SetParentSetNeedsDisplay();
	|            if (!host.UseSubMenusSingleFrame)
	|                host.OnMenuOpened();
	|            return true;
	|        }
	|
	|        bool MoveUp()
	|        {
	|            if (barItems.IsTopLevel || current == -1)
	|            {
	|                return true;
	|            }
	|            bool disabled;
	|            do
	|            {
	|                current--;
	|                if (host.UseKeysUpDownAsKeysLeftRight && !host.UseSubMenusSingleFrame)
	|                {
	|                    if ((current == -1 || this != host.openCurrentMenu) && barItems.Children[current + 1].IsFromSubMenu && host.selectedSub > -1)
	|                    {
	|                        current++;
	|                        host.PreviousMenu(true);
	|                        if (current > 0)
	|                        {
	|                            current--;
	|                            host.openCurrentMenu = this;
	|                        }
	|                        break;
	|                    }
	|                }
	|                if (current < 0)
	|                    current = barItems.Children.Length - 1;
	|                if (!host.SelectEnabledItem(barItems.Children, current, out current, false))
	|                {
	|                    current = 0;
	|                    if (!host.SelectEnabledItem(barItems.Children, current, out current) && !host.CloseMenu(false))
	|                    {
	|                        return false;
	|                    }
	|                    break;
	|                }
	|                var item = barItems.Children[current];
	|                if (item?.IsEnabled() != true)
	|                {
	|                    disabled = true;
	|                }
	|                else
	|                {
	|                    disabled = false;
	|                }
	|                if (!host.UseSubMenusSingleFrame && host.UseKeysUpDownAsKeysLeftRight && barItems.SubMenu(barItems.Children[current]) != null &&
	|                    !disabled && host.IsMenuOpen)
	|                {
	|                    if (!CheckSubMenu())
	|                        return false;
	|                    break;
	|                }
	|            } while (barItems.Children[current] == null || disabled);
	|            SetNeedsDisplay();
	|            SetParentSetNeedsDisplay();
	|            if (!host.UseSubMenusSingleFrame)
	|                host.OnMenuOpened();
	|            return true;
	|        }
	|
	|        private void SetParentSetNeedsDisplay()
	|        {
	|            if (host.openSubMenu != null)
	|            {
	|                foreach (var menu in host.openSubMenu)
	|                {
	|                    menu.SetNeedsDisplay();
	|                }
	|            }
	|
	|            host?.openMenu.SetNeedsDisplay();
	|            host.SetNeedsDisplay();
	|        }
	|
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!host.handled && !host.HandleGrabView(me, this))
	|            {
	|                return false;
	|            }
	|            host.handled = false;
	|            bool disabled;
	|            if (me.Flags == MouseFlags.Button1Clicked)
	|            {
	|                disabled = false;
	|                if (me.Y < 1)
	|                    return true;
	|                var meY = me.Y - 1;
	|                if (meY >= barItems.Children.Length)
	|                    return true;
	|                var item = barItems.Children[meY];
	|                if (item == null || !item.IsEnabled()) disabled = true;
	|                if (disabled) return true;
	|                current = meY;
	|                if (item != null && !disabled)
	|                    RunSelected();
	|                return true;
	|            }
	|            else if (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked ||
	|              me.Flags == MouseFlags.Button1TripleClicked || me.Flags == MouseFlags.ReportMousePosition ||
	|              me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition))
	|            {
	|
	|                disabled = false;
	|                if (me.Y < 1 || me.Y - 1 >= barItems.Children.Length)
	|                {
	|                    return true;
	|                }
	|                var item = barItems.Children[me.Y - 1];
	|                if (item == null) return true;
	|                if (item == null || !item.IsEnabled()) disabled = true;
	|                if (item != null && !disabled)
	|                    current = me.Y - 1;
	|                if (host.UseSubMenusSingleFrame || !CheckSubMenu())
	|                {
	|                    SetNeedsDisplay();
	|                    SetParentSetNeedsDisplay();
	|                    return true;
	|                }
	|                host.OnMenuOpened();
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        internal bool CheckSubMenu()
	|        {
	|            if (current == -1 || barItems.Children[current] == null)
	|            {
	|                return true;
	|            }
	|            var subMenu = barItems.SubMenu(barItems.Children[current]);
	|            if (subMenu != null)
	|            {
	|                int pos = -1;
	|                if (host.openSubMenu != null)
	|                {
	|                    pos = host.openSubMenu.FindIndex(o => o?.barItems == subMenu);
	|                }
	|                if (pos == -1 && this != host.openCurrentMenu && subMenu.Children != host.openCurrentMenu.barItems.Children
	|                    && !host.CloseMenu(false, true))
	|                {
	|                    return false;
	|                }
	|                host.Activate(host.selected, pos, subMenu);
	|            }
	|            else if (host.openSubMenu?.Count == 0 || host.openSubMenu?.Last().barItems.IsSubMenuOf(barItems.Children[current]) == false)
	|            {
	|                return host.CloseMenu(false, true);
	|            }
	|            else
	|            {
	|                SetNeedsDisplay();
	|                SetParentSetNeedsDisplay();
	|            }
	|            return true;
	|        }
	|
	|        int GetSubMenuIndex(MenuBarItem subMenu)
	|        {
	|            int pos = -1;
	|            if (this != null && Subviews.Count > 0)
	|            {
	|                Menu v = null;
	|                foreach (var menu in Subviews)
	|                {
	|                    if (((Menu)menu).barItems == subMenu)
	|                        v = (Menu)menu;
	|                }
	|                if (v != null)
	|                    pos = Subviews.IndexOf(v);
	|            }
	|
	|            return pos;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        protected override void Dispose(bool disposing)
	|        {
	|            if (Application.Current != null)
	|            {
	|                Application.Current.Resized -= Current_Resized;
	|            }
	|
	|            base.Dispose(disposing);
	|        }
	|    }
	|
	|    /// <summary>
	|    ///	<para>
	|    /// Provides a menu bar that spans the top of a <see cref=""Toplevel""/> View with drop-down and cascading menus. 
	|    ///	</para>
	|    /// <para>
	|    /// By default, any sub-sub-menus (sub-menus of the <see cref=""MenuItem""/>s added to <see cref=""MenuBarItem""/>s) 
	|    /// are displayed in a cascading manner, where each sub-sub-menu pops out of the sub-menu frame
	|    /// (either to the right or left, depending on where the sub-menu is relative to the edge of the screen). By setting
	|    /// <see cref=""UseSubMenusSingleFrame""/> to <see langword=""true""/>, this behavior can be changed such that all sub-sub-menus are
	|    /// drawn within a single frame below the MenuBar.
	|    /// </para>
	|    /// </summary>
	|    /// <remarks>
	|    ///	<para>
	|    ///	The <see cref=""MenuBar""/> appears on the first row of the parent <see cref=""Toplevel""/> View and uses the full width.
	|    ///	</para>
	|    ///	<para>
	|    ///	The <see cref=""MenuBar""/> provides global hotkeys for the application. See <see cref=""MenuItem.HotKey""/>.
	|    ///	</para>
	|    ///	<para>
	|    ///	See also: <see cref=""ContextMenu""/>
	|    ///	</para>
	|    /// </remarks>
	|    public class MenuBar : View
	|    {
	|        internal int selected;
	|        internal int selectedSub;
	|
	|        /// <summary>
	|        /// Gets or sets the array of <see cref=""MenuBarItem""/>s for the menu. Only set this after the <see cref=""MenuBar""/> is visible.
	|        /// </summary>
	|        /// <value>The menu array.</value>
	|        public MenuBarItem[] Menus { get; set; }
	|
	|        private bool useKeysUpDownAsKeysLeftRight = false;
	|
	|        /// <summary>
	|        /// Used for change the navigation key style.
	|        /// </summary>
	|        public bool UseKeysUpDownAsKeysLeftRight
	|        {
	|            get => useKeysUpDownAsKeysLeftRight;
	|            set
	|            {
	|                useKeysUpDownAsKeysLeftRight = value;
	|                if (value && UseSubMenusSingleFrame)
	|                {
	|                    UseSubMenusSingleFrame = false;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        static ustring shortcutDelimiter = ""+"";
	|        /// <summary>
	|        /// Sets or gets the shortcut delimiter separator. The default is ""+"".
	|        /// </summary>
	|        public static ustring ShortcutDelimiter
	|        {
	|            get => shortcutDelimiter;
	|            set
	|            {
	|                if (shortcutDelimiter != value)
	|                {
	|                    shortcutDelimiter = value == ustring.Empty ? "" "" : value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The specifier character for the hotkey to all menus.
	|        /// </summary>
	|        new public static Rune HotKeySpecifier => '_';
	|
	|        private bool useSubMenusSingleFrame;
	|
	|        /// <summary>
	|        /// Gets or sets if the sub-menus must be displayed in a single or multiple frames.
	|        /// <para>
	|        /// By default any sub-sub-menus (sub-menus of the main <see cref=""MenuItem""/>s) are displayed in a cascading manner, 
	|        /// where each sub-sub-menu pops out of the sub-menu frame
	|        /// (either to the right or left, depending on where the sub-menu is relative to the edge of the screen). By setting
	|        /// <see cref=""UseSubMenusSingleFrame""/> to <see langword=""true""/>, this behavior can be changed such that all sub-sub-menus are
	|        /// drawn within a single frame below the MenuBar.
	|        /// </para>		
	|        /// </summary>
	|        public bool UseSubMenusSingleFrame
	|        {
	|            get => useSubMenusSingleFrame;
	|            set
	|            {
	|                useSubMenusSingleFrame = value;
	|                if (value && UseKeysUpDownAsKeysLeftRight)
	|                {
	|                    useKeysUpDownAsKeysLeftRight = false;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The <see cref=""Gui.Key""/> used to activate the menu bar by keyboard.
	|        /// </summary>
	|        public Key Key { get; set; } = Key.F9;
	|
	|        ///<inheritdoc/>
	|        public override bool Visible
	|        {
	|            get => base.Visible;
	|            set
	|            {
	|                base.Visible = value;
	|                if (!value)
	|                {
	|                    CloseAllMenus();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""MenuBar""/>.
	|        /// </summary>
	|        public MenuBar() : this(new MenuBarItem[] { }) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""MenuBar""/> class with the specified set of toplevel menu items.
	|        /// </summary>
	|        /// <param name=""menus"">Individual menu items; a null item will result in a separator being drawn.</param>
	|        public MenuBar(MenuBarItem[] menus) : base()
	|        {
	|            X = 0;
	|            Y = 0;
	|            Width = Dim.Fill();
	|            Height = 1;
	|            Menus = menus;
	|            //CanFocus = true;
	|            selected = -1;
	|            selectedSub = -1;
	|            ColorScheme = Colors.Menu;
	|            WantMousePositionReports = true;
	|            IsMenuOpen = false;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.Left, () => { MoveLeft(); return true; });
	|            AddCommand(Command.Right, () => { MoveRight(); return true; });
	|            AddCommand(Command.Cancel, () => { CloseMenuBar(); return true; });
	|            AddCommand(Command.Accept, () => { ProcessMenu(selected, Menus[selected]); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.Esc, Command.Cancel);
	|            AddKeyBinding(Key.C | Key.CtrlMask, Command.Cancel);
	|            AddKeyBinding(Key.CursorDown, Command.Accept);
	|            AddKeyBinding(Key.Enter, Command.Accept);
	|        }
	|
	|        bool openedByAltKey;
	|
	|        bool isCleaning;
	|
	|        ///<inheritdoc/>
	|        public override bool OnLeave(View view)
	|        {
	|            if ((!(view is MenuBar) && !(view is Menu) || !(view is MenuBar) && !(view is Menu) && openMenu != null) && !isCleaning && !reopen)
	|            {
	|                CleanUp();
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnKeyDown(KeyEvent keyEvent)
	|        {
	|            if (keyEvent.IsAlt || (keyEvent.IsCtrl && keyEvent.Key == (Key.CtrlMask | Key.Space)))
	|            {
	|                openedByAltKey = true;
	|                SetNeedsDisplay();
	|                openedByHotKey = false;
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnKeyUp(KeyEvent keyEvent)
	|        {
	|            if (keyEvent.IsAlt || keyEvent.Key == Key.AltMask || (keyEvent.IsCtrl && keyEvent.Key == (Key.CtrlMask | Key.Space)))
	|            {
	|                // User pressed Alt - this may be a precursor to a menu accelerator (e.g. Alt-F)
	|                if (openedByAltKey && !IsMenuOpen && openMenu == null && (((uint)keyEvent.Key & (uint)Key.CharMask) == 0
	|                    || ((uint)keyEvent.Key & (uint)Key.CharMask) == (uint)Key.Space))
	|                {
	|                    // There's no open menu, the first menu item should be highlight.
	|                    // The right way to do this is to SetFocus(MenuBar), but for some reason
	|                    // that faults.
	|
	|                    var mbar = GetMouseGrabViewInstance(this);
	|                    if (mbar != null)
	|                    {
	|                        mbar.CleanUp();
	|                    }
	|
	|                    //Activate (0);
	|                    //StartMenu ();
	|                    IsMenuOpen = true;
	|                    selected = 0;
	|                    CanFocus = true;
	|                    lastFocused = SuperView == null ? Application.Current.MostFocused : SuperView.MostFocused;
	|                    SetFocus();
	|                    SetNeedsDisplay();
	|                    Application.GrabMouse(this);
	|                }
	|                else if (!openedByHotKey)
	|                {
	|                    // There's an open menu. If this Alt key-up is a pre-cursor to an accelerator
	|                    // we don't want to close the menu because it'll flash.
	|                    // How to deal with that?
	|
	|                    CleanUp();
	|                }
	|
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        internal void CleanUp()
	|        {
	|            isCleaning = true;
	|            if (openMenu != null)
	|            {
	|                CloseAllMenus();
	|            }
	|            openedByAltKey = false;
	|            IsMenuOpen = false;
	|            selected = -1;
	|            CanFocus = false;
	|            if (lastFocused != null)
	|            {
	|                lastFocused.SetFocus();
	|            }
	|            SetNeedsDisplay();
	|            Application.UngrabMouse();
	|            isCleaning = false;
	|        }
	|
	|        // The column where the MenuBar starts
	|        static int xOrigin = 0;
	|        // Spaces before the Title
	|        static int leftPadding = 1;
	|        // Spaces after the Title
	|        static int rightPadding = 1;
	|        // Spaces after the submenu Title, before Help
	|        static int parensAroundHelp = 3;
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            Move(0, 0);
	|            Driver.SetAttribute(GetNormalColor());
	|            for (int i = 0; i < Frame.Width; i++)
	|                Driver.AddRune(' ');
	|
	|            Move(1, 0);
	|            int pos = 0;
	|
	|            for (int i = 0; i < Menus.Length; i++)
	|            {
	|                var menu = Menus[i];
	|                Move(pos, 0);
	|                Attribute hotColor, normalColor;
	|                if (i == selected && IsMenuOpen)
	|                {
	|                    hotColor = i == selected ? ColorScheme.HotFocus : ColorScheme.HotNormal;
	|                    normalColor = i == selected ? ColorScheme.Focus : GetNormalColor();
	|                }
	|                else
	|                {
	|                    hotColor = ColorScheme.HotNormal;
	|                    normalColor = GetNormalColor();
	|                }
	|                // Note Help on MenuBar is drawn with parens around it
	|                DrawHotString(menu.Help.IsEmpty ? $"" {menu.Title} "" : $"" {menu.Title} ({menu.Help}) "", hotColor, normalColor);
	|                pos += leftPadding + menu.TitleLength + (menu.Help.ConsoleWidth > 0 ? leftPadding + menu.Help.ConsoleWidth + parensAroundHelp : 0) + rightPadding;
	|            }
	|            PositionCursor();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            if (selected == -1 && HasFocus && Menus.Length > 0)
	|            {
	|                selected = 0;
	|            }
	|            int pos = 0;
	|            for (int i = 0; i < Menus.Length; i++)
	|            {
	|                if (i == selected)
	|                {
	|                    pos++;
	|                    Move(pos + 1, 0);
	|                    return;
	|                }
	|                else
	|                {
	|                    pos += leftPadding + Menus[i].TitleLength + (Menus[i].Help.ConsoleWidth > 0 ? Menus[i].Help.ConsoleWidth + parensAroundHelp : 0) + rightPadding;
	|                }
	|            }
	|        }
	|
	|        void Selected(MenuItem item)
	|        {
	|            var action = item.Action;
	|
	|            if (action == null)
	|                return;
	|
	|            Application.UngrabMouse();
	|            CloseAllMenus();
	|            Application.Refresh();
	|            Run(action);
	|        }
	|
	|        internal void Run(Action action)
	|        {
	|            Application.MainLoop.AddIdle(() =>
	|            {
	|                action();
	|                return false;
	|            });
	|
	|            CloseAllMenus();
	|        }
	|
	|        /// <summary>
	|        /// Raised as a menu is opening.
	|        /// </summary>
	|        public event Action<MenuOpeningEventArgs> MenuOpening;
	|
	|        /// <summary>
	|        /// Raised when a menu is opened.
	|        /// </summary>
	|        public event Action<MenuItem> MenuOpened;
	|
	|        /// <summary>
	|        /// Raised when a menu is closing passing <see cref=""MenuClosingEventArgs""/>.
	|        /// </summary>
	|        public event Action<MenuClosingEventArgs> MenuClosing;
	|
	|        /// <summary>
	|        /// Raised when all the menu is closed.
	|        /// </summary>
	|        public event Action MenuAllClosed;
	|
	|        internal Menu openMenu;
	|        Menu ocm;
	|        internal Menu openCurrentMenu
	|        {
	|            get => ocm;
	|            set
	|            {
	|                if (ocm != value)
	|                {
	|                    ocm = value;
	|                    if (ocm.current > -1)
	|                    {
	|                        OnMenuOpened();
	|                    }
	|                }
	|            }
	|        }
	|        internal List<Menu> openSubMenu;
	|        View previousFocused;
	|        internal bool isMenuOpening;
	|        internal bool isMenuClosing;
	|
	|        /// <summary>
	|        /// <see langword=""true""/> if the menu is open; otherwise <see langword=""true""/>.
	|        /// </summary>
	|        public bool IsMenuOpen { get; protected set; }
	|
	|        /// <summary>
	|        /// Virtual method that will invoke the <see cref=""MenuOpening""/> event if it's defined.
	|        /// </summary>
	|        /// <param name=""currentMenu"">The current menu to be replaced.</param>
	|        /// <returns>Returns the <see cref=""MenuOpeningEventArgs""/></returns>
	|        public virtual MenuOpeningEventArgs OnMenuOpening(MenuBarItem currentMenu)
	|        {
	|            var ev = new MenuOpeningEventArgs(currentMenu);
	|            MenuOpening?.Invoke(ev);
	|            return ev;
	|        }
	|
	|        /// <summary>
	|        /// Virtual method that will invoke the <see cref=""MenuOpened""/> event if it's defined.
	|        /// </summary>
	|        public virtual void OnMenuOpened()
	|        {
	|            MenuItem mi = null;
	|            if (openCurrentMenu.barItems.Children != null && openCurrentMenu.barItems.Children.Length > 0
	|                && openCurrentMenu?.current > -1)
	|            {
	|
	|                mi = openCurrentMenu.barItems.Children[openCurrentMenu.current];
	|            }
	|            else if (openCurrentMenu.barItems.IsTopLevel)
	|            {
	|                mi = openCurrentMenu.barItems;
	|            }
	|            else if (openCurrentMenu?.current > -1)
	|            {
	|                mi = openMenu.barItems.Children[openMenu.current];
	|            }
	|            MenuOpened?.Invoke(mi);
	|        }
	|
	|        /// <summary>
	|        /// Virtual method that will invoke the <see cref=""MenuClosing""/>.
	|        /// </summary>
	|        /// <param name=""currentMenu"">The current menu to be closed.</param>
	|        /// <param name=""reopen"">Whether the current menu will be reopen.</param>
	|        /// <param name=""isSubMenu"">Whether is a sub-menu or not.</param>
	|        public virtual MenuClosingEventArgs OnMenuClosing(MenuBarItem currentMenu, bool reopen, bool isSubMenu)
	|        {
	|            var ev = new MenuClosingEventArgs(currentMenu, reopen, isSubMenu);
	|            MenuClosing?.Invoke(ev);
	|            return ev;
	|        }
	|
	|        /// <summary>
	|        /// Virtual method that will invoke the <see cref=""MenuAllClosed""/>.
	|        /// </summary>
	|        public virtual void OnMenuAllClosed()
	|        {
	|            MenuAllClosed?.Invoke();
	|        }
	|
	|        View lastFocused;
	|
	|        /// <summary>
	|        /// Gets the view that was last focused before opening the menu.
	|        /// </summary>
	|        public View LastFocused { get; private set; }
	|
	|        internal void OpenMenu(int index, int sIndex = -1, MenuBarItem subMenu = null)
	|        {
	|            isMenuOpening = true;
	|            var newMenu = OnMenuOpening(Menus[index]);
	|            if (newMenu.Cancel)
	|            {
	|                isMenuOpening = false;
	|                return;
	|            }
	|            if (newMenu.NewMenuBarItem != null)
	|            {
	|                Menus[index] = newMenu.NewMenuBarItem;
	|            }
	|            int pos = 0;
	|            switch (subMenu)
	|            {
	|                case null:
	|                    // Open a submenu below a MenuBar
	|                    lastFocused = lastFocused ?? (SuperView == null ? Application.Current.MostFocused : SuperView.MostFocused);
	|                    if (openSubMenu != null && !CloseMenu(false, true))
	|                        return;
	|                    if (openMenu != null)
	|                    {
	|                        if (SuperView == null)
	|                        {
	|                            Application.Current.Remove(openMenu);
	|                        }
	|                        else
	|                        {
	|                            SuperView.Remove(openMenu);
	|                        }
	|                        openMenu.Dispose();
	|                    }
	|
	|                    // This positions the submenu horizontally aligned with the first character of the
	|                    // menu it belongs to's text
	|                    for (int i = 0; i < index; i++)
	|                        pos += Menus[i].TitleLength + (Menus[i].Help.ConsoleWidth > 0 ? Menus[i].Help.ConsoleWidth + 2 : 0) + leftPadding + rightPadding;
	|                    openMenu = new Menu(this, Frame.X + pos, Frame.Y + 1, Menus[index]);
	|                    openCurrentMenu = openMenu;
	|                    openCurrentMenu.previousSubFocused = openMenu;
	|
	|                    if (SuperView == null)
	|                    {
	|                        Application.Current.Add(openMenu);
	|                    }
	|                    else
	|                    {
	|                        SuperView.Add(openMenu);
	|                    }
	|                    openMenu.SetFocus();
	|                    break;
	|                default:
	|                    // Opens a submenu next to another submenu (openSubMenu)
	|                    if (openSubMenu == null)
	|                        openSubMenu = new List<Menu>();
	|                    if (sIndex > -1)
	|                    {
	|                        RemoveSubMenu(sIndex);
	|                    }
	|                    else
	|                    {
	|                        var last = openSubMenu.Count > 0 ? openSubMenu.Last() : openMenu;
	|                        if (!UseSubMenusSingleFrame)
	|                        {
	|                            openCurrentMenu = new Menu(this, last.Frame.Left + last.Frame.Width, last.Frame.Top + 1 + last.current, subMenu, last);
	|                        }
	|                        else
	|                        {
	|                            var first = openSubMenu.Count > 0 ? openSubMenu.First() : openMenu;
	|                            var mbi = new MenuItem[2 + subMenu.Children.Length];
	|                            mbi[0] = new MenuItem() { Title = subMenu.Title, Parent = subMenu };
	|                            mbi[1] = null;
	|                            for (int j = 0; j < subMenu.Children.Length; j++)
	|                            {
	|                                mbi[j + 2] = subMenu.Children[j];
	|                            }
	|                            var newSubMenu = new MenuBarItem(mbi);
	|                            openCurrentMenu = new Menu(this, first.Frame.Left, first.Frame.Top, newSubMenu);
	|                            last.Visible = false;
	|                            Application.GrabMouse(openCurrentMenu);
	|                        }
	|                        openCurrentMenu.previousSubFocused = last.previousSubFocused;
	|                        openSubMenu.Add(openCurrentMenu);
	|                        if (SuperView == null)
	|                        {
	|                            Application.Current.Add(openCurrentMenu);
	|                        }
	|                        else
	|                        {
	|                            SuperView.Add(openCurrentMenu);
	|                        }
	|                    }
	|                    selectedSub = openSubMenu.Count - 1;
	|                    if (selectedSub > -1 && SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current))
	|                    {
	|                        openCurrentMenu.SetFocus();
	|                    }
	|                    break;
	|            }
	|            isMenuOpening = false;
	|            IsMenuOpen = true;
	|        }
	|
	|        private int openIndex = 0;
	|        public int OpenIndex
	|        {
	|            get { return openIndex; }
	|            set { openIndex = value; }
	|        }
	|
	|        /// <summary>
	|        /// Opens the Menu programatically, as though the F9 key were pressed.
	|        /// </summary>
	|        public void OpenMenu()
	|        {
	|            var mbar = GetMouseGrabViewInstance(this);
	|            if (mbar != null)
	|            {
	|                mbar.CleanUp();
	|            }
	|
	|            if (openMenu != null)
	|                return;
	|            selected = OpenIndex;
	|            SetNeedsDisplay();
	|
	|            previousFocused = SuperView == null ? Application.Current.Focused : SuperView.Focused;
	|            OpenMenu(selected);
	|            if (!SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current) && !CloseMenu(false))
	|            {
	|                return;
	|            }
	|            if (!openCurrentMenu.CheckSubMenu())
	|                return;
	|            Application.GrabMouse(this);
	|        }
	|
	|        // Activates the menu, handles either first focus, or activating an entry when it was already active
	|        // For mouse events.
	|        internal void Activate(int idx, int sIdx = -1, MenuBarItem subMenu = null)
	|        {
	|            selected = idx;
	|            selectedSub = sIdx;
	|            if (openMenu == null)
	|                previousFocused = SuperView == null ? Application.Current.Focused : SuperView.Focused;
	|
	|            OpenMenu(idx, sIdx, subMenu);
	|            SetNeedsDisplay();
	|        }
	|
	|        internal bool SelectEnabledItem(IEnumerable<MenuItem> chldren, int current, out int newCurrent, bool forward = true)
	|        {
	|            if (chldren == null)
	|            {
	|                newCurrent = -1;
	|                return true;
	|            }
	|
	|            IEnumerable<MenuItem> childrens;
	|            if (forward)
	|            {
	|                childrens = chldren;
	|            }
	|            else
	|            {
	|                childrens = chldren.Reverse();
	|            }
	|            int count;
	|            if (forward)
	|            {
	|                count = -1;
	|            }
	|            else
	|            {
	|                count = childrens.Count();
	|            }
	|            foreach (var child in childrens)
	|            {
	|                if (forward)
	|                {
	|                    if (++count < current)
	|                    {
	|                        continue;
	|                    }
	|                }
	|                else
	|                {
	|                    if (--count > current)
	|                    {
	|                        continue;
	|                    }
	|                }
	|                if (child == null || !child.IsEnabled())
	|                {
	|                    if (forward)
	|                    {
	|                        current++;
	|                    }
	|                    else
	|                    {
	|                        current--;
	|                    }
	|                }
	|                else
	|                {
	|                    newCurrent = current;
	|                    return true;
	|                }
	|            }
	|            newCurrent = -1;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Closes the Menu programmatically if open and not canceled (as though F9 were pressed).
	|        /// </summary>
	|        public bool CloseMenu(bool ignoreUseSubMenusSingleFrame = false)
	|        {
	|            return CloseMenu(false, false, ignoreUseSubMenusSingleFrame);
	|        }
	|
	|        bool reopen;
	|
	|        internal bool CloseMenu(bool reopen = false, bool isSubMenu = false, bool ignoreUseSubMenusSingleFrame = false)
	|        {
	|            var mbi = isSubMenu ? openCurrentMenu.barItems : openMenu?.barItems;
	|            if (UseSubMenusSingleFrame && mbi != null &&
	|                !ignoreUseSubMenusSingleFrame && mbi.Parent != null)
	|            {
	|                return false;
	|            }
	|            isMenuClosing = true;
	|            this.reopen = reopen;
	|            var args = OnMenuClosing(mbi, reopen, isSubMenu);
	|            if (args.Cancel)
	|            {
	|                isMenuClosing = false;
	|                if (args.CurrentMenu.Parent != null)
	|                    openMenu.current = ((MenuBarItem)args.CurrentMenu.Parent).Children.IndexOf(args.CurrentMenu);
	|                return false;
	|            }
	|            switch (isSubMenu)
	|            {
	|                case false:
	|                    if (openMenu != null)
	|                    {
	|                        if (SuperView == null)
	|                        {
	|                            Application.Current.Remove(openMenu);
	|                        }
	|                        else
	|                        {
	|                            SuperView?.Remove(openMenu);
	|                        }
	|                    }
	|                    SetNeedsDisplay();
	|                    if (previousFocused != null && previousFocused is Menu && openMenu != null && previousFocused.ToString() != openCurrentMenu.ToString())
	|                        previousFocused.SetFocus();
	|                    openMenu?.Dispose();
	|                    openMenu = null;
	|                    if (lastFocused is Menu || lastFocused is MenuBar)
	|                    {
	|                        lastFocused = null;
	|                    }
	|                    LastFocused = lastFocused;
	|                    lastFocused = null;
	|                    if (LastFocused != null && LastFocused.CanFocus)
	|                    {
	|                        if (!reopen)
	|                        {
	|                            selected = -1;
	|                        }
	|                        LastFocused.SetFocus();
	|                    }
	|                    else if (LastFocused == null && !IsMenuOpen)
	|                    {
	|                        Application.Current?.FocusFirst();
	|                    }
	|                    else
	|                    {
	|                        SetFocus();
	|                        PositionCursor();
	|                    }
	|                    IsMenuOpen = false;
	|                    break;
	|
	|                case true:
	|                    selectedSub = -1;
	|                    SetNeedsDisplay();
	|                    RemoveAllOpensSubMenus();
	|                    openCurrentMenu.previousSubFocused.SetFocus();
	|                    openSubMenu = null;
	|                    IsMenuOpen = true;
	|                    break;
	|            }
	|            this.reopen = false;
	|            isMenuClosing = false;
	|            return true;
	|        }
	|
	|        void RemoveSubMenu(int index, bool ignoreUseSubMenusSingleFrame = false)
	|        {
	|            if (openSubMenu == null || (UseSubMenusSingleFrame
	|                && !ignoreUseSubMenusSingleFrame && openSubMenu.Count == 0))
	|
	|                return;
	|            for (int i = openSubMenu.Count - 1; i > index; i--)
	|            {
	|                isMenuClosing = true;
	|                Menu menu;
	|                if (openSubMenu.Count - 1 > 0)
	|                    menu = openSubMenu[i - 1];
	|                else
	|                    menu = openMenu;
	|                if (!menu.Visible)
	|                    menu.Visible = true;
	|                openCurrentMenu = menu;
	|                openCurrentMenu.SetFocus();
	|                if (openSubMenu != null)
	|                {
	|                    menu = openSubMenu[i];
	|                    if (SuperView == null)
	|                    {
	|                        Application.Current.Remove(menu);
	|                    }
	|                    else
	|                    {
	|                        SuperView.Remove(menu);
	|                    }
	|                    openSubMenu.Remove(menu);
	|                    menu.Dispose();
	|                }
	|                RemoveSubMenu(i, ignoreUseSubMenusSingleFrame);
	|            }
	|            if (openSubMenu.Count > 0)
	|                openCurrentMenu = openSubMenu.Last();
	|
	|            isMenuClosing = false;
	|        }
	|
	|        internal void RemoveAllOpensSubMenus()
	|        {
	|            if (openSubMenu != null)
	|            {
	|                foreach (var item in openSubMenu)
	|                {
	|                    if (SuperView == null)
	|                    {
	|                        Application.Current.Remove(item);
	|                    }
	|                    else
	|                    {
	|                        SuperView.Remove(item);
	|                    }
	|                    item.Dispose();
	|                }
	|            }
	|        }
	|
	|        internal void CloseAllMenus()
	|        {
	|            if (!isMenuOpening && !isMenuClosing)
	|            {
	|                if (openSubMenu != null && !CloseMenu(false, true))
	|                    return;
	|                if (!CloseMenu(false))
	|                    return;
	|                if (LastFocused != null && LastFocused != this)
	|                    selected = -1;
	|                Application.UngrabMouse();
	|            }
	|            IsMenuOpen = false;
	|            openedByHotKey = false;
	|            openedByAltKey = false;
	|            OnMenuAllClosed();
	|        }
	|
	|        View FindDeepestMenu(View view, ref int count)
	|        {
	|            count = count > 0 ? count : 0;
	|            foreach (var menu in view.Subviews)
	|            {
	|                if (menu is Menu)
	|                {
	|                    count++;
	|                    return FindDeepestMenu((Menu)menu, ref count);
	|                }
	|            }
	|            return view;
	|        }
	|
	|        internal void PreviousMenu(bool isSubMenu = false, bool ignoreUseSubMenusSingleFrame = false)
	|        {
	|            switch (isSubMenu)
	|            {
	|                case false:
	|                    if (selected <= 0)
	|                        selected = Menus.Length - 1;
	|                    else
	|                        selected--;
	|
	|                    if (selected > -1 && !CloseMenu(true, false, ignoreUseSubMenusSingleFrame))
	|                        return;
	|                    OpenMenu(selected);
	|                    if (!SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current, false))
	|                    {
	|                        openCurrentMenu.current = 0;
	|                    }
	|                    break;
	|                case true:
	|                    if (selectedSub > -1)
	|                    {
	|                        selectedSub--;
	|                        RemoveSubMenu(selectedSub, ignoreUseSubMenusSingleFrame);
	|                        SetNeedsDisplay();
	|                    }
	|                    else
	|                        PreviousMenu();
	|
	|                    break;
	|            }
	|        }
	|
	|        internal void NextMenu(bool isSubMenu = false, bool ignoreUseSubMenusSingleFrame = false)
	|        {
	|            switch (isSubMenu)
	|            {
	|                case false:
	|                    if (selected == -1)
	|                        selected = 0;
	|                    else if (selected + 1 == Menus.Length)
	|                        selected = 0;
	|                    else
	|                        selected++;
	|
	|                    if (selected > -1 && !CloseMenu(true, ignoreUseSubMenusSingleFrame))
	|                        return;
	|                    OpenMenu(selected);
	|                    SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current);
	|                    break;
	|                case true:
	|                    if (UseKeysUpDownAsKeysLeftRight)
	|                    {
	|                        if (CloseMenu(false, true, ignoreUseSubMenusSingleFrame))
	|                        {
	|                            NextMenu(false, ignoreUseSubMenusSingleFrame);
	|                        }
	|                    }
	|                    else
	|                    {
	|                        var subMenu = openCurrentMenu.current > -1 && openCurrentMenu.barItems.Children.Length > 0
	|                            ? openCurrentMenu.barItems.SubMenu(openCurrentMenu.barItems.Children[openCurrentMenu.current])
	|                            : null;
	|                        if ((selectedSub == -1 || openSubMenu == null || openSubMenu?.Count - 1 == selectedSub) && subMenu == null)
	|                        {
	|                            if (openSubMenu != null && !CloseMenu(false, true))
	|                                return;
	|                            NextMenu(false, ignoreUseSubMenusSingleFrame);
	|                        }
	|                        else if (subMenu != null || (openCurrentMenu.current > -1
	|                          && !openCurrentMenu.barItems.Children[openCurrentMenu.current].IsFromSubMenu))
	|                        {
	|                            selectedSub++;
	|                            openCurrentMenu.CheckSubMenu();
	|                        }
	|                        else
	|                        {
	|                            if (CloseMenu(false, true, ignoreUseSubMenusSingleFrame))
	|                            {
	|                                NextMenu(false, ignoreUseSubMenusSingleFrame);
	|                            }
	|                            return;
	|                        }
	|
	|                        SetNeedsDisplay();
	|                        if (UseKeysUpDownAsKeysLeftRight)
	|                            openCurrentMenu.CheckSubMenu();
	|                    }
	|                    break;
	|            }
	|        }
	|
	|        bool openedByHotKey;
	|        internal bool FindAndOpenMenuByHotkey(KeyEvent kb)
	|        {
	|            //int pos = 0;
	|            var c = ((uint)kb.Key & (uint)Key.CharMask);
	|            for (int i = 0; i < Menus.Length; i++)
	|            {
	|                // TODO: this code is duplicated, hotkey should be part of the MenuBarItem
	|                var mi = Menus[i];
	|                int p = mi.Title.IndexOf(MenuBar.HotKeySpecifier);
	|                if (p != -1 && p + 1 < mi.Title.RuneCount)
	|                {
	|                    if (Char.ToUpperInvariant((char)mi.Title[p + 1]) == c)
	|                    {
	|                        ProcessMenu(i, mi);
	|                        return true;
	|                    }
	|                    else if (mi.Children?.Length > 0)
	|                    {
	|                        if (FindAndOpenChildrenMenuByHotkey(kb, mi.Children))
	|                        {
	|                            return true;
	|                        }
	|                    }
	|                }
	|                else if (mi.Children?.Length > 0)
	|                {
	|                    if (FindAndOpenChildrenMenuByHotkey(kb, mi.Children))
	|                    {
	|                        return true;
	|                    }
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        bool FindAndOpenChildrenMenuByHotkey(KeyEvent kb, MenuItem[] children)
	|        {
	|            var c = ((uint)kb.Key & (uint)Key.CharMask);
	|            for (int i = 0; i < children.Length; i++)
	|            {
	|                var mi = children[i];
	|
	|                if (mi == null)
	|                {
	|                    continue;
	|                }
	|
	|                int p = mi.Title.IndexOf(MenuBar.HotKeySpecifier);
	|                if (p != -1 && p + 1 < mi.Title.RuneCount)
	|                {
	|                    if (Char.ToUpperInvariant((char)mi.Title[p + 1]) == c)
	|                    {
	|                        if (mi.IsEnabled())
	|                        {
	|                            var action = mi.Action;
	|                            if (action != null)
	|                            {
	|                                Run(action);
	|                            }
	|                        }
	|                        return true;
	|                    }
	|                    else if (mi is MenuBarItem menuBarItem && menuBarItem?.Children.Length > 0)
	|                    {
	|                        if (FindAndOpenChildrenMenuByHotkey(kb, menuBarItem.Children))
	|                        {
	|                            return true;
	|                        }
	|                    }
	|                }
	|                else if (mi is MenuBarItem menuBarItem && menuBarItem?.Children.Length > 0)
	|                {
	|                    if (FindAndOpenChildrenMenuByHotkey(kb, menuBarItem.Children))
	|                    {
	|                        return true;
	|                    }
	|                }
	|            }
	|            return false;
	|        }
	|
	|        internal bool FindAndOpenMenuByShortcut(KeyEvent kb, MenuItem[] children = null)
	|        {
	|            if (children == null)
	|            {
	|                children = Menus;
	|            }
	|
	|            var key = kb.KeyValue;
	|            var keys = ShortcutHelper.GetModifiersKey(kb);
	|            key |= (int)keys;
	|            for (int i = 0; i < children.Length; i++)
	|            {
	|                var mi = children[i];
	|                if (mi == null)
	|                {
	|                    continue;
	|                }
	|                if ((!(mi is MenuBarItem mbiTopLevel) || mbiTopLevel.IsTopLevel) && mi.Shortcut != Key.Null && mi.Shortcut == (Key)key)
	|                {
	|                    if (mi.IsEnabled())
	|                    {
	|                        var action = mi.Action;
	|                        if (action != null)
	|                        {
	|                            Run(action);
	|                        }
	|                    }
	|                    return true;
	|                }
	|                if (mi is MenuBarItem menuBarItem && menuBarItem.Children != null && !menuBarItem.IsTopLevel && FindAndOpenMenuByShortcut(kb, menuBarItem.Children))
	|                {
	|                    return true;
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        private void ProcessMenu(int i, MenuBarItem mi)
	|        {
	|            if (selected < 0 && IsMenuOpen)
	|            {
	|                return;
	|            }
	|
	|            if (mi.IsTopLevel)
	|            {
	|                var menu = new Menu(this, i, 0, mi);
	|                menu.Run(mi.Action);
	|                menu.Dispose();
	|            }
	|            else
	|            {
	|                openedByHotKey = true;
	|                Application.GrabMouse(this);
	|                selected = i;
	|                OpenMenu(i);
	|                if (!SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current) && !CloseMenu(false))
	|                {
	|                    return;
	|                }
	|                if (!openCurrentMenu.CheckSubMenu())
	|                    return;
	|            }
	|            SetNeedsDisplay();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessHotKey(KeyEvent kb)
	|        {
	|            if (kb.Key == Key)
	|            {
	|                if (Visible && !IsMenuOpen)
	|                {
	|                    OpenMenu();
	|                }
	|                else
	|                {
	|                    CloseAllMenus();
	|                }
	|                return true;
	|            }
	|
	|            // To ncurses simulate a AltMask key pressing Alt+Space because
	|            // it can't detect an alone special key down was pressed.
	|            if (kb.IsAlt && kb.Key == Key.AltMask && openMenu == null)
	|            {
	|                OnKeyDown(kb);
	|                OnKeyUp(kb);
	|                return true;
	|            }
	|            else if (kb.IsAlt && !kb.IsCtrl && !kb.IsShift)
	|            {
	|                if (FindAndOpenMenuByHotkey(kb)) return true;
	|            }
	|            //var kc = kb.KeyValue;
	|
	|            return base.ProcessHotKey(kb);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            if (InvokeKeybindings(kb) == true)
	|                return true;
	|
	|            var key = kb.KeyValue;
	|            if ((key >= 'a' && key <= 'z') || (key >= 'A' && key <= 'Z') || (key >= '0' && key <= '9'))
	|            {
	|                char c = Char.ToUpper((char)key);
	|
	|                if (selected == -1 || Menus[selected].IsTopLevel)
	|                    return false;
	|
	|                foreach (var mi in Menus[selected].Children)
	|                {
	|                    if (mi == null)
	|                        continue;
	|                    int p = mi.Title.IndexOf(MenuBar.HotKeySpecifier);
	|                    if (p != -1 && p + 1 < mi.Title.RuneCount)
	|                    {
	|                        if (mi.Title[p + 1] == c)
	|                        {
	|                            Selected(mi);
	|                            return true;
	|                        }
	|                    }
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        void CloseMenuBar()
	|        {
	|            if (!CloseMenu(false))
	|                return;
	|            if (openedByAltKey)
	|            {
	|                openedByAltKey = false;
	|                LastFocused?.SetFocus();
	|            }
	|            SetNeedsDisplay();
	|        }
	|
	|        void MoveRight()
	|        {
	|            selected = (selected + 1) % Menus.Length;
	|            OpenMenu(selected);
	|            SetNeedsDisplay();
	|        }
	|
	|        void MoveLeft()
	|        {
	|            selected--;
	|            if (selected < 0)
	|                selected = Menus.Length - 1;
	|            OpenMenu(selected);
	|            SetNeedsDisplay();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessColdKey(KeyEvent kb)
	|        {
	|            return FindAndOpenMenuByShortcut(kb);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!handled && !HandleGrabView(me, this))
	|            {
	|                return false;
	|            }
	|            handled = false;
	|
	|            if (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked || me.Flags == MouseFlags.Button1TripleClicked || me.Flags == MouseFlags.Button1Clicked ||
	|                (me.Flags == MouseFlags.ReportMousePosition && selected > -1) ||
	|                (me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) && selected > -1))
	|            {
	|                int pos = xOrigin;
	|                int cx = me.X;
	|                for (int i = 0; i < Menus.Length; i++)
	|                {
	|                    if (cx >= pos && cx < pos + leftPadding + Menus[i].TitleLength + Menus[i].Help.ConsoleWidth + rightPadding)
	|                    {
	|                        if (me.Flags == MouseFlags.Button1Clicked)
	|                        {
	|                            if (Menus[i].IsTopLevel)
	|                            {
	|                                var menu = new Menu(this, i, 0, Menus[i]);
	|                                menu.Run(Menus[i].Action);
	|                                menu.Dispose();
	|                            }
	|                            else if (!IsMenuOpen)
	|                            {
	|                                Activate(i);
	|                            }
	|                        }
	|                        else if (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked || me.Flags == MouseFlags.Button1TripleClicked)
	|                        {
	|                            if (IsMenuOpen && !Menus[i].IsTopLevel)
	|                            {
	|                                CloseAllMenus();
	|                            }
	|                            else if (!Menus[i].IsTopLevel)
	|                            {
	|                                Activate(i);
	|                            }
	|                        }
	|                        else if (selected != i && selected > -1 && (me.Flags == MouseFlags.ReportMousePosition ||
	|                          me.Flags == MouseFlags.Button1Pressed && me.Flags == MouseFlags.ReportMousePosition))
	|                        {
	|                            if (IsMenuOpen)
	|                            {
	|                                if (!CloseMenu(true, false))
	|                                {
	|                                    return true;
	|                                }
	|                                Activate(i);
	|                            }
	|                        }
	|                        else
	|                        {
	|                            if (IsMenuOpen)
	|                                Activate(i);
	|                        }
	|                        return true;
	|                    }
	|                    pos += leftPadding + Menus[i].TitleLength + rightPadding;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        internal bool handled;
	|        internal bool isContextMenuLoading;
	|
	|        internal bool HandleGrabView(MouseEvent me, View current)
	|        {
	|            if (Application.MouseGrabView != null)
	|            {
	|                if (me.View is MenuBar || me.View is Menu)
	|                {
	|                    var mbar = GetMouseGrabViewInstance(me.View);
	|                    if (mbar != null)
	|                    {
	|                        if (me.Flags == MouseFlags.Button1Clicked)
	|                        {
	|                            mbar.CleanUp();
	|                            Application.GrabMouse(me.View);
	|                        }
	|                        else
	|                        {
	|                            handled = false;
	|                            return false;
	|                        }
	|                    }
	|                    if (me.View != current)
	|                    {
	|                        Application.UngrabMouse();
	|                        var v = me.View;
	|                        Application.GrabMouse(v);
	|                        MouseEvent nme;
	|                        if (me.Y > -1)
	|                        {
	|                            var newxy = v.ScreenToView(me.X, me.Y);
	|                            nme = new MouseEvent()
	|                            {
	|                                X = newxy.X,
	|                                Y = newxy.Y,
	|                                Flags = me.Flags,
	|                                OfX = me.X - newxy.X,
	|                                OfY = me.Y - newxy.Y,
	|                                View = v
	|                            };
	|                        }
	|                        else
	|                        {
	|                            nme = new MouseEvent()
	|                            {
	|                                X = me.X + current.Frame.X,
	|                                Y = 0,
	|                                Flags = me.Flags,
	|                                View = v
	|                            };
	|                        }
	|
	|                        v.MouseEvent(nme);
	|                        return false;
	|                    }
	|                }
	|                else if (!isContextMenuLoading && !(me.View is MenuBar || me.View is Menu)
	|                  && me.Flags != MouseFlags.ReportMousePosition && me.Flags != 0)
	|                {
	|
	|                    Application.UngrabMouse();
	|                    if (IsMenuOpen)
	|                        CloseAllMenus();
	|                    handled = false;
	|                    return false;
	|                }
	|                else
	|                {
	|                    handled = false;
	|                    isContextMenuLoading = false;
	|                    return false;
	|                }
	|            }
	|            else if (!IsMenuOpen && (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked
	|              || me.Flags == MouseFlags.Button1TripleClicked || me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition)))
	|            {
	|
	|                Application.GrabMouse(current);
	|            }
	|            else if (IsMenuOpen && (me.View is MenuBar || me.View is Menu))
	|            {
	|                Application.GrabMouse(me.View);
	|            }
	|            else
	|            {
	|                handled = false;
	|                return false;
	|            }
	|
	|            handled = true;
	|
	|            return true;
	|        }
	|
	|        MenuBar GetMouseGrabViewInstance(View view)
	|        {
	|            if (view == null || Application.MouseGrabView == null)
	|            {
	|                return null;
	|            }
	|
	|            MenuBar hostView = null;
	|            if (view is MenuBar)
	|            {
	|                hostView = (MenuBar)view;
	|            }
	|            else if (view is Menu)
	|            {
	|                hostView = ((Menu)view).host;
	|            }
	|
	|            var grabView = Application.MouseGrabView;
	|            MenuBar hostGrabView = null;
	|            if (grabView is MenuBar)
	|            {
	|                hostGrabView = (MenuBar)grabView;
	|            }
	|            else if (grabView is Menu)
	|            {
	|                hostGrabView = ((Menu)grabView).host;
	|            }
	|
	|            return hostView != hostGrabView ? hostGrabView : null;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// An <see cref=""EventArgs""/> which allows passing a cancelable menu opening event or replacing with a new <see cref=""MenuBarItem""/>.
	|    /// </summary>
	|    public class MenuOpeningEventArgs : EventArgs
	|    {
	|        /// <summary>
	|        /// The current <see cref=""MenuBarItem""/> parent.
	|        /// </summary>
	|        public MenuBarItem CurrentMenu { get; }
	|
	|        /// <summary>
	|        /// The new <see cref=""MenuBarItem""/> to be replaced.
	|        /// </summary>
	|        public MenuBarItem NewMenuBarItem { get; set; }
	|        /// <summary>
	|        /// Flag that allows the cancellation of the event. If set to <see langword=""true""/> in the
	|        /// event handler, the event will be canceled. 
	|        /// </summary>
	|        public bool Cancel { get; set; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""MenuOpeningEventArgs""/>.
	|        /// </summary>
	|        /// <param name=""currentMenu"">The current <see cref=""MenuBarItem""/> parent.</param>
	|        public MenuOpeningEventArgs(MenuBarItem currentMenu)
	|        {
	|            CurrentMenu = currentMenu;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// An <see cref=""EventArgs""/> which allows passing a cancelable menu closing event.
	|    /// </summary>
	|    public class MenuClosingEventArgs : EventArgs
	|    {
	|        /// <summary>
	|        /// The current <see cref=""MenuBarItem""/> parent.
	|        /// </summary>
	|        public MenuBarItem CurrentMenu { get; }
	|
	|        /// <summary>
	|        /// Indicates whether the current menu will reopen.
	|        /// </summary>
	|        public bool Reopen { get; }
	|
	|        /// <summary>
	|        /// Indicates whether the current menu is a sub-menu.
	|        /// </summary>
	|        public bool IsSubMenu { get; }
	|
	|        /// <summary>
	|        /// Flag that allows the cancellation of the event. If set to <see langword=""true""/> in the
	|        /// event handler, the event will be canceled. 
	|        /// </summary>
	|        public bool Cancel { get; set; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""MenuClosingEventArgs""/>.
	|        /// </summary>
	|        /// <param name=""currentMenu"">The current <see cref=""MenuBarItem""/> parent.</param>
	|        /// <param name=""reopen"">Whether the current menu will reopen.</param>
	|        /// <param name=""isSubMenu"">Indicates whether it is a sub-menu.</param>
	|        public MenuClosingEventArgs(MenuBarItem currentMenu, bool reopen, bool isSubMenu)
	|        {
	|            CurrentMenu = currentMenu;
	|            Reopen = reopen;
	|            IsSubMenu = isSubMenu;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// MessageBox displays a modal message to the user, with a title, a message and a series of options that the user can choose from.
	|    /// </summary>
	|    /// <para>
	|    ///   The difference between the <see cref=""Query(ustring, ustring, ustring[])""/> and <see cref=""ErrorQuery(ustring, ustring, ustring[])""/> 
	|    ///   method is the default set of colors used for the message box.
	|    /// </para>
	|    /// <para>
	|    /// The following example pops up a <see cref=""MessageBox""/> with the specified title and text, plus two <see cref=""Button""/>s.
	|    /// The value -1 is returned when the user cancels the <see cref=""MessageBox""/> by pressing the ESC key.
	|    /// </para>
	|    /// <example>
	|    /// <code lang=""c#"">
	|    /// var n = MessageBox.Query (""Quit Demo"", ""Are you sure you want to quit this demo?"", ""Yes"", ""No"");
	|    /// if (n == 0)
	|    ///    quit = true;
	|    /// else
	|    ///    quit = false;
	|    /// </code>
	|    /// </example>
	|    public static class MessageBox
	|    {
	|        /// <summary>
	|        /// Presents a normal <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""width"">Width for the window.</param>
	|        /// <param name=""height"">Height for the window.</param>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// Use <see cref=""Query(ustring, ustring, ustring[])""/> instead; it automatically sizes the MessageBox based on the contents.
	|        /// </remarks>
	|        public static int Query(int width, int height, ustring title, ustring message, params ustring[] buttons)
	|        {
	|            return QueryFull(false, width, height, title, message, 0, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
	|        /// from the size of the message and buttons.
	|        /// </remarks>
	|        public static int Query(ustring title, ustring message, params ustring[] buttons)
	|        {
	|            return QueryFull(false, 0, 0, title, message, 0, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""width"">Width for the window.</param>
	|        /// <param name=""height"">Height for the window.</param>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// Use <see cref=""ErrorQuery(ustring, ustring, ustring[])""/> instead; it automatically sizes the MessageBox based on the contents.
	|        /// </remarks>
	|        public static int ErrorQuery(int width, int height, ustring title, ustring message, params ustring[] buttons)
	|        {
	|            return QueryFull(true, width, height, title, message, 0, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
	|        /// from the size of the title, message. and buttons.
	|        /// </remarks>
	|        public static int ErrorQuery(ustring title, ustring message, params ustring[] buttons)
	|        {
	|            return QueryFull(true, 0, 0, title, message, 0, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents a normal <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""width"">Width for the window.</param>
	|        /// <param name=""height"">Height for the window.</param>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// Use <see cref=""Query(ustring, ustring, ustring[])""/> instead; it automatically sizes the MessageBox based on the contents.
	|        /// </remarks>
	|        public static int Query(int width, int height, ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
	|        {
	|            return QueryFull(false, width, height, title, message, defaultButton, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
	|        /// from the size of the message and buttons.
	|        /// </remarks>
	|        public static int Query(ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
	|        {
	|            return QueryFull(false, 0, 0, title, message, defaultButton, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents a normal <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""width"">Width for the window.</param>
	|        /// <param name=""height"">Height for the window.</param>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""border"">The border settings.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// Use <see cref=""Query(ustring, ustring, ustring[])""/> instead; it automatically sizes the MessageBox based on the contents.
	|        /// </remarks>
	|        public static int Query(int width, int height, ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
	|        {
	|            return QueryFull(false, width, height, title, message, defaultButton, border, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""border"">The border settings.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
	|        /// from the size of the message and buttons.
	|        /// </remarks>
	|        public static int Query(ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
	|        {
	|            return QueryFull(false, 0, 0, title, message, defaultButton, border, buttons);
	|        }
	|
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""width"">Width for the window.</param>
	|        /// <param name=""height"">Height for the window.</param>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// Use <see cref=""ErrorQuery(ustring, ustring, ustring[])""/> instead; it automatically sizes the MessageBox based on the contents.
	|        /// </remarks>
	|        public static int ErrorQuery(int width, int height, ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
	|        {
	|            return QueryFull(true, width, height, title, message, defaultButton, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
	|        /// from the size of the title, message. and buttons.
	|        /// </remarks>
	|        public static int ErrorQuery(ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
	|        {
	|            return QueryFull(true, 0, 0, title, message, defaultButton, null, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""width"">Width for the window.</param>
	|        /// <param name=""height"">Height for the window.</param>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""border"">The border settings.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// Use <see cref=""ErrorQuery(ustring, ustring, ustring[])""/> instead; it automatically sizes the MessageBox based on the contents.
	|        /// </remarks>
	|        public static int ErrorQuery(int width, int height, ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
	|        {
	|            return QueryFull(true, width, height, title, message, defaultButton, border, buttons);
	|        }
	|
	|        /// <summary>
	|        /// Presents an error <see cref=""MessageBox""/> with the specified title and message and a list of buttons to show to the user.
	|        /// </summary>
	|        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
	|        /// <param name=""title"">Title for the query.</param>
	|        /// <param name=""message"">Message to display, might contain multiple lines.</param>
	|        /// <param name=""defaultButton"">Index of the default button.</param>
	|        /// <param name=""border"">The border settings.</param>
	|        /// <param name=""buttons"">Array of buttons to add.</param>
	|        /// <remarks>
	|        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
	|        /// from the size of the title, message. and buttons.
	|        /// </remarks>
	|        public static int ErrorQuery(ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
	|        {
	|            return QueryFull(true, 0, 0, title, message, defaultButton, border, buttons);
	|        }
	|
	|        static int QueryFull(bool useErrorColors, int width, int height, ustring title, ustring message,
	|            int defaultButton = 0, Border border = null, params ustring[] buttons)
	|        {
	|            int defaultWidth = 50;
	|            if (defaultWidth > Application.Driver.Cols / 2)
	|            {
	|                defaultWidth = (int)(Application.Driver.Cols * 0.60f);
	|            }
	|            int maxWidthLine = TextFormatter.MaxWidthLine(message);
	|            if (maxWidthLine > Application.Driver.Cols)
	|            {
	|                maxWidthLine = Application.Driver.Cols;
	|            }
	|            if (width == 0)
	|            {
	|                maxWidthLine = Math.Max(maxWidthLine, defaultWidth);
	|            }
	|            else
	|            {
	|                maxWidthLine = width;
	|            }
	|            int textWidth = Math.Min(TextFormatter.MaxWidth(message, maxWidthLine), Application.Driver.Cols);
	|            int textHeight = TextFormatter.MaxLines(message, textWidth); // message.Count (ustring.Make ('\n')) + 1;
	|            int msgboxHeight = Math.Min(Math.Max(1, textHeight) + 4, Application.Driver.Rows); // textHeight + (top + top padding + buttons + bottom)
	|
	|            // Create button array for Dialog
	|            int count = 0;
	|            List<Button> buttonList = new List<Button>();
	|            if (buttons != null && defaultButton > buttons.Length - 1)
	|            {
	|                defaultButton = buttons.Length - 1;
	|            }
	|            foreach (var s in buttons)
	|            {
	|                var b = new Button(s);
	|                if (count == defaultButton)
	|                {
	|                    b.IsDefault = true;
	|                }
	|                buttonList.Add(b);
	|                count++;
	|            }
	|
	|            // Create Dialog (retain backwards compat by supporting specifying height/width)
	|            Dialog d;
	|            if (width == 0 & height == 0)
	|            {
	|                d = new Dialog(title, buttonList.ToArray())
	|                {
	|                    Height = msgboxHeight
	|                };
	|            }
	|            else
	|            {
	|                d = new Dialog(title, width, Math.Max(height, 4), buttonList.ToArray());
	|            }
	|
	|            if (border != null)
	|            {
	|                d.Border = border;
	|            }
	|
	|            if (useErrorColors)
	|            {
	|                d.ColorScheme = Colors.Error;
	|            }
	|
	|            if (message != null)
	|            {
	|                var l = new Label(message)
	|                {
	|                    LayoutStyle = LayoutStyle.Computed,
	|                    TextAlignment = TextAlignment.Centered,
	|                    X = Pos.Center(),
	|                    Y = Pos.Center(),
	|                    Width = Dim.Fill(),
	|                    Height = Dim.Fill(1),
	|                    AutoSize = false
	|                };
	|                d.Add(l);
	|            }
	|
	|            if (width == 0 & height == 0)
	|            {
	|                // Dynamically size Width
	|                d.Width = Math.Min(Math.Max(maxWidthLine, Math.Max(title.ConsoleWidth, Math.Max(textWidth + 2, d.GetButtonsWidth() + d.buttons.Count + 2))), Application.Driver.Cols); // textWidth + (left + padding + padding + right)
	|            }
	|
	|            // Setup actions
	|            Clicked = -1;
	|            for (int n = 0; n < buttonList.Count; n++)
	|            {
	|                int buttonId = n;
	|                var b = buttonList[n];
	|                b.Clicked += () =>
	|                {
	|                    Clicked = buttonId;
	|                    Application.RequestStop();
	|                };
	|                if (b.IsDefault)
	|                {
	|                    b.SetFocus();
	|                }
	|            }
	|
	|            // Run the modal; do not shutdown the mainloop driver when done
	|            Application.Run(d);
	|            return Clicked;
	|        }
	|
	|        /// <summary>
	|        /// The index of the selected button, or -1 if the user pressed ESC to close the dialog.
	|        /// This is useful for web based console where by default there is no SynchronizationContext or TaskScheduler.
	|        /// </summary>
	|        public static int Clicked { get; private set; } = -1;
	|    }
	|    //=======================================================================
	|    //
	|    // NetDriver.cs: The System.Console-based .NET driver, works on Windows and Unix, but is not particularly efficient.
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    internal class NetWinVTConsole
	|    {
	|        IntPtr InputHandle, OutputHandle, ErrorHandle;
	|        uint originalInputConsoleMode, originalOutputConsoleMode, originalErrorConsoleMode;
	|
	|        public NetWinVTConsole()
	|        {
	|            InputHandle = GetStdHandle(STD_INPUT_HANDLE);
	|            if (!GetConsoleMode(InputHandle, out uint mode))
	|            {
	|                throw new ApplicationException($""Failed to get input console mode, error code: {GetLastError()}."");
	|            }
	|            originalInputConsoleMode = mode;
	|            if ((mode & ENABLE_VIRTUAL_TERMINAL_INPUT) < ENABLE_VIRTUAL_TERMINAL_INPUT)
	|            {
	|                mode |= ENABLE_VIRTUAL_TERMINAL_INPUT;
	|                if (!SetConsoleMode(InputHandle, mode))
	|                {
	|                    throw new ApplicationException($""Failed to set input console mode, error code: {GetLastError()}."");
	|                }
	|            }
	|
	|            OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
	|            if (!GetConsoleMode(OutputHandle, out mode))
	|            {
	|                throw new ApplicationException($""Failed to get output console mode, error code: {GetLastError()}."");
	|            }
	|            originalOutputConsoleMode = mode;
	|            if ((mode & (ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN)) < DISABLE_NEWLINE_AUTO_RETURN)
	|            {
	|                mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;
	|                if (!SetConsoleMode(OutputHandle, mode))
	|                {
	|                    throw new ApplicationException($""Failed to set output console mode, error code: {GetLastError()}."");
	|                }
	|            }
	|
	|            ErrorHandle = GetStdHandle(STD_ERROR_HANDLE);
	|            if (!GetConsoleMode(ErrorHandle, out mode))
	|            {
	|                throw new ApplicationException($""Failed to get error console mode, error code: {GetLastError()}."");
	|            }
	|            originalErrorConsoleMode = mode;
	|            if ((mode & (DISABLE_NEWLINE_AUTO_RETURN)) < DISABLE_NEWLINE_AUTO_RETURN)
	|            {
	|                mode |= DISABLE_NEWLINE_AUTO_RETURN;
	|                if (!SetConsoleMode(ErrorHandle, mode))
	|                {
	|                    throw new ApplicationException($""Failed to set error console mode, error code: {GetLastError()}."");
	|                }
	|            }
	|        }
	|
	|        public void Cleanup()
	|        {
	|            if (!SetConsoleMode(InputHandle, originalInputConsoleMode))
	|            {
	|                throw new ApplicationException($""Failed to restore input console mode, error code: {GetLastError()}."");
	|            }
	|            if (!SetConsoleMode(OutputHandle, originalOutputConsoleMode))
	|            {
	|                throw new ApplicationException($""Failed to restore output console mode, error code: {GetLastError()}."");
	|            }
	|            if (!SetConsoleMode(ErrorHandle, originalErrorConsoleMode))
	|            {
	|                throw new ApplicationException($""Failed to restore error console mode, error code: {GetLastError()}."");
	|            }
	|        }
	|
	|        const int STD_INPUT_HANDLE = -10;
	|        const int STD_OUTPUT_HANDLE = -11;
	|        const int STD_ERROR_HANDLE = -12;
	|
	|        // Input modes.
	|        const uint ENABLE_PROCESSED_INPUT = 1;
	|        const uint ENABLE_LINE_INPUT = 2;
	|        const uint ENABLE_ECHO_INPUT = 4;
	|        const uint ENABLE_WINDOW_INPUT = 8;
	|        const uint ENABLE_MOUSE_INPUT = 16;
	|        const uint ENABLE_INSERT_MODE = 32;
	|        const uint ENABLE_QUICK_EDIT_MODE = 64;
	|        const uint ENABLE_EXTENDED_FLAGS = 128;
	|        const uint ENABLE_VIRTUAL_TERMINAL_INPUT = 512;
	|
	|        // Output modes.
	|        const uint ENABLE_PROCESSED_OUTPUT = 1;
	|        const uint ENABLE_WRAP_AT_EOL_OUTPUT = 2;
	|        const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4;
	|        const uint DISABLE_NEWLINE_AUTO_RETURN = 8;
	|        const uint ENABLE_LVB_GRID_WORLDWIDE = 10;
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern IntPtr GetStdHandle(int nStdHandle);
	|
	|        [DllImport(""kernel32.dll"")]
	|        static extern bool GetConsoleMode(IntPtr hConsoleHandle, out uint lpMode);
	|
	|        [DllImport(""kernel32.dll"")]
	|        static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint dwMode);
	|
	|        [DllImport(""kernel32.dll"")]
	|        static extern uint GetLastError();
	|    }
	|
	|    internal class NetEvents
	|    {
	|        ManualResetEventSlim inputReady = new ManualResetEventSlim(false);
	|        ManualResetEventSlim waitForStart = new ManualResetEventSlim(false);
	|        ManualResetEventSlim winChange = new ManualResetEventSlim(false);
	|        Queue<InputResult?> inputResultQueue = new Queue<InputResult?>();
	|        ConsoleDriver consoleDriver;
	|        volatile ConsoleKeyInfo[] cki = null;
	|        static volatile bool isEscSeq;
	|
	|        internal CancellationTokenSource TokenSource = new CancellationTokenSource();
	|
	|#if PROCESS_REQUEST
	|		bool neededProcessRequest;
	|#endif
	|        public EscSeqReqProc EscSeqReqProc { get; } = new EscSeqReqProc();
	|
	|        public NetEvents(ConsoleDriver consoleDriver)
	|        {
	|            if (consoleDriver == null)
	|            {
	|                throw new ArgumentNullException(""Console driver instance must be provided."");
	|            }
	|            this.consoleDriver = consoleDriver;
	|            Task.Run(ProcessInputResultQueue, TokenSource.Token);
	|            Task.Run(CheckWinChange, TokenSource.Token);
	|        }
	|
	|        public InputResult? ReadConsoleInput()
	|        {
	|            while (!TokenSource.IsCancellationRequested)
	|            {
	|                waitForStart.Set();
	|                winChange.Set();
	|
	|                if (inputResultQueue.Count == 0)
	|                {
	|                    inputReady.Wait();
	|                    inputReady.Reset();
	|                }
	|#if PROCESS_REQUEST
	|				neededProcessRequest = false;
	|#endif
	|                if (inputResultQueue.Count > 0)
	|                {
	|                    return inputResultQueue.Dequeue();
	|                }
	|            }
	|
	|            return null;
	|        }
	|
	|        void ProcessInputResultQueue()
	|        {
	|            while (!TokenSource.IsCancellationRequested)
	|            {
	|                waitForStart.Wait();
	|                waitForStart.Reset();
	|
	|                if (inputResultQueue.Count == 0)
	|                {
	|                    GetConsoleKey();
	|                }
	|
	|                inputReady.Set();
	|            }
	|        }
	|
	|        void GetConsoleKey()
	|        {
	|            ConsoleKey key = 0;
	|            ConsoleModifiers mod = 0;
	|            ConsoleKeyInfo newConsoleKeyInfo = default;
	|
	|            while (!TokenSource.IsCancellationRequested)
	|            {
	|                ConsoleKeyInfo consoleKeyInfo = default;
	|
	|                try
	|                {
	|                    if (Console.KeyAvailable)
	|                    {
	|                        consoleKeyInfo = Console.ReadKey(true);
	|                    }
	|                    else
	|                    {
	|                        Task.Delay(100, TokenSource.Token).Wait(TokenSource.Token);
	|                        if (Console.KeyAvailable)
	|                        {
	|                            consoleKeyInfo = Console.ReadKey(true);
	|                        }
	|                    }
	|                }
	|                catch (OperationCanceledException)
	|                {
	|
	|                    return;
	|                }
	|
	|                if ((consoleKeyInfo.KeyChar == (char)Key.Esc && !isEscSeq)
	|                    || (consoleKeyInfo.KeyChar != (char)Key.Esc && isEscSeq))
	|                {
	|                    if (cki == null && consoleKeyInfo.KeyChar != (char)Key.Esc && isEscSeq)
	|                    {
	|                        cki = EscSeqUtils.ResizeArray(new ConsoleKeyInfo((char)Key.Esc, 0,
	|                            false, false, false), cki);
	|                    }
	|                    isEscSeq = true;
	|                    newConsoleKeyInfo = consoleKeyInfo;
	|                    cki = EscSeqUtils.ResizeArray(consoleKeyInfo, cki);
	|                    if (!Console.KeyAvailable)
	|                    {
	|                        DecodeEscSeq(ref newConsoleKeyInfo, ref key, cki, ref mod);
	|                        cki = null;
	|                        isEscSeq = false;
	|                        break;
	|                    }
	|                }
	|                else if (consoleKeyInfo.KeyChar == (char)Key.Esc && isEscSeq)
	|                {
	|                    DecodeEscSeq(ref newConsoleKeyInfo, ref key, cki, ref mod);
	|                    cki = null;
	|                    if (!Console.KeyAvailable)
	|                    {
	|                        isEscSeq = false;
	|                    }
	|                    break;
	|                }
	|                else
	|                {
	|                    if (consoleKeyInfo != default)
	|                    {
	|                        GetConsoleInputType(consoleKeyInfo);
	|                        break;
	|                    }
	|                }
	|
	|                TokenSource.Token.ThrowIfCancellationRequested();
	|            }
	|        }
	|
	|        void CheckWinChange()
	|        {
	|            while (!TokenSource.IsCancellationRequested)
	|            {
	|                winChange.Wait();
	|                winChange.Reset();
	|                WaitWinChange();
	|                inputReady.Set();
	|            }
	|        }
	|
	|        void WaitWinChange()
	|        {
	|            while (!TokenSource.IsCancellationRequested)
	|            {
	|                try
	|                {
	|                    // Wait for a while then check if screen has changed sizes
	|                    Task.Delay(500, TokenSource.Token).Wait(TokenSource.Token);
	|
	|                }
	|                catch (OperationCanceledException)
	|                {
	|
	|                    return;
	|                }
	|
	|                int buffHeight, buffWidth;
	|                if (((NetDriver)consoleDriver).IsWinPlatform)
	|                {
	|                    buffHeight = Math.Max(Console.BufferHeight, 0);
	|                    buffWidth = Math.Max(Console.BufferWidth, 0);
	|                }
	|                else
	|                {
	|                    buffHeight = consoleDriver.Rows;
	|                    buffWidth = consoleDriver.Cols;
	|                }
	|                if (IsWinChanged(
	|                    Math.Max(Console.WindowHeight, 0),
	|                    Math.Max(Console.WindowWidth, 0),
	|                    buffHeight,
	|                    buffWidth))
	|                {
	|
	|                    return;
	|                }
	|            }
	|        }
	|
	|        bool IsWinChanged(int winHeight, int winWidth, int buffHeight, int buffWidth)
	|        {
	|            if (winWidth != consoleDriver.Cols || winHeight != consoleDriver.Rows)
	|            {
	|                var w = Math.Max(winWidth, 0);
	|                var h = Math.Max(winHeight, 0);
	|                GetWindowSizeEvent(new Size(w, h));
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        void GetWindowSizeEvent(Size size)
	|        {
	|            WindowSizeEvent windowSizeEvent = new WindowSizeEvent()
	|            {
	|                Size = size
	|            };
	|
	|            inputResultQueue.Enqueue(new InputResult()
	|            {
	|                EventType = EventType.WindowSize,
	|                WindowSizeEvent = windowSizeEvent
	|            });
	|        }
	|
	|        void GetConsoleInputType(ConsoleKeyInfo consoleKeyInfo)
	|        {
	|            InputResult inputResult = new InputResult
	|            {
	|                EventType = EventType.Key
	|            };
	|            MouseEvent mouseEvent = new MouseEvent();
	|            ConsoleKeyInfo newConsoleKeyInfo = EscSeqUtils.GetConsoleInputKey(consoleKeyInfo);
	|            if (inputResult.EventType == EventType.Key)
	|            {
	|                inputResult.ConsoleKeyInfo = newConsoleKeyInfo;
	|            }
	|            else
	|            {
	|                inputResult.MouseEvent = mouseEvent;
	|            }
	|
	|            inputResultQueue.Enqueue(inputResult);
	|        }
	|
	|        void DecodeEscSeq(ref ConsoleKeyInfo newConsoleKeyInfo, ref ConsoleKey key, ConsoleKeyInfo[] cki, ref ConsoleModifiers mod)
	|        {
	|            string c1Control, code, terminating;
	|            string[] values;
	|            // isKeyMouse is true if it's CSI<, false otherwise
	|            bool isKeyMouse;
	|            bool isReq;
	|            List<MouseFlags> mouseFlags;
	|            Point pos;
	|            EscSeqUtils.DecodeEscSeq(EscSeqReqProc, ref newConsoleKeyInfo, ref key, cki, ref mod, out c1Control, out code, out values, out terminating, out isKeyMouse, out mouseFlags, out pos, out isReq, ProcessContinuousButtonPressed);
	|
	|            if (isKeyMouse)
	|            {
	|                foreach (var mf in mouseFlags)
	|                {
	|                    GetMouseEvent(MapMouseFlags(mf), pos);
	|                }
	|                return;
	|            }
	|            else if (isReq)
	|            {
	|                GetRequestEvent(c1Control, code, values, terminating);
	|                return;
	|            }
	|            InputResult inputResult = new InputResult
	|            {
	|                EventType = EventType.Key,
	|                ConsoleKeyInfo = newConsoleKeyInfo
	|            };
	|
	|            inputResultQueue.Enqueue(inputResult);
	|        }
	|
	|        void ProcessContinuousButtonPressed(MouseFlags mouseFlag, Point pos)
	|        {
	|            GetMouseEvent(MapMouseFlags(mouseFlag), pos);
	|        }
	|
	|        MouseButtonState MapMouseFlags(MouseFlags mouseFlags)
	|        {
	|            MouseButtonState mbs = default;
	|            foreach (var flag in Enum.GetValues(mouseFlags.GetType()))
	|            {
	|                if (mouseFlags.HasFlag((MouseFlags)flag))
	|                {
	|                    switch (flag)
	|                    {
	|                        case MouseFlags.Button1Pressed:
	|                            mbs |= MouseButtonState.Button1Pressed;
	|                            break;
	|                        case MouseFlags.Button1Released:
	|                            mbs |= MouseButtonState.Button1Released;
	|                            break;
	|                        case MouseFlags.Button1Clicked:
	|                            mbs |= MouseButtonState.Button1Clicked;
	|                            break;
	|                        case MouseFlags.Button1DoubleClicked:
	|                            mbs |= MouseButtonState.Button1DoubleClicked;
	|                            break;
	|                        case MouseFlags.Button1TripleClicked:
	|                            mbs |= MouseButtonState.Button1TripleClicked;
	|                            break;
	|                        case MouseFlags.Button2Pressed:
	|                            mbs |= MouseButtonState.Button2Pressed;
	|                            break;
	|                        case MouseFlags.Button2Released:
	|                            mbs |= MouseButtonState.Button2Released;
	|                            break;
	|                        case MouseFlags.Button2Clicked:
	|                            mbs |= MouseButtonState.Button2Clicked;
	|                            break;
	|                        case MouseFlags.Button2DoubleClicked:
	|                            mbs |= MouseButtonState.Button2DoubleClicked;
	|                            break;
	|                        case MouseFlags.Button2TripleClicked:
	|                            mbs |= MouseButtonState.Button2TripleClicked;
	|                            break;
	|                        case MouseFlags.Button3Pressed:
	|                            mbs |= MouseButtonState.Button3Pressed;
	|                            break;
	|                        case MouseFlags.Button3Released:
	|                            mbs |= MouseButtonState.Button3Released;
	|                            break;
	|                        case MouseFlags.Button3Clicked:
	|                            mbs |= MouseButtonState.Button3Clicked;
	|                            break;
	|                        case MouseFlags.Button3DoubleClicked:
	|                            mbs |= MouseButtonState.Button3DoubleClicked;
	|                            break;
	|                        case MouseFlags.Button3TripleClicked:
	|                            mbs |= MouseButtonState.Button3TripleClicked;
	|                            break;
	|                        case MouseFlags.WheeledUp:
	|                            mbs |= MouseButtonState.ButtonWheeledUp;
	|                            break;
	|                        case MouseFlags.WheeledDown:
	|                            mbs |= MouseButtonState.ButtonWheeledDown;
	|                            break;
	|                        case MouseFlags.WheeledLeft:
	|                            mbs |= MouseButtonState.ButtonWheeledLeft;
	|                            break;
	|                        case MouseFlags.WheeledRight:
	|                            mbs |= MouseButtonState.ButtonWheeledRight;
	|                            break;
	|                        case MouseFlags.Button4Pressed:
	|                            mbs |= MouseButtonState.Button4Pressed;
	|                            break;
	|                        case MouseFlags.Button4Released:
	|                            mbs |= MouseButtonState.Button4Released;
	|                            break;
	|                        case MouseFlags.Button4Clicked:
	|                            mbs |= MouseButtonState.Button4Clicked;
	|                            break;
	|                        case MouseFlags.Button4DoubleClicked:
	|                            mbs |= MouseButtonState.Button4DoubleClicked;
	|                            break;
	|                        case MouseFlags.Button4TripleClicked:
	|                            mbs |= MouseButtonState.Button4TripleClicked;
	|                            break;
	|                        case MouseFlags.ButtonShift:
	|                            mbs |= MouseButtonState.ButtonShift;
	|                            break;
	|                        case MouseFlags.ButtonCtrl:
	|                            mbs |= MouseButtonState.ButtonCtrl;
	|                            break;
	|                        case MouseFlags.ButtonAlt:
	|                            mbs |= MouseButtonState.ButtonAlt;
	|                            break;
	|                        case MouseFlags.ReportMousePosition:
	|                            mbs |= MouseButtonState.ReportMousePosition;
	|                            break;
	|                        case MouseFlags.AllEvents:
	|                            mbs |= MouseButtonState.AllEvents;
	|                            break;
	|                    }
	|                }
	|            }
	|            return mbs;
	|        }
	|
	|        Point lastCursorPosition;
	|
	|        void GetRequestEvent(string c1Control, string code, string[] values, string terminating)
	|        {
	|            EventType eventType = new EventType();
	|            switch (terminating)
	|            {
	|                case ""R"": // Reports cursor position as CSI r ; c R
	|                    Point point = new Point
	|                    {
	|                        X = int.Parse(values[1]) - 1,
	|                        Y = int.Parse(values[0]) - 1
	|                    };
	|                    if (lastCursorPosition.Y != point.Y)
	|                    {
	|                        lastCursorPosition = point;
	|                        eventType = EventType.WindowPosition;
	|                        var winPositionEv = new WindowPositionEvent()
	|                        {
	|                            Top = 0,
	|                            Left = 0,
	|                            CursorPosition = point
	|                        };
	|                        inputResultQueue.Enqueue(new InputResult()
	|                        {
	|                            EventType = eventType,
	|                            WindowPositionEvent = winPositionEv
	|                        });
	|                    }
	|                    else
	|                    {
	|                        return;
	|                    }
	|                    break;
	|                default:
	|                    SetRequestedEvent(c1Control, code, values, terminating);
	|                    break;
	|            }
	|
	|            inputReady.Set();
	|        }
	|
	|        void SetRequestedEvent(string c1Control, string code, string[] values, string terminating)
	|        {
	|            EventType eventType = EventType.RequestResponse;
	|            var requestRespEv = new RequestResponseEvent()
	|            {
	|                ResultTuple = (c1Control, code, values, terminating)
	|            };
	|            inputResultQueue.Enqueue(new InputResult()
	|            {
	|                EventType = eventType,
	|                RequestResponseEvent = requestRespEv
	|            });
	|        }
	|
	|        void GetMouseEvent(MouseButtonState buttonState, Point pos)
	|        {
	|            MouseEvent mouseEvent = new MouseEvent()
	|            {
	|                Position = pos,
	|                ButtonState = buttonState,
	|            };
	|
	|            inputResultQueue.Enqueue(new InputResult()
	|            {
	|                EventType = EventType.Mouse,
	|                MouseEvent = mouseEvent
	|            });
	|
	|            inputReady.Set();
	|        }
	|
	|        public enum EventType
	|        {
	|            Key = 1,
	|            Mouse = 2,
	|            WindowSize = 3,
	|            WindowPosition = 4,
	|            RequestResponse = 5
	|        }
	|
	|        [Flags]
	|        public enum MouseButtonState
	|        {
	|            Button1Pressed = 0x1,
	|            Button1Released = 0x2,
	|            Button1Clicked = 0x4,
	|            Button1DoubleClicked = 0x8,
	|            Button1TripleClicked = 0x10,
	|            Button2Pressed = 0x20,
	|            Button2Released = 0x40,
	|            Button2Clicked = 0x80,
	|            Button2DoubleClicked = 0x100,
	|            Button2TripleClicked = 0x200,
	|            Button3Pressed = 0x400,
	|            Button3Released = 0x800,
	|            Button3Clicked = 0x1000,
	|            Button3DoubleClicked = 0x2000,
	|            Button3TripleClicked = 0x4000,
	|            ButtonWheeledUp = 0x8000,
	|            ButtonWheeledDown = 0x10000,
	|            ButtonWheeledLeft = 0x20000,
	|            ButtonWheeledRight = 0x40000,
	|            Button4Pressed = 0x80000,
	|            Button4Released = 0x100000,
	|            Button4Clicked = 0x200000,
	|            Button4DoubleClicked = 0x400000,
	|            Button4TripleClicked = 0x800000,
	|            ButtonShift = 0x1000000,
	|            ButtonCtrl = 0x2000000,
	|            ButtonAlt = 0x4000000,
	|            ReportMousePosition = 0x8000000,
	|            AllEvents = -1
	|        }
	|
	|        public struct MouseEvent
	|        {
	|            public Point Position;
	|            public MouseButtonState ButtonState;
	|        }
	|
	|        public struct WindowSizeEvent
	|        {
	|            public Size Size;
	|        }
	|
	|        public struct WindowPositionEvent
	|        {
	|            public int Top;
	|            public int Left;
	|            public Point CursorPosition;
	|        }
	|
	|        public struct RequestResponseEvent
	|        {
	|            public (string c1Control, string code, string[] values, string terminating) ResultTuple;
	|        }
	|
	|        public struct InputResult
	|        {
	|            public EventType EventType;
	|            public ConsoleKeyInfo ConsoleKeyInfo;
	|            public MouseEvent MouseEvent;
	|            public WindowSizeEvent WindowSizeEvent;
	|            public WindowPositionEvent WindowPositionEvent;
	|            public RequestResponseEvent RequestResponseEvent;
	|        }
	|    }
	|
	|    internal class NetDriver : ConsoleDriver
	|    {
	|        const int COLOR_BLACK = 30;
	|        const int COLOR_RED = 31;
	|        const int COLOR_GREEN = 32;
	|        const int COLOR_YELLOW = 33;
	|        const int COLOR_BLUE = 34;
	|        const int COLOR_MAGENTA = 35;
	|        const int COLOR_CYAN = 36;
	|        const int COLOR_WHITE = 37;
	|        const int COLOR_BRIGHT_BLACK = 90;
	|        const int COLOR_BRIGHT_RED = 91;
	|        const int COLOR_BRIGHT_GREEN = 92;
	|        const int COLOR_BRIGHT_YELLOW = 93;
	|        const int COLOR_BRIGHT_BLUE = 94;
	|        const int COLOR_BRIGHT_MAGENTA = 95;
	|        const int COLOR_BRIGHT_CYAN = 96;
	|        const int COLOR_BRIGHT_WHITE = 97;
	|
	|        int cols, rows, left, top;
	|
	|        public override int Cols => cols;
	|        public override int Rows => rows;
	|        public override int Left => left;
	|        public override int Top => top;
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool EnableConsoleScrolling { get; set; }
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool HeightAsBuffer { get; set; }
	|        public NetWinVTConsole NetWinConsole { get; }
	|        public bool IsWinPlatform { get; }
	|        public override IClipboard Clipboard { get; }
	|        public override int[,,] Contents => contents;
	|
	|        public NetDriver()
	|        {
	|            var p = Environment.OSVersion.Platform;
	|            if (p == PlatformID.Win32NT || p == PlatformID.Win32S || p == PlatformID.Win32Windows)
	|            {
	|                IsWinPlatform = true;
	|                NetWinConsole = new NetWinVTConsole();
	|            }
	|            if (IsWinPlatform)
	|            {
	|                Clipboard = new WindowsClipboard();
	|            }
	|            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
	|            {
	|                Clipboard = new MacOSXClipboard();
	|            }
	|            else
	|            {
	|                if (CursesDriver.Is_WSL_Platform())
	|                {
	|                    Clipboard = new WSLClipboard();
	|                }
	|                else
	|                {
	|                    Clipboard = new CursesClipboard();
	|                }
	|            }
	|        }
	|
	|        // The format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
	|        int[,,] contents;
	|        bool[] dirtyLine;
	|
	|        static bool sync = false;
	|
	|        // Current row, and current col, tracked by Move/AddCh only
	|        int ccol, crow;
	|
	|        public override void Move(int col, int row)
	|        {
	|            ccol = col;
	|            crow = row;
	|        }
	|
	|        public override void AddRune(Rune rune)
	|        {
	|            if (contents.Length != Rows * Cols * 3)
	|            {
	|                return;
	|            }
	|            rune = MakePrintable(rune);
	|            var runeWidth = Rune.ColumnWidth(rune);
	|            var validClip = IsValidContent(ccol, crow, Clip);
	|
	|            if (validClip)
	|            {
	|                if (runeWidth == 0 && ccol > 0)
	|                {
	|                    var r = contents[crow, ccol - 1, 0];
	|                    var s = new string(new char[] { (char)r, (char)rune });
	|                    string sn;
	|                    if (!s.IsNormalized())
	|                    {
	|                        sn = s.Normalize();
	|                    }
	|                    else
	|                    {
	|                        sn = s;
	|                    }
	|                    var c = sn[0];
	|                    contents[crow, ccol - 1, 0] = c;
	|                    contents[crow, ccol - 1, 1] = CurrentAttribute;
	|                    contents[crow, ccol - 1, 2] = 1;
	|
	|                }
	|                else
	|                {
	|                    if (runeWidth < 2 && ccol > 0
	|                        && Rune.ColumnWidth((char)contents[crow, ccol - 1, 0]) > 1)
	|                    {
	|
	|                        contents[crow, ccol - 1, 0] = (int)(uint)' ';
	|
	|                    }
	|                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
	|                      && Rune.ColumnWidth((char)contents[crow, ccol, 0]) > 1)
	|                    {
	|
	|                        contents[crow, ccol + 1, 0] = (int)(uint)' ';
	|                        contents[crow, ccol + 1, 2] = 1;
	|
	|                    }
	|                    if (runeWidth > 1 && ccol == Clip.Right - 1)
	|                    {
	|                        contents[crow, ccol, 0] = (int)(uint)' ';
	|                    }
	|                    else
	|                    {
	|                        contents[crow, ccol, 0] = (int)(uint)rune;
	|                    }
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 1;
	|
	|                }
	|                dirtyLine[crow] = true;
	|            }
	|
	|            if (runeWidth < 0 || runeWidth > 0)
	|            {
	|                ccol++;
	|            }
	|
	|            if (runeWidth > 1)
	|            {
	|                if (validClip && ccol < Clip.Right)
	|                {
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 0;
	|                }
	|                ccol++;
	|            }
	|
	|            if (sync)
	|            {
	|                UpdateScreen();
	|            }
	|        }
	|
	|        public override void AddStr(ustring str)
	|        {
	|            foreach (var rune in str)
	|                AddRune(rune);
	|        }
	|
	|        public override void End()
	|        {
	|            mainLoop.Dispose();
	|
	|            if (IsWinPlatform)
	|            {
	|                NetWinConsole.Cleanup();
	|            }
	|
	|            StopReportingMouseMoves();
	|            Console.ResetColor();
	|
	|            //Disable alternative screen buffer.
	|            Console.Out.Write(""\x1b[?1049l"");
	|
	|            //Set cursor key to cursor.
	|            Console.Out.Write(""\x1b[?25h"");
	|
	|            Console.Out.Close();
	|        }
	|
	|        public override Attribute MakeColor(Color foreground, Color background)
	|        {
	|            return MakeColor((ConsoleColor)foreground, (ConsoleColor)background);
	|        }
	|
	|        static Attribute MakeColor(ConsoleColor f, ConsoleColor b)
	|        {
	|            // Encode the colors into the int value.
	|            return new Attribute(
	|                value: ((((int)f) & 0xffff) << 16) | (((int)b) & 0xffff),
	|                foreground: (Color)f,
	|                background: (Color)b
	|                );
	|        }
	|
	|        public override void Init(Action terminalResized)
	|        {
	|            TerminalResized = terminalResized;
	|
	|            //Enable alternative screen buffer.
	|            Console.Out.Write(""\x1b[?1049h"");
	|
	|            //Set cursor key to application.
	|            Console.Out.Write(""\x1b[?25l"");
	|
	|            Console.TreatControlCAsInput = true;
	|
	|            cols = Console.WindowWidth;
	|            rows = Console.WindowHeight;
	|
	|            CurrentAttribute = MakeColor(Color.White, Color.Black);
	|            InitalizeColorSchemes();
	|
	|            CurrentAttribute = MakeColor(Color.White, Color.Black);
	|            InitalizeColorSchemes();
	|
	|            ResizeScreen();
	|            UpdateOffScreen();
	|
	|            StartReportingMouseMoves();
	|        }
	|
	|        public override void ResizeScreen()
	|        {
	|            if (Console.WindowHeight > 0)
	|            {
	|                // Not supported on Unix.
	|                if (IsWinPlatform)
	|                {
	|                    // Can raise an exception while is still resizing.
	|                    try
	|                    {
	|#pragma warning disable CA1416
	|                        Console.CursorTop = 0;
	|                        Console.CursorLeft = 0;
	|                        Console.WindowTop = 0;
	|                        Console.WindowLeft = 0;
	|                        if (Console.WindowHeight > Rows)
	|                        {
	|                            Console.SetWindowSize(Cols, Rows);
	|                        }
	|                        Console.SetBufferSize(Cols, Rows);
	|#pragma warning restore CA1416
	|                    }
	|                    catch (System.IO.IOException)
	|                    {
	|                        setClip();
	|                    }
	|                    catch (ArgumentOutOfRangeException)
	|                    {
	|                        setClip();
	|                    }
	|                }
	|                else
	|                {
	|                    Console.Out.Write($""\x1b[8;{Rows};{Cols}t"");
	|                }
	|            }
	|
	|            setClip();
	|
	|            void setClip()
	|            {
	|                Clip = new Rect(0, 0, Cols, Rows);
	|            }
	|        }
	|
	|        public override void UpdateOffScreen()
	|        {
	|            contents = new int[Rows, Cols, 3];
	|            dirtyLine = new bool[Rows];
	|
	|            lock (contents)
	|            {
	|                // Can raise an exception while is still resizing.
	|                try
	|                {
	|                    for (int row = 0; row < rows; row++)
	|                    {
	|                        for (int c = 0; c < cols; c++)
	|                        {
	|                            contents[row, c, 0] = ' ';
	|                            contents[row, c, 1] = (ushort)Colors.TopLevel.Normal;
	|                            contents[row, c, 2] = 0;
	|                            dirtyLine[row] = true;
	|                        }
	|                    }
	|                }
	|                catch (IndexOutOfRangeException) { }
	|            }
	|        }
	|
	|        public override Attribute MakeAttribute(Color fore, Color back)
	|        {
	|            return MakeColor((ConsoleColor)fore, (ConsoleColor)back);
	|        }
	|
	|        public override void Refresh()
	|        {
	|            UpdateScreen();
	|            UpdateCursor();
	|        }
	|
	|        public override void UpdateScreen()
	|        {
	|            if (winChanging || Console.WindowHeight < 1 || contents.Length != Rows * Cols * 3 || Rows != Console.WindowHeight)
	|            {
	|                return;
	|            }
	|
	|            int top = 0;
	|            int left = 0;
	|            int rows = Rows;
	|            int cols = Cols;
	|            System.Text.StringBuilder output = new System.Text.StringBuilder();
	|            int redrawAttr = -1;
	|            var lastCol = -1;
	|
	|            Console.CursorVisible = false;
	|
	|            for (int row = top; row < rows; row++)
	|            {
	|                if (Console.WindowHeight < 1)
	|                {
	|                    return;
	|                }
	|                if (!dirtyLine[row])
	|                {
	|                    continue;
	|                }
	|                if (!SetCursorPosition(0, row))
	|                {
	|                    return;
	|                }
	|                dirtyLine[row] = false;
	|                output.Clear();
	|                for (int col = left; col < cols; col++)
	|                {
	|                    lastCol = -1;
	|                    var outputWidth = 0;
	|                    for (; col < cols; col++)
	|                    {
	|                        if (contents[row, col, 2] == 0)
	|                        {
	|                            if (output.Length > 0)
	|                            {
	|                                SetCursorPosition(lastCol, row);
	|                                Console.Write(output);
	|                                output.Clear();
	|                                lastCol += outputWidth;
	|                                outputWidth = 0;
	|                            }
	|                            else if (lastCol == -1)
	|                            {
	|                                lastCol = col;
	|                            }
	|                            if (lastCol + 1 < cols)
	|                                lastCol++;
	|                            continue;
	|                        }
	|
	|                        if (lastCol == -1)
	|                            lastCol = col;
	|
	|                        var attr = contents[row, col, 1];
	|                        if (attr != redrawAttr)
	|                        {
	|                            redrawAttr = attr;
	|                            output.Append(WriteAttributes(attr));
	|                        }
	|                        outputWidth++;
	|                        var rune = contents[row, col, 0];
	|                        char[] spair;
	|                        if (Rune.DecodeSurrogatePair((uint)rune, out spair))
	|                        {
	|                            output.Append(spair);
	|                        }
	|                        else
	|                        {
	|                            output.Append((char)rune);
	|                        }
	|                        contents[row, col, 2] = 0;
	|                    }
	|                }
	|                if (output.Length > 0)
	|                {
	|                    SetCursorPosition(lastCol, row);
	|                    Console.Write(output);
	|                }
	|            }
	|            SetCursorPosition(0, 0);
	|        }
	|
	|        void SetVirtualCursorPosition(int col, int row)
	|        {
	|            Console.Out.Write($""\x1b[{row + 1};{col + 1}H"");
	|        }
	|
	|        System.Text.StringBuilder WriteAttributes(int attr)
	|        {
	|            const string CSI = ""\x1b["";
	|            int bg = 0;
	|            int fg = 0;
	|            System.Text.StringBuilder sb = new System.Text.StringBuilder();
	|
	|            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
	|                  .OfType<ConsoleColor>()
	|                  .Select(s => (int)s);
	|            if (values.Contains(attr & 0xffff))
	|            {
	|                bg = MapColors((ConsoleColor)(attr & 0xffff), false);
	|            }
	|            if (values.Contains((attr >> 16) & 0xffff))
	|            {
	|                fg = MapColors((ConsoleColor)((attr >> 16) & 0xffff));
	|            }
	|            sb.Append($""{CSI}{bg};{fg}m"");
	|
	|            return sb;
	|        }
	|
	|        int MapColors(ConsoleColor color, bool isForeground = true)
	|        {
	|            switch (color)
	|            {
	|                case ConsoleColor.Black:
	|                    return isForeground ? COLOR_BLACK : COLOR_BLACK + 10;
	|                case ConsoleColor.DarkBlue:
	|                    return isForeground ? COLOR_BLUE : COLOR_BLUE + 10;
	|                case ConsoleColor.DarkGreen:
	|                    return isForeground ? COLOR_GREEN : COLOR_GREEN + 10;
	|                case ConsoleColor.DarkCyan:
	|                    return isForeground ? COLOR_CYAN : COLOR_CYAN + 10;
	|                case ConsoleColor.DarkRed:
	|                    return isForeground ? COLOR_RED : COLOR_RED + 10;
	|                case ConsoleColor.DarkMagenta:
	|                    return isForeground ? COLOR_MAGENTA : COLOR_MAGENTA + 10;
	|                case ConsoleColor.DarkYellow:
	|                    return isForeground ? COLOR_YELLOW : COLOR_YELLOW + 10;
	|                case ConsoleColor.Gray:
	|                    return isForeground ? COLOR_WHITE : COLOR_WHITE + 10;
	|                case ConsoleColor.DarkGray:
	|                    return isForeground ? COLOR_BRIGHT_BLACK : COLOR_BRIGHT_BLACK + 10;
	|                case ConsoleColor.Blue:
	|                    return isForeground ? COLOR_BRIGHT_BLUE : COLOR_BRIGHT_BLUE + 10;
	|                case ConsoleColor.Green:
	|                    return isForeground ? COLOR_BRIGHT_GREEN : COLOR_BRIGHT_GREEN + 10;
	|                case ConsoleColor.Cyan:
	|                    return isForeground ? COLOR_BRIGHT_CYAN : COLOR_BRIGHT_CYAN + 10;
	|                case ConsoleColor.Red:
	|                    return isForeground ? COLOR_BRIGHT_RED : COLOR_BRIGHT_RED + 10;
	|                case ConsoleColor.Magenta:
	|                    return isForeground ? COLOR_BRIGHT_MAGENTA : COLOR_BRIGHT_MAGENTA + 10;
	|                case ConsoleColor.Yellow:
	|                    return isForeground ? COLOR_BRIGHT_YELLOW : COLOR_BRIGHT_YELLOW + 10;
	|                case ConsoleColor.White:
	|                    return isForeground ? COLOR_BRIGHT_WHITE : COLOR_BRIGHT_WHITE + 10;
	|            }
	|            return 0;
	|        }
	|
	|        bool SetCursorPosition(int col, int row)
	|        {
	|            if (IsWinPlatform)
	|            {
	|                // Could happens that the windows is still resizing and the col is bigger than Console.WindowWidth.
	|                try
	|                {
	|                    Console.SetCursorPosition(col, row);
	|                    return true;
	|                }
	|                catch (Exception)
	|                {
	|                    return false;
	|                }
	|            }
	|            else
	|            {
	|                SetVirtualCursorPosition(col, row);
	|                return true;
	|            }
	|        }
	|
	|        private void SetWindowPosition(int col, int row)
	|        {
	|            top = Console.WindowTop;
	|            left = Console.WindowLeft;
	|        }
	|
	|        private bool EnsureBufferSize()
	|        {
	|#pragma warning disable CA1416
	|            if (IsWinPlatform && Console.BufferHeight < Rows)
	|            {
	|                try
	|                {
	|                    Console.SetBufferSize(Console.WindowWidth, Rows);
	|                }
	|                catch (Exception)
	|                {
	|                    return false;
	|                }
	|            }
	|#pragma warning restore CA1416
	|            return true;
	|        }
	|
	|        private CursorVisibility? savedCursorVisibility;
	|
	|        public override void UpdateCursor()
	|        {
	|            EnsureCursorVisibility();
	|            //Debug.WriteLine ($""Before - CursorTop: {Console.CursorTop};CursorLeft: {Console.CursorLeft}"");
	|
	|            if (ccol >= 0 && ccol < Cols && crow >= 0 && crow < Rows)
	|            {
	|                SetCursorPosition(ccol, crow);
	|                SetWindowPosition(0, crow);
	|            }
	|            //Debug.WriteLine ($""WindowTop: {Console.WindowTop};WindowLeft: {Console.WindowLeft}"");
	|            //Debug.WriteLine ($""After - CursorTop: {Console.CursorTop};CursorLeft: {Console.CursorLeft}"");
	|        }
	|
	|        public override void StartReportingMouseMoves()
	|        {
	|            Console.Out.Write(EscSeqUtils.EnableMouseEvents);
	|        }
	|
	|        public override void StopReportingMouseMoves()
	|        {
	|            Console.Out.Write(EscSeqUtils.DisableMouseEvents);
	|        }
	|
	|        public override void Suspend()
	|        {
	|            if (Environment.OSVersion.Platform != PlatformID.Unix)
	|            {
	|                return;
	|            }
	|
	|            StopReportingMouseMoves();
	|            Console.ResetColor();
	|            Console.Clear();
	|
	|            //Disable alternative screen buffer.
	|            Console.Out.Write(""\x1b[?1049l"");
	|
	|            //Set cursor key to cursor.
	|            Console.Out.Write(""\x1b[?25h"");
	|
	|            Platform.Suspend();
	|
	|            //Enable alternative screen buffer.
	|            Console.Out.Write(""\x1b[?1049h"");
	|
	|            Application.Refresh();
	|            StartReportingMouseMoves();
	|        }
	|
	|        public override void SetAttribute(Attribute c)
	|        {
	|            base.SetAttribute(c);
	|        }
	|
	|        public ConsoleKeyInfo FromVKPacketToKConsoleKeyInfo(ConsoleKeyInfo consoleKeyInfo)
	|        {
	|            if (consoleKeyInfo.Key != ConsoleKey.Packet)
	|            {
	|                return consoleKeyInfo;
	|            }
	|
	|            var mod = consoleKeyInfo.Modifiers;
	|            var shift = (mod & ConsoleModifiers.Shift) != 0;
	|            var alt = (mod & ConsoleModifiers.Alt) != 0;
	|            var control = (mod & ConsoleModifiers.Control) != 0;
	|
	|            var keyChar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(consoleKeyInfo.KeyChar, consoleKeyInfo.Modifiers, out uint virtualKey, out _);
	|
	|            return new ConsoleKeyInfo((char)keyChar, (ConsoleKey)virtualKey, shift, alt, control);
	|        }
	|
	|        Key MapKey(ConsoleKeyInfo keyInfo)
	|        {
	|            MapKeyModifiers(keyInfo, (Key)keyInfo.Key);
	|            switch (keyInfo.Key)
	|            {
	|                case ConsoleKey.Escape:
	|                    return MapKeyModifiers(keyInfo, Key.Esc);
	|                case ConsoleKey.Tab:
	|                    return keyInfo.Modifiers == ConsoleModifiers.Shift ? Key.BackTab : Key.Tab;
	|                case ConsoleKey.Home:
	|                    return MapKeyModifiers(keyInfo, Key.Home);
	|                case ConsoleKey.End:
	|                    return MapKeyModifiers(keyInfo, Key.End);
	|                case ConsoleKey.LeftArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorLeft);
	|                case ConsoleKey.RightArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorRight);
	|                case ConsoleKey.UpArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorUp);
	|                case ConsoleKey.DownArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorDown);
	|                case ConsoleKey.PageUp:
	|                    return MapKeyModifiers(keyInfo, Key.PageUp);
	|                case ConsoleKey.PageDown:
	|                    return MapKeyModifiers(keyInfo, Key.PageDown);
	|                case ConsoleKey.Enter:
	|                    return MapKeyModifiers(keyInfo, Key.Enter);
	|                case ConsoleKey.Spacebar:
	|                    return MapKeyModifiers(keyInfo, keyInfo.KeyChar == 0 ? Key.Space : (Key)keyInfo.KeyChar);
	|                case ConsoleKey.Backspace:
	|                    return MapKeyModifiers(keyInfo, Key.Backspace);
	|                case ConsoleKey.Delete:
	|                    return MapKeyModifiers(keyInfo, Key.DeleteChar);
	|                case ConsoleKey.Insert:
	|                    return MapKeyModifiers(keyInfo, Key.InsertChar);
	|
	|
	|                case ConsoleKey.Oem1:
	|                case ConsoleKey.Oem2:
	|                case ConsoleKey.Oem3:
	|                case ConsoleKey.Oem4:
	|                case ConsoleKey.Oem5:
	|                case ConsoleKey.Oem6:
	|                case ConsoleKey.Oem7:
	|                case ConsoleKey.Oem8:
	|                case ConsoleKey.Oem102:
	|                case ConsoleKey.OemPeriod:
	|                case ConsoleKey.OemComma:
	|                case ConsoleKey.OemPlus:
	|                case ConsoleKey.OemMinus:
	|                    return (Key)((uint)keyInfo.KeyChar);
	|            }
	|
	|            var key = keyInfo.Key;
	|            if (key >= ConsoleKey.A && key <= ConsoleKey.Z)
	|            {
	|                var delta = key - ConsoleKey.A;
	|                if (keyInfo.Modifiers == ConsoleModifiers.Control)
	|                {
	|                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.A + delta));
	|                }
	|                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
	|                {
	|                    return (Key)(((uint)Key.AltMask) | ((uint)Key.A + delta));
	|                }
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    if (keyInfo.KeyChar == 0 || (keyInfo.KeyChar != 0 && keyInfo.KeyChar >= 1 && keyInfo.KeyChar <= 26))
	|                    {
	|                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
	|                    }
	|                }
	|                return (Key)((uint)keyInfo.KeyChar);
	|            }
	|            if (key >= ConsoleKey.D0 && key <= ConsoleKey.D9)
	|            {
	|                var delta = key - ConsoleKey.D0;
	|                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
	|                {
	|                    return (Key)(((uint)Key.AltMask) | ((uint)Key.D0 + delta));
	|                }
	|                if (keyInfo.Modifiers == ConsoleModifiers.Control)
	|                {
	|                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.D0 + delta));
	|                }
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    if (keyInfo.KeyChar == 0 || keyInfo.KeyChar == 30 || keyInfo.KeyChar == ((uint)Key.D0 + delta))
	|                    {
	|                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
	|                    }
	|                }
	|                return (Key)((uint)keyInfo.KeyChar);
	|            }
	|            if (key >= ConsoleKey.F1 && key <= ConsoleKey.F12)
	|            {
	|                var delta = key - ConsoleKey.F1;
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.F1 + delta));
	|                }
	|
	|                return (Key)((uint)Key.F1 + delta);
	|            }
	|            if (keyInfo.KeyChar != 0)
	|            {
	|                return MapKeyModifiers(keyInfo, (Key)((uint)keyInfo.KeyChar));
	|            }
	|
	|            return (Key)(0xffffffff);
	|        }
	|
	|        KeyModifiers keyModifiers;
	|
	|        Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
	|        {
	|            if (keyModifiers == null)
	|            {
	|                keyModifiers = new KeyModifiers();
	|            }
	|            Key keyMod = new Key();
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
	|            {
	|                keyMod = Key.ShiftMask;
	|                keyModifiers.Shift = true;
	|            }
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
	|            {
	|                keyMod |= Key.CtrlMask;
	|                keyModifiers.Ctrl = true;
	|            }
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
	|            {
	|                keyMod |= Key.AltMask;
	|                keyModifiers.Alt = true;
	|            }
	|
	|            return keyMod != Key.Null ? keyMod | key : key;
	|        }
	|
	|        Action<KeyEvent> keyHandler;
	|        Action<KeyEvent> keyDownHandler;
	|        Action<KeyEvent> keyUpHandler;
	|        Action<MouseEvent> mouseHandler;
	|        NetMainLoop mainLoop;
	|
	|        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
	|        {
	|            this.keyHandler = keyHandler;
	|            this.keyDownHandler = keyDownHandler;
	|            this.keyUpHandler = keyUpHandler;
	|            this.mouseHandler = mouseHandler;
	|
	|            var mLoop = this.mainLoop = mainLoop.Driver as NetMainLoop;
	|
	|            // Note: Net doesn't support keydown/up events and thus any passed keyDown/UpHandlers will be simulated to be called.
	|            mLoop.ProcessInput = (e) => ProcessInput(e);
	|        }
	|
	|        void ProcessInput(NetEvents.InputResult inputEvent)
	|        {
	|            switch (inputEvent.EventType)
	|            {
	|                case NetEvents.EventType.Key:
	|                    ConsoleKeyInfo consoleKeyInfo = inputEvent.ConsoleKeyInfo;
	|                    if (consoleKeyInfo.Key == ConsoleKey.Packet)
	|                    {
	|                        consoleKeyInfo = FromVKPacketToKConsoleKeyInfo(consoleKeyInfo);
	|                    }
	|                    keyModifiers = new KeyModifiers();
	|                    var map = MapKey(consoleKeyInfo);
	|                    if (map == (Key)0xffffffff)
	|                    {
	|                        return;
	|                    }
	|                    if (map == Key.Null)
	|                    {
	|                        keyDownHandler(new KeyEvent(map, keyModifiers));
	|                        keyUpHandler(new KeyEvent(map, keyModifiers));
	|                    }
	|                    else
	|                    {
	|                        keyDownHandler(new KeyEvent(map, keyModifiers));
	|                        keyHandler(new KeyEvent(map, keyModifiers));
	|                        keyUpHandler(new KeyEvent(map, keyModifiers));
	|                    }
	|                    break;
	|                case NetEvents.EventType.Mouse:
	|                    mouseHandler(ToDriverMouse(inputEvent.MouseEvent));
	|                    break;
	|                case NetEvents.EventType.WindowSize:
	|                    ChangeWin(inputEvent.WindowSizeEvent.Size);
	|                    break;
	|                case NetEvents.EventType.RequestResponse:
	|                    Application.Top.Data = inputEvent.RequestResponseEvent.ResultTuple;
	|                    break;
	|            }
	|        }
	|
	|        volatile bool winChanging;
	|
	|        void ChangeWin(Size size)
	|        {
	|            winChanging = true;
	|            top = 0;
	|            left = 0;
	|            cols = size.Width;
	|            rows = Math.Max(size.Height, 0);
	|            ResizeScreen();
	|            UpdateOffScreen();
	|            winChanging = false;
	|            TerminalResized?.Invoke();
	|        }
	|
	|        MouseEvent ToDriverMouse(NetEvents.MouseEvent me)
	|        {
	|            //System.Diagnostics.Debug.WriteLine ($""X: {me.Position.X}; Y: {me.Position.Y}; ButtonState: {me.ButtonState}"");
	|
	|            MouseFlags mouseFlag = 0;
	|
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button1Pressed) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button1Pressed;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button1Released) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button1Released;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button1Clicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button1Clicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button1DoubleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button1DoubleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button1TripleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button1TripleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button2Pressed) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button2Pressed;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button2Released) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button2Released;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button2Clicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button2Clicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button2DoubleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button2DoubleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button2TripleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button2TripleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button3Pressed) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button3Pressed;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button3Released) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button3Released;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button3Clicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button3Clicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button3DoubleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button3DoubleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button3TripleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button3TripleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledUp) != 0)
	|            {
	|                mouseFlag |= MouseFlags.WheeledUp;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledDown) != 0)
	|            {
	|                mouseFlag |= MouseFlags.WheeledDown;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledLeft) != 0)
	|            {
	|                mouseFlag |= MouseFlags.WheeledLeft;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledRight) != 0)
	|            {
	|                mouseFlag |= MouseFlags.WheeledRight;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button4Pressed) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button4Pressed;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button4Released) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button4Released;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button4Clicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button4Clicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button4DoubleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button4DoubleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.Button4TripleClicked) != 0)
	|            {
	|                mouseFlag |= MouseFlags.Button4TripleClicked;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ReportMousePosition) != 0)
	|            {
	|                mouseFlag |= MouseFlags.ReportMousePosition;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonShift) != 0)
	|            {
	|                mouseFlag |= MouseFlags.ButtonShift;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonCtrl) != 0)
	|            {
	|                mouseFlag |= MouseFlags.ButtonCtrl;
	|            }
	|            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonAlt) != 0)
	|            {
	|                mouseFlag |= MouseFlags.ButtonAlt;
	|            }
	|
	|            return new MouseEvent()
	|            {
	|                X = me.Position.X,
	|                Y = me.Position.Y,
	|                Flags = mouseFlag
	|            };
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool GetCursorVisibility(out CursorVisibility visibility)
	|        {
	|            visibility = savedCursorVisibility ?? CursorVisibility.Default;
	|            return visibility == CursorVisibility.Default;
	|        }
	|
	|
	|        /// <inheritdoc/>
	|        public override bool SetCursorVisibility(CursorVisibility visibility)
	|        {
	|            savedCursorVisibility = visibility;
	|            Console.Out.Write(visibility == CursorVisibility.Default
	|                ? ""\x1b[?25h""
	|                : ""\x1b[?25l"");
	|
	|            return visibility == CursorVisibility.Default;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool EnsureCursorVisibility()
	|        {
	|            if (!(ccol >= 0 && crow >= 0 && ccol < Cols && crow < Rows))
	|            {
	|                GetCursorVisibility(out CursorVisibility cursorVisibility);
	|                savedCursorVisibility = cursorVisibility;
	|                SetCursorVisibility(CursorVisibility.Invisible);
	|                return false;
	|            }
	|
	|            SetCursorVisibility(savedCursorVisibility ?? CursorVisibility.Default);
	|            return savedCursorVisibility == CursorVisibility.Default;
	|        }
	|
	|        public override void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
	|        {
	|            NetEvents.InputResult input = new NetEvents.InputResult();
	|            input.EventType = NetEvents.EventType.Key;
	|            input.ConsoleKeyInfo = new ConsoleKeyInfo(keyChar, key, shift, alt, control);
	|
	|            try
	|            {
	|                ProcessInput(input);
	|            }
	|            catch (OverflowException) { }
	|        }
	|
	|        public override bool GetColors(int value, out Color foreground, out Color background)
	|        {
	|            bool hasColor = false;
	|            foreground = default;
	|            background = default;
	|            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
	|                  .OfType<ConsoleColor>()
	|                  .Select(s => (int)s);
	|            if (values.Contains(value & 0xffff))
	|            {
	|                hasColor = true;
	|                background = (Color)(ConsoleColor)(value & 0xffff);
	|            }
	|            if (values.Contains((value >> 16) & 0xffff))
	|            {
	|                hasColor = true;
	|                foreground = (Color)(ConsoleColor)((value >> 16) & 0xffff);
	|            }
	|            return hasColor;
	|        }
	|
	|        #region Unused
	|        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
	|        {
	|        }
	|
	|        public override void SetColors(short foregroundColorId, short backgroundColorId)
	|        {
	|        }
	|
	|        public override void CookMouse()
	|        {
	|        }
	|
	|        public override void UncookMouse()
	|        {
	|        }
	|        #endregion
	|
	|        //
	|        // These are for the .NET driver, but running natively on Windows, wont run
	|        // on the Mono emulation
	|        //
	|
	|    }
	|
	|    /// <summary>
	|    /// Mainloop intended to be used with the .NET System.Console API, and can
	|    /// be used on Windows and Unix, it is cross platform but lacks things like
	|    /// file descriptor monitoring.
	|    /// </summary>
	|    /// <remarks>
	|    /// This implementation is used for NetDriver.
	|    /// </remarks>
	|    internal class NetMainLoop : IMainLoopDriver, IDisposable
	|    {
	|        ManualResetEventSlim keyReady = new ManualResetEventSlim(false);
	|        ManualResetEventSlim waitForProbe = new ManualResetEventSlim(false);
	|        Queue<NetEvents.InputResult?> inputResult = new Queue<NetEvents.InputResult?>();
	|        MainLoop mainLoop;
	|        CancellationTokenSource tokenSource = new CancellationTokenSource();
	|        internal NetEvents netEvents;
	|
	|        /// <summary>
	|        /// Invoked when a Key is pressed.
	|        /// </summary>
	|        public Action<NetEvents.InputResult> ProcessInput;
	|
	|        /// <summary>
	|        /// Initializes the class with the console driver.
	|        /// </summary>
	|        /// <remarks>
	|        ///   Passing a consoleDriver is provided to capture windows resizing.
	|        /// </remarks>
	|        /// <param name=""consoleDriver"">The console driver used by this Net main loop.</param>
	|        public NetMainLoop(ConsoleDriver consoleDriver = null)
	|        {
	|            if (consoleDriver == null)
	|            {
	|                throw new ArgumentNullException(""Console driver instance must be provided."");
	|            }
	|            netEvents = new NetEvents(consoleDriver);
	|        }
	|
	|        void NetInputHandler()
	|        {
	|            while (!tokenSource.IsCancellationRequested)
	|            {
	|                waitForProbe.Wait();
	|                waitForProbe.Reset();
	|                if (inputResult.Count == 0)
	|                {
	|                    inputResult.Enqueue(netEvents.ReadConsoleInput());
	|                }
	|                while (inputResult.Count > 0 && inputResult.Peek() == null)
	|                {
	|                    inputResult.Dequeue();
	|                }
	|                if (inputResult.Count > 0)
	|                {
	|                    keyReady.Set();
	|                }
	|            }
	|        }
	|
	|        void IMainLoopDriver.Setup(MainLoop mainLoop)
	|        {
	|            this.mainLoop = mainLoop;
	|            Task.Run(NetInputHandler, tokenSource.Token);
	|        }
	|
	|        void IMainLoopDriver.Wakeup()
	|        {
	|            keyReady.Set();
	|        }
	|
	|        bool IMainLoopDriver.EventsPending(bool wait)
	|        {
	|            waitForProbe.Set();
	|
	|            if (CheckTimers(wait, out var waitTimeout))
	|            {
	|                return true;
	|            }
	|
	|            try
	|            {
	|                if (!tokenSource.IsCancellationRequested)
	|                {
	|                    keyReady.Wait(waitTimeout, tokenSource.Token);
	|                }
	|            }
	|            catch (OperationCanceledException)
	|            {
	|                return true;
	|            }
	|            finally
	|            {
	|                keyReady.Reset();
	|            }
	|
	|            if (!tokenSource.IsCancellationRequested)
	|            {
	|                return inputResult.Count > 0 || CheckTimers(wait, out _);
	|            }
	|
	|            tokenSource.Token.ThrowIfCancellationRequested();
	|            return true;
	|        }
	|
	|        bool CheckTimers(bool wait, out int waitTimeout)
	|        {
	|            long now = DateTime.UtcNow.Ticks;
	|
	|            if (mainLoop.timeouts.Count > 0)
	|            {
	|                waitTimeout = (int)((mainLoop.timeouts.Keys[0] - now) / TimeSpan.TicksPerMillisecond);
	|                if (waitTimeout < 0)
	|                    return true;
	|            }
	|            else
	|            {
	|                waitTimeout = -1;
	|            }
	|
	|            if (!wait)
	|                waitTimeout = 0;
	|
	|            int ic;
	|            lock (mainLoop.idleHandlers)
	|            {
	|                ic = mainLoop.idleHandlers.Count;
	|            }
	|
	|            return ic > 0;
	|        }
	|
	|        void IMainLoopDriver.MainIteration()
	|        {
	|            while (inputResult.Count > 0)
	|            {
	|                ProcessInput?.Invoke(inputResult.Dequeue().Value);
	|            }
	|        }
	|
	|        public void Dispose()
	|        {
	|            tokenSource.Cancel();
	|            netEvents.TokenSource.Cancel();
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// A container for single <see cref=""Child""/> that will allow to drawn <see cref=""Border""/> in
	|    ///  two ways. If <see cref=""UsePanelFrame""/> the borders and the child will be accommodated in the available
	|    ///  panel size, otherwise the panel will be resized based on the child and borders thickness sizes.
	|    /// </summary>
	|    public class PanelView : View
	|    {
	|        ChildContentView childContentView;
	|
	|        private class ChildContentView : View { }
	|
	|        private class SavedPosDim
	|        {
	|            public Pos X;
	|            public Pos Y;
	|            public Dim Width;
	|            public Dim Height;
	|        }
	|
	|        private SavedPosDim savedPanel;
	|        private SavedPosDim savedChild;
	|
	|        private View child;
	|        private bool usePanelFrame;
	|
	|        /// <summary>
	|        /// Initializes a panel with a null child.
	|        /// </summary>
	|        public PanelView() : this(null) { }
	|
	|        /// <summary>
	|        /// Initializes a panel with a valid child.
	|        /// </summary>
	|        /// <param name=""child""></param>
	|        public PanelView(View child)
	|        {
	|            childContentView = new ChildContentView();
	|            base.Add(childContentView);
	|            CanFocus = false;
	|            Child = child;
	|            if (child != null)
	|            {
	|                Visible = child.Visible;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets if the panel size will used, otherwise the child size.
	|        /// </summary>
	|        public bool UsePanelFrame
	|        {
	|            get => usePanelFrame;
	|            set
	|            {
	|                usePanelFrame = value;
	|                AdjustContainer();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The child that will use this panel.
	|        /// </summary>
	|        public View Child
	|        {
	|            get => child;
	|            set
	|            {
	|                if (child != null && value == null)
	|                {
	|                    childContentView.Remove(child);
	|                    child = value;
	|                    return;
	|                }
	|                child = value;
	|                savedChild = new SavedPosDim()
	|                {
	|                    X = child?.X ?? child?.Frame.X,
	|                    Y = child?.Y ?? child?.Frame.Y,
	|                    Width = child?.Width ?? child?.Frame.Width,
	|                    Height = child?.Height ?? child?.Frame.Height
	|                };
	|                if (child == null)
	|                {
	|                    Visible = false;
	|                    return;
	|                }
	|                if (child?.Border != null)
	|                {
	|                    Border = child.Border;
	|                }
	|                else
	|                {
	|                    if (Border == null)
	|                    {
	|                        Border = new Border();
	|                    }
	|                    Child.Border = Border;
	|                }
	|                Border.Child = childContentView;
	|                if (!child.IsInitialized)
	|                {
	|                    child.Initialized += Child_Initialized;
	|                }
	|                childContentView.Add(Child);
	|            }
	|        }
	|
	|        /// <inheritdoc />
	|        public override Border Border
	|        {
	|            get => base.Border;
	|            set
	|            {
	|                if (base.Border?.Child != null && value.Child == null)
	|                {
	|                    value.Child = base.Border.Child;
	|                }
	|                base.Border = value;
	|                if (value == null)
	|                {
	|                    return;
	|                }
	|                Border.BorderChanged += Border_BorderChanged;
	|                if (Child != null && (Child?.Border == null || Child?.Border != value))
	|                {
	|                    if (Child?.Border == null)
	|                    {
	|                        Child.Border = new Border();
	|                    }
	|                    Child.Border = Border;
	|                    Child.Border.BorderChanged += Border_BorderChanged;
	|                }
	|                AdjustContainer();
	|            }
	|        }
	|
	|        private void Child_Initialized(object sender, EventArgs e)
	|        {
	|            savedPanel = new SavedPosDim()
	|            {
	|                X = X,
	|                Y = Y,
	|                Width = Width,
	|                Height = Height
	|            };
	|            AdjustContainer();
	|            Child.Initialized -= Child_Initialized;
	|        }
	|
	|        private void Border_BorderChanged(Border obj)
	|        {
	|            AdjustContainer();
	|        }
	|
	|        private void AdjustContainer()
	|        {
	|            if (Child?.IsInitialized == true)
	|            {
	|                if (Child?.Border != null && Child.Border != Border)
	|                {
	|                    Border = Child.Border;
	|                }
	|                var borderLength = Child.Border.DrawMarginFrame ? 1 : 0;
	|                var sumPadding = Child.Border.GetSumThickness();
	|                var effect3DOffset = Child.Border.Effect3D ? Child.Border.Effect3DOffset : new Point();
	|                if (!UsePanelFrame)
	|                {
	|                    X = savedPanel.X;
	|                    childContentView.X = borderLength + sumPadding.Left;
	|                    Y = savedPanel.Y;
	|                    childContentView.Y = borderLength + sumPadding.Top;
	|                    if (savedChild.Width is Dim.DimFill)
	|                    {
	|                        var margin = -savedChild.Width.Anchor(0);
	|                        Width = Dim.Fill(margin);
	|                        childContentView.Width = Dim.Fill(margin + borderLength + sumPadding.Right);
	|                    }
	|                    else
	|                    {
	|                        var savedLayout = LayoutStyle;
	|                        LayoutStyle = LayoutStyle.Absolute;
	|                        Width = savedChild.X.Anchor(0) + savedChild.Width + (2 * borderLength) + sumPadding.Right + sumPadding.Left;
	|                        LayoutStyle = savedLayout;
	|                        childContentView.Width = Dim.Fill(borderLength + sumPadding.Right);
	|                    }
	|                    if (savedChild.Height is Dim.DimFill)
	|                    {
	|                        var margin = -savedChild.Height.Anchor(0);
	|                        Height = Dim.Fill(margin);
	|                        childContentView.Height = Dim.Fill(margin + borderLength + sumPadding.Bottom);
	|                    }
	|                    else
	|                    {
	|                        var savedLayout = LayoutStyle;
	|                        LayoutStyle = LayoutStyle.Absolute;
	|                        Height = savedChild.Y.Anchor(0) + savedChild.Height + (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
	|                        LayoutStyle = savedLayout;
	|                        childContentView.Height = Dim.Fill(borderLength + sumPadding.Bottom);
	|                    }
	|                }
	|                else
	|                {
	|                    X = savedPanel.X - (effect3DOffset.X < 0 ? effect3DOffset.X : 0);
	|                    childContentView.X = borderLength + sumPadding.Left;
	|                    Y = savedPanel.Y - (effect3DOffset.Y < 0 ? effect3DOffset.Y : 0);
	|                    childContentView.Y = borderLength + sumPadding.Top;
	|                    Width = savedPanel.Width;
	|                    Height = savedPanel.Height;
	|                    if (Width is Dim.DimFill)
	|                    {
	|                        var margin = -savedPanel.Width.Anchor(0) +
	|                            (effect3DOffset.X > 0 ? effect3DOffset.X : 0);
	|                        Width = Dim.Fill(margin);
	|                        childContentView.Width = Dim.Fill(margin + borderLength + sumPadding.Right +
	|                            (effect3DOffset.X > 0 ? effect3DOffset.X : 0));
	|                    }
	|                    else
	|                    {
	|                        childContentView.Width = Dim.Fill(borderLength + sumPadding.Right);
	|                    }
	|                    if (Height is Dim.DimFill)
	|                    {
	|                        var margin = -savedPanel.Height.Anchor(0) +
	|                            (effect3DOffset.Y > 0 ? effect3DOffset.Y : 0);
	|                        Height = Dim.Fill(margin);
	|                        childContentView.Height = Dim.Fill(margin + borderLength + sumPadding.Bottom +
	|                            (effect3DOffset.Y > 0 ? effect3DOffset.Y : 0));
	|                    }
	|                    else
	|                    {
	|                        childContentView.Height = Dim.Fill(borderLength + sumPadding.Bottom);
	|                    }
	|                }
	|                Visible = Child.Visible;
	|            }
	|            else
	|            {
	|                Visible = false;
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void Add(View view)
	|        {
	|            if (Child != null)
	|            {
	|                Child = null;
	|            }
	|            Child = view;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void Remove(View view)
	|        {
	|            if (view == childContentView)
	|            {
	|                base.Remove(view);
	|                return;
	|            }
	|            childContentView.Remove(view);
	|            if (Child != null)
	|            {
	|                Child = null;
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void RemoveAll()
	|        {
	|            if (Child != null)
	|            {
	|                Child = null;
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            if (!NeedDisplay.IsEmpty)
	|            {
	|                Driver.SetAttribute(Child.GetNormalColor());
	|                Clear();
	|                Child.Border.DrawContent(Border.Child);
	|            }
	|            var savedClip = childContentView.ClipToBounds();
	|            childContentView.Redraw(childContentView.Bounds);
	|            Driver.Clip = savedClip;
	|
	|            ClearLayoutNeeded();
	|            ClearNeedsDisplay();
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // System.Drawing.Point.cs
	|    //
	|    // Author:
	|    //   Mike Kestner (mkestner@speakeasy.net)
	|    //
	|    // Copyright (C) 2001 Mike Kestner
	|    // Copyright (C) 2004 Novell, Inc.  http://www.novell.com 
	|    //
	|
	|    /// <summary>
	|    /// Represents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane.
	|    /// </summary>
	|    public struct Point
	|    {
	|        /// <summary>
	|        /// Gets or sets the x-coordinate of this Point.
	|        /// </summary>
	|        public int X;
	|
	|        /// <summary>
	|        /// Gets or sets the y-coordinate of this Point.
	|        /// </summary>
	|        public int Y;
	|
	|        // -----------------------
	|        // Public Shared Members
	|        // -----------------------
	|
	|        /// <summary>
	|        ///	Empty Shared Field
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	An uninitialized Point Structure.
	|        /// </remarks>
	|
	|        public static readonly Point Empty;
	|
	|        /// <summary>
	|        ///	Addition Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Translates a Point using the Width and Height
	|        ///	properties of the given <typeref>Size</typeref>.
	|        /// </remarks>
	|
	|        public static Point operator +(Point pt, Size sz)
	|        {
	|            return new Point(pt.X + sz.Width, pt.Y + sz.Height);
	|        }
	|
	|        /// <summary>
	|        ///	Equality Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Compares two Point objects. The return value is
	|        ///	based on the equivalence of the X and Y properties 
	|        ///	of the two points.
	|        /// </remarks>
	|
	|        public static bool operator ==(Point left, Point right)
	|        {
	|            return ((left.X == right.X) && (left.Y == right.Y));
	|        }
	|
	|        /// <summary>
	|        ///	Inequality Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Compares two Point objects. The return value is
	|        ///	based on the equivalence of the X and Y properties 
	|        ///	of the two points.
	|        /// </remarks>
	|
	|        public static bool operator !=(Point left, Point right)
	|        {
	|            return ((left.X != right.X) || (left.Y != right.Y));
	|        }
	|
	|        /// <summary>
	|        ///	Subtraction Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Translates a Point using the negation of the Width 
	|        ///	and Height properties of the given Size.
	|        /// </remarks>
	|
	|        public static Point operator -(Point pt, Size sz)
	|        {
	|            return new Point(pt.X - sz.Width, pt.Y - sz.Height);
	|        }
	|
	|        /// <summary>
	|        ///	Point to Size Conversion
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Returns a Size based on the Coordinates of a given 
	|        ///	Point. Requires explicit cast.
	|        /// </remarks>
	|
	|        public static explicit operator Size(Point p)
	|        {
	|            if (p.X < 0 || p.Y < 0)
	|                throw new ArgumentException(""Either Width and Height must be greater or equal to 0."");
	|
	|            return new Size(p.X, p.Y);
	|        }
	|
	|        // -----------------------
	|        // Public Constructors
	|        // -----------------------
	|        /// <summary>
	|        ///	Point Constructor
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Creates a Point from a Size value.
	|        /// </remarks>
	|
	|        public Point(Size sz)
	|        {
	|            X = sz.Width;
	|            Y = sz.Height;
	|        }
	|
	|        /// <summary>
	|        ///	Point Constructor
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Creates a Point from a specified x,y coordinate pair.
	|        /// </remarks>
	|
	|        public Point(int x, int y)
	|        {
	|            this.X = x;
	|            this.Y = y;
	|        }
	|
	|        // -----------------------
	|        // Public Instance Members
	|        // -----------------------
	|
	|        /// <summary>
	|        ///	IsEmpty Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Indicates if both X and Y are zero.
	|        /// </remarks>		
	|        public bool IsEmpty
	|        {
	|            get
	|            {
	|                return ((X == 0) && (Y == 0));
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Equals Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Checks equivalence of this Point and another object.
	|        /// </remarks>
	|
	|        public override bool Equals(object obj)
	|        {
	|            if (!(obj is Point))
	|                return false;
	|
	|            return (this == (Point)obj);
	|        }
	|
	|        /// <summary>
	|        ///	GetHashCode Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Calculates a hashing value.
	|        /// </remarks>
	|
	|        public override int GetHashCode()
	|        {
	|            return X ^ Y;
	|        }
	|
	|        /// <summary>
	|        ///	Offset Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Moves the Point a specified distance.
	|        /// </remarks>
	|
	|        public void Offset(int dx, int dy)
	|        {
	|            X += dx;
	|            Y += dy;
	|        }
	|
	|        /// <summary>
	|        ///	ToString Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Formats the Point as a string in coordinate notation.
	|        /// </remarks>
	|
	|        public override string ToString()
	|        {
	|            return string.Format(""{{X={0},Y={1}}}"", X.ToString(CultureInfo.InvariantCulture),
	|                Y.ToString(CultureInfo.InvariantCulture));
	|        }
	|
	|        /// <summary>
	|        /// Adds the specified Size to the specified Point.
	|        /// </summary>
	|        /// <returns>The Point that is the result of the addition operation.</returns>
	|        /// <param name=""pt"">The Point to add.</param>
	|        /// <param name=""sz"">The Size to add.</param>
	|        public static Point Add(Point pt, Size sz)
	|        {
	|            return new Point(pt.X + sz.Width, pt.Y + sz.Height);
	|        }
	|
	|        /// <summary>
	|        /// Translates this Point by the specified Point.
	|        /// </summary>
	|        /// <returns>The offset.</returns>
	|        /// <param name=""p"">The Point used offset this Point.</param>
	|        public void Offset(Point p)
	|        {
	|            Offset(p.X, p.Y);
	|        }
	|
	|        /// <summary>
	|        /// Returns the result of subtracting specified Size from the specified Point.
	|        /// </summary>
	|        /// <returns>The Point that is the result of the subtraction operation.</returns>
	|        /// <param name=""pt"">The Point to be subtracted from.</param>
	|        /// <param name=""sz"">The Size to subtract from the Point.</param>
	|        public static Point Subtract(Point pt, Size sz)
	|        {
	|            return new Point(pt.X - sz.Width, pt.Y - sz.Height);
	|        }
	|
	|    }
	|    //=======================================================================
	|    // Licensed to the .NET Foundation under one or more agreements.
	|    // The .NET Foundation licenses this file to you under the MIT license.
	|    // See the LICENSE file in the project root for more information.
	|
	|    // Copied from: https://github.com/dotnet/corefx/tree/master/src/System.Drawing.Primitives/src/System/Drawing
	|
	|    /// <summary>
	|    /// Represents an ordered pair of x and y coordinates that define a point in a two-dimensional plane.
	|    /// </summary>
	|    public struct PointF : IEquatable<PointF>
	|    {
	|        /// <summary>
	|        /// Creates a new instance of the <see cref='Terminal.Gui.PointF'/> class with member data left uninitialized.
	|        /// </summary>
	|        public static readonly PointF Empty;
	|        private float x; // Do not rename (binary serialization)
	|        private float y; // Do not rename (binary serialization)
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.PointF'/> class with the specified coordinates.
	|        /// </summary>
	|        public PointF(float x, float y)
	|        {
	|            this.x = x;
	|            this.y = y;
	|        }
	|
	|        /// <summary>
	|        /// Gets a value indicating whether this <see cref='Terminal.Gui.PointF'/> is empty.
	|        /// </summary>
	|        [Browsable(false)]
	|        public bool IsEmpty => x == 0f && y == 0f;
	|
	|        /// <summary>
	|        /// Gets the x-coordinate of this <see cref='Terminal.Gui.PointF'/>.
	|        /// </summary>
	|        public float X
	|        {
	|            get => x;
	|            set => x = value;
	|        }
	|
	|        /// <summary>
	|        /// Gets the y-coordinate of this <see cref='Terminal.Gui.PointF'/>.
	|        /// </summary>
	|        public float Y
	|        {
	|            get => y;
	|            set => y = value;
	|        }
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.Size'/> .
	|        /// </summary>
	|        public static PointF operator +(PointF pt, Size sz) => Add(pt, sz);
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.Size'/> .
	|        /// </summary>
	|        public static PointF operator -(PointF pt, Size sz) => Subtract(pt, sz);
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.SizeF'/> .
	|        /// </summary>
	|        public static PointF operator +(PointF pt, SizeF sz) => Add(pt, sz);
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.SizeF'/> .
	|        /// </summary>
	|        public static PointF operator -(PointF pt, SizeF sz) => Subtract(pt, sz);
	|
	|        /// <summary>
	|        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
	|        /// <see cref='Terminal.Gui.PointF.X'/> and <see cref='Terminal.Gui.PointF.Y'/> properties of the two
	|        /// <see cref='Terminal.Gui.PointF'/> objects are equal.
	|        /// </summary>
	|        public static bool operator ==(PointF left, PointF right) => left.X == right.X && left.Y == right.Y;
	|
	|        /// <summary>
	|        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
	|        /// <see cref='Terminal.Gui.PointF.X'/> or <see cref='Terminal.Gui.PointF.Y'/> properties of the two
	|        /// <see cref='Terminal.Gui.PointF'/> objects are unequal.
	|        /// </summary>
	|        public static bool operator !=(PointF left, PointF right) => !(left == right);
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.Size'/> .
	|        /// </summary>
	|        public static PointF Add(PointF pt, Size sz) => new PointF(pt.X + sz.Width, pt.Y + sz.Height);
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.Size'/> .
	|        /// </summary>
	|        public static PointF Subtract(PointF pt, Size sz) => new PointF(pt.X - sz.Width, pt.Y - sz.Height);
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.SizeF'/> .
	|        /// </summary>
	|        public static PointF Add(PointF pt, SizeF sz) => new PointF(pt.X + sz.Width, pt.Y + sz.Height);
	|
	|        /// <summary>
	|        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.SizeF'/> .
	|        /// </summary>
	|        public static PointF Subtract(PointF pt, SizeF sz) => new PointF(pt.X - sz.Width, pt.Y - sz.Height);
	|
	|
	|        /// <summary>
	|        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
	|        /// <see cref='Terminal.Gui.PointF.X'/> and <see cref='Terminal.Gui.PointF.Y'/> properties of the two
	|        /// <see cref='Terminal.Gui.PointF'/> objects are equal.
	|        /// </summary>
	|        public override bool Equals(object obj) => obj is PointF && Equals((PointF)obj);
	|
	|
	|        /// <summary>
	|        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
	|        /// <see cref='Terminal.Gui.PointF.X'/> and <see cref='Terminal.Gui.PointF.Y'/> properties of the two
	|        /// <see cref='Terminal.Gui.PointF'/> objects are equal.
	|        /// </summary>
	|        public bool Equals(PointF other) => this == other;
	|
	|        /// <summary>
	|        /// Generates a hashcode from the X and Y components
	|        /// </summary>
	|        /// <returns></returns>
	|        public override int GetHashCode()
	|        {
	|            return X.GetHashCode() ^ Y.GetHashCode();
	|        }
	|
	|        /// <summary>
	|        /// Returns a string including the X and Y values
	|        /// </summary>
	|        /// <returns></returns>
	|        public override string ToString() => ""{X="" + x.ToString() + "", Y="" + y.ToString() + ""}"";
	|    }
	|    //=======================================================================
	|    //
	|    // PosDim.cs: Pos and Dim objects for view dimensions.
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    /// Describes the position of a <see cref=""View""/> which can be an absolute value, a percentage, centered, or 
	|    /// relative to the ending dimension. Integer values are implicitly convertible to
	|    /// an absolute <see cref=""Pos""/>. These objects are created using the static methods Percent,
	|    /// AnchorEnd, and Center. The <see cref=""Pos""/> objects can be combined with the addition and 
	|    /// subtraction operators.
	|    /// </summary>
	|    /// <remarks>
	|    ///   <para>
	|    ///     Use the <see cref=""Pos""/> objects on the X or Y properties of a view to control the position.
	|    ///   </para>
	|    ///   <para>
	|    ///     These can be used to set the absolute position, when merely assigning an
	|    ///     integer value (via the implicit integer to <see cref=""Pos""/> conversion), and they can be combined
	|    ///     to produce more useful layouts, like: Pos.Center - 3, which would shift the position
	|    ///     of the <see cref=""View""/> 3 characters to the left after centering for example.
	|    ///   </para>
	|    ///   <para>
	|    ///     It is possible to reference coordinates of another view by using the methods
	|    ///     Left(View), Right(View), Bottom(View), Top(View). The X(View) and Y(View) are
	|    ///     aliases to Left(View) and Top(View) respectively.
	|    ///   </para>
	|    /// </remarks>
	|    public class Pos
	|    {
	|        internal virtual int Anchor(int width)
	|        {
	|            return 0;
	|        }
	|
	|        // Helper class to provide dynamic value by the execution of a function that returns an integer.
	|        internal class PosFunc : Pos
	|        {
	|            Func<int> function;
	|
	|            public PosFunc(Func<int> n)
	|            {
	|                this.function = n;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return function();
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Pos.PosFunc({function()})"";
	|            }
	|
	|            public override int GetHashCode() => function.GetHashCode();
	|
	|            public override bool Equals(object other) => other is PosFunc f && f.function() == function();
	|        }
	|
	|        /// <summary>
	|        /// Creates a ""PosFunc"" from the specified function.
	|        /// </summary>
	|        /// <param name=""function"">The function to be executed.</param>
	|        /// <returns>The <see cref=""Pos""/> returned from the function.</returns>
	|        public static Pos Function(Func<int> function)
	|        {
	|            return new PosFunc(function);
	|        }
	|
	|        internal class PosFactor : Pos
	|        {
	|            float factor;
	|
	|            public PosFactor(float n)
	|            {
	|                this.factor = n;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return (int)(width * factor);
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Pos.Factor({factor})"";
	|            }
	|
	|            public override int GetHashCode() => factor.GetHashCode();
	|
	|            public override bool Equals(object other) => other is PosFactor f && f.factor == factor;
	|        }
	|
	|        /// <summary>
	|        /// Creates a percentage <see cref=""Pos""/> object
	|        /// </summary>
	|        /// <returns>The percent <see cref=""Pos""/> object.</returns>
	|        /// <param name=""n"">A value between 0 and 100 representing the percentage.</param>
	|        /// <example>
	|        /// This creates a <see cref=""TextField""/>that is centered horizontally, is 50% of the way down, 
	|        /// is 30% the height, and is 80% the width of the <see cref=""View""/> it added to.
	|        /// <code>
	|        /// var textView = new TextView () {
	|        ///	X = Pos.Center (),
	|        ///	Y = Pos.Percent (50),
	|        ///	Width = Dim.Percent (80),
	|        /// 	Height = Dim.Percent (30),
	|        /// };
	|        /// </code>
	|        /// </example>
	|        public static Pos Percent(float n)
	|        {
	|            if (n < 0 || n > 100)
	|                throw new ArgumentException(""Percent value must be between 0 and 100"");
	|
	|            return new PosFactor(n / 100);
	|        }
	|
	|        internal class PosAnchorEnd : Pos
	|        {
	|            int n;
	|
	|            public PosAnchorEnd(int n)
	|            {
	|                this.n = n;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return width - n;
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Pos.AnchorEnd(margin={n})"";
	|            }
	|
	|            public override int GetHashCode() => n.GetHashCode();
	|
	|            public override bool Equals(object other) => other is PosAnchorEnd anchorEnd && anchorEnd.n == n;
	|        }
	|
	|        /// <summary>
	|        /// Creates a <see cref=""Pos""/> object that is anchored to the end (right side or bottom) of the dimension, 
	|        /// useful to flush the layout from the right or bottom.
	|        /// </summary>
	|        /// <returns>The <see cref=""Pos""/> object anchored to the end (the bottom or the right side).</returns>
	|        /// <param name=""margin"">Optional margin to place to the right or below.</param>
	|        /// <example>
	|        /// This sample shows how align a <see cref=""Button""/> to the bottom-right of a <see cref=""View""/>.
	|        /// <code>
	|        /// // See Issue #502 
	|        /// anchorButton.X = Pos.AnchorEnd () - (Pos.Right (anchorButton) - Pos.Left (anchorButton));
	|        /// anchorButton.Y = Pos.AnchorEnd (1);
	|        /// </code>
	|        /// </example>
	|        public static Pos AnchorEnd(int margin = 0)
	|        {
	|            if (margin < 0)
	|                throw new ArgumentException(""Margin must be positive"");
	|
	|            return new PosAnchorEnd(margin);
	|        }
	|
	|        internal class PosCenter : Pos
	|        {
	|            internal override int Anchor(int width)
	|            {
	|                return width / 2;
	|            }
	|
	|            public override string ToString()
	|            {
	|                return ""Pos.Center"";
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Pos""/> object that can be used to center the <see cref=""View""/>
	|        /// </summary>
	|        /// <returns>The center Pos.</returns>
	|        /// <example>
	|        /// This creates a <see cref=""TextField""/>that is centered horizontally, is 50% of the way down, 
	|        /// is 30% the height, and is 80% the width of the <see cref=""View""/> it added to.
	|        /// <code>
	|        /// var textView = new TextView () {
	|        ///	X = Pos.Center (),
	|        ///	Y = Pos.Percent (50),
	|        ///	Width = Dim.Percent (80),
	|        /// 	Height = Dim.Percent (30),
	|        /// };
	|        /// </code>
	|        /// </example>
	|        public static Pos Center()
	|        {
	|            return new PosCenter();
	|        }
	|
	|        internal class PosAbsolute : Pos
	|        {
	|            int n;
	|            public PosAbsolute(int n) { this.n = n; }
	|
	|            public override string ToString()
	|            {
	|                return $""Pos.Absolute({n})"";
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return n;
	|            }
	|
	|            public override int GetHashCode() => n.GetHashCode();
	|
	|            public override bool Equals(object other) => other is PosAbsolute abs && abs.n == n;
	|        }
	|
	|        /// <summary>
	|        /// Creates an Absolute <see cref=""Pos""/> from the specified integer value.
	|        /// </summary>
	|        /// <returns>The Absolute <see cref=""Pos""/>.</returns>
	|        /// <param name=""n"">The value to convert to the <see cref=""Pos""/> .</param>
	|        public static implicit operator Pos(int n)
	|        {
	|            return new PosAbsolute(n);
	|        }
	|
	|        /// <summary>
	|        /// Creates an Absolute <see cref=""Pos""/> from the specified integer value.
	|        /// </summary>
	|        /// <returns>The Absolute <see cref=""Pos""/>.</returns>
	|        /// <param name=""n"">The value to convert to the <see cref=""Pos""/>.</param>
	|        public static Pos At(int n)
	|        {
	|            return new PosAbsolute(n);
	|        }
	|
	|        internal class PosCombine : Pos
	|        {
	|            internal Pos left, right;
	|            bool add;
	|            public PosCombine(bool add, Pos left, Pos right)
	|            {
	|                this.left = left;
	|                this.right = right;
	|                this.add = add;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                var la = left.Anchor(width);
	|                var ra = right.Anchor(width);
	|                if (add)
	|                    return la + ra;
	|                else
	|                    return la - ra;
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Pos.Combine({left.ToString()}{(add ? '+' : '-')}{right.ToString()})"";
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Adds a <see cref=""Terminal.Gui.Pos""/> to a <see cref=""Terminal.Gui.Pos""/>, yielding a new <see cref=""Pos""/>.
	|        /// </summary>
	|        /// <param name=""left"">The first <see cref=""Terminal.Gui.Pos""/> to add.</param>
	|        /// <param name=""right"">The second <see cref=""Terminal.Gui.Pos""/> to add.</param>
	|        /// <returns>The <see cref=""Pos""/> that is the sum of the values of <c>left</c> and <c>right</c>.</returns>
	|        public static Pos operator +(Pos left, Pos right)
	|        {
	|            if (left is PosAbsolute && right is PosAbsolute)
	|            {
	|                return new PosAbsolute(left.Anchor(0) + right.Anchor(0));
	|            }
	|            PosCombine newPos = new PosCombine(true, left, right);
	|            SetPosCombine(left, newPos);
	|            return newPos;
	|        }
	|
	|        /// <summary>
	|        /// Subtracts a <see cref=""Terminal.Gui.Pos""/> from a <see cref=""Terminal.Gui.Pos""/>, yielding a new <see cref=""Pos""/>.
	|        /// </summary>
	|        /// <param name=""left"">The <see cref=""Terminal.Gui.Pos""/> to subtract from (the minuend).</param>
	|        /// <param name=""right"">The <see cref=""Terminal.Gui.Pos""/> to subtract (the subtrahend).</param>
	|        /// <returns>The <see cref=""Pos""/> that is the <c>left</c> minus <c>right</c>.</returns>
	|        public static Pos operator -(Pos left, Pos right)
	|        {
	|            if (left is PosAbsolute && right is PosAbsolute)
	|            {
	|                return new PosAbsolute(left.Anchor(0) - right.Anchor(0));
	|            }
	|            PosCombine newPos = new PosCombine(false, left, right);
	|            SetPosCombine(left, newPos);
	|            return newPos;
	|        }
	|
	|        static void SetPosCombine(Pos left, PosCombine newPos)
	|        {
	|            var view = left as PosView;
	|            if (view != null)
	|            {
	|                view.Target.SetNeedsLayout();
	|            }
	|        }
	|
	|        internal class PosView : Pos
	|        {
	|            public View Target;
	|            int side;
	|            public PosView(View view, int side)
	|            {
	|                Target = view;
	|                this.side = side;
	|            }
	|            internal override int Anchor(int width)
	|            {
	|                switch (side)
	|                {
	|                    case 0: return Target.Frame.X;
	|                    case 1: return Target.Frame.Y;
	|                    case 2: return Target.Frame.Right;
	|                    case 3: return Target.Frame.Bottom;
	|                    default:
	|                        return 0;
	|                }
	|            }
	|
	|            public override string ToString()
	|            {
	|                string tside;
	|                switch (side)
	|                {
	|                    case 0: tside = ""x""; break;
	|                    case 1: tside = ""y""; break;
	|                    case 2: tside = ""right""; break;
	|                    case 3: tside = ""bottom""; break;
	|                    default: tside = ""unknown""; break;
	|                }
	|                return $""Pos.View(side={tside}, target={Target.ToString()})"";
	|            }
	|
	|            public override int GetHashCode() => Target.GetHashCode();
	|
	|            public override bool Equals(object other) => other is PosView abs && abs.Target == Target;
	|        }
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Pos""/> object tracks the Left (X) position of the specified <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The <see cref=""Pos""/> that depends on the other view.</returns>
	|        /// <param name=""view"">The <see cref=""View""/>  that will be tracked.</param>
	|        public static Pos Left(View view) => new PosCombine(true, new PosView(view, 0), new Pos.PosAbsolute(0));
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Pos""/> object tracks the Left (X) position of the specified <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The <see cref=""Pos""/> that depends on the other view.</returns>
	|        /// <param name=""view"">The <see cref=""View""/>  that will be tracked.</param>
	|        public static Pos X(View view) => new PosCombine(true, new PosView(view, 0), new Pos.PosAbsolute(0));
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Pos""/> object tracks the Top (Y) position of the specified <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The <see cref=""Pos""/> that depends on the other view.</returns>
	|        /// <param name=""view"">The <see cref=""View""/>  that will be tracked.</param>
	|        public static Pos Top(View view) => new PosCombine(true, new PosView(view, 1), new Pos.PosAbsolute(0));
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Pos""/> object tracks the Top (Y) position of the specified <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The <see cref=""Pos""/> that depends on the other view.</returns>
	|        /// <param name=""view"">The <see cref=""View""/>  that will be tracked.</param>
	|        public static Pos Y(View view) => new PosCombine(true, new PosView(view, 1), new Pos.PosAbsolute(0));
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Pos""/> object tracks the Right (X+Width) coordinate of the specified <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The <see cref=""Pos""/> that depends on the other view.</returns>
	|        /// <param name=""view"">The <see cref=""View""/>  that will be tracked.</param>
	|        public static Pos Right(View view) => new PosCombine(true, new PosView(view, 2), new Pos.PosAbsolute(0));
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Pos""/> object tracks the Bottom (Y+Height) coordinate of the specified <see cref=""View""/> 
	|        /// </summary>
	|        /// <returns>The <see cref=""Pos""/> that depends on the other view.</returns>
	|        /// <param name=""view"">The <see cref=""View""/>  that will be tracked.</param>
	|        public static Pos Bottom(View view) => new PosCombine(true, new PosView(view, 3), new Pos.PosAbsolute(0));
	|
	|        /// <summary>Serves as the default hash function. </summary>
	|        /// <returns>A hash code for the current object.</returns>
	|        public override int GetHashCode() => Anchor(0).GetHashCode();
	|
	|        /// <summary>Determines whether the specified object is equal to the current object.</summary>
	|        /// <param name=""other"">The object to compare with the current object. </param>
	|        /// <returns>
	|        ///     <see langword=""true"" /> if the specified object  is equal to the current object; otherwise, <see langword=""false"" />.</returns>
	|        public override bool Equals(object other) => other is Pos abs && abs == this;
	|    }
	|
	|    /// <summary>
	|    /// Dim properties of a <see cref=""View""/> to control the position.
	|    /// </summary>
	|    /// <remarks>
	|    ///   <para>
	|    ///     Use the Dim objects on the Width or Height properties of a <see cref=""View""/> to control the position.
	|    ///   </para>
	|    ///   <para>
	|    ///     These can be used to set the absolute position, when merely assigning an
	|    ///     integer value (via the implicit integer to Pos conversion), and they can be combined
	|    ///     to produce more useful layouts, like: Pos.Center - 3, which would shift the position
	|    ///     of the <see cref=""View""/> 3 characters to the left after centering for example.
	|    ///   </para>
	|    /// </remarks>
	|    public class Dim
	|    {
	|        internal virtual int Anchor(int width)
	|        {
	|            return 0;
	|        }
	|
	|        // Helper class to provide dynamic value by the execution of a function that returns an integer.
	|        internal class DimFunc : Dim
	|        {
	|            Func<int> function;
	|
	|            public DimFunc(Func<int> n)
	|            {
	|                this.function = n;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return function();
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Dim.DimFunc({function()})"";
	|            }
	|
	|            public override int GetHashCode() => function.GetHashCode();
	|
	|            public override bool Equals(object other) => other is DimFunc f && f.function() == function();
	|        }
	|
	|        /// <summary>
	|        /// Creates a ""DimFunc"" from the specified function.
	|        /// </summary>
	|        /// <param name=""function"">The function to be executed.</param>
	|        /// <returns>The <see cref=""Dim""/> returned from the function.</returns>
	|        public static Dim Function(Func<int> function)
	|        {
	|            return new DimFunc(function);
	|        }
	|
	|        internal class DimFactor : Dim
	|        {
	|            float factor;
	|            bool remaining;
	|
	|            public DimFactor(float n, bool r = false)
	|            {
	|                factor = n;
	|                remaining = r;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return (int)(width * factor);
	|            }
	|
	|            public bool IsFromRemaining()
	|            {
	|                return remaining;
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Dim.Factor(factor={factor}, remaining={remaining})"";
	|            }
	|
	|            public override int GetHashCode() => factor.GetHashCode();
	|
	|            public override bool Equals(object other) => other is DimFactor f && f.factor == factor && f.remaining == remaining;
	|        }
	|
	|        /// <summary>
	|        /// Creates a percentage <see cref=""Dim""/> object
	|        /// </summary>
	|        /// <returns>The percent <see cref=""Dim""/> object.</returns>
	|        /// <param name=""n"">A value between 0 and 100 representing the percentage.</param>
	|        /// <param name=""r"">If <c>true</c> the Percent is computed based on the remaining space after the X/Y anchor positions. If <c>false</c> is computed based on the whole original space.</param>
	|        /// <example>
	|        /// This initializes a <see cref=""TextField""/>that is centered horizontally, is 50% of the way down, 
	|        /// is 30% the height, and is 80% the width of the <see cref=""View""/> it added to.
	|        /// <code>
	|        /// var textView = new TextView () {
	|        ///	X = Pos.Center (),
	|        ///	Y = Pos.Percent (50),
	|        ///	Width = Dim.Percent (80),
	|        /// 	Height = Dim.Percent (30),
	|        /// };
	|        /// </code>
	|        /// </example>
	|        public static Dim Percent(float n, bool r = false)
	|        {
	|            if (n < 0 || n > 100)
	|                throw new ArgumentException(""Percent value must be between 0 and 100"");
	|
	|            return new DimFactor(n / 100, r);
	|        }
	|
	|        internal class DimAbsolute : Dim
	|        {
	|            int n;
	|            public DimAbsolute(int n) { this.n = n; }
	|
	|            public override string ToString()
	|            {
	|                return $""Dim.Absolute({n})"";
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return n;
	|            }
	|
	|            public override int GetHashCode() => n.GetHashCode();
	|
	|            public override bool Equals(object other) => other is DimAbsolute abs && abs.n == n;
	|        }
	|
	|        internal class DimFill : Dim
	|        {
	|            int margin;
	|            public DimFill(int margin) { this.margin = margin; }
	|
	|            public override string ToString()
	|            {
	|                return $""Dim.Fill(margin={margin})"";
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                return width - margin;
	|            }
	|
	|            public override int GetHashCode() => margin.GetHashCode();
	|
	|            public override bool Equals(object other) => other is DimFill fill && fill.margin == margin;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Dim""/> class that fills the dimension, but leaves the specified number of colums for a margin.
	|        /// </summary>
	|        /// <returns>The Fill dimension.</returns>
	|        /// <param name=""margin"">Margin to use.</param>
	|        public static Dim Fill(int margin = 0)
	|        {
	|            return new DimFill(margin);
	|        }
	|
	|        /// <summary>
	|        /// Creates an Absolute <see cref=""Dim""/> from the specified integer value.
	|        /// </summary>
	|        /// <returns>The Absolute <see cref=""Dim""/>.</returns>
	|        /// <param name=""n"">The value to convert to the pos.</param>
	|        public static implicit operator Dim(int n)
	|        {
	|            return new DimAbsolute(n);
	|        }
	|
	|        /// <summary>
	|        /// Creates an Absolute <see cref=""Dim""/> from the specified integer value.
	|        /// </summary>
	|        /// <returns>The Absolute <see cref=""Dim""/>.</returns>
	|        /// <param name=""n"">The value to convert to the <see cref=""Dim""/>.</param>
	|        public static Dim Sized(int n)
	|        {
	|            return new DimAbsolute(n);
	|        }
	|
	|        internal class DimCombine : Dim
	|        {
	|            internal Dim left, right;
	|            internal bool add;
	|            public DimCombine(bool add, Dim left, Dim right)
	|            {
	|                this.left = left;
	|                this.right = right;
	|                this.add = add;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                var la = left.Anchor(width);
	|                var ra = right.Anchor(width);
	|                if (add)
	|                    return la + ra;
	|                else
	|                    return la - ra;
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Dim.Combine({left.ToString()}{(add ? '+' : '-')}{right.ToString()})"";
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Adds a <see cref=""Terminal.Gui.Dim""/> to a <see cref=""Terminal.Gui.Dim""/>, yielding a new <see cref=""Dim""/>.
	|        /// </summary>
	|        /// <param name=""left"">The first <see cref=""Terminal.Gui.Dim""/> to add.</param>
	|        /// <param name=""right"">The second <see cref=""Terminal.Gui.Dim""/> to add.</param>
	|        /// <returns>The <see cref=""Dim""/> that is the sum of the values of <c>left</c> and <c>right</c>.</returns>
	|        public static Dim operator +(Dim left, Dim right)
	|        {
	|            if (left is DimAbsolute && right is DimAbsolute)
	|            {
	|                return new DimAbsolute(left.Anchor(0) + right.Anchor(0));
	|            }
	|            DimCombine newDim = new DimCombine(true, left, right);
	|            SetDimCombine(left, newDim);
	|            return newDim;
	|        }
	|
	|        /// <summary>
	|        /// Subtracts a <see cref=""Terminal.Gui.Dim""/> from a <see cref=""Terminal.Gui.Dim""/>, yielding a new <see cref=""Dim""/>.
	|        /// </summary>
	|        /// <param name=""left"">The <see cref=""Terminal.Gui.Dim""/> to subtract from (the minuend).</param>
	|        /// <param name=""right"">The <see cref=""Terminal.Gui.Dim""/> to subtract (the subtrahend).</param>
	|        /// <returns>The <see cref=""Dim""/> that is the <c>left</c> minus <c>right</c>.</returns>
	|        public static Dim operator -(Dim left, Dim right)
	|        {
	|            if (left is DimAbsolute && right is DimAbsolute)
	|            {
	|                return new DimAbsolute(left.Anchor(0) - right.Anchor(0));
	|            }
	|            DimCombine newDim = new DimCombine(false, left, right);
	|            SetDimCombine(left, newDim);
	|            return newDim;
	|        }
	|
	|        static void SetDimCombine(Dim left, DimCombine newPos)
	|        {
	|            var view = left as DimView;
	|            if (view != null)
	|            {
	|                view.Target.SetNeedsLayout();
	|            }
	|        }
	|
	|        internal class DimView : Dim
	|        {
	|            public View Target;
	|            int side;
	|            public DimView(View view, int side)
	|            {
	|                Target = view;
	|                this.side = side;
	|            }
	|
	|            internal override int Anchor(int width)
	|            {
	|                switch (side)
	|                {
	|                    case 0: return Target.Frame.Height;
	|                    case 1: return Target.Frame.Width;
	|                    default:
	|                        return 0;
	|                }
	|            }
	|
	|            public override string ToString()
	|            {
	|                string tside;
	|                switch (side)
	|                {
	|                    case 0: tside = ""Height""; break;
	|                    case 1: tside = ""Width""; break;
	|                    default: tside = ""unknown""; break;
	|                }
	|                return $""DimView(side={tside}, target={Target.ToString()})"";
	|            }
	|
	|            public override int GetHashCode() => Target.GetHashCode();
	|
	|            public override bool Equals(object other) => other is DimView abs && abs.Target == Target;
	|        }
	|        /// <summary>
	|        /// Returns a <see cref=""Dim""/> object tracks the Width of the specified <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The <see cref=""Dim""/> of the other <see cref=""View""/>.</returns>
	|        /// <param name=""view"">The view that will be tracked.</param>
	|        public static Dim Width(View view) => new DimView(view, 1);
	|
	|        /// <summary>
	|        /// Returns a <see cref=""Dim""/> object tracks the Height of the specified <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The <see cref=""Dim""/> of the other <see cref=""View""/>.</returns>
	|        /// <param name=""view"">The view that will be tracked.</param>
	|        public static Dim Height(View view) => new DimView(view, 0);
	|
	|        /// <summary>Serves as the default hash function. </summary>
	|        /// <returns>A hash code for the current object.</returns>
	|        public override int GetHashCode() => Anchor(0).GetHashCode();
	|
	|        /// <summary>Determines whether the specified object is equal to the current object.</summary>
	|        /// <param name=""other"">The object to compare with the current object. </param>
	|        /// <returns>
	|        ///     <see langword=""true"" /> if the specified object  is equal to the current object; otherwise, <see langword=""false"" />.</returns>
	|        public override bool Equals(object other) => other is Dim abs && abs == this;
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Specifies the style that a <see cref=""ProgressBar""/> uses to indicate the progress of an operation.
	|    /// </summary>
	|    public enum ProgressBarStyle
	|    {
	|        /// <summary>
	|        /// Indicates progress by increasing the number of segmented blocks in a <see cref=""ProgressBar""/>.
	|        /// </summary>
	|        Blocks,
	|        /// <summary>
	|        /// Indicates progress by increasing the size of a smooth, continuous bar in a <see cref=""ProgressBar""/>.
	|        /// </summary>
	|        Continuous,
	|        /// <summary>
	|        /// Indicates progress by continuously scrolling a block across a <see cref=""ProgressBar""/> in a marquee fashion.
	|        /// </summary>
	|        MarqueeBlocks,
	|        /// <summary>
	|        /// Indicates progress by continuously scrolling a block across a <see cref=""ProgressBar""/> in a marquee fashion.
	|        /// </summary>
	|        MarqueeContinuous
	|
	|    }
	|
	|    /// <summary>
	|    ///Specifies the format that a <see cref=""ProgressBar""/> uses to indicate the visual presentation.
	|    /// </summary>
	|    public enum ProgressBarFormat
	|    {
	|        /// <summary>
	|        /// A simple visual presentation showing only the progress bar.
	|        /// </summary>
	|        Simple,
	|        /// <summary>
	|        /// A simple visual presentation showing the progress bar and the percentage.
	|        /// </summary>
	|        SimplePlusPercentage,
	|        /// <summary>
	|        /// A framed visual presentation showing only the progress bar.
	|        /// </summary>
	|        Framed,
	|        /// <summary>
	|        /// A framed visual presentation showing the progress bar and the percentage.
	|        /// </summary>
	|        FramedPlusPercentage,
	|        /// <summary>
	|        /// A framed visual presentation showing all with the progress bar padded.
	|        /// </summary>
	|        FramedProgressPadded
	|    }
	|
	|    /// <summary>
	|    /// A Progress Bar view that can indicate progress of an activity visually.
	|    /// </summary>
	|    /// <remarks>
	|    ///   <para>
	|    ///     <see cref=""ProgressBar""/> can operate in two modes, percentage mode, or
	|    ///     activity mode.  The progress bar starts in percentage mode and
	|    ///     setting the Fraction property will reflect on the UI the progress 
	|    ///     made so far.   Activity mode is used when the application has no 
	|    ///     way of knowing how much time is left, and is started when the <see cref=""Pulse""/> method is called.  
	|    ///     Call <see cref=""Pulse""/> repeatedly as progress is made.
	|    ///   </para>
	|    /// </remarks>
	|    public class ProgressBar : View
	|    {
	|        bool isActivity;
	|        int[] activityPos;
	|        int delta, padding;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""ProgressBar""/> class, starts in percentage mode with an absolute position and size.
	|        /// </summary>
	|        /// <param name=""rect"">Rect.</param>
	|        public ProgressBar(Rect rect) : base(rect)
	|        {
	|            Initialize(rect);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""ProgressBar""/> class, starts in percentage mode and uses relative layout.
	|        /// </summary>
	|        public ProgressBar() : base()
	|        {
	|            Initialize(Rect.Empty);
	|        }
	|
	|        void Initialize(Rect rect)
	|        {
	|            CanFocus = false;
	|            fraction = 0;
	|            ColorScheme = new ColorScheme()
	|            {
	|                Normal = Application.Driver.MakeAttribute(Color.BrightGreen, Color.Gray),
	|                HotNormal = Colors.Base.Normal
	|            };
	|            if (rect.IsEmpty)
	|            {
	|                Height = 1;
	|            }
	|        }
	|
	|        float fraction;
	|
	|        /// <summary>
	|        /// Gets or sets the <see cref=""ProgressBar""/> fraction to display, must be a value between 0 and 1.
	|        /// </summary>
	|        /// <value>The fraction representing the progress.</value>
	|        public float Fraction
	|        {
	|            get => fraction;
	|            set
	|            {
	|                fraction = Math.Min(value, 1);
	|                isActivity = false;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ProgressBarStyle progressBarStyle;
	|
	|        /// <summary>
	|        /// Gets/Sets the progress bar style based on the <see cref=""Terminal.Gui.ProgressBarStyle""/>
	|        /// </summary>
	|        public ProgressBarStyle ProgressBarStyle
	|        {
	|            get => progressBarStyle;
	|            set
	|            {
	|                progressBarStyle = value;
	|                switch (value)
	|                {
	|                    case ProgressBarStyle.Blocks:
	|                        SegmentCharacter = Driver.BlocksMeterSegment;
	|                        break;
	|                    case ProgressBarStyle.Continuous:
	|                        SegmentCharacter = Driver.ContinuousMeterSegment;
	|                        break;
	|                    case ProgressBarStyle.MarqueeBlocks:
	|                        SegmentCharacter = Driver.BlocksMeterSegment;
	|                        break;
	|                    case ProgressBarStyle.MarqueeContinuous:
	|                        SegmentCharacter = Driver.ContinuousMeterSegment;
	|                        break;
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        private ProgressBarFormat progressBarFormat;
	|
	|        /// <summary>
	|        /// Specifies the format that a <see cref=""ProgressBar""/> uses to indicate the visual presentation.
	|        /// </summary>
	|        public ProgressBarFormat ProgressBarFormat
	|        {
	|            get => progressBarFormat;
	|            set
	|            {
	|                progressBarFormat = value;
	|                switch (progressBarFormat)
	|                {
	|                    case ProgressBarFormat.Simple:
	|                        Height = 1;
	|                        break;
	|                    case ProgressBarFormat.SimplePlusPercentage:
	|                        Height = 2;
	|                        break;
	|                    case ProgressBarFormat.Framed:
	|                        Height = 3;
	|                        break;
	|                    case ProgressBarFormat.FramedPlusPercentage:
	|                        Height = 4;
	|                        break;
	|                    case ProgressBarFormat.FramedProgressPadded:
	|                        Height = 6;
	|                        break;
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        private Rune segmentCharacter = Driver.BlocksMeterSegment;
	|
	|        /// <summary>
	|        /// Segment indicator for meter views.
	|        /// </summary>
	|        public Rune SegmentCharacter
	|        {
	|            get => segmentCharacter;
	|            set
	|            {
	|                segmentCharacter = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override ustring Text
	|        {
	|            get => GetPercentageText();
	|            set
	|            {
	|                base.Text = SetPercentageText(value);
	|            }
	|        }
	|
	|        private bool bidirectionalMarquee = true;
	|
	|        /// <summary>
	|        /// Specifies if the <see cref=""ProgressBarStyle.MarqueeBlocks""/> or the
	|        ///  <see cref=""ProgressBarStyle.MarqueeContinuous""/> styles is unidirectional
	|        ///  or bidirectional.
	|        /// </summary>
	|        public bool BidirectionalMarquee
	|        {
	|            get => bidirectionalMarquee;
	|            set
	|            {
	|                bidirectionalMarquee = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ustring GetPercentageText()
	|        {
	|            switch (progressBarStyle)
	|            {
	|                case ProgressBarStyle.Blocks:
	|                case ProgressBarStyle.Continuous:
	|                    return $""{fraction * 100:F0}%"";
	|                case ProgressBarStyle.MarqueeBlocks:
	|                case ProgressBarStyle.MarqueeContinuous:
	|                    break;
	|            }
	|
	|            return base.Text;
	|        }
	|
	|        ustring SetPercentageText(ustring value)
	|        {
	|            switch (progressBarStyle)
	|            {
	|                case ProgressBarStyle.Blocks:
	|                case ProgressBarStyle.Continuous:
	|                    return $""{fraction * 100:F0}%"";
	|                case ProgressBarStyle.MarqueeBlocks:
	|                case ProgressBarStyle.MarqueeContinuous:
	|                    break;
	|            }
	|
	|            return value;
	|        }
	|
	|        /// <summary>
	|        /// Notifies the <see cref=""ProgressBar""/> that some progress has taken place.
	|        /// </summary>
	|        /// <remarks>
	|        /// If the <see cref=""ProgressBar""/> is percentage mode, it switches to activity
	|        /// mode. If is in activity mode, the marker is moved.
	|        /// </remarks>
	|        public void Pulse()
	|        {
	|            if (activityPos == null)
	|            {
	|                PopulateActivityPos();
	|            }
	|            if (!isActivity)
	|            {
	|                isActivity = true;
	|                delta = 1;
	|            }
	|            else
	|            {
	|                for (int i = 0; i < activityPos.Length; i++)
	|                {
	|                    activityPos[i] += delta;
	|                }
	|                int fWidth = GetFrameWidth();
	|                if (activityPos[activityPos.Length - 1] < 0)
	|                {
	|                    for (int i = 0; i < activityPos.Length; i++)
	|                    {
	|                        activityPos[i] = i - activityPos.Length + 2;
	|                    }
	|                    delta = 1;
	|                }
	|                else if (activityPos[0] >= fWidth)
	|                {
	|                    if (bidirectionalMarquee)
	|                    {
	|                        for (int i = 0; i < activityPos.Length; i++)
	|                        {
	|                            activityPos[i] = fWidth + i - 2;
	|                        }
	|                        delta = -1;
	|                    }
	|                    else
	|                    {
	|                        PopulateActivityPos();
	|                    }
	|                }
	|            }
	|
	|            SetNeedsDisplay();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect region)
	|        {
	|            DrawFrame();
	|
	|            Driver.SetAttribute(GetNormalColor());
	|
	|            int fWidth = GetFrameWidth();
	|            if (isActivity)
	|            {
	|                Move(padding, padding);
	|                for (int i = 0; i < fWidth; i++)
	|                    if (Array.IndexOf(activityPos, i) != -1)
	|                        Driver.AddRune(SegmentCharacter);
	|                    else
	|                        Driver.AddRune(' ');
	|            }
	|            else
	|            {
	|                Move(padding, padding);
	|                int mid = (int)(fraction * fWidth);
	|                int i;
	|                for (i = 0; i < mid & i < fWidth; i++)
	|                    Driver.AddRune(SegmentCharacter);
	|                for (; i < fWidth; i++)
	|                    Driver.AddRune(' ');
	|            }
	|
	|            DrawText(fWidth);
	|        }
	|
	|        int GetFrameWidth()
	|        {
	|            switch (progressBarFormat)
	|            {
	|                case ProgressBarFormat.Simple:
	|                case ProgressBarFormat.SimplePlusPercentage:
	|                    break;
	|                case ProgressBarFormat.Framed:
	|                case ProgressBarFormat.FramedPlusPercentage:
	|                    return Frame.Width - 2;
	|                case ProgressBarFormat.FramedProgressPadded:
	|                    return Frame.Width - 2 - padding;
	|            }
	|
	|            return Frame.Width;
	|        }
	|
	|        void DrawText(int fWidth)
	|        {
	|            switch (progressBarFormat)
	|            {
	|                case ProgressBarFormat.Simple:
	|                case ProgressBarFormat.Framed:
	|                    break;
	|                case ProgressBarFormat.SimplePlusPercentage:
	|                case ProgressBarFormat.FramedPlusPercentage:
	|                case ProgressBarFormat.FramedProgressPadded:
	|                    var tf = new TextFormatter()
	|                    {
	|                        Alignment = TextAlignment.Centered,
	|                        Text = Text
	|                    };
	|                    var row = padding + (progressBarFormat == ProgressBarFormat.FramedProgressPadded
	|                        ? 2 : 1);
	|                    Move(padding, row);
	|                    var rect = new Rect(padding, row, fWidth, Frame.Height);
	|                    tf?.Draw(ViewToScreen(rect), ColorScheme.HotNormal, ColorScheme.HotNormal,
	|                        SuperView == null ? default : SuperView.ViewToScreen(SuperView.Bounds));
	|                    break;
	|            }
	|        }
	|
	|        void DrawFrame()
	|        {
	|            switch (progressBarFormat)
	|            {
	|                case ProgressBarFormat.Simple:
	|                case ProgressBarFormat.SimplePlusPercentage:
	|                    padding = 0;
	|                    break;
	|                case ProgressBarFormat.Framed:
	|                case ProgressBarFormat.FramedPlusPercentage:
	|                    padding = 1;
	|                    Application.Driver.DrawWindowFrame(ViewToScreen(Bounds), padding, padding, padding, padding, true);
	|                    break;
	|                case ProgressBarFormat.FramedProgressPadded:
	|                    padding = 2;
	|                    Application.Driver.DrawWindowFrame(ViewToScreen(Bounds), padding, padding, padding, padding + 1, true);
	|                    Application.Driver.DrawWindowFrame(ViewToScreen(Bounds), padding - 1, padding - 1, padding - 1, padding - 1, true);
	|                    break;
	|            }
	|        }
	|
	|        void PopulateActivityPos()
	|        {
	|            activityPos = new int[Math.Min(Frame.Width / 3, 5)];
	|            for (int i = 0; i < activityPos.Length; i++)
	|            {
	|                activityPos[i] = i - activityPos.Length + 1;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Displays a group of labels each with a selected indicator. Only one of those can be selected at a given time.
	|    /// </summary>
	|    public class RadioGroup : View
	|    {
	|        int selected = -1;
	|        int cursor;
	|        DisplayModeLayout displayMode;
	|        int horizontalSpace = 2;
	|        List<(int pos, int length)> horizontal;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""RadioGroup""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        public RadioGroup() : this(radioLabels: new ustring[] { }) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""RadioGroup""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <param name=""radioLabels"">The radio labels; an array of strings that can contain hotkeys using an underscore before the letter.</param>
	|        /// <param name=""selected"">The index of the item to be selected, the value is clamped to the number of items.</param>
	|        public RadioGroup(ustring[] radioLabels, int selected = 0) : base()
	|        {
	|            Initialize(Rect.Empty, radioLabels, selected);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""RadioGroup""/> class using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <param name=""rect"">Boundaries for the radio group.</param>
	|        /// <param name=""radioLabels"">The radio labels; an array of strings that can contain hotkeys using an underscore before the letter.</param>
	|        /// <param name=""selected"">The index of item to be selected, the value is clamped to the number of items.</param>
	|        public RadioGroup(Rect rect, ustring[] radioLabels, int selected = 0) : base(rect)
	|        {
	|            Initialize(rect, radioLabels, selected);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""RadioGroup""/> class using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// The <see cref=""View""/> frame is computed from the provided radio labels.
	|        /// </summary>
	|        /// <param name=""x"">The x coordinate.</param>
	|        /// <param name=""y"">The y coordinate.</param>
	|        /// <param name=""radioLabels"">The radio labels; an array of strings that can contain hotkeys using an underscore before the letter.</param>
	|        /// <param name=""selected"">The item to be selected, the value is clamped to the number of items.</param>
	|        public RadioGroup(int x, int y, ustring[] radioLabels, int selected = 0) :
	|            this(MakeRect(x, y, radioLabels != null ? radioLabels.ToList() : null), radioLabels, selected)
	|        { }
	|
	|        void Initialize(Rect rect, ustring[] radioLabels, int selected)
	|        {
	|            if (radioLabels == null)
	|            {
	|                this.radioLabels = new List<ustring>();
	|            }
	|            else
	|            {
	|                this.radioLabels = radioLabels.ToList();
	|            }
	|
	|            this.selected = selected;
	|            if (rect == Rect.Empty)
	|            {
	|                SetWidthHeight(this.radioLabels);
	|            }
	|            else
	|            {
	|                Frame = rect;
	|            }
	|            CanFocus = true;
	|            HotKeySpecifier = new Rune('_');
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.LineUp, () => { MoveUp(); return true; });
	|            AddCommand(Command.LineDown, () => { MoveDown(); return true; });
	|            AddCommand(Command.TopHome, () => { MoveHome(); return true; });
	|            AddCommand(Command.BottomEnd, () => { MoveEnd(); return true; });
	|            AddCommand(Command.Accept, () => { SelectItem(); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|            AddKeyBinding(Key.Home, Command.TopHome);
	|            AddKeyBinding(Key.End, Command.BottomEnd);
	|            AddKeyBinding(Key.Space, Command.Accept);
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the <see cref=""DisplayModeLayout""/> for this <see cref=""RadioGroup""/>.
	|        /// </summary>
	|        public DisplayModeLayout DisplayMode
	|        {
	|            get { return displayMode; }
	|            set
	|            {
	|                if (displayMode != value)
	|                {
	|                    displayMode = value;
	|                    SetWidthHeight(radioLabels);
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the horizontal space for this <see cref=""RadioGroup""/> if the <see cref=""DisplayMode""/> is <see cref=""DisplayModeLayout.Horizontal""/>
	|        /// </summary>
	|        public int HorizontalSpace
	|        {
	|            get { return horizontalSpace; }
	|            set
	|            {
	|                if (horizontalSpace != value && displayMode == DisplayModeLayout.Horizontal)
	|                {
	|                    horizontalSpace = value;
	|                    SetWidthHeight(radioLabels);
	|                    UpdateTextFormatterText();
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        void SetWidthHeight(List<ustring> radioLabels)
	|        {
	|            switch (displayMode)
	|            {
	|                case DisplayModeLayout.Vertical:
	|                    var r = MakeRect(0, 0, radioLabels);
	|                    if (IsAdded && LayoutStyle == LayoutStyle.Computed)
	|                    {
	|                        Width = r.Width;
	|                        Height = radioLabels.Count;
	|                    }
	|                    else
	|                    {
	|                        Frame = new Rect(Frame.Location, new Size(r.Width, radioLabels.Count));
	|                    }
	|                    break;
	|                case DisplayModeLayout.Horizontal:
	|                    CalculateHorizontalPositions();
	|                    var length = 0;
	|                    foreach (var item in horizontal)
	|                    {
	|                        length += item.length;
	|                    }
	|                    var hr = new Rect(0, 0, length, 1);
	|                    if (IsAdded && LayoutStyle == LayoutStyle.Computed)
	|                    {
	|                        Width = hr.Width;
	|                        Height = 1;
	|                    }
	|                    else
	|                    {
	|                        Frame = new Rect(Frame.Location, new Size(hr.Width, radioLabels.Count));
	|                    }
	|                    break;
	|            }
	|        }
	|
	|        static Rect MakeRect(int x, int y, List<ustring> radioLabels)
	|        {
	|            if (radioLabels == null)
	|            {
	|                return new Rect(x, y, 0, 0);
	|            }
	|
	|            int width = 0;
	|
	|            foreach (var s in radioLabels)
	|                width = Math.Max(s.ConsoleWidth + 3, width);
	|            return new Rect(x, y, width, radioLabels.Count);
	|        }
	|
	|        List<ustring> radioLabels = new List<ustring>();
	|
	|        /// <summary>
	|        /// The radio labels to display
	|        /// </summary>
	|        /// <value>The radio labels.</value>
	|        public ustring[] RadioLabels
	|        {
	|            get => radioLabels.ToArray();
	|            set
	|            {
	|                var prevCount = radioLabels.Count;
	|                radioLabels = value.ToList();
	|                if (prevCount != radioLabels.Count)
	|                {
	|                    SetWidthHeight(radioLabels);
	|                }
	|                SelectedItem = 0;
	|                cursor = 0;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        private void CalculateHorizontalPositions()
	|        {
	|            if (displayMode == DisplayModeLayout.Horizontal)
	|            {
	|                horizontal = new List<(int pos, int length)>();
	|                int start = 0;
	|                int length = 0;
	|                for (int i = 0; i < radioLabels.Count; i++)
	|                {
	|                    start += length;
	|                    length = radioLabels[i].ConsoleWidth + 2 + (i < radioLabels.Count - 1 ? horizontalSpace : 0);
	|                    horizontal.Add((start, length));
	|                }
	|            }
	|        }
	|
	|        //// Redraws the RadioGroup 
	|        //void Update(List<ustring> newRadioLabels)
	|        //{
	|        //	for (int i = 0; i < radioLabels.Count; i++) {
	|        //		Move(0, i);
	|        //		Driver.SetAttribute(ColorScheme.Normal);
	|        //		Driver.AddStr(ustring.Make(new string (' ', radioLabels[i].ConsoleWidth + 4)));
	|        //	}
	|        //	if (newRadioLabels.Count != radioLabels.Count) {
	|        //		SetWidthHeight(newRadioLabels);
	|        //	}
	|        //}
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            Driver.SetAttribute(GetNormalColor());
	|            Clear();
	|            for (int i = 0; i < radioLabels.Count; i++)
	|            {
	|                switch (DisplayMode)
	|                {
	|                    case DisplayModeLayout.Vertical:
	|                        Move(0, i);
	|                        break;
	|                    case DisplayModeLayout.Horizontal:
	|                        Move(horizontal[i].pos, 0);
	|                        break;
	|                }
	|                var rl = radioLabels[i];
	|                Driver.SetAttribute(GetNormalColor());
	|                Driver.AddStr(ustring.Make(new Rune[] { i == selected ? Driver.Selected : Driver.UnSelected, ' ' }));
	|                TextFormatter.FindHotKey(rl, HotKeySpecifier, true, out int hotPos, out Key hotKey);
	|                if (hotPos != -1 && (hotKey != Key.Null || hotKey != Key.Unknown))
	|                {
	|                    var rlRunes = rl.ToRunes();
	|                    for (int j = 0; j < rlRunes.Length; j++)
	|                    {
	|                        Rune rune = rlRunes[j];
	|                        if (j == hotPos && i == cursor)
	|                        {
	|                            Application.Driver.SetAttribute(HasFocus ? ColorScheme.HotFocus : GetHotNormalColor());
	|                        }
	|                        else if (j == hotPos && i != cursor)
	|                        {
	|                            Application.Driver.SetAttribute(GetHotNormalColor());
	|                        }
	|                        else if (HasFocus && i == cursor)
	|                        {
	|                            Application.Driver.SetAttribute(ColorScheme.Focus);
	|                        }
	|                        if (rune == HotKeySpecifier && j + 1 < rlRunes.Length)
	|                        {
	|                            j++;
	|                            rune = rlRunes[j];
	|                            if (i == cursor)
	|                            {
	|                                Application.Driver.SetAttribute(HasFocus ? ColorScheme.HotFocus : GetHotNormalColor());
	|                            }
	|                            else if (i != cursor)
	|                            {
	|                                Application.Driver.SetAttribute(GetHotNormalColor());
	|                            }
	|                        }
	|                        Application.Driver.AddRune(rune);
	|                        Driver.SetAttribute(GetNormalColor());
	|                    }
	|                }
	|                else
	|                {
	|                    DrawHotString(rl, HasFocus && i == cursor, ColorScheme);
	|                }
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            switch (DisplayMode)
	|            {
	|                case DisplayModeLayout.Vertical:
	|                    Move(0, cursor);
	|                    break;
	|                case DisplayModeLayout.Horizontal:
	|                    Move(horizontal[cursor].pos, 0);
	|                    break;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Invoked when the selected radio label has changed.
	|        /// </summary>
	|        public event Action<SelectedItemChangedArgs> SelectedItemChanged;
	|
	|        /// <summary>
	|        /// The currently selected item from the list of radio labels
	|        /// </summary>
	|        /// <value>The selected.</value>
	|        public int SelectedItem
	|        {
	|            get => selected;
	|            set
	|            {
	|                OnSelectedItemChanged(value, SelectedItem);
	|                cursor = selected;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Allow to invoke the <see cref=""SelectedItemChanged""/> after their creation.
	|        /// </summary>
	|        public void Refresh()
	|        {
	|            OnSelectedItemChanged(selected, -1);
	|        }
	|
	|        /// <summary>
	|        /// Called whenever the current selected item changes. Invokes the <see cref=""SelectedItemChanged""/> event.
	|        /// </summary>
	|        /// <param name=""selectedItem""></param>
	|        /// <param name=""previousSelectedItem""></param>
	|        public virtual void OnSelectedItemChanged(int selectedItem, int previousSelectedItem)
	|        {
	|            selected = selectedItem;
	|            SelectedItemChanged?.Invoke(new SelectedItemChangedArgs(selectedItem, previousSelectedItem));
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessColdKey(KeyEvent kb)
	|        {
	|            var key = kb.KeyValue;
	|            if (key < Char.MaxValue && Char.IsLetterOrDigit((char)key))
	|            {
	|                int i = 0;
	|                key = Char.ToUpper((char)key);
	|                foreach (var l in radioLabels)
	|                {
	|                    bool nextIsHot = false;
	|                    TextFormatter.FindHotKey(l, HotKeySpecifier, true, out _, out Key hotKey);
	|                    foreach (Rune c in l)
	|                    {
	|                        if (c == HotKeySpecifier)
	|                        {
	|                            nextIsHot = true;
	|                        }
	|                        else
	|                        {
	|                            if ((nextIsHot && Rune.ToUpper(c) == key) || (key == (uint)hotKey))
	|                            {
	|                                SelectedItem = i;
	|                                cursor = i;
	|                                if (!HasFocus)
	|                                    SetFocus();
	|                                return true;
	|                            }
	|                            nextIsHot = false;
	|                        }
	|                    }
	|                    i++;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            return base.ProcessKey(kb);
	|        }
	|
	|        void SelectItem()
	|        {
	|            SelectedItem = cursor;
	|        }
	|
	|        void MoveEnd()
	|        {
	|            cursor = Math.Max(radioLabels.Count - 1, 0);
	|        }
	|
	|        void MoveHome()
	|        {
	|            cursor = 0;
	|        }
	|
	|        void MoveDown()
	|        {
	|            if (cursor + 1 < radioLabels.Count)
	|            {
	|                cursor++;
	|                SetNeedsDisplay();
	|            }
	|            else if (cursor > 0)
	|            {
	|                cursor = 0;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        void MoveUp()
	|        {
	|            if (cursor > 0)
	|            {
	|                cursor--;
	|                SetNeedsDisplay();
	|            }
	|            else if (radioLabels.Count - 1 > 0)
	|            {
	|                cursor = radioLabels.Count - 1;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked))
	|            {
	|                return false;
	|            }
	|            if (!CanFocus)
	|            {
	|                return false;
	|            }
	|            SetFocus();
	|
	|            var pos = displayMode == DisplayModeLayout.Horizontal ? me.X : me.Y;
	|            var rCount = displayMode == DisplayModeLayout.Horizontal ? horizontal.Last().pos + horizontal.Last().length : radioLabels.Count;
	|
	|            if (pos < rCount)
	|            {
	|                var c = displayMode == DisplayModeLayout.Horizontal ? horizontal.FindIndex((x) => x.pos <= me.X && x.pos + x.length - 2 >= me.X) : me.Y;
	|                if (c > -1)
	|                {
	|                    cursor = SelectedItem = c;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|            return true;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Used for choose the display mode of this <see cref=""RadioGroup""/>
	|    /// </summary>
	|    public enum DisplayModeLayout
	|    {
	|        /// <summary>
	|        /// Vertical mode display. It's the default.
	|        /// </summary>
	|        Vertical,
	|        /// <summary>
	|        /// Horizontal mode display.
	|        /// </summary>
	|        Horizontal
	|    }
	|
	|    /// <summary>
	|    /// Event arguments for the SelectedItemChagned event.
	|    /// </summary>
	|    public class SelectedItemChangedArgs : EventArgs
	|    {
	|        /// <summary>
	|        /// Gets the index of the item that was previously selected. -1 if there was no previous selection.
	|        /// </summary>
	|        public int PreviousSelectedItem { get; }
	|
	|        /// <summary>
	|        /// Gets the index of the item that is now selected. -1 if there is no selection.
	|        /// </summary>
	|        public int SelectedItem { get; }
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""SelectedItemChangedArgs""/> class.
	|        /// </summary>
	|        /// <param name=""selectedItem""></param>
	|        /// <param name=""previousSelectedItem""></param>
	|        public SelectedItemChangedArgs(int selectedItem, int previousSelectedItem)
	|        {
	|            PreviousSelectedItem = previousSelectedItem;
	|            SelectedItem = selectedItem;
	|        }
	|    }
	|    //=======================================================================
	|    static class ReadOnlyCollectionExtensions
	|    {
	|
	|        public static int IndexOf<T>(this IReadOnlyCollection<T> self, Func<T, bool> predicate)
	|        {
	|            int i = 0;
	|            foreach (T element in self)
	|            {
	|                if (predicate(element))
	|                    return i;
	|                i++;
	|            }
	|            return -1;
	|        }
	|        public static int IndexOf<T>(this IReadOnlyCollection<T> self, T toFind)
	|        {
	|            int i = 0;
	|            foreach (T element in self)
	|            {
	|                if (Equals(element, toFind))
	|                    return i;
	|                i++;
	|            }
	|            return -1;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // System.Drawing.Rectangle.cs
	|    //
	|    // Author:
	|    //   Mike Kestner (mkestner@speakeasy.net)
	|    //
	|    // Copyright (C) 2001 Mike Kestner
	|    // Copyright (C) 2004 Novell, Inc.  http://www.novell.com 
	|    //
	|
	|    /// <summary>
	|    /// Stores a set of four integers that represent the location and size of a rectangle
	|    /// </summary>
	|    public struct Rect
	|    {
	|        int width;
	|        int height;
	|
	|        /// <summary>
	|        /// Gets or sets the x-coordinate of the upper-left corner of this Rectangle structure.
	|        /// </summary>
	|        public int X;
	|        /// <summary>
	|        /// Gets or sets the y-coordinate of the upper-left corner of this Rectangle structure.
	|        /// </summary>
	|        public int Y;
	|
	|        /// <summary>
	|        /// Gets or sets the width of this Rect structure.
	|        /// </summary>
	|        public int Width
	|        {
	|            get { return width; }
	|            set
	|            {
	|                if (value < 0)
	|                    throw new ArgumentException(""Width must be greater or equal to 0."");
	|                width = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the height of this Rectangle structure.
	|        /// </summary>
	|        public int Height
	|        {
	|            get { return height; }
	|            set
	|            {
	|                if (value < 0)
	|                    throw new ArgumentException(""Height must be greater or equal to 0."");
	|                height = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Empty Shared Field
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	An uninitialized Rectangle Structure.
	|        /// </remarks>
	|
	|        public static readonly Rect Empty;
	|
	|        /// <summary>
	|        ///	FromLTRB Shared Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Produces a Rectangle structure from left, top, right
	|        ///	and bottom coordinates.
	|        /// </remarks>
	|
	|        public static Rect FromLTRB(int left, int top,
	|                          int right, int bottom)
	|        {
	|            return new Rect(left, top, right - left,
	|                          bottom - top);
	|        }
	|
	|        /// <summary>
	|        ///	Inflate Shared Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Produces a new Rectangle by inflating an existing 
	|        ///	Rectangle by the specified coordinate values.
	|        /// </remarks>
	|
	|        public static Rect Inflate(Rect rect, int x, int y)
	|        {
	|            Rect r = new Rect(rect.Location, rect.Size);
	|            r.Inflate(x, y);
	|            return r;
	|        }
	|
	|        /// <summary>
	|        ///	Inflate Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Inflates the Rectangle by a specified width and height.
	|        /// </remarks>
	|
	|        public void Inflate(int width, int height)
	|        {
	|            Inflate(new Size(width, height));
	|        }
	|
	|        /// <summary>
	|        ///	Inflate Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Inflates the Rectangle by a specified Size.
	|        /// </remarks>
	|
	|        public void Inflate(Size size)
	|        {
	|            X -= size.Width;
	|            Y -= size.Height;
	|            Width += size.Width * 2;
	|            Height += size.Height * 2;
	|        }
	|
	|        /// <summary>
	|        ///	Intersect Shared Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Produces a new Rectangle by intersecting 2 existing 
	|        ///	Rectangles. Returns null if there is no	intersection.
	|        /// </remarks>
	|
	|        public static Rect Intersect(Rect a, Rect b)
	|        {
	|            // MS.NET returns a non-empty rectangle if the two rectangles
	|            // touch each other
	|            if (!a.IntersectsWithInclusive(b))
	|                return Empty;
	|
	|            return Rect.FromLTRB(
	|                Math.Max(a.Left, b.Left),
	|                Math.Max(a.Top, b.Top),
	|                Math.Min(a.Right, b.Right),
	|                Math.Min(a.Bottom, b.Bottom));
	|        }
	|
	|        /// <summary>
	|        ///	Intersect Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Replaces the Rectangle with the intersection of itself
	|        ///	and another Rectangle.
	|        /// </remarks>
	|
	|        public void Intersect(Rect rect)
	|        {
	|            this = Rect.Intersect(this, rect);
	|        }
	|
	|        /// <summary>
	|        ///	Union Shared Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Produces a new Rectangle from the union of 2 existing 
	|        ///	Rectangles.
	|        /// </remarks>
	|
	|        public static Rect Union(Rect a, Rect b)
	|        {
	|            return FromLTRB(Math.Min(a.Left, b.Left),
	|                     Math.Min(a.Top, b.Top),
	|                     Math.Max(a.Right, b.Right),
	|                     Math.Max(a.Bottom, b.Bottom));
	|        }
	|
	|        /// <summary>
	|        ///	Equality Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Compares two Rectangle objects. The return value is
	|        ///	based on the equivalence of the Location and Size 
	|        ///	properties of the two Rectangles.
	|        /// </remarks>
	|
	|        public static bool operator ==(Rect left, Rect right)
	|        {
	|            return ((left.Location == right.Location) &&
	|                (left.Size == right.Size));
	|        }
	|
	|        /// <summary>
	|        ///	Inequality Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Compares two Rectangle objects. The return value is
	|        ///	based on the equivalence of the Location and Size 
	|        ///	properties of the two Rectangles.
	|        /// </remarks>
	|
	|        public static bool operator !=(Rect left, Rect right)
	|        {
	|            return ((left.Location != right.Location) ||
	|                (left.Size != right.Size));
	|        }
	|
	|        // -----------------------
	|        // Public Constructors
	|        // -----------------------
	|
	|        /// <summary>
	|        ///	Rectangle Constructor
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Creates a Rectangle from Point and Size values.
	|        /// </remarks>
	|
	|        public Rect(Point location, Size size)
	|        {
	|            X = location.X;
	|            Y = location.Y;
	|            width = size.Width;
	|            height = size.Height;
	|            Width = width;
	|            Height = height;
	|        }
	|
	|        /// <summary>
	|        ///	Rectangle Constructor
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Creates a Rectangle from a specified x,y location and
	|        ///	width and height values.
	|        /// </remarks>
	|
	|        public Rect(int x, int y, int width, int height)
	|        {
	|            X = x;
	|            Y = y;
	|            this.width = width;
	|            this.height = height;
	|            Width = this.width;
	|            Height = this.height;
	|        }
	|
	|
	|
	|        /// <summary>
	|        ///	Bottom Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The Y coordinate of the bottom edge of the Rectangle.
	|        ///	Read only.
	|        /// </remarks>		
	|        public int Bottom
	|        {
	|            get
	|            {
	|                return Y + Height;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	IsEmpty Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Indicates if the width or height are zero. Read only.
	|        /// </remarks>		
	|        public bool IsEmpty
	|        {
	|            get
	|            {
	|                return ((X == 0) && (Y == 0) && (Width == 0) && (Height == 0));
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Left Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The X coordinate of the left edge of the Rectangle.
	|        ///	Read only.
	|        /// </remarks>
	|
	|        public int Left
	|        {
	|            get
	|            {
	|                return X;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Location Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The Location of the top-left corner of the Rectangle.
	|        /// </remarks>
	|
	|        public Point Location
	|        {
	|            get
	|            {
	|                return new Point(X, Y);
	|            }
	|            set
	|            {
	|                X = value.X;
	|                Y = value.Y;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Right Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The X coordinate of the right edge of the Rectangle.
	|        ///	Read only.
	|        /// </remarks>
	|
	|        public int Right
	|        {
	|            get
	|            {
	|                return X + Width;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Size Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The Size of the Rectangle.
	|        /// </remarks>
	|
	|        public Size Size
	|        {
	|            get
	|            {
	|                return new Size(Width, Height);
	|            }
	|            set
	|            {
	|                Width = value.Width;
	|                Height = value.Height;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Top Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The Y coordinate of the top edge of the Rectangle.
	|        ///	Read only.
	|        /// </remarks>
	|
	|        public int Top
	|        {
	|            get
	|            {
	|                return Y;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Contains Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Checks if an x,y coordinate lies within this Rectangle.
	|        /// </remarks>
	|
	|        public bool Contains(int x, int y)
	|        {
	|            return ((x >= Left) && (x < Right) &&
	|                (y >= Top) && (y < Bottom));
	|        }
	|
	|        /// <summary>
	|        ///	Contains Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Checks if a Point lies within this Rectangle.
	|        /// </remarks>
	|
	|        public bool Contains(Point pt)
	|        {
	|            return Contains(pt.X, pt.Y);
	|        }
	|
	|        /// <summary>
	|        ///	Contains Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Checks if a Rectangle lies entirely within this 
	|        ///	Rectangle.
	|        /// </remarks>
	|
	|        public bool Contains(Rect rect)
	|        {
	|            return (rect == Intersect(this, rect));
	|        }
	|
	|        /// <summary>
	|        ///	Equals Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Checks equivalence of this Rectangle and another object.
	|        /// </remarks>
	|
	|        public override bool Equals(object obj)
	|        {
	|            if (!(obj is Rect))
	|                return false;
	|
	|            return (this == (Rect)obj);
	|        }
	|
	|        /// <summary>
	|        ///	GetHashCode Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Calculates a hashing value.
	|        /// </remarks>
	|
	|        public override int GetHashCode()
	|        {
	|            return (Height + Width) ^ X + Y;
	|        }
	|
	|        /// <summary>
	|        ///	IntersectsWith Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Checks if a Rectangle intersects with this one.
	|        /// </remarks>
	|
	|        public bool IntersectsWith(Rect rect)
	|        {
	|            return !((Left >= rect.Right) || (Right <= rect.Left) ||
	|                (Top >= rect.Bottom) || (Bottom <= rect.Top));
	|        }
	|
	|        bool IntersectsWithInclusive(Rect r)
	|        {
	|            return !((Left > r.Right) || (Right < r.Left) ||
	|                (Top > r.Bottom) || (Bottom < r.Top));
	|        }
	|
	|        /// <summary>
	|        ///	Offset Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Moves the Rectangle a specified distance.
	|        /// </remarks>
	|
	|        public void Offset(int x, int y)
	|        {
	|            this.X += x;
	|            this.Y += y;
	|        }
	|
	|        /// <summary>
	|        ///	Offset Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Moves the Rectangle a specified distance.
	|        /// </remarks>
	|
	|        public void Offset(Point pos)
	|        {
	|            X += pos.X;
	|            Y += pos.Y;
	|        }
	|
	|        /// <summary>
	|        ///	ToString Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Formats the Rectangle as a string in (x,y,w,h) notation.
	|        /// </remarks>
	|
	|        public override string ToString()
	|        {
	|            return String.Format(""{{X={0},Y={1},Width={2},Height={3}}}"",
	|                         X, Y, Width, Height);
	|        }
	|
	|    }
	|    //=======================================================================
	|    // Licensed to the .NET Foundation under one or more agreements.
	|    // The .NET Foundation licenses this file to you under the MIT license.
	|    // See the LICENSE file in the project root for more information.
	|
	|    // Copied from https://github.com/dotnet/corefx/tree/master/src/System.Drawing.Primitives/src/System/Drawing
	|
	|    /// <summary>
	|    /// Stores the location and size of a rectangular region.
	|    /// </summary>
	|    public struct RectangleF : IEquatable<RectangleF>
	|    {
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.RectangleF'/> class.
	|        /// </summary>
	|        public static readonly RectangleF Empty;
	|
	|        private float x; // Do not rename (binary serialization)
	|        private float y; // Do not rename (binary serialization)
	|        private float width; // Do not rename (binary serialization)
	|        private float height; // Do not rename (binary serialization)
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.RectangleF'/> class with the specified location
	|        /// and size.
	|        /// </summary>
	|        public RectangleF(float x, float y, float width, float height)
	|        {
	|            this.x = x;
	|            this.y = y;
	|            this.width = width;
	|            this.height = height;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.RectangleF'/> class with the specified location
	|        /// and size.
	|        /// </summary>
	|        public RectangleF(PointF location, SizeF size)
	|        {
	|            x = location.X;
	|            y = location.Y;
	|            width = size.Width;
	|            height = size.Height;
	|        }
	|
	|        /// <summary>
	|        /// Creates a new <see cref='Terminal.Gui.RectangleF'/> with the specified location and size.
	|        /// </summary>
	|        public static RectangleF FromLTRB(float left, float top, float right, float bottom) =>
	|            new RectangleF(left, top, right - left, bottom - top);
	|
	|        /// <summary>
	|        /// Gets or sets the coordinates of the upper-left corner of the rectangular region represented by this
	|        /// <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        [Browsable(false)]
	|        public PointF Location
	|        {
	|            get => new PointF(X, Y);
	|            set
	|            {
	|                X = value.X;
	|                Y = value.Y;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the size of this <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        [Browsable(false)]
	|        public SizeF Size
	|        {
	|            get => new SizeF(Width, Height);
	|            set
	|            {
	|                Width = value.Width;
	|                Height = value.Height;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the x-coordinate of the upper-left corner of the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        public float X
	|        {
	|            get => x;
	|            set => x = value;
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the y-coordinate of the upper-left corner of the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        public float Y
	|        {
	|            get => y;
	|            set => y = value;
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the width of the rectangular region defined by this <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        public float Width
	|        {
	|            get => width;
	|            set => width = value;
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the height of the rectangular region defined by this <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        public float Height
	|        {
	|            get => height;
	|            set => height = value;
	|        }
	|
	|        /// <summary>
	|        /// Gets the x-coordinate of the upper-left corner of the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.RectangleF'/> .
	|        /// </summary>
	|        [Browsable(false)]
	|        public float Left => X;
	|
	|        /// <summary>
	|        /// Gets the y-coordinate of the upper-left corner of the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        [Browsable(false)]
	|        public float Top => Y;
	|
	|        /// <summary>
	|        /// Gets the x-coordinate of the lower-right corner of the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        [Browsable(false)]
	|        public float Right => X + Width;
	|
	|        /// <summary>
	|        /// Gets the y-coordinate of the lower-right corner of the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        [Browsable(false)]
	|        public float Bottom => Y + Height;
	|
	|        /// <summary>
	|        /// Tests whether this <see cref='Terminal.Gui.RectangleF'/> has a <see cref='Terminal.Gui.RectangleF.Width'/> or a <see cref='Terminal.Gui.RectangleF.Height'/> of 0.
	|        /// </summary>
	|        [Browsable(false)]
	|        public bool IsEmpty => (Width <= 0) || (Height <= 0);
	|
	|        /// <summary>
	|        /// Tests whether <paramref name=""obj""/> is a <see cref='Terminal.Gui.RectangleF'/> with the same location and
	|        /// size of this <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        public override bool Equals(object obj) => obj is RectangleF && Equals((RectangleF)obj);
	|
	|        /// <summary>
	|        /// Returns true if two <see cref='Terminal.Gui.RectangleF'/> objects have equal location and size.
	|        /// </summary>
	|        /// <param name=""other""></param>
	|        /// <returns></returns>
	|        public bool Equals(RectangleF other) => this == other;
	|
	|        /// <summary>
	|        /// Tests whether two <see cref='Terminal.Gui.RectangleF'/> objects have equal location and size.
	|        /// </summary>
	|        public static bool operator ==(RectangleF left, RectangleF right) =>
	|            left.X == right.X && left.Y == right.Y && left.Width == right.Width && left.Height == right.Height;
	|
	|        /// <summary>
	|        /// Tests whether two <see cref='Terminal.Gui.RectangleF'/> objects differ in location or size.
	|        /// </summary>
	|        public static bool operator !=(RectangleF left, RectangleF right) => !(left == right);
	|
	|        /// <summary>
	|        /// Determines if the specified point is contained within the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.Rect'/> .
	|        /// </summary>
	|        public bool Contains(float x, float y) => X <= x && x < X + Width && Y <= y && y < Y + Height;
	|
	|        /// <summary>
	|        /// Determines if the specified point is contained within the rectangular region defined by this
	|        /// <see cref='Terminal.Gui.Rect'/> .
	|        /// </summary>
	|        public bool Contains(PointF pt) => Contains(pt.X, pt.Y);
	|
	|        /// <summary>
	|        /// Determines if the rectangular region represented by <paramref name=""rect""/> is entirely contained within
	|        /// the rectangular region represented by this <see cref='Terminal.Gui.Rect'/> .
	|        /// </summary>
	|        public bool Contains(RectangleF rect) =>
	|            (X <= rect.X) && (rect.X + rect.Width <= X + Width) && (Y <= rect.Y) && (rect.Y + rect.Height <= Y + Height);
	|
	|        /// <summary>
	|        /// Gets the hash code for this <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        public override int GetHashCode()
	|        {
	|            return (Height.GetHashCode() + Width.GetHashCode()) ^ X.GetHashCode() + Y.GetHashCode();
	|        }
	|
	|        /// <summary>
	|        /// Inflates this <see cref='Terminal.Gui.Rect'/> by the specified amount.
	|        /// </summary>
	|        public void Inflate(float x, float y)
	|        {
	|            X -= x;
	|            Y -= y;
	|            Width += 2 * x;
	|            Height += 2 * y;
	|        }
	|
	|        /// <summary>
	|        /// Inflates this <see cref='Terminal.Gui.Rect'/> by the specified amount.
	|        /// </summary>
	|        public void Inflate(SizeF size) => Inflate(size.Width, size.Height);
	|
	|        /// <summary>
	|        /// Creates a <see cref='Terminal.Gui.Rect'/> that is inflated by the specified amount.
	|        /// </summary>
	|        public static RectangleF Inflate(RectangleF rect, float x, float y)
	|        {
	|            RectangleF r = rect;
	|            r.Inflate(x, y);
	|            return r;
	|        }
	|
	|        /// <summary>
	|        /// Creates a Rectangle that represents the intersection between this Rectangle and rect.
	|        /// </summary>
	|        public void Intersect(RectangleF rect)
	|        {
	|            RectangleF result = Intersect(rect, this);
	|
	|            X = result.X;
	|            Y = result.Y;
	|            Width = result.Width;
	|            Height = result.Height;
	|        }
	|
	|        /// <summary>
	|        /// Creates a rectangle that represents the intersection between a and b. If there is no intersection, an
	|        /// empty rectangle is returned.
	|        /// </summary>
	|        public static RectangleF Intersect(RectangleF a, RectangleF b)
	|        {
	|            float x1 = Math.Max(a.X, b.X);
	|            float x2 = Math.Min(a.X + a.Width, b.X + b.Width);
	|            float y1 = Math.Max(a.Y, b.Y);
	|            float y2 = Math.Min(a.Y + a.Height, b.Y + b.Height);
	|
	|            if (x2 >= x1 && y2 >= y1)
	|            {
	|                return new RectangleF(x1, y1, x2 - x1, y2 - y1);
	|            }
	|
	|            return Empty;
	|        }
	|
	|        /// <summary>
	|        /// Determines if this rectangle intersects with rect.
	|        /// </summary>
	|        public bool IntersectsWith(RectangleF rect) =>
	|            (rect.X < X + Width) && (X < rect.X + rect.Width) && (rect.Y < Y + Height) && (Y < rect.Y + rect.Height);
	|
	|        /// <summary>
	|        /// Creates a rectangle that represents the union between a and b.
	|        /// </summary>
	|        public static RectangleF Union(RectangleF a, RectangleF b)
	|        {
	|            float x1 = Math.Min(a.X, b.X);
	|            float x2 = Math.Max(a.X + a.Width, b.X + b.Width);
	|            float y1 = Math.Min(a.Y, b.Y);
	|            float y2 = Math.Max(a.Y + a.Height, b.Y + b.Height);
	|
	|            return new RectangleF(x1, y1, x2 - x1, y2 - y1);
	|        }
	|
	|        /// <summary>
	|        /// Adjusts the location of this rectangle by the specified amount.
	|        /// </summary>
	|        public void Offset(PointF pos) => Offset(pos.X, pos.Y);
	|
	|        /// <summary>
	|        /// Adjusts the location of this rectangle by the specified amount.
	|        /// </summary>
	|        public void Offset(float x, float y)
	|        {
	|            X += x;
	|            Y += y;
	|        }
	|
	|        /// <summary>
	|        /// Converts the specified <see cref='Terminal.Gui.Rect'/> to a
	|        /// <see cref='Terminal.Gui.RectangleF'/>.
	|        /// </summary>
	|        public static implicit operator RectangleF(Rect r) => new RectangleF(r.X, r.Y, r.Width, r.Height);
	|
	|        /// <summary>
	|        /// Converts the <see cref='Terminal.Gui.RectangleF.Location'/> and <see cref='Terminal.Gui.RectangleF.Size'/>
	|        /// of this <see cref='Terminal.Gui.RectangleF'/> to a human-readable string.
	|        /// </summary>
	|        public override string ToString() =>
	|            ""{X="" + X.ToString() + "",Y="" + Y.ToString() +
	|            "",Width="" + Width.ToString() + "",Height="" + Height.ToString() + ""}"";
	|    }
	|    //=======================================================================
	|    //
	|    // Core.cs: The core engine for gui.cs
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|    // Pending:
	|    //   - Check for NeedDisplay on the hierarchy and repaint
	|    //   - Layout support
	|    //   - ""Colors"" type or ""Attributes"" type?
	|    //   - What to surface as ""BackgroundCOlor"" when clearing a window, an attribute or colors?
	|    //
	|    // Optimziations
	|    //   - Add rendering limitation to the exposed area
	|
	|    /// <summary>
	|    /// Responder base class implemented by objects that want to participate on keyboard and mouse input.
	|    /// </summary>
	|    public class Responder : IDisposable
	|    {
	|        bool disposedValue;
	|
	|#if DEBUG_IDISPOSABLE
	|		/// <summary>
	|		/// For debug purposes to verify objects are being disposed properly
	|		/// </summary>
	|		public bool WasDisposed = false;
	|		/// <summary>
	|		/// For debug purposes to verify objects are being disposed properly
	|		/// </summary>
	|		public int DisposedCount = 0;
	|		/// <summary>
	|		/// For debug purposes
	|		/// </summary>
	|		public static List<Responder> Instances = new List<Responder> ();
	|		/// <summary>
	|		/// For debug purposes
	|		/// </summary>
	|		public Responder ()
	|		{
	|			Instances.Add (this);
	|		}
	|#endif
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""Responder""/> can focus.
	|        /// </summary>
	|        /// <value><c>true</c> if can focus; otherwise, <c>false</c>.</value>
	|        public virtual bool CanFocus { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""Responder""/> has focus.
	|        /// </summary>
	|        /// <value><c>true</c> if has focus; otherwise, <c>false</c>.</value>
	|        public virtual bool HasFocus { get; }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""Responder""/> can respond to user interaction.
	|        /// </summary>
	|        public virtual bool Enabled { get; set; } = true;
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""Responder""/> and all its child controls are displayed.
	|        /// </summary>
	|        public virtual bool Visible { get; set; } = true;
	|
	|        // Key handling
	|        /// <summary>
	|        ///   This method can be overwritten by view that
	|        ///     want to provide accelerator functionality
	|        ///     (Alt-key for example).
	|        /// </summary>
	|        /// <remarks>
	|        ///   <para>
	|        ///     Before keys are sent to the subview on the
	|        ///     current view, all the views are
	|        ///     processed and the key is passed to the widgets
	|        ///     to allow some of them to process the keystroke
	|        ///     as a hot-key. </para>
	|        ///  <para>
	|        ///     For example, if you implement a button that
	|        ///     has a hotkey ok ""o"", you would catch the
	|        ///     combination Alt-o here.  If the event is
	|        ///     caught, you must return true to stop the
	|        ///     keystroke from being dispatched to other
	|        ///     views.
	|        ///  </para>
	|        /// </remarks>
	|
	|        public virtual bool ProcessHotKey(KeyEvent kb)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        ///   If the view is focused, gives the view a
	|        ///   chance to process the keystroke.
	|        /// </summary>
	|        /// <remarks>
	|        ///   <para>
	|        ///     Views can override this method if they are
	|        ///     interested in processing the given keystroke.
	|        ///     If they consume the keystroke, they must
	|        ///     return true to stop the keystroke from being
	|        ///     processed by other widgets or consumed by the
	|        ///     widget engine.    If they return false, the
	|        ///     keystroke will be passed using the ProcessColdKey
	|        ///     method to other views to process.
	|        ///   </para>
	|        ///   <para>
	|        ///     The View implementation does nothing but return false,
	|        ///     so it is not necessary to call base.ProcessKey if you
	|        ///     derive directly from View, but you should if you derive
	|        ///     other View subclasses.
	|        ///   </para>
	|        /// </remarks>
	|        /// <param name=""keyEvent"">Contains the details about the key that produced the event.</param>
	|        public virtual bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        ///   This method can be overwritten by views that
	|        ///     want to provide accelerator functionality
	|        ///     (Alt-key for example), but without
	|        ///     interefering with normal ProcessKey behavior.
	|        /// </summary>
	|        /// <remarks>
	|        ///   <para>
	|        ///     After keys are sent to the subviews on the
	|        ///     current view, all the view are
	|        ///     processed and the key is passed to the views
	|        ///     to allow some of them to process the keystroke
	|        ///     as a cold-key. </para>
	|        ///  <para>
	|        ///    This functionality is used, for example, by
	|        ///    default buttons to act on the enter key.
	|        ///    Processing this as a hot-key would prevent
	|        ///    non-default buttons from consuming the enter
	|        ///    keypress when they have the focus.
	|        ///  </para>
	|        /// </remarks>
	|        /// <param name=""keyEvent"">Contains the details about the key that produced the event.</param>
	|        public virtual bool ProcessColdKey(KeyEvent keyEvent)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a key is pressed.
	|        /// </summary>
	|        /// <param name=""keyEvent"">Contains the details about the key that produced the event.</param>
	|        /// <returns>true if the event was handled</returns>
	|        public virtual bool OnKeyDown(KeyEvent keyEvent)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a key is released.
	|        /// </summary>
	|        /// <param name=""keyEvent"">Contains the details about the key that produced the event.</param>
	|        /// <returns>true if the event was handled</returns>
	|        public virtual bool OnKeyUp(KeyEvent keyEvent)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a mouse event is generated
	|        /// </summary>
	|        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
	|        /// <param name=""mouseEvent"">Contains the details about the mouse event.</param>
	|        public virtual bool MouseEvent(MouseEvent mouseEvent)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a mouse event is generated for the first time.
	|        /// </summary>
	|        /// <param name=""mouseEvent""></param>
	|        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
	|        public virtual bool OnMouseEnter(MouseEvent mouseEvent)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a mouse event is generated for the last time.
	|        /// </summary>
	|        /// <param name=""mouseEvent""></param>
	|        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
	|        public virtual bool OnMouseLeave(MouseEvent mouseEvent)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a view gets focus.
	|        /// </summary>
	|        /// <param name=""view"">The view that is losing focus.</param>
	|        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
	|        public virtual bool OnEnter(View view)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a view loses focus.
	|        /// </summary>
	|        /// <param name=""view"">The view that is getting focus.</param>
	|        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
	|        public virtual bool OnLeave(View view)
	|        {
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when the <see cref=""CanFocus""/> property from a view is changed.
	|        /// </summary>
	|        public virtual void OnCanFocusChanged() { }
	|
	|        /// <summary>
	|        /// Method invoked when the <see cref=""Enabled""/> property from a view is changed.
	|        /// </summary>
	|        public virtual void OnEnabledChanged() { }
	|
	|        /// <summary>
	|        /// Method invoked when the <see cref=""Visible""/> property from a view is changed.
	|        /// </summary>
	|        public virtual void OnVisibleChanged() { }
	|
	|        /// <summary>
	|        /// Utilty function to determine <paramref name=""method""/> is overridden in the <paramref name=""subclass""/>.
	|        /// </summary>
	|        /// <param name=""subclass"">The view.</param>
	|        /// <param name=""method"">The method name.</param>
	|        /// <returns><see langword=""true""/> if it's overridden, <see langword=""false""/> otherwise.</returns>
	|        internal static bool IsOverridden(Responder subclass, string method)
	|        {
	|            MethodInfo m = subclass.GetType().GetMethod(method,
	|                BindingFlags.Instance
	|                | BindingFlags.Public
	|                | BindingFlags.NonPublic
	|                | BindingFlags.DeclaredOnly);
	|            if (m == null)
	|            {
	|                return false;
	|            }
	|            return m.GetBaseDefinition().DeclaringType != m.DeclaringType;
	|        }
	|
	|        /// <summary>
	|        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
	|        /// </summary>
	|        /// <remarks>
	|        /// If disposing equals true, the method has been called directly
	|        /// or indirectly by a user's code. Managed and unmanaged resources
	|        /// can be disposed.
	|        /// If disposing equals false, the method has been called by the
	|        /// runtime from inside the finalizer and you should not reference
	|        /// other objects. Only unmanaged resources can be disposed.		
	|        /// </remarks>
	|        /// <param name=""disposing""></param>
	|        protected virtual void Dispose(bool disposing)
	|        {
	|            if (!disposedValue)
	|            {
	|                if (disposing)
	|                {
	|                    // TODO: dispose managed state (managed objects)
	|                }
	|
	|                // TODO: free unmanaged resources (unmanaged objects) and override finalizer
	|                // TODO: set large fields to null
	|                disposedValue = true;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resource.
	|        /// </summary>
	|        public void Dispose()
	|        {
	|            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
	|            Dispose(disposing: true);
	|            GC.SuppressFinalize(this);
	|#if DEBUG_IDISPOSABLE
	|			WasDisposed = true;
	|
	|			foreach (var instance in Instances.Where (x => x.WasDisposed).ToList ()) {
	|				Instances.Remove (instance);
	|			}
	|#endif
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // ScrollBarView.cs: ScrollBarView view.
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    /// ScrollBarViews are views that display a 1-character scrollbar, either horizontal or vertical
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   The scrollbar is drawn to be a representation of the Size, assuming that the 
	|    ///   scroll position is set at Position.
	|    /// </para>
	|    /// <para>
	|    ///   If the region to display the scrollbar is larger than three characters, 
	|    ///   arrow indicators are drawn.
	|    /// </para>
	|    /// </remarks>
	|    public class ScrollBarView : View
	|    {
	|        bool vertical;
	|        int size, position;
	|        bool showScrollIndicator;
	|        bool keepContentAlwaysInViewport = true;
	|        bool autoHideScrollBars = true;
	|        bool hosted;
	|        ScrollBarView otherScrollBarView;
	|        View contentBottomRightCorner;
	|
	|        bool showBothScrollIndicator => OtherScrollBarView != null && OtherScrollBarView.showScrollIndicator && showScrollIndicator;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.ScrollBarView""/> class using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <param name=""rect"">Frame for the scrollbar.</param>
	|        public ScrollBarView(Rect rect) : this(rect, 0, 0, false) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.ScrollBarView""/> class using <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <param name=""rect"">Frame for the scrollbar.</param>
	|        /// <param name=""size"">The size that this scrollbar represents. Sets the <see cref=""Size""/> property.</param>
	|        /// <param name=""position"">The position within this scrollbar. Sets the <see cref=""Position""/> property.</param>
	|        /// <param name=""isVertical"">If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal. Sets the <see cref=""IsVertical""/> property.</param>
	|        public ScrollBarView(Rect rect, int size, int position, bool isVertical) : base(rect)
	|        {
	|            Init(size, position, isVertical);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.ScrollBarView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        public ScrollBarView() : this(0, 0, false) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.ScrollBarView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <param name=""size"">The size that this scrollbar represents.</param>
	|        /// <param name=""position"">The position within this scrollbar.</param>
	|        /// <param name=""isVertical"">If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal.</param>
	|        public ScrollBarView(int size, int position, bool isVertical) : base()
	|        {
	|            Init(size, position, isVertical);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.ScrollBarView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <param name=""host"">The view that will host this scrollbar.</param>
	|        /// <param name=""isVertical"">If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal.</param>
	|        /// <param name=""showBothScrollIndicator"">If set to <c>true (default)</c> will have the other scrollbar, otherwise will have only one.</param>
	|        public ScrollBarView(View host, bool isVertical, bool showBothScrollIndicator = true) : this(0, 0, isVertical)
	|        {
	|            if (host == null)
	|            {
	|                throw new ArgumentNullException(""The host parameter can't be null."");
	|            }
	|            else if (host.SuperView == null)
	|            {
	|                throw new ArgumentNullException(""The host SuperView parameter can't be null."");
	|            }
	|            hosted = true;
	|            ColorScheme = host.ColorScheme;
	|            X = isVertical ? Pos.Right(host) - 1 : Pos.Left(host);
	|            Y = isVertical ? Pos.Top(host) : Pos.Bottom(host) - 1;
	|            Host = host;
	|            CanFocus = false;
	|            Enabled = host.Enabled;
	|            Visible = host.Visible;
	|            //Host.CanFocusChanged += Host_CanFocusChanged;
	|            Host.EnabledChanged += Host_EnabledChanged;
	|            Host.VisibleChanged += Host_VisibleChanged;
	|            Host.SuperView.Add(this);
	|            AutoHideScrollBars = true;
	|            if (showBothScrollIndicator)
	|            {
	|                OtherScrollBarView = new ScrollBarView(0, 0, !isVertical)
	|                {
	|                    ColorScheme = host.ColorScheme,
	|                    Host = host,
	|                    CanFocus = false,
	|                    Enabled = host.Enabled,
	|                    Visible = host.Visible,
	|                    OtherScrollBarView = this
	|                };
	|                OtherScrollBarView.hosted = true;
	|                OtherScrollBarView.X = OtherScrollBarView.IsVertical ? Pos.Right(host) - 1 : Pos.Left(host);
	|                OtherScrollBarView.Y = OtherScrollBarView.IsVertical ? Pos.Top(host) : Pos.Bottom(host) - 1;
	|                OtherScrollBarView.Host.SuperView.Add(OtherScrollBarView);
	|                OtherScrollBarView.ShowScrollIndicator = true;
	|            }
	|            ShowScrollIndicator = true;
	|            contentBottomRightCorner = new View("" "") { Visible = host.Visible, ColorScheme = host.ColorScheme };
	|            Host.SuperView.Add(contentBottomRightCorner);
	|            contentBottomRightCorner.X = Pos.Right(host) - 1;
	|            contentBottomRightCorner.Y = Pos.Bottom(host) - 1;
	|            contentBottomRightCorner.Width = 1;
	|            contentBottomRightCorner.Height = 1;
	|            contentBottomRightCorner.MouseClick += ContentBottomRightCorner_MouseClick;
	|            contentBottomRightCorner.DrawContent += ContentBottomRightCorner_DrawContent;
	|            ClearOnVisibleFalse = false;
	|        }
	|
	|        private void Host_VisibleChanged()
	|        {
	|            if (!Host.Visible)
	|            {
	|                Visible = Host.Visible;
	|                if (otherScrollBarView != null)
	|                {
	|                    otherScrollBarView.Visible = Visible;
	|                }
	|                contentBottomRightCorner.Visible = Visible;
	|            }
	|            else
	|            {
	|                ShowHideScrollBars();
	|            }
	|        }
	|
	|        private void Host_EnabledChanged()
	|        {
	|            Enabled = Host.Enabled;
	|            if (otherScrollBarView != null)
	|            {
	|                otherScrollBarView.Enabled = Enabled;
	|            }
	|            contentBottomRightCorner.Enabled = Enabled;
	|        }
	|
	|        //private void Host_CanFocusChanged ()
	|        //{
	|        //	CanFocus = Host.CanFocus;
	|        //	if (otherScrollBarView != null) {
	|        //		otherScrollBarView.CanFocus = CanFocus;
	|        //	}
	|        //}
	|
	|        void ContentBottomRightCorner_MouseClick(MouseEventArgs me)
	|        {
	|            if (me.MouseEvent.Flags == MouseFlags.WheeledDown || me.MouseEvent.Flags == MouseFlags.WheeledUp
	|                || me.MouseEvent.Flags == MouseFlags.WheeledRight || me.MouseEvent.Flags == MouseFlags.WheeledLeft)
	|            {
	|                me.Handled = true;
	|                MouseEvent(me.MouseEvent);
	|            }
	|            else if (me.MouseEvent.Flags == MouseFlags.Button1Clicked)
	|            {
	|                me.Handled = true;
	|                Host.SetFocus();
	|            }
	|        }
	|
	|        private void ContentBottomRightCorner_DrawContent(Rect obj)
	|        {
	|            Driver.SetAttribute(Host.HasFocus ? GetFocusColor() : GetNormalColor());
	|            Host.SuperView.AddRune(contentBottomRightCorner.Frame.X, contentBottomRightCorner.Frame.Y, ' ');
	|        }
	|
	|        void Init(int size, int position, bool isVertical)
	|        {
	|            vertical = isVertical;
	|            this.position = position;
	|            this.size = size;
	|            WantContinuousButtonPressed = true;
	|        }
	|
	|        /// <summary>
	|        /// If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal.
	|        /// </summary>
	|        public bool IsVertical
	|        {
	|            get => vertical;
	|            set
	|            {
	|                vertical = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The size of content the scrollbar represents.
	|        /// </summary>
	|        /// <value>The size.</value>
	|        /// <remarks>The <see cref=""Size""/> is typically the size of the virtual content. E.g. when a Scrollbar is
	|        /// part of a <see cref=""View""/> the Size is set to the appropriate dimension of <see cref=""Host""/>.</remarks>
	|        public int Size
	|        {
	|            get => size;
	|            set
	|            {
	|                size = value;
	|                SetRelativeLayout(Bounds);
	|                ShowHideScrollBars(false);
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This event is raised when the position on the scrollbar has changed.
	|        /// </summary>
	|        public event Action ChangedPosition;
	|
	|        /// <summary>
	|        /// The position, relative to <see cref=""Size""/>, to set the scrollbar at.
	|        /// </summary>
	|        /// <value>The position.</value>
	|        public int Position
	|        {
	|            get => position;
	|            set
	|            {
	|                if (position != value)
	|                {
	|                    if (CanScroll(value - position, out int max, vertical))
	|                    {
	|                        if (max == value - position)
	|                        {
	|                            position = value;
	|                        }
	|                        else
	|                        {
	|                            position = Math.Max(position + max, 0);
	|                        }
	|                    }
	|                    else if (max < 0)
	|                    {
	|                        position = Math.Max(position + max, 0);
	|                    }
	|                    var s = GetBarsize(vertical);
	|                    OnChangedPosition();
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or sets the view that host this <see cref=""View""/>
	|        /// </summary>
	|        public View Host { get; internal set; }
	|
	|        /// <summary>
	|        /// Represent a vertical or horizontal ScrollBarView other than this.
	|        /// </summary>
	|        public ScrollBarView OtherScrollBarView
	|        {
	|            get => otherScrollBarView;
	|            set
	|            {
	|                if (value != null && (value.IsVertical && vertical || !value.IsVertical && !vertical))
	|                {
	|                    throw new ArgumentException($""There is already a {(vertical ? ""vertical"" : ""horizontal"")} ScrollBarView."");
	|                }
	|                otherScrollBarView = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the visibility for the vertical or horizontal scroll indicator.
	|        /// </summary>
	|        /// <value><c>true</c> if show vertical or horizontal scroll indicator; otherwise, <c>false</c>.</value>
	|        public bool ShowScrollIndicator
	|        {
	|            get => showScrollIndicator;
	|            set
	|            {
	|                if (value == showScrollIndicator)
	|                {
	|                    return;
	|                }
	|
	|                showScrollIndicator = value;
	|                SetNeedsLayout();
	|                if (value)
	|                {
	|                    Visible = true;
	|                }
	|                else
	|                {
	|                    Visible = false;
	|                    Position = 0;
	|                }
	|                SetWidthHeight();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or sets if the view-port is kept always visible in the area of this <see cref=""ScrollBarView""/>
	|        /// </summary>
	|        public bool KeepContentAlwaysInViewport
	|        {
	|            get { return keepContentAlwaysInViewport; }
	|            set
	|            {
	|                if (keepContentAlwaysInViewport != value)
	|                {
	|                    keepContentAlwaysInViewport = value;
	|                    int pos = 0;
	|                    if (value && !vertical && position + Host.Bounds.Width > size)
	|                    {
	|                        pos = size - Host.Bounds.Width + (showBothScrollIndicator ? 1 : 0);
	|                    }
	|                    if (value && vertical && position + Host.Bounds.Height > size)
	|                    {
	|                        pos = size - Host.Bounds.Height + (showBothScrollIndicator ? 1 : 0);
	|                    }
	|                    if (pos != 0)
	|                    {
	|                        Position = pos;
	|                    }
	|                    if (OtherScrollBarView != null && OtherScrollBarView.keepContentAlwaysInViewport != value)
	|                    {
	|                        OtherScrollBarView.KeepContentAlwaysInViewport = value;
	|                    }
	|                    if (pos == 0)
	|                    {
	|                        Refresh();
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// If true the vertical/horizontal scroll bars won't be showed if it's not needed.
	|        /// </summary>
	|        public bool AutoHideScrollBars
	|        {
	|            get => autoHideScrollBars;
	|            set
	|            {
	|                if (autoHideScrollBars != value)
	|                {
	|                    autoHideScrollBars = value;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Virtual method to invoke the <see cref=""ChangedPosition""/> action event.
	|        /// </summary>
	|        public virtual void OnChangedPosition()
	|        {
	|            ChangedPosition?.Invoke();
	|        }
	|
	|        /// <summary>
	|        /// Only used for a hosted view that will update and redraw the scrollbars.
	|        /// </summary>
	|        public virtual void Refresh()
	|        {
	|            ShowHideScrollBars();
	|        }
	|
	|        void ShowHideScrollBars(bool redraw = true)
	|        {
	|            if (!hosted || (hosted && !autoHideScrollBars))
	|            {
	|                if (contentBottomRightCorner != null && contentBottomRightCorner.Visible)
	|                {
	|                    contentBottomRightCorner.Visible = false;
	|                }
	|                else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && otherScrollBarView.contentBottomRightCorner.Visible)
	|                {
	|                    otherScrollBarView.contentBottomRightCorner.Visible = false;
	|                }
	|                return;
	|            }
	|
	|            var pending = CheckBothScrollBars(this);
	|            if (otherScrollBarView != null)
	|            {
	|                CheckBothScrollBars(otherScrollBarView, pending);
	|            }
	|
	|            SetWidthHeight();
	|            SetRelativeLayout(Bounds);
	|            if (otherScrollBarView != null)
	|            {
	|                OtherScrollBarView.SetRelativeLayout(OtherScrollBarView.Bounds);
	|            }
	|
	|            if (showBothScrollIndicator)
	|            {
	|                if (contentBottomRightCorner != null && !contentBottomRightCorner.Visible)
	|                {
	|                    contentBottomRightCorner.Visible = true;
	|                }
	|                else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && !otherScrollBarView.contentBottomRightCorner.Visible)
	|                {
	|                    otherScrollBarView.contentBottomRightCorner.Visible = true;
	|                }
	|            }
	|            else if (!showScrollIndicator)
	|            {
	|                if (contentBottomRightCorner != null && contentBottomRightCorner.Visible)
	|                {
	|                    contentBottomRightCorner.Visible = false;
	|                }
	|                else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && otherScrollBarView.contentBottomRightCorner.Visible)
	|                {
	|                    otherScrollBarView.contentBottomRightCorner.Visible = false;
	|                }
	|                if (Application.MouseGrabView != null && Application.MouseGrabView == this)
	|                {
	|                    Application.UngrabMouse();
	|                }
	|            }
	|            else if (contentBottomRightCorner != null && contentBottomRightCorner.Visible)
	|            {
	|                contentBottomRightCorner.Visible = false;
	|            }
	|            else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && otherScrollBarView.contentBottomRightCorner.Visible)
	|            {
	|                otherScrollBarView.contentBottomRightCorner.Visible = false;
	|            }
	|            if (Host?.Visible == true && showScrollIndicator && !Visible)
	|            {
	|                Visible = true;
	|            }
	|            if (Host?.Visible == true && otherScrollBarView?.showScrollIndicator == true && !otherScrollBarView.Visible)
	|            {
	|                otherScrollBarView.Visible = true;
	|            }
	|
	|            if (!redraw)
	|            {
	|                return;
	|            }
	|
	|            if (showScrollIndicator)
	|            {
	|                Redraw(Bounds);
	|            }
	|            if (otherScrollBarView != null && otherScrollBarView.showScrollIndicator)
	|            {
	|                otherScrollBarView.Redraw(otherScrollBarView.Bounds);
	|            }
	|        }
	|
	|        bool CheckBothScrollBars(ScrollBarView scrollBarView, bool pending = false)
	|        {
	|            int barsize = scrollBarView.vertical ? scrollBarView.Bounds.Height : scrollBarView.Bounds.Width;
	|
	|            if (barsize == 0 || barsize >= scrollBarView.size)
	|            {
	|                if (scrollBarView.showScrollIndicator)
	|                {
	|                    scrollBarView.ShowScrollIndicator = false;
	|                }
	|                if (scrollBarView.Visible)
	|                {
	|                    scrollBarView.Visible = false;
	|                }
	|            }
	|            else if (barsize > 0 && barsize == scrollBarView.size && scrollBarView.OtherScrollBarView != null && pending)
	|            {
	|                if (scrollBarView.showScrollIndicator)
	|                {
	|                    scrollBarView.ShowScrollIndicator = false;
	|                }
	|                if (scrollBarView.Visible)
	|                {
	|                    scrollBarView.Visible = false;
	|                }
	|                if (scrollBarView.OtherScrollBarView != null && scrollBarView.showBothScrollIndicator)
	|                {
	|                    scrollBarView.OtherScrollBarView.ShowScrollIndicator = false;
	|                }
	|                if (scrollBarView.OtherScrollBarView.Visible)
	|                {
	|                    scrollBarView.OtherScrollBarView.Visible = false;
	|                }
	|            }
	|            else if (barsize > 0 && barsize == size && scrollBarView.OtherScrollBarView != null && !pending)
	|            {
	|                pending = true;
	|            }
	|            else
	|            {
	|                if (scrollBarView.OtherScrollBarView != null && pending)
	|                {
	|                    if (!scrollBarView.showBothScrollIndicator)
	|                    {
	|                        scrollBarView.OtherScrollBarView.ShowScrollIndicator = true;
	|                    }
	|                    if (!scrollBarView.OtherScrollBarView.Visible)
	|                    {
	|                        scrollBarView.OtherScrollBarView.Visible = true;
	|                    }
	|                }
	|                if (!scrollBarView.showScrollIndicator)
	|                {
	|                    scrollBarView.ShowScrollIndicator = true;
	|                }
	|                if (!scrollBarView.Visible)
	|                {
	|                    scrollBarView.Visible = true;
	|                }
	|            }
	|
	|            return pending;
	|        }
	|
	|        void SetWidthHeight()
	|        {
	|            if (showBothScrollIndicator)
	|            {
	|                Width = vertical ? 1 : Dim.Width(Host) - 1;
	|                Height = vertical ? Dim.Height(Host) - 1 : 1;
	|
	|                otherScrollBarView.Width = otherScrollBarView.vertical ? 1 : Dim.Width(Host) - 1;
	|                otherScrollBarView.Height = otherScrollBarView.vertical ? Dim.Height(Host) - 1 : 1;
	|            }
	|            else if (showScrollIndicator)
	|            {
	|                Width = vertical ? 1 : Dim.Width(Host) - 0;
	|                Height = vertical ? Dim.Height(Host) - 0 : 1;
	|            }
	|            else if (otherScrollBarView?.showScrollIndicator == true)
	|            {
	|                otherScrollBarView.Width = otherScrollBarView.vertical ? 1 : Dim.Width(Host) - 0;
	|                otherScrollBarView.Height = otherScrollBarView.vertical ? Dim.Height(Host) - 0 : 1;
	|            }
	|        }
	|
	|        int posTopTee;
	|        int posLeftTee;
	|        int posBottomTee;
	|        int posRightTee;
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect region)
	|        {
	|            if (ColorScheme == null || ((!showScrollIndicator || Size == 0) && AutoHideScrollBars && Visible))
	|            {
	|                if ((!showScrollIndicator || Size == 0) && AutoHideScrollBars && Visible)
	|                {
	|                    ShowHideScrollBars(false);
	|                }
	|                return;
	|            }
	|
	|            Driver.SetAttribute(Host.HasFocus ? ColorScheme.Focus : GetNormalColor());
	|
	|            if ((vertical && Bounds.Height == 0) || (!vertical && Bounds.Width == 0))
	|            {
	|                return;
	|            }
	|
	|            if (vertical)
	|            {
	|                if (region.Right < Bounds.Width - 1)
	|                {
	|                    return;
	|                }
	|
	|                var col = Bounds.Width - 1;
	|                var bh = Bounds.Height;
	|                Rune special;
	|
	|                if (bh < 4)
	|                {
	|                    var by1 = position * bh / Size;
	|                    var by2 = (position + bh) * bh / Size;
	|
	|                    Move(col, 0);
	|                    if (Bounds.Height == 1)
	|                    {
	|                        Driver.AddRune(Driver.Diamond);
	|                    }
	|                    else
	|                    {
	|                        Driver.AddRune(Driver.UpArrow);
	|                    }
	|                    if (Bounds.Height == 3)
	|                    {
	|                        Move(col, 1);
	|                        Driver.AddRune(Driver.Diamond);
	|                    }
	|                    if (Bounds.Height > 1)
	|                    {
	|                        Move(col, Bounds.Height - 1);
	|                        Driver.AddRune(Driver.DownArrow);
	|                    }
	|                }
	|                else
	|                {
	|                    bh -= 2;
	|                    var by1 = KeepContentAlwaysInViewport ? position * bh / Size : position * bh / (Size + bh);
	|                    var by2 = KeepContentAlwaysInViewport ? Math.Min(((position + bh) * bh / Size) + 1, bh - 1) : (position + bh) * bh / (Size + bh);
	|                    if (KeepContentAlwaysInViewport && by1 == by2)
	|                    {
	|                        by1 = Math.Max(by1 - 1, 0);
	|                    }
	|
	|                    Move(col, 0);
	|                    Driver.AddRune(Driver.UpArrow);
	|                    Move(col, Bounds.Height - 1);
	|                    Driver.AddRune(Driver.DownArrow);
	|
	|                    bool hasTopTee = false;
	|                    bool hasDiamond = false;
	|                    bool hasBottomTee = false;
	|                    for (int y = 0; y < bh; y++)
	|                    {
	|                        Move(col, y + 1);
	|                        if ((y < by1 || y > by2) && ((position > 0 && !hasTopTee) || (hasTopTee && hasBottomTee)))
	|                        {
	|                            special = Driver.Stipple;
	|                        }
	|                        else
	|                        {
	|                            if (y != by2 && y > 1 && by2 - by1 == 0 && by1 < bh - 1 && hasTopTee && !hasDiamond)
	|                            {
	|                                hasDiamond = true;
	|                                special = Driver.Diamond;
	|                            }
	|                            else
	|                            {
	|                                if (y == by1 && !hasTopTee)
	|                                {
	|                                    hasTopTee = true;
	|                                    posTopTee = y;
	|                                    special = Driver.TopTee;
	|                                }
	|                                else if ((position == 0 && y == bh - 1 || y >= by2 || by2 == 0) && !hasBottomTee)
	|                                {
	|                                    hasBottomTee = true;
	|                                    posBottomTee = y;
	|                                    special = Driver.BottomTee;
	|                                }
	|                                else
	|                                {
	|                                    special = Driver.VLine;
	|                                }
	|                            }
	|                        }
	|                        Driver.AddRune(special);
	|                    }
	|                    if (!hasTopTee)
	|                    {
	|                        Move(col, Bounds.Height - 2);
	|                        Driver.AddRune(Driver.TopTee);
	|                    }
	|                }
	|            }
	|            else
	|            {
	|                if (region.Bottom < Bounds.Height - 1)
	|                {
	|                    return;
	|                }
	|
	|                var row = Bounds.Height - 1;
	|                var bw = Bounds.Width;
	|                Rune special;
	|
	|                if (bw < 4)
	|                {
	|                    var bx1 = position * bw / Size;
	|                    var bx2 = (position + bw) * bw / Size;
	|
	|                    Move(0, row);
	|                    Driver.AddRune(Driver.LeftArrow);
	|                    Driver.AddRune(Driver.RightArrow);
	|                }
	|                else
	|                {
	|                    bw -= 2;
	|                    var bx1 = KeepContentAlwaysInViewport ? position * bw / Size : position * bw / (Size + bw);
	|                    var bx2 = KeepContentAlwaysInViewport ? Math.Min(((position + bw) * bw / Size) + 1, bw - 1) : (position + bw) * bw / (Size + bw);
	|                    if (KeepContentAlwaysInViewport && bx1 == bx2)
	|                    {
	|                        bx1 = Math.Max(bx1 - 1, 0);
	|                    }
	|
	|                    Move(0, row);
	|                    Driver.AddRune(Driver.LeftArrow);
	|
	|                    bool hasLeftTee = false;
	|                    bool hasDiamond = false;
	|                    bool hasRightTee = false;
	|                    for (int x = 0; x < bw; x++)
	|                    {
	|                        if ((x < bx1 || x >= bx2 + 1) && ((position > 0 && !hasLeftTee) || (hasLeftTee && hasRightTee)))
	|                        {
	|                            special = Driver.Stipple;
	|                        }
	|                        else
	|                        {
	|                            if (x != bx2 && x > 1 && bx2 - bx1 == 0 && bx1 < bw - 1 && hasLeftTee && !hasDiamond)
	|                            {
	|                                hasDiamond = true;
	|                                special = Driver.Diamond;
	|                            }
	|                            else
	|                            {
	|                                if (x == bx1 && !hasLeftTee)
	|                                {
	|                                    hasLeftTee = true;
	|                                    posLeftTee = x;
	|                                    special = Driver.LeftTee;
	|                                }
	|                                else if ((position == 0 && x == bw - 1 || x >= bx2 || bx2 == 0) && !hasRightTee)
	|                                {
	|                                    hasRightTee = true;
	|                                    posRightTee = x;
	|                                    special = Driver.RightTee;
	|                                }
	|                                else
	|                                {
	|                                    special = Driver.HLine;
	|                                }
	|                            }
	|                        }
	|                        Driver.AddRune(special);
	|                    }
	|                    if (!hasLeftTee)
	|                    {
	|                        Move(Bounds.Width - 2, row);
	|                        Driver.AddRune(Driver.LeftTee);
	|                    }
	|
	|                    Driver.AddRune(Driver.RightArrow);
	|                }
	|            }
	|        }
	|
	|        int lastLocation = -1;
	|        int posBarOffset;
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent mouseEvent)
	|        {
	|            if (mouseEvent.Flags != MouseFlags.Button1Pressed && mouseEvent.Flags != MouseFlags.Button1DoubleClicked &&
	|                !mouseEvent.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) &&
	|                mouseEvent.Flags != MouseFlags.Button1Released && mouseEvent.Flags != MouseFlags.WheeledDown &&
	|                mouseEvent.Flags != MouseFlags.WheeledUp && mouseEvent.Flags != MouseFlags.WheeledRight &&
	|                mouseEvent.Flags != MouseFlags.WheeledLeft && mouseEvent.Flags != MouseFlags.Button1TripleClicked)
	|            {
	|                return false;
	|            }
	|
	|            if (!Host.CanFocus)
	|            {
	|                return true;
	|            }
	|            if (Host?.HasFocus == false)
	|            {
	|                Host.SetFocus();
	|            }
	|
	|            int location = vertical ? mouseEvent.Y : mouseEvent.X;
	|            int barsize = vertical ? Bounds.Height : Bounds.Width;
	|            int posTopLeftTee = vertical ? posTopTee + 1 : posLeftTee + 1;
	|            int posBottomRightTee = vertical ? posBottomTee + 1 : posRightTee + 1;
	|            barsize -= 2;
	|            var pos = Position;
	|
	|            if (mouseEvent.Flags != MouseFlags.Button1Released
	|                && (Application.MouseGrabView == null || Application.MouseGrabView != this))
	|            {
	|                Application.GrabMouse(this);
	|            }
	|            else if (mouseEvent.Flags == MouseFlags.Button1Released && Application.MouseGrabView != null && Application.MouseGrabView == this)
	|            {
	|                lastLocation = -1;
	|                Application.UngrabMouse();
	|                return true;
	|            }
	|            if (showScrollIndicator && (mouseEvent.Flags == MouseFlags.WheeledDown || mouseEvent.Flags == MouseFlags.WheeledUp ||
	|                mouseEvent.Flags == MouseFlags.WheeledRight || mouseEvent.Flags == MouseFlags.WheeledLeft))
	|            {
	|                return Host.MouseEvent(mouseEvent);
	|            }
	|
	|            if (location == 0)
	|            {
	|                if (pos > 0)
	|                {
	|                    Position = pos - 1;
	|                }
	|            }
	|            else if (location == barsize + 1)
	|            {
	|                if (CanScroll(1, out _, vertical))
	|                {
	|                    Position = pos + 1;
	|                }
	|            }
	|            else if (location > 0 && location < barsize + 1)
	|            {
	|                //var b1 = pos * (Size > 0 ? barsize / Size : 0);
	|                //var b2 = Size > 0
	|                //	? (KeepContentAlwaysInViewport ? Math.Min (((pos + barsize) * barsize / Size) + 1, barsize - 1) : (pos + barsize) * barsize / Size)
	|                //	: 0;
	|                //if (KeepContentAlwaysInViewport && b1 == b2) {
	|                //	b1 = Math.Max (b1 - 1, 0);
	|                //}
	|
	|                if (lastLocation > -1 || (location >= posTopLeftTee && location <= posBottomRightTee
	|                && mouseEvent.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition)))
	|                {
	|                    if (lastLocation == -1)
	|                    {
	|                        lastLocation = location;
	|                        posBarOffset = keepContentAlwaysInViewport ? Math.Max(location - posTopLeftTee, 1) : 0;
	|                        return true;
	|                    }
	|
	|                    if (location > lastLocation)
	|                    {
	|                        if (location - posBarOffset < barsize)
	|                        {
	|                            var np = ((location - posBarOffset) * Size / barsize) + (Size / barsize);
	|                            if (CanScroll(np - pos, out int nv, vertical))
	|                            {
	|                                Position = pos + nv;
	|                            }
	|                        }
	|                        else if (CanScroll(Size - pos, out int nv, vertical))
	|                        {
	|                            Position = Math.Min(pos + nv, Size);
	|                        }
	|                    }
	|                    else if (location < lastLocation)
	|                    {
	|                        if (location - posBarOffset > 0)
	|                        {
	|                            var np = ((location - posBarOffset) * Size / barsize) - (Size / barsize);
	|                            if (CanScroll(np - pos, out int nv, vertical))
	|                            {
	|                                Position = pos + nv;
	|                            }
	|                        }
	|                        else
	|                        {
	|                            Position = 0;
	|                        }
	|                    }
	|                    else if (location - posBarOffset >= barsize && posBottomRightTee - posTopLeftTee >= 3 && CanScroll(Size - pos, out int nv, vertical))
	|                    {
	|                        Position = Math.Min(pos + nv, Size);
	|                    }
	|                    else if (location - posBarOffset >= barsize - 1 && posBottomRightTee - posTopLeftTee <= 3 && CanScroll(Size - pos, out nv, vertical))
	|                    {
	|                        Position = Math.Min(pos + nv, Size);
	|                    }
	|                    else if (location - posBarOffset <= 0 && posBottomRightTee - posTopLeftTee <= 3)
	|                    {
	|                        Position = 0;
	|                    }
	|                }
	|                else if (location > posBottomRightTee)
	|                {
	|                    if (CanScroll(barsize, out int nv, vertical))
	|                    {
	|                        Position = pos + nv;
	|                    }
	|                }
	|                else if (location < posTopLeftTee)
	|                {
	|                    if (CanScroll(-barsize, out int nv, vertical))
	|                    {
	|                        Position = pos + nv;
	|                    }
	|                }
	|                else if (location == 1 && posTopLeftTee <= 3)
	|                {
	|                    Position = 0;
	|                }
	|                else if (location == barsize)
	|                {
	|                    if (CanScroll(Size - pos, out int nv, vertical))
	|                    {
	|                        Position = Math.Min(pos + nv, Size);
	|                    }
	|                }
	|            }
	|
	|            return true;
	|        }
	|
	|        internal bool CanScroll(int n, out int max, bool isVertical = false)
	|        {
	|            if (Host?.Bounds.IsEmpty != false)
	|            {
	|                max = 0;
	|                return false;
	|            }
	|            int s = GetBarsize(isVertical);
	|            var newSize = Math.Max(Math.Min(size - s, position + n), 0);
	|            max = size > s + newSize ? (newSize == 0 ? -position : n) : size - (s + position) - 1;
	|            if (size >= s + newSize && max != 0)
	|            {
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        int GetBarsize(bool isVertical)
	|        {
	|            if (Host?.Bounds.IsEmpty != false)
	|            {
	|                return 0;
	|            }
	|            return isVertical ?
	|                (KeepContentAlwaysInViewport ? Host.Bounds.Height + (showBothScrollIndicator ? -2 : -1) : 0) :
	|                (KeepContentAlwaysInViewport ? Host.Bounds.Width + (showBothScrollIndicator ? -2 : -1) : 0);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // ScrollView.cs: ScrollView view.
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|    //
	|    // TODO:
	|    // - focus in scrollview
	|    // - focus handling in scrollview to auto scroll to focused view
	|    // - Raise events
	|    // - Perhaps allow an option to not display the scrollbar arrow indicators?
	|
	|    /// <summary>
	|    /// Scrollviews are views that present a window into a virtual space where subviews are added.  Similar to the iOS UIScrollView.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///   The subviews that are added to this <see cref=""Gui.ScrollView""/> are offset by the
	|    ///   <see cref=""ContentOffset""/> property.  The view itself is a window into the 
	|    ///   space represented by the <see cref=""ContentSize""/>.
	|    /// </para>
	|    /// <para>
	|    ///   Use the 
	|    /// </para>
	|    /// </remarks>
	|    public class ScrollView : View
	|    {
	|        private class ContentView : View
	|        {
	|            public ContentView(Rect frame) : base(frame)
	|            {
	|                CanFocus = true;
	|            }
	|        }
	|
	|        ContentView contentView;
	|        ScrollBarView vertical, horizontal;
	|
	|        /// <summary>
	|        ///  Initializes a new instance of the <see cref=""Gui.ScrollView""/> class using <see cref=""LayoutStyle.Absolute""/> positioning.
	|        /// </summary>
	|        /// <param name=""frame""></param>
	|        public ScrollView(Rect frame) : base(frame)
	|        {
	|            Initialize(frame);
	|        }
	|
	|
	|        /// <summary>
	|        ///  Initializes a new instance of the <see cref=""Gui.ScrollView""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        public ScrollView() : base()
	|        {
	|            Initialize(Rect.Empty);
	|        }
	|
	|        void Initialize(Rect frame)
	|        {
	|            contentView = new ContentView(frame);
	|            vertical = new ScrollBarView(1, 0, isVertical: true)
	|            {
	|                X = Pos.AnchorEnd(1),
	|                Y = 0,
	|                Width = 1,
	|                Height = Dim.Fill(showHorizontalScrollIndicator ? 1 : 0)
	|            };
	|            vertical.ChangedPosition += delegate
	|            {
	|                ContentOffset = new Point(ContentOffset.X, vertical.Position);
	|            };
	|            vertical.Host = this;
	|            horizontal = new ScrollBarView(1, 0, isVertical: false)
	|            {
	|                X = 0,
	|                Y = Pos.AnchorEnd(1),
	|                Width = Dim.Fill(showVerticalScrollIndicator ? 1 : 0),
	|                Height = 1
	|            };
	|            horizontal.ChangedPosition += delegate
	|            {
	|                ContentOffset = new Point(horizontal.Position, ContentOffset.Y);
	|            };
	|            horizontal.Host = this;
	|            vertical.OtherScrollBarView = horizontal;
	|            horizontal.OtherScrollBarView = vertical;
	|            base.Add(contentView);
	|            CanFocus = true;
	|
	|            MouseEnter += View_MouseEnter;
	|            MouseLeave += View_MouseLeave;
	|            contentView.MouseEnter += View_MouseEnter;
	|            contentView.MouseLeave += View_MouseLeave;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.ScrollUp, () => ScrollUp(1));
	|            AddCommand(Command.ScrollDown, () => ScrollDown(1));
	|            AddCommand(Command.ScrollLeft, () => ScrollLeft(1));
	|            AddCommand(Command.ScrollRight, () => ScrollRight(1));
	|            AddCommand(Command.PageUp, () => ScrollUp(Bounds.Height));
	|            AddCommand(Command.PageDown, () => ScrollDown(Bounds.Height));
	|            AddCommand(Command.PageLeft, () => ScrollLeft(Bounds.Width));
	|            AddCommand(Command.PageRight, () => ScrollRight(Bounds.Width));
	|            AddCommand(Command.TopHome, () => ScrollUp(contentSize.Height));
	|            AddCommand(Command.BottomEnd, () => ScrollDown(contentSize.Height));
	|            AddCommand(Command.LeftHome, () => ScrollLeft(contentSize.Width));
	|            AddCommand(Command.RightEnd, () => ScrollRight(contentSize.Width));
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.CursorUp, Command.ScrollUp);
	|            AddKeyBinding(Key.CursorDown, Command.ScrollDown);
	|            AddKeyBinding(Key.CursorLeft, Command.ScrollLeft);
	|            AddKeyBinding(Key.CursorRight, Command.ScrollRight);
	|
	|            AddKeyBinding(Key.PageUp, Command.PageUp);
	|            AddKeyBinding((Key)'v' | Key.AltMask, Command.PageUp);
	|
	|            AddKeyBinding(Key.PageDown, Command.PageDown);
	|            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);
	|
	|            AddKeyBinding(Key.PageUp | Key.CtrlMask, Command.PageLeft);
	|            AddKeyBinding(Key.PageDown | Key.CtrlMask, Command.PageRight);
	|            AddKeyBinding(Key.Home, Command.TopHome);
	|            AddKeyBinding(Key.End, Command.BottomEnd);
	|            AddKeyBinding(Key.Home | Key.CtrlMask, Command.LeftHome);
	|            AddKeyBinding(Key.End | Key.CtrlMask, Command.RightEnd);
	|        }
	|
	|        Size contentSize;
	|        Point contentOffset;
	|        bool showHorizontalScrollIndicator;
	|        bool showVerticalScrollIndicator;
	|        bool keepContentAlwaysInViewport = true;
	|        bool autoHideScrollBars = true;
	|
	|        /// <summary>
	|        /// Represents the contents of the data shown inside the scrollview
	|        /// </summary>
	|        /// <value>The size of the content.</value>
	|        public Size ContentSize
	|        {
	|            get
	|            {
	|                return contentSize;
	|            }
	|            set
	|            {
	|                if (contentSize != value)
	|                {
	|                    contentSize = value;
	|                    contentView.Frame = new Rect(contentOffset, value);
	|                    vertical.Size = contentSize.Height;
	|                    horizontal.Size = contentSize.Width;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Represents the top left corner coordinate that is displayed by the scrollview
	|        /// </summary>
	|        /// <value>The content offset.</value>
	|        public Point ContentOffset
	|        {
	|            get
	|            {
	|                return contentOffset;
	|            }
	|            set
	|            {
	|                var co = new Point(-Math.Abs(value.X), -Math.Abs(value.Y));
	|                if (contentOffset != co)
	|                {
	|                    contentOffset = co;
	|                    contentView.Frame = new Rect(contentOffset, contentSize);
	|                    var p = Math.Max(0, -contentOffset.Y);
	|                    if (vertical.Position != p)
	|                    {
	|                        vertical.Position = Math.Max(0, -contentOffset.Y);
	|                    }
	|                    p = Math.Max(0, -contentOffset.X);
	|                    if (horizontal.Position != p)
	|                    {
	|                        horizontal.Position = Math.Max(0, -contentOffset.X);
	|                    }
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// If true the vertical/horizontal scroll bars won't be showed if it's not needed.
	|        /// </summary>
	|        public bool AutoHideScrollBars
	|        {
	|            get => autoHideScrollBars;
	|            set
	|            {
	|                if (autoHideScrollBars != value)
	|                {
	|                    autoHideScrollBars = value;
	|                    if (Subviews.Contains(vertical))
	|                    {
	|                        vertical.AutoHideScrollBars = value;
	|                    }
	|                    if (Subviews.Contains(horizontal))
	|                    {
	|                        horizontal.AutoHideScrollBars = value;
	|                    }
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or sets if the view-port is kept always visible in the area of this <see cref=""ScrollView""/>
	|        /// </summary>
	|        public bool KeepContentAlwaysInViewport
	|        {
	|            get { return keepContentAlwaysInViewport; }
	|            set
	|            {
	|                if (keepContentAlwaysInViewport != value)
	|                {
	|                    keepContentAlwaysInViewport = value;
	|                    vertical.OtherScrollBarView.KeepContentAlwaysInViewport = value;
	|                    horizontal.OtherScrollBarView.KeepContentAlwaysInViewport = value;
	|                    Point p = default;
	|                    if (value && -contentOffset.X + Bounds.Width > contentSize.Width)
	|                    {
	|                        p = new Point(contentSize.Width - Bounds.Width + (showVerticalScrollIndicator ? 1 : 0), -contentOffset.Y);
	|                    }
	|                    if (value && -contentOffset.Y + Bounds.Height > contentSize.Height)
	|                    {
	|                        if (p == default)
	|                        {
	|                            p = new Point(-contentOffset.X, contentSize.Height - Bounds.Height + (showHorizontalScrollIndicator ? 1 : 0));
	|                        }
	|                        else
	|                        {
	|                            p.Y = contentSize.Height - Bounds.Height + (showHorizontalScrollIndicator ? 1 : 0);
	|                        }
	|                    }
	|                    if (p != default)
	|                    {
	|                        ContentOffset = p;
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Adds the view to the scrollview.
	|        /// </summary>
	|        /// <param name=""view"">The view to add to the scrollview.</param>
	|        public override void Add(View view)
	|        {
	|            if (!IsOverridden(view, ""MouseEvent""))
	|            {
	|                view.MouseEnter += View_MouseEnter;
	|                view.MouseLeave += View_MouseLeave;
	|            }
	|            contentView.Add(view);
	|            SetNeedsLayout();
	|        }
	|
	|        /// <summary>
	|        /// Removes the view from the scrollview.
	|        /// </summary>
	|        /// <param name=""view"">The view to remove from the scrollview.</param>
	|        public override void Remove(View view)
	|        {
	|            if (view == null)
	|            {
	|                return;
	|            }
	|
	|            SetNeedsDisplay();
	|            var container = view?.SuperView;
	|            if (container == this)
	|            {
	|                base.Remove(view);
	|            }
	|            else
	|            {
	|                container?.Remove(view);
	|            }
	|
	|            if (contentView.InternalSubviews.Count < 1)
	|            {
	|                this.CanFocus = false;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Removes all widgets from this container.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public override void RemoveAll()
	|        {
	|            contentView.RemoveAll();
	|        }
	|
	|        void View_MouseLeave(MouseEventArgs e)
	|        {
	|            if (Application.MouseGrabView != null && Application.MouseGrabView != vertical && Application.MouseGrabView != horizontal)
	|            {
	|                Application.UngrabMouse();
	|            }
	|        }
	|
	|        void View_MouseEnter(MouseEventArgs e)
	|        {
	|            Application.GrabMouse(this);
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the visibility for the horizontal scroll indicator.
	|        /// </summary>
	|        /// <value><c>true</c> if show horizontal scroll indicator; otherwise, <c>false</c>.</value>
	|        public bool ShowHorizontalScrollIndicator
	|        {
	|            get => showHorizontalScrollIndicator;
	|            set
	|            {
	|                if (value == showHorizontalScrollIndicator)
	|                {
	|                    return;
	|                }
	|
	|                showHorizontalScrollIndicator = value;
	|                SetNeedsLayout();
	|                if (value)
	|                {
	|                    base.Add(horizontal);
	|                    horizontal.ShowScrollIndicator = value;
	|                    horizontal.AutoHideScrollBars = autoHideScrollBars;
	|                    horizontal.OtherScrollBarView = vertical;
	|                    horizontal.OtherScrollBarView.ShowScrollIndicator = value;
	|                    horizontal.MouseEnter += View_MouseEnter;
	|                    horizontal.MouseLeave += View_MouseLeave;
	|                }
	|                else
	|                {
	|                    base.Remove(horizontal);
	|                    horizontal.OtherScrollBarView = null;
	|                    horizontal.MouseEnter -= View_MouseEnter;
	|                    horizontal.MouseLeave -= View_MouseLeave;
	|                }
	|                vertical.Height = Dim.Fill(showHorizontalScrollIndicator ? 1 : 0);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the visibility for the vertical scroll indicator.
	|        /// </summary>
	|        /// <value><c>true</c> if show vertical scroll indicator; otherwise, <c>false</c>.</value>
	|        public bool ShowVerticalScrollIndicator
	|        {
	|            get => showVerticalScrollIndicator;
	|            set
	|            {
	|                if (value == showVerticalScrollIndicator)
	|                {
	|                    return;
	|                }
	|
	|                showVerticalScrollIndicator = value;
	|                SetNeedsLayout();
	|                if (value)
	|                {
	|                    base.Add(vertical);
	|                    vertical.ShowScrollIndicator = value;
	|                    vertical.AutoHideScrollBars = autoHideScrollBars;
	|                    vertical.OtherScrollBarView = horizontal;
	|                    vertical.OtherScrollBarView.ShowScrollIndicator = value;
	|                    vertical.MouseEnter += View_MouseEnter;
	|                    vertical.MouseLeave += View_MouseLeave;
	|                }
	|                else
	|                {
	|                    Remove(vertical);
	|                    vertical.OtherScrollBarView = null;
	|                    vertical.MouseEnter -= View_MouseEnter;
	|                    vertical.MouseLeave -= View_MouseLeave;
	|                }
	|                horizontal.Width = Dim.Fill(showVerticalScrollIndicator ? 1 : 0);
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void Redraw(Rect region)
	|        {
	|            Driver.SetAttribute(GetNormalColor());
	|            SetViewsNeedsDisplay();
	|            Clear();
	|
	|            var savedClip = ClipToBounds();
	|            OnDrawContent(new Rect(ContentOffset,
	|                new Size(Math.Max(Bounds.Width - (ShowVerticalScrollIndicator ? 1 : 0), 0),
	|                    Math.Max(Bounds.Height - (ShowHorizontalScrollIndicator ? 1 : 0), 0))));
	|            contentView.Redraw(contentView.Frame);
	|            Driver.Clip = savedClip;
	|
	|            if (autoHideScrollBars)
	|            {
	|                ShowHideScrollBars();
	|            }
	|            else
	|            {
	|                if (ShowVerticalScrollIndicator)
	|                {
	|                    vertical.SetRelativeLayout(Bounds);
	|                    vertical.Redraw(vertical.Bounds);
	|                }
	|
	|                if (ShowHorizontalScrollIndicator)
	|                {
	|                    horizontal.SetRelativeLayout(Bounds);
	|                    horizontal.Redraw(horizontal.Bounds);
	|                }
	|            }
	|
	|            // Fill in the bottom right corner
	|            if (ShowVerticalScrollIndicator && ShowHorizontalScrollIndicator)
	|            {
	|                AddRune(Bounds.Width - 1, Bounds.Height - 1, ' ');
	|            }
	|            Driver.SetAttribute(GetNormalColor());
	|        }
	|
	|        void ShowHideScrollBars()
	|        {
	|            bool v = false, h = false; bool p = false;
	|
	|            if (Bounds.Height == 0 || Bounds.Height > contentSize.Height)
	|            {
	|                if (ShowVerticalScrollIndicator)
	|                {
	|                    ShowVerticalScrollIndicator = false;
	|                }
	|                v = false;
	|            }
	|            else if (Bounds.Height > 0 && Bounds.Height == contentSize.Height)
	|            {
	|                p = true;
	|            }
	|            else
	|            {
	|                if (!ShowVerticalScrollIndicator)
	|                {
	|                    ShowVerticalScrollIndicator = true;
	|                }
	|                v = true;
	|            }
	|            if (Bounds.Width == 0 || Bounds.Width > contentSize.Width)
	|            {
	|                if (ShowHorizontalScrollIndicator)
	|                {
	|                    ShowHorizontalScrollIndicator = false;
	|                }
	|                h = false;
	|            }
	|            else if (Bounds.Width > 0 && Bounds.Width == contentSize.Width && p)
	|            {
	|                if (ShowHorizontalScrollIndicator)
	|                {
	|                    ShowHorizontalScrollIndicator = false;
	|                }
	|                h = false;
	|                if (ShowVerticalScrollIndicator)
	|                {
	|                    ShowVerticalScrollIndicator = false;
	|                }
	|                v = false;
	|            }
	|            else
	|            {
	|                if (p)
	|                {
	|                    if (!ShowVerticalScrollIndicator)
	|                    {
	|                        ShowVerticalScrollIndicator = true;
	|                    }
	|                    v = true;
	|                }
	|                if (!ShowHorizontalScrollIndicator)
	|                {
	|                    ShowHorizontalScrollIndicator = true;
	|                }
	|                h = true;
	|            }
	|            var dim = Dim.Fill(h ? 1 : 0);
	|            if (!vertical.Height.Equals(dim))
	|            {
	|                vertical.Height = dim;
	|            }
	|            dim = Dim.Fill(v ? 1 : 0);
	|            if (!horizontal.Width.Equals(dim))
	|            {
	|                horizontal.Width = dim;
	|            }
	|
	|            if (v)
	|            {
	|                vertical.SetRelativeLayout(Bounds);
	|                vertical.Redraw(vertical.Bounds);
	|            }
	|            if (h)
	|            {
	|                horizontal.SetRelativeLayout(Bounds);
	|                horizontal.Redraw(horizontal.Bounds);
	|            }
	|        }
	|
	|        void SetViewsNeedsDisplay()
	|        {
	|            foreach (View view in contentView.Subviews)
	|            {
	|                view.SetNeedsDisplay();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            if (InternalSubviews.Count == 0)
	|                Move(0, 0);
	|            else
	|                base.PositionCursor();
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view up.
	|        /// </summary>
	|        /// <returns><c>true</c>, if left was scrolled, <c>false</c> otherwise.</returns>
	|        /// <param name=""lines"">Number of lines to scroll.</param>
	|        public bool ScrollUp(int lines)
	|        {
	|            if (contentOffset.Y < 0)
	|            {
	|                ContentOffset = new Point(contentOffset.X, Math.Min(contentOffset.Y + lines, 0));
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view to the left
	|        /// </summary>
	|        /// <returns><c>true</c>, if left was scrolled, <c>false</c> otherwise.</returns>
	|        /// <param name=""cols"">Number of columns to scroll by.</param>
	|        public bool ScrollLeft(int cols)
	|        {
	|            if (contentOffset.X < 0)
	|            {
	|                ContentOffset = new Point(Math.Min(contentOffset.X + cols, 0), contentOffset.Y);
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view down.
	|        /// </summary>
	|        /// <returns><c>true</c>, if left was scrolled, <c>false</c> otherwise.</returns>
	|        /// <param name=""lines"">Number of lines to scroll.</param>
	|        public bool ScrollDown(int lines)
	|        {
	|            if (vertical.CanScroll(lines, out _, true))
	|            {
	|                ContentOffset = new Point(contentOffset.X, contentOffset.Y - lines);
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view to the right.
	|        /// </summary>
	|        /// <returns><c>true</c>, if right was scrolled, <c>false</c> otherwise.</returns>
	|        /// <param name=""cols"">Number of columns to scroll by.</param>
	|        public bool ScrollRight(int cols)
	|        {
	|            if (horizontal.CanScroll(cols, out _))
	|            {
	|                ContentOffset = new Point(contentOffset.X - cols, contentOffset.Y);
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            if (base.ProcessKey(kb))
	|                return true;
	|
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (me.Flags != MouseFlags.WheeledDown && me.Flags != MouseFlags.WheeledUp &&
	|                me.Flags != MouseFlags.WheeledRight && me.Flags != MouseFlags.WheeledLeft &&
	|                //				me.Flags != MouseFlags.Button1Pressed && me.Flags != MouseFlags.Button1Clicked &&
	|                !me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition))
	|            {
	|                return false;
	|            }
	|
	|            if (me.Flags == MouseFlags.WheeledDown && ShowVerticalScrollIndicator)
	|            {
	|                ScrollDown(1);
	|            }
	|            else if (me.Flags == MouseFlags.WheeledUp && ShowVerticalScrollIndicator)
	|            {
	|                ScrollUp(1);
	|            }
	|            else if (me.Flags == MouseFlags.WheeledRight && showHorizontalScrollIndicator)
	|            {
	|                ScrollRight(1);
	|            }
	|            else if (me.Flags == MouseFlags.WheeledLeft && ShowVerticalScrollIndicator)
	|            {
	|                ScrollLeft(1);
	|            }
	|            else if (me.X == vertical.Frame.X && ShowVerticalScrollIndicator)
	|            {
	|                vertical.MouseEvent(me);
	|            }
	|            else if (me.Y == horizontal.Frame.Y && ShowHorizontalScrollIndicator)
	|            {
	|                horizontal.MouseEvent(me);
	|            }
	|            else if (IsOverridden(me.View, ""MouseEvent""))
	|            {
	|                Application.UngrabMouse();
	|            }
	|            return true;
	|        }
	|
	|        ///<inheritdoc/>
	|        protected override void Dispose(bool disposing)
	|        {
	|            if (!showVerticalScrollIndicator)
	|            {
	|                // It was not added to SuperView, so it won't get disposed automatically
	|                vertical?.Dispose();
	|            }
	|            if (!showHorizontalScrollIndicator)
	|            {
	|                // It was not added to SuperView, so it won't get disposed automatically
	|                horizontal?.Dispose();
	|            }
	|            base.Dispose(disposing);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            if (Subviews.Count == 0 || !Subviews.Any(subview => subview.CanFocus))
	|            {
	|                Application.Driver?.SetCursorVisibility(CursorVisibility.Invisible);
	|            }
	|
	|            return base.OnEnter(view);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Represents a helper to manipulate shortcut keys used on views.
	|    /// </summary>
	|    public class ShortcutHelper
	|    {
	|        private Key shortcut;
	|
	|        /// <summary>
	|        /// This is the global setting that can be used as a global shortcut to invoke the action on the view.
	|        /// </summary>
	|        public virtual Key Shortcut
	|        {
	|            get => shortcut;
	|            set
	|            {
	|                if (shortcut != value && (PostShortcutValidation(value) || value == Key.Null))
	|                {
	|                    shortcut = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The keystroke combination used in the <see cref=""Shortcut""/> as string.
	|        /// </summary>
	|        public virtual ustring ShortcutTag => GetShortcutTag(shortcut);
	|
	|        /// <summary>
	|        /// The action to run if the <see cref=""Shortcut""/> is defined.
	|        /// </summary>
	|        public virtual Action ShortcutAction { get; set; }
	|
	|        /// <summary>
	|        /// Gets the key with all the keys modifiers, especially the shift key that sometimes have to be injected later.
	|        /// </summary>
	|        /// <param name=""kb"">The <see cref=""KeyEvent""/> to check.</param>
	|        /// <returns>The <see cref=""KeyEvent.Key""/> with all the keys modifiers.</returns>
	|        public static Key GetModifiersKey(KeyEvent kb)
	|        {
	|            var key = kb.Key;
	|            if (kb.IsAlt && (key & Key.AltMask) == 0)
	|            {
	|                key |= Key.AltMask;
	|            }
	|            if (kb.IsCtrl && (key & Key.CtrlMask) == 0)
	|            {
	|                key |= Key.CtrlMask;
	|            }
	|            if (kb.IsShift && (key & Key.ShiftMask) == 0)
	|            {
	|                key |= Key.ShiftMask;
	|            }
	|
	|            return key;
	|        }
	|
	|        /// <summary>
	|        /// Get the <see cref=""Shortcut""/> key as string.
	|        /// </summary>
	|        /// <param name=""shortcut"">The shortcut key.</param>
	|        /// <param name=""delimiter"">The delimiter string.</param>
	|        /// <returns></returns>
	|        public static ustring GetShortcutTag(Key shortcut, ustring delimiter = null)
	|        {
	|            if (shortcut == Key.Null)
	|            {
	|                return """";
	|            }
	|
	|            var k = shortcut;
	|            if (delimiter == null)
	|            {
	|                delimiter = MenuBar.ShortcutDelimiter;
	|            }
	|            ustring tag = ustring.Empty;
	|            var sCut = GetKeyToString(k, out Key knm).ToString();
	|            if (knm == Key.Unknown)
	|            {
	|                k &= ~Key.Unknown;
	|                sCut = GetKeyToString(k, out _).ToString();
	|            }
	|            if ((k & Key.CtrlMask) != 0)
	|            {
	|                tag = ""Ctrl"";
	|            }
	|            if ((k & Key.ShiftMask) != 0)
	|            {
	|                if (!tag.IsEmpty)
	|                {
	|                    tag += delimiter;
	|                }
	|                tag += ""Shift"";
	|            }
	|            if ((k & Key.AltMask) != 0)
	|            {
	|                if (!tag.IsEmpty)
	|                {
	|                    tag += delimiter;
	|                }
	|                tag += ""Alt"";
	|            }
	|
	|            ustring[] keys = ustring.Make(sCut).Split("","");
	|            for (int i = 0; i < keys.Length; i++)
	|            {
	|                var key = keys[i].TrimSpace();
	|                if (key == Key.AltMask.ToString() || key == Key.ShiftMask.ToString() || key == Key.CtrlMask.ToString())
	|                {
	|                    continue;
	|                }
	|                if (!tag.IsEmpty)
	|                {
	|                    tag += delimiter;
	|                }
	|                if (!key.Contains(""F"") && key.Length > 2 && keys.Length == 1)
	|                {
	|                    k = (uint)Key.AltMask + k;
	|                    tag += ((char)k).ToString();
	|                }
	|                else if (key.Length == 2 && key.StartsWith(""D""))
	|                {
	|                    tag += ((char)key.ElementAt(1)).ToString();
	|                }
	|                else
	|                {
	|                    tag += key;
	|                }
	|            }
	|
	|            return tag;
	|        }
	|
	|        /// <summary>
	|        /// Return key as string.
	|        /// </summary>
	|        /// <param name=""key"">The key to extract.</param>
	|        /// <param name=""knm"">Correspond to the non modifier key.</param>
	|        public static ustring GetKeyToString(Key key, out Key knm)
	|        {
	|            if (key == Key.Null)
	|            {
	|                knm = Key.Null;
	|                return """";
	|            }
	|
	|            knm = key;
	|            var mK = key & (Key.AltMask | Key.CtrlMask | Key.ShiftMask);
	|            knm &= ~mK;
	|            for (uint i = (uint)Key.F1; i < (uint)Key.F12; i++)
	|            {
	|                if (knm == (Key)i)
	|                {
	|                    mK |= (Key)i;
	|                }
	|            }
	|            knm &= ~mK;
	|            uint.TryParse(knm.ToString(), out uint c);
	|            var s = mK == Key.Null ? """" : mK.ToString();
	|            if (s != """" && (knm != Key.Null || c > 0))
	|            {
	|                s += "","";
	|            }
	|            s += c == 0 ? knm == Key.Null ? """" : knm.ToString() : ((char)c).ToString();
	|            return s;
	|        }
	|
	|        /// <summary>
	|        /// Allows to retrieve a <see cref=""Key""/> from a <see cref=""ShortcutTag""/>
	|        /// </summary>
	|        /// <param name=""tag"">The key as string.</param>
	|        /// <param name=""delimiter"">The delimiter string.</param>
	|        public static Key GetShortcutFromTag(ustring tag, ustring delimiter = null)
	|        {
	|            var sCut = tag;
	|            if (sCut.IsEmpty)
	|            {
	|                return default;
	|            }
	|
	|            Key key = Key.Null;
	|            //var hasCtrl = false;
	|            if (delimiter == null)
	|            {
	|                delimiter = MenuBar.ShortcutDelimiter;
	|            }
	|
	|            ustring[] keys = sCut.Split(delimiter);
	|            for (int i = 0; i < keys.Length; i++)
	|            {
	|                var k = keys[i];
	|                if (k == ""Ctrl"")
	|                {
	|                    //hasCtrl = true;
	|                    key |= Key.CtrlMask;
	|                }
	|                else if (k == ""Shift"")
	|                {
	|                    key |= Key.ShiftMask;
	|                }
	|                else if (k == ""Alt"")
	|                {
	|                    key |= Key.AltMask;
	|                }
	|                else if (k.StartsWith(""F"") && k.Length > 1)
	|                {
	|                    int.TryParse(k.Substring(1).ToString(), out int n);
	|                    for (uint j = (uint)Key.F1; j <= (uint)Key.F12; j++)
	|                    {
	|                        int.TryParse(((Key)j).ToString().Substring(1), out int f);
	|                        if (f == n)
	|                        {
	|                            key |= (Key)j;
	|                        }
	|                    }
	|                }
	|                else
	|                {
	|                    key |= (Key)Enum.Parse(typeof(Key), k.ToString());
	|                }
	|            }
	|
	|            return key;
	|        }
	|
	|        /// <summary>
	|        /// Lookup for a <see cref=""Key""/> on range of keys.
	|        /// </summary>
	|        /// <param name=""key"">The source key.</param>
	|        /// <param name=""first"">First key in range.</param>
	|        /// <param name=""last"">Last key in range.</param>
	|        public static bool CheckKeysFlagRange(Key key, Key first, Key last)
	|        {
	|            for (uint i = (uint)first; i < (uint)last; i++)
	|            {
	|                if ((key | (Key)i) == key)
	|                {
	|                    return true;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Used at key down or key press validation.
	|        /// </summary>
	|        /// <param name=""key"">The key to validate.</param>
	|        /// <returns><c>true</c> if is valid.<c>false</c>otherwise.</returns>
	|        public static bool PreShortcutValidation(Key key)
	|        {
	|            if ((key & (Key.CtrlMask | Key.ShiftMask | Key.AltMask)) == 0 && !CheckKeysFlagRange(key, Key.F1, Key.F12))
	|            {
	|                return false;
	|            }
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Used at key up validation.
	|        /// </summary>
	|        /// <param name=""key"">The key to validate.</param>
	|        /// <returns><c>true</c> if is valid.<c>false</c>otherwise.</returns>
	|        public static bool PostShortcutValidation(Key key)
	|        {
	|            GetKeyToString(key, out Key knm);
	|
	|            if (CheckKeysFlagRange(key, Key.F1, Key.F12) ||
	|                ((key & (Key.CtrlMask | Key.ShiftMask | Key.AltMask)) != 0 && knm != Key.Null && knm != Key.Unknown))
	|            {
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Allows a view to run a <see cref=""View.ShortcutAction""/> if defined.
	|        /// </summary>
	|        /// <param name=""kb"">The <see cref=""KeyEvent""/></param>
	|        /// <param name=""view"">The <see cref=""View""/></param>
	|        /// <returns><c>true</c> if defined <c>false</c>otherwise.</returns>
	|        public static bool FindAndOpenByShortcut(KeyEvent kb, View view = null)
	|        {
	|            if (view == null)
	|            {
	|                return false;
	|            }
	|
	|            var key = kb.KeyValue;
	|            var keys = GetModifiersKey(kb);
	|            key |= (int)keys;
	|            foreach (var v in view.Subviews)
	|            {
	|                if (v.Shortcut != Key.Null && v.Shortcut == (Key)key)
	|                {
	|                    var action = v.ShortcutAction;
	|                    if (action != null)
	|                    {
	|                        Application.MainLoop.AddIdle(() =>
	|                        {
	|                            action();
	|                            return false;
	|                        });
	|                    }
	|                    return true;
	|                }
	|                if (FindAndOpenByShortcut(kb, v))
	|                {
	|                    return true;
	|                }
	|            }
	|
	|            return false;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // System.Drawing.Size.cs
	|    //
	|    // Author:
	|    //   Mike Kestner (mkestner@speakeasy.net)
	|    //
	|    // Copyright (C) 2001 Mike Kestner
	|    // Copyright (C) 2004 Novell, Inc. http://www.novell.com
	|    //
	|
	|    /// <summary>
	|    /// Stores an ordered pair of integers, which specify a Height and Width.
	|    /// </summary>
	|    public struct Size
	|    {
	|        int width, height;
	|
	|        /// <summary>
	|        /// Gets a Size structure that has a Height and Width value of 0.
	|        /// </summary>
	|        public static readonly Size Empty;
	|
	|        /// <summary>
	|        ///	Addition Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Addition of two Size structures.
	|        /// </remarks>
	|
	|        public static Size operator +(Size sz1, Size sz2)
	|        {
	|            return new Size(sz1.Width + sz2.Width,
	|                     sz1.Height + sz2.Height);
	|        }
	|
	|        /// <summary>
	|        ///	Equality Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Compares two Size objects. The return value is
	|        ///	based on the equivalence of the Width and Height 
	|        ///	properties of the two Sizes.
	|        /// </remarks>
	|
	|        public static bool operator ==(Size sz1, Size sz2)
	|        {
	|            return ((sz1.Width == sz2.Width) &&
	|                (sz1.Height == sz2.Height));
	|        }
	|
	|        /// <summary>
	|        ///	Inequality Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Compares two Size objects. The return value is
	|        ///	based on the equivalence of the Width and Height 
	|        ///	properties of the two Sizes.
	|        /// </remarks>
	|
	|        public static bool operator !=(Size sz1, Size sz2)
	|        {
	|            return ((sz1.Width != sz2.Width) ||
	|                (sz1.Height != sz2.Height));
	|        }
	|
	|        /// <summary>
	|        ///	Subtraction Operator
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Subtracts two Size structures.
	|        /// </remarks>
	|
	|        public static Size operator -(Size sz1, Size sz2)
	|        {
	|            return new Size(sz1.Width - sz2.Width,
	|                     sz1.Height - sz2.Height);
	|        }
	|
	|        /// <summary>
	|        ///	Size to Point Conversion
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Returns a Point based on the dimensions of a given 
	|        ///	Size. Requires explicit cast.
	|        /// </remarks>
	|
	|        public static explicit operator Point(Size size)
	|        {
	|            return new Point(size.Width, size.Height);
	|        }
	|
	|        /// <summary>
	|        ///	Size Constructor
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Creates a Size from a Point value.
	|        /// </remarks>
	|
	|        public Size(Point pt)
	|        {
	|            width = pt.X;
	|            height = pt.Y;
	|        }
	|
	|        /// <summary>
	|        ///	Size Constructor
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Creates a Size from specified dimensions.
	|        /// </remarks>
	|
	|        public Size(int width, int height)
	|        {
	|            if (width < 0 || height < 0)
	|                throw new ArgumentException(""Either Width and Height must be greater or equal to 0."");
	|
	|            this.width = width;
	|            this.height = height;
	|        }
	|
	|        /// <summary>
	|        ///	IsEmpty Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Indicates if both Width and Height are zero.
	|        /// </remarks>
	|
	|        public bool IsEmpty
	|        {
	|            get
	|            {
	|                return ((width == 0) && (height == 0));
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Width Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The Width coordinate of the Size.
	|        /// </remarks>
	|
	|        public int Width
	|        {
	|            get
	|            {
	|                return width;
	|            }
	|            set
	|            {
	|                if (value < 0)
	|                    throw new ArgumentException(""Width must be greater or equal to 0."");
	|                width = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Height Property
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	The Height coordinate of the Size.
	|        /// </remarks>
	|
	|        public int Height
	|        {
	|            get
	|            {
	|                return height;
	|            }
	|            set
	|            {
	|                if (value < 0)
	|                    throw new ArgumentException(""Height must be greater or equal to 0."");
	|                height = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///	Equals Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Checks equivalence of this Size and another object.
	|        /// </remarks>
	|
	|        public override bool Equals(object obj)
	|        {
	|            if (!(obj is Size))
	|                return false;
	|
	|            return (this == (Size)obj);
	|        }
	|
	|        /// <summary>
	|        ///	GetHashCode Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Calculates a hashing value.
	|        /// </remarks>
	|
	|        public override int GetHashCode()
	|        {
	|            return width ^ height;
	|        }
	|
	|        /// <summary>
	|        ///	ToString Method
	|        /// </summary>
	|        ///
	|        /// <remarks>
	|        ///	Formats the Size as a string in coordinate notation.
	|        /// </remarks>
	|
	|        public override string ToString()
	|        {
	|            return String.Format(""{{Width={0}, Height={1}}}"", width, height);
	|        }
	|
	|        /// <summary>
	|        /// Adds the width and height of one Size structure to the width and height of another Size structure.
	|        /// </summary>
	|        /// <returns>The add.</returns>
	|        /// <param name=""sz1"">The first Size structure to add.</param>
	|        /// <param name=""sz2"">The second Size structure to add.</param>
	|        public static Size Add(Size sz1, Size sz2)
	|        {
	|            return new Size(sz1.Width + sz2.Width,
	|                     sz1.Height + sz2.Height);
	|
	|        }
	|
	|        /// <summary>
	|        /// Subtracts the width and height of one Size structure to the width and height of another Size structure.
	|        /// </summary>
	|        /// <returns>The subtract.</returns>
	|        /// <param name=""sz1"">The first Size structure to subtract.</param>
	|        /// <param name=""sz2"">The second Size structure to subtract.</param>
	|        public static Size Subtract(Size sz1, Size sz2)
	|        {
	|            return new Size(sz1.Width - sz2.Width,
	|                     sz1.Height - sz2.Height);
	|        }
	|
	|    }
	|    //=======================================================================
	|    // Licensed to the .NET Foundation under one or more agreements.
	|    // The .NET Foundation licenses this file to you under the MIT license.
	|    // See the LICENSE file in the project root for more information.
	|
	|    // Copied from: https://github.com/dotnet/corefx/tree/master/src/System.Drawing.Primitives/src/System/Drawing
	|
	|    /// <summary>
	|    /// Represents the size of a rectangular region with an ordered pair of width and height.
	|    /// </summary>
	|    public struct SizeF : IEquatable<SizeF>
	|    {
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class.
	|        /// </summary>
	|        public static readonly SizeF Empty;
	|        private float width; // Do not rename (binary serialization)
	|        private float height; // Do not rename (binary serialization)
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class from the specified
	|        /// existing <see cref='Terminal.Gui.SizeF'/>.
	|        /// </summary>
	|        public SizeF(SizeF size)
	|        {
	|            width = size.width;
	|            height = size.height;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class from the specified
	|        /// <see cref='Terminal.Gui.PointF'/>.
	|        /// </summary>
	|        public SizeF(PointF pt)
	|        {
	|            width = pt.X;
	|            height = pt.Y;
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class from the specified dimensions.
	|        /// </summary>
	|        public SizeF(float width, float height)
	|        {
	|            this.width = width;
	|            this.height = height;
	|        }
	|
	|        /// <summary>
	|        /// Performs vector addition of two <see cref='Terminal.Gui.SizeF'/> objects.
	|        /// </summary>
	|        public static SizeF operator +(SizeF sz1, SizeF sz2) => Add(sz1, sz2);
	|
	|        /// <summary>
	|        /// Contracts a <see cref='Terminal.Gui.SizeF'/> by another <see cref='Terminal.Gui.SizeF'/>
	|        /// </summary>
	|        public static SizeF operator -(SizeF sz1, SizeF sz2) => Subtract(sz1, sz2);
	|
	|        /// <summary>
	|        /// Multiplies <see cref=""SizeF""/> by a <see cref=""float""/> producing <see cref=""SizeF""/>.
	|        /// </summary>
	|        /// <param name=""left"">Multiplier of type <see cref=""float""/>.</param>
	|        /// <param name=""right"">Multiplicand of type <see cref=""SizeF""/>.</param>
	|        /// <returns>Product of type <see cref=""SizeF""/>.</returns>
	|        public static SizeF operator *(float left, SizeF right) => Multiply(right, left);
	|
	|        /// <summary>
	|        /// Multiplies <see cref=""SizeF""/> by a <see cref=""float""/> producing <see cref=""SizeF""/>.
	|        /// </summary>
	|        /// <param name=""left"">Multiplicand of type <see cref=""SizeF""/>.</param>
	|        /// <param name=""right"">Multiplier of type <see cref=""float""/>.</param>
	|        /// <returns>Product of type <see cref=""SizeF""/>.</returns>
	|        public static SizeF operator *(SizeF left, float right) => Multiply(left, right);
	|
	|        /// <summary>
	|        /// Divides <see cref=""SizeF""/> by a <see cref=""float""/> producing <see cref=""SizeF""/>.
	|        /// </summary>
	|        /// <param name=""left"">Dividend of type <see cref=""SizeF""/>.</param>
	|        /// <param name=""right"">Divisor of type <see cref=""int""/>.</param>
	|        /// <returns>Result of type <see cref=""SizeF""/>.</returns>
	|        public static SizeF operator /(SizeF left, float right)
	|            => new SizeF(left.width / right, left.height / right);
	|
	|        /// <summary>
	|        /// Tests whether two <see cref='Terminal.Gui.SizeF'/> objects are identical.
	|        /// </summary>
	|        public static bool operator ==(SizeF sz1, SizeF sz2) => sz1.Width == sz2.Width && sz1.Height == sz2.Height;
	|
	|        /// <summary>
	|        /// Tests whether two <see cref='Terminal.Gui.SizeF'/> objects are different.
	|        /// </summary>
	|        public static bool operator !=(SizeF sz1, SizeF sz2) => !(sz1 == sz2);
	|
	|        /// <summary>
	|        /// Converts the specified <see cref='Terminal.Gui.SizeF'/> to a <see cref='Terminal.Gui.PointF'/>.
	|        /// </summary>
	|        public static explicit operator PointF(SizeF size) => new PointF(size.Width, size.Height);
	|
	|        /// <summary>
	|        /// Tests whether this <see cref='Terminal.Gui.SizeF'/> has zero width and height.
	|        /// </summary>
	|        [Browsable(false)]
	|        public bool IsEmpty => width == 0 && height == 0;
	|
	|        /// <summary>
	|        /// Represents the horizontal component of this <see cref='Terminal.Gui.SizeF'/>.
	|        /// </summary>
	|        public float Width
	|        {
	|            get => width;
	|            set => width = value;
	|        }
	|
	|        /// <summary>
	|        /// Represents the vertical component of this <see cref='Terminal.Gui.SizeF'/>.
	|        /// </summary>
	|        public float Height
	|        {
	|            get => height;
	|            set => height = value;
	|        }
	|
	|        /// <summary>
	|        /// Performs vector addition of two <see cref='Terminal.Gui.SizeF'/> objects.
	|        /// </summary>
	|        public static SizeF Add(SizeF sz1, SizeF sz2) => new SizeF(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
	|
	|        /// <summary>
	|        /// Contracts a <see cref='Terminal.Gui.SizeF'/> by another <see cref='Terminal.Gui.SizeF'/>.
	|        /// </summary>
	|        public static SizeF Subtract(SizeF sz1, SizeF sz2) => new SizeF(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
	|
	|        /// <summary>
	|        /// Tests to see whether the specified object is a <see cref='Terminal.Gui.SizeF'/>  with the same dimensions
	|        /// as this <see cref='Terminal.Gui.SizeF'/>.
	|        /// </summary>
	|        public override bool Equals(object obj) => obj is SizeF && Equals((SizeF)obj);
	|
	|
	|        /// <summary>
	|        /// Tests whether two <see cref='Terminal.Gui.SizeF'/> objects are identical.
	|        /// </summary>
	|        public bool Equals(SizeF other) => this == other;
	|
	|        /// <summary>
	|        /// Generates a hashcode from the width and height
	|        /// </summary>
	|        /// <returns></returns>
	|        public override int GetHashCode()
	|        {
	|            return width.GetHashCode() ^ height.GetHashCode();
	|        }
	|
	|        /// <summary>
	|        /// Creates a human-readable string that represents this <see cref='Terminal.Gui.SizeF'/>.
	|        /// </summary>
	|        public override string ToString() => ""{Width="" + width.ToString() + "", Height="" + height.ToString() + ""}"";
	|
	|        /// <summary>
	|        /// Multiplies <see cref=""SizeF""/> by a <see cref=""float""/> producing <see cref=""SizeF""/>.
	|        /// </summary>
	|        /// <param name=""size"">Multiplicand of type <see cref=""SizeF""/>.</param>
	|        /// <param name=""multiplier"">Multiplier of type <see cref=""float""/>.</param>
	|        /// <returns>Product of type SizeF.</returns>
	|        private static SizeF Multiply(SizeF size, float multiplier) =>
	|            new SizeF(size.width * multiplier, size.height * multiplier);
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Extension of <see cref=""Stack{T}""/> helper to work with specific <see cref=""IEqualityComparer{T}""/>
	|    /// </summary>
	|    public static class StackExtensions
	|    {
	|        /// <summary>
	|        /// Replaces an stack object values that match with the value to replace.
	|        /// </summary>
	|        /// <typeparam name=""T"">The stack object type.</typeparam>
	|        /// <param name=""stack"">The stack object.</param>
	|        /// <param name=""valueToReplace"">Value to replace.</param>
	|        /// <param name=""valueToReplaceWith"">Value to replace with to what matches the value to replace.</param>
	|        /// <param name=""comparer"">The comparison object.</param>
	|        public static void Replace<T>(this Stack<T> stack, T valueToReplace,
	|            T valueToReplaceWith, IEqualityComparer<T> comparer = null)
	|        {
	|            comparer = comparer ?? EqualityComparer<T>.Default;
	|
	|            var temp = new Stack<T>();
	|            while (stack.Count > 0)
	|            {
	|                var value = stack.Pop();
	|                if (comparer.Equals(value, valueToReplace))
	|                {
	|                    stack.Push(valueToReplaceWith);
	|                    break;
	|                }
	|                temp.Push(value);
	|            }
	|
	|            while (temp.Count > 0)
	|                stack.Push(temp.Pop());
	|        }
	|
	|        /// <summary>
	|        /// Swap two stack objects values that matches with the both values.
	|        /// </summary>
	|        /// <typeparam name=""T"">The stack object type.</typeparam>
	|        /// <param name=""stack"">The stack object.</param>
	|        /// <param name=""valueToSwapFrom"">Value to swap from.</param>
	|        /// <param name=""valueToSwapTo"">Value to swap to.</param>
	|        /// <param name=""comparer"">The comparison object.</param>
	|        public static void Swap<T>(this Stack<T> stack, T valueToSwapFrom,
	|            T valueToSwapTo, IEqualityComparer<T> comparer = null)
	|        {
	|            comparer = comparer ?? EqualityComparer<T>.Default;
	|
	|            int index = stack.Count - 1;
	|            T[] stackArr = new T[stack.Count];
	|            while (stack.Count > 0)
	|            {
	|                var value = stack.Pop();
	|                if (comparer.Equals(value, valueToSwapFrom))
	|                {
	|                    stackArr[index] = valueToSwapTo;
	|                }
	|                else if (comparer.Equals(value, valueToSwapTo))
	|                {
	|                    stackArr[index] = valueToSwapFrom;
	|                }
	|                else
	|                {
	|                    stackArr[index] = value;
	|                }
	|                index--;
	|            }
	|
	|            for (int i = 0; i < stackArr.Length; i++)
	|                stack.Push(stackArr[i]);
	|        }
	|
	|        /// <summary>
	|        /// Move the first stack object value to the end.
	|        /// </summary>
	|        /// <typeparam name=""T"">The stack object type.</typeparam>
	|        /// <param name=""stack"">The stack object.</param>
	|        public static void MoveNext<T>(this Stack<T> stack)
	|        {
	|            var temp = new Stack<T>();
	|            var last = stack.Pop();
	|            while (stack.Count > 0)
	|            {
	|                var value = stack.Pop();
	|                temp.Push(value);
	|            }
	|            temp.Push(last);
	|
	|            while (temp.Count > 0)
	|                stack.Push(temp.Pop());
	|        }
	|
	|        /// <summary>
	|        /// Move the last stack object value to the top.
	|        /// </summary>
	|        /// <typeparam name=""T"">The stack object type.</typeparam>
	|        /// <param name=""stack"">The stack object.</param>
	|        public static void MovePrevious<T>(this Stack<T> stack)
	|        {
	|            var temp = new Stack<T>();
	|            T first = default;
	|            while (stack.Count > 0)
	|            {
	|                var value = stack.Pop();
	|                temp.Push(value);
	|                if (stack.Count == 1)
	|                {
	|                    first = stack.Pop();
	|                }
	|            }
	|
	|            while (temp.Count > 0)
	|                stack.Push(temp.Pop());
	|            stack.Push(first);
	|        }
	|
	|        /// <summary>
	|        /// Find all duplicates stack objects values.
	|        /// </summary>
	|        /// <typeparam name=""T"">The stack object type.</typeparam>
	|        /// <param name=""stack"">The stack object.</param>
	|        /// <param name=""comparer"">The comparison object.</param>
	|        /// <returns>The duplicates stack object.</returns>
	|        public static Stack<T> FindDuplicates<T>(this Stack<T> stack, IEqualityComparer<T> comparer = null)
	|        {
	|            comparer = comparer ?? EqualityComparer<T>.Default;
	|
	|            var dup = new Stack<T>();
	|            T[] stackArr = stack.ToArray();
	|            for (int i = 0; i < stackArr.Length; i++)
	|            {
	|                var value = stackArr[i];
	|                for (int j = i + 1; j < stackArr.Length; j++)
	|                {
	|                    var valueToFind = stackArr[j];
	|                    if (comparer.Equals(value, valueToFind) && !Contains(dup, valueToFind))
	|                    {
	|                        dup.Push(value);
	|                    }
	|                }
	|            }
	|
	|            return dup;
	|        }
	|
	|        /// <summary>
	|        /// Check if the stack object contains the value to find.
	|        /// </summary>
	|        /// <typeparam name=""T"">The stack object type.</typeparam>
	|        /// <param name=""stack"">The stack object.</param>
	|        /// <param name=""valueToFind"">Value to find.</param>
	|        /// <param name=""comparer"">The comparison object.</param>
	|        /// <returns><c>true</c> If the value was found.<c>false</c> otherwise.</returns>
	|        public static bool Contains<T>(this Stack<T> stack, T valueToFind, IEqualityComparer<T> comparer = null)
	|        {
	|            comparer = comparer ?? EqualityComparer<T>.Default;
	|
	|            foreach (T obj in stack)
	|            {
	|                if (comparer.Equals(obj, valueToFind))
	|                {
	|                    return true;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Move the stack object value to the index.
	|        /// </summary>
	|        /// <typeparam name=""T"">The stack object type.</typeparam>
	|        /// <param name=""stack"">The stack object.</param>
	|        /// <param name=""valueToMove"">Value to move.</param>
	|        /// <param name=""index"">The index where to move.</param>
	|        /// <param name=""comparer"">The comparison object.</param>
	|        public static void MoveTo<T>(this Stack<T> stack, T valueToMove, int index = 0,
	|            IEqualityComparer<T> comparer = null)
	|        {
	|            if (index < 0)
	|            {
	|                return;
	|            }
	|
	|            comparer = comparer ?? EqualityComparer<T>.Default;
	|
	|            var temp = new Stack<T>();
	|            var toMove = default(T);
	|            var stackCount = stack.Count;
	|            var count = 0;
	|            while (stack.Count > 0)
	|            {
	|                var value = stack.Pop();
	|                if (comparer.Equals(value, valueToMove))
	|                {
	|                    toMove = value;
	|                    break;
	|                }
	|                temp.Push(value);
	|                count++;
	|            }
	|
	|            int idx = 0;
	|            while (stack.Count < stackCount)
	|            {
	|                if (count - idx == index)
	|                {
	|                    stack.Push(toMove);
	|                }
	|                else
	|                {
	|                    stack.Push(temp.Pop());
	|                }
	|                idx++;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // StatusBar.cs: a statusbar for an application
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|    // TODO:
	|    //   Add mouse support
	|
	|    /// <summary>
	|    /// <see cref=""StatusItem""/> objects are contained by <see cref=""StatusBar""/> <see cref=""View""/>s. 
	|    /// Each <see cref=""StatusItem""/> has a title, a shortcut (hotkey), and an <see cref=""Action""/> that will be invoked when the 
	|    /// <see cref=""StatusItem.Shortcut""/> is pressed.
	|    /// The <see cref=""StatusItem.Shortcut""/> will be a global hotkey for the application in the current context of the screen.
	|    /// The colour of the <see cref=""StatusItem.Title""/> will be changed after each ~ (can be customized using <see cref=""HotTextSpecifier""/>).
	|    /// A <see cref=""StatusItem.Title""/> set to `~F1~ Help` will render as *F1* using <see cref=""ColorScheme.HotNormal""/> and
	|    /// *Help* as <see cref=""ColorScheme.Normal""/>.
	|    /// </summary>
	|    public class StatusItem
	|    {
	|        //*master//
	|        public ScriptEngine.Machine.IValue Tag { get; set; }
	|        //master*//
	|
	|        /// <summary>
	|        /// Initializes a new <see cref=""StatusItem""/>.
	|        /// </summary>
	|        /// <param name=""shortcut"">Shortcut to activate the <see cref=""StatusItem""/>.</param>
	|        /// <param name=""title"">Title for the <see cref=""StatusItem""/>.</param>
	|        /// <param name=""action"">Action to invoke when the <see cref=""StatusItem""/> is activated.</param>
	|        /// <param name=""canExecute"">Function to determine if the action can currently be executed.</param>
	|        public StatusItem(Key shortcut, ustring title, Action action, Func<bool> canExecute = null)
	|        {
	|            Title = title ?? """";
	|            Shortcut = shortcut;
	|            Action = action;
	|            CanExecute = canExecute;
	|        }
	|
	|        /// <summary>
	|        /// Gets the global shortcut to invoke the action on the menu.
	|        /// </summary>
	|        public Key Shortcut { get; }
	|
	|        /// <summary>
	|        /// Gets or sets the title.
	|        /// </summary>
	|        /// <value>The title.</value>
	|        /// <remarks>
	|        /// The colour of the <see cref=""StatusItem.Title""/> will be changed after each ~. 
	|        /// A <see cref=""StatusItem.Title""/> set to `~F1~ Help` will render as *F1* using <see cref=""ColorScheme.HotNormal""/> and
	|        /// *Help* as <see cref=""ColorScheme.HotNormal""/>.
	|        /// </remarks>
	|        public ustring Title { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the action to be invoked when the statusbar item is triggered
	|        /// </summary>
	|        /// <value>Action to invoke.</value>
	|        public Action Action { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the action to be invoked to determine if the <see cref=""StatusItem""/> can be triggered. 
	|        /// If <see cref=""CanExecute""/> returns <see langword=""true""/> the status item will be enabled. Otherwise, it will be disabled.
	|        /// </summary>
	|        /// <value>Function to determine if the action is can be executed or not.</value>
	|        public Func<bool> CanExecute { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the rune that toggles the text color between <see cref=""ColorScheme.Normal""/> and <see cref=""ColorScheme.HotNormal""/>.
	|        /// The default value is '~'.
	|        /// Therefore, '~F1~ Help' will be rendered as 'F1' using <see cref=""ColorScheme.HotNormal""/> and 'Help' using <see cref=""ColorScheme.Normal""/>.
	|        /// In order to use '~' as part of the title (e.g., to denote the home directory as a part of the current directory),
	|        /// <see cref=""HotTextSpecifier""/> should be changed to a different rune.
	|        /// </summary>
	|        public Rune HotTextSpecifier { get; set; } = '~';
	|
	|        /// <summary>
	|        /// Returns <see langword=""true""/> if the status item is enabled. This method is a wrapper around <see cref=""CanExecute""/>.
	|        /// </summary>
	|        public bool IsEnabled()
	|        {
	|            return CanExecute == null ? true : CanExecute();
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets arbitrary data for the status item.
	|        /// </summary>
	|        /// <remarks>This property is not used internally.</remarks>
	|        public object Data { get; set; }
	|    };
	|
	|    /// <summary>
	|    /// A status bar is a <see cref=""View""/> that snaps to the bottom of a <see cref=""Toplevel""/> displaying set of <see cref=""StatusItem""/>s.
	|    /// The <see cref=""StatusBar""/> should be context sensitive. This means, if the main menu and an open text editor are visible, the items probably shown will
	|    /// be ~F1~ Help ~F2~ Save ~F3~ Load. While a dialog to ask a file to load is executed, the remaining commands will probably be ~F1~ Help.
	|    /// So for each context must be a new instance of a statusbar.
	|    /// </summary>
	|    public class StatusBar : View
	|    {
	|        /// <summary>
	|        /// The items that compose the <see cref=""StatusBar""/>
	|        /// </summary>
	|        public StatusItem[] Items { get; set; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""StatusBar""/> class.
	|        /// </summary>
	|        public StatusBar() : this(items: new StatusItem[] { }) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""StatusBar""/> class with the specified set of <see cref=""StatusItem""/>s.
	|        /// The <see cref=""StatusBar""/> will be drawn on the lowest line of the terminal or <see cref=""View.SuperView""/> (if not null).
	|        /// </summary>
	|        /// <param name=""items"">A list of statusbar items.</param>
	|        public StatusBar(StatusItem[] items) : base()
	|        {
	|            Items = items;
	|            CanFocus = false;
	|            ColorScheme = Colors.Menu;
	|            X = 0;
	|            Y = Pos.AnchorEnd(1);
	|            Width = Dim.Fill();
	|            Height = 1;
	|        }
	|
	|        static ustring shortcutDelimiter = ""-"";
	|        /// <summary>
	|        /// Used for change the shortcut delimiter separator.
	|        /// </summary>
	|        public static ustring ShortcutDelimiter
	|        {
	|            get => shortcutDelimiter;
	|            set
	|            {
	|                if (shortcutDelimiter != value)
	|                {
	|                    shortcutDelimiter = value == ustring.Empty ? "" "" : value;
	|                }
	|            }
	|        }
	|
	|        Attribute ToggleScheme(Attribute scheme)
	|        {
	|            var result = scheme == ColorScheme.Normal ? ColorScheme.HotNormal : ColorScheme.Normal;
	|            Driver.SetAttribute(result);
	|            return result;
	|        }
	|
	|        Attribute DetermineColorSchemeFor(StatusItem item)
	|        {
	|            if (item != null)
	|            {
	|                if (item.IsEnabled())
	|                {
	|                    return GetNormalColor();
	|                }
	|                return ColorScheme.Disabled;
	|            }
	|            return GetNormalColor();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            Move(0, 0);
	|            Driver.SetAttribute(GetNormalColor());
	|            for (int i = 0; i < Frame.Width; i++)
	|                Driver.AddRune(' ');
	|
	|            Move(1, 0);
	|            var scheme = GetNormalColor();
	|            Driver.SetAttribute(scheme);
	|            for (int i = 0; i < Items.Length; i++)
	|            {
	|                var title = Items[i].Title.ToString();
	|                var hotTextSpecifier = Items[i].HotTextSpecifier;
	|                Driver.SetAttribute(DetermineColorSchemeFor(Items[i]));
	|                for (int n = 0; n < Items[i].Title.RuneCount; n++)
	|                {
	|                    if (title[n] == hotTextSpecifier)
	|                    {
	|                        if (Items[i].IsEnabled())
	|                        {
	|                            scheme = ToggleScheme(scheme);
	|                        }
	|                        continue;
	|                    }
	|                    Driver.AddRune(title[n]);
	|                }
	|                if (i + 1 < Items.Length)
	|                {
	|                    Driver.AddRune(' ');
	|                    Driver.AddRune(Driver.VLine);
	|                    Driver.AddRune(' ');
	|                }
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessHotKey(KeyEvent kb)
	|        {
	|            foreach (var item in Items)
	|            {
	|                if (kb.Key == item.Shortcut)
	|                {
	|                    if (item.IsEnabled())
	|                    {
	|                        Run(item.Action);
	|                    }
	|                    return true;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (me.Flags != MouseFlags.Button1Clicked)
	|                return false;
	|
	|            int pos = 1;
	|            for (int i = 0; i < Items.Length; i++)
	|            {
	|                if (me.X >= pos && me.X < pos + GetItemTitleLength(Items[i]))
	|                {
	|                    var item = Items[i];
	|                    if (item.IsEnabled())
	|                    {
	|                        Run(item.Action);
	|                    }
	|                    break;
	|                }
	|                pos += GetItemTitleLength(Items[i]) + 3;
	|            }
	|            return true;
	|        }
	|
	|        int GetItemTitleLength(StatusItem item)
	|        {
	|            int len = 0;
	|            foreach (var ch in item.Title)
	|            {
	|                if (ch == item.HotTextSpecifier)
	|                    continue;
	|                len++;
	|            }
	|
	|            return len;
	|        }
	|
	|        void Run(Action action)
	|        {
	|            if (action == null)
	|                return;
	|
	|            Application.MainLoop.AddIdle(() =>
	|            {
	|                action();
	|                return false;
	|            });
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        /// <summary>
	|        /// Inserts a <see cref=""StatusItem""/> in the specified index of <see cref=""Items""/>.
	|        /// </summary>
	|        /// <param name=""index"">The zero-based index at which item should be inserted.</param>
	|        /// <param name=""item"">The item to insert.</param>
	|        public void AddItemAt(int index, StatusItem item)
	|        {
	|            var itemsList = new List<StatusItem>(Items);
	|            itemsList.Insert(index, item);
	|            Items = itemsList.ToArray();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Removes a <see cref=""StatusItem""/> at specified index of <see cref=""Items""/>.
	|        /// </summary>
	|        /// <param name=""index"">The zero-based index of the item to remove.</param>
	|        /// <returns>The <see cref=""StatusItem""/> removed.</returns>
	|        public StatusItem RemoveItem(int index)
	|        {
	|            var itemsList = new List<StatusItem>(Items);
	|            var item = itemsList[index];
	|            itemsList.RemoveAt(index);
	|            Items = itemsList.ToArray();
	|            SetNeedsDisplay();
	|
	|            return item;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// View for tabular data based on a <see cref=""DataTable""/>.
	|    /// 
	|    /// <a href=""https://gui-cs.github.io/Terminal.Gui/articles/tableview.html"">See TableView Deep Dive for more information</a>.
	|    /// </summary>
	|    public class TableView : View
	|    {
	|
	|        /// <summary>
	|        ///  Defines the event arguments for <see cref=""TableView.CellActivated""/> event
	|        /// </summary>
	|        public class CellActivatedEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// The current table to which the new indexes refer.  May be null e.g. if selection change is the result of clearing the table from the view
	|            /// </summary>
	|            /// <value></value>
	|            public DataTable Table { get; }
	|
	|
	|            /// <summary>
	|            /// The column index of the <see cref=""Table""/> cell that is being activated
	|            /// </summary>
	|            /// <value></value>
	|            public int Col { get; }
	|
	|            /// <summary>
	|            /// The row index of the <see cref=""Table""/> cell that is being activated
	|            /// </summary>
	|            /// <value></value>
	|            public int Row { get; }
	|
	|            /// <summary>
	|            /// Creates a new instance of arguments describing a cell being activated in <see cref=""TableView""/>
	|            /// </summary>
	|            /// <param name=""t""></param>
	|            /// <param name=""col""></param>
	|            /// <param name=""row""></param>
	|            public CellActivatedEventArgs(DataTable t, int col, int row)
	|            {
	|                Table = t;
	|                Col = col;
	|                Row = row;
	|            }
	|        }
	|
	|        private int columnOffset;
	|        private int rowOffset;
	|        private int selectedRow;
	|        private int selectedColumn;
	|        private DataTable table;
	|        private TableStyle style = new TableStyle();
	|        private Key cellActivationKey = Key.Enter;
	|
	|        Point? scrollLeftPoint;
	|        Point? scrollRightPoint;
	|
	|        /// <summary>
	|        /// The default maximum cell width for <see cref=""TableView.MaxCellWidth""/> and <see cref=""ColumnStyle.MaxWidth""/>
	|        /// </summary>
	|        public const int DefaultMaxCellWidth = 100;
	|
	|
	|        /// <summary>
	|        /// The default minimum cell width for <see cref=""ColumnStyle.MinAcceptableWidth""/>
	|        /// </summary>
	|        public const int DefaultMinAcceptableWidth = 100;
	|
	|        /// <summary>
	|        /// The data table to render in the view.  Setting this property automatically updates and redraws the control.
	|        /// </summary>
	|        public DataTable Table { get => table; set { table = value; Update(); } }
	|
	|        /// <summary>
	|        /// Contains options for changing how the table is rendered
	|        /// </summary>
	|        public TableStyle Style { get => style; set { style = value; Update(); } }
	|
	|        /// <summary>
	|        /// True to select the entire row at once.  False to select individual cells.  Defaults to false
	|        /// </summary>
	|        public bool FullRowSelect { get; set; }
	|
	|        /// <summary>
	|        /// True to allow regions to be selected 
	|        /// </summary>
	|        /// <value></value>
	|        public bool MultiSelect { get; set; } = true;
	|
	|        /// <summary>
	|        /// When <see cref=""MultiSelect""/> is enabled this property contain all rectangles of selected cells.  Rectangles describe column/rows selected in <see cref=""Table""/> (not screen coordinates)
	|        /// </summary>
	|        /// <returns></returns>
	|        public Stack<TableSelection> MultiSelectedRegions { get; } = new Stack<TableSelection>();
	|
	|        /// <summary>
	|        /// Horizontal scroll offset.  The index of the first column in <see cref=""Table""/> to display when when rendering the view.
	|        /// </summary>
	|        /// <remarks>This property allows very wide tables to be rendered with horizontal scrolling</remarks>
	|        public int ColumnOffset
	|        {
	|            get => columnOffset;
	|
	|            //try to prevent this being set to an out of bounds column
	|            set => columnOffset = TableIsNullOrInvisible() ? 0 : Math.Max(0, Math.Min(Table.Columns.Count - 1, value));
	|        }
	|
	|        /// <summary>
	|        /// Vertical scroll offset.  The index of the first row in <see cref=""Table""/> to display in the first non header line of the control when rendering the view.
	|        /// </summary>
	|        public int RowOffset
	|        {
	|            get => rowOffset;
	|            set => rowOffset = TableIsNullOrInvisible() ? 0 : Math.Max(0, Math.Min(Table.Rows.Count - 1, value));
	|        }
	|
	|        /// <summary>
	|        /// The index of <see cref=""DataTable.Columns""/> in <see cref=""Table""/> that the user has currently selected
	|        /// </summary>
	|        public int SelectedColumn
	|        {
	|            get => selectedColumn;
	|
	|            set
	|            {
	|                var oldValue = selectedColumn;
	|
	|                //try to prevent this being set to an out of bounds column
	|                selectedColumn = TableIsNullOrInvisible() ? 0 : Math.Min(Table.Columns.Count - 1, Math.Max(0, value));
	|
	|                if (oldValue != selectedColumn)
	|                    OnSelectedCellChanged(new SelectedCellChangedEventArgs(Table, oldValue, SelectedColumn, SelectedRow, SelectedRow));
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The index of <see cref=""DataTable.Rows""/> in <see cref=""Table""/> that the user has currently selected
	|        /// </summary>
	|        public int SelectedRow
	|        {
	|            get => selectedRow;
	|            set
	|            {
	|
	|                var oldValue = selectedRow;
	|
	|                selectedRow = TableIsNullOrInvisible() ? 0 : Math.Min(Table.Rows.Count - 1, Math.Max(0, value));
	|
	|                if (oldValue != selectedRow)
	|                    OnSelectedCellChanged(new SelectedCellChangedEventArgs(Table, SelectedColumn, SelectedColumn, oldValue, selectedRow));
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The maximum number of characters to render in any given column.  This prevents one long column from pushing out all the others
	|        /// </summary>
	|        public int MaxCellWidth { get; set; } = DefaultMaxCellWidth;
	|
	|        /// <summary>
	|        /// The text representation that should be rendered for cells with the value <see cref=""DBNull.Value""/>
	|        /// </summary>
	|        public string NullSymbol { get; set; } = ""-"";
	|
	|        /// <summary>
	|        /// The symbol to add after each cell value and header value to visually seperate values (if not using vertical gridlines)
	|        /// </summary>
	|        public char SeparatorSymbol { get; set; } = ' ';
	|
	|        /// <summary>
	|        /// This event is raised when the selected cell in the table changes.
	|        /// </summary>
	|        public event Action<SelectedCellChangedEventArgs> SelectedCellChanged;
	|
	|        /// <summary>
	|        /// This event is raised when a cell is activated e.g. by double clicking or pressing <see cref=""CellActivationKey""/>
	|        /// </summary>
	|        public event Action<CellActivatedEventArgs> CellActivated;
	|
	|        /// <summary>
	|        /// The key which when pressed should trigger <see cref=""CellActivated""/> event.  Defaults to Enter.
	|        /// </summary>
	|        public Key CellActivationKey
	|        {
	|            get => cellActivationKey;
	|            set
	|            {
	|                if (cellActivationKey != value)
	|                {
	|                    ReplaceKeyBinding(cellActivationKey, value);
	|
	|                    // of API user is mixing and matching old and new methods of keybinding then they may have lost
	|                    // the old binding (e.g. with ClearKeybindings) so ReplaceKeyBinding alone will fail
	|                    AddKeyBinding(value, Command.Accept);
	|                    cellActivationKey = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Initialzies a <see cref=""TableView""/> class using <see cref=""LayoutStyle.Computed""/> layout. 
	|        /// </summary>
	|        /// <param name=""table"">The table to display in the control</param>
	|        public TableView(DataTable table) : this()
	|        {
	|            this.Table = table;
	|        }
	|
	|        /// <summary>
	|        /// Initialzies a <see cref=""TableView""/> class using <see cref=""LayoutStyle.Computed""/> layout. Set the <see cref=""Table""/> property to begin editing
	|        /// </summary>
	|        public TableView() : base()
	|        {
	|            CanFocus = true;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.Right, () => { ChangeSelectionByOffset(1, 0, false); return true; });
	|            AddCommand(Command.Left, () => { ChangeSelectionByOffset(-1, 0, false); return true; });
	|            AddCommand(Command.LineUp, () => { ChangeSelectionByOffset(0, -1, false); return true; });
	|            AddCommand(Command.LineDown, () => { ChangeSelectionByOffset(0, 1, false); return true; });
	|            AddCommand(Command.PageUp, () => { PageUp(false); return true; });
	|            AddCommand(Command.PageDown, () => { PageDown(false); return true; });
	|            AddCommand(Command.LeftHome, () => { ChangeSelectionToStartOfRow(false); return true; });
	|            AddCommand(Command.RightEnd, () => { ChangeSelectionToEndOfRow(false); return true; });
	|            AddCommand(Command.TopHome, () => { ChangeSelectionToStartOfTable(false); return true; });
	|            AddCommand(Command.BottomEnd, () => { ChangeSelectionToEndOfTable(false); return true; });
	|
	|            AddCommand(Command.RightExtend, () => { ChangeSelectionByOffset(1, 0, true); return true; });
	|            AddCommand(Command.LeftExtend, () => { ChangeSelectionByOffset(-1, 0, true); return true; });
	|            AddCommand(Command.LineUpExtend, () => { ChangeSelectionByOffset(0, -1, true); return true; });
	|            AddCommand(Command.LineDownExtend, () => { ChangeSelectionByOffset(0, 1, true); return true; });
	|            AddCommand(Command.PageUpExtend, () => { PageUp(true); return true; });
	|            AddCommand(Command.PageDownExtend, () => { PageDown(true); return true; });
	|            AddCommand(Command.LeftHomeExtend, () => { ChangeSelectionToStartOfRow(true); return true; });
	|            AddCommand(Command.RightEndExtend, () => { ChangeSelectionToEndOfRow(true); return true; });
	|            AddCommand(Command.TopHomeExtend, () => { ChangeSelectionToStartOfTable(true); return true; });
	|            AddCommand(Command.BottomEndExtend, () => { ChangeSelectionToEndOfTable(true); return true; });
	|
	|            AddCommand(Command.SelectAll, () => { SelectAll(); return true; });
	|            AddCommand(Command.Accept, () => { OnCellActivated(new CellActivatedEventArgs(Table, SelectedColumn, SelectedRow)); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|            AddKeyBinding(Key.PageUp, Command.PageUp);
	|            AddKeyBinding(Key.PageDown, Command.PageDown);
	|            AddKeyBinding(Key.Home, Command.LeftHome);
	|            AddKeyBinding(Key.End, Command.RightEnd);
	|            AddKeyBinding(Key.Home | Key.CtrlMask, Command.TopHome);
	|            AddKeyBinding(Key.End | Key.CtrlMask, Command.BottomEnd);
	|
	|            AddKeyBinding(Key.CursorLeft | Key.ShiftMask, Command.LeftExtend);
	|            AddKeyBinding(Key.CursorRight | Key.ShiftMask, Command.RightExtend);
	|            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LineUpExtend);
	|            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.LineDownExtend);
	|            AddKeyBinding(Key.PageUp | Key.ShiftMask, Command.PageUpExtend);
	|            AddKeyBinding(Key.PageDown | Key.ShiftMask, Command.PageDownExtend);
	|            AddKeyBinding(Key.Home | Key.ShiftMask, Command.LeftHomeExtend);
	|            AddKeyBinding(Key.End | Key.ShiftMask, Command.RightEndExtend);
	|            AddKeyBinding(Key.Home | Key.CtrlMask | Key.ShiftMask, Command.TopHomeExtend);
	|            AddKeyBinding(Key.End | Key.CtrlMask | Key.ShiftMask, Command.BottomEndExtend);
	|
	|            AddKeyBinding(Key.A | Key.CtrlMask, Command.SelectAll);
	|            AddKeyBinding(CellActivationKey, Command.Accept);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            Move(0, 0);
	|            var frame = Frame;
	|
	|            scrollRightPoint = null;
	|            scrollLeftPoint = null;
	|
	|            // What columns to render at what X offset in viewport
	|            var columnsToRender = CalculateViewport(bounds).ToArray();
	|
	|            Driver.SetAttribute(GetNormalColor());
	|
	|            //invalidate current row (prevents scrolling around leaving old characters in the frame
	|            Driver.AddStr(new string(' ', bounds.Width));
	|
	|            int line = 0;
	|
	|            if (ShouldRenderHeaders())
	|            {
	|                // Render something like:
	|                /*
	|                    ┌────────────────────┬──────────┬───────────┬──────────────┬─────────┐
	|                    │ArithmeticComparator│chi       │Healthboard│Interpretation│Labnumber│
	|                    └────────────────────┴──────────┴───────────┴──────────────┴─────────┘
	|                */
	|                if (Style.ShowHorizontalHeaderOverline)
	|                {
	|                    RenderHeaderOverline(line, bounds.Width, columnsToRender);
	|                    line++;
	|                }
	|
	|                RenderHeaderMidline(line, columnsToRender);
	|                line++;
	|
	|                if (Style.ShowHorizontalHeaderUnderline)
	|                {
	|                    RenderHeaderUnderline(line, bounds.Width, columnsToRender);
	|                    line++;
	|                }
	|            }
	|
	|            int headerLinesConsumed = line;
	|
	|            //render the cells
	|            for (; line < frame.Height; line++)
	|            {
	|
	|                ClearLine(line, bounds.Width);
	|
	|                //work out what Row to render
	|                var rowToRender = RowOffset + (line - headerLinesConsumed);
	|
	|                //if we have run off the end of the table
	|                if (TableIsNullOrInvisible() || rowToRender >= Table.Rows.Count || rowToRender < 0)
	|                    continue;
	|
	|                RenderRow(line, rowToRender, columnsToRender);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Clears a line of the console by filling it with spaces
	|        /// </summary>
	|        /// <param name=""row""></param>
	|        /// <param name=""width""></param>
	|        private void ClearLine(int row, int width)
	|        {
	|            Move(0, row);
	|            Driver.SetAttribute(GetNormalColor());
	|            Driver.AddStr(new string(' ', width));
	|        }
	|
	|        /// <summary>
	|        /// Returns the amount of vertical space currently occupied by the header or 0 if it is not visible.
	|        /// </summary>
	|        /// <returns></returns>
	|        private int GetHeaderHeightIfAny()
	|        {
	|            return ShouldRenderHeaders() ? GetHeaderHeight() : 0;
	|        }
	|
	|        /// <summary>
	|        /// Returns the amount of vertical space required to display the header
	|        /// </summary>
	|        /// <returns></returns>
	|        private int GetHeaderHeight()
	|        {
	|            int heightRequired = 1;
	|
	|            if (Style.ShowHorizontalHeaderOverline)
	|                heightRequired++;
	|
	|            if (Style.ShowHorizontalHeaderUnderline)
	|                heightRequired++;
	|
	|            return heightRequired;
	|        }
	|
	|        private void RenderHeaderOverline(int row, int availableWidth, ColumnToRender[] columnsToRender)
	|        {
	|            // Renders a line above table headers (when visible) like:
	|            // ┌────────────────────┬──────────┬───────────┬──────────────┬─────────┐
	|
	|            for (int c = 0; c < availableWidth; c++)
	|            {
	|
	|                var rune = Driver.HLine;
	|
	|                if (Style.ShowVerticalHeaderLines)
	|                {
	|
	|                    if (c == 0)
	|                    {
	|                        rune = Driver.ULCorner;
	|                    }
	|                    // if the next column is the start of a header
	|                    else if (columnsToRender.Any(r => r.X == c + 1))
	|                    {
	|                        rune = Driver.TopTee;
	|                    }
	|                    else if (c == availableWidth - 1)
	|                    {
	|                        rune = Driver.URCorner;
	|                    }
	|                    // if the next console column is the lastcolumns end
	|                    else if (Style.ExpandLastColumn == false &&
	|                         columnsToRender.Any(r => r.IsVeryLast && r.X + r.Width - 1 == c))
	|                    {
	|                        rune = Driver.TopTee;
	|                    }
	|                }
	|
	|                AddRuneAt(Driver, c, row, rune);
	|            }
	|        }
	|
	|        private void RenderHeaderMidline(int row, ColumnToRender[] columnsToRender)
	|        {
	|            // Renders something like:
	|            // │ArithmeticComparator│chi       │Healthboard│Interpretation│Labnumber│
	|
	|            ClearLine(row, Bounds.Width);
	|
	|            //render start of line
	|            if (style.ShowVerticalHeaderLines)
	|                AddRune(0, row, Driver.VLine);
	|
	|            for (int i = 0; i < columnsToRender.Length; i++)
	|            {
	|
	|                var current = columnsToRender[i];
	|
	|                var colStyle = Style.GetColumnStyleIfAny(current.Column);
	|                var colName = current.Column.ColumnName;
	|
	|                RenderSeparator(current.X - 1, row, true);
	|
	|                Move(current.X, row);
	|
	|                Driver.AddStr(TruncateOrPad(colName, colName, current.Width, colStyle));
	|
	|                if (Style.ExpandLastColumn == false && current.IsVeryLast)
	|                {
	|                    RenderSeparator(current.X + current.Width - 1, row, true);
	|                }
	|            }
	|
	|            //render end of line
	|            if (style.ShowVerticalHeaderLines)
	|                AddRune(Bounds.Width - 1, row, Driver.VLine);
	|        }
	|
	|        private void RenderHeaderUnderline(int row, int availableWidth, ColumnToRender[] columnsToRender)
	|        {
	|            /*
	|			 *  First lets work out if we should be rendering scroll indicators
	|			 */
	|
	|            // are there are visible columns to the left that have been pushed
	|            // off the screen due to horizontal scrolling?
	|            bool moreColumnsToLeft = ColumnOffset > 0;
	|
	|            // if we moved left would we find a new column (or are they all invisible?)
	|            if (!TryGetNearestVisibleColumn(ColumnOffset - 1, false, false, out _))
	|            {
	|                moreColumnsToLeft = false;
	|            }
	|
	|            // are there visible columns to the right that have not yet been reached?
	|            // lets find out, what is the column index of the last column we are rendering
	|            int lastColumnIdxRendered = ColumnOffset + columnsToRender.Length - 1;
	|
	|            // are there more valid indexes?
	|            bool moreColumnsToRight = lastColumnIdxRendered < Table.Columns.Count;
	|
	|            // if we went right from the last column would we find a new visible column?
	|            if (!TryGetNearestVisibleColumn(lastColumnIdxRendered + 1, true, false, out _))
	|            {
	|                // no we would not
	|                moreColumnsToRight = false;
	|            }
	|
	|            /*
	|			 *  Now lets draw the line itself
	|			 */
	|
	|            // Renders a line below the table headers (when visible) like:
	|            // ├──────────┼───────────┼───────────────────┼──────────┼────────┼─────────────┤
	|
	|            for (int c = 0; c < availableWidth; c++)
	|            {
	|
	|                // Start by assuming we just draw a straight line the
	|                // whole way but update to instead draw a header indicator
	|                // or scroll arrow etc
	|                var rune = Driver.HLine;
	|
	|                if (Style.ShowVerticalHeaderLines)
	|                {
	|                    if (c == 0)
	|                    {
	|                        // for first character render line
	|                        rune = Style.ShowVerticalCellLines ? Driver.LeftTee : Driver.LLCorner;
	|
	|                        // unless we have horizontally scrolled along
	|                        // in which case render an arrow, to indicate user
	|                        // can scroll left
	|                        if (Style.ShowHorizontalScrollIndicators && moreColumnsToLeft)
	|                        {
	|                            rune = Driver.LeftArrow;
	|                            scrollLeftPoint = new Point(c, row);
	|                        }
	|
	|                    }
	|                    // if the next column is the start of a header
	|                    else if (columnsToRender.Any(r => r.X == c + 1))
	|                    {
	|
	|                        /*TODO: is ┼ symbol in Driver?*/
	|                        rune = Style.ShowVerticalCellLines ? '┼' : Driver.BottomTee;
	|                    }
	|                    else if (c == availableWidth - 1)
	|                    {
	|
	|                        // for the last character in the table
	|                        rune = Style.ShowVerticalCellLines ? Driver.RightTee : Driver.LRCorner;
	|
	|                        // unless there is more of the table we could horizontally
	|                        // scroll along to see. In which case render an arrow,
	|                        // to indicate user can scroll right
	|                        if (Style.ShowHorizontalScrollIndicators && moreColumnsToRight)
	|                        {
	|                            rune = Driver.RightArrow;
	|                            scrollRightPoint = new Point(c, row);
	|                        }
	|
	|                    }
	|                    // if the next console column is the lastcolumns end
	|                    else if (Style.ExpandLastColumn == false &&
	|                            columnsToRender.Any(r => r.IsVeryLast && r.X + r.Width - 1 == c))
	|                    {
	|                        rune = Style.ShowVerticalCellLines ? '┼' : Driver.BottomTee;
	|                    }
	|                }
	|
	|                AddRuneAt(Driver, c, row, rune);
	|            }
	|
	|        }
	|        private void RenderRow(int row, int rowToRender, ColumnToRender[] columnsToRender)
	|        {
	|            var focused = HasFocus;
	|
	|            var rowScheme = (Style.RowColorGetter?.Invoke(
	|                new RowColorGetterArgs(Table, rowToRender))) ?? ColorScheme;
	|
	|            //render start of line
	|            if (style.ShowVerticalCellLines)
	|                AddRune(0, row, Driver.VLine);
	|
	|            //start by clearing the entire line
	|            Move(0, row);
	|
	|            Attribute color;
	|
	|            if (FullRowSelect && IsSelected(0, rowToRender))
	|            {
	|                color = focused ? rowScheme.HotFocus : rowScheme.HotNormal;
	|            }
	|            else
	|            {
	|                color = Enabled ? rowScheme.Normal : rowScheme.Disabled;
	|            }
	|
	|            Driver.SetAttribute(color);
	|            Driver.AddStr(new string(' ', Bounds.Width));
	|
	|            // Render cells for each visible header for the current row
	|            for (int i = 0; i < columnsToRender.Length; i++)
	|            {
	|
	|                var current = columnsToRender[i];
	|
	|                var colStyle = Style.GetColumnStyleIfAny(current.Column);
	|
	|                // move to start of cell (in line with header positions)
	|                Move(current.X, row);
	|
	|                // Set color scheme based on whether the current cell is the selected one
	|                bool isSelectedCell = IsSelected(current.Column.Ordinal, rowToRender);
	|
	|                var val = Table.Rows[rowToRender][current.Column];
	|
	|                // Render the (possibly truncated) cell value
	|                var representation = GetRepresentation(val, colStyle);
	|
	|                // to get the colour scheme
	|                var colorSchemeGetter = colStyle?.ColorGetter;
	|
	|                ColorScheme scheme;
	|                if (colorSchemeGetter != null)
	|                {
	|                    // user has a delegate for defining row color per cell, call it
	|                    scheme = colorSchemeGetter(
	|                        new CellColorGetterArgs(Table, rowToRender, current.Column.Ordinal, val, representation, rowScheme));
	|
	|                    // if users custom color getter returned null, use the row scheme
	|                    if (scheme == null)
	|                    {
	|                        scheme = rowScheme;
	|                    }
	|                }
	|                else
	|                {
	|                    // There is no custom cell coloring delegate so use the scheme for the row
	|                    scheme = rowScheme;
	|                }
	|
	|                Attribute cellColor;
	|                if (isSelectedCell)
	|                {
	|                    cellColor = focused ? scheme.HotFocus : scheme.HotNormal;
	|                }
	|                else
	|                {
	|                    cellColor = Enabled ? scheme.Normal : scheme.Disabled;
	|                }
	|
	|                var render = TruncateOrPad(val, representation, current.Width, colStyle);
	|
	|                // While many cells can be selected (see MultiSelectedRegions) only one cell is the primary (drives navigation etc)
	|                bool isPrimaryCell = current.Column.Ordinal == selectedColumn && rowToRender == selectedRow;
	|
	|                RenderCell(cellColor, render, isPrimaryCell);
	|
	|                // Reset color scheme to normal for drawing separators if we drew text with custom scheme
	|                if (scheme != rowScheme)
	|                {
	|
	|                    if (isSelectedCell)
	|                    {
	|                        color = focused ? rowScheme.HotFocus : rowScheme.HotNormal;
	|                    }
	|                    else
	|                    {
	|                        color = Enabled ? rowScheme.Normal : rowScheme.Disabled;
	|                    }
	|                    Driver.SetAttribute(color);
	|                }
	|
	|                // If not in full row select mode always, reset color scheme to normal and render the vertical line (or space) at the end of the cell
	|                if (!FullRowSelect)
	|                    Driver.SetAttribute(Enabled ? rowScheme.Normal : rowScheme.Disabled);
	|
	|                RenderSeparator(current.X - 1, row, false);
	|
	|                if (Style.ExpandLastColumn == false && current.IsVeryLast)
	|                {
	|                    RenderSeparator(current.X + current.Width - 1, row, false);
	|                }
	|            }
	|
	|            //render end of line
	|            if (style.ShowVerticalCellLines)
	|                AddRune(Bounds.Width - 1, row, Driver.VLine);
	|        }
	|
	|        /// <summary>
	|        /// Override to provide custom multi colouring to cells.  Use <see cref=""View.Driver""/> to
	|        /// with <see cref=""ConsoleDriver.AddStr(ustring)""/>.  The driver will already be
	|        /// in the correct place when rendering and you must render the full <paramref name=""render""/>
	|        /// or the view will not look right.  For simpler provision of color use <see cref=""ColumnStyle.ColorGetter""/>
	|        /// For changing the content that is rendered use <see cref=""ColumnStyle.RepresentationGetter""/>
	|        /// </summary>
	|        /// <param name=""cellColor""></param>
	|        /// <param name=""render""></param>
	|        /// <param name=""isPrimaryCell""></param>
	|        protected virtual void RenderCell(Attribute cellColor, string render, bool isPrimaryCell)
	|        {
	|            // If the cell is the selected col/row then draw the first rune in inverted colors
	|            // this allows the user to track which cell is the active one during a multi cell
	|            // selection or in full row select mode
	|            if (Style.InvertSelectedCellFirstCharacter && isPrimaryCell)
	|            {
	|
	|                if (render.Length > 0)
	|                {
	|                    // invert the color of the current cell for the first character
	|                    Driver.SetAttribute(Driver.MakeAttribute(cellColor.Background, cellColor.Foreground));
	|                    Driver.AddRune(render[0]);
	|
	|                    if (render.Length > 1)
	|                    {
	|                        Driver.SetAttribute(cellColor);
	|                        Driver.AddStr(render.Substring(1));
	|                    }
	|                }
	|            }
	|            else
	|            {
	|                Driver.SetAttribute(cellColor);
	|                Driver.AddStr(render);
	|            }
	|        }
	|
	|        private void RenderSeparator(int col, int row, bool isHeader)
	|        {
	|            if (col < 0)
	|                return;
	|
	|            var renderLines = isHeader ? style.ShowVerticalHeaderLines : style.ShowVerticalCellLines;
	|
	|            Rune symbol = renderLines ? Driver.VLine : SeparatorSymbol;
	|            AddRune(col, row, symbol);
	|        }
	|
	|        void AddRuneAt(ConsoleDriver d, int col, int row, Rune ch)
	|        {
	|            Move(col, row);
	|            d.AddRune(ch);
	|        }
	|
	|        /// <summary>
	|        /// Truncates or pads <paramref name=""representation""/> so that it occupies a exactly <paramref name=""availableHorizontalSpace""/> using the alignment specified in <paramref name=""colStyle""/> (or left if no style is defined)
	|        /// </summary>
	|        /// <param name=""originalCellValue"">The object in this cell of the <see cref=""Table""/></param>
	|        /// <param name=""representation"">The string representation of <paramref name=""originalCellValue""/></param>
	|        /// <param name=""availableHorizontalSpace""></param>
	|        /// <param name=""colStyle"">Optional style indicating custom alignment for the cell</param>
	|        /// <returns></returns>
	|        private string TruncateOrPad(object originalCellValue, string representation, int availableHorizontalSpace, ColumnStyle colStyle)
	|        {
	|            if (string.IsNullOrEmpty(representation))
	|                return representation;
	|
	|            // if value is not wide enough
	|            if (representation.Sum(c => Rune.ColumnWidth(c)) < availableHorizontalSpace)
	|            {
	|
	|                // pad it out with spaces to the given alignment
	|                int toPad = availableHorizontalSpace - (representation.Sum(c => Rune.ColumnWidth(c)) + 1 /*leave 1 space for cell boundary*/);
	|
	|                switch (colStyle?.GetAlignment(originalCellValue) ?? TextAlignment.Left)
	|                {
	|
	|                    case TextAlignment.Left:
	|                        return representation + new string(' ', toPad);
	|                    case TextAlignment.Right:
	|                        return new string(' ', toPad) + representation;
	|
	|                    // TODO: With single line cells, centered and justified are the same right?
	|                    case TextAlignment.Centered:
	|                    case TextAlignment.Justified:
	|                        return
	|                            new string(' ', (int)Math.Floor(toPad / 2.0)) + // round down
	|                            representation +
	|                             new string(' ', (int)Math.Ceiling(toPad / 2.0)); // round up
	|                }
	|            }
	|
	|            // value is too wide
	|            return new string(representation.TakeWhile(c => (availableHorizontalSpace -= Rune.ColumnWidth(c)) > 0).ToArray());
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            if (TableIsNullOrInvisible())
	|            {
	|                PositionCursor();
	|                return false;
	|            }
	|
	|            var result = InvokeKeybindings(keyEvent);
	|            if (result != null)
	|            {
	|                PositionCursor();
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Moves the <see cref=""SelectedRow""/> and <see cref=""SelectedColumn""/> to the given col/row in <see cref=""Table""/>. Optionally starting a box selection (see <see cref=""MultiSelect""/>)
	|        /// </summary>
	|        /// <param name=""col""></param>
	|        /// <param name=""row""></param>
	|        /// <param name=""extendExistingSelection"">True to create a multi cell selection or adjust an existing one</param>
	|        public void SetSelection(int col, int row, bool extendExistingSelection)
	|        {
	|            // if we are trying to increase the column index then
	|            // we are moving right otherwise we are moving left
	|            bool lookRight = col > selectedColumn;
	|
	|            col = GetNearestVisibleColumn(col, lookRight, true);
	|
	|            if (!MultiSelect || !extendExistingSelection)
	|                MultiSelectedRegions.Clear();
	|
	|            if (extendExistingSelection)
	|            {
	|                // If we are extending current selection but there isn't one
	|                if (MultiSelectedRegions.Count == 0)
	|                {
	|                    // Create a new region between the old active cell and the new cell
	|                    var rect = CreateTableSelection(SelectedColumn, SelectedRow, col, row);
	|                    MultiSelectedRegions.Push(rect);
	|                }
	|                else
	|                {
	|                    // Extend the current head selection to include the new cell
	|                    var head = MultiSelectedRegions.Pop();
	|                    var newRect = CreateTableSelection(head.Origin.X, head.Origin.Y, col, row);
	|                    MultiSelectedRegions.Push(newRect);
	|                }
	|            }
	|
	|            SelectedColumn = col;
	|            SelectedRow = row;
	|        }
	|
	|        /// <summary>
	|        /// Unions the current selected cell (and/or regions) with the provided cell and makes
	|        /// it the active one.
	|        /// </summary>
	|        /// <param name=""col""></param>
	|        /// <param name=""row""></param>
	|        private void UnionSelection(int col, int row)
	|        {
	|            if (!MultiSelect || TableIsNullOrInvisible())
	|            {
	|                return;
	|            }
	|
	|            EnsureValidSelection();
	|
	|            var oldColumn = SelectedColumn;
	|            var oldRow = SelectedRow;
	|
	|            // move us to the new cell
	|            SelectedColumn = col;
	|            SelectedRow = row;
	|            MultiSelectedRegions.Push(
	|                CreateTableSelection(col, row)
	|                );
	|
	|            // if the old cell was not part of a rectangular select
	|            // or otherwise selected we need to retain it in the selection
	|
	|            if (!IsSelected(oldColumn, oldRow))
	|            {
	|                MultiSelectedRegions.Push(
	|                    CreateTableSelection(oldColumn, oldRow)
	|                    );
	|            }
	|        }
	|
	|
	|        /// <summary>
	|        /// Moves the <see cref=""SelectedRow""/> and <see cref=""SelectedColumn""/> by the provided offsets. Optionally starting a box selection (see <see cref=""MultiSelect""/>)
	|        /// </summary>
	|        /// <param name=""offsetX"">Offset in number of columns</param>
	|        /// <param name=""offsetY"">Offset in number of rows</param>
	|        /// <param name=""extendExistingSelection"">True to create a multi cell selection or adjust an existing one</param>
	|        public void ChangeSelectionByOffset(int offsetX, int offsetY, bool extendExistingSelection)
	|        {
	|            SetSelection(SelectedColumn + offsetX, SelectedRow + offsetY, extendExistingSelection);
	|            Update();
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection up by one page
	|        /// </summary>
	|        /// <param name=""extend"">true to extend the current selection (if any) instead of replacing</param>
	|        public void PageUp(bool extend)
	|        {
	|            ChangeSelectionByOffset(0, -(Bounds.Height - GetHeaderHeightIfAny()), extend);
	|            Update();
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection down by one page
	|        /// </summary>
	|        /// <param name=""extend"">true to extend the current selection (if any) instead of replacing</param>
	|        public void PageDown(bool extend)
	|        {
	|            ChangeSelectionByOffset(0, Bounds.Height - GetHeaderHeightIfAny(), extend);
	|            Update();
	|        }
	|
	|        /// <summary>
	|        /// Moves or extends the selection to the first cell in the table (0,0).
	|        /// If <see cref=""FullRowSelect""/> is enabled then selection instead moves
	|        /// to (<see cref=""SelectedColumn""/>,0) i.e. no horizontal scrolling.
	|        /// </summary>
	|        /// <param name=""extend"">true to extend the current selection (if any) instead of replacing</param>
	|        public void ChangeSelectionToStartOfTable(bool extend)
	|        {
	|            SetSelection(FullRowSelect ? SelectedColumn : 0, 0, extend);
	|            Update();
	|        }
	|
	|        /// <summary>
	|        /// Moves or extends the selection to the final cell in the table (nX,nY).
	|        /// If <see cref=""FullRowSelect""/> is enabled then selection instead moves
	|        /// to (<see cref=""SelectedColumn""/>,nY) i.e. no horizontal scrolling.
	|        /// </summary>
	|        /// <param name=""extend"">true to extend the current selection (if any) instead of replacing</param>
	|        public void ChangeSelectionToEndOfTable(bool extend)
	|        {
	|            var finalColumn = Table.Columns.Count - 1;
	|
	|            SetSelection(FullRowSelect ? SelectedColumn : finalColumn, Table.Rows.Count - 1, extend);
	|            Update();
	|        }
	|
	|
	|        /// <summary>
	|        /// Moves or extends the selection to the last cell in the current row
	|        /// </summary>
	|        /// <param name=""extend"">true to extend the current selection (if any) instead of replacing</param>
	|        public void ChangeSelectionToEndOfRow(bool extend)
	|        {
	|            SetSelection(Table.Columns.Count - 1, SelectedRow, extend);
	|            Update();
	|        }
	|
	|        /// <summary>
	|        /// Moves or extends the selection to the first cell in the current row
	|        /// </summary>
	|        /// <param name=""extend"">true to extend the current selection (if any) instead of replacing</param>
	|        public void ChangeSelectionToStartOfRow(bool extend)
	|        {
	|            SetSelection(0, SelectedRow, extend);
	|            Update();
	|        }
	|
	|        /// <summary>
	|        /// When <see cref=""MultiSelect""/> is on, creates selection over all cells in the table (replacing any old selection regions)
	|        /// </summary>
	|        public void SelectAll()
	|        {
	|            if (TableIsNullOrInvisible() || !MultiSelect || Table.Rows.Count == 0)
	|                return;
	|
	|            MultiSelectedRegions.Clear();
	|
	|            // Create a single region over entire table, set the origin of the selection to the active cell so that a followup spread selection e.g. shift-right behaves properly
	|            MultiSelectedRegions.Push(new TableSelection(new Point(SelectedColumn, SelectedRow), new Rect(0, 0, Table.Columns.Count, table.Rows.Count)));
	|            Update();
	|        }
	|
	|        /// <summary>
	|        /// Returns all cells in any <see cref=""MultiSelectedRegions""/> (if <see cref=""MultiSelect""/> is enabled) and the selected cell
	|        /// </summary>
	|        /// <remarks>Return value is not affected by <see cref=""FullRowSelect""/> (i.e. returned <see cref=""Point""/>s are not expanded to 
	|        /// include all points on row).</remarks>
	|        /// <returns></returns>
	|        public IEnumerable<Point> GetAllSelectedCells()
	|        {
	|            if (TableIsNullOrInvisible() || Table.Rows.Count == 0)
	|                yield break;
	|
	|            EnsureValidSelection();
	|
	|            // If there are one or more rectangular selections
	|            if (MultiSelect && MultiSelectedRegions.Any())
	|            {
	|
	|                // Quiz any cells for whether they are selected.  For performance we only need to check those between the top left and lower right vertex of selection regions
	|                var yMin = MultiSelectedRegions.Min(r => r.Rect.Top);
	|                var yMax = MultiSelectedRegions.Max(r => r.Rect.Bottom);
	|
	|                var xMin = FullRowSelect ? 0 : MultiSelectedRegions.Min(r => r.Rect.Left);
	|                var xMax = FullRowSelect ? Table.Columns.Count : MultiSelectedRegions.Max(r => r.Rect.Right);
	|
	|                for (int y = yMin; y < yMax; y++)
	|                {
	|                    for (int x = xMin; x < xMax; x++)
	|                    {
	|                        if (IsSelected(x, y))
	|                        {
	|                            yield return new Point(x, y);
	|                        }
	|                    }
	|                }
	|            }
	|            else
	|            {
	|
	|                // if there are no region selections then it is just the active cell
	|
	|                // if we are selecting the full row
	|                if (FullRowSelect)
	|                {
	|                    // all cells in active row are selected
	|                    for (int x = 0; x < Table.Columns.Count; x++)
	|                    {
	|                        yield return new Point(x, SelectedRow);
	|                    }
	|                }
	|                else
	|                {
	|                    // Not full row select and no multi selections
	|                    yield return new Point(SelectedColumn, SelectedRow);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns a new rectangle between the two points with positive width/height regardless of relative positioning of the points.  pt1 is always considered the <see cref=""TableSelection.Origin""/> point
	|        /// </summary>
	|        /// <param name=""pt1X"">Origin point for the selection in X</param>
	|        /// <param name=""pt1Y"">Origin point for the selection in Y</param>
	|        /// <param name=""pt2X"">End point for the selection in X</param>
	|        /// <param name=""pt2Y"">End point for the selection in Y</param>
	|        /// <returns></returns>
	|        private TableSelection CreateTableSelection(int pt1X, int pt1Y, int pt2X, int pt2Y)
	|        {
	|            var top = Math.Max(Math.Min(pt1Y, pt2Y), 0);
	|            var bot = Math.Max(Math.Max(pt1Y, pt2Y), 0);
	|
	|            var left = Math.Max(Math.Min(pt1X, pt2X), 0);
	|            var right = Math.Max(Math.Max(pt1X, pt2X), 0);
	|
	|            // Rect class is inclusive of Top Left but exclusive of Bottom Right so extend by 1
	|            return new TableSelection(new Point(pt1X, pt1Y), new Rect(left, top, right - left + 1, bot - top + 1));
	|        }
	|
	|        /// <summary>
	|        /// Returns a single point as a <see cref=""TableSelection""/>
	|        /// </summary>
	|        /// <param name=""x""></param>
	|        /// <param name=""y""></param>
	|        /// <returns></returns>
	|        private TableSelection CreateTableSelection(int x, int y)
	|        {
	|            return CreateTableSelection(x, y, x, y);
	|        }
	|        /// <summary>
	|        /// <para>
	|        /// Returns true if the given cell is selected either because it is the active cell or part of a multi cell selection (e.g. <see cref=""FullRowSelect""/>).
	|        /// </para>
	|        /// <remarks>Returns <see langword=""false""/> if <see cref=""ColumnStyle.Visible""/> is <see langword=""false""/>.</remarks>
	|        /// </summary>
	|        /// <param name=""col""></param>
	|        /// <param name=""row""></param>
	|        /// <returns></returns>
	|        public bool IsSelected(int col, int row)
	|        {
	|            if (!IsColumnVisible(col))
	|            {
	|                return false;
	|            }
	|
	|            // Cell is also selected if in any multi selection region
	|            if (MultiSelect && MultiSelectedRegions.Any(r => r.Rect.Contains(col, row)))
	|                return true;
	|
	|            // Cell is also selected if Y axis appears in any region (when FullRowSelect is enabled)
	|            if (FullRowSelect && MultiSelect && MultiSelectedRegions.Any(r => r.Rect.Bottom > row && r.Rect.Top <= row))
	|                return true;
	|
	|            return row == SelectedRow &&
	|                    (col == SelectedColumn || FullRowSelect);
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the given <paramref name=""columnIndex""/> indexes a visible
	|        /// column otherwise false.  Returns false for indexes that are out of bounds.
	|        /// </summary>
	|        /// <param name=""columnIndex""></param>
	|        /// <returns></returns>
	|        private bool IsColumnVisible(int columnIndex)
	|        {
	|            // if the column index provided is out of bounds
	|            if (columnIndex < 0 || columnIndex >= table.Columns.Count)
	|            {
	|                return false;
	|            }
	|
	|            return this.Style.GetColumnStyleIfAny(Table.Columns[columnIndex])?.Visible ?? true;
	|        }
	|
	|        /// <summary>
	|        /// Positions the cursor in the area of the screen in which the start of the active cell is rendered.  Calls base implementation if active cell is not visible due to scrolling or table is loaded etc
	|        /// </summary>
	|        public override void PositionCursor()
	|        {
	|            if (TableIsNullOrInvisible())
	|            {
	|                base.PositionCursor();
	|                return;
	|            }
	|
	|            var screenPoint = CellToScreen(SelectedColumn, SelectedRow);
	|
	|            if (screenPoint != null)
	|                Move(screenPoint.Value.X, screenPoint.Value.Y);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) && !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
	|                me.Flags != MouseFlags.WheeledDown && me.Flags != MouseFlags.WheeledUp &&
	|                me.Flags != MouseFlags.WheeledLeft && me.Flags != MouseFlags.WheeledRight)
	|                return false;
	|
	|            if (!HasFocus && CanFocus)
	|            {
	|                SetFocus();
	|            }
	|
	|            if (TableIsNullOrInvisible())
	|            {
	|                return false;
	|            }
	|
	|            // Scroll wheel flags
	|            switch (me.Flags)
	|            {
	|                case MouseFlags.WheeledDown:
	|                    RowOffset++;
	|                    EnsureValidScrollOffsets();
	|                    SetNeedsDisplay();
	|                    return true;
	|
	|                case MouseFlags.WheeledUp:
	|                    RowOffset--;
	|                    EnsureValidScrollOffsets();
	|                    SetNeedsDisplay();
	|                    return true;
	|
	|                case MouseFlags.WheeledRight:
	|                    ColumnOffset++;
	|                    EnsureValidScrollOffsets();
	|                    SetNeedsDisplay();
	|                    return true;
	|
	|                case MouseFlags.WheeledLeft:
	|                    ColumnOffset--;
	|                    EnsureValidScrollOffsets();
	|                    SetNeedsDisplay();
	|                    return true;
	|            }
	|
	|            if (me.Flags.HasFlag(MouseFlags.Button1Clicked))
	|            {
	|
	|                if (scrollLeftPoint != null
	|                    && scrollLeftPoint.Value.X == me.X
	|                    && scrollLeftPoint.Value.Y == me.Y)
	|                {
	|                    ColumnOffset--;
	|                    EnsureValidScrollOffsets();
	|                    SetNeedsDisplay();
	|                }
	|
	|                if (scrollRightPoint != null
	|                    && scrollRightPoint.Value.X == me.X
	|                    && scrollRightPoint.Value.Y == me.Y)
	|                {
	|                    ColumnOffset++;
	|                    EnsureValidScrollOffsets();
	|                    SetNeedsDisplay();
	|                }
	|
	|                var hit = ScreenToCell(me.X, me.Y);
	|                if (hit != null)
	|                {
	|
	|                    if (MultiSelect && HasControlOrAlt(me))
	|                    {
	|                        UnionSelection(hit.Value.X, hit.Value.Y);
	|                    }
	|                    else
	|                    {
	|                        SetSelection(hit.Value.X, hit.Value.Y, me.Flags.HasFlag(MouseFlags.ButtonShift));
	|                    }
	|
	|                    Update();
	|                }
	|            }
	|
	|            // Double clicking a cell activates
	|            if (me.Flags == MouseFlags.Button1DoubleClicked)
	|            {
	|                var hit = ScreenToCell(me.X, me.Y);
	|                if (hit != null)
	|                {
	|                    OnCellActivated(new CellActivatedEventArgs(Table, hit.Value.X, hit.Value.Y));
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        private bool HasControlOrAlt(MouseEvent me)
	|        {
	|            return me.Flags.HasFlag(MouseFlags.ButtonAlt) || me.Flags.HasFlag(MouseFlags.ButtonCtrl);
	|        }
	|
	|        /// <summary>.
	|        /// Returns the column and row of <see cref=""Table""/> that corresponds to a given point 
	|        /// on the screen (relative to the control client area).  Returns null if the point is
	|        /// in the header, no table is loaded or outside the control bounds.
	|        /// </summary>
	|        /// <param name=""clientX"">X offset from the top left of the control.</param>
	|        /// <param name=""clientY"">Y offset from the top left of the control.</param>
	|        /// <returns>Cell clicked or null.</returns>
	|        public Point? ScreenToCell(int clientX, int clientY)
	|        {
	|            return ScreenToCell(clientX, clientY, out _);
	|        }
	|
	|        /// <inheritdoc cref=""ScreenToCell(int, int)""/>
	|        /// <param name=""clientX"">X offset from the top left of the control.</param>
	|        /// <param name=""clientY"">Y offset from the top left of the control.</param>
	|        /// <param name=""headerIfAny"">If the click is in a header this is the column clicked.</param>
	|        public Point? ScreenToCell(int clientX, int clientY, out DataColumn headerIfAny)
	|        {
	|            headerIfAny = null;
	|
	|            if (TableIsNullOrInvisible())
	|                return null;
	|
	|            var viewPort = CalculateViewport(Bounds);
	|
	|            var headerHeight = GetHeaderHeightIfAny();
	|
	|            var col = viewPort.LastOrDefault(c => c.X <= clientX);
	|
	|            // Click is on the header section of rendered UI
	|            if (clientY < headerHeight)
	|            {
	|                headerIfAny = col?.Column;
	|                return null;
	|            }
	|
	|
	|            var rowIdx = RowOffset - headerHeight + clientY;
	|
	|            // if click is off bottom of the rows don't give an
	|            // invalid index back to user!
	|            if (rowIdx >= Table.Rows.Count)
	|            {
	|                return null;
	|            }
	|
	|            if (col != null && rowIdx >= 0)
	|            {
	|
	|                return new Point(col.Column.Ordinal, rowIdx);
	|            }
	|
	|            return null;
	|        }
	|
	|        /// <summary>
	|        /// Returns the screen position (relative to the control client area) that the given cell is rendered or null if it is outside the current scroll area or no table is loaded
	|        /// </summary>
	|        /// <param name=""tableColumn"">The index of the <see cref=""Table""/> column you are looking for, use <see cref=""DataColumn.Ordinal""/></param>
	|        /// <param name=""tableRow"">The index of the row in <see cref=""Table""/> that you are looking for</param>
	|        /// <returns></returns>
	|        public Point? CellToScreen(int tableColumn, int tableRow)
	|        {
	|            if (TableIsNullOrInvisible())
	|                return null;
	|
	|            var viewPort = CalculateViewport(Bounds);
	|
	|            var headerHeight = GetHeaderHeightIfAny();
	|
	|            var colHit = viewPort.FirstOrDefault(c => c.Column.Ordinal == tableColumn);
	|
	|            // current column is outside the scroll area
	|            if (colHit == null)
	|                return null;
	|
	|            // the cell is too far up above the current scroll area
	|            if (RowOffset > tableRow)
	|                return null;
	|
	|            // the cell is way down below the scroll area and off the screen
	|            if (tableRow > RowOffset + (Bounds.Height - headerHeight))
	|                return null;
	|
	|            return new Point(colHit.X, tableRow + headerHeight - RowOffset);
	|        }
	|        /// <summary>
	|        /// Updates the view to reflect changes to <see cref=""Table""/> and to (<see cref=""ColumnOffset""/> / <see cref=""RowOffset""/>) etc
	|        /// </summary>
	|        /// <remarks>This always calls <see cref=""View.SetNeedsDisplay()""/></remarks>
	|        public void Update()
	|        {
	|            if (TableIsNullOrInvisible())
	|            {
	|                SetNeedsDisplay();
	|                return;
	|            }
	|
	|            EnsureValidScrollOffsets();
	|            EnsureValidSelection();
	|
	|            EnsureSelectedCellIsVisible();
	|
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Updates <see cref=""ColumnOffset""/> and <see cref=""RowOffset""/> where they are outside the bounds of the table (by adjusting them to the nearest existing cell).  Has no effect if <see cref=""Table""/> has not been set.
	|        /// </summary>
	|        /// <remarks>Changes will not be immediately visible in the display until you call <see cref=""View.SetNeedsDisplay()""/></remarks>
	|        public void EnsureValidScrollOffsets()
	|        {
	|            if (TableIsNullOrInvisible())
	|            {
	|                return;
	|            }
	|
	|            ColumnOffset = Math.Max(Math.Min(ColumnOffset, Table.Columns.Count - 1), 0);
	|            RowOffset = Math.Max(Math.Min(RowOffset, Table.Rows.Count - 1), 0);
	|        }
	|
	|
	|        /// <summary>
	|        /// Updates <see cref=""SelectedColumn""/>, <see cref=""SelectedRow""/> and <see cref=""MultiSelectedRegions""/> where they are outside the bounds of the table (by adjusting them to the nearest existing cell).  Has no effect if <see cref=""Table""/> has not been set.
	|        /// </summary>
	|        /// <remarks>Changes will not be immediately visible in the display until you call <see cref=""View.SetNeedsDisplay()""/></remarks>
	|        public void EnsureValidSelection()
	|        {
	|            if (TableIsNullOrInvisible())
	|            {
	|
	|                // Table doesn't exist, we should probably clear those selections
	|                MultiSelectedRegions.Clear();
	|                return;
	|            }
	|
	|            SelectedColumn = Math.Max(Math.Min(SelectedColumn, Table.Columns.Count - 1), 0);
	|            SelectedRow = Math.Max(Math.Min(SelectedRow, Table.Rows.Count - 1), 0);
	|
	|            // If SelectedColumn is invisible move it to a visible one
	|            SelectedColumn = GetNearestVisibleColumn(SelectedColumn, lookRight: true, true);
	|
	|            var oldRegions = MultiSelectedRegions.ToArray().Reverse();
	|
	|            MultiSelectedRegions.Clear();
	|
	|            // evaluate 
	|            foreach (var region in oldRegions)
	|            {
	|                // ignore regions entirely below current table state
	|                if (region.Rect.Top >= Table.Rows.Count)
	|                    continue;
	|
	|                // ignore regions entirely too far right of table columns
	|                if (region.Rect.Left >= Table.Columns.Count)
	|                    continue;
	|
	|                // ensure region's origin exists
	|                region.Origin = new Point(
	|                    Math.Max(Math.Min(region.Origin.X, Table.Columns.Count - 1), 0),
	|                    Math.Max(Math.Min(region.Origin.Y, Table.Rows.Count - 1), 0));
	|
	|                // ensure regions do not go over edge of table bounds
	|                region.Rect = Rect.FromLTRB(region.Rect.Left,
	|                    region.Rect.Top,
	|                    Math.Max(Math.Min(region.Rect.Right, Table.Columns.Count), 0),
	|                    Math.Max(Math.Min(region.Rect.Bottom, Table.Rows.Count), 0)
	|                    );
	|
	|                MultiSelectedRegions.Push(region);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the <see cref=""Table""/> is not set or all the
	|        /// <see cref=""DataColumn""/> in the <see cref=""Table""/> have an explicit
	|        /// <see cref=""ColumnStyle""/> that marks them <see cref=""ColumnStyle.visible""/>
	|        /// <see langword=""false""/>.
	|        /// </summary>
	|        /// <returns></returns>
	|        private bool TableIsNullOrInvisible()
	|        {
	|            return Table == null ||
	|                Table.Columns.Count <= 0 ||
	|                Table.Columns.Cast<DataColumn>().All(
	|                c => (Style.GetColumnStyleIfAny(c)?.Visible ?? true) == false);
	|        }
	|
	|        /// <summary>
	|        /// Returns <paramref name=""columnIndex""/> unless the <see cref=""ColumnStyle.Visible""/> is false for
	|        /// the indexed <see cref=""DataColumn""/>.  If so then the index returned is nudged to the nearest visible
	|        /// column.
	|        /// </summary>
	|        /// <remarks>Returns <paramref name=""columnIndex""/> unchanged if it is invalid (e.g. out of bounds).</remarks>
	|        /// <param name=""columnIndex"">The input column index.</param>
	|        /// <param name=""lookRight"">When nudging invisible selections look right first.
	|        /// <see langword=""true""/> to look right, <see langword=""false""/> to look left.</param>
	|        /// <param name=""allowBumpingInOppositeDirection"">If we cannot find anything visible when
	|        /// looking in direction of <paramref name=""lookRight""/> then should we look in the opposite
	|        /// direction instead? Use true if you want to push a selection to a valid index no matter what.
	|        /// Use false if you are primarily interested in learning about directional column visibility.</param>
	|        private int GetNearestVisibleColumn(int columnIndex, bool lookRight, bool allowBumpingInOppositeDirection)
	|        {
	|            if (TryGetNearestVisibleColumn(columnIndex, lookRight, allowBumpingInOppositeDirection, out var answer))
	|            {
	|                return answer;
	|            }
	|
	|            return columnIndex;
	|        }
	|
	|        private bool TryGetNearestVisibleColumn(int columnIndex, bool lookRight, bool allowBumpingInOppositeDirection, out int idx)
	|        {
	|            // if the column index provided is out of bounds
	|            if (columnIndex < 0 || columnIndex >= table.Columns.Count)
	|            {
	|
	|                idx = columnIndex;
	|                return false;
	|            }
	|
	|            // get the column visibility by index (if no style visible is true)
	|            bool[] columnVisibility = Table.Columns.Cast<DataColumn>()
	|                .Select(c => this.Style.GetColumnStyleIfAny(c)?.Visible ?? true)
	|                .ToArray();
	|
	|            // column is visible
	|            if (columnVisibility[columnIndex])
	|            {
	|                idx = columnIndex;
	|                return true;
	|            }
	|
	|            int increment = lookRight ? 1 : -1;
	|
	|            // move in that direction
	|            for (int i = columnIndex; i >= 0 && i < columnVisibility.Length; i += increment)
	|            {
	|                // if we find a visible column
	|                if (columnVisibility[i])
	|                {
	|                    idx = i;
	|                    return true;
	|                }
	|            }
	|
	|            // Caller only wants to look in one direction and we did not find any
	|            // visible columns in that direction
	|            if (!allowBumpingInOppositeDirection)
	|            {
	|                idx = columnIndex;
	|                return false;
	|            }
	|
	|            // Caller will let us look in the other direction so
	|            // now look other way
	|            increment = -increment;
	|
	|            for (int i = columnIndex; i >= 0 && i < columnVisibility.Length; i += increment)
	|            {
	|                // if we find a visible column
	|                if (columnVisibility[i])
	|                {
	|                    idx = i;
	|                    return true;
	|                }
	|            }
	|
	|            // nothing seems to be visible so just return input index
	|            idx = columnIndex;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Updates scroll offsets to ensure that the selected cell is visible.  Has no effect if <see cref=""Table""/> has not been set.
	|        /// </summary>
	|        /// <remarks>Changes will not be immediately visible in the display until you call <see cref=""View.SetNeedsDisplay()""/></remarks>
	|        public void EnsureSelectedCellIsVisible()
	|        {
	|            if (Table == null || Table.Columns.Count <= 0)
	|            {
	|                return;
	|            }
	|
	|            var columnsToRender = CalculateViewport(Bounds).ToArray();
	|            var headerHeight = GetHeaderHeightIfAny();
	|
	|            //if we have scrolled too far to the left 
	|            if (SelectedColumn < columnsToRender.Min(r => r.Column.Ordinal))
	|            {
	|                ColumnOffset = SelectedColumn;
	|            }
	|
	|            //if we have scrolled too far to the right
	|            if (SelectedColumn > columnsToRender.Max(r => r.Column.Ordinal))
	|            {
	|
	|                if (Style.SmoothHorizontalScrolling)
	|                {
	|
	|                    // Scroll right 1 column at a time until the users selected column is visible
	|                    while (SelectedColumn > columnsToRender.Max(r => r.Column.Ordinal))
	|                    {
	|
	|                        ColumnOffset++;
	|                        columnsToRender = CalculateViewport(Bounds).ToArray();
	|
	|                        // if we are already scrolled to the last column then break
	|                        // this will prevent any theoretical infinite loop
	|                        if (ColumnOffset >= Table.Columns.Count - 1)
	|                            break;
	|
	|                    }
	|                }
	|                else
	|                {
	|                    ColumnOffset = SelectedColumn;
	|                }
	|
	|            }
	|
	|            //if we have scrolled too far down
	|            if (SelectedRow >= RowOffset + (Bounds.Height - headerHeight))
	|            {
	|                RowOffset = SelectedRow - (Bounds.Height - headerHeight) + 1;
	|            }
	|            //if we have scrolled too far up
	|            if (SelectedRow < RowOffset)
	|            {
	|                RowOffset = SelectedRow;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Invokes the <see cref=""SelectedCellChanged""/> event
	|        /// </summary>
	|        protected virtual void OnSelectedCellChanged(SelectedCellChangedEventArgs args)
	|        {
	|            SelectedCellChanged?.Invoke(args);
	|        }
	|
	|        /// <summary>
	|        /// Invokes the <see cref=""CellActivated""/> event
	|        /// </summary>
	|        /// <param name=""args""></param>
	|        protected virtual void OnCellActivated(CellActivatedEventArgs args)
	|        {
	|            CellActivated?.Invoke(args);
	|        }
	|
	|        /// <summary>
	|        /// Calculates which columns should be rendered given the <paramref name=""bounds""/> in which to display and the <see cref=""ColumnOffset""/>
	|        /// </summary>
	|        /// <param name=""bounds""></param>
	|        /// <param name=""padding""></param>
	|        /// <returns></returns>
	|        private IEnumerable<ColumnToRender> CalculateViewport(Rect bounds, int padding = 1)
	|        {
	|            if (TableIsNullOrInvisible())
	|                yield break;
	|
	|            int usedSpace = 0;
	|
	|            //if horizontal space is required at the start of the line (before the first header)
	|            if (Style.ShowVerticalHeaderLines || Style.ShowVerticalCellLines)
	|                usedSpace += 1;
	|
	|            int availableHorizontalSpace = bounds.Width;
	|            int rowsToRender = bounds.Height;
	|
	|            // reserved for the headers row
	|            if (ShouldRenderHeaders())
	|                rowsToRender -= GetHeaderHeight();
	|
	|            bool first = true;
	|            var lastColumn = Table.Columns.Cast<DataColumn>().Last();
	|
	|            foreach (var col in Table.Columns.Cast<DataColumn>().Skip(ColumnOffset))
	|            {
	|
	|                int startingIdxForCurrentHeader = usedSpace;
	|                var colStyle = Style.GetColumnStyleIfAny(col);
	|                int colWidth;
	|
	|                // if column is not being rendered
	|                if (colStyle?.Visible == false)
	|                {
	|                    // do not add it to the returned columns
	|                    continue;
	|                }
	|
	|                // is there enough space for this column (and it's data)?
	|                colWidth = CalculateMaxCellWidth(col, rowsToRender, colStyle) + padding;
	|
	|                // there is not enough space for this columns 
	|                // visible content
	|                if (usedSpace + colWidth > availableHorizontalSpace)
	|                {
	|                    bool showColumn = false;
	|
	|                    // if this column accepts flexible width rendering and
	|                    // is therefore happy rendering into less space
	|                    if (colStyle != null && colStyle.MinAcceptableWidth > 0 &&
	|                        // is there enough space to meet the MinAcceptableWidth
	|                        (availableHorizontalSpace - usedSpace) >= colStyle.MinAcceptableWidth)
	|                    {
	|                        // show column and use use whatever space is 
	|                        // left for rendering it
	|                        showColumn = true;
	|                        colWidth = availableHorizontalSpace - usedSpace;
	|                    }
	|
	|                    // If its the only column we are able to render then
	|                    // accept it anyway (that must be one massively wide column!)
	|                    if (first)
	|                    {
	|                        showColumn = true;
	|                    }
	|
	|                    // no special exceptions and we are out of space
	|                    // so stop accepting new columns for the render area
	|                    if (!showColumn)
	|                        break;
	|                }
	|
	|                usedSpace += colWidth;
	|
	|                // there is space
	|                yield return new ColumnToRender(col, startingIdxForCurrentHeader,
	|                    // required for if we end up here because first == true i.e. we have a single massive width (overspilling bounds) column to present
	|                    Math.Min(availableHorizontalSpace, colWidth),
	|                    lastColumn == col);
	|                first = false;
	|            }
	|        }
	|
	|        private bool ShouldRenderHeaders()
	|        {
	|            if (TableIsNullOrInvisible())
	|                return false;
	|
	|            return Style.AlwaysShowHeaders || rowOffset == 0;
	|        }
	|
	|        /// <summary>
	|        /// Returns the maximum of the <paramref name=""col""/> name and the maximum length of data that will be rendered starting at <see cref=""RowOffset""/> and rendering <paramref name=""rowsToRender""/>
	|        /// </summary>
	|        /// <param name=""col""></param>
	|        /// <param name=""rowsToRender""></param>
	|        /// <param name=""colStyle""></param>
	|        /// <returns></returns>
	|        private int CalculateMaxCellWidth(DataColumn col, int rowsToRender, ColumnStyle colStyle)
	|        {
	|            int spaceRequired = col.ColumnName.Sum(c => Rune.ColumnWidth(c));
	|
	|            // if table has no rows
	|            if (RowOffset < 0)
	|                return spaceRequired;
	|
	|
	|            for (int i = RowOffset; i < RowOffset + rowsToRender && i < Table.Rows.Count; i++)
	|            {
	|
	|                //expand required space if cell is bigger than the last biggest cell or header
	|                spaceRequired = Math.Max(spaceRequired, GetRepresentation(Table.Rows[i][col], colStyle).Sum(c => Rune.ColumnWidth(c)));
	|            }
	|
	|            // Don't require more space than the style allows
	|            if (colStyle != null)
	|            {
	|
	|                // enforce maximum cell width based on style
	|                if (spaceRequired > colStyle.MaxWidth)
	|                {
	|                    spaceRequired = colStyle.MaxWidth;
	|                }
	|
	|                // enforce minimum cell width based on style
	|                if (spaceRequired < colStyle.MinWidth)
	|                {
	|                    spaceRequired = colStyle.MinWidth;
	|                }
	|            }
	|
	|            // enforce maximum cell width based on global table style
	|            if (spaceRequired > MaxCellWidth)
	|                spaceRequired = MaxCellWidth;
	|
	|
	|            return spaceRequired;
	|        }
	|
	|        /// <summary>
	|        /// Returns the value that should be rendered to best represent a strongly typed <paramref name=""value""/> read from <see cref=""Table""/>
	|        /// </summary>
	|        /// <param name=""value""></param>
	|        /// <param name=""colStyle"">Optional style defining how to represent cell values</param>
	|        /// <returns></returns>
	|        private string GetRepresentation(object value, ColumnStyle colStyle)
	|        {
	|            if (value == null || value == DBNull.Value)
	|            {
	|                return NullSymbol;
	|            }
	|
	|            return colStyle != null ? colStyle.GetRepresentation(value) : value.ToString();
	|        }
	|
	|        /// <summary>
	|        /// Delegate for providing color to <see cref=""TableView""/> cells based on the value being rendered
	|        /// </summary>
	|        /// <param name=""args"">Contains information about the cell for which color is needed</param>
	|        /// <returns></returns>
	|        public delegate ColorScheme CellColorGetterDelegate(CellColorGetterArgs args);
	|
	|        /// <summary>
	|        /// Delegate for providing color for a whole row of a <see cref=""TableView""/>
	|        /// </summary>
	|        /// <param name=""args""></param>
	|        /// <returns></returns>
	|        public delegate ColorScheme RowColorGetterDelegate(RowColorGetterArgs args);
	|
	|        #region Nested Types
	|        /// <summary>
	|        /// Describes how to render a given column in  a <see cref=""TableView""/> including <see cref=""Alignment""/> 
	|        /// and textual representation of cells (e.g. date formats)
	|        /// 
	|        /// <a href=""https://gui-cs.github.io/Terminal.Gui/articles/tableview.html"">See TableView Deep Dive for more information</a>.
	|        /// </summary>
	|        public class ColumnStyle
	|        {
	|
	|            /// <summary>
	|            /// Defines the default alignment for all values rendered in this column.  For custom alignment based on cell contents use <see cref=""AlignmentGetter""/>.
	|            /// </summary>
	|            public TextAlignment Alignment { get; set; }
	|
	|            /// <summary>
	|            /// Defines a delegate for returning custom alignment per cell based on cell values.  When specified this will override <see cref=""Alignment""/>
	|            /// </summary>
	|            public Func<object, TextAlignment> AlignmentGetter;
	|
	|            /// <summary>
	|            /// Defines a delegate for returning custom representations of cell values.  If not set then <see cref=""object.ToString()""/> is used.  Return values from your delegate may be truncated e.g. based on <see cref=""MaxWidth""/>
	|            /// </summary>
	|            public Func<object, string> RepresentationGetter;
	|
	|            /// <summary>
	|            /// Defines a delegate for returning a custom color scheme per cell based on cell values.
	|            /// Return null for the default
	|            /// </summary>
	|            public CellColorGetterDelegate ColorGetter;
	|            private bool visible = true;
	|
	|            /// <summary>
	|            /// Defines the format for values e.g. ""yyyy-MM-dd"" for dates
	|            /// </summary>
	|            public string Format { get; set; }
	|
	|            /// <summary>
	|            /// Set the maximum width of the column in characters.  This value will be ignored if more than the tables <see cref=""TableView.MaxCellWidth""/>.  Defaults to <see cref=""TableView.DefaultMaxCellWidth""/>
	|            /// </summary>
	|            public int MaxWidth { get; set; } = TableView.DefaultMaxCellWidth;
	|
	|            /// <summary>
	|            /// Set the minimum width of the column in characters.  Setting this will ensure that
	|            /// even when a column has short content/header it still fills a given width of the control.
	|            /// 
	|            /// <para>This value will be ignored if more than the tables <see cref=""TableView.MaxCellWidth""/> 
	|            /// or the <see cref=""MaxWidth""/>
	|            /// </para>
	|            /// <remarks>
	|            /// For setting a flexible column width (down to a lower limit) use <see cref=""MinAcceptableWidth""/>
	|            /// instead
	|            /// </remarks>
	|            /// </summary>
	|            public int MinWidth { get; set; }
	|
	|            /// <summary>
	|            /// Enables flexible sizing of this column based on available screen space to render into.
	|            /// </summary>
	|            public int MinAcceptableWidth { get; set; } = DefaultMinAcceptableWidth;
	|
	|            /// <summary>
	|            /// Gets or Sets a value indicating whether the column should be visible to the user.
	|            /// This affects both whether it is rendered and whether it can be selected. Defaults to
	|            /// true.
	|            /// </summary>
	|            /// <remarks>If <see cref=""MaxWidth""/> is 0 then <see cref=""Visible""/> will always return false.</remarks>
	|            public bool Visible { get => MaxWidth >= 0 && visible; set => visible = value; }
	|
	|
	|            /// <summary>
	|            /// Returns the alignment for the cell based on <paramref name=""cellValue""/> and <see cref=""AlignmentGetter""/>/<see cref=""Alignment""/>
	|            /// </summary>
	|            /// <param name=""cellValue""></param>
	|            /// <returns></returns>
	|            public TextAlignment GetAlignment(object cellValue)
	|            {
	|                if (AlignmentGetter != null)
	|                    return AlignmentGetter(cellValue);
	|
	|                return Alignment;
	|            }
	|
	|            /// <summary>
	|            /// Returns the full string to render (which may be truncated if too long) that the current style says best represents the given <paramref name=""value""/>
	|            /// </summary>
	|            /// <param name=""value""></param>
	|            /// <returns></returns>
	|            public string GetRepresentation(object value)
	|            {
	|                if (!string.IsNullOrWhiteSpace(Format))
	|                {
	|
	|                    if (value is IFormattable f)
	|                        return f.ToString(Format, null);
	|                }
	|
	|
	|                if (RepresentationGetter != null)
	|                    return RepresentationGetter(value);
	|
	|                return value?.ToString();
	|            }
	|        }
	|        /// <summary>
	|        /// Defines rendering options that affect how the table is displayed.
	|        /// 
	|        /// <a href=""https://gui-cs.github.io/Terminal.Gui/articles/tableview.html"">See TableView Deep Dive for more information</a>.
	|        /// </summary>
	|        public class TableStyle
	|        {
	|
	|            /// <summary>
	|            /// When scrolling down always lock the column headers in place as the first row of the table
	|            /// </summary>
	|            public bool AlwaysShowHeaders { get; set; } = false;
	|
	|            /// <summary>
	|            /// True to render a solid line above the headers
	|            /// </summary>
	|            public bool ShowHorizontalHeaderOverline { get; set; } = true;
	|
	|            /// <summary>
	|            /// True to render a solid line under the headers
	|            /// </summary>
	|            public bool ShowHorizontalHeaderUnderline { get; set; } = true;
	|
	|            /// <summary>
	|            /// True to render a solid line vertical line between cells
	|            /// </summary>
	|            public bool ShowVerticalCellLines { get; set; } = true;
	|
	|            /// <summary>
	|            /// True to render a solid line vertical line between headers
	|            /// </summary>
	|            public bool ShowVerticalHeaderLines { get; set; } = true;
	|
	|            /// <summary>
	|            /// True to render a arrows on the right/left of the table when 
	|            /// there are more column(s) that can be scrolled to.  Requires
	|            /// <see cref=""ShowHorizontalHeaderUnderline""/> to be true.
	|            /// Defaults to true
	|            /// </summary>
	|            public bool ShowHorizontalScrollIndicators { get; set; } = true;
	|
	|            /// <summary>
	|            /// True to invert the colors of the first symbol of the selected cell in the <see cref=""TableView""/>.
	|            /// This gives the appearance of a cursor for when the <see cref=""ConsoleDriver""/> doesn't otherwise show
	|            /// this
	|            /// </summary>
	|            public bool InvertSelectedCellFirstCharacter { get; set; } = false;
	|
	|            /// <summary>
	|            /// Collection of columns for which you want special rendering (e.g. custom column lengths, text alignment etc)
	|            /// </summary>
	|            public Dictionary<DataColumn, ColumnStyle> ColumnStyles { get; set; } = new Dictionary<DataColumn, ColumnStyle>();
	|
	|            /// <summary>
	|            /// Delegate for coloring specific rows in a different color.  For cell color <see cref=""ColumnStyle.ColorGetter""/>
	|            /// </summary>
	|            /// <value></value>
	|            public RowColorGetterDelegate RowColorGetter { get; set; }
	|
	|            /// <summary>
	|            /// Determines rendering when the last column in the table is visible but it's
	|            /// content or <see cref=""ColumnStyle.MaxWidth""/> is less than the remaining 
	|            /// space in the control.  True (the default) will expand the column to fill
	|            /// the remaining bounds of the control.  False will draw a column ending line
	|            /// and leave a blank column that cannot be selected in the remaining space.  
	|            /// </summary>
	|            /// <value></value>
	|            public bool ExpandLastColumn { get; set; } = true;
	|
	|            /// <summary>
	|            /// <para>
	|            /// Determines how <see cref=""TableView.ColumnOffset""/> is updated when scrolling
	|            /// right off the end of the currently visible area.
	|            /// </para>
	|            /// <para>
	|            /// If true then when scrolling right the scroll offset is increased the minimum required to show
	|            /// the new column.  This may be slow if you have an incredibly large number of columns in
	|            /// your table and/or slow <see cref=""ColumnStyle.RepresentationGetter""/> implementations
	|            /// </para>
	|            /// <para>
	|            /// If false then scroll offset is set to the currently selected column (i.e. PageRight).
	|            /// </para>
	|            /// </summary>
	|            public bool SmoothHorizontalScrolling { get; set; } = true;
	|
	|            /// <summary>
	|            /// Returns the entry from <see cref=""ColumnStyles""/> for the given <paramref name=""col""/> or null if no custom styling is defined for it
	|            /// </summary>
	|            /// <param name=""col""></param>
	|            /// <returns></returns>
	|            public ColumnStyle GetColumnStyleIfAny(DataColumn col)
	|            {
	|                return ColumnStyles.TryGetValue(col, out ColumnStyle result) ? result : null;
	|            }
	|
	|            /// <summary>
	|            /// Returns an existing <see cref=""ColumnStyle""/> for the given <paramref name=""col""/> or creates a new one with default options
	|            /// </summary>
	|            /// <param name=""col""></param>
	|            /// <returns></returns>
	|            public ColumnStyle GetOrCreateColumnStyle(DataColumn col)
	|            {
	|                if (!ColumnStyles.ContainsKey(col))
	|                    ColumnStyles.Add(col, new ColumnStyle());
	|
	|                return ColumnStyles[col];
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Describes a desire to render a column at a given horizontal position in the UI
	|        /// </summary>
	|        internal class ColumnToRender
	|        {
	|
	|            /// <summary>
	|            /// The column to render
	|            /// </summary>
	|            public DataColumn Column { get; set; }
	|
	|            /// <summary>
	|            /// The horizontal position to begin rendering the column at
	|            /// </summary>
	|            public int X { get; set; }
	|
	|            /// <summary>
	|            /// The width that the column should occupy as calculated by <see cref=""CalculateViewport(Rect, int)""/>.  Note that this includes
	|            /// space for padding i.e. the separator between columns.
	|            /// </summary>
	|            public int Width { get; }
	|
	|            /// <summary>
	|            /// True if this column is the very last column in the <see cref=""Table""/> (not just the last visible column)
	|            /// </summary>
	|            public bool IsVeryLast { get; }
	|
	|            public ColumnToRender(DataColumn col, int x, int width, bool isVeryLast)
	|            {
	|                Column = col;
	|                X = x;
	|                Width = width;
	|                IsVeryLast = isVeryLast;
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Arguments for a <see cref=""CellColorGetterDelegate""/>.  Describes a cell for which a rendering
	|        /// <see cref=""ColorScheme""/> is being sought
	|        /// </summary>
	|        public class CellColorGetterArgs
	|        {
	|
	|            /// <summary>
	|            /// The data table hosted by the <see cref=""TableView""/> control.
	|            /// </summary>
	|            public DataTable Table { get; }
	|
	|            /// <summary>
	|            /// The index of the row in <see cref=""Table""/> for which color is needed
	|            /// </summary>
	|            public int RowIndex { get; }
	|
	|            /// <summary>
	|            /// The index of column in <see cref=""Table""/> for which color is needed
	|            /// </summary>
	|            public int ColIdex { get; }
	|
	|            /// <summary>
	|            /// The hard typed value being rendered in the cell for which color is needed
	|            /// </summary>
	|            public object CellValue { get; }
	|
	|            /// <summary>
	|            /// The textual representation of <see cref=""CellValue""/> (what will actually be drawn to the screen)
	|            /// </summary>
	|            public string Representation { get; }
	|
	|            /// <summary>
	|            /// the color scheme that is going to be used to render the cell if no cell specific color scheme is returned
	|            /// </summary>
	|            public ColorScheme RowScheme { get; }
	|
	|            internal CellColorGetterArgs(DataTable table, int rowIdx, int colIdx, object cellValue, string representation, ColorScheme rowScheme)
	|            {
	|                Table = table;
	|                RowIndex = rowIdx;
	|                ColIdex = colIdx;
	|                CellValue = cellValue;
	|                Representation = representation;
	|                RowScheme = rowScheme;
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Arguments for <see cref=""RowColorGetterDelegate""/>. Describes a row of data in a <see cref=""DataTable""/>
	|        /// for which <see cref=""ColorScheme""/> is sought.
	|        /// </summary>
	|        public class RowColorGetterArgs
	|        {
	|
	|            /// <summary>
	|            /// The data table hosted by the <see cref=""TableView""/> control.
	|            /// </summary>
	|            public DataTable Table { get; }
	|
	|            /// <summary>
	|            /// The index of the row in <see cref=""Table""/> for which color is needed
	|            /// </summary>
	|            public int RowIndex { get; }
	|
	|            internal RowColorGetterArgs(DataTable table, int rowIdx)
	|            {
	|                Table = table;
	|                RowIndex = rowIdx;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Defines the event arguments for <see cref=""TableView.SelectedCellChanged""/> 
	|        /// </summary>
	|        public class SelectedCellChangedEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// The current table to which the new indexes refer.  May be null e.g. if selection change is the result of clearing the table from the view
	|            /// </summary>
	|            /// <value></value>
	|            public DataTable Table { get; }
	|
	|
	|            /// <summary>
	|            /// The previous selected column index.  May be invalid e.g. when the selection has been changed as a result of replacing the existing Table with a smaller one
	|            /// </summary>
	|            /// <value></value>
	|            public int OldCol { get; }
	|
	|
	|            /// <summary>
	|            /// The newly selected column index.
	|            /// </summary>
	|            /// <value></value>
	|            public int NewCol { get; }
	|
	|
	|            /// <summary>
	|            /// The previous selected row index.  May be invalid e.g. when the selection has been changed as a result of deleting rows from the table
	|            /// </summary>
	|            /// <value></value>
	|            public int OldRow { get; }
	|
	|
	|            /// <summary>
	|            /// The newly selected row index.
	|            /// </summary>
	|            /// <value></value>
	|            public int NewRow { get; }
	|
	|            /// <summary>
	|            /// Creates a new instance of arguments describing a change in selected cell in a <see cref=""TableView""/>
	|            /// </summary>
	|            /// <param name=""t""></param>
	|            /// <param name=""oldCol""></param>
	|            /// <param name=""newCol""></param>
	|            /// <param name=""oldRow""></param>
	|            /// <param name=""newRow""></param>
	|            public SelectedCellChangedEventArgs(DataTable t, int oldCol, int newCol, int oldRow, int newRow)
	|            {
	|                Table = t;
	|                OldCol = oldCol;
	|                NewCol = newCol;
	|                OldRow = oldRow;
	|                NewRow = newRow;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Describes a selected region of the table
	|        /// </summary>
	|        public class TableSelection
	|        {
	|
	|            /// <summary>
	|            /// Corner of the <see cref=""Rect""/> where selection began
	|            /// </summary>
	|            /// <value></value>
	|            public Point Origin { get; set; }
	|
	|            /// <summary>
	|            /// Area selected
	|            /// </summary>
	|            /// <value></value>
	|            public Rect Rect { get; set; }
	|
	|            /// <summary>
	|            /// Creates a new selected area starting at the origin corner and covering the provided rectangular area
	|            /// </summary>
	|            /// <param name=""origin""></param>
	|            /// <param name=""rect""></param>
	|            public TableSelection(Point origin, Rect rect)
	|            {
	|                Origin = origin;
	|                Rect = rect;
	|            }
	|        }
	|        #endregion
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Control that hosts multiple sub views, presenting a single one at once
	|    /// </summary>
	|    public class TabView : View
	|    {
	|        private Tab selectedTab;
	|
	|        /// <summary>
	|        /// The default <see cref=""MaxTabTextWidth""/> to set on new <see cref=""TabView""/> controls
	|        /// </summary>
	|        public const uint DefaultMaxTabTextWidth = 30;
	|
	|        /// <summary>
	|        /// This sub view is the 2 or 3 line control that represents the actual tabs themselves
	|        /// </summary>
	|        TabRowView tabsBar;
	|
	|        private class TabContentView : View { }
	|
	|        /// <summary>
	|        /// This sub view is the main client area of the current tab.  It hosts the <see cref=""Tab.View""/> 
	|        /// of the tab, the <see cref=""SelectedTab""/>
	|        /// </summary>
	|        TabContentView contentView;
	|        private List<Tab> tabs = new List<Tab>();
	|
	|        /// <summary>
	|        /// All tabs currently hosted by the control
	|        /// </summary>
	|        /// <value></value>
	|        public IReadOnlyCollection<Tab> Tabs { get => tabs.AsReadOnly(); }
	|
	|        /// <summary>
	|        /// When there are too many tabs to render, this indicates the first
	|        /// tab to render on the screen.
	|        /// </summary>
	|        /// <value></value>
	|        public int TabScrollOffset { get; set; }
	|
	|        /// <summary>
	|        /// The maximum number of characters to render in a Tab header.  This prevents one long tab 
	|        /// from pushing out all the others.
	|        /// </summary>
	|        public uint MaxTabTextWidth { get; set; } = DefaultMaxTabTextWidth;
	|
	|        /// <summary>
	|        /// Event for when <see cref=""SelectedTab""/> changes
	|        /// </summary>
	|        public event EventHandler<TabChangedEventArgs> SelectedTabChanged;
	|
	|
	|        /// <summary>
	|        /// Event fired when a <see cref=""TabView.Tab""/> is clicked.  Can be used to cancel navigation,
	|        /// show context menu (e.g. on right click) etc.
	|        /// </summary>
	|        public event EventHandler<TabMouseEventArgs> TabClicked;
	|
	|
	|        /// <summary>
	|        /// The currently selected member of <see cref=""Tabs""/> chosen by the user
	|        /// </summary>
	|        /// <value></value>
	|        public Tab SelectedTab
	|        {
	|            get => selectedTab;
	|            set
	|            {
	|
	|                var old = selectedTab;
	|
	|                if (selectedTab != null)
	|                {
	|
	|                    if (selectedTab.View != null)
	|                    {
	|                        // remove old content
	|                        if (selectedTab.View.Subviews.Count == 0)
	|                        {
	|                            contentView.Remove(selectedTab.View);
	|                        }
	|                        else
	|                        {
	|                            foreach (var view in selectedTab.View.Subviews)
	|                            {
	|                                contentView.Remove(view);
	|                            }
	|                        }
	|                    }
	|                }
	|
	|                selectedTab = value;
	|
	|                if (value != null)
	|                {
	|
	|                    // add new content
	|                    if (selectedTab.View != null)
	|                    {
	|                        if (selectedTab.View.Subviews.Count == 0)
	|                        {
	|                            contentView.Add(selectedTab.View);
	|                        }
	|                        else
	|                        {
	|                            foreach (var view in selectedTab.View.Subviews)
	|                            {
	|                                contentView.Add(view);
	|                            }
	|                        }
	|                    }
	|                }
	|
	|                EnsureSelectedTabIsVisible();
	|
	|                if (old != value)
	|                {
	|                    OnSelectedTabChanged(old, value);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Render choices for how to display tabs.  After making changes, call <see cref=""ApplyStyleChanges()""/>
	|        /// </summary>
	|        /// <value></value>
	|        public TabStyle Style { get; set; } = new TabStyle();
	|
	|
	|        /// <summary>
	|        /// Initializes a <see cref=""TabView""/> class using <see cref=""LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        public TabView() : base()
	|        {
	|            CanFocus = true;
	|            contentView = new TabContentView();
	|            tabsBar = new TabRowView(this);
	|
	|            ApplyStyleChanges();
	|
	|            base.Add(tabsBar);
	|            base.Add(contentView);
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.Left, () => { SwitchTabBy(-1); return true; });
	|            AddCommand(Command.Right, () => { SwitchTabBy(1); return true; });
	|            AddCommand(Command.LeftHome, () => { SelectedTab = Tabs.FirstOrDefault(); return true; });
	|            AddCommand(Command.RightEnd, () => { SelectedTab = Tabs.LastOrDefault(); return true; });
	|
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.Home, Command.LeftHome);
	|            AddKeyBinding(Key.End, Command.RightEnd);
	|        }
	|
	|        /// <summary>
	|        /// Updates the control to use the latest state settings in <see cref=""Style""/>.
	|        /// This can change the size of the client area of the tab (for rendering the 
	|        /// selected tab's content).  This method includes a call 
	|        /// to <see cref=""View.SetNeedsDisplay()""/>
	|        /// </summary>
	|        public void ApplyStyleChanges()
	|        {
	|            contentView.X = Style.ShowBorder ? 1 : 0;
	|            contentView.Width = Dim.Fill(Style.ShowBorder ? 1 : 0);
	|
	|            if (Style.TabsOnBottom)
	|            {
	|                // Tabs are along the bottom so just dodge the border
	|                contentView.Y = Style.ShowBorder ? 1 : 0;
	|
	|                // Fill client area leaving space at bottom for tabs
	|                contentView.Height = Dim.Fill(GetTabHeight(false));
	|
	|                var tabHeight = GetTabHeight(false);
	|                tabsBar.Height = tabHeight;
	|
	|                tabsBar.Y = Pos.Percent(100) - tabHeight;
	|
	|            }
	|            else
	|            {
	|
	|                // Tabs are along the top
	|
	|                var tabHeight = GetTabHeight(true);
	|
	|                //move content down to make space for tabs
	|                contentView.Y = tabHeight;
	|
	|                // Fill client area leaving space at bottom for border
	|                contentView.Height = Dim.Fill(Style.ShowBorder ? 1 : 0);
	|
	|                // The top tab should be 2 or 3 rows high and on the top
	|
	|                tabsBar.Height = tabHeight;
	|
	|                // Should be able to just use 0 but switching between top/bottom tabs repeatedly breaks in ValidatePosDim if just using the absolute value 0
	|                tabsBar.Y = Pos.Percent(0);
	|            }
	|
	|
	|            SetNeedsDisplay();
	|        }
	|
	|
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            Move(0, 0);
	|            Driver.SetAttribute(GetNormalColor());
	|
	|            if (Style.ShowBorder)
	|            {
	|
	|                // How much space do we need to leave at the bottom to show the tabs
	|                int spaceAtBottom = Math.Max(0, GetTabHeight(false) - 1);
	|                int startAtY = Math.Max(0, GetTabHeight(true) - 1);
	|
	|                DrawFrame(new Rect(0, startAtY, bounds.Width,
	|                    Math.Max(bounds.Height - spaceAtBottom - startAtY, 0)), 0, true);
	|            }
	|
	|            if (Tabs.Any())
	|            {
	|                tabsBar.Redraw(tabsBar.Bounds);
	|                contentView.SetNeedsDisplay();
	|                var savedClip = contentView.ClipToBounds();
	|                contentView.Redraw(contentView.Bounds);
	|                Driver.Clip = savedClip;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Disposes the control and all <see cref=""Tabs""/>
	|        /// </summary>
	|        /// <param name=""disposing""></param>
	|        protected override void Dispose(bool disposing)
	|        {
	|            base.Dispose(disposing);
	|
	|            // Manually dispose all tabs
	|            foreach (var tab in Tabs)
	|            {
	|                tab.View?.Dispose();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Raises the <see cref=""SelectedTabChanged""/> event
	|        /// </summary>
	|        protected virtual void OnSelectedTabChanged(Tab oldTab, Tab newTab)
	|        {
	|
	|            SelectedTabChanged?.Invoke(this, new TabChangedEventArgs(oldTab, newTab));
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            if (HasFocus && CanFocus && Focused == tabsBar)
	|            {
	|                var result = InvokeKeybindings(keyEvent);
	|                if (result != null)
	|                    return (bool)result;
	|            }
	|
	|            return base.ProcessKey(keyEvent);
	|        }
	|
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedTab""/> by the given <paramref name=""amount""/>.  
	|        /// Positive for right, negative for left.  If no tab is currently selected then
	|        /// the first tab will become selected
	|        /// </summary>
	|        /// <param name=""amount""></param>
	|        public void SwitchTabBy(int amount)
	|        {
	|            if (Tabs.Count == 0)
	|            {
	|                return;
	|            }
	|
	|            // if there is only one tab anyway or nothing is selected
	|            if (Tabs.Count == 1 || SelectedTab == null)
	|            {
	|                SelectedTab = Tabs.ElementAt(0);
	|                SetNeedsDisplay();
	|                return;
	|            }
	|
	|            var currentIdx = Tabs.IndexOf(SelectedTab);
	|
	|            // Currently selected tab has vanished!
	|            if (currentIdx == -1)
	|            {
	|                SelectedTab = Tabs.ElementAt(0);
	|                SetNeedsDisplay();
	|                return;
	|            }
	|
	|            var newIdx = Math.Max(0, Math.Min(currentIdx + amount, Tabs.Count - 1));
	|
	|            SelectedTab = tabs[newIdx];
	|            SetNeedsDisplay();
	|
	|            EnsureSelectedTabIsVisible();
	|        }
	|
	|
	|        /// <summary>
	|        /// Updates <see cref=""TabScrollOffset""/> to be a valid index of <see cref=""Tabs""/>
	|        /// </summary>
	|        /// <remarks>Changes will not be immediately visible in the display until you call <see cref=""View.SetNeedsDisplay()""/></remarks>
	|        public void EnsureValidScrollOffsets()
	|        {
	|            TabScrollOffset = Math.Max(Math.Min(TabScrollOffset, Tabs.Count - 1), 0);
	|        }
	|
	|        /// <summary>
	|        /// Updates <see cref=""TabScrollOffset""/> to ensure that <see cref=""SelectedTab""/> is visible
	|        /// </summary>
	|        public void EnsureSelectedTabIsVisible()
	|        {
	|            if (SelectedTab == null)
	|            {
	|                return;
	|            }
	|
	|            // if current viewport does not include the selected tab
	|            if (!CalculateViewport(Bounds).Any(r => Equals(SelectedTab, r.Tab)))
	|            {
	|
	|                // Set scroll offset so the first tab rendered is the
	|                TabScrollOffset = Math.Max(0, Tabs.IndexOf(SelectedTab));
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the number of rows occupied by rendering the tabs, this depends 
	|        /// on <see cref=""TabStyle.ShowTopLine""/> and can be 0 (e.g. if 
	|        /// <see cref=""TabStyle.TabsOnBottom""/> and you ask for <paramref name=""top""/>).
	|        /// </summary>
	|        /// <param name=""top"">True to measure the space required at the top of the control,
	|        /// false to measure space at the bottom</param>
	|        /// <returns></returns>
	|        private int GetTabHeight(bool top)
	|        {
	|            if (top && Style.TabsOnBottom)
	|            {
	|                return 0;
	|            }
	|
	|            if (!top && !Style.TabsOnBottom)
	|            {
	|                return 0;
	|            }
	|
	|            return Style.ShowTopLine ? 3 : 2;
	|        }
	|
	|
	|        /// <summary>
	|        /// Returns which tabs to render at each x location
	|        /// </summary>
	|        /// <returns></returns>
	|        private IEnumerable<TabToRender> CalculateViewport(Rect bounds)
	|        {
	|            int i = 1;
	|
	|            // Starting at the first or scrolled to tab
	|            foreach (var tab in Tabs.Skip(TabScrollOffset))
	|            {
	|
	|                // while there is space for the tab
	|                var tabTextWidth = tab.Text.Sum(c => Rune.ColumnWidth(c));
	|
	|                string text = tab.Text.ToString();
	|
	|                // The maximum number of characters to use for the tab name as specified
	|                // by the user (MaxTabTextWidth).  But not more than the width of the view
	|                // or we won't even be able to render a single tab!
	|                var maxWidth = Math.Max(0, Math.Min(bounds.Width - 3, MaxTabTextWidth));
	|
	|                // if tab view is width <= 3 don't render any tabs
	|                if (maxWidth == 0)
	|                {
	|                    yield return new TabToRender(i, tab, string.Empty, Equals(SelectedTab, tab), 0);
	|                    break;
	|                }
	|
	|                if (tabTextWidth > maxWidth)
	|                {
	|                    text = tab.Text.ToString().Substring(0, (int)maxWidth);
	|                    tabTextWidth = (int)maxWidth;
	|                }
	|
	|                // if there is not enough space for this tab
	|                if (i + tabTextWidth >= bounds.Width)
	|                {
	|                    break;
	|                }
	|
	|                // there is enough space!
	|                yield return new TabToRender(i, tab, text, Equals(SelectedTab, tab), tabTextWidth);
	|                i += tabTextWidth + 1;
	|            }
	|        }
	|
	|
	|        /// <summary>
	|        /// Adds the given <paramref name=""tab""/> to <see cref=""Tabs""/>
	|        /// </summary>
	|        /// <param name=""tab""></param>
	|        /// <param name=""andSelect"">True to make the newly added Tab the <see cref=""SelectedTab""/></param>
	|        public void AddTab(Tab tab, bool andSelect)
	|        {
	|            if (tabs.Contains(tab))
	|            {
	|                return;
	|            }
	|
	|
	|            tabs.Add(tab);
	|
	|            if (SelectedTab == null || andSelect)
	|            {
	|                SelectedTab = tab;
	|
	|                EnsureSelectedTabIsVisible();
	|
	|                tab.View?.SetFocus();
	|            }
	|
	|            SetNeedsDisplay();
	|        }
	|
	|
	|        /// <summary>
	|        /// Removes the given <paramref name=""tab""/> from <see cref=""Tabs""/>.
	|        /// Caller is responsible for disposing the tab's hosted <see cref=""Tab.View""/>
	|        /// if appropriate.
	|        /// </summary>
	|        /// <param name=""tab""></param>
	|        public void RemoveTab(Tab tab)
	|        {
	|            if (tab == null || !tabs.Contains(tab))
	|            {
	|                return;
	|            }
	|
	|            // what tab was selected before closing
	|            var idx = tabs.IndexOf(tab);
	|
	|            tabs.Remove(tab);
	|
	|            // if the currently selected tab is no longer a member of Tabs
	|            if (SelectedTab == null || !Tabs.Contains(SelectedTab))
	|            {
	|                // select the tab closest to the one that disappeared
	|                var toSelect = Math.Max(idx - 1, 0);
	|
	|                if (toSelect < Tabs.Count)
	|                {
	|                    SelectedTab = Tabs.ElementAt(toSelect);
	|                }
	|                else
	|                {
	|                    SelectedTab = Tabs.LastOrDefault();
	|                }
	|
	|            }
	|
	|            EnsureSelectedTabIsVisible();
	|            SetNeedsDisplay();
	|        }
	|
	|        #region Nested Types
	|
	|        private class TabToRender
	|        {
	|            public int X { get; set; }
	|            public Tab Tab { get; set; }
	|
	|            /// <summary>
	|            /// True if the tab that is being rendered is the selected one
	|            /// </summary>
	|            /// <value></value>
	|            public bool IsSelected { get; set; }
	|            public int Width { get; }
	|            public string TextToRender { get; }
	|
	|            public TabToRender(int x, Tab tab, string textToRender, bool isSelected, int width)
	|            {
	|                X = x;
	|                Tab = tab;
	|                IsSelected = isSelected;
	|                Width = width;
	|                TextToRender = textToRender;
	|            }
	|        }
	|
	|        private class TabRowView : View
	|        {
	|
	|            readonly TabView host;
	|
	|            public TabRowView(TabView host)
	|            {
	|                this.host = host;
	|
	|                CanFocus = true;
	|                Height = 1;
	|                Width = Dim.Fill();
	|            }
	|
	|            public override bool OnEnter(View view)
	|            {
	|                Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|                return base.OnEnter(view);
	|            }
	|
	|            public override void Redraw(Rect bounds)
	|            {
	|                base.Redraw(bounds);
	|
	|                var tabLocations = host.CalculateViewport(bounds).ToArray();
	|                var width = bounds.Width;
	|                Driver.SetAttribute(GetNormalColor());
	|
	|                if (host.Style.ShowTopLine)
	|                {
	|                    RenderOverline(tabLocations, width);
	|                }
	|
	|                RenderTabLine(tabLocations, width);
	|
	|                RenderUnderline(tabLocations, width);
	|                Driver.SetAttribute(GetNormalColor());
	|
	|
	|            }
	|
	|            /// <summary>
	|            /// Renders the line of the tabs that does not adjoin the content
	|            /// </summary>
	|            /// <param name=""tabLocations""></param>
	|            /// <param name=""width""></param>
	|            private void RenderOverline(TabToRender[] tabLocations, int width)
	|            {
	|                // if tabs are on the bottom draw the side of the tab that doesn't border the content area at the bottom otherwise the top
	|                int y = host.Style.TabsOnBottom ? 2 : 0;
	|
	|                Move(0, y);
	|
	|                var selected = tabLocations.FirstOrDefault(t => t.IsSelected);
	|
	|                // Clear out everything
	|                Driver.AddStr(new string(' ', width));
	|
	|                // Nothing is selected... odd but we are done
	|                if (selected == null)
	|                {
	|                    return;
	|                }
	|
	|
	|                Move(selected.X - 1, y);
	|                Driver.AddRune(host.Style.TabsOnBottom ? Driver.LLCorner : Driver.ULCorner);
	|
	|                for (int i = 0; i < selected.Width; i++)
	|                {
	|
	|                    if (selected.X + i > width)
	|                    {
	|                        // we ran out of space horizontally
	|                        return;
	|                    }
	|
	|                    Driver.AddRune(Driver.HLine);
	|                }
	|
	|                // Add the end of the selected tab
	|                Driver.AddRune(host.Style.TabsOnBottom ? Driver.LRCorner : Driver.URCorner);
	|
	|            }
	|
	|            /// <summary>
	|            /// Renders the line with the tab names in it
	|            /// </summary>
	|            /// <param name=""tabLocations""></param>
	|            /// <param name=""width""></param>
	|            private void RenderTabLine(TabToRender[] tabLocations, int width)
	|            {
	|                int y;
	|
	|                if (host.Style.TabsOnBottom)
	|                {
	|
	|                    y = 1;
	|                }
	|                else
	|                {
	|                    y = host.Style.ShowTopLine ? 1 : 0;
	|                }
	|
	|
	|
	|                // clear any old text
	|                Move(0, y);
	|                Driver.AddStr(new string(' ', width));
	|
	|                foreach (var toRender in tabLocations)
	|                {
	|
	|                    if (toRender.IsSelected)
	|                    {
	|                        Move(toRender.X - 1, y);
	|                        Driver.AddRune(Driver.VLine);
	|                    }
	|
	|                    Move(toRender.X, y);
	|
	|                    // if tab is the selected one and focus is inside this control
	|                    if (toRender.IsSelected && host.HasFocus)
	|                    {
	|
	|                        if (host.Focused == this)
	|                        {
	|
	|                            // if focus is the tab bar ourself then show that they can switch tabs
	|                            Driver.SetAttribute(ColorScheme.HotFocus);
	|
	|                        }
	|                        else
	|                        {
	|
	|                            // Focus is inside the tab
	|                            Driver.SetAttribute(ColorScheme.HotNormal);
	|                        }
	|                    }
	|
	|
	|                    Driver.AddStr(toRender.TextToRender);
	|                    Driver.SetAttribute(GetNormalColor());
	|
	|                    if (toRender.IsSelected)
	|                    {
	|                        Driver.AddRune(Driver.VLine);
	|                    }
	|                }
	|            }
	|
	|            /// <summary>
	|            /// Renders the line of the tab that adjoins the content of the tab
	|            /// </summary>
	|            /// <param name=""tabLocations""></param>
	|            /// <param name=""width""></param>
	|            private void RenderUnderline(TabToRender[] tabLocations, int width)
	|            {
	|                int y = GetUnderlineYPosition();
	|
	|                Move(0, y);
	|
	|                // If host has no border then we need to draw the solid line first (then we draw gaps over the top)
	|                if (!host.Style.ShowBorder)
	|                {
	|
	|                    for (int x = 0; x < width; x++)
	|                    {
	|                        Driver.AddRune(Driver.HLine);
	|                    }
	|
	|
	|                }
	|                var selected = tabLocations.FirstOrDefault(t => t.IsSelected);
	|
	|                if (selected == null)
	|                {
	|                    return;
	|                }
	|
	|                Move(selected.X - 1, y);
	|
	|                Driver.AddRune(selected.X == 1 ? Driver.VLine :
	|            (host.Style.TabsOnBottom ? Driver.URCorner : Driver.LRCorner));
	|
	|                Driver.AddStr(new string(' ', selected.Width));
	|
	|
	|                Driver.AddRune(selected.X + selected.Width == width - 1 ?
	|             Driver.VLine :
	|                (host.Style.TabsOnBottom ? Driver.ULCorner : Driver.LLCorner));
	|
	|
	|                // draw scroll indicators
	|
	|                // if there are more tabs to the left not visible
	|                if (host.TabScrollOffset > 0)
	|                {
	|                    Move(0, y);
	|
	|                    // indicate that
	|                    Driver.AddRune(Driver.LeftArrow);
	|                }
	|
	|                // if there are more tabs to the right not visible
	|                if (ShouldDrawRightScrollIndicator(tabLocations))
	|                {
	|                    Move(width - 1, y);
	|
	|                    // indicate that
	|                    Driver.AddRune(Driver.RightArrow);
	|                }
	|            }
	|
	|            private bool ShouldDrawRightScrollIndicator(TabToRender[] tabLocations)
	|            {
	|                return tabLocations.LastOrDefault()?.Tab != host.Tabs.LastOrDefault();
	|            }
	|
	|            private int GetUnderlineYPosition()
	|            {
	|                if (host.Style.TabsOnBottom)
	|                {
	|
	|                    return 0;
	|                }
	|                else
	|                {
	|
	|                    return host.Style.ShowTopLine ? 2 : 1;
	|                }
	|            }
	|
	|            public override bool MouseEvent(MouseEvent me)
	|            {
	|                var hit = ScreenToTab(me.X, me.Y);
	|
	|                bool isClick = me.Flags.HasFlag(MouseFlags.Button1Clicked) ||
	|                    me.Flags.HasFlag(MouseFlags.Button2Clicked) ||
	|                    me.Flags.HasFlag(MouseFlags.Button3Clicked);
	|
	|                if (isClick)
	|                {
	|                    host.OnTabClicked(new TabMouseEventArgs(hit, me));
	|
	|                    // user canceled click
	|                    if (me.Handled)
	|                    {
	|                        return true;
	|                    }
	|                }
	|
	|
	|                if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) &&
	|                !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
	|                !me.Flags.HasFlag(MouseFlags.Button1TripleClicked))
	|                    return false;
	|
	|                if (!HasFocus && CanFocus)
	|                {
	|                    SetFocus();
	|                }
	|
	|
	|                if (me.Flags.HasFlag(MouseFlags.Button1Clicked) ||
	|                me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) ||
	|                me.Flags.HasFlag(MouseFlags.Button1TripleClicked))
	|                {
	|
	|                    var scrollIndicatorHit = ScreenToScrollIndicator(me.X, me.Y);
	|
	|                    if (scrollIndicatorHit != 0)
	|                    {
	|
	|                        host.SwitchTabBy(scrollIndicatorHit);
	|
	|                        SetNeedsDisplay();
	|                        return true;
	|                    }
	|
	|
	|                    if (hit != null)
	|                    {
	|                        host.SelectedTab = hit;
	|                        SetNeedsDisplay();
	|                        return true;
	|                    }
	|                }
	|
	|                return false;
	|            }
	|
	|            /// <summary>
	|            /// Calculates whether scroll indicators are visible and if so whether the click
	|            /// was on one of them.
	|            /// </summary>
	|            /// <param name=""x""></param>
	|            /// <param name=""y""></param>
	|            /// <returns>-1 for click in scroll left, 1 for scroll right or 0 for no hit</returns>
	|            private int ScreenToScrollIndicator(int x, int y)
	|            {
	|                // scroll indicator is showing
	|                if (host.TabScrollOffset > 0 && x == 0)
	|                {
	|
	|                    return y == GetUnderlineYPosition() ? -1 : 0;
	|                }
	|
	|                // scroll indicator is showing
	|                if (x == Bounds.Width - 1 && ShouldDrawRightScrollIndicator(host.CalculateViewport(Bounds).ToArray()))
	|                {
	|
	|                    return y == GetUnderlineYPosition() ? 1 : 0;
	|                }
	|
	|                return 0;
	|            }
	|
	|            /// <summary>
	|            /// Translates the client coordinates of a click into a tab when the click is on top of a tab
	|            /// </summary>
	|            /// <param name=""x""></param>
	|            /// <param name=""y""></param>
	|            /// <returns></returns>
	|            public Tab ScreenToTab(int x, int y)
	|            {
	|                var tabs = host.CalculateViewport(Bounds);
	|
	|                return tabs.LastOrDefault(t => x >= t.X && x < t.X + t.Width)?.Tab;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Raises the <see cref=""TabClicked""/> event.
	|        /// </summary>
	|        /// <param name=""tabMouseEventArgs""></param>
	|        protected virtual private void OnTabClicked(TabMouseEventArgs tabMouseEventArgs)
	|        {
	|            TabClicked?.Invoke(this, tabMouseEventArgs);
	|        }
	|
	|        /// <summary>
	|        /// Describes a mouse event over a specific <see cref=""TabView.Tab""/> in a <see cref=""TabView""/>.
	|        /// </summary>
	|        public class TabMouseEventArgs : EventArgs
	|        {
	|
	|            /// <summary>
	|            /// Gets the <see cref=""TabView.Tab""/> (if any) that the mouse
	|            /// was over when the <see cref=""MouseEvent""/> occurred.
	|            /// </summary>
	|            /// <remarks>This will be null if the click is after last tab
	|            /// or before first.</remarks>
	|            public Tab Tab { get; }
	|
	|            /// <summary>
	|            /// Gets the actual mouse event.  Use <see cref=""MouseEvent.Handled""/> to cancel this event
	|            /// and perform custom behavior (e.g. show a context menu).
	|            /// </summary>
	|            public MouseEvent MouseEvent { get; }
	|
	|            /// <summary>
	|            /// Creates a new instance of the <see cref=""TabMouseEventArgs""/> class.
	|            /// </summary>
	|            /// <param name=""tab""><see cref=""TabView.Tab""/> that the mouse was over when the event occurred.</param>
	|            /// <param name=""mouseEvent"">The mouse activity being reported</param>
	|            public TabMouseEventArgs(Tab tab, MouseEvent mouseEvent)
	|            {
	|                Tab = tab;
	|                MouseEvent = mouseEvent;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// A single tab in a <see cref=""TabView""/>
	|        /// </summary>
	|        public class Tab
	|        {
	|            private ustring text;
	|
	|            /// <summary>
	|            /// The text to display in a <see cref=""TabView""/>
	|            /// </summary>
	|            /// <value></value>
	|            public ustring Text { get => text ?? ""Unamed""; set => text = value; }
	|
	|            /// <summary>
	|            /// The control to display when the tab is selected
	|            /// </summary>
	|            /// <value></value>
	|            public View View { get; set; }
	|
	|            /// <summary>
	|            /// Creates a new unamed tab with no controls inside
	|            /// </summary>
	|            public Tab()
	|            {
	|
	|            }
	|
	|            /// <summary>
	|            /// Creates a new tab with the given text hosting a view
	|            /// </summary>
	|            /// <param name=""text""></param>
	|            /// <param name=""view""></param>
	|            public Tab(string text, View view)
	|            {
	|                this.Text = text;
	|                this.View = view;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Describes render stylistic selections of a <see cref=""TabView""/>
	|        /// </summary>
	|        public class TabStyle
	|        {
	|
	|            /// <summary>
	|            /// True to show the top lip of tabs.  False to directly begin with tab text during 
	|            /// rendering.  When true header line occupies 3 rows, when false only 2.
	|            /// Defaults to true.
	|            /// 
	|            /// <para>When <see cref=""TabsOnBottom""/> is enabled this instead applies to the
	|            ///  bottommost line of the control</para>
	|            /// </summary> 
	|            public bool ShowTopLine { get; set; } = true;
	|
	|
	|            /// <summary>
	|            /// True to show a solid box around the edge of the control.  Defaults to true.
	|            /// </summary>
	|            public bool ShowBorder { get; set; } = true;
	|
	|            /// <summary>
	|            /// True to render tabs at the bottom of the view instead of the top
	|            /// </summary>
	|            public bool TabsOnBottom { get; set; } = false;
	|
	|        }
	|
	|        /// <summary>
	|        /// Describes a change in <see cref=""TabView.SelectedTab""/>
	|        /// </summary>
	|        public class TabChangedEventArgs : EventArgs
	|        {
	|
	|            /// <summary>
	|            /// The previously selected tab. May be null
	|            /// </summary>
	|            public Tab OldTab { get; }
	|
	|            /// <summary>
	|            /// The currently selected tab. May be null
	|            /// </summary>
	|            public Tab NewTab { get; }
	|
	|            /// <summary>
	|            /// Documents a tab change
	|            /// </summary>
	|            /// <param name=""oldTab""></param>
	|            /// <param name=""newTab""></param>
	|            public TabChangedEventArgs(Tab oldTab, Tab newTab)
	|            {
	|                OldTab = oldTab;
	|                NewTab = newTab;
	|            }
	|        }
	|        #endregion
	|    }
	|    //=======================================================================
	|    //
	|    // TextField.cs: single-line text editor with Emacs keybindings
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|
	|    /// <summary>
	|    ///   Single-line text entry <see cref=""View""/>
	|    /// </summary>
	|    /// <remarks>
	|    ///   The <see cref=""TextField""/> <see cref=""View""/> provides editing functionality and mouse support.
	|    /// </remarks>
	|    public class TextField : View
	|    {
	|        List<Rune> text;
	|        int first, point;
	|        int selectedStart = -1; // -1 represents there is no text selection.
	|        ustring selectedText;
	|        HistoryText historyText = new HistoryText();
	|        CultureInfo currentCulture;
	|
	|        /// <summary>
	|        /// Tracks whether the text field should be considered ""used"", that is, that the user has moved in the entry, so new input should be appended at the cursor position, rather than clearing the entry
	|        /// </summary>
	|        public bool Used { get; set; }
	|
	|        /// <summary>
	|        /// If set to true its not allow any changes in the text.
	|        /// </summary>
	|        public bool ReadOnly { get; set; } = false;
	|
	|        /// <summary>
	|        /// Changing event, raised before the <see cref=""Text""/> changes and can be canceled or changing the new text.
	|        /// </summary>
	|        public event Action<TextChangingEventArgs> TextChanging;
	|
	|        /// <summary>
	|        ///   Changed event, raised when the text has changed.
	|        /// </summary>
	|        /// <remarks>
	|        ///   This event is raised when the <see cref=""Text""/> changes. 
	|        /// </remarks>
	|        /// <remarks>
	|        ///   The passed <see cref=""EventArgs""/> is a <see cref=""ustring""/> containing the old value. 
	|        /// </remarks>
	|        public event Action<ustring> TextChanged;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""TextField""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        /// <param name=""text"">Initial text contents.</param>
	|        public TextField(string text) : this(ustring.Make(text)) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""TextField""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        public TextField() : this(string.Empty) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""TextField""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        /// <param name=""text"">Initial text contents.</param>
	|        public TextField(ustring text) : base(text)
	|        {
	|            Initialize(text, text.RuneCount + 1);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""TextField""/> class using <see cref=""LayoutStyle.Absolute""/> positioning.
	|        /// </summary>
	|        /// <param name=""x"">The x coordinate.</param>
	|        /// <param name=""y"">The y coordinate.</param>
	|        /// <param name=""w"">The width.</param>
	|        /// <param name=""text"">Initial text contents.</param>
	|        public TextField(int x, int y, int w, ustring text) : base(new Rect(x, y, w, 1))
	|        {
	|            Initialize(text, w);
	|        }
	|
	|        void Initialize(ustring text, int w)
	|        {
	|            Height = 1;
	|
	|            if (text == null)
	|                text = """";
	|
	|            this.text = TextModel.ToRunes(text.Split(""\n"")[0]);
	|            point = text.RuneCount;
	|            first = point > w + 1 ? point - w + 1 : 0;
	|            CanFocus = true;
	|            Used = true;
	|            WantMousePositionReports = true;
	|            savedCursorVisibility = desiredCursorVisibility;
	|
	|            historyText.ChangeText += HistoryText_ChangeText;
	|
	|            Initialized += TextField_Initialized;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.DeleteCharRight, () => { DeleteCharRight(); return true; });
	|            AddCommand(Command.DeleteCharLeft, () => { DeleteCharLeft(); return true; });
	|            AddCommand(Command.LeftHomeExtend, () => { MoveHomeExtend(); return true; });
	|            AddCommand(Command.RightEndExtend, () => { MoveEndExtend(); return true; });
	|            AddCommand(Command.LeftHome, () => { MoveHome(); return true; });
	|            AddCommand(Command.LeftExtend, () => { MoveLeftExtend(); return true; });
	|            AddCommand(Command.RightExtend, () => { MoveRightExtend(); return true; });
	|            AddCommand(Command.WordLeftExtend, () => { MoveWordLeftExtend(); return true; });
	|            AddCommand(Command.WordRightExtend, () => { MoveWordRightExtend(); return true; });
	|            AddCommand(Command.Left, () => { MoveLeft(); return true; });
	|            AddCommand(Command.RightEnd, () => { MoveEnd(); return true; });
	|            AddCommand(Command.Right, () => { MoveRight(); return true; });
	|            AddCommand(Command.CutToEndLine, () => { KillToEnd(); return true; });
	|            AddCommand(Command.CutToStartLine, () => { KillToStart(); return true; });
	|            AddCommand(Command.Undo, () => { UndoChanges(); return true; });
	|            AddCommand(Command.Redo, () => { RedoChanges(); return true; });
	|            AddCommand(Command.WordLeft, () => { MoveWordLeft(); return true; });
	|            AddCommand(Command.WordRight, () => { MoveWordRight(); return true; });
	|            AddCommand(Command.KillWordForwards, () => { KillWordForwards(); return true; });
	|            AddCommand(Command.KillWordBackwards, () => { KillWordBackwards(); return true; });
	|            AddCommand(Command.ToggleOverwrite, () => { SetOverwrite(!Used); return true; });
	|            AddCommand(Command.EnableOverwrite, () => { SetOverwrite(true); return true; });
	|            AddCommand(Command.DisableOverwrite, () => { SetOverwrite(false); return true; });
	|            AddCommand(Command.Copy, () => { Copy(); return true; });
	|            AddCommand(Command.Cut, () => { Cut(); return true; });
	|            AddCommand(Command.Paste, () => { Paste(); return true; });
	|            AddCommand(Command.SelectAll, () => { SelectAll(); return true; });
	|            AddCommand(Command.DeleteAll, () => { DeleteAll(); return true; });
	|            AddCommand(Command.Accept, () => { ShowContextMenu(); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
	|            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);
	|
	|            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
	|            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);
	|
	|            AddKeyBinding(Key.Home | Key.ShiftMask, Command.LeftHomeExtend);
	|            AddKeyBinding(Key.Home | Key.ShiftMask | Key.CtrlMask, Command.LeftHomeExtend);
	|            AddKeyBinding(Key.A | Key.ShiftMask | Key.CtrlMask, Command.LeftHomeExtend);
	|
	|            AddKeyBinding(Key.End | Key.ShiftMask, Command.RightEndExtend);
	|            AddKeyBinding(Key.End | Key.ShiftMask | Key.CtrlMask, Command.RightEndExtend);
	|            AddKeyBinding(Key.E | Key.ShiftMask | Key.CtrlMask, Command.RightEndExtend);
	|
	|            AddKeyBinding(Key.Home, Command.LeftHome);
	|            AddKeyBinding(Key.Home | Key.CtrlMask, Command.LeftHome);
	|            AddKeyBinding(Key.A | Key.CtrlMask, Command.LeftHome);
	|
	|            AddKeyBinding(Key.CursorLeft | Key.ShiftMask, Command.LeftExtend);
	|            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LeftExtend);
	|
	|            AddKeyBinding(Key.CursorRight | Key.ShiftMask, Command.RightExtend);
	|            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.RightExtend);
	|
	|            AddKeyBinding(Key.CursorLeft | Key.ShiftMask | Key.CtrlMask, Command.WordLeftExtend);
	|            AddKeyBinding(Key.CursorUp | Key.ShiftMask | Key.CtrlMask, Command.WordLeftExtend);
	|            AddKeyBinding((Key)((int)'B' + Key.ShiftMask | Key.AltMask), Command.WordLeftExtend);
	|
	|            AddKeyBinding(Key.CursorRight | Key.ShiftMask | Key.CtrlMask, Command.WordRightExtend);
	|            AddKeyBinding(Key.CursorDown | Key.ShiftMask | Key.CtrlMask, Command.WordRightExtend);
	|            AddKeyBinding((Key)((int)'F' + Key.ShiftMask | Key.AltMask), Command.WordRightExtend);
	|
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);
	|
	|            AddKeyBinding(Key.End, Command.RightEnd);
	|            AddKeyBinding(Key.End | Key.CtrlMask, Command.RightEnd);
	|            AddKeyBinding(Key.E | Key.CtrlMask, Command.RightEnd);
	|
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);
	|
	|            AddKeyBinding(Key.K | Key.CtrlMask, Command.CutToEndLine);
	|            AddKeyBinding(Key.K | Key.AltMask, Command.CutToStartLine);
	|
	|            AddKeyBinding(Key.Z | Key.CtrlMask, Command.Undo);
	|            AddKeyBinding(Key.Backspace | Key.AltMask, Command.Undo);
	|
	|            AddKeyBinding(Key.Y | Key.CtrlMask, Command.Redo);
	|
	|            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.WordLeft);
	|            AddKeyBinding(Key.CursorUp | Key.CtrlMask, Command.WordLeft);
	|            AddKeyBinding((Key)((int)'B' + Key.AltMask), Command.WordLeft);
	|
	|            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.WordRight);
	|            AddKeyBinding(Key.CursorDown | Key.CtrlMask, Command.WordRight);
	|            AddKeyBinding((Key)((int)'F' + Key.AltMask), Command.WordRight);
	|
	|            AddKeyBinding(Key.DeleteChar | Key.CtrlMask, Command.KillWordForwards);
	|            AddKeyBinding(Key.Backspace | Key.CtrlMask, Command.KillWordBackwards);
	|            AddKeyBinding(Key.InsertChar, Command.ToggleOverwrite);
	|            AddKeyBinding(Key.C | Key.CtrlMask, Command.Copy);
	|            AddKeyBinding(Key.X | Key.CtrlMask, Command.Cut);
	|            AddKeyBinding(Key.V | Key.CtrlMask, Command.Paste);
	|            AddKeyBinding(Key.T | Key.CtrlMask, Command.SelectAll);
	|
	|            AddKeyBinding(Key.R | Key.CtrlMask, Command.DeleteAll);
	|            AddKeyBinding(Key.D | Key.CtrlMask | Key.ShiftMask, Command.DeleteAll);
	|
	|            currentCulture = Thread.CurrentThread.CurrentUICulture;
	|
	|            ContextMenu = new ContextMenu(this, BuildContextMenuBarItem());
	|            ContextMenu.KeyChanged += ContextMenu_KeyChanged;
	|
	|            AddKeyBinding(ContextMenu.Key, Command.Accept);
	|        }
	|
	|        private MenuBarItem BuildContextMenuBarItem()
	|        {
	|            return new MenuBarItem(new MenuItem[] {
	|                    new MenuItem (Strings.ctxSelectAll, """", () => SelectAll (), null, null, GetKeyFromCommand (Command.SelectAll)),
	|                    new MenuItem (Strings.ctxDeleteAll, """", () => DeleteAll (), null, null, GetKeyFromCommand (Command.DeleteAll)),
	|                    new MenuItem (Strings.ctxCopy, """", () => Copy (), null, null, GetKeyFromCommand (Command.Copy)),
	|                    new MenuItem (Strings.ctxCut, """", () => Cut (), null, null, GetKeyFromCommand (Command.Cut)),
	|                    new MenuItem (Strings.ctxPaste, """", () => Paste (), null, null, GetKeyFromCommand (Command.Paste)),
	|                    new MenuItem (Strings.ctxUndo, """", () => UndoChanges (), null, null, GetKeyFromCommand (Command.Undo)),
	|                    new MenuItem (Strings.ctxRedo, """", () => RedoChanges (), null, null, GetKeyFromCommand (Command.Redo)),
	|                });
	|        }
	|
	|        private void ContextMenu_KeyChanged(Key obj)
	|        {
	|            ReplaceKeyBinding(obj, ContextMenu.Key);
	|        }
	|
	|        private void HistoryText_ChangeText(HistoryText.HistoryTextItem obj)
	|        {
	|            if (obj == null)
	|                return;
	|
	|            Text = ustring.Make(obj?.Lines[obj.CursorPosition.Y]);
	|            CursorPosition = obj.CursorPosition.X;
	|            Adjust();
	|        }
	|
	|        void TextField_Initialized(object sender, EventArgs e)
	|        {
	|            Autocomplete.HostControl = this;
	|            Autocomplete.PopupInsideContainer = false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnLeave(View view)
	|        {
	|            if (Application.MouseGrabView != null && Application.MouseGrabView == this)
	|                Application.UngrabMouse();
	|            //if (SelectedLength != 0 && !(Application.MouseGrabView is MenuBar))
	|            //	ClearAllSelection ();
	|
	|            return base.OnLeave(view);
	|        }
	|
	|        /// <summary>
	|        /// Provides autocomplete context menu based on suggestions at the current cursor
	|        /// position. Populate <see cref=""Autocomplete.AllSuggestions""/> to enable this feature.
	|        /// </summary>
	|        public IAutocomplete Autocomplete { get; protected set; } = new TextFieldAutocomplete();
	|
	|        ///<inheritdoc/>
	|        public override Rect Frame
	|        {
	|            get => base.Frame;
	|            set
	|            {
	|                base.Frame = value;
	|                Adjust();
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Sets or gets the text held by the view.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public new ustring Text
	|        {
	|            get
	|            {
	|                return ustring.Make(text);
	|            }
	|
	|            set
	|            {
	|                var oldText = ustring.Make(text);
	|
	|                if (oldText == value)
	|                    return;
	|
	|                var newText = OnTextChanging(value.Replace(""\t"", """").Split(""\n"")[0]);
	|                if (newText.Cancel)
	|                {
	|                    if (point > text.Count)
	|                    {
	|                        point = text.Count;
	|                    }
	|                    return;
	|                }
	|                ClearAllSelection();
	|                text = TextModel.ToRunes(newText.NewText);
	|
	|                if (!Secret && !historyText.IsFromHistory)
	|                {
	|                    historyText.Add(new List<List<Rune>>() { oldText.ToRuneList() },
	|                        new Point(point, 0));
	|                    historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0)
	|                        , HistoryText.LineStatus.Replaced);
	|                }
	|
	|                TextChanged?.Invoke(oldText);
	|
	|                if (point > text.Count)
	|                {
	|                    point = Math.Max(TextModel.DisplaySize(text, 0).size - 1, 0);
	|                }
	|
	|                Adjust();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Sets the secret property.
	|        /// </summary>
	|        /// <remarks>
	|        ///   This makes the text entry suitable for entering passwords.
	|        /// </remarks>
	|        public bool Secret { get; set; }
	|
	|        /// <summary>
	|        ///    Sets or gets the current cursor position.
	|        /// </summary>
	|        public virtual int CursorPosition
	|        {
	|            get { return point; }
	|            set
	|            {
	|                if (value < 0)
	|                {
	|                    point = 0;
	|                }
	|                else if (value > text.Count)
	|                {
	|                    point = text.Count;
	|                }
	|                else
	|                {
	|                    point = value;
	|                }
	|                PrepareSelection(selectedStart, point - selectedStart);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the left offset position.
	|        /// </summary>
	|        public int ScrollOffset => first;
	|
	|        /// <summary>
	|        /// Indicates whatever the text was changed or not.
	|        /// <see langword=""true""/> if the text was changed <see langword=""false""/> otherwise.
	|        /// </summary>
	|        public bool IsDirty => historyText.IsDirty(Text);
	|
	|        /// <summary>
	|        /// Indicates whatever the text has history changes or not.
	|        /// <see langword=""true""/> if the text has history changes <see langword=""false""/> otherwise.
	|        /// </summary>
	|        public bool HasHistoryChanges => historyText.HasHistoryChanges;
	|
	|        /// <summary>
	|        /// Get the <see cref=""ContextMenu""/> for this view.
	|        /// </summary>
	|        public ContextMenu ContextMenu { get; private set; }
	|
	|        /// <summary>
	|        ///   Sets the cursor position.
	|        /// </summary>
	|        public override void PositionCursor()
	|        {
	|            var col = 0;
	|            for (int idx = first < 0 ? 0 : first; idx < text.Count; idx++)
	|            {
	|                if (idx == point)
	|                    break;
	|                var cols = Rune.ColumnWidth(text[idx]);
	|                TextModel.SetCol(ref col, Frame.Width - 1, cols);
	|            }
	|            var pos = point - first + Math.Min(Frame.X, 0);
	|            var offB = OffSetBackground();
	|            var containerFrame = SuperView?.ViewToScreen(SuperView.Bounds) ?? default;
	|            var thisFrame = ViewToScreen(Bounds);
	|            if (pos > -1 && col >= pos && pos < Frame.Width + offB
	|                && containerFrame.IntersectsWith(thisFrame))
	|            {
	|                RestoreCursorVisibility();
	|                Move(col, 0);
	|            }
	|            else
	|            {
	|                HideCursorVisibility();
	|                if (pos < 0)
	|                {
	|                    Move(pos, 0, false);
	|                }
	|                else
	|                {
	|                    Move(pos - offB, 0, false);
	|                }
	|            }
	|        }
	|
	|        CursorVisibility savedCursorVisibility;
	|
	|        void HideCursorVisibility()
	|        {
	|            if (desiredCursorVisibility != CursorVisibility.Invisible)
	|            {
	|                DesiredCursorVisibility = CursorVisibility.Invisible;
	|            }
	|        }
	|
	|        void RestoreCursorVisibility()
	|        {
	|            if (desiredCursorVisibility != savedCursorVisibility)
	|            {
	|                DesiredCursorVisibility = savedCursorVisibility;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            var selColor = new Attribute(ColorScheme.Focus.Background, ColorScheme.Focus.Foreground);
	|            SetSelectedStartSelectedLength();
	|
	|            Driver.SetAttribute(GetNormalColor());
	|            Move(0, 0);
	|
	|            int p = first;
	|            int col = 0;
	|            int width = Frame.Width + OffSetBackground();
	|            var tcount = text.Count;
	|            var roc = GetReadOnlyColor();
	|            for (int idx = p; idx < tcount; idx++)
	|            {
	|                var rune = text[idx];
	|                var cols = Rune.ColumnWidth(rune);
	|                if (idx == point && HasFocus && !Used && length == 0 && !ReadOnly)
	|                {
	|                    Driver.SetAttribute(selColor);
	|                }
	|                else if (ReadOnly)
	|                {
	|                    Driver.SetAttribute(idx >= start && length > 0 && idx < start + length ? selColor : roc);
	|                }
	|                else if (!HasFocus && Enabled)
	|                {
	|                    Driver.SetAttribute(ColorScheme.Focus);
	|                }
	|                else if (!Enabled)
	|                {
	|                    Driver.SetAttribute(roc);
	|                }
	|                else
	|                {
	|                    Driver.SetAttribute(idx >= start && length > 0 && idx < start + length ? selColor : ColorScheme.Focus);
	|                }
	|                if (col + cols <= width)
	|                {
	|                    Driver.AddRune((Rune)(Secret ? '*' : rune));
	|                }
	|                if (!TextModel.SetCol(ref col, width, cols))
	|                {
	|                    break;
	|                }
	|                if (idx + 1 < tcount && col + Rune.ColumnWidth(text[idx + 1]) > width)
	|                {
	|                    break;
	|                }
	|            }
	|
	|            Driver.SetAttribute(ColorScheme.Focus);
	|            for (int i = col; i < width; i++)
	|            {
	|                Driver.AddRune(' ');
	|            }
	|
	|            PositionCursor();
	|
	|            if (SelectedLength > 0)
	|                return;
	|
	|            // draw autocomplete
	|            Autocomplete.GenerateSuggestions();
	|
	|            var renderAt = new Point(
	|                CursorPosition - ScrollOffset, 0);
	|
	|            Autocomplete.RenderOverlay(renderAt);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override Attribute GetNormalColor()
	|        {
	|            return Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
	|        }
	|
	|        Attribute GetReadOnlyColor()
	|        {
	|            if (ColorScheme.Disabled.Foreground == ColorScheme.Focus.Background)
	|            {
	|                return new Attribute(ColorScheme.Focus.Foreground, ColorScheme.Focus.Background);
	|            }
	|            return new Attribute(ColorScheme.Disabled.Foreground, ColorScheme.Focus.Background);
	|        }
	|
	|        void Adjust()
	|        {
	|            if (!IsAdded)
	|                return;
	|
	|            int offB = OffSetBackground();
	|            if (point < first)
	|            {
	|                first = point;
	|            }
	|            else if (Frame.Width > 0 && (first + point - (Frame.Width + offB) == 0 ||
	|                TextModel.DisplaySize(text, first, point).size >= Frame.Width + offB))
	|            {
	|
	|                first = Math.Max(TextModel.CalculateLeftColumn(text, first,
	|                    point, Frame.Width + offB), 0);
	|            }
	|            SetNeedsDisplay();
	|        }
	|
	|        int OffSetBackground()
	|        {
	|            int offB = 0;
	|            if (SuperView?.Frame.Right - Frame.Right < 0)
	|            {
	|                offB = SuperView.Frame.Right - Frame.Right - 1;
	|            }
	|
	|            return offB;
	|        }
	|
	|        void SetText(List<Rune> newText)
	|        {
	|            Text = ustring.Make(newText);
	|        }
	|
	|        void SetText(IEnumerable<Rune> newText)
	|        {
	|            SetText(newText.ToList());
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool CanFocus
	|        {
	|            get => base.CanFocus;
	|            set { base.CanFocus = value; }
	|        }
	|
	|        void SetClipboard(IEnumerable<Rune> text)
	|        {
	|            if (!Secret)
	|                Clipboard.Contents = ustring.Make(text.ToList());
	|        }
	|
	|        int oldCursorPos;
	|
	|        /// <summary>
	|        /// Processes key presses for the <see cref=""TextField""/>.
	|        /// </summary>
	|        /// <param name=""kb""></param>
	|        /// <returns></returns>
	|        /// <remarks>
	|        /// The <see cref=""TextField""/> control responds to the following keys:
	|        /// <list type=""table"">
	|        ///    <listheader>
	|        ///        <term>Keys</term>
	|        ///        <description>Function</description>
	|        ///    </listheader>
	|        ///    <item>
	|        ///        <term><see cref=""Key.Delete""/>, <see cref=""Key.Backspace""/></term>
	|        ///        <description>Deletes the character before cursor.</description>
	|        ///    </item>
	|        /// </list>
	|        /// </remarks>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            // remember current cursor position
	|            // because the new calculated cursor position is needed to be set BEFORE the change event is triggest
	|            // Needed for the Elmish Wrapper issue https://github.com/DieselMeister/Terminal.Gui.Elmish/issues/2
	|            oldCursorPos = point;
	|
	|            // Give autocomplete first opportunity to respond to key presses
	|            if (SelectedLength == 0 && Autocomplete.ProcessKey(kb))
	|            {
	|                return true;
	|            }
	|
	|            var result = InvokeKeybindings(new KeyEvent(ShortcutHelper.GetModifiersKey(kb),
	|                new KeyModifiers() { Alt = kb.IsAlt, Ctrl = kb.IsCtrl, Shift = kb.IsShift }));
	|            if (result != null)
	|                return (bool)result;
	|
	|            // Ignore other control characters.
	|            if (kb.Key < Key.Space || kb.Key > Key.CharMask)
	|                return false;
	|
	|            if (ReadOnly)
	|                return true;
	|
	|            InsertText(kb);
	|
	|            return true;
	|        }
	|
	|        void InsertText(KeyEvent kb, bool useOldCursorPos = true)
	|        {
	|            historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0));
	|
	|            List<Rune> newText = text;
	|            if (length > 0)
	|            {
	|                newText = DeleteSelectedText();
	|                oldCursorPos = point;
	|            }
	|            if (!useOldCursorPos)
	|            {
	|                oldCursorPos = point;
	|            }
	|            var kbstr = TextModel.ToRunes(ustring.Make((uint)kb.Key));
	|            if (Used)
	|            {
	|                point++;
	|                if (point == newText.Count + 1)
	|                {
	|                    SetText(newText.Concat(kbstr).ToList());
	|                }
	|                else
	|                {
	|                    if (oldCursorPos > newText.Count)
	|                    {
	|                        oldCursorPos = newText.Count;
	|                    }
	|                    SetText(newText.GetRange(0, oldCursorPos).Concat(kbstr).Concat(newText.GetRange(oldCursorPos, Math.Min(newText.Count - oldCursorPos, newText.Count))));
	|                }
	|            }
	|            else
	|            {
	|                SetText(newText.GetRange(0, oldCursorPos).Concat(kbstr).Concat(newText.GetRange(Math.Min(oldCursorPos + 1, newText.Count), Math.Max(newText.Count - oldCursorPos - 1, 0))));
	|                point++;
	|            }
	|            Adjust();
	|        }
	|
	|        void SetOverwrite(bool overwrite)
	|        {
	|            Used = overwrite;
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Deletes word backwards.
	|        /// </summary>
	|        public virtual void KillWordBackwards()
	|        {
	|            ClearAllSelection();
	|            int bw = WordBackward(point);
	|            if (bw != -1)
	|            {
	|                SetText(text.GetRange(0, bw).Concat(text.GetRange(point, text.Count - point)));
	|                point = bw;
	|            }
	|            Adjust();
	|        }
	|
	|        /// <summary>
	|        /// Deletes word forwards.
	|        /// </summary>
	|        public virtual void KillWordForwards()
	|        {
	|            ClearAllSelection();
	|            int fw = WordForward(point);
	|            if (fw != -1)
	|            {
	|                SetText(text.GetRange(0, point).Concat(text.GetRange(fw, text.Count - fw)));
	|            }
	|            Adjust();
	|        }
	|
	|        void MoveWordRight()
	|        {
	|            ClearAllSelection();
	|            int fw = WordForward(point);
	|            if (fw != -1)
	|                point = fw;
	|            Adjust();
	|        }
	|
	|        void MoveWordLeft()
	|        {
	|            ClearAllSelection();
	|            int bw = WordBackward(point);
	|            if (bw != -1)
	|                point = bw;
	|            Adjust();
	|        }
	|
	|        void RedoChanges()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            historyText.Redo();
	|
	|            //if (ustring.IsNullOrEmpty (Clipboard.Contents))
	|            //	return true;
	|            //var clip = TextModel.ToRunes (Clipboard.Contents);
	|            //if (clip == null)
	|            //	return true;
	|
	|            //if (point == text.Count) {
	|            //	point = text.Count;
	|            //	SetText(text.Concat(clip).ToList());
	|            //} else {
	|            //	point += clip.Count;
	|            //	SetText(text.GetRange(0, oldCursorPos).Concat(clip).Concat(text.GetRange(oldCursorPos, text.Count - oldCursorPos)));
	|            //}
	|            //Adjust ();
	|        }
	|
	|        void UndoChanges()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            historyText.Undo();
	|        }
	|
	|        void KillToStart()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            ClearAllSelection();
	|            if (point == 0)
	|                return;
	|            SetClipboard(text.GetRange(0, point));
	|            SetText(text.GetRange(point, text.Count - point));
	|            point = 0;
	|            Adjust();
	|        }
	|
	|        void KillToEnd()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            ClearAllSelection();
	|            if (point >= text.Count)
	|                return;
	|            SetClipboard(text.GetRange(point, text.Count - point));
	|            SetText(text.GetRange(0, point));
	|            Adjust();
	|        }
	|
	|        void MoveRight()
	|        {
	|            ClearAllSelection();
	|            if (point == text.Count)
	|                return;
	|            point++;
	|            Adjust();
	|        }
	|
	|        void MoveEnd()
	|        {
	|            ClearAllSelection();
	|            point = text.Count;
	|            Adjust();
	|        }
	|
	|        void MoveLeft()
	|        {
	|            ClearAllSelection();
	|            if (point > 0)
	|            {
	|                point--;
	|                Adjust();
	|            }
	|        }
	|
	|        void MoveWordRightExtend()
	|        {
	|            if (point < text.Count)
	|            {
	|                int x = start > -1 && start > point ? start : point;
	|                int sfw = WordForward(x);
	|                if (sfw != -1)
	|                    point = sfw;
	|                PrepareSelection(x, sfw - x);
	|            }
	|        }
	|
	|        void MoveWordLeftExtend()
	|        {
	|            if (point > 0)
	|            {
	|                int x = Math.Min(start > -1 && start > point ? start : point, text.Count);
	|                if (x > 0)
	|                {
	|                    int sbw = WordBackward(x);
	|                    if (sbw != -1)
	|                        point = sbw;
	|                    PrepareSelection(x, sbw - x);
	|                }
	|            }
	|        }
	|
	|        void MoveRightExtend()
	|        {
	|            if (point < text.Count)
	|            {
	|                PrepareSelection(point++, 1);
	|            }
	|        }
	|
	|        void MoveLeftExtend()
	|        {
	|            if (point > 0)
	|            {
	|                PrepareSelection(point--, -1);
	|            }
	|        }
	|
	|        void MoveHome()
	|        {
	|            ClearAllSelection();
	|            point = 0;
	|            Adjust();
	|        }
	|
	|        void MoveEndExtend()
	|        {
	|            if (point <= text.Count)
	|            {
	|                int x = point;
	|                point = text.Count;
	|                PrepareSelection(x, point - x);
	|            }
	|        }
	|
	|        void MoveHomeExtend()
	|        {
	|            if (point > 0)
	|            {
	|                int x = point;
	|                point = 0;
	|                PrepareSelection(x, point - x);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Deletes the left character.
	|        /// </summary>
	|        public virtual void DeleteCharLeft(bool useOldCursorPos = true)
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0));
	|
	|            if (length == 0)
	|            {
	|                if (point == 0)
	|                    return;
	|
	|                if (!useOldCursorPos)
	|                {
	|                    oldCursorPos = point;
	|                }
	|                point--;
	|                if (oldCursorPos < text.Count)
	|                {
	|                    SetText(text.GetRange(0, oldCursorPos - 1).Concat(text.GetRange(oldCursorPos, text.Count - oldCursorPos)));
	|                }
	|                else
	|                {
	|                    SetText(text.GetRange(0, oldCursorPos - 1));
	|                }
	|                Adjust();
	|            }
	|            else
	|            {
	|                var newText = DeleteSelectedText();
	|                Text = ustring.Make(newText);
	|                Adjust();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Deletes the right character.
	|        /// </summary>
	|        public virtual void DeleteCharRight()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0));
	|
	|            if (length == 0)
	|            {
	|                if (text.Count == 0 || text.Count == point)
	|                    return;
	|
	|                SetText(text.GetRange(0, point).Concat(text.GetRange(point + 1, text.Count - (point + 1))));
	|                Adjust();
	|            }
	|            else
	|            {
	|                var newText = DeleteSelectedText();
	|                Text = ustring.Make(newText);
	|                Adjust();
	|            }
	|        }
	|
	|        int WordForward(int p)
	|        {
	|            if (p >= text.Count)
	|                return -1;
	|
	|            int i = p + 1;
	|            if (i == text.Count)
	|                return text.Count;
	|
	|            var ti = text[i];
	|            if (Rune.IsLetterOrDigit(ti) && Rune.IsWhiteSpace(text[p]))
	|                return i;
	|
	|            if (Rune.IsPunctuation(ti) || Rune.IsSymbol(ti) || Rune.IsWhiteSpace(ti))
	|            {
	|                for (; i < text.Count; i++)
	|                {
	|                    if (Rune.IsLetterOrDigit(text[i]))
	|                        return i;
	|                }
	|            }
	|            else
	|            {
	|                for (; i < text.Count; i++)
	|                {
	|                    if (!Rune.IsLetterOrDigit(text[i]))
	|                        break;
	|                }
	|                for (; i < text.Count; i++)
	|                {
	|                    if (Rune.IsLetterOrDigit(text[i]) ||
	|                        (Rune.IsPunctuation(text[i]) && Rune.IsWhiteSpace(text[i - 1])))
	|                        break;
	|                }
	|            }
	|
	|            if (i != p)
	|                return Math.Min(i, text.Count);
	|
	|            return -1;
	|        }
	|
	|        int WordBackward(int p)
	|        {
	|            if (p == 0)
	|                return -1;
	|
	|            int i = p - 1;
	|            if (i == 0)
	|                return 0;
	|
	|            var ti = text[i];
	|            var lastValidCol = -1;
	|            if (Rune.IsPunctuation(ti) || Rune.IsSymbol(ti) || Rune.IsWhiteSpace(ti))
	|            {
	|                for (; i >= 0; i--)
	|                {
	|                    if (Rune.IsLetterOrDigit(text[i]))
	|                    {
	|                        lastValidCol = i;
	|                        break;
	|                    }
	|                    if (i - 1 > 0 && !Rune.IsWhiteSpace(text[i]) && Rune.IsWhiteSpace(text[i - 1]))
	|                    {
	|                        return i;
	|                    }
	|                }
	|                for (; i >= 0; i--)
	|                {
	|                    if (!Rune.IsLetterOrDigit(text[i]))
	|                        break;
	|                    lastValidCol = i;
	|                }
	|                if (lastValidCol > -1)
	|                {
	|                    return lastValidCol;
	|                }
	|            }
	|            else
	|            {
	|                for (; i >= 0; i--)
	|                {
	|                    if (!Rune.IsLetterOrDigit(text[i]))
	|                        break;
	|                    lastValidCol = i;
	|                }
	|                if (lastValidCol > -1)
	|                {
	|                    return lastValidCol;
	|                }
	|            }
	|
	|            if (i != p)
	|                return Math.Max(i, 0);
	|
	|            return -1;
	|        }
	|
	|        void ShowContextMenu()
	|        {
	|            if (currentCulture != Thread.CurrentThread.CurrentUICulture)
	|            {
	|
	|                currentCulture = Thread.CurrentThread.CurrentUICulture;
	|
	|                ContextMenu.MenuItems = BuildContextMenuBarItem();
	|            }
	|            ContextMenu.Show();
	|        }
	|
	|        /// <summary>
	|        /// Selects all text.
	|        /// </summary>
	|        public void SelectAll()
	|        {
	|            if (text.Count == 0)
	|            {
	|                return;
	|            }
	|
	|            selectedStart = 0;
	|            MoveEndExtend();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Deletes all text.
	|        /// </summary>
	|        public void DeleteAll()
	|        {
	|            if (text.Count == 0)
	|            {
	|                return;
	|            }
	|
	|            selectedStart = 0;
	|            MoveEndExtend();
	|            DeleteCharLeft();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Start position of the selected text.
	|        /// </summary>
	|        public int SelectedStart
	|        {
	|            get => selectedStart;
	|            set
	|            {
	|                if (value < -1)
	|                {
	|                    selectedStart = -1;
	|                }
	|                else if (value > text.Count)
	|                {
	|                    selectedStart = text.Count;
	|                }
	|                else
	|                {
	|                    selectedStart = value;
	|                }
	|                PrepareSelection(selectedStart, point - selectedStart);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Length of the selected text.
	|        /// </summary>
	|        public int SelectedLength { get => length; }
	|
	|        /// <summary>
	|        /// The selected text.
	|        /// </summary>
	|        public ustring SelectedText
	|        {
	|            get => Secret ? null : selectedText;
	|            private set => selectedText = value;
	|        }
	|
	|        int start, length;
	|        bool isButtonPressed;
	|        bool isButtonReleased = true;
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent ev)
	|        {
	|            if (!ev.Flags.HasFlag(MouseFlags.Button1Pressed) && !ev.Flags.HasFlag(MouseFlags.ReportMousePosition) &&
	|                !ev.Flags.HasFlag(MouseFlags.Button1Released) && !ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
	|                !ev.Flags.HasFlag(MouseFlags.Button1TripleClicked) && !ev.Flags.HasFlag(ContextMenu.MouseFlags))
	|            {
	|                return false;
	|            }
	|
	|            if (!CanFocus)
	|            {
	|                return true;
	|            }
	|
	|            if (!HasFocus && ev.Flags != MouseFlags.ReportMousePosition)
	|            {
	|                SetFocus();
	|            }
	|
	|            // Give autocomplete first opportunity to respond to mouse clicks
	|            if (SelectedLength == 0 && Autocomplete.MouseEvent(ev, true))
	|            {
	|                return true;
	|            }
	|
	|            if (ev.Flags == MouseFlags.Button1Pressed)
	|            {
	|                EnsureHasFocus();
	|                PositionCursor(ev);
	|                if (isButtonReleased)
	|                {
	|                    ClearAllSelection();
	|                }
	|                isButtonReleased = true;
	|                isButtonPressed = true;
	|            }
	|            else if (ev.Flags == (MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) && isButtonPressed)
	|            {
	|                int x = PositionCursor(ev);
	|                isButtonReleased = false;
	|                PrepareSelection(x);
	|                if (Application.MouseGrabView == null)
	|                {
	|                    Application.GrabMouse(this);
	|                }
	|            }
	|            else if (ev.Flags == MouseFlags.Button1Released)
	|            {
	|                isButtonReleased = true;
	|                isButtonPressed = false;
	|                Application.UngrabMouse();
	|            }
	|            else if (ev.Flags == MouseFlags.Button1DoubleClicked)
	|            {
	|                EnsureHasFocus();
	|                int x = PositionCursor(ev);
	|                int sbw = x;
	|                if (x == text.Count || (x > 0 && (char)text[x - 1] != ' ')
	|                    || (x > 0 && (char)text[x] == ' '))
	|                {
	|
	|                    sbw = WordBackward(x);
	|                }
	|                if (sbw != -1)
	|                {
	|                    x = sbw;
	|                    PositionCursor(x);
	|                }
	|                int sfw = WordForward(x);
	|                ClearAllSelection();
	|                if (sfw != -1 && sbw != -1)
	|                {
	|                    point = sfw;
	|                }
	|                PrepareSelection(sbw, sfw - sbw);
	|            }
	|            else if (ev.Flags == MouseFlags.Button1TripleClicked)
	|            {
	|                EnsureHasFocus();
	|                PositionCursor(0);
	|                ClearAllSelection();
	|                PrepareSelection(0, text.Count);
	|            }
	|            else if (ev.Flags == ContextMenu.MouseFlags)
	|            {
	|                ShowContextMenu();
	|            }
	|
	|            SetNeedsDisplay();
	|            return true;
	|
	|            void EnsureHasFocus()
	|            {
	|                if (!HasFocus)
	|                {
	|                    SetFocus();
	|                }
	|            }
	|        }
	|
	|        int PositionCursor(MouseEvent ev)
	|        {
	|            // We could also set the cursor position.
	|            int x;
	|            var pX = TextModel.GetColFromX(text, first, ev.X);
	|            if (text.Count == 0)
	|            {
	|                x = pX - ev.OfX;
	|            }
	|            else
	|            {
	|                x = pX;
	|            }
	|            return PositionCursor(x, false);
	|        }
	|
	|        int PositionCursor(int x, bool getX = true)
	|        {
	|            int pX = x;
	|            if (getX)
	|            {
	|                pX = TextModel.GetColFromX(text, first, x);
	|            }
	|            if (first + pX > text.Count)
	|            {
	|                point = text.Count;
	|            }
	|            else if (first + pX < first)
	|            {
	|                point = 0;
	|            }
	|            else
	|            {
	|                point = first + pX;
	|            }
	|
	|            return point;
	|        }
	|
	|        void PrepareSelection(int x, int direction = 0)
	|        {
	|            x = x + first < -1 ? 0 : x;
	|            selectedStart = selectedStart == -1 && text.Count > 0 && x >= 0 && x <= text.Count ? x : selectedStart;
	|            if (selectedStart > -1)
	|            {
	|                length = Math.Abs(x + direction <= text.Count ? x + direction - selectedStart : text.Count - selectedStart);
	|                SetSelectedStartSelectedLength();
	|                if (start > -1 && length > 0)
	|                {
	|                    selectedText = length > 0 ? ustring.Make(text).ToString().Substring(
	|                        start < 0 ? 0 : start, length > text.Count ? text.Count : length) : """";
	|                    if (first > start)
	|                    {
	|                        first = start;
	|                    }
	|                }
	|                else if (start > -1 && length == 0)
	|                {
	|                    selectedText = null;
	|                }
	|            }
	|            else if (length > 0 || selectedText != null)
	|            {
	|                ClearAllSelection();
	|            }
	|            Adjust();
	|        }
	|
	|        /// <summary>
	|        /// Clear the selected text.
	|        /// </summary>
	|        public void ClearAllSelection()
	|        {
	|            if (selectedStart == -1 && length == 0 && selectedText == """")
	|                return;
	|
	|            selectedStart = -1;
	|            length = 0;
	|            selectedText = null;
	|            start = 0;
	|            length = 0;
	|            SetNeedsDisplay();
	|        }
	|
	|        void SetSelectedStartSelectedLength()
	|        {
	|            if (SelectedStart > -1 && point < SelectedStart)
	|            {
	|                start = point;
	|            }
	|            else
	|            {
	|                start = SelectedStart;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Copy the selected text to the clipboard.
	|        /// </summary>
	|        public virtual void Copy()
	|        {
	|            if (Secret || length == 0)
	|                return;
	|
	|            Clipboard.Contents = SelectedText;
	|        }
	|
	|        /// <summary>
	|        /// Cut the selected text to the clipboard.
	|        /// </summary>
	|        public virtual void Cut()
	|        {
	|            if (ReadOnly || Secret || length == 0)
	|                return;
	|
	|            Clipboard.Contents = SelectedText;
	|            var newText = DeleteSelectedText();
	|            Text = ustring.Make(newText);
	|            Adjust();
	|        }
	|
	|        List<Rune> DeleteSelectedText()
	|        {
	|            ustring actualText = Text;
	|            SetSelectedStartSelectedLength();
	|            int selStart = SelectedStart > -1 ? start : point;
	|            (var _, var len) = TextModel.DisplaySize(text, 0, selStart, false);
	|            (var _, var len2) = TextModel.DisplaySize(text, selStart, selStart + length, false);
	|            (var _, var len3) = TextModel.DisplaySize(text, selStart + length, actualText.RuneCount, false);
	|            var newText = actualText[0, len] +
	|                actualText[len + len2, len + len2 + len3];
	|            ClearAllSelection();
	|            point = selStart >= newText.RuneCount ? newText.RuneCount : selStart;
	|            return newText.ToRuneList();
	|        }
	|
	|        /// <summary>
	|        /// Paste the selected text from the clipboard.
	|        /// </summary>
	|        public virtual void Paste()
	|        {
	|            if (ReadOnly || ustring.IsNullOrEmpty(Clipboard.Contents))
	|            {
	|                return;
	|            }
	|
	|            SetSelectedStartSelectedLength();
	|            int selStart = start == -1 ? CursorPosition : start;
	|            ustring actualText = Text;
	|            (int _, int len) = TextModel.DisplaySize(text, 0, selStart, false);
	|            (var _, var len2) = TextModel.DisplaySize(text, selStart, selStart + length, false);
	|            (var _, var len3) = TextModel.DisplaySize(text, selStart + length, actualText.RuneCount, false);
	|            ustring cbTxt = Clipboard.Contents.Split(""\n"")[0] ?? """";
	|            Text = actualText[0, len] +
	|                cbTxt +
	|                actualText[len + len2, len + len2 + len3];
	|            point = selStart + cbTxt.RuneCount;
	|            ClearAllSelection();
	|            SetNeedsDisplay();
	|            Adjust();
	|        }
	|
	|        /// <summary>
	|        /// Virtual method that invoke the <see cref=""TextChanging""/> event if it's defined.
	|        /// </summary>
	|        /// <param name=""newText"">The new text to be replaced.</param>
	|        /// <returns>Returns the <see cref=""TextChangingEventArgs""/></returns>
	|        public virtual TextChangingEventArgs OnTextChanging(ustring newText)
	|        {
	|            var ev = new TextChangingEventArgs(newText);
	|            TextChanging?.Invoke(ev);
	|            return ev;
	|        }
	|
	|        CursorVisibility desiredCursorVisibility = CursorVisibility.Default;
	|
	|        /// <summary>
	|        /// Get / Set the wished cursor when the field is focused
	|        /// </summary>
	|        public CursorVisibility DesiredCursorVisibility
	|        {
	|            get => desiredCursorVisibility;
	|            set
	|            {
	|                if (desiredCursorVisibility != value && HasFocus)
	|                {
	|                    Application.Driver.SetCursorVisibility(value);
	|                }
	|
	|                desiredCursorVisibility = value;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        /// <summary>
	|        /// Inserts the given <paramref name=""toAdd""/> text at the current cursor position
	|        /// exactly as if the user had just typed it
	|        /// </summary>
	|        /// <param name=""toAdd"">Text to add</param>
	|        /// <param name=""useOldCursorPos"">If uses the <see cref=""oldCursorPos""/>.</param>
	|        public void InsertText(string toAdd, bool useOldCursorPos = true)
	|        {
	|            foreach (var ch in toAdd)
	|            {
	|
	|                Key key;
	|
	|                try
	|                {
	|                    key = (Key)ch;
	|                }
	|                catch (Exception)
	|                {
	|
	|                    throw new ArgumentException($""Cannot insert character '{ch}' because it does not map to a Key"");
	|                }
	|
	|                InsertText(new KeyEvent() { Key = key }, useOldCursorPos);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Allows clearing the <see cref=""HistoryText.HistoryTextItem""/> items updating the original text.
	|        /// </summary>
	|        public void ClearHistoryChanges()
	|        {
	|            historyText.Clear(Text);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// An <see cref=""EventArgs""/> which allows passing a cancelable new text value event.
	|    /// </summary>
	|    public class TextChangingEventArgs : EventArgs
	|    {
	|        /// <summary>
	|        /// The new text to be replaced.
	|        /// </summary>
	|        public ustring NewText { get; set; }
	|        /// <summary>
	|        /// Flag which allows to cancel the new text value.
	|        /// </summary>
	|        public bool Cancel { get; set; }
	|
	|        /// <summary>
	|        /// Initializes a new instance of <see cref=""TextChangingEventArgs""/>
	|        /// </summary>
	|        /// <param name=""newText"">The new <see cref=""TextField.Text""/> to be replaced.</param>
	|        public TextChangingEventArgs(ustring newText)
	|        {
	|            NewText = newText;
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Renders an overlay on another view at a given point that allows selecting
	|    /// from a range of 'autocomplete' options.
	|    /// An implementation on a TextField.
	|    /// </summary>
	|    public class TextFieldAutocomplete : Autocomplete
	|    {
	|
	|        /// <inheritdoc/>
	|        protected override void DeleteTextBackwards()
	|        {
	|            ((TextField)HostControl).DeleteCharLeft(false);
	|        }
	|
	|        /// <inheritdoc/>
	|        protected override string GetCurrentWord(int columnOffset = 0)
	|        {
	|            var host = (TextField)HostControl;
	|            var currentLine = host.Text.ToRuneList();
	|            var cursorPosition = Math.Min(host.CursorPosition + columnOffset, currentLine.Count);
	|            return IdxToWord(currentLine, cursorPosition, columnOffset);
	|        }
	|
	|        /// <inheritdoc/>
	|        protected override void InsertText(string accepted)
	|        {
	|            ((TextField)HostControl).InsertText(accepted, false);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Text alignment enumeration, controls how text is displayed.
	|    /// </summary>
	|    public enum TextAlignment
	|    {
	|        /// <summary>
	|        /// Aligns the text to the left of the frame.
	|        /// </summary>
	|        Left,
	|        /// <summary>
	|        /// Aligns the text to the right side of the frame.
	|        /// </summary>
	|        Right,
	|        /// <summary>
	|        /// Centers the text in the frame.
	|        /// </summary>
	|        Centered,
	|        /// <summary>
	|        /// Shows the text as justified text in the frame.
	|        /// </summary>
	|        Justified
	|    }
	|
	|    /// <summary>
	|    /// Vertical text alignment enumeration, controls how text is displayed.
	|    /// </summary>
	|    public enum VerticalTextAlignment
	|    {
	|        /// <summary>
	|        /// Aligns the text to the top of the frame.
	|        /// </summary>
	|        Top,
	|        /// <summary>
	|        /// Aligns the text to the bottom of the frame.
	|        /// </summary>
	|        Bottom,
	|        /// <summary>
	|        /// Centers the text verticaly in the frame.
	|        /// </summary>
	|        Middle,
	|        /// <summary>
	|        /// Shows the text as justified text in the frame.
	|        /// </summary>
	|        Justified
	|    }
	|
	|    /// TextDirection  [H] = Horizontal  [V] = Vertical
	|    /// =============
	|    /// LeftRight_TopBottom [H] Normal
	|    /// TopBottom_LeftRight [V] Normal
	|    /// 
	|    /// RightLeft_TopBottom [H] Invert Text
	|    /// TopBottom_RightLeft [V] Invert Lines
	|    /// 
	|    /// LeftRight_BottomTop [H] Invert Lines
	|    /// BottomTop_LeftRight [V] Invert Text
	|    /// 
	|    /// RightLeft_BottomTop [H] Invert Text + Invert Lines
	|    /// BottomTop_RightLeft [V] Invert Text + Invert Lines
	|    ///
	|    /// <summary>
	|    /// Text direction enumeration, controls how text is displayed.
	|    /// </summary>
	|    public enum TextDirection
	|    {
	|        /// <summary>
	|        /// Normal horizontal direction.
	|        /// <code>HELLO<br/>WORLD</code>
	|        /// </summary>
	|        LeftRight_TopBottom,
	|        /// <summary>
	|        /// Normal vertical direction.
	|        /// <code>H W<br/>E O<br/>L R<br/>L L<br/>O D</code>
	|        /// </summary>
	|        TopBottom_LeftRight,
	|        /// <summary>
	|        /// This is a horizontal direction. <br/> RTL
	|        /// <code>OLLEH<br/>DLROW</code>
	|        /// </summary>
	|        RightLeft_TopBottom,
	|        /// <summary>
	|        /// This is a vertical direction.
	|        /// <code>W H<br/>O E<br/>R L<br/>L L<br/>D O</code>
	|        /// </summary>
	|        TopBottom_RightLeft,
	|        /// <summary>
	|        /// This is a horizontal direction.
	|        /// <code>WORLD<br/>HELLO</code>
	|        /// </summary>
	|        LeftRight_BottomTop,
	|        /// <summary>
	|        /// This is a vertical direction.
	|        /// <code>O D<br/>L L<br/>L R<br/>E O<br/>H W</code>
	|        /// </summary>
	|        BottomTop_LeftRight,
	|        /// <summary>
	|        /// This is a horizontal direction.
	|        /// <code>DLROW<br/>OLLEH</code>
	|        /// </summary>
	|        RightLeft_BottomTop,
	|        /// <summary>
	|        /// This is a vertical direction.
	|        /// <code>D O<br/>L L<br/>R L<br/>O E<br/>W H</code>
	|        /// </summary>
	|        BottomTop_RightLeft
	|    }
	|
	|    /// <summary>
	|    /// Provides text formatting capabilities for console apps. Supports, hotkeys, horizontal alignment, multiple lines, and word-based line wrap.
	|    /// </summary>
	|    public class TextFormatter
	|    {
	|        List<ustring> lines = new List<ustring>();
	|        ustring text;
	|        TextAlignment textAlignment;
	|        VerticalTextAlignment textVerticalAlignment;
	|        TextDirection textDirection;
	|        Attribute textColor = -1;
	|        bool needsFormat;
	|        Key hotKey;
	|        Size size;
	|
	|        /// <summary>
	|        /// Event invoked when the <see cref=""HotKey""/> is changed.
	|        /// </summary>
	|        public event Action<Key> HotKeyChanged;
	|
	|        /// <summary>
	|        ///   The text to be displayed. This text is never modified.
	|        /// </summary>
	|        public virtual ustring Text
	|        {
	|            get => text;
	|            set
	|            {
	|                text = value;
	|
	|                if (text != null && text.RuneCount > 0 && (Size.Width == 0 || Size.Height == 0 || Size.Width != text.ConsoleWidth))
	|                {
	|                    // Provide a default size (width = length of longest line, height = 1)
	|                    // TODO: It might makes more sense for the default to be width = length of first line?
	|                    Size = new Size(TextFormatter.MaxWidth(Text, int.MaxValue), 1);
	|                }
	|
	|                NeedsFormat = true;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Used by <see cref=""Text""/> to resize the view's <see cref=""View.Bounds""/> with the <see cref=""Size""/>.
	|        /// Setting <see cref=""AutoSize""/> to true only work if the <see cref=""View.Width""/> and <see cref=""View.Height""/> are null or
	|        ///   <see cref=""LayoutStyle.Absolute""/> values and doesn't work with <see cref=""LayoutStyle.Computed""/> layout,
	|        ///   to avoid breaking the <see cref=""Pos""/> and <see cref=""Dim""/> settings.
	|        /// </summary>
	|        public bool AutoSize { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets a flag that determines whether <see cref=""Text""/> will have trailing spaces preserved
	|        /// or not when <see cref=""WordWrap""/> is enabled. If `true` any trailing spaces will be trimmed when
	|        /// either the <see cref=""Text""/> property is changed or when <see cref=""WordWrap""/> is set to `true`.
	|        /// The default is `false`.
	|        /// </summary>
	|        public bool PreserveTrailingSpaces { get; set; }
	|
	|        /// <summary>
	|        /// Controls the horizontal text-alignment property.
	|        /// </summary>
	|        /// <value>The text alignment.</value>
	|        public TextAlignment Alignment
	|        {
	|            get => textAlignment;
	|            set
	|            {
	|                textAlignment = value;
	|                NeedsFormat = true;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Controls the vertical text-alignment property. 
	|        /// </summary>
	|        /// <value>The text vertical alignment.</value>
	|        public VerticalTextAlignment VerticalAlignment
	|        {
	|            get => textVerticalAlignment;
	|            set
	|            {
	|                textVerticalAlignment = value;
	|                NeedsFormat = true;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Controls the text-direction property. 
	|        /// </summary>
	|        /// <value>The text vertical alignment.</value>
	|        public TextDirection Direction
	|        {
	|            get => textDirection;
	|            set
	|            {
	|                textDirection = value;
	|                NeedsFormat = true;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Check if it is a horizontal direction
	|        /// </summary>
	|        public static bool IsHorizontalDirection(TextDirection textDirection)
	|        {
	|            switch (textDirection)
	|            {
	|                case TextDirection.LeftRight_TopBottom:
	|                case TextDirection.LeftRight_BottomTop:
	|                case TextDirection.RightLeft_TopBottom:
	|                case TextDirection.RightLeft_BottomTop:
	|                    return true;
	|                default:
	|                    return false;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Check if it is a vertical direction
	|        /// </summary>
	|        public static bool IsVerticalDirection(TextDirection textDirection)
	|        {
	|            switch (textDirection)
	|            {
	|                case TextDirection.TopBottom_LeftRight:
	|                case TextDirection.TopBottom_RightLeft:
	|                case TextDirection.BottomTop_LeftRight:
	|                case TextDirection.BottomTop_RightLeft:
	|                    return true;
	|                default:
	|                    return false;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Check if it is Left to Right direction
	|        /// </summary>
	|        public static bool IsLeftToRight(TextDirection textDirection)
	|        {
	|            switch (textDirection)
	|            {
	|                case TextDirection.LeftRight_TopBottom:
	|                case TextDirection.LeftRight_BottomTop:
	|                    return true;
	|                default:
	|                    return false;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Check if it is Top to Bottom direction
	|        /// </summary>
	|        public static bool IsTopToBottom(TextDirection textDirection)
	|        {
	|            switch (textDirection)
	|            {
	|                case TextDirection.TopBottom_LeftRight:
	|                case TextDirection.TopBottom_RightLeft:
	|                    return true;
	|                default:
	|                    return false;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///  Gets or sets the size of the area the text will be constrained to when formatted.
	|        /// </summary>
	|        public Size Size
	|        {
	|            get => size;
	|            set
	|            {
	|                size = value;
	|                NeedsFormat = true;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The specifier character for the hotkey (e.g. '_'). Set to '\xffff' to disable hotkey support for this View instance. The default is '\xffff'.
	|        /// </summary>
	|        public Rune HotKeySpecifier { get; set; } = (Rune)0xFFFF;
	|
	|        /// <summary>
	|        /// The position in the text of the hotkey. The hotkey will be rendered using the hot color.
	|        /// </summary>
	|        public int HotKeyPos { get => hotKeyPos; set => hotKeyPos = value; }
	|
	|        /// <summary>
	|        /// Gets the hotkey. Will be an upper case letter or digit.
	|        /// </summary>
	|        public Key HotKey
	|        {
	|            get => hotKey;
	|            internal set
	|            {
	|                if (hotKey != value)
	|                {
	|                    var oldKey = hotKey;
	|                    hotKey = value;
	|                    HotKeyChanged?.Invoke(oldKey);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the cursor position from <see cref=""HotKey""/>. If the <see cref=""HotKey""/> is defined, the cursor will be positioned over it.
	|        /// </summary>
	|        public int CursorPosition { get; set; }
	|
	|        /// <summary>
	|        /// Gets the formatted lines.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        /// Upon a 'get' of this property, if the text needs to be formatted (if <see cref=""NeedsFormat""/> is <c>true</c>)
	|        /// <see cref=""Format(ustring, int, bool, bool, bool, int, TextDirection)""/> will be called internally. 
	|        /// </para>
	|        /// </remarks>
	|        public List<ustring> Lines
	|        {
	|            get
	|            {
	|                // With this check, we protect against subclasses with overrides of Text
	|                if (ustring.IsNullOrEmpty(Text) || Size.IsEmpty)
	|                {
	|                    lines = new List<ustring> {
	|                        ustring.Empty
	|                    };
	|                    NeedsFormat = false;
	|                    return lines;
	|                }
	|
	|                if (NeedsFormat)
	|                {
	|                    var shown_text = text;
	|                    if (FindHotKey(text, HotKeySpecifier, true, out hotKeyPos, out Key newHotKey))
	|                    {
	|                        HotKey = newHotKey;
	|                        shown_text = RemoveHotKeySpecifier(Text, hotKeyPos, HotKeySpecifier);
	|                        shown_text = ReplaceHotKeyWithTag(shown_text, hotKeyPos);
	|                    }
	|
	|                    if (IsVerticalDirection(textDirection))
	|                    {
	|                        var colsWidth = GetSumMaxCharWidth(shown_text, 0, 1);
	|                        lines = Format(shown_text, Size.Height, textVerticalAlignment == VerticalTextAlignment.Justified, Size.Width > colsWidth,
	|                            PreserveTrailingSpaces, 0, textDirection);
	|                        if (!AutoSize)
	|                        {
	|                            colsWidth = GetMaxColsForWidth(lines, Size.Width);
	|                            if (lines.Count > colsWidth)
	|                            {
	|                                lines.RemoveRange(colsWidth, lines.Count - colsWidth);
	|                            }
	|                        }
	|                    }
	|                    else
	|                    {
	|                        lines = Format(shown_text, Size.Width, textAlignment == TextAlignment.Justified, Size.Height > 1,
	|                            PreserveTrailingSpaces, 0, textDirection);
	|                        if (!AutoSize && lines.Count > Size.Height)
	|                        {
	|                            lines.RemoveRange(Size.Height, lines.Count - Size.Height);
	|                        }
	|                    }
	|
	|                    NeedsFormat = false;
	|                }
	|                return lines;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets whether the <see cref=""TextFormatter""/> needs to format the text when <see cref=""Draw(Rect, Attribute, Attribute, Rect, bool)""/> is called.
	|        /// If it is <c>false</c> when Draw is called, the Draw call will be faster.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        /// This is set to true when the properties of <see cref=""TextFormatter""/> are set.
	|        /// </para>
	|        /// </remarks>
	|        public bool NeedsFormat { get => needsFormat; set => needsFormat = value; }
	|
	|        static ustring StripCRLF(ustring str, bool keepNewLine = false)
	|        {
	|            var runes = str.ToRuneList();
	|            for (int i = 0; i < runes.Count; i++)
	|            {
	|                switch (runes[i])
	|                {
	|                    case '\n':
	|                        if (!keepNewLine)
	|                        {
	|                            runes.RemoveAt(i);
	|                        }
	|                        break;
	|
	|                    case '\r':
	|                        if ((i + 1) < runes.Count && runes[i + 1] == '\n')
	|                        {
	|                            runes.RemoveAt(i);
	|                            if (!keepNewLine)
	|                            {
	|                                runes.RemoveAt(i);
	|                            }
	|                            i++;
	|                        }
	|                        else
	|                        {
	|                            if (!keepNewLine)
	|                            {
	|                                runes.RemoveAt(i);
	|                            }
	|                        }
	|                        break;
	|                }
	|            }
	|            return ustring.Make(runes);
	|        }
	|        static ustring ReplaceCRLFWithSpace(ustring str)
	|        {
	|            var runes = str.ToRuneList();
	|            for (int i = 0; i < runes.Count; i++)
	|            {
	|                switch (runes[i])
	|                {
	|                    case '\n':
	|                        runes[i] = (Rune)' ';
	|                        break;
	|
	|                    case '\r':
	|                        if ((i + 1) < runes.Count && runes[i + 1] == '\n')
	|                        {
	|                            runes[i] = (Rune)' ';
	|                            runes.RemoveAt(i + 1);
	|                            i++;
	|                        }
	|                        else
	|                        {
	|                            runes[i] = (Rune)' ';
	|                        }
	|                        break;
	|                }
	|            }
	|            return ustring.Make(runes);
	|        }
	|
	|        /// <summary>
	|        /// Splits all newlines in the <paramref name=""text""/> into a list
	|        /// and supports both CRLF and LF, preserving the ending newline.
	|        /// </summary>
	|        /// <param name=""text"">The text.</param>
	|        /// <returns>A list of text without the newline characters.</returns>
	|        public static List<ustring> SplitNewLine(ustring text)
	|        {
	|            var runes = text.ToRuneList();
	|            var lines = new List<ustring>();
	|            var start = 0;
	|            var end = 0;
	|
	|            for (int i = 0; i < runes.Count; i++)
	|            {
	|                end = i;
	|                switch (runes[i])
	|                {
	|                    case '\n':
	|                        lines.Add(ustring.Make(runes.GetRange(start, end - start)));
	|                        i++;
	|                        start = i;
	|                        break;
	|
	|                    case '\r':
	|                        if ((i + 1) < runes.Count && runes[i + 1] == '\n')
	|                        {
	|                            lines.Add(ustring.Make(runes.GetRange(start, end - start)));
	|                            i += 2;
	|                            start = i;
	|                        }
	|                        else
	|                        {
	|                            lines.Add(ustring.Make(runes.GetRange(start, end - start)));
	|                            i++;
	|                            start = i;
	|                        }
	|                        break;
	|                }
	|            }
	|            if (runes.Count > 0 && lines.Count == 0)
	|            {
	|                lines.Add(ustring.Make(runes));
	|            }
	|            else if (runes.Count > 0 && start < runes.Count)
	|            {
	|                lines.Add(ustring.Make(runes.GetRange(start, runes.Count - start)));
	|            }
	|            else
	|            {
	|                lines.Add(ustring.Make(""""));
	|            }
	|            return lines;
	|        }
	|
	|        /// <summary>
	|        /// Adds trailing whitespace or truncates <paramref name=""text""/>
	|        /// so that it fits exactly <paramref name=""width""/> console units.
	|        /// Note that some unicode characters take 2+ columns
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        /// <param name=""width""></param>
	|        /// <returns></returns>
	|        public static string ClipOrPad(string text, int width)
	|        {
	|            if (string.IsNullOrEmpty(text))
	|                return text;
	|
	|            // if value is not wide enough
	|            if (text.Sum(c => Rune.ColumnWidth(c)) < width)
	|            {
	|
	|                // pad it out with spaces to the given alignment
	|                int toPad = width - (text.Sum(c => Rune.ColumnWidth(c)));
	|
	|                return text + new string(' ', toPad);
	|            }
	|
	|            // value is too wide
	|            return new string(text.TakeWhile(c => (width -= Rune.ColumnWidth(c)) >= 0).ToArray());
	|        }
	|
	|        /// <summary>
	|        /// Formats the provided text to fit within the width provided using word wrapping.
	|        /// </summary>
	|        /// <param name=""text"">The text to word wrap</param>
	|        /// <param name=""width"">The width to contain the text to</param>
	|        /// <param name=""preserveTrailingSpaces"">If <c>true</c>, the wrapped text will keep the trailing spaces.
	|        ///  If <c>false</c>, the trailing spaces will be trimmed.</param>
	|        /// <param name=""tabWidth"">The tab width.</param>
	|        /// <param name=""textDirection"">The text direction.</param>
	|        /// <returns>Returns a list of word wrapped lines.</returns>
	|        /// <remarks>
	|        /// <para>
	|        /// This method does not do any justification.
	|        /// </para>
	|        /// <para>
	|        /// This method strips Newline ('\n' and '\r\n') sequences before processing.
	|        /// </para>
	|        /// </remarks>
	|        public static List<ustring> WordWrap(ustring text, int width, bool preserveTrailingSpaces = false, int tabWidth = 0,
	|            TextDirection textDirection = TextDirection.LeftRight_TopBottom)
	|        {
	|            if (width < 0)
	|            {
	|                throw new ArgumentOutOfRangeException(""Width cannot be negative."");
	|            }
	|
	|            int start = 0, end;
	|            var lines = new List<ustring>();
	|
	|            if (ustring.IsNullOrEmpty(text))
	|            {
	|                return lines;
	|            }
	|
	|            var runes = StripCRLF(text).ToRuneList();
	|            if (!preserveTrailingSpaces)
	|            {
	|                if (IsHorizontalDirection(textDirection))
	|                {
	|                    while ((end = start + Math.Max(GetMaxLengthForWidth(runes.GetRange(start, runes.Count - start), width), 1)) < runes.Count)
	|                    {
	|                        while (runes[end] != ' ' && end > start)
	|                            end--;
	|                        if (end == start)
	|                            end = start + GetMaxLengthForWidth(runes.GetRange(end, runes.Count - end), width);
	|                        lines.Add(ustring.Make(runes.GetRange(start, end - start)));
	|                        start = end;
	|                        if (runes[end] == ' ')
	|                        {
	|                            start++;
	|                        }
	|                    }
	|                }
	|                else
	|                {
	|                    while ((end = start + width) < runes.Count)
	|                    {
	|                        while (runes[end] != ' ' && end > start)
	|                            end--;
	|                        if (end == start)
	|                            end = start + width;
	|                        lines.Add(ustring.Make(runes.GetRange(start, end - start)));
	|                        start = end;
	|                        if (runes[end] == ' ')
	|                        {
	|                            start++;
	|                        }
	|                    }
	|                }
	|            }
	|            else
	|            {
	|                while ((end = start) < runes.Count)
	|                {
	|                    end = GetNextWhiteSpace(start, width, out bool incomplete);
	|                    if (end == 0 && incomplete)
	|                    {
	|                        start = text.RuneCount;
	|                        break;
	|                    }
	|                    lines.Add(ustring.Make(runes.GetRange(start, end - start)));
	|                    start = end;
	|                    if (incomplete)
	|                    {
	|                        start = text.RuneCount;
	|                        break;
	|                    }
	|                }
	|            }
	|
	|            int GetNextWhiteSpace(int from, int cWidth, out bool incomplete, int cLength = 0)
	|            {
	|                var lastFrom = from;
	|                var to = from;
	|                var length = cLength;
	|                incomplete = false;
	|
	|                while (length < cWidth && to < runes.Count)
	|                {
	|                    var rune = runes[to];
	|                    if (IsHorizontalDirection(textDirection))
	|                    {
	|                        length += Rune.ColumnWidth(rune);
	|                    }
	|                    else
	|                    {
	|                        length++;
	|                    }
	|                    if (length > cWidth)
	|                    {
	|                        if (to >= runes.Count || (length > 1 && cWidth <= 1))
	|                        {
	|                            incomplete = true;
	|                        }
	|                        return to;
	|                    }
	|                    if (rune == ' ')
	|                    {
	|                        if (length == cWidth)
	|                        {
	|                            return to + 1;
	|                        }
	|                        else if (length > cWidth)
	|                        {
	|                            return to;
	|                        }
	|                        else
	|                        {
	|                            return GetNextWhiteSpace(to + 1, cWidth, out incomplete, length);
	|                        }
	|                    }
	|                    else if (rune == '\t')
	|                    {
	|                        length += tabWidth + 1;
	|                        if (length == tabWidth && tabWidth > cWidth)
	|                        {
	|                            return to + 1;
	|                        }
	|                        else if (length > cWidth && tabWidth > cWidth)
	|                        {
	|                            return to;
	|                        }
	|                        else
	|                        {
	|                            return GetNextWhiteSpace(to + 1, cWidth, out incomplete, length);
	|                        }
	|                    }
	|                    to++;
	|                }
	|                if (cLength > 0 && to < runes.Count && runes[to] != ' ' && runes[to] != '\t')
	|                {
	|                    return from;
	|                }
	|                else if (cLength > 0 && to < runes.Count && (runes[to] == ' ' || runes[to] == '\t'))
	|                {
	|                    return lastFrom;
	|                }
	|                else
	|                {
	|                    return to;
	|                }
	|            }
	|
	|            if (start < text.RuneCount)
	|            {
	|                lines.Add(ustring.Make(runes.GetRange(start, runes.Count - start)));
	|            }
	|
	|            return lines;
	|        }
	|
	|        /// <summary>
	|        /// Justifies text within a specified width. 
	|        /// </summary>
	|        /// <param name=""text"">The text to justify.</param>
	|        /// <param name=""width"">If the text length is greater that <c>width</c> it will be clipped.</param>
	|        /// <param name=""talign"">Alignment.</param>
	|        /// <param name=""textDirection"">The text direction.</param>
	|        /// <returns>Justified and clipped text.</returns>
	|        public static ustring ClipAndJustify(ustring text, int width, TextAlignment talign, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
	|        {
	|            return ClipAndJustify(text, width, talign == TextAlignment.Justified, textDirection);
	|        }
	|
	|        /// <summary>
	|        /// Justifies text within a specified width. 
	|        /// </summary>
	|        /// <param name=""text"">The text to justify.</param>
	|        /// <param name=""width"">If the text length is greater that <c>width</c> it will be clipped.</param>
	|        /// <param name=""justify"">Justify.</param>
	|        /// <param name=""textDirection"">The text direction.</param>
	|        /// <returns>Justified and clipped text.</returns>
	|        public static ustring ClipAndJustify(ustring text, int width, bool justify, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
	|        {
	|            if (width < 0)
	|            {
	|                throw new ArgumentOutOfRangeException(""Width cannot be negative."");
	|            }
	|            if (ustring.IsNullOrEmpty(text))
	|            {
	|                return text;
	|            }
	|
	|            var runes = text.ToRuneList();
	|            int slen = runes.Count;
	|            if (slen > width)
	|            {
	|                if (IsHorizontalDirection(textDirection))
	|                {
	|                    return ustring.Make(runes.GetRange(0, GetMaxLengthForWidth(text, width)));
	|                }
	|                else
	|                {
	|                    return ustring.Make(runes.GetRange(0, width));
	|                }
	|            }
	|            else
	|            {
	|                if (justify)
	|                {
	|                    return Justify(text, width, ' ', textDirection);
	|                }
	|                else if (IsHorizontalDirection(textDirection) && GetTextWidth(text) > width)
	|                {
	|                    return ustring.Make(runes.GetRange(0, GetMaxLengthForWidth(text, width)));
	|                }
	|                return text;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Justifies the text to fill the width provided. Space will be added between words (demarked by spaces and tabs) to
	|        /// make the text just fit <c>width</c>. Spaces will not be added to the ends.
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        /// <param name=""width""></param>
	|        /// <param name=""spaceChar"">Character to replace whitespace and pad with. For debugging purposes.</param>
	|        /// <param name=""textDirection"">The text direction.</param>
	|        /// <returns>The justified text.</returns>
	|        public static ustring Justify(ustring text, int width, char spaceChar = ' ', TextDirection textDirection = TextDirection.LeftRight_TopBottom)
	|        {
	|            if (width < 0)
	|            {
	|                throw new ArgumentOutOfRangeException(""Width cannot be negative."");
	|            }
	|            if (ustring.IsNullOrEmpty(text))
	|            {
	|                return text;
	|            }
	|
	|            var words = text.Split(ustring.Make(' '));
	|            int textCount;
	|            if (IsHorizontalDirection(textDirection))
	|            {
	|                textCount = words.Sum(arg => GetTextWidth(arg));
	|            }
	|            else
	|            {
	|                textCount = words.Sum(arg => arg.RuneCount);
	|            }
	|            var spaces = words.Length > 1 ? (width - textCount) / (words.Length - 1) : 0;
	|            var extras = words.Length > 1 ? (width - textCount) % (words.Length - 1) : 0;
	|
	|            var s = new System.Text.StringBuilder();
	|            for (int w = 0; w < words.Length; w++)
	|            {
	|                var x = words[w];
	|                s.Append(x);
	|                if (w + 1 < words.Length)
	|                    for (int i = 0; i < spaces; i++)
	|                        s.Append(spaceChar);
	|                if (extras > 0)
	|                {
	|                    for (int i = 0; i < 1; i++)
	|                        s.Append(spaceChar);
	|                    extras--;
	|                }
	|                if (w + 1 == words.Length - 1)
	|                {
	|                    for (int i = 0; i < extras; i++)
	|                        s.Append(spaceChar);
	|                }
	|            }
	|            return ustring.Make(s.ToString());
	|        }
	|
	|        static char[] whitespace = new char[] { ' ', '\t' };
	|        private int hotKeyPos = -1;
	|
	|        /// <summary>
	|        /// Reformats text into lines, applying text alignment and optionally wrapping text to new lines on word boundaries.
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        /// <param name=""width"">The width to bound the text to for word wrapping and clipping.</param>
	|        /// <param name=""talign"">Specifies how the text will be aligned horizontally.</param>
	|        /// <param name=""wordWrap"">If <c>true</c>, the text will be wrapped to new lines as need. If <c>false</c>, forces text to fit a single line. Line breaks are converted to spaces. The text will be clipped to <c>width</c></param>
	|        /// <param name=""preserveTrailingSpaces"">If <c>true</c> and 'wordWrap' also true, the wrapped text will keep the trailing spaces. If <c>false</c>, the trailing spaces will be trimmed.</param>
	|        /// <param name=""tabWidth"">The tab width.</param>
	|        /// <param name=""textDirection"">The text direction.</param>
	|        /// <returns>A list of word wrapped lines.</returns>
	|        /// <remarks>
	|        /// <para>
	|        /// An empty <c>text</c> string will result in one empty line.
	|        /// </para>
	|        /// <para>
	|        /// If <c>width</c> is 0, a single, empty line will be returned.
	|        /// </para>
	|        /// <para>
	|        /// If <c>width</c> is int.MaxValue, the text will be formatted to the maximum width possible. 
	|        /// </para>
	|        /// </remarks>
	|        public static List<ustring> Format(ustring text, int width, TextAlignment talign, bool wordWrap, bool preserveTrailingSpaces = false, int tabWidth = 0, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
	|        {
	|            return Format(text, width, talign == TextAlignment.Justified, wordWrap, preserveTrailingSpaces, tabWidth, textDirection);
	|        }
	|
	|        /// <summary>
	|        /// Reformats text into lines, applying text alignment and optionally wrapping text to new lines on word boundaries.
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        /// <param name=""width"">The width to bound the text to for word wrapping and clipping.</param>
	|        /// <param name=""justify"">Specifies whether the text should be justified.</param>
	|        /// <param name=""wordWrap"">If <c>true</c>, the text will be wrapped to new lines as need. If <c>false</c>, forces text to fit a single line. Line breaks are converted to spaces. The text will be clipped to <c>width</c></param>
	|        /// <param name=""preserveTrailingSpaces"">If <c>true</c> and 'wordWrap' also true, the wrapped text will keep the trailing spaces. If <c>false</c>, the trailing spaces will be trimmed.</param>
	|        /// <param name=""tabWidth"">The tab width.</param>
	|        /// <param name=""textDirection"">The text direction.</param>
	|        /// <returns>A list of word wrapped lines.</returns>
	|        /// <remarks>
	|        /// <para>
	|        /// An empty <c>text</c> string will result in one empty line.
	|        /// </para>
	|        /// <para>
	|        /// If <c>width</c> is 0, a single, empty line will be returned.
	|        /// </para>
	|        /// <para>
	|        /// If <c>width</c> is int.MaxValue, the text will be formatted to the maximum width possible. 
	|        /// </para>
	|        /// </remarks>
	|        public static List<ustring> Format(ustring text, int width, bool justify, bool wordWrap,
	|            bool preserveTrailingSpaces = false, int tabWidth = 0, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
	|        {
	|            if (width < 0)
	|            {
	|                throw new ArgumentOutOfRangeException(""width cannot be negative"");
	|            }
	|            List<ustring> lineResult = new List<ustring>();
	|
	|            if (ustring.IsNullOrEmpty(text) || width == 0)
	|            {
	|                lineResult.Add(ustring.Empty);
	|                return lineResult;
	|            }
	|
	|            if (wordWrap == false)
	|            {
	|                text = ReplaceCRLFWithSpace(text);
	|                lineResult.Add(ClipAndJustify(text, width, justify, textDirection));
	|                return lineResult;
	|            }
	|
	|            var runes = StripCRLF(text, true).ToRuneList();
	|            int runeCount = runes.Count;
	|            int lp = 0;
	|            for (int i = 0; i < runeCount; i++)
	|            {
	|                Rune c = runes[i];
	|                if (c == '\n')
	|                {
	|                    var wrappedLines = WordWrap(ustring.Make(runes.GetRange(lp, i - lp)), width, preserveTrailingSpaces, tabWidth, textDirection);
	|                    foreach (var line in wrappedLines)
	|                    {
	|                        lineResult.Add(ClipAndJustify(line, width, justify, textDirection));
	|                    }
	|                    if (wrappedLines.Count == 0)
	|                    {
	|                        lineResult.Add(ustring.Empty);
	|                    }
	|                    lp = i + 1;
	|                }
	|            }
	|            foreach (var line in WordWrap(ustring.Make(runes.GetRange(lp, runeCount - lp)), width, preserveTrailingSpaces, tabWidth, textDirection))
	|            {
	|                lineResult.Add(ClipAndJustify(line, width, justify, textDirection));
	|            }
	|
	|            return lineResult;
	|        }
	|
	|        /// <summary>
	|        /// Computes the number of lines needed to render the specified text given the width.
	|        /// </summary>
	|        /// <returns>Number of lines.</returns>
	|        /// <param name=""text"">Text, may contain newlines.</param>
	|        /// <param name=""width"">The minimum width for the text.</param>
	|        public static int MaxLines(ustring text, int width)
	|        {
	|            var result = TextFormatter.Format(text, width, false, true);
	|            return result.Count;
	|        }
	|
	|        /// <summary>
	|        /// Computes the maximum width needed to render the text (single line or multiple lines) given a minimum width.
	|        /// </summary>
	|        /// <returns>Max width of lines.</returns>
	|        /// <param name=""text"">Text, may contain newlines.</param>
	|        /// <param name=""width"">The minimum width for the text.</param>
	|        public static int MaxWidth(ustring text, int width)
	|        {
	|            var result = TextFormatter.Format(text, width, false, true);
	|            var max = 0;
	|            result.ForEach(s =>
	|            {
	|                var m = 0;
	|                s.ToRuneList().ForEach(r => m += Math.Max(Rune.ColumnWidth(r), 1));
	|                if (m > max)
	|                {
	|                    max = m;
	|                }
	|            });
	|            return max;
	|        }
	|
	|        /// <summary>
	|        /// Determines the line with the highest width in the 
	|        /// <paramref name=""text""/> if it contains newlines.
	|        /// </summary>
	|        /// <param name=""text"">Text, may contain newlines.</param>
	|        /// <returns>The highest line width.</returns>
	|        public static int MaxWidthLine(ustring text)
	|        {
	|            var result = TextFormatter.SplitNewLine(text);
	|            return result.Max(x => x.ConsoleWidth);
	|        }
	|
	|        /// <summary>
	|        /// Gets the total width of the passed text.
	|        /// </summary>
	|        /// <param name=""text""></param>
	|        /// <returns>The text width.</returns>
	|        public static int GetTextWidth(ustring text)
	|        {
	|            return text.ToRuneList().Sum(r => Math.Max(Rune.ColumnWidth(r), 1));
	|        }
	|
	|        /// <summary>
	|        /// Gets the maximum characters width from the list based on the <paramref name=""startIndex""/>
	|        /// and the <paramref name=""length""/>.
	|        /// </summary>
	|        /// <param name=""lines"">The lines.</param>
	|        /// <param name=""startIndex"">The start index.</param>
	|        /// <param name=""length"">The length.</param>
	|        /// <returns>The maximum characters width.</returns>
	|        public static int GetSumMaxCharWidth(List<ustring> lines, int startIndex = -1, int length = -1)
	|        {
	|            var max = 0;
	|            for (int i = (startIndex == -1 ? 0 : startIndex); i < (length == -1 ? lines.Count : startIndex + length); i++)
	|            {
	|                var runes = lines[i];
	|                if (runes.Length > 0)
	|                    max += runes.Max(r => Math.Max(Rune.ColumnWidth(r), 1));
	|            }
	|            return max;
	|        }
	|
	|        /// <summary>
	|        /// Gets the maximum characters width from the text based on the <paramref name=""startIndex""/>
	|        /// and the <paramref name=""length""/>.
	|        /// </summary>
	|        /// <param name=""text"">The text.</param>
	|        /// <param name=""startIndex"">The start index.</param>
	|        /// <param name=""length"">The length.</param>
	|        /// <returns>The maximum characters width.</returns>
	|        public static int GetSumMaxCharWidth(ustring text, int startIndex = -1, int length = -1)
	|        {
	|            var max = 0;
	|            var runes = text.ToRunes();
	|            for (int i = (startIndex == -1 ? 0 : startIndex); i < (length == -1 ? runes.Length : startIndex + length); i++)
	|            {
	|                max += Math.Max(Rune.ColumnWidth(runes[i]), 1);
	|            }
	|            return max;
	|        }
	|
	|        /// <summary>
	|        /// Gets the index position from the text based on the <paramref name=""width""/>.
	|        /// </summary>
	|        /// <param name=""text"">The text.</param>
	|        /// <param name=""width"">The width.</param>
	|        /// <returns>The index of the text that fit the width.</returns>
	|        public static int GetMaxLengthForWidth(ustring text, int width)
	|        {
	|            var runes = text.ToRuneList();
	|            var runesLength = 0;
	|            var runeIdx = 0;
	|            for (; runeIdx < runes.Count; runeIdx++)
	|            {
	|                var runeWidth = Math.Max(Rune.ColumnWidth(runes[runeIdx]), 1);
	|                if (runesLength + runeWidth > width)
	|                {
	|                    break;
	|                }
	|                runesLength += runeWidth;
	|            }
	|            return runeIdx;
	|        }
	|
	|        /// <summary>
	|        /// Gets the index position from the list based on the <paramref name=""width""/>.
	|        /// </summary>
	|        /// <param name=""runes"">The runes.</param>
	|        /// <param name=""width"">The width.</param>
	|        /// <returns>The index of the list that fit the width.</returns>
	|        public static int GetMaxLengthForWidth(List<Rune> runes, int width)
	|        {
	|            var runesLength = 0;
	|            var runeIdx = 0;
	|            for (; runeIdx < runes.Count; runeIdx++)
	|            {
	|                var runeWidth = Math.Max(Rune.ColumnWidth(runes[runeIdx]), 1);
	|                if (runesLength + runeWidth > width)
	|                {
	|                    break;
	|                }
	|                runesLength += runeWidth;
	|            }
	|            return runeIdx;
	|        }
	|
	|        /// <summary>
	|        /// Gets the index position from the list based on the <paramref name=""width""/>.
	|        /// </summary>
	|        /// <param name=""lines"">The lines.</param>
	|        /// <param name=""width"">The width.</param>
	|        /// <returns>The index of the list that fit the width.</returns>
	|        public static int GetMaxColsForWidth(List<ustring> lines, int width)
	|        {
	|            var runesLength = 0;
	|            var lineIdx = 0;
	|            for (; lineIdx < lines.Count; lineIdx++)
	|            {
	|                var runes = lines[lineIdx].ToRuneList();
	|                var maxRruneWidth = runes.Count > 0
	|                    ? runes.Max(r => Math.Max(Rune.ColumnWidth(r), 1)) : 1;
	|                if (runesLength + maxRruneWidth > width)
	|                {
	|                    break;
	|                }
	|                runesLength += maxRruneWidth;
	|            }
	|            return lineIdx;
	|        }
	|
	|        /// <summary>
	|        ///  Calculates the rectangle required to hold text, assuming no word wrapping.
	|        /// </summary>
	|        /// <param name=""x"">The x location of the rectangle</param>
	|        /// <param name=""y"">The y location of the rectangle</param>
	|        /// <param name=""text"">The text to measure</param>
	|        /// <param name=""direction"">The text direction.</param>
	|        /// <returns></returns>
	|        public static Rect CalcRect(int x, int y, ustring text, TextDirection direction = TextDirection.LeftRight_TopBottom)
	|        {
	|            if (ustring.IsNullOrEmpty(text))
	|            {
	|                return new Rect(new Point(x, y), Size.Empty);
	|            }
	|
	|            int w, h;
	|
	|            if (IsHorizontalDirection(direction))
	|            {
	|                int mw = 0;
	|                int ml = 1;
	|
	|                int cols = 0;
	|                foreach (var rune in text)
	|                {
	|                    if (rune == '\n')
	|                    {
	|                        ml++;
	|                        if (cols > mw)
	|                        {
	|                            mw = cols;
	|                        }
	|                        cols = 0;
	|                    }
	|                    else if (rune != '\r')
	|                    {
	|                        cols++;
	|                        var rw = Rune.ColumnWidth(rune);
	|                        if (rw > 0)
	|                        {
	|                            rw--;
	|                        }
	|                        cols += rw;
	|                    }
	|                }
	|                if (cols > mw)
	|                {
	|                    mw = cols;
	|                }
	|                w = mw;
	|                h = ml;
	|            }
	|            else
	|            {
	|                int vw = 1, cw = 1;
	|                int vh = 0;
	|
	|                int rows = 0;
	|                foreach (var rune in text)
	|                {
	|                    if (rune == '\n')
	|                    {
	|                        vw++;
	|                        if (rows > vh)
	|                        {
	|                            vh = rows;
	|                        }
	|                        rows = 0;
	|                        cw = 1;
	|                    }
	|                    else if (rune != '\r')
	|                    {
	|                        rows++;
	|                        var rw = Rune.ColumnWidth(rune);
	|                        if (cw < rw)
	|                        {
	|                            cw = rw;
	|                            vw++;
	|                        }
	|                    }
	|                }
	|                if (rows > vh)
	|                {
	|                    vh = rows;
	|                }
	|                w = vw;
	|                h = vh;
	|            }
	|
	|            return new Rect(x, y, w, h);
	|        }
	|
	|        /// <summary>
	|        /// Finds the hotkey and its location in text. 
	|        /// </summary>
	|        /// <param name=""text"">The text to look in.</param>
	|        /// <param name=""hotKeySpecifier"">The hotkey specifier (e.g. '_') to look for.</param>
	|        /// <param name=""firstUpperCase"">If <c>true</c> the legacy behavior of identifying the first upper case character as the hotkey will be enabled.
	|        /// Regardless of the value of this parameter, <c>hotKeySpecifier</c> takes precedence.</param>
	|        /// <param name=""hotPos"">Outputs the Rune index into <c>text</c>.</param>
	|        /// <param name=""hotKey"">Outputs the hotKey.</param>
	|        /// <returns><c>true</c> if a hotkey was found; <c>false</c> otherwise.</returns>
	|        public static bool FindHotKey(ustring text, Rune hotKeySpecifier, bool firstUpperCase, out int hotPos, out Key hotKey)
	|        {
	|            if (ustring.IsNullOrEmpty(text) || hotKeySpecifier == (Rune)0xFFFF)
	|            {
	|                hotPos = -1;
	|                hotKey = Key.Unknown;
	|                return false;
	|            }
	|
	|            Rune hot_key = (Rune)0;
	|            int hot_pos = -1;
	|
	|            // Use first hot_key char passed into 'hotKey'.
	|            // TODO: Ignore hot_key of two are provided
	|            // TODO: Do not support non-alphanumeric chars that can't be typed
	|            int i = 0;
	|            foreach (Rune c in text)
	|            {
	|                if ((char)c != 0xFFFD)
	|                {
	|                    if (c == hotKeySpecifier)
	|                    {
	|                        hot_pos = i;
	|                    }
	|                    else if (hot_pos > -1)
	|                    {
	|                        hot_key = c;
	|                        break;
	|                    }
	|                }
	|                i++;
	|            }
	|
	|
	|            // Legacy support - use first upper case char if the specifier was not found
	|            if (hot_pos == -1 && firstUpperCase)
	|            {
	|                i = 0;
	|                foreach (Rune c in text)
	|                {
	|                    if ((char)c != 0xFFFD)
	|                    {
	|                        if (Rune.IsUpper(c))
	|                        {
	|                            hot_key = c;
	|                            hot_pos = i;
	|                            break;
	|                        }
	|                    }
	|                    i++;
	|                }
	|            }
	|
	|            if (hot_key != (Rune)0 && hot_pos != -1)
	|            {
	|                hotPos = hot_pos;
	|
	|                if (hot_key.IsValid && char.IsLetterOrDigit((char)hot_key))
	|                {
	|                    hotKey = (Key)char.ToUpperInvariant((char)hot_key);
	|                    return true;
	|                }
	|            }
	|
	|            hotPos = -1;
	|            hotKey = Key.Unknown;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Replaces the Rune at the index specified by the <c>hotPos</c> parameter with a tag identifying 
	|        /// it as the hotkey.
	|        /// </summary>
	|        /// <param name=""text"">The text to tag the hotkey in.</param>
	|        /// <param name=""hotPos"">The Rune index of the hotkey in <c>text</c>.</param>
	|        /// <returns>The text with the hotkey tagged.</returns>
	|        /// <remarks>
	|        /// The returned string will not render correctly without first un-doing the tag. To undo the tag, search for 
	|        /// </remarks>
	|        public ustring ReplaceHotKeyWithTag(ustring text, int hotPos)
	|        {
	|            // Set the high bit
	|            var runes = text.ToRuneList();
	|            if (Rune.IsLetterOrNumber(runes[hotPos]))
	|            {
	|                runes[hotPos] = new Rune((uint)runes[hotPos]);
	|            }
	|            return ustring.Make(runes);
	|        }
	|
	|        /// <summary>
	|        /// Removes the hotkey specifier from text.
	|        /// </summary>
	|        /// <param name=""text"">The text to manipulate.</param>
	|        /// <param name=""hotKeySpecifier"">The hot-key specifier (e.g. '_') to look for.</param>
	|        /// <param name=""hotPos"">Returns the position of the hot-key in the text. -1 if not found.</param>
	|        /// <returns>The input text with the hotkey specifier ('_') removed.</returns>
	|        public static ustring RemoveHotKeySpecifier(ustring text, int hotPos, Rune hotKeySpecifier)
	|        {
	|            if (ustring.IsNullOrEmpty(text))
	|            {
	|                return text;
	|            }
	|
	|            // Scan 
	|            ustring start = ustring.Empty;
	|            int i = 0;
	|            foreach (Rune c in text)
	|            {
	|                if (c == hotKeySpecifier && i == hotPos)
	|                {
	|                    i++;
	|                    continue;
	|                }
	|                start += ustring.Make(c);
	|                i++;
	|            }
	|            return start;
	|        }
	|
	|        /// <summary>
	|        /// Draws the text held by <see cref=""TextFormatter""/> to <see cref=""Application.Driver""/> using the colors specified.
	|        /// </summary>
	|        /// <param name=""bounds"">Specifies the screen-relative location and maximum size for drawing the text.</param>
	|        /// <param name=""normalColor"">The color to use for all text except the hotkey</param>
	|        /// <param name=""hotColor"">The color to use to draw the hotkey</param>
	|        /// <param name=""containerBounds"">Specifies the screen-relative location and maximum container size.</param>
	|        /// <param name=""fillRemaining"">Determines if the bounds width will be used (default) or only the text width will be used.</param>
	|        public void Draw(Rect bounds, Attribute normalColor, Attribute hotColor, Rect containerBounds = default, bool fillRemaining = true)
	|        {
	|            // With this check, we protect against subclasses with overrides of Text (like Button)
	|            if (ustring.IsNullOrEmpty(text))
	|            {
	|                return;
	|            }
	|
	|            Application.Driver?.SetAttribute(normalColor);
	|
	|            // Use ""Lines"" to ensure a Format (don't use ""lines""))
	|
	|            var linesFormated = Lines;
	|            switch (textDirection)
	|            {
	|                case TextDirection.TopBottom_RightLeft:
	|                case TextDirection.LeftRight_BottomTop:
	|                case TextDirection.RightLeft_BottomTop:
	|                case TextDirection.BottomTop_RightLeft:
	|                    linesFormated.Reverse();
	|                    break;
	|            }
	|
	|            var isVertical = IsVerticalDirection(textDirection);
	|            var maxBounds = containerBounds == default
	|                ? bounds
	|                : new Rect(Math.Max(containerBounds.X, bounds.X),
	|                    Math.Max(containerBounds.Y, bounds.Y),
	|                    Math.Max(Math.Max(containerBounds.Width, containerBounds.Right - bounds.Left), 0),
	|                    Math.Max(Math.Max(containerBounds.Height, containerBounds.Bottom - bounds.Top), 0));
	|
	|            int boundsStart = 0;
	|            if (isVertical)
	|            {
	|                if (bounds.X < 0)
	|                {
	|                    boundsStart = bounds.X;
	|                }
	|            }
	|            else
	|            {
	|                if (bounds.Y < 0)
	|                {
	|                    boundsStart = bounds.Y;
	|                }
	|            }
	|            for (int line = 0; line < linesFormated.Count; line++)
	|            {
	|                if (boundsStart < 0)
	|                {
	|                    boundsStart++;
	|                    continue;
	|                }
	|                if ((isVertical && line > bounds.Width) || (!isVertical && line > bounds.Height))
	|                {
	|                    continue;
	|                }
	|                if ((isVertical && line >= maxBounds.Left + maxBounds.Width)
	|                    || (!isVertical && line >= maxBounds.Top + maxBounds.Height))
	|                {
	|                    break;
	|                }
	|
	|                var runes = lines[line].ToRunes();
	|
	|                switch (textDirection)
	|                {
	|                    case TextDirection.RightLeft_BottomTop:
	|                    case TextDirection.RightLeft_TopBottom:
	|                    case TextDirection.BottomTop_LeftRight:
	|                    case TextDirection.BottomTop_RightLeft:
	|                        runes = runes.Reverse().ToArray();
	|                        break;
	|                }
	|
	|                // When text is justified, we lost left or right, so we use the direction to align. 
	|
	|                int x, y;
	|                // Horizontal Alignment
	|                if (textAlignment == TextAlignment.Right || (textAlignment == TextAlignment.Justified && !IsLeftToRight(textDirection)))
	|                {
	|                    if (isVertical)
	|                    {
	|                        var runesWidth = GetSumMaxCharWidth(Lines, line);
	|                        x = bounds.Right - runesWidth;
	|                        CursorPosition = bounds.Width - runesWidth + (hotKeyPos > -1 ? hotKeyPos : 0);
	|                    }
	|                    else
	|                    {
	|                        var runesWidth = GetTextWidth(ustring.Make(runes));
	|                        x = bounds.Right - runesWidth;
	|                        CursorPosition = bounds.Width - runesWidth + (hotKeyPos > -1 ? hotKeyPos : 0);
	|                    }
	|                }
	|                else if (textAlignment == TextAlignment.Left || textAlignment == TextAlignment.Justified)
	|                {
	|                    if (isVertical)
	|                    {
	|                        var runesWidth = line > 0 ? GetSumMaxCharWidth(Lines, 0, line) : 0;
	|                        x = bounds.Left + runesWidth;
	|                    }
	|                    else
	|                    {
	|                        x = bounds.Left;
	|                    }
	|                    CursorPosition = hotKeyPos > -1 ? hotKeyPos : 0;
	|                }
	|                else if (textAlignment == TextAlignment.Centered)
	|                {
	|                    if (isVertical)
	|                    {
	|                        var runesWidth = GetSumMaxCharWidth(Lines, line);
	|                        x = bounds.Left + line + ((bounds.Width - runesWidth) / 2);
	|                        CursorPosition = (bounds.Width - runesWidth) / 2 + (hotKeyPos > -1 ? hotKeyPos : 0);
	|                    }
	|                    else
	|                    {
	|                        var runesWidth = GetTextWidth(ustring.Make(runes));
	|                        x = bounds.Left + (bounds.Width - runesWidth) / 2;
	|                        CursorPosition = (bounds.Width - runesWidth) / 2 + (hotKeyPos > -1 ? hotKeyPos : 0);
	|                    }
	|                }
	|                else
	|                {
	|                    throw new ArgumentOutOfRangeException();
	|                }
	|
	|                // Vertical Alignment
	|                if (textVerticalAlignment == VerticalTextAlignment.Bottom || (textVerticalAlignment == VerticalTextAlignment.Justified && !IsTopToBottom(textDirection)))
	|                {
	|                    if (isVertical)
	|                    {
	|                        y = bounds.Bottom - runes.Length;
	|                    }
	|                    else
	|                    {
	|                        y = bounds.Bottom - Lines.Count + line;
	|                    }
	|                }
	|                else if (textVerticalAlignment == VerticalTextAlignment.Top || textVerticalAlignment == VerticalTextAlignment.Justified)
	|                {
	|                    if (isVertical)
	|                    {
	|                        y = bounds.Top;
	|                    }
	|                    else
	|                    {
	|                        y = bounds.Top + line;
	|                    }
	|                }
	|                else if (textVerticalAlignment == VerticalTextAlignment.Middle)
	|                {
	|                    if (isVertical)
	|                    {
	|                        var s = (bounds.Height - runes.Length) / 2;
	|                        y = bounds.Top + s;
	|                    }
	|                    else
	|                    {
	|                        var s = (bounds.Height - Lines.Count) / 2;
	|                        y = bounds.Top + line + s;
	|                    }
	|                }
	|                else
	|                {
	|                    throw new ArgumentOutOfRangeException();
	|                }
	|
	|                var start = isVertical ? bounds.Top : bounds.Left;
	|                var size = isVertical ? bounds.Height : bounds.Width;
	|                var current = start;
	|
	|                for (var idx = (isVertical ? start - y : start - x); current < start + size; idx++)
	|                {
	|                    if (!fillRemaining && idx < 0)
	|                    {
	|                        current++;
	|                        continue;
	|                    }
	|                    else if (!fillRemaining && idx > runes.Length - 1)
	|                    {
	|                        break;
	|                    }
	|                    if ((!isVertical && idx >= maxBounds.Left + maxBounds.Width - bounds.X) || (isVertical && idx >= maxBounds.Top + maxBounds.Height - bounds.Y))
	|                    {
	|                        break;
	|                    }
	|
	|                    var rune = (Rune)' ';
	|                    if (isVertical)
	|                    {
	|                        Application.Driver?.Move(x, current);
	|                        if (idx >= 0 && idx < runes.Length)
	|                        {
	|                            rune = runes[idx];
	|                        }
	|                    }
	|                    else
	|                    {
	|                        Application.Driver?.Move(current, y);
	|                        if (idx >= 0 && idx < runes.Length)
	|                        {
	|                            rune = runes[idx];
	|                        }
	|                    }
	|                    if (HotKeyPos > -1 && idx == HotKeyPos)
	|                    {
	|                        if ((isVertical && textVerticalAlignment == VerticalTextAlignment.Justified) ||
	|                        (!isVertical && textAlignment == TextAlignment.Justified))
	|                        {
	|                            CursorPosition = idx - start;
	|                        }
	|                        Application.Driver?.SetAttribute(hotColor);
	|                        Application.Driver?.AddRune(rune);
	|                        Application.Driver?.SetAttribute(normalColor);
	|                    }
	|                    else
	|                    {
	|                        Application.Driver?.AddRune(rune);
	|                    }
	|                    var runeWidth = Math.Max(Rune.ColumnWidth(rune), 1);
	|                    if (isVertical)
	|                    {
	|                        current++;
	|                    }
	|                    else
	|                    {
	|                        current += runeWidth;
	|                    }
	|                    var nextRuneWidth = idx + 1 > -1 && idx + 1 < runes.Length ? Rune.ColumnWidth(runes[idx + 1]) : 0;
	|                    if (!isVertical && idx + 1 < runes.Length && current + nextRuneWidth > start + size)
	|                    {
	|                        break;
	|                    }
	|                }
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // TextValidateField.cs: single-line text editor with validation through providers.
	|    //
	|    // Authors:
	|    //	José Miguel Perricone (jmperricone@hotmail.com)
	|    //
	|
	|    namespace TextValidateProviders
	|    {
	|        /// <summary>
	|        /// TextValidateField Providers Interface.
	|        /// All TextValidateField are created with a ITextValidateProvider.
	|        /// </summary>
	|        public interface ITextValidateProvider
	|        {
	|            /// <summary>
	|            /// Set that this provider uses a fixed width.
	|            /// e.g. Masked ones are fixed.
	|            /// </summary>
	|            bool Fixed { get; }
	|
	|            /// <summary>
	|            /// Set Cursor position to <paramref name=""pos""/>.
	|            /// </summary>
	|            /// <param name=""pos""></param>
	|            /// <returns>Return first valid position.</returns>
	|            int Cursor(int pos);
	|
	|            /// <summary>
	|            /// First valid position before <paramref name=""pos""/>.
	|            /// </summary>
	|            /// <param name=""pos""></param>
	|            /// <returns>New cursor position if any, otherwise returns <paramref name=""pos""/></returns>
	|            int CursorLeft(int pos);
	|
	|            /// <summary>
	|            /// First valid position after <paramref name=""pos""/>.
	|            /// </summary>
	|            /// <param name=""pos"">Current position.</param>
	|            /// <returns>New cursor position if any, otherwise returns <paramref name=""pos""/></returns>
	|            int CursorRight(int pos);
	|
	|            /// <summary>
	|            /// Find the first valid character position.
	|            /// </summary>
	|            /// <returns>New cursor position.</returns>
	|            int CursorStart();
	|
	|            /// <summary>
	|            /// Find the last valid character position.
	|            /// </summary>
	|            /// <returns>New cursor position.</returns>
	|            int CursorEnd();
	|
	|            /// <summary>
	|            /// Deletes the current character in <paramref name=""pos""/>.
	|            /// </summary>
	|            /// <param name=""pos""></param>
	|            /// <returns>true if the character was successfully removed, otherwise false.</returns>
	|            bool Delete(int pos);
	|
	|            /// <summary>
	|            /// Insert character <paramref name=""ch""/> in position <paramref name=""pos""/>.
	|            /// </summary>
	|            /// <param name=""ch""></param>
	|            /// <param name=""pos""></param>
	|            /// <returns>true if the character was successfully inserted, otherwise false.</returns>
	|            bool InsertAt(char ch, int pos);
	|
	|            /// <summary>
	|            /// True if the input is valid, otherwise false.
	|            /// </summary>
	|            bool IsValid { get; }
	|
	|            /// <summary>
	|            /// Set the input text and get the current value.
	|            /// </summary>
	|            ustring Text { get; set; }
	|
	|            /// <summary>
	|            /// Gets the formatted string for display.
	|            /// </summary>
	|            ustring DisplayText { get; }
	|        }
	|
	|        //////////////////////////////////////////////////////////////////////////////
	|        // PROVIDERS
	|        //////////////////////////////////////////////////////////////////////////////
	|
	|        #region NetMaskedTextProvider
	|
	|        /// <summary>
	|        /// .Net MaskedTextProvider Provider for TextValidateField.
	|        /// <para></para>
	|        /// <para><a href=""https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.maskedtextprovider?view=net-5.0"">Wrapper around MaskedTextProvider</a></para>
	|        /// <para><a href=""https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.maskedtextbox.mask?view=net-5.0"">Masking elements</a></para>
	|        /// </summary>
	|        public class NetMaskedTextProvider : ITextValidateProvider
	|        {
	|            MaskedTextProvider provider;
	|
	|            /// <summary>
	|            /// Empty Constructor
	|            /// </summary>
	|            public NetMaskedTextProvider(string mask)
	|            {
	|                Mask = mask;
	|            }
	|
	|            /// <summary>
	|            /// Mask property
	|            /// </summary>
	|            public ustring Mask
	|            {
	|                get
	|                {
	|                    return provider?.Mask;
	|                }
	|                set
	|                {
	|                    var current = provider != null ? provider.ToString(false, false) : string.Empty;
	|                    provider = new MaskedTextProvider(value == ustring.Empty ? ""&&&&&&"" : value.ToString());
	|                    if (string.IsNullOrEmpty(current) == false)
	|                    {
	|                        provider.Set(current);
	|                    }
	|                }
	|            }
	|
	|            ///<inheritdoc/>
	|            public ustring Text
	|            {
	|                get
	|                {
	|                    return provider.ToString();
	|                }
	|                set
	|                {
	|                    provider.Set(value.ToString());
	|                }
	|            }
	|
	|            ///<inheritdoc/>
	|            public bool IsValid => provider.MaskCompleted;
	|
	|            ///<inheritdoc/>
	|            public bool Fixed => true;
	|
	|            ///<inheritdoc/>
	|            public ustring DisplayText => provider.ToDisplayString();
	|
	|            ///<inheritdoc/>
	|            public int Cursor(int pos)
	|            {
	|                if (pos < 0)
	|                {
	|                    return CursorStart();
	|                }
	|                else if (pos > provider.Length)
	|                {
	|                    return CursorEnd();
	|                }
	|                else
	|                {
	|                    var p = provider.FindEditPositionFrom(pos, false);
	|                    if (p == -1) p = provider.FindEditPositionFrom(pos, true);
	|                    return p;
	|                }
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorStart()
	|            {
	|                return
	|                    provider.IsEditPosition(0)
	|                    ? 0
	|                    : provider.FindEditPositionFrom(0, true);
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorEnd()
	|            {
	|                return
	|                    provider.IsEditPosition(provider.Length - 1)
	|                    ? provider.Length - 1
	|                    : provider.FindEditPositionFrom(provider.Length, false);
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorLeft(int pos)
	|            {
	|                var c = provider.FindEditPositionFrom(pos - 1, false);
	|                return c == -1 ? pos : c;
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorRight(int pos)
	|            {
	|                var c = provider.FindEditPositionFrom(pos + 1, true);
	|                return c == -1 ? pos : c;
	|            }
	|
	|            ///<inheritdoc/>
	|            public bool Delete(int pos)
	|            {
	|                return provider.Replace(' ', pos);// .RemoveAt (pos);
	|            }
	|
	|            ///<inheritdoc/>
	|            public bool InsertAt(char ch, int pos)
	|            {
	|                return provider.Replace(ch, pos);
	|            }
	|        }
	|        #endregion
	|
	|        #region TextRegexProvider
	|
	|        /// <summary>
	|        /// Regex Provider for TextValidateField.
	|        /// </summary>
	|        public class TextRegexProvider : ITextValidateProvider
	|        {
	|            Regex regex;
	|            List<Rune> text;
	|            List<Rune> pattern;
	|
	|            /// <summary>
	|            /// Empty Constructor.
	|            /// </summary>
	|            public TextRegexProvider(string pattern)
	|            {
	|                Pattern = pattern;
	|            }
	|
	|            /// <summary>
	|            /// Regex pattern property.
	|            /// </summary>
	|            public ustring Pattern
	|            {
	|                get
	|                {
	|                    return ustring.Make(pattern);
	|                }
	|                set
	|                {
	|                    pattern = value.ToRuneList();
	|                    CompileMask();
	|                    SetupText();
	|                }
	|            }
	|
	|            ///<inheritdoc/>
	|            public ustring Text
	|            {
	|                get
	|                {
	|                    return ustring.Make(text);
	|                }
	|                set
	|                {
	|                    text = value != ustring.Empty ? value.ToRuneList() : null;
	|                    SetupText();
	|                }
	|            }
	|
	|            ///<inheritdoc/>
	|            public ustring DisplayText => Text;
	|
	|            ///<inheritdoc/>
	|            public bool IsValid
	|            {
	|                get
	|                {
	|                    return Validate(text);
	|                }
	|            }
	|
	|            ///<inheritdoc/>
	|            public bool Fixed => false;
	|
	|            /// <summary>
	|            /// When true, validates with the regex pattern on each input, preventing the input if it's not valid.
	|            /// </summary>
	|            public bool ValidateOnInput { get; set; } = true;
	|
	|
	|            bool Validate(List<Rune> text)
	|            {
	|                var match = regex.Match(ustring.Make(text).ToString());
	|                return match.Success;
	|            }
	|
	|            ///<inheritdoc/>
	|            public int Cursor(int pos)
	|            {
	|                if (pos < 0)
	|                {
	|                    return CursorStart();
	|                }
	|                else if (pos >= text.Count)
	|                {
	|                    return CursorEnd();
	|                }
	|                else
	|                {
	|                    return pos;
	|                }
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorStart()
	|            {
	|                return 0;
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorEnd()
	|            {
	|                return text.Count;
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorLeft(int pos)
	|            {
	|                if (pos > 0)
	|                {
	|                    return pos - 1;
	|                }
	|                return pos;
	|            }
	|
	|            ///<inheritdoc/>
	|            public int CursorRight(int pos)
	|            {
	|                if (pos < text.Count)
	|                {
	|                    return pos + 1;
	|                }
	|                return pos;
	|            }
	|
	|            ///<inheritdoc/>
	|            public bool Delete(int pos)
	|            {
	|                if (text.Count > 0 && pos < text.Count)
	|                {
	|                    text.RemoveAt(pos);
	|                }
	|                return true;
	|            }
	|
	|            ///<inheritdoc/>
	|            public bool InsertAt(char ch, int pos)
	|            {
	|                var aux = text.ToList();
	|                aux.Insert(pos, ch);
	|                if (Validate(aux) || ValidateOnInput == false)
	|                {
	|                    text.Insert(pos, ch);
	|                    return true;
	|                }
	|                return false;
	|            }
	|
	|            void SetupText()
	|            {
	|                if (text != null && IsValid)
	|                {
	|                    return;
	|                }
	|
	|                text = new List<Rune>();
	|            }
	|
	|            /// <summary>
	|            /// Compiles the regex pattern for validation./>
	|            /// </summary>
	|            private void CompileMask()
	|            {
	|                regex = new Regex(ustring.Make(pattern).ToString(), RegexOptions.Compiled);
	|            }
	|        }
	|        #endregion
	|    }
	|
	|    /// <summary>
	|    /// Text field that validates input through a  <see cref=""ITextValidateProvider""/>
	|    /// </summary>
	|    public class TextValidateField : View
	|    {
	|
	|        ITextValidateProvider provider;
	|        int cursorPosition = 0;
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""TextValidateField""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        public TextValidateField() : this(null)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""TextValidateField""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        public TextValidateField(ITextValidateProvider provider)
	|        {
	|            if (provider != null)
	|            {
	|                Provider = provider;
	|            }
	|
	|            Initialize();
	|        }
	|
	|        void Initialize()
	|        {
	|            Height = 1;
	|            CanFocus = true;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.LeftHome, () => { HomeKeyHandler(); return true; });
	|            AddCommand(Command.RightEnd, () => { EndKeyHandler(); return true; });
	|            AddCommand(Command.DeleteCharRight, () => { DeleteKeyHandler(); return true; });
	|            AddCommand(Command.DeleteCharLeft, () => { BackspaceKeyHandler(); return true; });
	|            AddCommand(Command.Left, () => { CursorLeft(); return true; });
	|            AddCommand(Command.Right, () => { CursorRight(); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.Home, Command.LeftHome);
	|            AddKeyBinding(Key.End, Command.RightEnd);
	|
	|            AddKeyBinding(Key.Delete, Command.DeleteCharRight);
	|            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
	|
	|            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|        }
	|
	|        /// <summary>
	|        /// Provider
	|        /// </summary>
	|        public ITextValidateProvider Provider
	|        {
	|            get => provider;
	|            set
	|            {
	|                provider = value;
	|                if (provider.Fixed == true)
	|                {
	|                    this.Width = provider.DisplayText == ustring.Empty ? 10 : Text.Length;
	|                }
	|                HomeKeyHandler();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent mouseEvent)
	|        {
	|            if (mouseEvent.Flags.HasFlag(MouseFlags.Button1Pressed))
	|            {
	|
	|                var c = provider.Cursor(mouseEvent.X - GetMargins(Frame.Width).left);
	|                if (provider.Fixed == false && TextAlignment == TextAlignment.Right && Text.Length > 0)
	|                {
	|                    c += 1;
	|                }
	|                cursorPosition = c;
	|                SetFocus();
	|                SetNeedsDisplay();
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Text
	|        /// </summary>
	|        public new ustring Text
	|        {
	|            get
	|            {
	|                if (provider == null)
	|                {
	|                    return ustring.Empty;
	|                }
	|
	|                return provider.Text;
	|            }
	|            set
	|            {
	|                if (provider == null)
	|                {
	|                    return;
	|                }
	|                provider.Text = value;
	|
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            var (left, _) = GetMargins(Frame.Width);
	|
	|            // Fixed = true, is for inputs thar have fixed width, like masked ones.
	|            // Fixed = false, is for normal input.
	|            // When it's right-aligned and it's a normal input, the cursor behaves differently.
	|            if (provider?.Fixed == false && TextAlignment == TextAlignment.Right)
	|            {
	|                Move(cursorPosition + left - 1, 0);
	|            }
	|            else
	|            {
	|                Move(cursorPosition + left, 0);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Margins for text alignment.
	|        /// </summary>
	|        /// <param name=""width"">Total width</param>
	|        /// <returns>Left and right margins</returns>
	|        (int left, int right) GetMargins(int width)
	|        {
	|            var count = Text.Length;
	|            var total = width - count;
	|            switch (TextAlignment)
	|            {
	|                case TextAlignment.Left:
	|                    return (0, total);
	|                case TextAlignment.Centered:
	|                    return (total / 2, (total / 2) + (total % 2));
	|                case TextAlignment.Right:
	|                    return (total, 0);
	|                default:
	|                    return (0, total);
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            if (provider == null)
	|            {
	|                Move(0, 0);
	|                Driver.AddStr(""Error: ITextValidateProvider not set!"");
	|                return;
	|            }
	|
	|            var bgcolor = !IsValid ? Color.BrightRed : ColorScheme.Focus.Background;
	|            var textColor = new Attribute(ColorScheme.Focus.Foreground, bgcolor);
	|
	|            var (margin_left, margin_right) = GetMargins(bounds.Width);
	|
	|            Move(0, 0);
	|
	|            // Left Margin
	|            Driver.SetAttribute(textColor);
	|            for (int i = 0; i < margin_left; i++)
	|            {
	|                Driver.AddRune(' ');
	|            }
	|
	|            // Content
	|            Driver.SetAttribute(textColor);
	|            // Content
	|            for (int i = 0; i < provider.DisplayText.Length; i++)
	|            {
	|                Driver.AddRune(provider.DisplayText[i]);
	|            }
	|
	|            // Right Margin
	|            Driver.SetAttribute(textColor);
	|            for (int i = 0; i < margin_right; i++)
	|            {
	|                Driver.AddRune(' ');
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Try to move the cursor to the left.
	|        /// </summary>
	|        /// <returns>True if moved.</returns>
	|        bool CursorLeft()
	|        {
	|            var current = cursorPosition;
	|            cursorPosition = provider.CursorLeft(cursorPosition);
	|            SetNeedsDisplay();
	|            return current != cursorPosition;
	|        }
	|
	|        /// <summary>
	|        /// Try to move the cursor to the right.
	|        /// </summary>
	|        /// <returns>True if moved.</returns>
	|        bool CursorRight()
	|        {
	|            var current = cursorPosition;
	|            cursorPosition = provider.CursorRight(cursorPosition);
	|            SetNeedsDisplay();
	|            return current != cursorPosition;
	|        }
	|
	|        /// <summary>
	|        /// Delete char at cursor position - 1, moving the cursor.
	|        /// </summary>
	|        /// <returns></returns>
	|        bool BackspaceKeyHandler()
	|        {
	|            if (provider.Fixed == false && TextAlignment == TextAlignment.Right && cursorPosition <= 1)
	|            {
	|                return false;
	|            }
	|            cursorPosition = provider.CursorLeft(cursorPosition);
	|            provider.Delete(cursorPosition);
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Deletes char at current position.
	|        /// </summary>
	|        /// <returns></returns>
	|        bool DeleteKeyHandler()
	|        {
	|            if (provider.Fixed == false && TextAlignment == TextAlignment.Right)
	|            {
	|                cursorPosition = provider.CursorLeft(cursorPosition);
	|            }
	|            provider.Delete(cursorPosition);
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Moves the cursor to first char.
	|        /// </summary>
	|        /// <returns></returns>
	|        bool HomeKeyHandler()
	|        {
	|            cursorPosition = provider.CursorStart();
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Moves the cursor to the last char.
	|        /// </summary>
	|        /// <returns></returns>
	|        bool EndKeyHandler()
	|        {
	|            cursorPosition = provider.CursorEnd();
	|            SetNeedsDisplay();
	|            return true;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            if (provider == null)
	|            {
	|                return false;
	|            }
	|
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            if (kb.Key < Key.Space || kb.Key > Key.CharMask)
	|                return false;
	|
	|            var key = new Rune((uint)kb.KeyValue);
	|
	|            var inserted = provider.InsertAt((char)key, cursorPosition);
	|
	|            if (inserted)
	|            {
	|                CursorRight();
	|            }
	|
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// This property returns true if the input is valid.
	|        /// </summary>
	|        public virtual bool IsValid
	|        {
	|            get
	|            {
	|                if (provider == null)
	|                {
	|                    return false;
	|                }
	|
	|                return provider.IsValid;
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    // TextView.cs: multi-line text editing
	|
	|    class TextModel
	|    {
	|        List<List<Rune>> lines = new List<List<Rune>>();
	|
	|        public event Action LinesLoaded;
	|
	|        public bool LoadFile(string file)
	|        {
	|            FilePath = file ?? throw new ArgumentNullException(nameof(file));
	|
	|            var stream = File.OpenRead(file);
	|            LoadStream(stream);
	|            return true;
	|        }
	|
	|        public bool CloseFile()
	|        {
	|            if (FilePath == null)
	|                throw new ArgumentNullException(nameof(FilePath));
	|
	|            FilePath = null;
	|            lines = new List<List<Rune>>();
	|            return true;
	|        }
	|
	|        // Turns the ustring into runes, this does not split the 
	|        // contents on a newline if it is present.
	|        internal static List<Rune> ToRunes(ustring str)
	|        {
	|            List<Rune> runes = new List<Rune>();
	|            foreach (var x in str.ToRunes())
	|            {
	|                runes.Add(x);
	|            }
	|            return runes;
	|        }
	|
	|        // Splits a string into a List that contains a List<Rune> for each line
	|        public static List<List<Rune>> StringToRunes(ustring content)
	|        {
	|            var lines = new List<List<Rune>>();
	|            int start = 0, i = 0;
	|            var hasCR = false;
	|            // ASCII code 13 = Carriage Return.
	|            // ASCII code 10 = Line Feed.
	|            for (; i < content.Length; i++)
	|            {
	|                if (content[i] == 13)
	|                {
	|                    hasCR = true;
	|                    continue;
	|                }
	|                if (content[i] == 10)
	|                {
	|                    if (i - start > 0)
	|                        lines.Add(ToRunes(content[start, hasCR ? i - 1 : i]));
	|                    else
	|                        lines.Add(ToRunes(ustring.Empty));
	|                    start = i + 1;
	|                    hasCR = false;
	|                }
	|            }
	|            if (i - start >= 0)
	|                lines.Add(ToRunes(content[start, null]));
	|            return lines;
	|        }
	|
	|        void Append(List<byte> line)
	|        {
	|            var str = ustring.Make(line.ToArray());
	|            lines.Add(ToRunes(str));
	|        }
	|
	|        public void LoadStream(Stream input)
	|        {
	|            if (input == null)
	|                throw new ArgumentNullException(nameof(input));
	|
	|            lines = new List<List<Rune>>();
	|            var buff = new BufferedStream(input);
	|            int v;
	|            var line = new List<byte>();
	|            var wasNewLine = false;
	|            while ((v = buff.ReadByte()) != -1)
	|            {
	|                if (v == 13)
	|                {
	|                    continue;
	|                }
	|                if (v == 10)
	|                {
	|                    Append(line);
	|                    line.Clear();
	|                    wasNewLine = true;
	|                    continue;
	|                }
	|                line.Add((byte)v);
	|                wasNewLine = false;
	|            }
	|            if (line.Count > 0 || wasNewLine)
	|                Append(line);
	|            buff.Dispose();
	|
	|            OnLinesLoaded();
	|        }
	|
	|        public void LoadString(ustring content)
	|        {
	|            lines = StringToRunes(content);
	|
	|            OnLinesLoaded();
	|        }
	|
	|        void OnLinesLoaded()
	|        {
	|            LinesLoaded?.Invoke();
	|        }
	|
	|        public override string ToString()
	|        {
	|            var sb = new StringBuilder();
	|            for (int i = 0; i < lines.Count; i++)
	|            {
	|                sb.Append(ustring.Make(lines[i]));
	|                if ((i + 1) < lines.Count)
	|                {
	|                    sb.AppendLine();
	|                }
	|            }
	|            return sb.ToString();
	|        }
	|
	|        public string FilePath { get; set; }
	|
	|        /// <summary>
	|        /// The number of text lines in the model
	|        /// </summary>
	|        public int Count => lines.Count;
	|
	|        /// <summary>
	|        /// Returns the specified line as a List of Rune
	|        /// </summary>
	|        /// <returns>The line.</returns>
	|        /// <param name=""line"">Line number to retrieve.</param>
	|        public List<Rune> GetLine(int line)
	|        {
	|            if (lines.Count > 0)
	|            {
	|                if (line < Count)
	|                {
	|                    return lines[line];
	|                }
	|                else
	|                {
	|                    return lines[Count - 1];
	|                }
	|            }
	|            else
	|            {
	|                lines.Add(new List<Rune>());
	|                return lines[0];
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Adds a line to the model at the specified position.
	|        /// </summary>
	|        /// <param name=""pos"">Line number where the line will be inserted.</param>
	|        /// <param name=""runes"">The line of text, as a List of Rune.</param>
	|        public void AddLine(int pos, List<Rune> runes)
	|        {
	|            lines.Insert(pos, runes);
	|        }
	|
	|        /// <summary>
	|        /// Removes the line at the specified position
	|        /// </summary>
	|        /// <param name=""pos"">Position.</param>
	|        public void RemoveLine(int pos)
	|        {
	|            if (lines.Count > 0)
	|            {
	|                if (lines.Count == 1 && lines[0].Count == 0)
	|                {
	|                    return;
	|                }
	|                lines.RemoveAt(pos);
	|            }
	|        }
	|
	|        public void ReplaceLine(int pos, List<Rune> runes)
	|        {
	|            if (lines.Count > 0 && pos < lines.Count)
	|            {
	|                lines[pos] = new List<Rune>(runes);
	|            }
	|            else if (lines.Count == 0 || (lines.Count > 0 && pos >= lines.Count))
	|            {
	|                lines.Add(runes);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the maximum line length of the visible lines.
	|        /// </summary>
	|        /// <param name=""first"">The first line.</param>
	|        /// <param name=""last"">The last line.</param>
	|        /// <param name=""tabWidth"">The tab width.</param>
	|        public int GetMaxVisibleLine(int first, int last, int tabWidth)
	|        {
	|            int maxLength = 0;
	|            last = last < lines.Count ? last : lines.Count;
	|            for (int i = first; i < last; i++)
	|            {
	|                var line = GetLine(i);
	|                var tabSum = line.Sum(r => r == '\t' ? Math.Max(tabWidth - 1, 0) : 0);
	|                var l = line.Count + tabSum;
	|                if (l > maxLength)
	|                {
	|                    maxLength = l;
	|                }
	|            }
	|
	|            return maxLength;
	|        }
	|
	|        internal static bool SetCol(ref int col, int width, int cols)
	|        {
	|            if (col + cols <= width)
	|            {
	|                col += cols;
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        internal static int GetColFromX(List<Rune> t, int start, int x, int tabWidth = 0)
	|        {
	|            if (x < 0)
	|            {
	|                return x;
	|            }
	|            int size = start;
	|            var pX = x + start;
	|            for (int i = start; i < t.Count; i++)
	|            {
	|                var r = t[i];
	|                size += Rune.ColumnWidth(r);
	|                if (r == '\t')
	|                {
	|                    size += tabWidth + 1;
	|                }
	|                if (i == pX || (size > pX))
	|                {
	|                    return i - start;
	|                }
	|            }
	|            return t.Count - start;
	|        }
	|
	|        // Returns the size and length in a range of the string.
	|        internal static (int size, int length) DisplaySize(List<Rune> t, int start = -1, int end = -1,
	|            bool checkNextRune = true, int tabWidth = 0)
	|        {
	|            if (t == null || t.Count == 0)
	|            {
	|                return (0, 0);
	|            }
	|            int size = 0;
	|            int len = 0;
	|            int tcount = end == -1 ? t.Count : end > t.Count ? t.Count : end;
	|            int i = start == -1 ? 0 : start;
	|            for (; i < tcount; i++)
	|            {
	|                var rune = t[i];
	|                size += Rune.ColumnWidth(rune);
	|                len += Rune.RuneLen(rune);
	|                if (rune == '\t')
	|                {
	|                    size += tabWidth + 1;
	|                    len += tabWidth - 1;
	|                }
	|                if (checkNextRune && i == tcount - 1 && t.Count > tcount
	|                    && IsWideRune(t[i + 1], tabWidth, out int s, out int l))
	|                {
	|                    size += s;
	|                    len += l;
	|                }
	|            }
	|
	|            bool IsWideRune(Rune r, int tWidth, out int s, out int l)
	|            {
	|                s = Rune.ColumnWidth(r);
	|                l = Rune.RuneLen(r);
	|                if (r == '\t')
	|                {
	|                    s += tWidth + 1;
	|                    l += tWidth - 1;
	|                }
	|
	|                return s > 1;
	|            }
	|
	|            return (size, len);
	|        }
	|
	|        // Returns the left column in a range of the string.
	|        internal static int CalculateLeftColumn(List<Rune> t, int start, int end, int width, int tabWidth = 0)
	|        {
	|            if (t == null || t.Count == 0)
	|            {
	|                return 0;
	|            }
	|            int size = 0;
	|            int tcount = end > t.Count - 1 ? t.Count - 1 : end;
	|            int col = 0;
	|
	|            for (int i = tcount; i >= 0; i--)
	|            {
	|                var rune = t[i];
	|                size += Rune.ColumnWidth(rune);
	|                if (rune == '\t')
	|                {
	|                    size += tabWidth + 1;
	|                }
	|                if (size > width)
	|                {
	|                    if (col + width == end)
	|                    {
	|                        col++;
	|                    }
	|                    break;
	|                }
	|                else if ((end < t.Count && col > 0 && start < end && col == start) || (end - col == width - 1))
	|                {
	|                    break;
	|                }
	|                col = i;
	|            }
	|
	|            return col;
	|        }
	|
	|        (Point startPointToFind, Point currentPointToFind, bool found) toFind;
	|
	|        internal (Point current, bool found) FindNextText(ustring text, out bool gaveFullTurn, bool matchCase = false, bool matchWholeWord = false)
	|        {
	|            if (text == null || lines.Count == 0)
	|            {
	|                gaveFullTurn = false;
	|                return (Point.Empty, false);
	|            }
	|
	|            if (toFind.found)
	|            {
	|                toFind.currentPointToFind.X++;
	|            }
	|            var foundPos = GetFoundNextTextPoint(text, lines.Count, matchCase, matchWholeWord, toFind.currentPointToFind);
	|            if (!foundPos.found && toFind.currentPointToFind != toFind.startPointToFind)
	|            {
	|                foundPos = GetFoundNextTextPoint(text, toFind.startPointToFind.Y + 1, matchCase, matchWholeWord, Point.Empty);
	|            }
	|            gaveFullTurn = ApplyToFind(foundPos);
	|
	|            return foundPos;
	|        }
	|
	|        internal (Point current, bool found) FindPreviousText(ustring text, out bool gaveFullTurn, bool matchCase = false, bool matchWholeWord = false)
	|        {
	|            if (text == null || lines.Count == 0)
	|            {
	|                gaveFullTurn = false;
	|                return (Point.Empty, false);
	|            }
	|
	|            if (toFind.found)
	|            {
	|                toFind.currentPointToFind.X++;
	|            }
	|            var linesCount = toFind.currentPointToFind.IsEmpty ? lines.Count - 1 : toFind.currentPointToFind.Y;
	|            var foundPos = GetFoundPreviousTextPoint(text, linesCount, matchCase, matchWholeWord, toFind.currentPointToFind);
	|            if (!foundPos.found && toFind.currentPointToFind != toFind.startPointToFind)
	|            {
	|                foundPos = GetFoundPreviousTextPoint(text, lines.Count - 1, matchCase, matchWholeWord,
	|                    new Point(lines[lines.Count - 1].Count, lines.Count));
	|            }
	|            gaveFullTurn = ApplyToFind(foundPos);
	|
	|            return foundPos;
	|        }
	|
	|        internal (Point current, bool found) ReplaceAllText(ustring text, bool matchCase = false, bool matchWholeWord = false, ustring textToReplace = null)
	|        {
	|            bool found = false;
	|            Point pos = Point.Empty;
	|
	|            for (int i = 0; i < lines.Count; i++)
	|            {
	|                var x = lines[i];
	|                var txt = GetText(x);
	|                var matchText = !matchCase ? text.ToUpper().ToString() : text.ToString();
	|                var col = txt.IndexOf(matchText);
	|                while (col > -1)
	|                {
	|                    if (matchWholeWord && !MatchWholeWord(txt, matchText, col))
	|                    {
	|                        if (col + 1 > txt.Length)
	|                        {
	|                            break;
	|                        }
	|                        col = txt.IndexOf(matchText, col + 1);
	|                        continue;
	|                    }
	|                    if (col > -1)
	|                    {
	|                        if (!found)
	|                        {
	|                            found = true;
	|                        }
	|                        lines[i] = ReplaceText(x, textToReplace, matchText, col).ToRuneList();
	|                        x = lines[i];
	|                        txt = GetText(x);
	|                        pos = new Point(col, i);
	|                        col += (textToReplace.Length - matchText.Length);
	|                    }
	|                    if (col < 0 || col + 1 > txt.Length)
	|                    {
	|                        break;
	|                    }
	|                    col = txt.IndexOf(matchText, col + 1);
	|                }
	|            }
	|
	|            string GetText(List<Rune> x)
	|            {
	|                var txt = ustring.Make(x).ToString();
	|                if (!matchCase)
	|                {
	|                    txt = txt.ToUpper();
	|                }
	|                return txt;
	|            }
	|
	|            return (pos, found);
	|        }
	|
	|        ustring ReplaceText(List<Rune> source, ustring textToReplace, string matchText, int col)
	|        {
	|            var origTxt = ustring.Make(source);
	|            (int _, int len) = TextModel.DisplaySize(source, 0, col, false);
	|            (var _, var len2) = TextModel.DisplaySize(source, col, col + matchText.Length, false);
	|            (var _, var len3) = TextModel.DisplaySize(source, col + matchText.Length, origTxt.RuneCount, false);
	|
	|            return origTxt[0, len] +
	|                textToReplace.ToString() +
	|                origTxt[len + len2, len + len2 + len3];
	|        }
	|
	|        bool ApplyToFind((Point current, bool found) foundPos)
	|        {
	|            bool gaveFullTurn = false;
	|            if (foundPos.found)
	|            {
	|                toFind.currentPointToFind = foundPos.current;
	|                if (toFind.found && toFind.currentPointToFind == toFind.startPointToFind)
	|                {
	|                    gaveFullTurn = true;
	|                }
	|                if (!toFind.found)
	|                {
	|                    toFind.startPointToFind = toFind.currentPointToFind = foundPos.current;
	|                    toFind.found = foundPos.found;
	|                }
	|            }
	|
	|            return gaveFullTurn;
	|        }
	|
	|        (Point current, bool found) GetFoundNextTextPoint(ustring text, int linesCount, bool matchCase, bool matchWholeWord, Point start)
	|        {
	|            for (int i = start.Y; i < linesCount; i++)
	|            {
	|                var x = lines[i];
	|                var txt = ustring.Make(x).ToString();
	|                if (!matchCase)
	|                {
	|                    txt = txt.ToUpper();
	|                }
	|                var matchText = !matchCase ? text.ToUpper().ToString() : text.ToString();
	|                var col = txt.IndexOf(matchText, Math.Min(start.X, txt.Length));
	|                if (col > -1 && matchWholeWord && !MatchWholeWord(txt, matchText, col))
	|                {
	|                    continue;
	|                }
	|                if (col > -1 && ((i == start.Y && col >= start.X)
	|                    || i > start.Y)
	|                    && txt.Contains(matchText))
	|                {
	|                    return (new Point(col, i), true);
	|                }
	|                else if (col == -1 && start.X > 0)
	|                {
	|                    start.X = 0;
	|                }
	|            }
	|
	|            return (Point.Empty, false);
	|        }
	|
	|        (Point current, bool found) GetFoundPreviousTextPoint(ustring text, int linesCount, bool matchCase, bool matchWholeWord, Point start)
	|        {
	|            for (int i = linesCount; i >= 0; i--)
	|            {
	|                var x = lines[i];
	|                var txt = ustring.Make(x).ToString();
	|                if (!matchCase)
	|                {
	|                    txt = txt.ToUpper();
	|                }
	|                if (start.Y != i)
	|                {
	|                    start.X = Math.Max(x.Count - 1, 0);
	|                }
	|                var matchText = !matchCase ? text.ToUpper().ToString() : text.ToString();
	|                var col = txt.LastIndexOf(matchText, toFind.found ? start.X - 1 : start.X);
	|                if (col > -1 && matchWholeWord && !MatchWholeWord(txt, matchText, col))
	|                {
	|                    continue;
	|                }
	|                if (col > -1 && ((i <= linesCount && col <= start.X)
	|                    || i < start.Y)
	|                    && txt.Contains(matchText))
	|                {
	|                    return (new Point(col, i), true);
	|                }
	|            }
	|
	|            return (Point.Empty, false);
	|        }
	|
	|        bool MatchWholeWord(string source, string matchText, int index = 0)
	|        {
	|            if (string.IsNullOrEmpty(source) || string.IsNullOrEmpty(matchText))
	|            {
	|                return false;
	|            }
	|
	|            var txt = matchText.Trim();
	|            var start = index > 0 ? index - 1 : 0;
	|            var end = index + txt.Length;
	|
	|            if ((start == 0 || Rune.IsWhiteSpace(source[start]))
	|                && (end == source.Length || Rune.IsWhiteSpace(source[end])))
	|            {
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Redefine column and line tracking.
	|        /// </summary>
	|        /// <param name=""point"">Contains the column and line.</param>
	|        internal void ResetContinuousFind(Point point)
	|        {
	|            toFind.startPointToFind = toFind.currentPointToFind = point;
	|            toFind.found = false;
	|        }
	|    }
	|
	|    class HistoryText
	|    {
	|        public enum LineStatus
	|        {
	|            Original,
	|            Replaced,
	|            Removed,
	|            Added
	|        }
	|
	|        public class HistoryTextItem
	|        {
	|            public List<List<Rune>> Lines;
	|            public Point CursorPosition;
	|            public LineStatus LineStatus;
	|            public bool IsUndoing;
	|            public Point FinalCursorPosition;
	|            public HistoryTextItem RemovedOnAdded;
	|
	|            public HistoryTextItem(List<List<Rune>> lines, Point curPos, LineStatus linesStatus)
	|            {
	|                Lines = lines;
	|                CursorPosition = curPos;
	|                LineStatus = linesStatus;
	|            }
	|
	|            public HistoryTextItem(HistoryTextItem historyTextItem)
	|            {
	|                Lines = new List<List<Rune>>(historyTextItem.Lines);
	|                CursorPosition = new Point(historyTextItem.CursorPosition.X, historyTextItem.CursorPosition.Y);
	|                LineStatus = historyTextItem.LineStatus;
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""(Count: {Lines.Count}, Cursor: {CursorPosition}, Status: {LineStatus})"";
	|            }
	|        }
	|
	|        List<HistoryTextItem> historyTextItems = new List<HistoryTextItem>();
	|        int idxHistoryText = -1;
	|        ustring originalText;
	|
	|        public bool IsFromHistory { get; private set; }
	|
	|        public bool HasHistoryChanges => idxHistoryText > -1;
	|
	|        public event Action<HistoryTextItem> ChangeText;
	|
	|        public void Add(List<List<Rune>> lines, Point curPos, LineStatus lineStatus = LineStatus.Original)
	|        {
	|            if (lineStatus == LineStatus.Original && historyTextItems.Count > 0
	|                && historyTextItems.Last().LineStatus == LineStatus.Original)
	|            {
	|                return;
	|            }
	|            if (lineStatus == LineStatus.Replaced && historyTextItems.Count > 0
	|                && historyTextItems.Last().LineStatus == LineStatus.Replaced)
	|            {
	|                return;
	|            }
	|
	|            if (historyTextItems.Count == 0 && lineStatus != LineStatus.Original)
	|                throw new ArgumentException(""The first item must be the original."");
	|
	|            if (idxHistoryText >= 0 && idxHistoryText + 1 < historyTextItems.Count)
	|                historyTextItems.RemoveRange(idxHistoryText + 1, historyTextItems.Count - idxHistoryText - 1);
	|
	|            historyTextItems.Add(new HistoryTextItem(lines, curPos, lineStatus));
	|            idxHistoryText++;
	|        }
	|
	|        public void ReplaceLast(List<List<Rune>> lines, Point curPos, LineStatus lineStatus)
	|        {
	|            var found = historyTextItems.FindLast(x => x.LineStatus == lineStatus);
	|            if (found != null)
	|            {
	|                found.Lines = lines;
	|                found.CursorPosition = curPos;
	|            }
	|        }
	|
	|        public void Undo()
	|        {
	|            if (historyTextItems?.Count > 0 && idxHistoryText > 0)
	|            {
	|                IsFromHistory = true;
	|
	|                idxHistoryText--;
	|
	|                var historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText])
	|                {
	|                    IsUndoing = true
	|                };
	|
	|                ProcessChanges(ref historyTextItem);
	|
	|                IsFromHistory = false;
	|            }
	|        }
	|
	|        public void Redo()
	|        {
	|            if (historyTextItems?.Count > 0 && idxHistoryText < historyTextItems.Count - 1)
	|            {
	|                IsFromHistory = true;
	|
	|                idxHistoryText++;
	|
	|                var historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText])
	|                {
	|                    IsUndoing = false
	|                };
	|
	|                ProcessChanges(ref historyTextItem);
	|
	|                IsFromHistory = false;
	|            }
	|        }
	|
	|        void ProcessChanges(ref HistoryTextItem historyTextItem)
	|        {
	|            if (historyTextItem.IsUndoing)
	|            {
	|                if (idxHistoryText - 1 > -1 && ((historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Added)
	|                    || historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed
	|                    || (historyTextItem.LineStatus == LineStatus.Replaced &&
	|                    historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Original)))
	|                {
	|
	|                    idxHistoryText--;
	|
	|                    while (historyTextItems[idxHistoryText].LineStatus == LineStatus.Added
	|                        && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed)
	|                    {
	|
	|                        idxHistoryText--;
	|                    }
	|                    historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText]);
	|                    historyTextItem.IsUndoing = true;
	|                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
	|                }
	|
	|                if (historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Added)
	|                {
	|                    historyTextItem.RemovedOnAdded = new HistoryTextItem(historyTextItems[idxHistoryText + 1]);
	|                }
	|
	|                if ((historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Original)
	|                    || (historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Original)
	|                    || (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed))
	|                {
	|
	|                    if (!historyTextItem.Lines[0].SequenceEqual(historyTextItems[idxHistoryText - 1].Lines[0])
	|                        && historyTextItem.CursorPosition == historyTextItems[idxHistoryText - 1].CursorPosition)
	|                    {
	|                        historyTextItem.Lines[0] = new List<Rune>(historyTextItems[idxHistoryText - 1].Lines[0]);
	|                    }
	|                    if (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed)
	|                    {
	|                        historyTextItem.FinalCursorPosition = historyTextItems[idxHistoryText - 2].CursorPosition;
	|                    }
	|                    else
	|                    {
	|                        historyTextItem.FinalCursorPosition = historyTextItems[idxHistoryText - 1].CursorPosition;
	|                    }
	|                }
	|                else
	|                {
	|                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
	|                }
	|
	|                OnChangeText(historyTextItem);
	|                while (historyTextItems[idxHistoryText].LineStatus == LineStatus.Removed
	|                    || historyTextItems[idxHistoryText].LineStatus == LineStatus.Added)
	|                {
	|
	|                    idxHistoryText--;
	|                }
	|            }
	|            else if (!historyTextItem.IsUndoing)
	|            {
	|                if (idxHistoryText + 1 < historyTextItems.Count && (historyTextItem.LineStatus == LineStatus.Original
	|                    || historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Added
	|                    || historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Removed))
	|                {
	|
	|                    idxHistoryText++;
	|                    historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText]);
	|                    historyTextItem.IsUndoing = false;
	|                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
	|                }
	|
	|                if (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed)
	|                {
	|                    historyTextItem.RemovedOnAdded = new HistoryTextItem(historyTextItems[idxHistoryText - 1]);
	|                }
	|
	|                if ((historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Replaced)
	|                    || (historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Original)
	|                    || (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Replaced))
	|                {
	|
	|                    if (historyTextItem.LineStatus == LineStatus.Removed
	|                        && !historyTextItem.Lines[0].SequenceEqual(historyTextItems[idxHistoryText + 1].Lines[0]))
	|                    {
	|                        historyTextItem.Lines[0] = new List<Rune>(historyTextItems[idxHistoryText + 1].Lines[0]);
	|                    }
	|                    historyTextItem.FinalCursorPosition = historyTextItems[idxHistoryText + 1].CursorPosition;
	|                }
	|                else
	|                {
	|                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
	|                }
	|
	|                OnChangeText(historyTextItem);
	|                while (historyTextItems[idxHistoryText].LineStatus == LineStatus.Removed
	|                    || historyTextItems[idxHistoryText].LineStatus == LineStatus.Added)
	|                {
	|
	|                    idxHistoryText++;
	|                }
	|            }
	|        }
	|
	|        void OnChangeText(HistoryTextItem lines)
	|        {
	|            ChangeText?.Invoke(lines);
	|        }
	|
	|        public void Clear(ustring text)
	|        {
	|            historyTextItems.Clear();
	|            idxHistoryText = -1;
	|            originalText = text;
	|            OnChangeText(null);
	|        }
	|
	|        public bool IsDirty(ustring text)
	|        {
	|            return originalText != text;
	|        }
	|    }
	|
	|    class WordWrapManager
	|    {
	|        class WrappedLine
	|        {
	|            public int ModelLine;
	|            public int Row;
	|            public int RowIndex;
	|            public int ColWidth;
	|        }
	|
	|        List<WrappedLine> wrappedModelLines = new List<WrappedLine>();
	|        int frameWidth;
	|        bool isWrapModelRefreshing;
	|
	|        public TextModel Model { get; private set; }
	|
	|        public WordWrapManager(TextModel model)
	|        {
	|            Model = model;
	|        }
	|
	|        public TextModel WrapModel(int width, out int nRow, out int nCol, out int nStartRow, out int nStartCol,
	|            int row = 0, int col = 0, int startRow = 0, int startCol = 0, int tabWidth = 0, bool preserveTrailingSpaces = true)
	|        {
	|            frameWidth = width;
	|
	|            var modelRow = isWrapModelRefreshing ? row : GetModelLineFromWrappedLines(row);
	|            var modelCol = isWrapModelRefreshing ? col : GetModelColFromWrappedLines(row, col);
	|            var modelStartRow = isWrapModelRefreshing ? startRow : GetModelLineFromWrappedLines(startRow);
	|            var modelStartCol = isWrapModelRefreshing ? startCol : GetModelColFromWrappedLines(startRow, startCol);
	|            var wrappedModel = new TextModel();
	|            int lines = 0;
	|            nRow = 0;
	|            nCol = 0;
	|            nStartRow = 0;
	|            nStartCol = 0;
	|            bool isRowAndColSetted = row == 0 && col == 0;
	|            bool isStartRowAndColSetted = startRow == 0 && startCol == 0;
	|            List<WrappedLine> wModelLines = new List<WrappedLine>();
	|
	|            for (int i = 0; i < Model.Count; i++)
	|            {
	|                var line = Model.GetLine(i);
	|                var wrappedLines = ToListRune(
	|                    TextFormatter.Format(ustring.Make(line), width, TextAlignment.Left, true, preserveTrailingSpaces, tabWidth));
	|                int sumColWidth = 0;
	|                for (int j = 0; j < wrappedLines.Count; j++)
	|                {
	|                    var wrapLine = wrappedLines[j];
	|                    if (!isRowAndColSetted && modelRow == i)
	|                    {
	|                        if (nCol + wrapLine.Count <= modelCol)
	|                        {
	|                            nCol += wrapLine.Count;
	|                            nRow = lines;
	|                            if (nCol == modelCol)
	|                            {
	|                                nCol = wrapLine.Count;
	|                                isRowAndColSetted = true;
	|                            }
	|                            else if (j == wrappedLines.Count - 1)
	|                            {
	|                                nCol = wrapLine.Count - j + modelCol - nCol;
	|                                isRowAndColSetted = true;
	|                            }
	|                        }
	|                        else
	|                        {
	|                            var offset = nCol + wrapLine.Count - modelCol;
	|                            nCol = wrapLine.Count - offset;
	|                            nRow = lines;
	|                            isRowAndColSetted = true;
	|                        }
	|                    }
	|                    if (!isStartRowAndColSetted && modelStartRow == i)
	|                    {
	|                        if (nStartCol + wrapLine.Count <= modelStartCol)
	|                        {
	|                            nStartCol += wrapLine.Count;
	|                            nStartRow = lines;
	|                            if (nStartCol == modelStartCol)
	|                            {
	|                                nStartCol = wrapLine.Count;
	|                                isStartRowAndColSetted = true;
	|                            }
	|                            else if (j == wrappedLines.Count - 1)
	|                            {
	|                                nStartCol = wrapLine.Count - j + modelStartCol - nStartCol;
	|                                isStartRowAndColSetted = true;
	|                            }
	|                        }
	|                        else
	|                        {
	|                            var offset = nStartCol + wrapLine.Count - modelStartCol;
	|                            nStartCol = wrapLine.Count - offset;
	|                            nStartRow = lines;
	|                            isStartRowAndColSetted = true;
	|                        }
	|                    }
	|                    wrappedModel.AddLine(lines, wrapLine);
	|                    sumColWidth += wrapLine.Count;
	|                    var wrappedLine = new WrappedLine()
	|                    {
	|                        ModelLine = i,
	|                        Row = lines,
	|                        RowIndex = j,
	|                        ColWidth = wrapLine.Count,
	|                    };
	|                    wModelLines.Add(wrappedLine);
	|                    lines++;
	|                }
	|            }
	|            wrappedModelLines = wModelLines;
	|
	|            return wrappedModel;
	|        }
	|
	|        public List<List<Rune>> ToListRune(List<ustring> textList)
	|        {
	|            var runesList = new List<List<Rune>>();
	|
	|            foreach (var text in textList)
	|            {
	|                runesList.Add(text.ToRuneList());
	|            }
	|
	|            return runesList;
	|        }
	|
	|        public int GetModelLineFromWrappedLines(int line) => wrappedModelLines.Count > 0
	|            ? wrappedModelLines[Math.Min(line, wrappedModelLines.Count - 1)].ModelLine
	|            : 0;
	|
	|        public int GetModelColFromWrappedLines(int line, int col)
	|        {
	|            if (wrappedModelLines?.Count == 0)
	|            {
	|                return 0;
	|            }
	|
	|            var modelLine = GetModelLineFromWrappedLines(line);
	|            var firstLine = wrappedModelLines.IndexOf(r => r.ModelLine == modelLine);
	|            int modelCol = 0;
	|
	|            for (int i = firstLine; i <= Math.Min(line, wrappedModelLines.Count - 1); i++)
	|            {
	|                var wLine = wrappedModelLines[i];
	|
	|                if (i < line)
	|                {
	|                    modelCol += wLine.ColWidth;
	|                }
	|                else
	|                {
	|                    modelCol += col;
	|                }
	|            }
	|
	|            return modelCol;
	|        }
	|
	|        List<Rune> GetCurrentLine(int row) => Model.GetLine(row);
	|
	|        public void AddLine(int row, int col)
	|        {
	|            var modelRow = GetModelLineFromWrappedLines(row);
	|            var modelCol = GetModelColFromWrappedLines(row, col);
	|            var line = GetCurrentLine(modelRow);
	|            var restCount = line.Count - modelCol;
	|            var rest = line.GetRange(modelCol, restCount);
	|            line.RemoveRange(modelCol, restCount);
	|            Model.AddLine(modelRow + 1, rest);
	|            isWrapModelRefreshing = true;
	|            WrapModel(frameWidth, out _, out _, out _, out _, modelRow + 1, 0);
	|            isWrapModelRefreshing = false;
	|        }
	|
	|        public bool Insert(int row, int col, Rune rune)
	|        {
	|            var line = GetCurrentLine(GetModelLineFromWrappedLines(row));
	|            line.Insert(GetModelColFromWrappedLines(row, col), rune);
	|            if (line.Count > frameWidth)
	|            {
	|                return true;
	|            }
	|            else
	|            {
	|                return false;
	|            }
	|        }
	|
	|        public bool RemoveAt(int row, int col)
	|        {
	|            var modelRow = GetModelLineFromWrappedLines(row);
	|            var line = GetCurrentLine(modelRow);
	|            var modelCol = GetModelColFromWrappedLines(row, col);
	|
	|            if (modelCol > line.Count)
	|            {
	|                Model.RemoveLine(modelRow);
	|                RemoveAt(row, 0);
	|                return false;
	|            }
	|            if (modelCol < line.Count)
	|                line.RemoveAt(modelCol);
	|            if (line.Count > frameWidth || (row + 1 < wrappedModelLines.Count
	|                && wrappedModelLines[row + 1].ModelLine == modelRow))
	|            {
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        public bool RemoveLine(int row, int col, out bool lineRemoved, bool forward = true)
	|        {
	|            lineRemoved = false;
	|            var modelRow = GetModelLineFromWrappedLines(row);
	|            var line = GetCurrentLine(modelRow);
	|            var modelCol = GetModelColFromWrappedLines(row, col);
	|
	|            if (modelCol == 0 && line.Count == 0)
	|            {
	|                Model.RemoveLine(modelRow);
	|                return false;
	|            }
	|            else if (modelCol < line.Count)
	|            {
	|                if (forward)
	|                {
	|                    line.RemoveAt(modelCol);
	|                    return true;
	|                }
	|                else if (modelCol - 1 > -1)
	|                {
	|                    line.RemoveAt(modelCol - 1);
	|                    return true;
	|                }
	|            }
	|            lineRemoved = true;
	|            if (forward)
	|            {
	|                if (modelRow + 1 == Model.Count)
	|                {
	|                    return false;
	|                }
	|
	|                var nextLine = Model.GetLine(modelRow + 1);
	|                line.AddRange(nextLine);
	|                Model.RemoveLine(modelRow + 1);
	|                if (line.Count > frameWidth)
	|                {
	|                    return true;
	|                }
	|            }
	|            else
	|            {
	|                if (modelRow == 0)
	|                {
	|                    return false;
	|                }
	|
	|                var prevLine = Model.GetLine(modelRow - 1);
	|                prevLine.AddRange(line);
	|                Model.RemoveLine(modelRow);
	|                if (prevLine.Count > frameWidth)
	|                {
	|                    return true;
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        public bool RemoveRange(int row, int index, int count)
	|        {
	|            var modelRow = GetModelLineFromWrappedLines(row);
	|            var line = GetCurrentLine(modelRow);
	|            var modelCol = GetModelColFromWrappedLines(row, index);
	|
	|            try
	|            {
	|                line.RemoveRange(modelCol, count);
	|            }
	|            catch (Exception)
	|            {
	|                return false;
	|            }
	|
	|            return true;
	|        }
	|
	|        public void UpdateModel(TextModel model, out int nRow, out int nCol, out int nStartRow, out int nStartCol,
	|            int row, int col, int startRow, int startCol, bool preserveTrailingSpaces)
	|        {
	|            isWrapModelRefreshing = true;
	|            Model = model;
	|            WrapModel(frameWidth, out nRow, out nCol, out nStartRow, out nStartCol, row, col, startRow, startCol, tabWidth: 0, preserveTrailingSpaces);
	|            isWrapModelRefreshing = false;
	|        }
	|
	|        public int GetWrappedLineColWidth(int line, int col, WordWrapManager wrapManager)
	|        {
	|            if (wrappedModelLines?.Count == 0)
	|                return 0;
	|
	|            var wModelLines = wrapManager.wrappedModelLines;
	|            var modelLine = GetModelLineFromWrappedLines(line);
	|            var firstLine = wrappedModelLines.IndexOf(r => r.ModelLine == modelLine);
	|            int modelCol = 0;
	|            int colWidthOffset = 0;
	|            int i = firstLine;
	|
	|            while (modelCol < col)
	|            {
	|                var wLine = wrappedModelLines[i];
	|                var wLineToCompare = wModelLines[i];
	|
	|                if (wLine.ModelLine != modelLine || wLineToCompare.ModelLine != modelLine)
	|                    break;
	|
	|                modelCol += Math.Max(wLine.ColWidth, wLineToCompare.ColWidth);
	|                colWidthOffset += wLine.ColWidth - wLineToCompare.ColWidth;
	|                if (modelCol > col)
	|                {
	|                    modelCol += col - modelCol;
	|                }
	|                i++;
	|            }
	|
	|            return modelCol - colWidthOffset;
	|        }
	|    }
	|
	|    /// <summary>
	|    ///  Multi-line text editing <see cref=""View""/>.
	|    /// </summary>
	|    /// <remarks>
	|    ///  <para>
	|    ///   <see cref=""TextView""/> provides a multi-line text editor. Users interact
	|    ///   with it with the standard Windows, Mac, and Linux (Emacs) commands. 
	|    ///  </para> 
	|    ///  <list type=""table""> 
	|    ///   <listheader>
	|    ///    <term>Shortcut</term>
	|    ///    <description>Action performed</description>
	|    ///   </listheader>
	|    ///   <item>
	|    ///    <term>Left cursor, Control-b</term>
	|    ///    <description>
	|    ///     Moves the editing point left.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Right cursor, Control-f</term>
	|    ///    <description>
	|    ///     Moves the editing point right.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Alt-b</term>
	|    ///    <description>
	|    ///     Moves one word back.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Alt-f</term>
	|    ///    <description>
	|    ///     Moves one word forward.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Up cursor, Control-p</term>
	|    ///    <description>
	|    ///     Moves the editing point one line up.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Down cursor, Control-n</term>
	|    ///    <description>
	|    ///     Moves the editing point one line down
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Home key, Control-a</term>
	|    ///    <description>
	|    ///     Moves the cursor to the beginning of the line.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>End key, Control-e</term>
	|    ///    <description>
	|    ///     Moves the cursor to the end of the line.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Control-Home</term>
	|    ///    <description>
	|    ///     Scrolls to the first line and moves the cursor there.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Control-End</term>
	|    ///    <description>
	|    ///     Scrolls to the last line and moves the cursor there.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Delete, Control-d</term>
	|    ///    <description>
	|    ///     Deletes the character in front of the cursor.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Backspace</term>
	|    ///    <description>
	|    ///     Deletes the character behind the cursor.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Control-k</term>
	|    ///    <description>
	|    ///     Deletes the text until the end of the line and replaces the kill buffer
	|    ///     with the deleted text. You can paste this text in a different place by
	|    ///     using Control-y.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Control-y</term>
	|    ///    <description>
	|    ///      Pastes the content of the kill ring into the current position.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Alt-d</term>
	|    ///    <description>
	|    ///      Deletes the word above the cursor and adds it to the kill ring. You 
	|    ///      can paste the contents of the kill ring with Control-y.
	|    ///    </description>
	|    ///   </item>
	|    ///   <item>
	|    ///    <term>Control-q</term>
	|    ///    <description>
	|    ///     Quotes the next input character, to prevent the normal processing of
	|    ///     key handling to take place.
	|    ///    </description>
	|    ///   </item>
	|    ///  </list>
	|    /// </remarks>
	|    public class TextView : View
	|    {
	|        TextModel model = new TextModel();
	|        int topRow;
	|        int leftColumn;
	|        int currentRow;
	|        int currentColumn;
	|        int selectionStartColumn, selectionStartRow;
	|        bool selecting;
	|        bool wordWrap;
	|        WordWrapManager wrapManager;
	|        bool continuousFind;
	|        int bottomOffset, rightOffset;
	|        int tabWidth = 4;
	|        bool allowsTab = true;
	|        bool allowsReturn = true;
	|        bool multiline = true;
	|        HistoryText historyText = new HistoryText();
	|        CultureInfo currentCulture;
	|
	|        /// <summary>
	|        /// Raised when the <see cref=""Text""/> property of the <see cref=""TextView""/> changes.
	|        /// </summary>
	|        /// <remarks>
	|        /// The <see cref=""Text""/> property of <see cref=""TextView""/> only changes when it is explicitly
	|        /// set, not as the user types. To be notified as the user changes the contents of the TextView
	|        /// see <see cref=""IsDirty""/>.
	|        /// </remarks>
	|        public event Action TextChanged;
	|
	|        /// <summary>
	|        ///  Raised when the contents of the <see cref=""TextView""/> are changed. 
	|        /// </summary>
	|        /// <remarks>
	|        /// Unlike the <see cref=""TextChanged""/> event, this event is raised whenever the user types or
	|        /// otherwise changes the contents of the <see cref=""TextView""/>.
	|        /// </remarks>
	|        public event Action<ContentsChangedEventArgs> ContentsChanged;
	|
	|        /// <summary>
	|        /// Invoked with the unwrapped <see cref=""CursorPosition""/>.
	|        /// </summary>
	|        public event Action<Point> UnwrappedCursorPosition;
	|
	|        /// <summary>
	|        /// Provides autocomplete context menu based on suggestions at the current cursor
	|        /// position. Populate <see cref=""Autocomplete.AllSuggestions""/> to enable this feature
	|        /// </summary>
	|        public IAutocomplete Autocomplete { get; protected set; } = new TextViewAutocomplete();
	|
	|        /// <summary>
	|        ///  Initializes a <see cref=""TextView""/> on the specified area, with absolute position and size.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public TextView(Rect frame) : base(frame)
	|        {
	|            Initialize();
	|        }
	|
	|        /// <summary>
	|        ///  Initializes a <see cref=""TextView""/> on the specified area, 
	|        ///  with dimensions controlled with the X, Y, Width and Height properties.
	|        /// </summary>
	|        public TextView() : base()
	|        {
	|            Initialize();
	|        }
	|
	|        void Initialize()
	|        {
	|            CanFocus = true;
	|            Used = true;
	|
	|            model.LinesLoaded += Model_LinesLoaded;
	|            historyText.ChangeText += HistoryText_ChangeText;
	|
	|            Initialized += TextView_Initialized;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.PageDown, () => { ProcessPageDown(); return true; });
	|            AddCommand(Command.PageDownExtend, () => { ProcessPageDownExtend(); return true; });
	|            AddCommand(Command.PageUp, () => { ProcessPageUp(); return true; });
	|            AddCommand(Command.PageUpExtend, () => { ProcessPageUpExtend(); return true; });
	|            AddCommand(Command.LineDown, () => { ProcessMoveDown(); return true; });
	|            AddCommand(Command.LineDownExtend, () => { ProcessMoveDownExtend(); return true; });
	|            AddCommand(Command.LineUp, () => { ProcessMoveUp(); return true; });
	|            AddCommand(Command.LineUpExtend, () => { ProcessMoveUpExtend(); return true; });
	|            AddCommand(Command.Right, () => ProcessMoveRight());
	|            AddCommand(Command.RightExtend, () => { ProcessMoveRightExtend(); return true; });
	|            AddCommand(Command.Left, () => ProcessMoveLeft());
	|            AddCommand(Command.LeftExtend, () => { ProcessMoveLeftExtend(); return true; });
	|            AddCommand(Command.DeleteCharLeft, () => { ProcessDeleteCharLeft(); return true; });
	|            AddCommand(Command.StartOfLine, () => { ProcessMoveStartOfLine(); return true; });
	|            AddCommand(Command.StartOfLineExtend, () => { ProcessMoveStartOfLineExtend(); return true; });
	|            AddCommand(Command.DeleteCharRight, () => { ProcessDeleteCharRight(); return true; });
	|            AddCommand(Command.EndOfLine, () => { ProcessMoveEndOfLine(); return true; });
	|            AddCommand(Command.EndOfLineExtend, () => { ProcessMoveEndOfLineExtend(); return true; });
	|            AddCommand(Command.CutToEndLine, () => { KillToEndOfLine(); return true; });
	|            AddCommand(Command.CutToStartLine, () => { KillToStartOfLine(); return true; });
	|            AddCommand(Command.Paste, () => { ProcessPaste(); return true; });
	|            AddCommand(Command.ToggleExtend, () => { ToggleSelecting(); return true; });
	|            AddCommand(Command.Copy, () => { ProcessCopy(); return true; });
	|            AddCommand(Command.Cut, () => { ProcessCut(); return true; });
	|            AddCommand(Command.WordLeft, () => { ProcessMoveWordBackward(); return true; });
	|            AddCommand(Command.WordLeftExtend, () => { ProcessMoveWordBackwardExtend(); return true; });
	|            AddCommand(Command.WordRight, () => { ProcessMoveWordForward(); return true; });
	|            AddCommand(Command.WordRightExtend, () => { ProcessMoveWordForwardExtend(); return true; });
	|            AddCommand(Command.KillWordForwards, () => { ProcessKillWordForward(); return true; });
	|            AddCommand(Command.KillWordBackwards, () => { ProcessKillWordBackward(); return true; });
	|            AddCommand(Command.NewLine, () => ProcessReturn());
	|            AddCommand(Command.BottomEnd, () => { MoveBottomEnd(); return true; });
	|            AddCommand(Command.BottomEndExtend, () => { MoveBottomEndExtend(); return true; });
	|            AddCommand(Command.TopHome, () => { MoveTopHome(); return true; });
	|            AddCommand(Command.TopHomeExtend, () => { MoveTopHomeExtend(); return true; });
	|            AddCommand(Command.SelectAll, () => { ProcessSelectAll(); return true; });
	|            AddCommand(Command.ToggleOverwrite, () => { ProcessSetOverwrite(); return true; });
	|            AddCommand(Command.EnableOverwrite, () => { SetOverwrite(true); return true; });
	|            AddCommand(Command.DisableOverwrite, () => { SetOverwrite(false); return true; });
	|            AddCommand(Command.Tab, () => ProcessTab());
	|            AddCommand(Command.BackTab, () => ProcessBackTab());
	|            AddCommand(Command.NextView, () => ProcessMoveNextView());
	|            AddCommand(Command.PreviousView, () => ProcessMovePreviousView());
	|            AddCommand(Command.Undo, () => { UndoChanges(); return true; });
	|            AddCommand(Command.Redo, () => { RedoChanges(); return true; });
	|            AddCommand(Command.DeleteAll, () => { DeleteAll(); return true; });
	|            AddCommand(Command.Accept, () =>
	|            {
	|                ContextMenu.Position = new Point(CursorPosition.X - leftColumn + 2, CursorPosition.Y - topRow + 2);
	|                ShowContextMenu();
	|                return true;
	|            });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.PageDown, Command.PageDown);
	|            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);
	|
	|            AddKeyBinding(Key.PageDown | Key.ShiftMask, Command.PageDownExtend);
	|
	|            AddKeyBinding(Key.PageUp, Command.PageUp);
	|            AddKeyBinding(((int)'V' + Key.AltMask), Command.PageUp);
	|
	|            AddKeyBinding(Key.PageUp | Key.ShiftMask, Command.PageUpExtend);
	|
	|            AddKeyBinding(Key.N | Key.CtrlMask, Command.LineDown);
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|
	|            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.LineDownExtend);
	|
	|            AddKeyBinding(Key.P | Key.CtrlMask, Command.LineUp);
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|
	|            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LineUpExtend);
	|
	|            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|
	|            AddKeyBinding(Key.CursorRight | Key.ShiftMask, Command.RightExtend);
	|
	|            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|
	|            AddKeyBinding(Key.CursorLeft | Key.ShiftMask, Command.LeftExtend);
	|
	|            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
	|            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);
	|
	|            AddKeyBinding(Key.Home, Command.StartOfLine);
	|            AddKeyBinding(Key.A | Key.CtrlMask, Command.StartOfLine);
	|
	|            AddKeyBinding(Key.Home | Key.ShiftMask, Command.StartOfLineExtend);
	|
	|            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
	|            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);
	|
	|            AddKeyBinding(Key.End, Command.EndOfLine);
	|            AddKeyBinding(Key.E | Key.CtrlMask, Command.EndOfLine);
	|
	|            AddKeyBinding(Key.End | Key.ShiftMask, Command.EndOfLineExtend);
	|
	|            AddKeyBinding(Key.K | Key.CtrlMask, Command.CutToEndLine); // kill-to-end
	|            AddKeyBinding(Key.DeleteChar | Key.CtrlMask | Key.ShiftMask, Command.CutToEndLine); // kill-to-end
	|
	|            AddKeyBinding(Key.K | Key.AltMask, Command.CutToStartLine); // kill-to-start
	|            AddKeyBinding(Key.Backspace | Key.CtrlMask | Key.ShiftMask, Command.CutToStartLine); // kill-to-start
	|
	|            AddKeyBinding(Key.Y | Key.CtrlMask, Command.Paste); // Control-y, yank
	|            AddKeyBinding(Key.Space | Key.CtrlMask, Command.ToggleExtend);
	|
	|            AddKeyBinding(((int)'C' + Key.AltMask), Command.Copy);
	|            AddKeyBinding(Key.C | Key.CtrlMask, Command.Copy);
	|
	|            AddKeyBinding(((int)'W' + Key.AltMask), Command.Cut);
	|            AddKeyBinding(Key.W | Key.CtrlMask, Command.Cut);
	|            AddKeyBinding(Key.X | Key.CtrlMask, Command.Cut);
	|
	|            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.WordLeft);
	|            AddKeyBinding((Key)((int)'B' + Key.AltMask), Command.WordLeft);
	|
	|            AddKeyBinding(Key.CursorLeft | Key.CtrlMask | Key.ShiftMask, Command.WordLeftExtend);
	|
	|            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.WordRight);
	|            AddKeyBinding((Key)((int)'F' + Key.AltMask), Command.WordRight);
	|
	|            AddKeyBinding(Key.CursorRight | Key.CtrlMask | Key.ShiftMask, Command.WordRightExtend);
	|            AddKeyBinding(Key.DeleteChar | Key.CtrlMask, Command.KillWordForwards); // kill-word-forwards
	|            AddKeyBinding(Key.Backspace | Key.CtrlMask, Command.KillWordBackwards); // kill-word-backwards
	|
	|            AddKeyBinding(Key.Enter, Command.NewLine);
	|            AddKeyBinding(Key.End | Key.CtrlMask, Command.BottomEnd);
	|            AddKeyBinding(Key.End | Key.CtrlMask | Key.ShiftMask, Command.BottomEndExtend);
	|            AddKeyBinding(Key.Home | Key.CtrlMask, Command.TopHome);
	|            AddKeyBinding(Key.Home | Key.CtrlMask | Key.ShiftMask, Command.TopHomeExtend);
	|            AddKeyBinding(Key.T | Key.CtrlMask, Command.SelectAll);
	|            AddKeyBinding(Key.InsertChar, Command.ToggleOverwrite);
	|            AddKeyBinding(Key.Tab, Command.Tab);
	|            AddKeyBinding(Key.BackTab | Key.ShiftMask, Command.BackTab);
	|
	|            AddKeyBinding(Key.Tab | Key.CtrlMask, Command.NextView);
	|            AddKeyBinding(Application.AlternateForwardKey, Command.NextView);
	|
	|            AddKeyBinding(Key.Tab | Key.CtrlMask | Key.ShiftMask, Command.PreviousView);
	|            AddKeyBinding(Application.AlternateBackwardKey, Command.PreviousView);
	|
	|            AddKeyBinding(Key.Z | Key.CtrlMask, Command.Undo);
	|            AddKeyBinding(Key.R | Key.CtrlMask, Command.Redo);
	|
	|            AddKeyBinding(Key.G | Key.CtrlMask, Command.DeleteAll);
	|            AddKeyBinding(Key.D | Key.CtrlMask | Key.ShiftMask, Command.DeleteAll);
	|
	|            currentCulture = Thread.CurrentThread.CurrentUICulture;
	|
	|            ContextMenu = new ContextMenu() { MenuItems = BuildContextMenuBarItem() };
	|            ContextMenu.KeyChanged += ContextMenu_KeyChanged;
	|
	|            AddKeyBinding(ContextMenu.Key, Command.Accept);
	|        }
	|
	|        private MenuBarItem BuildContextMenuBarItem()
	|        {
	|            return new MenuBarItem(new MenuItem[] {
	|                    new MenuItem (Strings.ctxSelectAll, """", () => SelectAll (), null, null, GetKeyFromCommand (Command.SelectAll)),
	|                    new MenuItem (Strings.ctxDeleteAll, """", () => DeleteAll (), null, null, GetKeyFromCommand (Command.DeleteAll)),
	|                    new MenuItem (Strings.ctxCopy, """", () => Copy (), null, null, GetKeyFromCommand (Command.Copy)),
	|                    new MenuItem (Strings.ctxCut, """", () => Cut (), null, null, GetKeyFromCommand (Command.Cut)),
	|                    new MenuItem (Strings.ctxPaste, """", () => Paste (), null, null, GetKeyFromCommand (Command.Paste)),
	|                    new MenuItem (Strings.ctxUndo, """", () => UndoChanges (), null, null, GetKeyFromCommand (Command.Undo)),
	|                    new MenuItem (Strings.ctxRedo, """", () => RedoChanges (), null, null, GetKeyFromCommand (Command.Redo)),
	|                });
	|        }
	|
	|        private void ContextMenu_KeyChanged(Key obj)
	|        {
	|            ReplaceKeyBinding(obj, ContextMenu.Key);
	|        }
	|
	|        private void Model_LinesLoaded()
	|        {
	|            // This call is not needed. Model_LinesLoaded gets invoked when
	|            // model.LoadString (value) is called. LoadString is called from one place
	|            // (Text.set) and historyText.Clear() is called immediately after.
	|            // If this call happens, HistoryText_ChangeText will get called multiple times
	|            // when Text is set, which is wrong.
	|            //historyText.Clear (Text);
	|        }
	|
	|        private void HistoryText_ChangeText(HistoryText.HistoryTextItem obj)
	|        {
	|            SetWrapModel();
	|
	|            if (obj != null)
	|            {
	|                var startLine = obj.CursorPosition.Y;
	|
	|                if (obj.RemovedOnAdded != null)
	|                {
	|                    int offset;
	|                    if (obj.IsUndoing)
	|                    {
	|                        offset = Math.Max(obj.RemovedOnAdded.Lines.Count - obj.Lines.Count, 1);
	|                    }
	|                    else
	|                    {
	|                        offset = obj.RemovedOnAdded.Lines.Count - 1;
	|                    }
	|                    for (int i = 0; i < offset; i++)
	|                    {
	|                        if (Lines > obj.RemovedOnAdded.CursorPosition.Y)
	|                        {
	|                            model.RemoveLine(obj.RemovedOnAdded.CursorPosition.Y);
	|                        }
	|                        else
	|                        {
	|                            break;
	|                        }
	|                    }
	|                }
	|
	|                for (int i = 0; i < obj.Lines.Count; i++)
	|                {
	|                    if (i == 0)
	|                    {
	|                        model.ReplaceLine(startLine, obj.Lines[i]);
	|                    }
	|                    else if ((obj.IsUndoing && obj.LineStatus == HistoryText.LineStatus.Removed)
	|                          || !obj.IsUndoing && obj.LineStatus == HistoryText.LineStatus.Added)
	|                    {
	|                        model.AddLine(startLine, obj.Lines[i]);
	|                    }
	|                    else if (Lines > obj.CursorPosition.Y + 1)
	|                    {
	|                        model.RemoveLine(obj.CursorPosition.Y + 1);
	|                    }
	|                    startLine++;
	|                }
	|
	|                CursorPosition = obj.FinalCursorPosition;
	|            }
	|
	|            UpdateWrapModel();
	|
	|            Adjust();
	|            OnContentsChanged();
	|        }
	|
	|        void TextView_Initialized(object sender, EventArgs e)
	|        {
	|            Autocomplete.HostControl = this;
	|
	|            if (Application.Top != null)
	|            {
	|                Application.Top.AlternateForwardKeyChanged += Top_AlternateForwardKeyChanged;
	|                Application.Top.AlternateBackwardKeyChanged += Top_AlternateBackwardKeyChanged;
	|            }
	|            OnContentsChanged();
	|        }
	|
	|        void Top_AlternateBackwardKeyChanged(Key obj)
	|        {
	|            ReplaceKeyBinding(obj, Application.AlternateBackwardKey);
	|        }
	|
	|        void Top_AlternateForwardKeyChanged(Key obj)
	|        {
	|            ReplaceKeyBinding(obj, Application.AlternateForwardKey);
	|        }
	|
	|        /// <summary>
	|        /// Tracks whether the text view should be considered ""used"", that is, that the user has moved in the entry,
	|        /// so new input should be appended at the cursor position, rather than clearing the entry
	|        /// </summary>
	|        public bool Used { get; set; }
	|
	|        void ResetPosition()
	|        {
	|            topRow = leftColumn = currentRow = currentColumn = 0;
	|            StopSelecting();
	|            ResetCursorVisibility();
	|        }
	|
	|        /// <summary>
	|        ///  Sets or gets the text in the <see cref=""TextView""/>.
	|        /// </summary>
	|        /// <remarks>
	|        /// The <see cref=""TextChanged""/> event is fired whenever this property is set. Note, however,
	|        /// that Text is not set by <see cref=""TextView""/> as the user types.
	|        /// </remarks>
	|        public override ustring Text
	|        {
	|            get
	|            {
	|                if (wordWrap)
	|                {
	|                    return wrapManager.Model.ToString();
	|                }
	|                else
	|                {
	|                    return model.ToString();
	|                }
	|            }
	|
	|            set
	|            {
	|                ResetPosition();
	|                model.LoadString(value);
	|                if (wordWrap)
	|                {
	|                    wrapManager = new WordWrapManager(model);
	|                    model = wrapManager.WrapModel(frameWidth, out _, out _, out _, out _);
	|                }
	|                TextChanged?.Invoke();
	|                SetNeedsDisplay();
	|
	|                historyText.Clear(Text);
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override Rect Frame
	|        {
	|            get => base.Frame;
	|            set
	|            {
	|                base.Frame = value;
	|                WrapTextModel();
	|                Adjust();
	|            }
	|        }
	|
	|        void WrapTextModel()
	|        {
	|            if (wordWrap && wrapManager != null)
	|            {
	|                model = wrapManager.WrapModel(frameWidth,
	|                    out int nRow, out int nCol,
	|                    out int nStartRow, out int nStartCol,
	|                    currentRow, currentColumn,
	|                    selectionStartRow, selectionStartColumn,
	|                    tabWidth, preserveTrailingSpaces: true);
	|                currentRow = nRow;
	|                currentColumn = nCol;
	|                selectionStartRow = nStartRow;
	|                selectionStartColumn = nStartCol;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        int frameWidth => Math.Max(Frame.Width - (RightOffset != 0 ? 2 : 1), 0);
	|
	|        /// <summary>
	|        /// Gets or sets the top row.
	|        /// </summary>
	|        public int TopRow { get => topRow; set => topRow = Math.Max(Math.Min(value, Lines - 1), 0); }
	|
	|        /// <summary>
	|        /// Gets or sets the left column.
	|        /// </summary>
	|        public int LeftColumn
	|        {
	|            get => leftColumn;
	|            set
	|            {
	|                if (value > 0 && wordWrap)
	|                    return;
	|                leftColumn = Math.Max(Math.Min(value, Maxlength - 1), 0);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the maximum visible length line.
	|        /// </summary>
	|        public int Maxlength => model.GetMaxVisibleLine(topRow, topRow + Frame.Height, TabWidth);
	|
	|        /// <summary>
	|        /// Gets the number of lines.
	|        /// </summary>
	|        public int Lines => model.Count;
	|
	|        /// <summary>
	|        ///  Sets or gets the current cursor position.
	|        /// </summary>
	|        public Point CursorPosition
	|        {
	|            get => new Point(currentColumn, currentRow);
	|            set
	|            {
	|                var line = model.GetLine(Math.Max(Math.Min(value.Y, model.Count - 1), 0));
	|                currentColumn = value.X < 0 ? 0 : value.X > line.Count ? line.Count : value.X;
	|                currentRow = value.Y < 0 ? 0 : value.Y > model.Count - 1
	|                    ? Math.Max(model.Count - 1, 0) : value.Y;
	|                SetNeedsDisplay();
	|                Adjust();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Start column position of the selected text.
	|        /// </summary>
	|        public int SelectionStartColumn
	|        {
	|            get => selectionStartColumn;
	|            set
	|            {
	|                var line = model.GetLine(currentRow);
	|                selectionStartColumn = value < 0 ? 0 : value > line.Count ? line.Count : value;
	|                selecting = true;
	|                SetNeedsDisplay();
	|                Adjust();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Start row position of the selected text.
	|        /// </summary>
	|        public int SelectionStartRow
	|        {
	|            get => selectionStartRow;
	|            set
	|            {
	|                selectionStartRow = value < 0 ? 0 : value > model.Count - 1
	|                    ? Math.Max(model.Count - 1, 0) : value;
	|                selecting = true;
	|                SetNeedsDisplay();
	|                Adjust();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The selected text.
	|        /// </summary>
	|        public ustring SelectedText
	|        {
	|            get
	|            {
	|                if (!selecting || (model.Count == 1 && model.GetLine(0).Count == 0))
	|                {
	|                    return ustring.Empty;
	|                }
	|
	|                return GetSelectedRegion();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Length of the selected text.
	|        /// </summary>
	|        public int SelectedLength => GetSelectedLength();
	|
	|        /// <summary>
	|        /// Get or sets the selecting.
	|        /// </summary>
	|        public bool Selecting
	|        {
	|            get => selecting;
	|            set => selecting = value;
	|        }
	|        /// <summary>
	|        /// Allows word wrap the to fit the available container width.
	|        /// </summary>
	|        public bool WordWrap
	|        {
	|            get => wordWrap;
	|            set
	|            {
	|                if (value == wordWrap)
	|                {
	|                    return;
	|                }
	|                if (value && !multiline)
	|                {
	|                    return;
	|                }
	|                wordWrap = value;
	|                ResetPosition();
	|                if (wordWrap)
	|                {
	|                    wrapManager = new WordWrapManager(model);
	|                    model = wrapManager.WrapModel(frameWidth, out _, out _, out _, out _);
	|                }
	|                else if (!wordWrap && wrapManager != null)
	|                {
	|                    model = wrapManager.Model;
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The bottom offset needed to use a horizontal scrollbar or for another reason.
	|        /// This is only needed with the keyboard navigation.
	|        /// </summary>
	|        public int BottomOffset
	|        {
	|            get => bottomOffset;
	|            set
	|            {
	|                topRow = AdjustOffset(value);
	|                bottomOffset = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The right offset needed to use a vertical scrollbar or for another reason.
	|        /// This is only needed with the keyboard navigation.
	|        /// </summary>
	|        public int RightOffset
	|        {
	|            get => rightOffset;
	|            set
	|            {
	|                leftColumn = AdjustOffset(value, false);
	|                rightOffset = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether pressing ENTER in a <see cref=""TextView""/>
	|        /// creates a new line of text in the view or activates the default button for the toplevel.
	|        /// </summary>
	|        public bool AllowsReturn
	|        {
	|            get => allowsReturn;
	|            set
	|            {
	|                allowsReturn = value;
	|                if (allowsReturn && !multiline)
	|                {
	|                    Multiline = true;
	|                }
	|                if (!allowsReturn && multiline)
	|                {
	|                    Multiline = false;
	|                    AllowsTab = false;
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets whether the <see cref=""TextView""/> inserts a tab character into the text or ignores 
	|        /// tab input. If set to `false` and the user presses the tab key (or shift-tab) the focus will move to the
	|        /// next view (or previous with shift-tab). The default is `true`; if the user presses the tab key, a tab 
	|        /// character will be inserted into the text.
	|        /// </summary>
	|        public bool AllowsTab
	|        {
	|            get => allowsTab;
	|            set
	|            {
	|                allowsTab = value;
	|                if (allowsTab && tabWidth == 0)
	|                {
	|                    tabWidth = 4;
	|                }
	|                if (allowsTab && !multiline)
	|                {
	|                    Multiline = true;
	|                }
	|                if (!allowsTab && tabWidth > 0)
	|                {
	|                    tabWidth = 0;
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating the number of whitespace when pressing the TAB key.
	|        /// </summary>
	|        public int TabWidth
	|        {
	|            get => tabWidth;
	|            set
	|            {
	|                tabWidth = Math.Max(value, 0);
	|                if (tabWidth > 0 && !AllowsTab)
	|                {
	|                    AllowsTab = true;
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        Dim savedHeight = null;
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""TextView""/> is a multiline text view.
	|        /// </summary>
	|        public bool Multiline
	|        {
	|            get => multiline;
	|            set
	|            {
	|                multiline = value;
	|                if (multiline && !allowsTab)
	|                {
	|                    AllowsTab = true;
	|                }
	|                if (multiline && !allowsReturn)
	|                {
	|                    AllowsReturn = true;
	|                }
	|
	|                if (!multiline)
	|                {
	|                    AllowsReturn = false;
	|                    AllowsTab = false;
	|                    WordWrap = false;
	|                    currentColumn = 0;
	|                    currentRow = 0;
	|                    savedHeight = Height;
	|                    var lyout = LayoutStyle;
	|                    if (LayoutStyle == LayoutStyle.Computed)
	|                    {
	|                        LayoutStyle = LayoutStyle.Absolute;
	|                    }
	|                    Height = 1;
	|                    LayoutStyle = lyout;
	|                    Autocomplete.PopupInsideContainer = false;
	|                    SetNeedsDisplay();
	|                }
	|                else if (multiline && savedHeight != null)
	|                {
	|                    var lyout = LayoutStyle;
	|                    if (LayoutStyle == LayoutStyle.Computed)
	|                    {
	|                        LayoutStyle = LayoutStyle.Absolute;
	|                    }
	|                    Height = savedHeight;
	|                    LayoutStyle = lyout;
	|                    Autocomplete.PopupInsideContainer = true;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Indicates whatever the text was changed or not.
	|        /// <see langword=""true""/> if the text was changed <see langword=""false""/> otherwise.
	|        /// </summary>
	|        public bool IsDirty => historyText.IsDirty(Text);
	|
	|        /// <summary>
	|        /// Indicates whatever the text has history changes or not.
	|        /// <see langword=""true""/> if the text has history changes <see langword=""false""/> otherwise.
	|        /// </summary>
	|        public bool HasHistoryChanges => historyText.HasHistoryChanges;
	|
	|        /// <summary>
	|        /// Get the <see cref=""ContextMenu""/> for this view.
	|        /// </summary>
	|        public ContextMenu ContextMenu { get; private set; }
	|
	|        int GetSelectedLength()
	|        {
	|            return SelectedText.Length;
	|        }
	|
	|        CursorVisibility savedCursorVisibility;
	|
	|        void SaveCursorVisibility()
	|        {
	|            if (desiredCursorVisibility != CursorVisibility.Invisible)
	|            {
	|                if (savedCursorVisibility == 0)
	|                {
	|                    savedCursorVisibility = desiredCursorVisibility;
	|                }
	|                DesiredCursorVisibility = CursorVisibility.Invisible;
	|            }
	|        }
	|
	|        void ResetCursorVisibility()
	|        {
	|            if (savedCursorVisibility != 0)
	|            {
	|                DesiredCursorVisibility = savedCursorVisibility;
	|                savedCursorVisibility = 0;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Loads the contents of the file into the <see cref=""TextView""/>.
	|        /// </summary>
	|        /// <returns><c>true</c>, if file was loaded, <c>false</c> otherwise.</returns>
	|        /// <param name=""path"">Path to the file to load.</param>
	|        public bool LoadFile(string path)
	|        {
	|            bool res;
	|            try
	|            {
	|                SetWrapModel();
	|                res = model.LoadFile(path);
	|                historyText.Clear(Text);
	|                ResetPosition();
	|            }
	|            catch (Exception)
	|            {
	|                throw;
	|            }
	|            finally
	|            {
	|                UpdateWrapModel();
	|                SetNeedsDisplay();
	|                Adjust();
	|            }
	|            return res;
	|        }
	|
	|        /// <summary>
	|        /// Loads the contents of the stream into the <see cref=""TextView""/>.
	|        /// </summary>
	|        /// <returns><c>true</c>, if stream was loaded, <c>false</c> otherwise.</returns>
	|        /// <param name=""stream"">Stream to load the contents from.</param>
	|        public void LoadStream(Stream stream)
	|        {
	|            model.LoadStream(stream);
	|            historyText.Clear(Text);
	|            ResetPosition();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Closes the contents of the stream into the <see cref=""TextView""/>.
	|        /// </summary>
	|        /// <returns><c>true</c>, if stream was closed, <c>false</c> otherwise.</returns>
	|        public bool CloseFile()
	|        {
	|            var res = model.CloseFile();
	|            ResetPosition();
	|            SetNeedsDisplay();
	|            return res;
	|        }
	|
	|        /// <summary>
	|        ///  Gets the current cursor row.
	|        /// </summary>
	|        public int CurrentRow => currentRow;
	|
	|        /// <summary>
	|        /// Gets the cursor column.
	|        /// </summary>
	|        /// <value>The cursor column.</value>
	|        public int CurrentColumn => currentColumn;
	|
	|        /// <summary>
	|        ///  Positions the cursor on the current row and column
	|        /// </summary>
	|        public override void PositionCursor()
	|        {
	|            if (!CanFocus || !Enabled)
	|            {
	|                return;
	|            }
	|
	|            if (selecting)
	|            {
	|                var minRow = Math.Min(Math.Max(Math.Min(selectionStartRow, currentRow) - topRow, 0), Frame.Height);
	|                var maxRow = Math.Min(Math.Max(Math.Max(selectionStartRow, currentRow) - topRow, 0), Frame.Height);
	|
	|                SetNeedsDisplay(new Rect(0, minRow, Frame.Width, maxRow));
	|            }
	|            var line = model.GetLine(currentRow);
	|            var col = 0;
	|            if (line.Count > 0)
	|            {
	|                for (int idx = leftColumn; idx < line.Count; idx++)
	|                {
	|                    if (idx >= currentColumn)
	|                        break;
	|                    var cols = Rune.ColumnWidth(line[idx]);
	|                    if (line[idx] == '\t')
	|                    {
	|                        cols += TabWidth + 1;
	|                    }
	|                    if (!TextModel.SetCol(ref col, Frame.Width, cols))
	|                    {
	|                        col = currentColumn;
	|                        break;
	|                    }
	|                }
	|            }
	|            var posX = currentColumn - leftColumn;
	|            var posY = currentRow - topRow;
	|            if (posX > -1 && col >= posX && posX < Frame.Width - RightOffset
	|                && topRow <= currentRow && posY < Frame.Height - BottomOffset)
	|            {
	|                ResetCursorVisibility();
	|                Move(col, currentRow - topRow);
	|            }
	|            else
	|            {
	|                SaveCursorVisibility();
	|            }
	|        }
	|
	|        void ClearRegion(int left, int top, int right, int bottom)
	|        {
	|            for (int row = top; row < bottom; row++)
	|            {
	|                Move(left, row);
	|                for (int col = left; col < right; col++)
	|                    AddRune(col, row, ' ');
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Sets the driver to the default color for the control where no text is being rendered. Defaults to <see cref=""ColorScheme.Normal""/>.
	|        /// </summary>
	|        protected virtual void SetNormalColor()
	|        {
	|            Driver.SetAttribute(GetNormalColor());
	|        }
	|
	|        /// <summary>
	|        /// Sets the <see cref=""View.Driver""/> to an appropriate color for rendering the given <paramref name=""idx""/> of the
	|        /// current <paramref name=""line""/>. Override to provide custom coloring by calling <see cref=""ConsoleDriver.SetAttribute(Attribute)""/>
	|        /// Defaults to <see cref=""ColorScheme.Normal""/>.
	|        /// </summary>
	|        /// <param name=""line""></param>
	|        /// <param name=""idx""></param>
	|        protected virtual void SetNormalColor(List<Rune> line, int idx)
	|        {
	|            Driver.SetAttribute(GetNormalColor());
	|        }
	|
	|        /// <summary>
	|        /// Sets the <see cref=""View.Driver""/> to an appropriate color for rendering the given <paramref name=""idx""/> of the
	|        /// current <paramref name=""line""/>. Override to provide custom coloring by calling <see cref=""ConsoleDriver.SetAttribute(Attribute)""/>
	|        /// Defaults to <see cref=""ColorScheme.Focus""/>.
	|        /// </summary>
	|        /// <param name=""line""></param>
	|        /// <param name=""idx""></param>
	|        protected virtual void SetSelectionColor(List<Rune> line, int idx)
	|        {
	|            Driver.SetAttribute(new Attribute(ColorScheme.Focus.Background, ColorScheme.Focus.Foreground));
	|        }
	|
	|        /// <summary>
	|        /// Sets the <see cref=""View.Driver""/> to an appropriate color for rendering the given <paramref name=""idx""/> of the
	|        /// current <paramref name=""line""/>. Override to provide custom coloring by calling <see cref=""ConsoleDriver.SetAttribute(Attribute)""/>
	|        /// Defaults to <see cref=""ColorScheme.Focus""/>.
	|        /// </summary>
	|        /// <param name=""line""></param>
	|        /// <param name=""idx""></param>
	|        protected virtual void SetReadOnlyColor(List<Rune> line, int idx)
	|        {
	|            Attribute attribute;
	|            if (ColorScheme.Disabled.Foreground == ColorScheme.Focus.Background)
	|            {
	|                attribute = new Attribute(ColorScheme.Focus.Foreground, ColorScheme.Focus.Background);
	|            }
	|            else
	|            {
	|                attribute = new Attribute(ColorScheme.Disabled.Foreground, ColorScheme.Focus.Background);
	|            }
	|            Driver.SetAttribute(attribute);
	|        }
	|
	|        /// <summary>
	|        /// Sets the <see cref=""View.Driver""/> to an appropriate color for rendering the given <paramref name=""idx""/> of the
	|        /// current <paramref name=""line""/>. Override to provide custom coloring by calling <see cref=""ConsoleDriver.SetAttribute(Attribute)""/>
	|        /// Defaults to <see cref=""ColorScheme.HotFocus""/>.
	|        /// </summary>
	|        /// <param name=""line""></param>
	|        /// <param name=""idx""></param>
	|        protected virtual void SetUsedColor(List<Rune> line, int idx)
	|        {
	|            Driver.SetAttribute(ColorScheme.HotFocus);
	|        }
	|
	|        bool isReadOnly = false;
	|
	|        /// <summary>
	|        /// Gets or sets whether the <see cref=""TextView""/> is in read-only mode or not
	|        /// </summary>
	|        /// <value>Boolean value(Default false)</value>
	|        public bool ReadOnly
	|        {
	|            get => isReadOnly;
	|            set
	|            {
	|                if (value != isReadOnly)
	|                {
	|                    isReadOnly = value;
	|
	|                    SetNeedsDisplay();
	|                    Adjust();
	|                }
	|            }
	|        }
	|
	|        CursorVisibility desiredCursorVisibility = CursorVisibility.Default;
	|
	|        /// <summary>
	|        /// Get / Set the wished cursor when the field is focused
	|        /// </summary>
	|        public CursorVisibility DesiredCursorVisibility
	|        {
	|            get => desiredCursorVisibility;
	|            set
	|            {
	|                if (HasFocus)
	|                {
	|                    Application.Driver.SetCursorVisibility(value);
	|                }
	|
	|                desiredCursorVisibility = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            //TODO: Improve it by handling read only mode of the text field
	|            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnLeave(View view)
	|        {
	|            if (Application.MouseGrabView != null && Application.MouseGrabView == this)
	|            {
	|                Application.UngrabMouse();
	|            }
	|
	|            return base.OnLeave(view);
	|        }
	|
	|        // Returns an encoded region start..end (top 32 bits are the row, low32 the column)
	|        void GetEncodedRegionBounds(out long start, out long end,
	|            int? startRow = null, int? startCol = null, int? cRow = null, int? cCol = null)
	|        {
	|            long selection;
	|            long point;
	|            if (startRow == null || startCol == null || cRow == null || cCol == null)
	|            {
	|                selection = ((long)(uint)selectionStartRow << 32) | (uint)selectionStartColumn;
	|                point = ((long)(uint)currentRow << 32) | (uint)currentColumn;
	|            }
	|            else
	|            {
	|                selection = ((long)(uint)startRow << 32) | (uint)startCol;
	|                point = ((long)(uint)cRow << 32) | (uint)cCol;
	|            }
	|            if (selection > point)
	|            {
	|                start = point;
	|                end = selection;
	|            }
	|            else
	|            {
	|                start = selection;
	|                end = point;
	|            }
	|        }
	|
	|        bool PointInSelection(int col, int row)
	|        {
	|            long start, end;
	|            GetEncodedRegionBounds(out start, out end);
	|            var q = ((long)(uint)row << 32) | (uint)col;
	|            return q >= start && q <= end - 1;
	|        }
	|
	|        //
	|        // Returns a ustring with the text in the selected 
	|        // region.
	|        //
	|        ustring GetRegion(int? sRow = null, int? sCol = null, int? cRow = null, int? cCol = null, TextModel model = null)
	|        {
	|            long start, end;
	|            GetEncodedRegionBounds(out start, out end, sRow, sCol, cRow, cCol);
	|            if (start == end)
	|            {
	|                return ustring.Empty;
	|            }
	|            int startRow = (int)(start >> 32);
	|            var maxrow = ((int)(end >> 32));
	|            int startCol = (int)(start & 0xffffffff);
	|            var endCol = (int)(end & 0xffffffff);
	|            var line = model == null ? this.model.GetLine(startRow) : model.GetLine(startRow);
	|
	|            if (startRow == maxrow)
	|                return StringFromRunes(line.GetRange(startCol, endCol - startCol));
	|
	|            ustring res = StringFromRunes(line.GetRange(startCol, line.Count - startCol));
	|
	|            for (int row = startRow + 1; row < maxrow; row++)
	|            {
	|                res = res + ustring.Make(Environment.NewLine) + StringFromRunes(model == null
	|                    ? this.model.GetLine(row) : model.GetLine(row));
	|            }
	|            line = model == null ? this.model.GetLine(maxrow) : model.GetLine(maxrow);
	|            res = res + ustring.Make(Environment.NewLine) + StringFromRunes(line.GetRange(0, endCol));
	|            return res;
	|        }
	|
	|        //
	|        // Clears the contents of the selected region
	|        //
	|        void ClearRegion()
	|        {
	|            SetWrapModel();
	|
	|            long start, end;
	|            long currentEncoded = ((long)(uint)currentRow << 32) | (uint)currentColumn;
	|            GetEncodedRegionBounds(out start, out end);
	|            int startRow = (int)(start >> 32);
	|            var maxrow = ((int)(end >> 32));
	|            int startCol = (int)(start & 0xffffffff);
	|            var endCol = (int)(end & 0xffffffff);
	|            var line = model.GetLine(startRow);
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, new Point(startCol, startRow));
	|
	|            List<List<Rune>> removedLines = new List<List<Rune>>();
	|
	|            if (startRow == maxrow)
	|            {
	|                removedLines.Add(new List<Rune>(line));
	|
	|                line.RemoveRange(startCol, endCol - startCol);
	|                currentColumn = startCol;
	|                if (wordWrap)
	|                {
	|                    SetNeedsDisplay();
	|                }
	|                else
	|                {
	|                    SetNeedsDisplay(new Rect(0, startRow - topRow, Frame.Width, startRow - topRow + 1));
	|                }
	|
	|                historyText.Add(new List<List<Rune>>(removedLines), CursorPosition, HistoryText.LineStatus.Removed);
	|
	|                UpdateWrapModel();
	|
	|                return;
	|            }
	|
	|            removedLines.Add(new List<Rune>(line));
	|
	|            line.RemoveRange(startCol, line.Count - startCol);
	|            var line2 = model.GetLine(maxrow);
	|            line.AddRange(line2.Skip(endCol));
	|            for (int row = startRow + 1; row <= maxrow; row++)
	|            {
	|
	|                removedLines.Add(new List<Rune>(model.GetLine(startRow + 1)));
	|
	|                model.RemoveLine(startRow + 1);
	|            }
	|            if (currentEncoded == end)
	|            {
	|                currentRow -= maxrow - (startRow);
	|            }
	|            currentColumn = startCol;
	|
	|            historyText.Add(new List<List<Rune>>(removedLines), CursorPosition,
	|                HistoryText.LineStatus.Removed);
	|
	|            UpdateWrapModel();
	|
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Select all text.
	|        /// </summary>
	|        public void SelectAll()
	|        {
	|            if (model.Count == 0)
	|            {
	|                return;
	|            }
	|
	|            StartSelecting();
	|            selectionStartColumn = 0;
	|            selectionStartRow = 0;
	|            currentColumn = model.GetLine(model.Count - 1).Count;
	|            currentRow = model.Count - 1;
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Find the next text based on the match case with the option to replace it.
	|        /// </summary>
	|        /// <param name=""textToFind"">The text to find.</param>
	|        /// <param name=""gaveFullTurn""><c>true</c>If all the text was forward searched.<c>false</c>otherwise.</param>
	|        /// <param name=""matchCase"">The match case setting.</param>
	|        /// <param name=""matchWholeWord"">The match whole word setting.</param>
	|        /// <param name=""textToReplace"">The text to replace.</param>
	|        /// <param name=""replace""><c>true</c>If is replacing.<c>false</c>otherwise.</param>
	|        /// <returns><c>true</c>If the text was found.<c>false</c>otherwise.</returns>
	|        public bool FindNextText(ustring textToFind, out bool gaveFullTurn, bool matchCase = false,
	|            bool matchWholeWord = false, ustring textToReplace = null, bool replace = false)
	|        {
	|            if (model.Count == 0)
	|            {
	|                gaveFullTurn = false;
	|                return false;
	|            }
	|
	|            SetWrapModel();
	|            ResetContinuousFind();
	|            var foundPos = model.FindNextText(textToFind, out gaveFullTurn, matchCase, matchWholeWord);
	|
	|            return SetFoundText(textToFind, foundPos, textToReplace, replace);
	|        }
	|
	|        /// <summary>
	|        /// Find the previous text based on the match case with the option to replace it.
	|        /// </summary>
	|        /// <param name=""textToFind"">The text to find.</param>
	|        /// <param name=""gaveFullTurn""><c>true</c>If all the text was backward searched.<c>false</c>otherwise.</param>
	|        /// <param name=""matchCase"">The match case setting.</param>
	|        /// <param name=""matchWholeWord"">The match whole word setting.</param>
	|        /// <param name=""textToReplace"">The text to replace.</param>
	|        /// <param name=""replace""><c>true</c>If the text was found.<c>false</c>otherwise.</param>
	|        /// <returns><c>true</c>If the text was found.<c>false</c>otherwise.</returns>
	|        public bool FindPreviousText(ustring textToFind, out bool gaveFullTurn, bool matchCase = false,
	|            bool matchWholeWord = false, ustring textToReplace = null, bool replace = false)
	|        {
	|            if (model.Count == 0)
	|            {
	|                gaveFullTurn = false;
	|                return false;
	|            }
	|
	|            SetWrapModel();
	|            ResetContinuousFind();
	|            var foundPos = model.FindPreviousText(textToFind, out gaveFullTurn, matchCase, matchWholeWord);
	|
	|            return SetFoundText(textToFind, foundPos, textToReplace, replace);
	|        }
	|
	|        /// <summary>
	|        /// Reset the flag to stop continuous find.
	|        /// </summary>
	|        public void FindTextChanged()
	|        {
	|            continuousFind = false;
	|        }
	|
	|        /// <summary>
	|        /// Replaces all the text based on the match case.
	|        /// </summary>
	|        /// <param name=""textToFind"">The text to find.</param>
	|        /// <param name=""matchCase"">The match case setting.</param>
	|        /// <param name=""matchWholeWord"">The match whole word setting.</param>
	|        /// <param name=""textToReplace"">The text to replace.</param>
	|        /// <returns><c>true</c>If the text was found.<c>false</c>otherwise.</returns>
	|        public bool ReplaceAllText(ustring textToFind, bool matchCase = false, bool matchWholeWord = false,
	|            ustring textToReplace = null)
	|        {
	|            if (isReadOnly || model.Count == 0)
	|            {
	|                return false;
	|            }
	|
	|            SetWrapModel();
	|            ResetContinuousFind();
	|            var foundPos = model.ReplaceAllText(textToFind, matchCase, matchWholeWord, textToReplace);
	|
	|            return SetFoundText(textToFind, foundPos, textToReplace, false, true);
	|        }
	|
	|        bool SetFoundText(ustring text, (Point current, bool found) foundPos,
	|            ustring textToReplace = null, bool replace = false, bool replaceAll = false)
	|        {
	|            if (foundPos.found)
	|            {
	|                StartSelecting();
	|                selectionStartColumn = foundPos.current.X;
	|                selectionStartRow = foundPos.current.Y;
	|                if (!replaceAll)
	|                {
	|                    currentColumn = selectionStartColumn + text.RuneCount;
	|                }
	|                else
	|                {
	|                    currentColumn = selectionStartColumn + textToReplace.RuneCount;
	|                }
	|                currentRow = foundPos.current.Y;
	|                if (!isReadOnly && replace)
	|                {
	|                    Adjust();
	|                    ClearSelectedRegion();
	|                    InsertText(textToReplace);
	|                    StartSelecting();
	|                    selectionStartColumn = currentColumn - textToReplace.RuneCount;
	|                }
	|                else
	|                {
	|                    UpdateWrapModel();
	|                    SetNeedsDisplay();
	|                    Adjust();
	|                }
	|                continuousFind = true;
	|                return foundPos.found;
	|            }
	|            UpdateWrapModel();
	|            continuousFind = false;
	|
	|            return foundPos.found;
	|        }
	|
	|        void ResetContinuousFind()
	|        {
	|            if (!continuousFind)
	|            {
	|                var col = selecting ? selectionStartColumn : currentColumn;
	|                var row = selecting ? selectionStartRow : currentRow;
	|                model.ResetContinuousFind(new Point(col, row));
	|            }
	|        }
	|
	|        string currentCaller;
	|
	|        /// <summary>
	|        /// Restore from original model.
	|        /// </summary>
	|        void SetWrapModel([CallerMemberName] string caller = null)
	|        {
	|            if (currentCaller != null)
	|                return;
	|
	|            if (wordWrap)
	|            {
	|                currentCaller = caller;
	|
	|                currentColumn = wrapManager.GetModelColFromWrappedLines(currentRow, currentColumn);
	|                currentRow = wrapManager.GetModelLineFromWrappedLines(currentRow);
	|                selectionStartColumn = wrapManager.GetModelColFromWrappedLines(selectionStartRow, selectionStartColumn);
	|                selectionStartRow = wrapManager.GetModelLineFromWrappedLines(selectionStartRow);
	|                model = wrapManager.Model;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Update the original model.
	|        /// </summary>
	|        void UpdateWrapModel([CallerMemberName] string caller = null)
	|        {
	|            if (currentCaller != null && currentCaller != caller)
	|                return;
	|
	|            if (wordWrap)
	|            {
	|                currentCaller = null;
	|
	|                wrapManager.UpdateModel(model, out int nRow, out int nCol,
	|                    out int nStartRow, out int nStartCol,
	|                    currentRow, currentColumn,
	|                    selectionStartRow, selectionStartColumn, preserveTrailingSpaces: true);
	|                currentRow = nRow;
	|                currentColumn = nCol;
	|                selectionStartRow = nStartRow;
	|                selectionStartColumn = nStartCol;
	|                wrapNeeded = true;
	|
	|                SetNeedsDisplay();
	|            }
	|            if (currentCaller != null)
	|                throw new InvalidOperationException($""WordWrap settings was changed after the {currentCaller} call."");
	|        }
	|
	|        /// <summary>
	|        /// Invoke the <see cref=""UnwrappedCursorPosition""/> event with the unwrapped <see cref=""CursorPosition""/>.
	|        /// </summary>
	|        public virtual void OnUnwrappedCursorPosition(int? cRow = null, int? cCol = null)
	|        {
	|            var row = cRow == null ? currentRow : cRow;
	|            var col = cCol == null ? currentColumn : cCol;
	|            if (cRow == null && cCol == null && wordWrap)
	|            {
	|                row = wrapManager.GetModelLineFromWrappedLines(currentRow);
	|                col = wrapManager.GetModelColFromWrappedLines(currentRow, currentColumn);
	|            }
	|            UnwrappedCursorPosition?.Invoke(new Point((int)col, (int)row));
	|        }
	|
	|        ustring GetSelectedRegion()
	|        {
	|            var cRow = currentRow;
	|            var cCol = currentColumn;
	|            var startRow = selectionStartRow;
	|            var startCol = selectionStartColumn;
	|            var model = this.model;
	|            if (wordWrap)
	|            {
	|                cRow = wrapManager.GetModelLineFromWrappedLines(currentRow);
	|                cCol = wrapManager.GetModelColFromWrappedLines(currentRow, currentColumn);
	|                startRow = wrapManager.GetModelLineFromWrappedLines(selectionStartRow);
	|                startCol = wrapManager.GetModelColFromWrappedLines(selectionStartRow, selectionStartColumn);
	|                model = wrapManager.Model;
	|            }
	|            OnUnwrappedCursorPosition(cRow, cCol);
	|            return GetRegion(startRow, startCol, cRow, cCol, model);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            SetNormalColor();
	|
	|            var offB = OffSetBackground();
	|            int right = Frame.Width + offB.width + RightOffset;
	|            int bottom = Frame.Height + offB.height + BottomOffset;
	|            var row = 0;
	|            for (int idxRow = topRow; idxRow < model.Count; idxRow++)
	|            {
	|                var line = model.GetLine(idxRow);
	|                int lineRuneCount = line.Count;
	|                var col = 0;
	|
	|                Move(0, row);
	|                for (int idxCol = leftColumn; idxCol < lineRuneCount; idxCol++)
	|                {
	|                    var rune = idxCol >= lineRuneCount ? ' ' : line[idxCol];
	|                    var cols = Rune.ColumnWidth(rune);
	|                    if (idxCol < line.Count && selecting && PointInSelection(idxCol, idxRow))
	|                    {
	|                        SetSelectionColor(line, idxCol);
	|                    }
	|                    else if (idxCol == currentColumn && idxRow == currentRow && !selecting && !Used
	|                      && HasFocus && idxCol < lineRuneCount)
	|                    {
	|                        SetSelectionColor(line, idxCol);
	|                    }
	|                    else if (ReadOnly)
	|                    {
	|                        SetReadOnlyColor(line, idxCol);
	|                    }
	|                    else
	|                    {
	|                        SetNormalColor(line, idxCol);
	|                    }
	|
	|                    if (rune == '\t')
	|                    {
	|                        cols += TabWidth + 1;
	|                        if (col + cols > right)
	|                        {
	|                            cols = right - col;
	|                        }
	|                        for (int i = 0; i < cols; i++)
	|                        {
	|                            if (col + i < right)
	|                            {
	|                                AddRune(col + i, row, ' ');
	|                            }
	|                        }
	|                    }
	|                    else
	|                    {
	|                        AddRune(col, row, rune);
	|                    }
	|                    if (!TextModel.SetCol(ref col, bounds.Right, cols))
	|                    {
	|                        break;
	|                    }
	|                    if (idxCol + 1 < lineRuneCount && col + Rune.ColumnWidth(line[idxCol + 1]) > right)
	|                    {
	|                        break;
	|                    }
	|                }
	|                if (col < right)
	|                {
	|                    SetNormalColor();
	|                    ClearRegion(col, row, right, row + 1);
	|                }
	|                row++;
	|            }
	|            if (row < bottom)
	|            {
	|                SetNormalColor();
	|                ClearRegion(bounds.Left, row, right, bottom);
	|            }
	|
	|            PositionCursor();
	|
	|            if (clickWithSelecting)
	|            {
	|                clickWithSelecting = false;
	|                return;
	|            }
	|            if (SelectedLength > 0)
	|                return;
	|
	|            // draw autocomplete
	|            Autocomplete.GenerateSuggestions();
	|
	|            var renderAt = new Point(
	|                CursorPosition.X - LeftColumn,
	|                Autocomplete.PopupInsideContainer
	|                    ? (CursorPosition.Y + 1) - TopRow
	|                    : 0);
	|
	|            Autocomplete.RenderOverlay(renderAt);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override Attribute GetNormalColor()
	|        {
	|            return Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool CanFocus
	|        {
	|            get => base.CanFocus;
	|            set { base.CanFocus = value; }
	|        }
	|
	|        void SetClipboard(ustring text)
	|        {
	|            if (text != null)
	|            {
	|                Clipboard.Contents = text;
	|            }
	|        }
	|
	|        void AppendClipboard(ustring text)
	|        {
	|            Clipboard.Contents += text;
	|        }
	|
	|
	|        /// <summary>
	|        /// Inserts the given <paramref name=""toAdd""/> text at the current cursor position
	|        /// exactly as if the user had just typed it
	|        /// </summary>
	|        /// <param name=""toAdd"">Text to add</param>
	|        public void InsertText(string toAdd)
	|        {
	|            foreach (var ch in toAdd)
	|            {
	|
	|                Key key;
	|
	|                try
	|                {
	|                    key = (Key)ch;
	|                }
	|                catch (Exception)
	|                {
	|
	|                    throw new ArgumentException($""Cannot insert character '{ch}' because it does not map to a Key"");
	|                }
	|
	|
	|                InsertText(new KeyEvent() { Key = key });
	|            }
	|
	|            if (NeedDisplay.IsEmpty)
	|            {
	|                PositionCursor();
	|            }
	|            else
	|            {
	|                Adjust();
	|            }
	|        }
	|
	|        void Insert(Rune rune)
	|        {
	|            var line = GetCurrentLine();
	|            if (Used)
	|            {
	|                line.Insert(Math.Min(currentColumn, line.Count), rune);
	|            }
	|            else
	|            {
	|                if (currentColumn < line.Count)
	|                {
	|                    line.RemoveAt(currentColumn);
	|                }
	|                line.Insert(Math.Min(currentColumn, line.Count), rune);
	|            }
	|            var prow = currentRow - topRow;
	|            if (!wrapNeeded)
	|            {
	|                SetNeedsDisplay(new Rect(0, prow, Math.Max(Frame.Width, 0), Math.Max(prow + 1, 0)));
	|            }
	|        }
	|
	|        ustring StringFromRunes(List<Rune> runes)
	|        {
	|            if (runes == null)
	|                throw new ArgumentNullException(nameof(runes));
	|            int size = 0;
	|            foreach (var rune in runes)
	|            {
	|                size += Utf8.RuneLen(rune);
	|            }
	|            var encoded = new byte[size];
	|            int offset = 0;
	|            foreach (var rune in runes)
	|            {
	|                offset += Utf8.EncodeRune(rune, encoded, offset);
	|            }
	|            return ustring.Make(encoded);
	|        }
	|
	|        /// <summary>
	|        /// Returns the characters on the current line (where the cursor is positioned).
	|        /// Use <see cref=""CurrentColumn""/> to determine the position of the cursor within
	|        /// that line
	|        /// </summary>
	|        /// <returns></returns>
	|        public List<Rune> GetCurrentLine() => model.GetLine(currentRow);
	|
	|        void InsertText(ustring text)
	|        {
	|            if (ustring.IsNullOrEmpty(text))
	|            {
	|                return;
	|            }
	|
	|            var lines = TextModel.StringToRunes(text);
	|
	|            if (lines.Count == 0)
	|            {
	|                return;
	|            }
	|
	|            SetWrapModel();
	|
	|            var line = GetCurrentLine();
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, CursorPosition);
	|
	|            // Optimize single line
	|            if (lines.Count == 1)
	|            {
	|                line.InsertRange(currentColumn, lines[0]);
	|                currentColumn += lines[0].Count;
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                if (!wordWrap && currentColumn - leftColumn > Frame.Width)
	|                {
	|                    leftColumn = Math.Max(currentColumn - Frame.Width + 1, 0);
	|                }
	|                if (wordWrap)
	|                {
	|                    SetNeedsDisplay();
	|                }
	|                else
	|                {
	|                    SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Math.Max(currentRow - topRow + 1, 0)));
	|                }
	|
	|                UpdateWrapModel();
	|
	|                OnContentsChanged();
	|
	|                return;
	|            }
	|
	|            List<Rune> rest = null;
	|            int lastp = 0;
	|
	|            if (model.Count > 0 && line.Count > 0 && !copyWithoutSelection)
	|            {
	|                // Keep a copy of the rest of the line
	|                var restCount = line.Count - currentColumn;
	|                rest = line.GetRange(currentColumn, restCount);
	|                line.RemoveRange(currentColumn, restCount);
	|            }
	|
	|            // First line is inserted at the current location, the rest is appended
	|            line.InsertRange(currentColumn, lines[0]);
	|            //model.AddLine (currentRow, lines [0]);
	|
	|            var addedLines = new List<List<Rune>>() { new List<Rune>(line) };
	|
	|            for (int i = 1; i < lines.Count; i++)
	|            {
	|                model.AddLine(currentRow + i, lines[i]);
	|
	|                addedLines.Add(new List<Rune>(lines[i]));
	|            }
	|
	|            if (rest != null)
	|            {
	|                var last = model.GetLine(currentRow + lines.Count - 1);
	|                lastp = last.Count;
	|                last.InsertRange(last.Count, rest);
	|
	|                addedLines.Last().InsertRange(addedLines.Last().Count, rest);
	|            }
	|
	|            historyText.Add(addedLines, CursorPosition, HistoryText.LineStatus.Added);
	|
	|            // Now adjust column and row positions
	|            currentRow += lines.Count - 1;
	|            currentColumn = rest != null ? lastp : lines[lines.Count - 1].Count;
	|            Adjust();
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, CursorPosition,
	|                HistoryText.LineStatus.Replaced);
	|
	|            UpdateWrapModel();
	|            OnContentsChanged();
	|        }
	|
	|        // The column we are tracking, or -1 if we are not tracking any column
	|        int columnTrack = -1;
	|
	|        // Tries to snap the cursor to the tracking column
	|        void TrackColumn()
	|        {
	|            // Now track the column
	|            var line = GetCurrentLine();
	|            if (line.Count < columnTrack)
	|                currentColumn = line.Count;
	|            else if (columnTrack != -1)
	|                currentColumn = columnTrack;
	|            else if (currentColumn > line.Count)
	|                currentColumn = line.Count;
	|            Adjust();
	|        }
	|
	|        void Adjust()
	|        {
	|            var offB = OffSetBackground();
	|            var line = GetCurrentLine();
	|            bool need = !NeedDisplay.IsEmpty || wrapNeeded;
	|            var tSize = TextModel.DisplaySize(line, -1, -1, false, TabWidth);
	|            var dSize = TextModel.DisplaySize(line, leftColumn, currentColumn, true, TabWidth);
	|            if (!wordWrap && currentColumn < leftColumn)
	|            {
	|                leftColumn = currentColumn;
	|                need = true;
	|            }
	|            else if (!wordWrap && (currentColumn - leftColumn + RightOffset > Frame.Width + offB.width
	|              || dSize.size + RightOffset >= Frame.Width + offB.width))
	|            {
	|                leftColumn = TextModel.CalculateLeftColumn(line, leftColumn, currentColumn,
	|                    Frame.Width + offB.width - RightOffset, TabWidth);
	|                need = true;
	|            }
	|            else if ((wordWrap && leftColumn > 0) || (dSize.size + RightOffset < Frame.Width + offB.width
	|              && tSize.size + RightOffset < Frame.Width + offB.width))
	|            {
	|                if (leftColumn > 0)
	|                {
	|                    leftColumn = 0;
	|                    need = true;
	|                }
	|            }
	|
	|            if (currentRow < topRow)
	|            {
	|                topRow = currentRow;
	|                need = true;
	|            }
	|            else if (currentRow - topRow + BottomOffset >= Frame.Height + offB.height)
	|            {
	|                topRow = Math.Min(Math.Max(currentRow - Frame.Height + 1 + BottomOffset, 0), currentRow);
	|                need = true;
	|            }
	|            else if (topRow > 0 && currentRow < topRow)
	|            {
	|                topRow = Math.Max(topRow - 1, 0);
	|                need = true;
	|            }
	|            if (need)
	|            {
	|                if (wrapNeeded)
	|                {
	|                    WrapTextModel();
	|                    wrapNeeded = false;
	|                }
	|                SetNeedsDisplay();
	|            }
	|            else
	|            {
	|                PositionCursor();
	|            }
	|
	|            OnUnwrappedCursorPosition();
	|        }
	|
	|        int AdjustOffset(int valueOffset, bool isRow = true)
	|        {
	|            var curWrap = isRow ? false : wordWrap;
	|            var curLength = isRow ? Lines - 1 : GetCurrentLine().Count;
	|            var curStart = isRow ? topRow : leftColumn;
	|            var curOffset = isRow ? bottomOffset : rightOffset;
	|            var curSize = isRow ? Frame.Height - valueOffset : Frame.Width - valueOffset;
	|            var newStart = curStart;
	|
	|            if (!curWrap)
	|            {
	|                if (curStart > 0 && curOffset > 0 && valueOffset == 0)
	|                {
	|                    newStart = Math.Max(curStart - curOffset, 0);
	|                }
	|                else if (curStart > 0 && curOffset == 0 && valueOffset > 0)
	|                {
	|                    newStart = Math.Max(Math.Min(curStart + valueOffset, curLength - curSize + 1), 0);
	|                }
	|
	|                if (newStart != curStart)
	|                {
	|                    Application.MainLoop.Invoke(() => SetNeedsDisplay());
	|                }
	|            }
	|
	|            return newStart;
	|        }
	|
	|        /// <summary>
	|        /// Event arguments for events for when the contents of the TextView change. E.g. the <see cref=""ContentsChanged""/> event.
	|        /// </summary>
	|        public class ContentsChangedEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// Creates a new <see cref=""ContentsChanged""/> instance.
	|            /// </summary>
	|            /// <param name=""currentRow"">Contains the row where the change occurred.</param>
	|            /// <param name=""currentColumn"">Contains the column where the change occured.</param>
	|            public ContentsChangedEventArgs(int currentRow, int currentColumn)
	|            {
	|                Row = currentRow;
	|                Col = currentColumn;
	|            }
	|
	|            /// <summary>
	|            /// 
	|            /// Contains the row where the change occurred.
	|            /// </summary>
	|            public int Row { get; private set; }
	|
	|            /// <summary>
	|            /// Contains the column where the change occurred.
	|            /// </summary>
	|            public int Col { get; private set; }
	|        }
	|
	|        /// <summary>
	|        /// Called when the contents of the TextView change. E.g. when the user types text or deletes text. Raises
	|        /// the <see cref=""ContentsChanged""/> event.
	|        /// </summary>
	|        public virtual void OnContentsChanged()
	|        {
	|            ContentsChanged?.Invoke(new ContentsChangedEventArgs(CurrentRow, CurrentColumn));
	|        }
	|
	|        (int width, int height) OffSetBackground()
	|        {
	|            int w = 0;
	|            int h = 0;
	|            if (SuperView?.Frame.Right - Frame.Right < 0)
	|            {
	|                w = SuperView.Frame.Right - Frame.Right - 1;
	|            }
	|            if (SuperView?.Frame.Bottom - Frame.Bottom < 0)
	|            {
	|                h = SuperView.Frame.Bottom - Frame.Bottom - 1;
	|            }
	|            return (w, h);
	|        }
	|
	|        /// <summary>
	|        /// Will scroll the <see cref=""TextView""/> to display the specified row at the top if <paramref name=""isRow""/> is true or
	|        /// will scroll the <see cref=""TextView""/> to display the specified column at the left if <paramref name=""isRow""/> is false.
	|        /// </summary>
	|        /// <param name=""idx"">Row that should be displayed at the top or Column that should be displayed at the left,
	|        /// if the value is negative it will be reset to zero</param>
	|        /// <param name=""isRow"">If true (default) the <paramref name=""idx""/> is a row, column otherwise.</param>
	|        public void ScrollTo(int idx, bool isRow = true)
	|        {
	|            if (idx < 0)
	|            {
	|                idx = 0;
	|            }
	|            if (isRow)
	|            {
	|                topRow = Math.Max(idx > model.Count - 1 ? model.Count - 1 : idx, 0);
	|            }
	|            else if (!wordWrap)
	|            {
	|                var maxlength = model.GetMaxVisibleLine(topRow, topRow + Frame.Height + RightOffset, TabWidth);
	|                leftColumn = Math.Max(!wordWrap && idx > maxlength - 1 ? maxlength - 1 : idx, 0);
	|            }
	|            SetNeedsDisplay();
	|        }
	|
	|        bool lastWasKill;
	|        bool wrapNeeded;
	|        bool shiftSelecting;
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            if (!CanFocus)
	|            {
	|                return true;
	|            }
	|
	|            // Give autocomplete first opportunity to respond to key presses
	|            if (SelectedLength == 0 && Autocomplete.ProcessKey(kb))
	|            {
	|                return true;
	|            }
	|
	|            var result = InvokeKeybindings(new KeyEvent(ShortcutHelper.GetModifiersKey(kb),
	|                new KeyModifiers() { Alt = kb.IsAlt, Ctrl = kb.IsCtrl, Shift = kb.IsShift }));
	|            if (result != null)
	|                return (bool)result;
	|
	|            ResetColumnTrack();
	|            // Ignore control characters and other special keys
	|            if (kb.Key < Key.Space || kb.Key > Key.CharMask)
	|                return false;
	|
	|            InsertText(kb);
	|            DoNeededAction();
	|
	|            return true;
	|        }
	|
	|        void RedoChanges()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            historyText.Redo();
	|        }
	|
	|        void UndoChanges()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            historyText.Undo();
	|        }
	|
	|        bool ProcessMovePreviousView()
	|        {
	|            ResetColumnTrack();
	|            return MovePreviousView();
	|        }
	|
	|        bool ProcessMoveNextView()
	|        {
	|            ResetColumnTrack();
	|            return MoveNextView();
	|        }
	|
	|        void ProcessSetOverwrite()
	|        {
	|            ResetColumnTrack();
	|            SetOverwrite(!Used);
	|        }
	|
	|        void ProcessSelectAll()
	|        {
	|            ResetColumnTrack();
	|            SelectAll();
	|        }
	|
	|        void MoveTopHomeExtend()
	|        {
	|            ResetColumnTrack();
	|            StartSelecting();
	|            MoveHome();
	|        }
	|
	|        void MoveTopHome()
	|        {
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveHome();
	|        }
	|
	|        void MoveBottomEndExtend()
	|        {
	|            ResetAllTrack();
	|            StartSelecting();
	|            MoveEnd();
	|        }
	|
	|        void MoveBottomEnd()
	|        {
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveEnd();
	|        }
	|
	|        void ProcessKillWordBackward()
	|        {
	|            ResetColumnTrack();
	|            KillWordBackward();
	|        }
	|
	|        void ProcessKillWordForward()
	|        {
	|            ResetColumnTrack();
	|            KillWordForward();
	|        }
	|
	|        void ProcessMoveWordForwardExtend()
	|        {
	|            ResetAllTrack();
	|            StartSelecting();
	|            MoveWordForward();
	|        }
	|
	|        void ProcessMoveWordForward()
	|        {
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveWordForward();
	|        }
	|
	|        void ProcessMoveWordBackwardExtend()
	|        {
	|            ResetAllTrack();
	|            StartSelecting();
	|            MoveWordBackward();
	|        }
	|
	|        void ProcessMoveWordBackward()
	|        {
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveWordBackward();
	|        }
	|
	|        void ProcessCut()
	|        {
	|            ResetColumnTrack();
	|            Cut();
	|        }
	|
	|        void ProcessCopy()
	|        {
	|            ResetColumnTrack();
	|            Copy();
	|        }
	|
	|        void ToggleSelecting()
	|        {
	|            ResetColumnTrack();
	|            selecting = !selecting;
	|            selectionStartColumn = currentColumn;
	|            selectionStartRow = currentRow;
	|        }
	|
	|        void ProcessPaste()
	|        {
	|            ResetColumnTrack();
	|            if (isReadOnly)
	|                return;
	|            Paste();
	|        }
	|
	|        void ProcessMoveEndOfLineExtend()
	|        {
	|            ResetAllTrack();
	|            StartSelecting();
	|            MoveEndOfLine();
	|        }
	|
	|        void ProcessMoveEndOfLine()
	|        {
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveEndOfLine();
	|        }
	|
	|        void ProcessDeleteCharRight()
	|        {
	|            ResetColumnTrack();
	|            DeleteCharRight();
	|        }
	|
	|        void ProcessMoveStartOfLineExtend()
	|        {
	|            ResetAllTrack();
	|            StartSelecting();
	|            MoveStartOfLine();
	|        }
	|
	|        void ProcessMoveStartOfLine()
	|        {
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveStartOfLine();
	|        }
	|
	|        void ProcessDeleteCharLeft()
	|        {
	|            ResetColumnTrack();
	|            DeleteCharLeft();
	|        }
	|
	|        void ProcessMoveLeftExtend()
	|        {
	|            ResetAllTrack();
	|            StartSelecting();
	|            MoveLeft();
	|        }
	|
	|        bool ProcessMoveLeft()
	|        {
	|            // if the user presses Left (without any control keys) and they are at the start of the text
	|            if (currentColumn == 0 && currentRow == 0)
	|            {
	|                // do not respond (this lets the key press fall through to navigation system - which usually changes focus backward)
	|                return false;
	|            }
	|
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveLeft();
	|            return true;
	|        }
	|
	|        void ProcessMoveRightExtend()
	|        {
	|            ResetAllTrack();
	|            StartSelecting();
	|            MoveRight();
	|        }
	|
	|        bool ProcessMoveRight()
	|        {
	|            // if the user presses Right (without any control keys)
	|            // determine where the last cursor position in the text is
	|            var lastRow = model.Count - 1;
	|            var lastCol = model.GetLine(lastRow).Count;
	|
	|            // if they are at the very end of all the text do not respond (this lets the key press fall through to navigation system - which usually changes focus forward)
	|            if (currentColumn == lastCol && currentRow == lastRow)
	|            {
	|                return false;
	|            }
	|
	|            ResetAllTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveRight();
	|            return true;
	|        }
	|
	|        void ProcessMoveUpExtend()
	|        {
	|            ResetColumnTrack();
	|            StartSelecting();
	|            MoveUp();
	|        }
	|
	|        void ProcessMoveUp()
	|        {
	|            ResetContinuousFindTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveUp();
	|        }
	|
	|        void ProcessMoveDownExtend()
	|        {
	|            ResetColumnTrack();
	|            StartSelecting();
	|            MoveDown();
	|        }
	|
	|        void ProcessMoveDown()
	|        {
	|            ResetContinuousFindTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MoveDown();
	|        }
	|
	|        void ProcessPageUpExtend()
	|        {
	|            ResetColumnTrack();
	|            StartSelecting();
	|            MovePageUp();
	|        }
	|
	|        void ProcessPageUp()
	|        {
	|            ResetColumnTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MovePageUp();
	|        }
	|
	|        void ProcessPageDownExtend()
	|        {
	|            ResetColumnTrack();
	|            StartSelecting();
	|            MovePageDown();
	|        }
	|
	|        void ProcessPageDown()
	|        {
	|            ResetColumnTrack();
	|            if (shiftSelecting && selecting)
	|            {
	|                StopSelecting();
	|            }
	|            MovePageDown();
	|        }
	|
	|        bool MovePreviousView()
	|        {
	|            if (Application.MdiTop != null)
	|            {
	|                return SuperView?.FocusPrev() == true;
	|            }
	|
	|            return false;
	|        }
	|
	|        bool MoveNextView()
	|        {
	|            if (Application.MdiTop != null)
	|            {
	|                return SuperView?.FocusNext() == true;
	|            }
	|
	|            return false;
	|        }
	|
	|        bool ProcessBackTab()
	|        {
	|            ResetColumnTrack();
	|
	|            if (!AllowsTab || isReadOnly)
	|            {
	|                return ProcessMovePreviousView();
	|            }
	|            if (currentColumn > 0)
	|            {
	|                SetWrapModel();
	|
	|                var currentLine = GetCurrentLine();
	|                if (currentLine.Count > 0 && currentLine[currentColumn - 1] == '\t')
	|                {
	|
	|                    historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|                    currentLine.RemoveAt(currentColumn - 1);
	|                    currentColumn--;
	|
	|                    historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                        HistoryText.LineStatus.Replaced);
	|                }
	|
	|                UpdateWrapModel();
	|            }
	|            DoNeededAction();
	|            return true;
	|        }
	|
	|        bool ProcessTab()
	|        {
	|            ResetColumnTrack();
	|
	|            if (!AllowsTab || isReadOnly)
	|            {
	|                return ProcessMoveNextView();
	|            }
	|            InsertText(new KeyEvent((Key)'\t', null));
	|            DoNeededAction();
	|            return true;
	|        }
	|
	|        void SetOverwrite(bool overwrite)
	|        {
	|            Used = overwrite;
	|            SetNeedsDisplay();
	|            DoNeededAction();
	|        }
	|
	|        bool ProcessReturn()
	|        {
	|            ResetColumnTrack();
	|
	|            if (!AllowsReturn || isReadOnly)
	|            {
	|                return false;
	|            }
	|
	|            SetWrapModel();
	|
	|            var currentLine = GetCurrentLine();
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|            if (selecting)
	|            {
	|                ClearSelectedRegion();
	|                currentLine = GetCurrentLine();
	|            }
	|            var restCount = currentLine.Count - currentColumn;
	|            var rest = currentLine.GetRange(currentColumn, restCount);
	|            currentLine.RemoveRange(currentColumn, restCount);
	|
	|            var addedLines = new List<List<Rune>>() { new List<Rune>(currentLine) };
	|
	|            model.AddLine(currentRow + 1, rest);
	|
	|            addedLines.Add(new List<Rune>(model.GetLine(currentRow + 1)));
	|
	|            historyText.Add(addedLines, CursorPosition, HistoryText.LineStatus.Added);
	|
	|            currentRow++;
	|
	|            bool fullNeedsDisplay = false;
	|            if (currentRow >= topRow + Frame.Height)
	|            {
	|                topRow++;
	|                fullNeedsDisplay = true;
	|            }
	|            currentColumn = 0;
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                HistoryText.LineStatus.Replaced);
	|
	|            if (!wordWrap && currentColumn < leftColumn)
	|            {
	|                fullNeedsDisplay = true;
	|                leftColumn = 0;
	|            }
	|
	|            if (fullNeedsDisplay)
	|                SetNeedsDisplay();
	|            else
	|                SetNeedsDisplay(new Rect(0, currentRow - topRow, 2, Frame.Height));
	|
	|            UpdateWrapModel();
	|
	|            DoNeededAction();
	|            OnContentsChanged();
	|            return true;
	|        }
	|
	|        void KillWordBackward()
	|        {
	|            if (isReadOnly)
	|                return;
	|
	|            SetWrapModel();
	|
	|            var currentLine = GetCurrentLine();
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition);
	|
	|            if (currentColumn == 0)
	|            {
	|                DeleteTextBackwards();
	|
	|                historyText.ReplaceLast(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                UpdateWrapModel();
	|
	|                return;
	|            }
	|            var newPos = WordBackward(currentColumn, currentRow);
	|            if (newPos.HasValue && currentRow == newPos.Value.row)
	|            {
	|                var restCount = currentColumn - newPos.Value.col;
	|                currentLine.RemoveRange(newPos.Value.col, restCount);
	|                if (wordWrap)
	|                {
	|                    wrapNeeded = true;
	|                }
	|                currentColumn = newPos.Value.col;
	|            }
	|            else if (newPos.HasValue)
	|            {
	|                var restCount = currentLine.Count - currentColumn;
	|                currentLine.RemoveRange(currentColumn, restCount);
	|                if (wordWrap)
	|                {
	|                    wrapNeeded = true;
	|                }
	|                currentColumn = newPos.Value.col;
	|                currentRow = newPos.Value.row;
	|            }
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                HistoryText.LineStatus.Replaced);
	|
	|            UpdateWrapModel();
	|
	|            if (wrapNeeded)
	|            {
	|                SetNeedsDisplay();
	|            }
	|            else
	|            {
	|                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
	|            }
	|            DoNeededAction();
	|        }
	|
	|        void KillWordForward()
	|        {
	|            if (isReadOnly)
	|                return;
	|
	|            SetWrapModel();
	|
	|            var currentLine = GetCurrentLine();
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition);
	|
	|            if (currentLine.Count == 0 || currentColumn == currentLine.Count)
	|            {
	|                DeleteTextForwards();
	|
	|                historyText.ReplaceLast(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                UpdateWrapModel();
	|
	|                return;
	|            }
	|            var newPos = WordForward(currentColumn, currentRow);
	|            var restCount = 0;
	|            if (newPos.HasValue && currentRow == newPos.Value.row)
	|            {
	|                restCount = newPos.Value.col - currentColumn;
	|                currentLine.RemoveRange(currentColumn, restCount);
	|            }
	|            else if (newPos.HasValue)
	|            {
	|                restCount = currentLine.Count - currentColumn;
	|                currentLine.RemoveRange(currentColumn, restCount);
	|            }
	|            if (wordWrap)
	|            {
	|                wrapNeeded = true;
	|            }
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                HistoryText.LineStatus.Replaced);
	|
	|            UpdateWrapModel();
	|
	|            if (wrapNeeded)
	|            {
	|                SetNeedsDisplay();
	|            }
	|            else
	|            {
	|                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
	|            }
	|            DoNeededAction();
	|        }
	|
	|        void MoveWordForward()
	|        {
	|            var newPos = WordForward(currentColumn, currentRow);
	|            if (newPos.HasValue)
	|            {
	|                currentColumn = newPos.Value.col;
	|                currentRow = newPos.Value.row;
	|            }
	|            Adjust();
	|            DoNeededAction();
	|        }
	|
	|        void MoveWordBackward()
	|        {
	|            var newPos = WordBackward(currentColumn, currentRow);
	|            if (newPos.HasValue)
	|            {
	|                currentColumn = newPos.Value.col;
	|                currentRow = newPos.Value.row;
	|            }
	|            Adjust();
	|            DoNeededAction();
	|        }
	|
	|        void KillToStartOfLine()
	|        {
	|            if (isReadOnly)
	|                return;
	|            if (model.Count == 1 && GetCurrentLine().Count == 0)
	|            {
	|                // Prevents from adding line feeds if there is no more lines.
	|                return;
	|            }
	|
	|            SetWrapModel();
	|
	|            var currentLine = GetCurrentLine();
	|            var setLastWasKill = true;
	|            if (currentLine.Count > 0 && currentColumn == 0)
	|            {
	|                UpdateWrapModel();
	|
	|                DeleteTextBackwards();
	|                return;
	|            }
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|            if (currentLine.Count == 0)
	|            {
	|                if (currentRow > 0)
	|                {
	|                    model.RemoveLine(currentRow);
	|
	|                    if (model.Count > 0 || lastWasKill)
	|                    {
	|                        var val = ustring.Make(Environment.NewLine);
	|                        if (lastWasKill)
	|                        {
	|                            AppendClipboard(val);
	|                        }
	|                        else
	|                        {
	|                            SetClipboard(val);
	|                        }
	|                    }
	|                    if (model.Count == 0)
	|                    {
	|                        // Prevents from adding line feeds if there is no more lines.
	|                        setLastWasKill = false;
	|                    }
	|
	|                    currentRow--;
	|                    currentLine = model.GetLine(currentRow);
	|
	|                    var removedLine = new List<List<Rune>>() { new List<Rune>(currentLine) };
	|
	|                    removedLine.Add(new List<Rune>());
	|
	|                    historyText.Add(new List<List<Rune>>(removedLine), CursorPosition, HistoryText.LineStatus.Removed);
	|
	|                    currentColumn = currentLine.Count;
	|                }
	|            }
	|            else
	|            {
	|                var restCount = currentColumn;
	|                var rest = currentLine.GetRange(0, restCount);
	|                var val = ustring.Empty;
	|                val += StringFromRunes(rest);
	|                if (lastWasKill)
	|                {
	|                    AppendClipboard(val);
	|                }
	|                else
	|                {
	|                    SetClipboard(val);
	|                }
	|                currentLine.RemoveRange(0, restCount);
	|                currentColumn = 0;
	|            }
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                HistoryText.LineStatus.Replaced);
	|
	|            UpdateWrapModel();
	|
	|            if (wrapNeeded)
	|                SetNeedsDisplay();
	|            else
	|                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
	|            lastWasKill = setLastWasKill;
	|            DoNeededAction();
	|        }
	|
	|        void KillToEndOfLine()
	|        {
	|            if (isReadOnly)
	|                return;
	|            if (model.Count == 1 && GetCurrentLine().Count == 0)
	|            {
	|                // Prevents from adding line feeds if there is no more lines.
	|                return;
	|            }
	|
	|            SetWrapModel();
	|
	|            var currentLine = GetCurrentLine();
	|            var setLastWasKill = true;
	|            if (currentLine.Count > 0 && currentColumn == currentLine.Count)
	|            {
	|                UpdateWrapModel();
	|
	|                DeleteTextForwards();
	|                return;
	|            }
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|            if (currentLine.Count == 0)
	|            {
	|                if (currentRow < model.Count - 1)
	|                {
	|                    var removedLines = new List<List<Rune>>() { new List<Rune>(currentLine) };
	|
	|                    model.RemoveLine(currentRow);
	|
	|                    removedLines.Add(new List<Rune>(GetCurrentLine()));
	|
	|                    historyText.Add(new List<List<Rune>>(removedLines), CursorPosition,
	|                        HistoryText.LineStatus.Removed);
	|                }
	|                if (model.Count > 0 || lastWasKill)
	|                {
	|                    var val = ustring.Make(Environment.NewLine);
	|                    if (lastWasKill)
	|                    {
	|                        AppendClipboard(val);
	|                    }
	|                    else
	|                    {
	|                        SetClipboard(val);
	|                    }
	|                }
	|                if (model.Count == 0)
	|                {
	|                    // Prevents from adding line feeds if there is no more lines.
	|                    setLastWasKill = false;
	|                }
	|            }
	|            else
	|            {
	|                var restCount = currentLine.Count - currentColumn;
	|                var rest = currentLine.GetRange(currentColumn, restCount);
	|                var val = ustring.Empty;
	|                val += StringFromRunes(rest);
	|                if (lastWasKill)
	|                {
	|                    AppendClipboard(val);
	|                }
	|                else
	|                {
	|                    SetClipboard(val);
	|                }
	|                currentLine.RemoveRange(currentColumn, restCount);
	|            }
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                HistoryText.LineStatus.Replaced);
	|
	|            UpdateWrapModel();
	|
	|            if (wrapNeeded)
	|                SetNeedsDisplay();
	|            else
	|                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
	|            lastWasKill = setLastWasKill;
	|            DoNeededAction();
	|        }
	|
	|        void MoveEndOfLine()
	|        {
	|            var currentLine = GetCurrentLine();
	|            currentColumn = currentLine.Count;
	|            Adjust();
	|            DoNeededAction();
	|        }
	|
	|        void MoveStartOfLine()
	|        {
	|            currentColumn = 0;
	|            leftColumn = 0;
	|            Adjust();
	|            DoNeededAction();
	|        }
	|
	|        /// <summary>
	|        /// Deletes all the selected or a single character at right from the position of the cursor.
	|        /// </summary>
	|        public void DeleteCharRight()
	|        {
	|            if (isReadOnly)
	|                return;
	|
	|            SetWrapModel();
	|
	|            if (selecting)
	|            {
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                    HistoryText.LineStatus.Original);
	|
	|                ClearSelectedRegion();
	|
	|                var currentLine = GetCurrentLine();
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                UpdateWrapModel();
	|
	|                return;
	|            }
	|            if (DeleteTextForwards())
	|            {
	|                UpdateWrapModel();
	|                OnContentsChanged();
	|
	|                return;
	|            }
	|
	|            UpdateWrapModel();
	|
	|            DoNeededAction();
	|            OnContentsChanged();
	|        }
	|
	|        /// <summary>
	|        /// Deletes all the selected or a single character at left from the position of the cursor.
	|        /// </summary>
	|        public void DeleteCharLeft()
	|        {
	|            if (isReadOnly)
	|                return;
	|
	|            SetWrapModel();
	|
	|            if (selecting)
	|            {
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                    HistoryText.LineStatus.Original);
	|
	|                ClearSelectedRegion();
	|
	|                var currentLine = GetCurrentLine();
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                UpdateWrapModel();
	|                OnContentsChanged();
	|
	|                return;
	|            }
	|            if (DeleteTextBackwards())
	|            {
	|                UpdateWrapModel();
	|                OnContentsChanged();
	|
	|                return;
	|            }
	|
	|            UpdateWrapModel();
	|
	|            DoNeededAction();
	|            OnContentsChanged();
	|        }
	|
	|        void MoveLeft()
	|        {
	|            if (currentColumn > 0)
	|            {
	|                currentColumn--;
	|            }
	|            else
	|            {
	|                if (currentRow > 0)
	|                {
	|                    currentRow--;
	|                    if (currentRow < topRow)
	|                    {
	|                        topRow--;
	|                        SetNeedsDisplay();
	|                    }
	|                    var currentLine = GetCurrentLine();
	|                    currentColumn = currentLine.Count;
	|                }
	|            }
	|            Adjust();
	|            DoNeededAction();
	|        }
	|
	|        void MoveRight()
	|        {
	|            var currentLine = GetCurrentLine();
	|            if (currentColumn < currentLine.Count)
	|            {
	|                currentColumn++;
	|            }
	|            else
	|            {
	|                if (currentRow + 1 < model.Count)
	|                {
	|                    currentRow++;
	|                    currentColumn = 0;
	|                    if (currentRow >= topRow + Frame.Height)
	|                    {
	|                        topRow++;
	|                        SetNeedsDisplay();
	|                    }
	|                }
	|            }
	|            Adjust();
	|            DoNeededAction();
	|        }
	|
	|        void MovePageUp()
	|        {
	|            int nPageUpShift = Frame.Height - 1;
	|            if (currentRow > 0)
	|            {
	|                if (columnTrack == -1)
	|                    columnTrack = currentColumn;
	|                currentRow = currentRow - nPageUpShift < 0 ? 0 : currentRow - nPageUpShift;
	|                if (currentRow < topRow)
	|                {
	|                    topRow = topRow - nPageUpShift < 0 ? 0 : topRow - nPageUpShift;
	|                    SetNeedsDisplay();
	|                }
	|                TrackColumn();
	|                PositionCursor();
	|            }
	|            DoNeededAction();
	|        }
	|
	|        void MovePageDown()
	|        {
	|            int nPageDnShift = Frame.Height - 1;
	|            if (currentRow >= 0 && currentRow < model.Count)
	|            {
	|                if (columnTrack == -1)
	|                    columnTrack = currentColumn;
	|                currentRow = (currentRow + nPageDnShift) > model.Count
	|                    ? model.Count > 0 ? model.Count - 1 : 0
	|                    : currentRow + nPageDnShift;
	|                if (topRow < currentRow - nPageDnShift)
	|                {
	|                    topRow = currentRow >= model.Count ? currentRow - nPageDnShift : topRow + nPageDnShift;
	|                    SetNeedsDisplay();
	|                }
	|                TrackColumn();
	|                PositionCursor();
	|            }
	|            DoNeededAction();
	|        }
	|
	|        void ResetContinuousFindTrack()
	|        {
	|            // Handle some state here - whether the last command was a kill
	|            // operation and the column tracking (up/down)
	|            lastWasKill = false;
	|            continuousFind = false;
	|        }
	|
	|        void ResetColumnTrack()
	|        {
	|            // Handle some state here - whether the last command was a kill
	|            // operation and the column tracking (up/down)
	|            lastWasKill = false;
	|            columnTrack = -1;
	|        }
	|
	|        void ResetAllTrack()
	|        {
	|            // Handle some state here - whether the last command was a kill
	|            // operation and the column tracking (up/down)
	|            lastWasKill = false;
	|            columnTrack = -1;
	|            continuousFind = false;
	|        }
	|
	|        bool InsertText(KeyEvent kb)
	|        {
	|            //So that special keys like tab can be processed
	|            if (isReadOnly)
	|                return true;
	|
	|            SetWrapModel();
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition);
	|
	|            if (selecting)
	|            {
	|                ClearSelectedRegion();
	|            }
	|            if (kb.Key == Key.Enter)
	|            {
	|                model.AddLine(currentRow + 1, new List<Rune>());
	|                currentRow++;
	|                currentColumn = 0;
	|            }
	|            else if ((uint)kb.Key == 13)
	|            {
	|                currentColumn = 0;
	|            }
	|            else
	|            {
	|                if (Used)
	|                {
	|                    Insert((uint)kb.Key);
	|                    currentColumn++;
	|                    if (currentColumn >= leftColumn + Frame.Width)
	|                    {
	|                        leftColumn++;
	|                        SetNeedsDisplay();
	|                    }
	|                }
	|                else
	|                {
	|                    Insert((uint)kb.Key);
	|                    currentColumn++;
	|                }
	|            }
	|
	|            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                HistoryText.LineStatus.Replaced);
	|
	|            UpdateWrapModel();
	|            OnContentsChanged();
	|
	|            return true;
	|        }
	|
	|        void ShowContextMenu()
	|        {
	|            if (currentCulture != Thread.CurrentThread.CurrentUICulture)
	|            {
	|
	|                currentCulture = Thread.CurrentThread.CurrentUICulture;
	|
	|                ContextMenu.MenuItems = BuildContextMenuBarItem();
	|            }
	|            ContextMenu.Show();
	|        }
	|
	|        /// <summary>
	|        /// Deletes all text.
	|        /// </summary>
	|        public void DeleteAll()
	|        {
	|            if (Lines == 0)
	|            {
	|                return;
	|            }
	|
	|            selectionStartColumn = 0;
	|            selectionStartRow = 0;
	|            MoveBottomEndExtend();
	|            DeleteCharLeft();
	|            SetNeedsDisplay();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnKeyUp(KeyEvent kb)
	|        {
	|            switch (kb.Key)
	|            {
	|                case Key.Space | Key.CtrlMask:
	|                    return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        void DoNeededAction()
	|        {
	|            if (NeedDisplay.IsEmpty)
	|            {
	|                PositionCursor();
	|            }
	|            else
	|            {
	|                Adjust();
	|            }
	|        }
	|
	|        bool DeleteTextForwards()
	|        {
	|            SetWrapModel();
	|
	|            var currentLine = GetCurrentLine();
	|            if (currentColumn == currentLine.Count)
	|            {
	|                if (currentRow + 1 == model.Count)
	|                {
	|                    UpdateWrapModel();
	|
	|                    return true;
	|                }
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|                var removedLines = new List<List<Rune>>() { new List<Rune>(currentLine) };
	|
	|                var nextLine = model.GetLine(currentRow + 1);
	|
	|                removedLines.Add(new List<Rune>(nextLine));
	|
	|                historyText.Add(removedLines, CursorPosition, HistoryText.LineStatus.Removed);
	|
	|                currentLine.AddRange(nextLine);
	|                model.RemoveLine(currentRow + 1);
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                if (wordWrap)
	|                {
	|                    wrapNeeded = true;
	|                }
	|                if (wrapNeeded)
	|                {
	|                    SetNeedsDisplay();
	|                }
	|                else
	|                {
	|                    var sr = currentRow - topRow;
	|                    SetNeedsDisplay(new Rect(0, sr, Frame.Width, sr + 1));
	|                }
	|            }
	|            else
	|            {
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|                currentLine.RemoveAt(currentColumn);
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                if (wordWrap)
	|                {
	|                    wrapNeeded = true;
	|                }
	|
	|                if (wrapNeeded)
	|                {
	|                    SetNeedsDisplay();
	|                }
	|                else
	|                {
	|                    var r = currentRow - topRow;
	|                    SetNeedsDisplay(new Rect(currentColumn - leftColumn, r, Frame.Width, r + 1));
	|                }
	|            }
	|
	|            UpdateWrapModel();
	|
	|            return false;
	|        }
	|
	|        bool DeleteTextBackwards()
	|        {
	|            SetWrapModel();
	|
	|            if (currentColumn > 0)
	|            {
	|                // Delete backwards 
	|                var currentLine = GetCurrentLine();
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|                currentLine.RemoveAt(currentColumn - 1);
	|                if (wordWrap)
	|                {
	|                    wrapNeeded = true;
	|                }
	|                currentColumn--;
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                if (currentColumn < leftColumn)
	|                {
	|                    leftColumn--;
	|                    SetNeedsDisplay();
	|                }
	|                else
	|                    SetNeedsDisplay(new Rect(0, currentRow - topRow, 1, Frame.Width));
	|            }
	|            else
	|            {
	|                // Merges the current line with the previous one.
	|                if (currentRow == 0)
	|                    return true;
	|                var prowIdx = currentRow - 1;
	|                var prevRow = model.GetLine(prowIdx);
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(prevRow) }, CursorPosition);
	|
	|                List<List<Rune>> removedLines = new List<List<Rune>>() { new List<Rune>(prevRow) };
	|
	|                removedLines.Add(new List<Rune>(GetCurrentLine()));
	|
	|                historyText.Add(removedLines, new Point(currentColumn, prowIdx),
	|                    HistoryText.LineStatus.Removed);
	|
	|                var prevCount = prevRow.Count;
	|                model.GetLine(prowIdx).AddRange(GetCurrentLine());
	|                model.RemoveLine(currentRow);
	|                if (wordWrap)
	|                {
	|                    wrapNeeded = true;
	|                }
	|                currentRow--;
	|
	|                historyText.Add(new List<List<Rune>>() { GetCurrentLine() }, new Point(currentColumn, prowIdx),
	|                    HistoryText.LineStatus.Replaced);
	|
	|                currentColumn = prevCount;
	|                SetNeedsDisplay();
	|            }
	|
	|            UpdateWrapModel();
	|
	|            return false;
	|        }
	|
	|        bool copyWithoutSelection;
	|
	|        /// <summary>
	|        /// Copy the selected text to the clipboard contents.
	|        /// </summary>
	|        public void Copy()
	|        {
	|            SetWrapModel();
	|            if (selecting)
	|            {
	|                SetClipboard(GetRegion());
	|                copyWithoutSelection = false;
	|            }
	|            else
	|            {
	|                var currentLine = GetCurrentLine();
	|                SetClipboard(ustring.Make(currentLine));
	|                copyWithoutSelection = true;
	|            }
	|            UpdateWrapModel();
	|            DoNeededAction();
	|        }
	|
	|        /// <summary>
	|        /// Cut the selected text to the clipboard contents.
	|        /// </summary>
	|        public void Cut()
	|        {
	|            SetWrapModel();
	|            SetClipboard(GetRegion());
	|            if (!isReadOnly)
	|            {
	|                ClearRegion();
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|            }
	|            UpdateWrapModel();
	|            selecting = false;
	|            DoNeededAction();
	|            OnContentsChanged();
	|        }
	|
	|        /// <summary>
	|        /// Paste the clipboard contents into the current selected position.
	|        /// </summary>
	|        public void Paste()
	|        {
	|            if (isReadOnly)
	|            {
	|                return;
	|            }
	|
	|            SetWrapModel();
	|            var contents = Clipboard.Contents;
	|            if (copyWithoutSelection && contents.FirstOrDefault(x => x == '\n' || x == '\r') == 0)
	|            {
	|                var runeList = contents == null ? new List<Rune>() : contents.ToRuneList();
	|                var currentLine = GetCurrentLine();
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);
	|
	|                var addedLine = new List<List<Rune>>() { new List<Rune>(currentLine) };
	|
	|                addedLine.Add(runeList);
	|
	|                historyText.Add(new List<List<Rune>>(addedLine), CursorPosition, HistoryText.LineStatus.Added);
	|
	|                model.AddLine(currentRow, runeList);
	|                currentRow++;
	|
	|                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                    HistoryText.LineStatus.Replaced);
	|
	|                SetNeedsDisplay();
	|                OnContentsChanged();
	|            }
	|            else
	|            {
	|                if (selecting)
	|                {
	|                    ClearRegion();
	|                }
	|                copyWithoutSelection = false;
	|                InsertText(contents);
	|
	|                if (selecting)
	|                {
	|                    historyText.ReplaceLast(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
	|                        HistoryText.LineStatus.Original);
	|                }
	|
	|                SetNeedsDisplay();
	|            }
	|            UpdateWrapModel();
	|            selecting = false;
	|            DoNeededAction();
	|        }
	|
	|        void StartSelecting()
	|        {
	|            if (shiftSelecting && selecting)
	|            {
	|                return;
	|            }
	|            shiftSelecting = true;
	|            selecting = true;
	|            selectionStartColumn = currentColumn;
	|            selectionStartRow = currentRow;
	|        }
	|
	|        void StopSelecting()
	|        {
	|            shiftSelecting = false;
	|            selecting = false;
	|            isButtonShift = false;
	|        }
	|
	|        void ClearSelectedRegion()
	|        {
	|            SetWrapModel();
	|            if (!isReadOnly)
	|            {
	|                ClearRegion();
	|            }
	|            UpdateWrapModel();
	|            selecting = false;
	|            DoNeededAction();
	|        }
	|
	|        void MoveUp()
	|        {
	|            if (currentRow > 0)
	|            {
	|                if (columnTrack == -1)
	|                {
	|                    columnTrack = currentColumn;
	|                }
	|                currentRow--;
	|                if (currentRow < topRow)
	|                {
	|                    topRow--;
	|                    SetNeedsDisplay();
	|                }
	|                TrackColumn();
	|                PositionCursor();
	|            }
	|            DoNeededAction();
	|        }
	|
	|        void MoveDown()
	|        {
	|            if (currentRow + 1 < model.Count)
	|            {
	|                if (columnTrack == -1)
	|                {
	|                    columnTrack = currentColumn;
	|                }
	|                currentRow++;
	|                if (currentRow + BottomOffset >= topRow + Frame.Height)
	|                {
	|                    topRow++;
	|                    SetNeedsDisplay();
	|                }
	|                TrackColumn();
	|                PositionCursor();
	|            }
	|            else if (currentRow > Frame.Height)
	|            {
	|                Adjust();
	|            }
	|            DoNeededAction();
	|        }
	|
	|        IEnumerable<(int col, int row, Rune rune)> ForwardIterator(int col, int row)
	|        {
	|            if (col < 0 || row < 0)
	|                yield break;
	|            if (row >= model.Count)
	|                yield break;
	|            var line = GetCurrentLine();
	|            if (col >= line.Count)
	|                yield break;
	|
	|            while (row < model.Count)
	|            {
	|                for (int c = col; c < line.Count; c++)
	|                {
	|                    yield return (c, row, line[c]);
	|                }
	|                col = 0;
	|                row++;
	|                line = GetCurrentLine();
	|            }
	|        }
	|
	|        Rune RuneAt(int col, int row)
	|        {
	|            var line = model.GetLine(row);
	|            if (line.Count > 0)
	|            {
	|                return line[col > line.Count - 1 ? line.Count - 1 : col];
	|            }
	|            else
	|            {
	|                return 0;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Will scroll the <see cref=""TextView""/> to the last line and position the cursor there.
	|        /// </summary>
	|        public void MoveEnd()
	|        {
	|            currentRow = model.Count - 1;
	|            var line = GetCurrentLine();
	|            currentColumn = line.Count;
	|            TrackColumn();
	|            PositionCursor();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Will scroll the <see cref=""TextView""/> to the first line and position the cursor there.
	|        /// </summary>
	|        public void MoveHome()
	|        {
	|            currentRow = 0;
	|            topRow = 0;
	|            currentColumn = 0;
	|            leftColumn = 0;
	|            TrackColumn();
	|            PositionCursor();
	|            SetNeedsDisplay();
	|        }
	|
	|        bool MoveNext(ref int col, ref int row, out Rune rune)
	|        {
	|            var line = model.GetLine(row);
	|            if (col + 1 < line.Count)
	|            {
	|                col++;
	|                rune = line[col];
	|                if (col + 1 == line.Count && !Rune.IsLetterOrDigit(rune)
	|                    && !Rune.IsWhiteSpace(line[col - 1]))
	|                {
	|                    col++;
	|                }
	|                return true;
	|            }
	|            else if (col + 1 == line.Count)
	|            {
	|                col++;
	|            }
	|            while (row + 1 < model.Count)
	|            {
	|                col = 0;
	|                row++;
	|                line = model.GetLine(row);
	|                if (line.Count > 0)
	|                {
	|                    rune = line[0];
	|                    return true;
	|                }
	|            }
	|            rune = 0;
	|            return false;
	|        }
	|
	|        bool MovePrev(ref int col, ref int row, out Rune rune)
	|        {
	|            var line = model.GetLine(row);
	|
	|            if (col > 0)
	|            {
	|                col--;
	|                rune = line[col];
	|                return true;
	|            }
	|            if (row == 0)
	|            {
	|                rune = 0;
	|                return false;
	|            }
	|            while (row > 0)
	|            {
	|                row--;
	|                line = model.GetLine(row);
	|                col = line.Count - 1;
	|                if (col >= 0)
	|                {
	|                    rune = line[col];
	|                    return true;
	|                }
	|            }
	|            rune = 0;
	|            return false;
	|        }
	|
	|        (int col, int row)? WordForward(int fromCol, int fromRow)
	|        {
	|            var col = fromCol;
	|            var row = fromRow;
	|            try
	|            {
	|                var rune = RuneAt(col, row);
	|
	|                void ProcMoveNext(ref int nCol, ref int nRow, Rune nRune)
	|                {
	|                    if (Rune.IsSymbol(nRune) || Rune.IsWhiteSpace(nRune))
	|                    {
	|                        while (MoveNext(ref nCol, ref nRow, out nRune))
	|                        {
	|                            if (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune))
	|                                return;
	|                        }
	|                        if (nRow != fromRow && (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune)))
	|                        {
	|                            return;
	|                        }
	|                        while (MoveNext(ref nCol, ref nRow, out nRune))
	|                        {
	|                            if (!Rune.IsLetterOrDigit(nRune) && !Rune.IsPunctuation(nRune))
	|                                break;
	|                        }
	|                    }
	|                    else
	|                    {
	|                        if (!MoveNext(ref nCol, ref nRow, out nRune))
	|                        {
	|                            return;
	|                        }
	|
	|                        var line = model.GetLine(fromRow);
	|                        if ((nRow != fromRow && fromCol < line.Count)
	|                            || (nRow == fromRow && nCol == line.Count - 1))
	|                        {
	|                            nCol = line.Count;
	|                            nRow = fromRow;
	|                            return;
	|                        }
	|                        else if (nRow != fromRow && fromCol == line.Count)
	|                        {
	|                            line = model.GetLine(nRow);
	|                            if (Rune.IsLetterOrDigit(line[nCol]) || Rune.IsPunctuation(line[nCol]))
	|                            {
	|                                return;
	|                            }
	|                        }
	|                        ProcMoveNext(ref nCol, ref nRow, nRune);
	|                    }
	|                }
	|
	|                ProcMoveNext(ref col, ref row, rune);
	|
	|                if (fromCol != col || fromRow != row)
	|                    return (col, row);
	|                return null;
	|            }
	|            catch (Exception)
	|            {
	|                return null;
	|            }
	|        }
	|
	|        (int col, int row)? WordBackward(int fromCol, int fromRow)
	|        {
	|            if (fromRow == 0 && fromCol == 0)
	|                return null;
	|
	|            var col = Math.Max(fromCol - 1, 0);
	|            var row = fromRow;
	|            try
	|            {
	|                var rune = RuneAt(col, row);
	|                int lastValidCol = Rune.IsLetterOrDigit(rune) || Rune.IsPunctuation(rune) ? col : -1;
	|
	|                void ProcMovePrev(ref int nCol, ref int nRow, Rune nRune)
	|                {
	|                    if (Rune.IsSymbol(nRune) || Rune.IsWhiteSpace(nRune))
	|                    {
	|                        while (MovePrev(ref nCol, ref nRow, out nRune))
	|                        {
	|                            if (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune))
	|                            {
	|                                lastValidCol = nCol;
	|                                break;
	|                            }
	|                        }
	|                        if (nRow != fromRow && (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune)))
	|                        {
	|                            if (lastValidCol > -1)
	|                            {
	|                                nCol = lastValidCol;
	|                            }
	|                            return;
	|                        }
	|                        while (MovePrev(ref nCol, ref nRow, out nRune))
	|                        {
	|                            if (!Rune.IsLetterOrDigit(nRune) && !Rune.IsPunctuation(nRune))
	|                                break;
	|                            if (nRow != fromRow)
	|                            {
	|                                break;
	|                            }
	|                            lastValidCol = nCol;
	|                        }
	|                        if (lastValidCol > -1)
	|                        {
	|                            nCol = lastValidCol;
	|                            nRow = fromRow;
	|                        }
	|                    }
	|                    else
	|                    {
	|                        if (!MovePrev(ref nCol, ref nRow, out nRune))
	|                        {
	|                            return;
	|                        }
	|
	|                        var line = model.GetLine(nRow);
	|                        if (nCol == 0 && nRow == fromRow && (Rune.IsLetterOrDigit(line[0]) || Rune.IsPunctuation(line[0])))
	|                        {
	|                            return;
	|                        }
	|                        lastValidCol = Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune) ? nCol : lastValidCol;
	|                        if (lastValidCol > -1 && (Rune.IsSymbol(nRune) || Rune.IsWhiteSpace(nRune)))
	|                        {
	|                            nCol = lastValidCol;
	|                            return;
	|                        }
	|                        if (fromRow != nRow)
	|                        {
	|                            nCol = line.Count;
	|                            return;
	|                        }
	|                        ProcMovePrev(ref nCol, ref nRow, nRune);
	|                    }
	|                }
	|
	|                ProcMovePrev(ref col, ref row, rune);
	|
	|                if (fromCol != col || fromRow != row)
	|                    return (col, row);
	|                return null;
	|            }
	|            catch (Exception)
	|            {
	|                return null;
	|            }
	|        }
	|
	|        bool isButtonShift;
	|        bool clickWithSelecting;
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent ev)
	|        {
	|            if (!ev.Flags.HasFlag(MouseFlags.Button1Clicked) && !ev.Flags.HasFlag(MouseFlags.Button1Pressed)
	|                && !ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition)
	|                && !ev.Flags.HasFlag(MouseFlags.Button1Released)
	|                && !ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ButtonShift)
	|                && !ev.Flags.HasFlag(MouseFlags.WheeledDown) && !ev.Flags.HasFlag(MouseFlags.WheeledUp)
	|                && !ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked)
	|                && !ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked | MouseFlags.ButtonShift)
	|                && !ev.Flags.HasFlag(MouseFlags.Button1TripleClicked)
	|                && !ev.Flags.HasFlag(ContextMenu.MouseFlags))
	|            {
	|                return false;
	|            }
	|
	|            if (!CanFocus)
	|            {
	|                return true;
	|            }
	|
	|            if (!HasFocus)
	|            {
	|                SetFocus();
	|            }
	|
	|            continuousFind = false;
	|
	|            // Give autocomplete first opportunity to respond to mouse clicks
	|            if (SelectedLength == 0 && Autocomplete.MouseEvent(ev, true))
	|            {
	|                return true;
	|            }
	|
	|            if (ev.Flags == MouseFlags.Button1Clicked)
	|            {
	|                if (shiftSelecting && !isButtonShift)
	|                {
	|                    StopSelecting();
	|                }
	|                ProcessMouseClick(ev, out _);
	|                PositionCursor();
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|            }
	|            else if (ev.Flags == MouseFlags.WheeledDown)
	|            {
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|                ScrollTo(topRow + 1);
	|            }
	|            else if (ev.Flags == MouseFlags.WheeledUp)
	|            {
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|                ScrollTo(topRow - 1);
	|            }
	|            else if (ev.Flags == MouseFlags.WheeledRight)
	|            {
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|                ScrollTo(leftColumn + 1, false);
	|            }
	|            else if (ev.Flags == MouseFlags.WheeledLeft)
	|            {
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|                ScrollTo(leftColumn - 1, false);
	|            }
	|            else if (ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition))
	|            {
	|                ProcessMouseClick(ev, out List<Rune> line);
	|                PositionCursor();
	|                if (model.Count > 0 && shiftSelecting && selecting)
	|                {
	|                    if (currentRow - topRow + BottomOffset >= Frame.Height - 1
	|                        && model.Count + BottomOffset > topRow + currentRow)
	|                    {
	|                        ScrollTo(topRow + Frame.Height);
	|                    }
	|                    else if (topRow > 0 && currentRow <= topRow)
	|                    {
	|                        ScrollTo(topRow - Frame.Height);
	|                    }
	|                    else if (ev.Y >= Frame.Height)
	|                    {
	|                        ScrollTo(model.Count + BottomOffset);
	|                    }
	|                    else if (ev.Y < 0 && topRow > 0)
	|                    {
	|                        ScrollTo(0);
	|                    }
	|                    if (currentColumn - leftColumn + RightOffset >= Frame.Width - 1
	|                        && line.Count + RightOffset > leftColumn + currentColumn)
	|                    {
	|                        ScrollTo(leftColumn + Frame.Width, false);
	|                    }
	|                    else if (leftColumn > 0 && currentColumn <= leftColumn)
	|                    {
	|                        ScrollTo(leftColumn - Frame.Width, false);
	|                    }
	|                    else if (ev.X >= Frame.Width)
	|                    {
	|                        ScrollTo(line.Count + RightOffset, false);
	|                    }
	|                    else if (ev.X < 0 && leftColumn > 0)
	|                    {
	|                        ScrollTo(0, false);
	|                    }
	|                }
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|            }
	|            else if (ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ButtonShift))
	|            {
	|                if (!shiftSelecting)
	|                {
	|                    isButtonShift = true;
	|                    StartSelecting();
	|                }
	|                ProcessMouseClick(ev, out _);
	|                PositionCursor();
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|            }
	|            else if (ev.Flags.HasFlag(MouseFlags.Button1Pressed))
	|            {
	|                if (shiftSelecting)
	|                {
	|                    clickWithSelecting = true;
	|                    StopSelecting();
	|                }
	|                ProcessMouseClick(ev, out _);
	|                PositionCursor();
	|                if (!selecting)
	|                {
	|                    StartSelecting();
	|                }
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|                if (Application.MouseGrabView == null)
	|                {
	|                    Application.GrabMouse(this);
	|                }
	|            }
	|            else if (ev.Flags.HasFlag(MouseFlags.Button1Released))
	|            {
	|                Application.UngrabMouse();
	|            }
	|            else if (ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked))
	|            {
	|                if (ev.Flags.HasFlag(MouseFlags.ButtonShift))
	|                {
	|                    if (!selecting)
	|                    {
	|                        StartSelecting();
	|                    }
	|                }
	|                else if (selecting)
	|                {
	|                    StopSelecting();
	|                }
	|                ProcessMouseClick(ev, out List<Rune> line);
	|                (int col, int row)? newPos;
	|                if (currentColumn == line.Count || (currentColumn > 0 && (line[currentColumn - 1] != ' '
	|                    || line[currentColumn] == ' ')))
	|                {
	|
	|                    newPos = WordBackward(currentColumn, currentRow);
	|                    if (newPos.HasValue)
	|                    {
	|                        currentColumn = currentRow == newPos.Value.row ? newPos.Value.col : 0;
	|                    }
	|                }
	|                if (!selecting)
	|                {
	|                    StartSelecting();
	|                }
	|                newPos = WordForward(currentColumn, currentRow);
	|                if (newPos != null && newPos.HasValue)
	|                {
	|                    currentColumn = currentRow == newPos.Value.row ? newPos.Value.col : line.Count;
	|                }
	|                PositionCursor();
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|            }
	|            else if (ev.Flags.HasFlag(MouseFlags.Button1TripleClicked))
	|            {
	|                if (selecting)
	|                {
	|                    StopSelecting();
	|                }
	|                ProcessMouseClick(ev, out List<Rune> line);
	|                currentColumn = 0;
	|                if (!selecting)
	|                {
	|                    StartSelecting();
	|                }
	|                currentColumn = line.Count;
	|                PositionCursor();
	|                lastWasKill = false;
	|                columnTrack = currentColumn;
	|            }
	|            else if (ev.Flags == ContextMenu.MouseFlags)
	|            {
	|                ContextMenu.Position = new Point(ev.X + 2, ev.Y + 2);
	|                ShowContextMenu();
	|            }
	|
	|            return true;
	|        }
	|
	|        void ProcessMouseClick(MouseEvent ev, out List<Rune> line)
	|        {
	|            List<Rune> r = null;
	|            if (model.Count > 0)
	|            {
	|                var maxCursorPositionableLine = Math.Max((model.Count - 1) - topRow, 0);
	|                if (Math.Max(ev.Y, 0) > maxCursorPositionableLine)
	|                {
	|                    currentRow = maxCursorPositionableLine + topRow;
	|                }
	|                else
	|                {
	|                    currentRow = Math.Max(ev.Y + topRow, 0);
	|                }
	|                r = GetCurrentLine();
	|                var idx = TextModel.GetColFromX(r, leftColumn, Math.Max(ev.X, 0), TabWidth);
	|                if (idx - leftColumn >= r.Count + RightOffset)
	|                {
	|                    currentColumn = Math.Max(r.Count - leftColumn + RightOffset, 0);
	|                }
	|                else
	|                {
	|                    currentColumn = idx + leftColumn;
	|                }
	|            }
	|
	|            line = r;
	|        }
	|
	|        /// <summary>
	|        /// Allows clearing the <see cref=""HistoryText.HistoryTextItem""/> items updating the original text.
	|        /// </summary>
	|        public void ClearHistoryChanges()
	|        {
	|            historyText?.Clear(Text);
	|        }
	|    }
	|
	|
	|    /// <summary>
	|    /// Renders an overlay on another view at a given point that allows selecting
	|    /// from a range of 'autocomplete' options.
	|    /// An implementation on a TextView.
	|    /// </summary>
	|    public class TextViewAutocomplete : Autocomplete
	|    {
	|
	|        ///<inheritdoc/>
	|        protected override string GetCurrentWord(int columnOffset = 0)
	|        {
	|            var host = (TextView)HostControl;
	|            var currentLine = host.GetCurrentLine();
	|            var cursorPosition = Math.Min(host.CurrentColumn + columnOffset, currentLine.Count);
	|            return IdxToWord(currentLine, cursorPosition, columnOffset);
	|        }
	|
	|        /// <inheritdoc/>
	|        protected override void DeleteTextBackwards()
	|        {
	|            ((TextView)HostControl).DeleteCharLeft();
	|        }
	|
	|        /// <inheritdoc/>
	|        protected override void InsertText(string accepted)
	|        {
	|            ((TextView)HostControl).InsertText(accepted);
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // TimeField.cs: text entry for time
	|    //
	|    // Author: Jörg Preiß
	|    //
	|    // Licensed under the MIT license
	|
	|    /// <summary>
	|    ///   Time editing <see cref=""View""/>
	|    /// </summary>
	|    /// <remarks>
	|    ///   The <see cref=""TimeField""/> <see cref=""View""/> provides time editing functionality with mouse support.
	|    /// </remarks>
	|    public class TimeField : TextField
	|    {
	|        TimeSpan time;
	|        bool isShort;
	|
	|        int longFieldLen = 8;
	|        int shortFieldLen = 5;
	|        string sepChar;
	|        string longFormat;
	|        string shortFormat;
	|
	|        int fieldLen => isShort ? shortFieldLen : longFieldLen;
	|        string format => isShort ? shortFormat : longFormat;
	|
	|        /// <summary>
	|        ///   TimeChanged event, raised when the Date has changed.
	|        /// </summary>
	|        /// <remarks>
	|        ///   This event is raised when the <see cref=""Time""/> changes.
	|        /// </remarks>
	|        /// <remarks>
	|        ///   The passed <see cref=""EventArgs""/> is a <see cref=""DateTimeEventArgs{T}""/> containing the old value, new value, and format string.
	|        /// </remarks>
	|        public event Action<DateTimeEventArgs<TimeSpan>> TimeChanged;
	|
	|        /// <summary>
	|        ///    Initializes a new instance of <see cref=""TimeField""/> using <see cref=""LayoutStyle.Absolute""/> positioning.
	|        /// </summary>
	|        /// <param name=""x"">The x coordinate.</param>
	|        /// <param name=""y"">The y coordinate.</param>
	|        /// <param name=""time"">Initial time.</param>
	|        /// <param name=""isShort"">If true, the seconds are hidden. Sets the <see cref=""IsShortFormat""/> property.</param>
	|        public TimeField(int x, int y, TimeSpan time, bool isShort = false) : base(x, y, isShort ? 7 : 10, """")
	|        {
	|            Initialize(time, isShort);
	|        }
	|
	|        /// <summary>
	|        ///    Initializes a new instance of <see cref=""TimeField""/> using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        /// <param name=""time"">Initial time</param>
	|        public TimeField(TimeSpan time) : base(string.Empty)
	|        {
	|            Width = fieldLen + 2;
	|            Initialize(time);
	|        }
	|
	|        /// <summary>
	|        ///    Initializes a new instance of <see cref=""TimeField""/> using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        public TimeField() : this(time: TimeSpan.MinValue) { }
	|
	|        void Initialize(TimeSpan time, bool isShort = false)
	|        {
	|            CultureInfo cultureInfo = CultureInfo.CurrentCulture;
	|            sepChar = cultureInfo.DateTimeFormat.TimeSeparator;
	|            longFormat = $"" hh\\{sepChar}mm\\{sepChar}ss"";
	|            shortFormat = $"" hh\\{sepChar}mm"";
	|            this.isShort = isShort;
	|            Time = time;
	|            CursorPosition = 1;
	|            TextChanged += TextField_TextChanged;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.DeleteCharRight, () => { DeleteCharRight(); return true; });
	|            AddCommand(Command.DeleteCharLeft, () => { DeleteCharLeft(); return true; });
	|            AddCommand(Command.LeftHome, () => MoveHome());
	|            AddCommand(Command.Left, () => MoveLeft());
	|            AddCommand(Command.RightEnd, () => MoveEnd());
	|            AddCommand(Command.Right, () => MoveRight());
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
	|            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);
	|
	|            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
	|            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);
	|
	|            AddKeyBinding(Key.Home, Command.LeftHome);
	|            AddKeyBinding(Key.A | Key.CtrlMask, Command.LeftHome);
	|
	|            AddKeyBinding(Key.CursorLeft, Command.Left);
	|            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);
	|
	|            AddKeyBinding(Key.End, Command.RightEnd);
	|            AddKeyBinding(Key.E | Key.CtrlMask, Command.RightEnd);
	|
	|            AddKeyBinding(Key.CursorRight, Command.Right);
	|            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);
	|        }
	|
	|        void TextField_TextChanged(ustring e)
	|        {
	|            try
	|            {
	|                if (!TimeSpan.TryParseExact(Text.ToString().Trim(), format.Trim(), CultureInfo.CurrentCulture, TimeSpanStyles.None, out TimeSpan result))
	|                    Text = e;
	|            }
	|            catch (Exception)
	|            {
	|                Text = e;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Gets or sets the time of the <see cref=""TimeField""/>.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public TimeSpan Time
	|        {
	|            get
	|            {
	|                return time;
	|            }
	|            set
	|            {
	|                if (ReadOnly)
	|                    return;
	|
	|                var oldTime = time;
	|                time = value;
	|                this.Text = "" "" + value.ToString(format.Trim());
	|                var args = new DateTimeEventArgs<TimeSpan>(oldTime, value, format);
	|                if (oldTime != value)
	|                {
	|                    OnTimeChanged(args);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or sets whether <see cref=""TimeField""/> uses the short or long time format.
	|        /// </summary>
	|        public bool IsShortFormat
	|        {
	|            get => isShort;
	|            set
	|            {
	|                isShort = value;
	|                if (isShort)
	|                    Width = 7;
	|                else
	|                    Width = 10;
	|                var ro = ReadOnly;
	|                if (ro)
	|                    ReadOnly = false;
	|                SetText(Text);
	|                ReadOnly = ro;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override int CursorPosition
	|        {
	|            get => base.CursorPosition;
	|            set
	|            {
	|                base.CursorPosition = Math.Max(Math.Min(value, fieldLen), 1);
	|            }
	|        }
	|
	|        bool SetText(Rune key)
	|        {
	|            var text = TextModel.ToRunes(Text);
	|            var newText = text.GetRange(0, CursorPosition);
	|            newText.Add(key);
	|            if (CursorPosition < fieldLen)
	|                newText = newText.Concat(text.GetRange(CursorPosition + 1, text.Count - (CursorPosition + 1))).ToList();
	|            return SetText(ustring.Make(newText));
	|        }
	|
	|        bool SetText(ustring text)
	|        {
	|            if (text.IsEmpty)
	|            {
	|                return false;
	|            }
	|
	|            ustring[] vals = text.Split(ustring.Make(sepChar));
	|            bool isValidTime = true;
	|            int hour = Int32.Parse(vals[0].ToString());
	|            int minute = Int32.Parse(vals[1].ToString());
	|            int second = isShort ? 0 : vals.Length > 2 ? Int32.Parse(vals[2].ToString()) : 0;
	|            if (hour < 0)
	|            {
	|                isValidTime = false;
	|                hour = 0;
	|                vals[0] = ""0"";
	|            }
	|            else if (hour > 23)
	|            {
	|                isValidTime = false;
	|                hour = 23;
	|                vals[0] = ""23"";
	|            }
	|            if (minute < 0)
	|            {
	|                isValidTime = false;
	|                minute = 0;
	|                vals[1] = ""0"";
	|            }
	|            else if (minute > 59)
	|            {
	|                isValidTime = false;
	|                minute = 59;
	|                vals[1] = ""59"";
	|            }
	|            if (second < 0)
	|            {
	|                isValidTime = false;
	|                second = 0;
	|                vals[2] = ""0"";
	|            }
	|            else if (second > 59)
	|            {
	|                isValidTime = false;
	|                second = 59;
	|                vals[2] = ""59"";
	|            }
	|            string t = isShort ? $"" {hour,2:00}{sepChar}{minute,2:00}"" : $"" {hour,2:00}{sepChar}{minute,2:00}{sepChar}{second,2:00}"";
	|
	|            if (!TimeSpan.TryParseExact(t.Trim(), format.Trim(), CultureInfo.CurrentCulture, TimeSpanStyles.None, out TimeSpan result) ||
	|                !isValidTime)
	|                return false;
	|            Time = result;
	|            return true;
	|        }
	|
	|        void IncCursorPosition()
	|        {
	|            if (CursorPosition == fieldLen)
	|                return;
	|            if (Text[++CursorPosition] == sepChar.ToCharArray()[0])
	|                CursorPosition++;
	|        }
	|
	|        void DecCursorPosition()
	|        {
	|            if (CursorPosition == 1)
	|                return;
	|            if (Text[--CursorPosition] == sepChar.ToCharArray()[0])
	|                CursorPosition--;
	|        }
	|
	|        void AdjCursorPosition()
	|        {
	|            if (Text[CursorPosition] == sepChar.ToCharArray()[0])
	|                CursorPosition++;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            var result = InvokeKeybindings(kb);
	|            if (result != null)
	|                return (bool)result;
	|
	|            // Ignore non-numeric characters.
	|            if (kb.Key < (Key)((int)Key.D0) || kb.Key > (Key)((int)Key.D9))
	|                return false;
	|
	|            if (ReadOnly)
	|                return true;
	|
	|            if (SetText(TextModel.ToRunes(ustring.Make((uint)kb.Key)).First()))
	|                IncCursorPosition();
	|
	|            return true;
	|        }
	|
	|        bool MoveRight()
	|        {
	|            IncCursorPosition();
	|            return true;
	|        }
	|
	|        bool MoveEnd()
	|        {
	|            CursorPosition = fieldLen;
	|            return true;
	|        }
	|
	|        bool MoveLeft()
	|        {
	|            DecCursorPosition();
	|            return true;
	|        }
	|
	|        bool MoveHome()
	|        {
	|            // Home, C-A
	|            CursorPosition = 1;
	|            return true;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void DeleteCharLeft(bool useOldCursorPos = true)
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            SetText('0');
	|            DecCursorPosition();
	|            return;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void DeleteCharRight()
	|        {
	|            if (ReadOnly)
	|                return;
	|
	|            SetText('0');
	|            return;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent ev)
	|        {
	|            if (!ev.Flags.HasFlag(MouseFlags.Button1Clicked))
	|                return false;
	|            if (!HasFocus)
	|                SetFocus();
	|
	|            var point = ev.X;
	|            if (point > fieldLen)
	|                point = fieldLen;
	|            if (point < 1)
	|                point = 1;
	|            CursorPosition = point;
	|            AdjCursorPosition();
	|            return true;
	|        }
	|
	|        /// <summary>
	|        /// Event firing method that invokes the <see cref=""TimeChanged""/> event.
	|        /// </summary>
	|        /// <param name=""args"">The event arguments</param>
	|        public virtual void OnTimeChanged(DateTimeEventArgs<TimeSpan> args)
	|        {
	|            TimeChanged?.Invoke(args);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Toplevel views can be modally executed. They are used for both an application's main view (filling the entire screen and
	|    /// for pop-up views such as <see cref=""Dialog""/>, <see cref=""MessageBox""/>, and <see cref=""Wizard""/>.
	|    /// </summary>
	|    /// <remarks>
	|    ///   <para>
	|    ///     Toplevels can be modally executing views, started by calling <see cref=""Application.Run(Toplevel, Func{Exception, bool})""/>. 
	|    ///     They return control to the caller when <see cref=""Application.RequestStop(Toplevel)""/> has 
	|    ///     been called (which sets the <see cref=""Toplevel.Running""/> property to <c>false</c>). 
	|    ///   </para>
	|    ///   <para>
	|    ///     A Toplevel is created when an application initializes Terminal.Gui by calling <see cref=""Application.Init(ConsoleDriver, IMainLoopDriver)""/>.
	|    ///     The application Toplevel can be accessed via <see cref=""Application.Top""/>. Additional Toplevels can be created 
	|    ///     and run (e.g. <see cref=""Dialog""/>s. To run a Toplevel, create the <see cref=""Toplevel""/> and 
	|    ///     call <see cref=""Application.Run(Toplevel, Func{Exception, bool})""/>.
	|    ///   </para>
	|    ///   <para>
	|    ///     Toplevels can also opt-in to more sophisticated initialization
	|    ///     by implementing <see cref=""ISupportInitialize""/>. When they do
	|    ///     so, the <see cref=""ISupportInitialize.BeginInit""/> and
	|    ///     <see cref=""ISupportInitialize.EndInit""/> methods will be called
	|    ///     before running the view.
	|    ///     If first-run-only initialization is preferred, the <see cref=""ISupportInitializeNotification""/>
	|    ///     can be implemented too, in which case the <see cref=""ISupportInitialize""/>
	|    ///     methods will only be called if <see cref=""ISupportInitializeNotification.IsInitialized""/>
	|    ///     is <see langword=""false""/>. This allows proper <see cref=""View""/> inheritance hierarchies
	|    ///     to override base class layout code optimally by doing so only on first run,
	|    ///     instead of on every run.
	|    ///   </para>
	|    /// </remarks>
	|    public class Toplevel : View
	|    {
	|        /// <summary>
	|        /// Gets or sets whether the <see cref=""MainLoop""/> for this <see cref=""Toplevel""/> is running or not. 
	|        /// </summary>
	|        /// <remarks>
	|        ///    Setting this property directly is discouraged. Use <see cref=""Application.RequestStop""/> instead. 
	|        /// </remarks>
	|        public bool Running { get; set; }
	|
	|        /// <summary>
	|        /// Invoked when the Toplevel <see cref=""Application.RunState""/> has begun to be loaded.
	|        /// A Loaded event handler is a good place to finalize initialization before calling 
	|        /// <see cref=""Application.RunLoop(Application.RunState, bool)""/>.
	|        /// </summary>
	|        public event Action Loaded;
	|
	|        /// <summary>
	|        /// Invoked when the Toplevel <see cref=""MainLoop""/> has started it's first iteration.
	|        /// Subscribe to this event to perform tasks when the <see cref=""Toplevel""/> has been laid out and focus has been set.
	|        /// changes. 
	|        /// <para>A Ready event handler is a good place to finalize initialization after calling 
	|        /// <see cref=""Application.Run(Func{Exception, bool})""/> on this Toplevel.</para>
	|        /// </summary>
	|        public event Action Ready;
	|
	|        /// <summary>
	|        /// Invoked when the Toplevel <see cref=""Application.RunState""/> has been unloaded.
	|        /// A Unloaded event handler is a good place to dispose objects after calling <see cref=""Application.End(Application.RunState)""/>.
	|        /// </summary>
	|        public event Action Unloaded;
	|
	|        /// <summary>
	|        /// Invoked when the Toplevel <see cref=""Application.RunState""/> becomes the <see cref=""Application.Current""/> Toplevel.
	|        /// </summary>
	|        public event Action<Toplevel> Activate;
	|
	|        /// <summary>
	|        /// Invoked when the Toplevel<see cref=""Application.RunState""/> ceases to be the <see cref=""Application.Current""/> Toplevel.
	|        /// </summary>
	|        public event Action<Toplevel> Deactivate;
	|
	|        /// <summary>
	|        /// Invoked when a child of the Toplevel <see cref=""Application.RunState""/> is closed by  
	|        /// <see cref=""Application.End(Application.RunState)""/>.
	|        /// </summary>
	|        public event Action<Toplevel> ChildClosed;
	|
	|        /// <summary>
	|        /// Invoked when the last child of the Toplevel <see cref=""Application.RunState""/> is closed from 
	|        /// by <see cref=""Application.End(Application.RunState)""/>.
	|        /// </summary>
	|        public event Action AllChildClosed;
	|
	|        /// <summary>
	|        /// Invoked when the Toplevel's <see cref=""Application.RunState""/> is being closed by  
	|        /// <see cref=""Application.RequestStop(Toplevel)""/>.
	|        /// </summary>
	|        public event Action<ToplevelClosingEventArgs> Closing;
	|
	|        /// <summary>
	|        /// Invoked when the Toplevel's <see cref=""Application.RunState""/> is closed by <see cref=""Application.End(Application.RunState)""/>.
	|        /// </summary>
	|        public event Action<Toplevel> Closed;
	|
	|        /// <summary>
	|        /// Invoked when a child Toplevel's <see cref=""Application.RunState""/> has been loaded.
	|        /// </summary>
	|        public event Action<Toplevel> ChildLoaded;
	|
	|        /// <summary>
	|        /// Invoked when a cjhild Toplevel's <see cref=""Application.RunState""/> has been unloaded.
	|        /// </summary>
	|        public event Action<Toplevel> ChildUnloaded;
	|
	|        /// <summary>
	|        /// Invoked when the terminal has been resized. The new <see cref=""Size""/> of the terminal is provided.
	|        /// </summary>
	|        public event Action<Size> Resized;
	|
	|        internal virtual void OnResized(Size size)
	|        {
	|            Resized?.Invoke(size);
	|        }
	|
	|        internal virtual void OnChildUnloaded(Toplevel top)
	|        {
	|            ChildUnloaded?.Invoke(top);
	|        }
	|
	|        internal virtual void OnChildLoaded(Toplevel top)
	|        {
	|            ChildLoaded?.Invoke(top);
	|        }
	|
	|        internal virtual void OnClosed(Toplevel top)
	|        {
	|            Closed?.Invoke(top);
	|        }
	|
	|        internal virtual bool OnClosing(ToplevelClosingEventArgs ev)
	|        {
	|            Closing?.Invoke(ev);
	|            return ev.Cancel;
	|        }
	|
	|        internal virtual void OnAllChildClosed()
	|        {
	|            AllChildClosed?.Invoke();
	|        }
	|
	|        internal virtual void OnChildClosed(Toplevel top)
	|        {
	|            if (IsMdiContainer)
	|            {
	|                SetChildNeedsDisplay();
	|            }
	|            ChildClosed?.Invoke(top);
	|        }
	|
	|        internal virtual void OnDeactivate(Toplevel activated)
	|        {
	|            Deactivate?.Invoke(activated);
	|        }
	|
	|        internal virtual void OnActivate(Toplevel deactivated)
	|        {
	|            Activate?.Invoke(deactivated);
	|        }
	|
	|        /// <summary>
	|        /// Called from <see cref=""Application.Begin(Toplevel)""/> before the <see cref=""Toplevel""/> redraws for the first time. 
	|        /// </summary>
	|        virtual public void OnLoaded()
	|        {
	|            foreach (Toplevel tl in Subviews.Where(v => v is Toplevel))
	|            {
	|                tl.OnLoaded();
	|            }
	|            Loaded?.Invoke();
	|        }
	|
	|        /// <summary>
	|        /// Called from <see cref=""Application.RunLoop""/> after the <see cref=""Toplevel""/> has entered the 
	|        /// first iteration of the loop.
	|        /// </summary>
	|        internal virtual void OnReady()
	|        {
	|            foreach (Toplevel tl in Subviews.Where(v => v is Toplevel))
	|            {
	|                tl.OnReady();
	|            }
	|            Ready?.Invoke();
	|        }
	|
	|        /// <summary>
	|        /// Called from <see cref=""Application.End(Application.RunState)""/> before the <see cref=""Toplevel""/> is disposed.
	|        /// </summary>
	|        internal virtual void OnUnloaded()
	|        {
	|            foreach (Toplevel tl in Subviews.Where(v => v is Toplevel))
	|            {
	|                tl.OnUnloaded();
	|            }
	|            Unloaded?.Invoke();
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Toplevel""/> class with the specified <see cref=""LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <param name=""frame"">A superview-relative rectangle specifying the location and size for the new Toplevel</param>
	|        public Toplevel(Rect frame) : base(frame)
	|        {
	|            Initialize();
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Toplevel""/> class with <see cref=""LayoutStyle.Computed""/> layout, 
	|        /// defaulting to full screen.
	|        /// </summary>
	|        public Toplevel() : base()
	|        {
	|            Initialize();
	|            Width = Dim.Fill();
	|            Height = Dim.Fill();
	|        }
	|
	|        void Initialize()
	|        {
	|            ColorScheme = Colors.TopLevel;
	|
	|            Application.GrabbingMouse += Application_GrabbingMouse;
	|            Application.UnGrabbingMouse += Application_UnGrabbingMouse;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.QuitToplevel, () => { QuitToplevel(); return true; });
	|            AddCommand(Command.Suspend, () => { Driver.Suspend(); ; return true; });
	|            AddCommand(Command.NextView, () => { MoveNextView(); return true; });
	|            AddCommand(Command.PreviousView, () => { MovePreviousView(); return true; });
	|            AddCommand(Command.NextViewOrTop, () => { MoveNextViewOrTop(); return true; });
	|            AddCommand(Command.PreviousViewOrTop, () => { MovePreviousViewOrTop(); return true; });
	|            AddCommand(Command.Refresh, () => { Application.Refresh(); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Application.QuitKey, Command.QuitToplevel);
	|            AddKeyBinding(Key.Z | Key.CtrlMask, Command.Suspend);
	|
	|            AddKeyBinding(Key.Tab, Command.NextView);
	|
	|            AddKeyBinding(Key.CursorRight, Command.NextView);
	|            AddKeyBinding(Key.F | Key.CtrlMask, Command.NextView);
	|
	|            AddKeyBinding(Key.CursorDown, Command.NextView);
	|            AddKeyBinding(Key.I | Key.CtrlMask, Command.NextView); // Unix
	|
	|            AddKeyBinding(Key.BackTab | Key.ShiftMask, Command.PreviousView);
	|            AddKeyBinding(Key.CursorLeft, Command.PreviousView);
	|            AddKeyBinding(Key.CursorUp, Command.PreviousView);
	|            AddKeyBinding(Key.B | Key.CtrlMask, Command.PreviousView);
	|
	|            AddKeyBinding(Key.Tab | Key.CtrlMask, Command.NextViewOrTop);
	|            AddKeyBinding(Application.AlternateForwardKey, Command.NextViewOrTop); // Needed on Unix
	|
	|            AddKeyBinding(Key.Tab | Key.ShiftMask | Key.CtrlMask, Command.PreviousViewOrTop);
	|            AddKeyBinding(Application.AlternateBackwardKey, Command.PreviousViewOrTop); // Needed on Unix
	|
	|            AddKeyBinding(Key.L | Key.CtrlMask, Command.Refresh);
	|        }
	|
	|        private bool Application_UnGrabbingMouse(View e)
	|        {
	|            if (dragPosition.HasValue)
	|            {
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        private bool Application_GrabbingMouse(View e)
	|        {
	|            if (Application.MouseGrabView == this && dragPosition.HasValue)
	|            {
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Invoked when the <see cref=""Application.AlternateForwardKey""/> is changed.
	|        /// </summary>
	|        public event Action<Key> AlternateForwardKeyChanged;
	|
	|        /// <summary>
	|        /// Virtual method to invoke the <see cref=""AlternateForwardKeyChanged""/> event.
	|        /// </summary>
	|        /// <param name=""oldKey""></param>
	|        public virtual void OnAlternateForwardKeyChanged(Key oldKey)
	|        {
	|            ReplaceKeyBinding(oldKey, Application.AlternateForwardKey);
	|            AlternateForwardKeyChanged?.Invoke(oldKey);
	|        }
	|
	|        /// <summary>
	|        /// Invoked when the <see cref=""Application.AlternateBackwardKey""/> is changed.
	|        /// </summary>
	|        public event Action<Key> AlternateBackwardKeyChanged;
	|
	|        /// <summary>
	|        /// Virtual method to invoke the <see cref=""AlternateBackwardKeyChanged""/> event.
	|        /// </summary>
	|        /// <param name=""oldKey""></param>
	|        public virtual void OnAlternateBackwardKeyChanged(Key oldKey)
	|        {
	|            ReplaceKeyBinding(oldKey, Application.AlternateBackwardKey);
	|            AlternateBackwardKeyChanged?.Invoke(oldKey);
	|        }
	|
	|        /// <summary>
	|        /// Invoked when the <see cref=""Application.QuitKey""/> is changed.
	|        /// </summary>
	|        public event Action<Key> QuitKeyChanged;
	|
	|        /// <summary>
	|        /// Virtual method to invoke the <see cref=""QuitKeyChanged""/> event.
	|        /// </summary>
	|        /// <param name=""oldKey""></param>
	|        public virtual void OnQuitKeyChanged(Key oldKey)
	|        {
	|            ReplaceKeyBinding(oldKey, Application.QuitKey);
	|            QuitKeyChanged?.Invoke(oldKey);
	|        }
	|
	|        /// <summary>
	|        /// Convenience factory method that creates a new Toplevel with the current terminal dimensions.
	|        /// </summary>
	|        /// <returns>The created Toplevel.</returns>
	|        public static Toplevel Create()
	|        {
	|            return new Toplevel(new Rect(0, 0, Driver.Cols, Driver.Rows));
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""Toplevel""/> can focus.
	|        /// </summary>
	|        /// <value><c>true</c> if can focus; otherwise, <c>false</c>.</value>
	|        public override bool CanFocus
	|        {
	|            get => SuperView == null ? true : base.CanFocus;
	|        }
	|
	|        /// <summary>
	|        /// Determines whether the <see cref=""Toplevel""/> is modal or not. 
	|        /// If set to <c>false</c> (the default):
	|        /// 
	|        /// <list type=""bullet"">
	|        ///   <item>
	|        ///		<description><see cref=""ProcessKey(KeyEvent)""/> events will propagate keys upwards.</description>
	|        ///   </item>
	|        ///   <item>
	|        ///		<description>The Toplevel will act as an embedded view (not a modal/pop-up).</description>
	|        ///   </item>
	|        /// </list>
	|        ///
	|        /// If set to <c>true</c>:
	|        /// 
	|        /// <list type=""bullet"">
	|        ///   <item>
	|        ///		<description><see cref=""ProcessKey(KeyEvent)""/> events will NOT propogate keys upwards.</description>
	|        ///	  </item>
	|        ///   <item>
	|        ///		<description>The Toplevel will and look like a modal (pop-up) (e.g. see <see cref=""Dialog""/>.</description>
	|        ///   </item>
	|        /// </list>
	|        /// </summary>
	|        public bool Modal { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the menu for this Toplevel.
	|        /// </summary>
	|        public virtual MenuBar MenuBar { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the status bar for this Toplevel.
	|        /// </summary>
	|        public virtual StatusBar StatusBar { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets if this Toplevel is a Mdi container.
	|        /// </summary>
	|        public bool IsMdiContainer { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets if this Toplevel is a Mdi child.
	|        /// </summary>
	|        public bool IsMdiChild
	|        {
	|            get
	|            {
	|                return Application.MdiTop != null && Application.MdiTop != this && !Modal;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnKeyDown(KeyEvent keyEvent)
	|        {
	|            if (base.OnKeyDown(keyEvent))
	|            {
	|                return true;
	|            }
	|
	|            switch (keyEvent.Key)
	|            {
	|                case Key.AltMask:
	|                case Key.AltMask | Key.Space:
	|                case Key.CtrlMask | Key.Space:
	|                case Key _ when (keyEvent.Key & Key.AltMask) == Key.AltMask:
	|                    return MenuBar != null && MenuBar.OnKeyDown(keyEvent);
	|            }
	|
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnKeyUp(KeyEvent keyEvent)
	|        {
	|            if (base.OnKeyUp(keyEvent))
	|            {
	|                return true;
	|            }
	|
	|            switch (keyEvent.Key)
	|            {
	|                case Key.AltMask:
	|                case Key.AltMask | Key.Space:
	|                case Key.CtrlMask | Key.Space:
	|                    if (MenuBar != null && MenuBar.OnKeyUp(keyEvent))
	|                    {
	|                        return true;
	|                    }
	|                    break;
	|            }
	|
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            if (base.ProcessKey(keyEvent))
	|                return true;
	|
	|            var result = InvokeKeybindings(new KeyEvent(ShortcutHelper.GetModifiersKey(keyEvent),
	|                new KeyModifiers() { Alt = keyEvent.IsAlt, Ctrl = keyEvent.IsCtrl, Shift = keyEvent.IsShift }));
	|            if (result != null)
	|                return (bool)result;
	|
	|#if false
	|			if (keyEvent.Key == Key.F5) {
	|				Application.DebugDrawBounds = !Application.DebugDrawBounds;
	|				SetNeedsDisplay ();
	|				return true;
	|			}
	|#endif
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessHotKey(KeyEvent keyEvent)
	|        {
	|            if (base.ProcessHotKey(keyEvent))
	|            {
	|                return true;
	|            }
	|
	|            if (this.IsMdiChild && Application.Top.ProcessHotKey(keyEvent))
	|            {
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool ProcessColdKey(KeyEvent keyEvent)
	|        {
	|            if (base.ProcessColdKey(keyEvent))
	|            {
	|                return true;
	|            }
	|
	|            if (ShortcutHelper.FindAndOpenByShortcut(keyEvent, this))
	|            {
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        private void MovePreviousViewOrTop()
	|        {
	|            if (Application.MdiTop == null)
	|            {
	|                var top = Modal ? this : Application.Top;
	|                top.FocusPrev();
	|                if (top.Focused == null)
	|                {
	|                    top.FocusPrev();
	|                }
	|                top.SetNeedsDisplay();
	|                Application.EnsuresTopOnFront();
	|            }
	|            else
	|            {
	|                MovePrevious();
	|            }
	|        }
	|
	|        private void MoveNextViewOrTop()
	|        {
	|            if (Application.MdiTop == null)
	|            {
	|                var top = Modal ? this : Application.Top;
	|                top.FocusNext();
	|                if (top.Focused == null)
	|                {
	|                    top.FocusNext();
	|                }
	|                top.SetNeedsDisplay();
	|                Application.EnsuresTopOnFront();
	|            }
	|            else
	|            {
	|                MoveNext();
	|            }
	|        }
	|
	|        private void MovePreviousView()
	|        {
	|            var old = GetDeepestFocusedSubview(Focused);
	|            if (!FocusPrev())
	|                FocusPrev();
	|            if (old != Focused && old != Focused?.Focused)
	|            {
	|                old?.SetNeedsDisplay();
	|                Focused?.SetNeedsDisplay();
	|            }
	|            else
	|            {
	|                FocusNearestView(SuperView?.TabIndexes?.Reverse(), Direction.Backward);
	|            }
	|        }
	|
	|        private void MoveNextView()
	|        {
	|            var old = GetDeepestFocusedSubview(Focused);
	|            if (!FocusNext())
	|                FocusNext();
	|            if (old != Focused && old != Focused?.Focused)
	|            {
	|                old?.SetNeedsDisplay();
	|                Focused?.SetNeedsDisplay();
	|            }
	|            else
	|            {
	|                FocusNearestView(SuperView?.TabIndexes, Direction.Forward);
	|            }
	|        }
	|
	|        private void QuitToplevel()
	|        {
	|            if (IsMdiChild)
	|            {
	|                RequestStop();
	|            }
	|            else if (Application.MdiTop != null)
	|            {
	|                Application.MdiTop.RequestStop();
	|            }
	|            else
	|            {
	|                Application.RequestStop();
	|            }
	|        }
	|
	|        View GetDeepestFocusedSubview(View view)
	|        {
	|            if (view == null)
	|            {
	|                return null;
	|            }
	|
	|            foreach (var v in view.Subviews)
	|            {
	|                if (v.HasFocus)
	|                {
	|                    return GetDeepestFocusedSubview(v);
	|                }
	|            }
	|            return view;
	|        }
	|
	|        void FocusNearestView(IEnumerable<View> views, Direction direction)
	|        {
	|            if (views == null)
	|            {
	|                return;
	|            }
	|
	|            bool found = false;
	|            bool focusProcessed = false;
	|            int idx = 0;
	|
	|            foreach (var v in views)
	|            {
	|                if (v == this)
	|                {
	|                    found = true;
	|                }
	|                if (found && v != this)
	|                {
	|                    if (direction == Direction.Forward)
	|                    {
	|                        SuperView?.FocusNext();
	|                    }
	|                    else
	|                    {
	|                        SuperView?.FocusPrev();
	|                    }
	|                    focusProcessed = true;
	|                    if (SuperView.Focused != null && SuperView.Focused != this)
	|                    {
	|                        return;
	|                    }
	|                }
	|                else if (found && !focusProcessed && idx == views.Count() - 1)
	|                {
	|                    views.ToList()[0].SetFocus();
	|                }
	|                idx++;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Add(View view)
	|        {
	|            CanFocus = true;
	|            AddMenuStatusBar(view);
	|            base.Add(view);
	|        }
	|
	|        internal void AddMenuStatusBar(View view)
	|        {
	|            if (view is MenuBar)
	|            {
	|                MenuBar = view as MenuBar;
	|            }
	|            if (view is StatusBar)
	|            {
	|                StatusBar = view as StatusBar;
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Remove(View view)
	|        {
	|            if (this is Toplevel toplevel && toplevel.MenuBar != null)
	|            {
	|                RemoveMenuStatusBar(view);
	|            }
	|            base.Remove(view);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void RemoveAll()
	|        {
	|            if (this == Application.Top)
	|            {
	|                MenuBar?.Dispose();
	|                MenuBar = null;
	|                StatusBar?.Dispose();
	|                StatusBar = null;
	|            }
	|            base.RemoveAll();
	|        }
	|
	|        internal void RemoveMenuStatusBar(View view)
	|        {
	|            if (view is MenuBar)
	|            {
	|                MenuBar?.Dispose();
	|                MenuBar = null;
	|            }
	|            if (view is StatusBar)
	|            {
	|                StatusBar?.Dispose();
	|                StatusBar = null;
	|            }
	|        }
	|
	|        internal View EnsureVisibleBounds(Toplevel top, int x, int y,
	|            out int nx, out int ny, out View mb, out View sb)
	|        {
	|            int l;
	|            View superView = GetSuperView(top);
	|            if (superView == null || top == Application.Top || superView == Application.Top)
	|            {
	|                l = Driver.Cols;
	|                superView = Application.Top;
	|            }
	|            else
	|            {
	|                l = superView.Frame.Width;
	|            }
	|            mb = null; sb = null;
	|            if (!(superView is Toplevel))
	|            {
	|                nx = Math.Max(Math.Min(x, top.Frame.Right - 1), 0);
	|                ny = Math.Max(Math.Min(y, top.Frame.Bottom - 1), 0);
	|                return superView;
	|            }
	|            var superViewBorder = superView.Border != null ? (superView.Border.DrawMarginFrame ? 1 : 0) : 0;
	|            var topBorder = top.Modal ? 0 : top.Border != null ? (top.Border.DrawMarginFrame ? 1 : 0) : 0;
	|            nx = Math.Max(x, 0);
	|            nx = !top.IsMdiChild && !top.Modal && nx + superViewBorder * 2 + top.Frame.Width >= l ? Math.Max(l - top.Frame.Width - superViewBorder * 2, 0) : nx;
	|            nx = top.Modal && nx == 0 ? superViewBorder : nx;
	|            nx = top.IsMdiChild && nx < superViewBorder ? superViewBorder : nx;
	|            nx = top.Modal && nx + superViewBorder + top.Frame.Width >= l ? l - top.Frame.Width - superViewBorder : nx;
	|            nx = top.IsMdiChild && nx + superViewBorder + top.Frame.Width >= l ? l - top.Frame.Width - superViewBorder : nx;
	|            if (nx + topBorder * 2 > top.Frame.X + top.Frame.Width)
	|            {
	|                nx = Math.Max(top.Frame.Right - topBorder * 2, 0);
	|            }
	|            //System.Diagnostics.Debug.WriteLine ($""nx:{nx}, rWidth:{rWidth}"");
	|            bool m = false, s = false;
	|            if (!(top is Window && top == Application.Top) && (superView == null || top == Application.Top || superView == Application.Top))
	|            {
	|                m = Application.Top.MenuBar?.Visible == true;
	|                mb = Application.Top.MenuBar;
	|            }
	|            else if (!(top is Window && top == Application.Top))
	|            {
	|                var t = superView;
	|                while (!(t is Toplevel))
	|                {
	|                    t = GetSuperView(t);
	|                }
	|                m = ((Toplevel)t).MenuBar?.Visible == true;
	|                mb = ((Toplevel)t).MenuBar;
	|            }
	|            if (superView == null || top == Application.Top || superView == Application.Top)
	|            {
	|                l = m ? 1 + (top.Modal ? superViewBorder - topBorder : 0) : 0;
	|            }
	|            else
	|            {
	|                l = 0;
	|            }
	|            ny = Math.Max(y, l);
	|            ny = top.Modal && ny == 0 ? superViewBorder : ny;
	|            ny = top.IsMdiChild && ny < superViewBorder + l ? ny + superViewBorder : ny;
	|            if (!(top is Window && top == Application.Top) && (superView == null || top == Application.Top || superView == Application.Top))
	|            {
	|                s = Application.Top.StatusBar?.Visible == true;
	|                sb = Application.Top.StatusBar;
	|            }
	|            else if (!(top is Window && top == Application.Top))
	|            {
	|                var t = superView;
	|                while (!(t is Toplevel))
	|                {
	|                    t = GetSuperView(t);
	|                }
	|                s = ((Toplevel)t).StatusBar?.Visible == true;
	|                sb = ((Toplevel)t).StatusBar;
	|            }
	|            if (superView == null || top == Application.Top || superView == Application.Top)
	|            {
	|                l = (s ? Driver.Rows - 1 : Driver.Rows);
	|            }
	|            else
	|            {
	|                l = (s ? superView.Frame.Height - 1 : superView.Frame.Height);
	|            }
	|            ny = Math.Min(ny, l);
	|            ny = !top.IsMdiChild && !top.Modal && ny + superViewBorder * 2 + top.Frame.Height >= l ? Math.Max(l - top.Frame.Height - superViewBorder * 2, m ? 1 : 0) : ny;
	|            ny = top.Modal && ny + superViewBorder * 2 + top.Frame.Height >= l ? l - top.Frame.Height - superViewBorder : ny;
	|            ny = top.IsMdiChild && ny + superViewBorder + top.Frame.Height >= l ? Math.Max(l - top.Frame.Height - superViewBorder, m ? 1 : 0) : ny;
	|            if (ny + topBorder * 2 > top.Frame.Y + top.Frame.Height)
	|            {
	|                ny = Math.Max(top.Frame.Bottom - topBorder * 2, 0);
	|            }
	|            //System.Diagnostics.Debug.WriteLine ($""ny:{ny}, rHeight:{rHeight}"");
	|
	|            if (superView != null && superView == top && superView == Application.Top)
	|            {
	|                nx = superView.Frame.X; ny = superView.Frame.Y;
	|            }
	|
	|            return superView;
	|        }
	|
	|        View GetSuperView(View view)
	|        {
	|            if (view.SuperView == null)
	|            {
	|                return Application.Top;
	|            }
	|            var superView = view.SuperView;
	|            if (superView.GetType().Name == ""ContentView"")
	|            {
	|                return superView.SuperView;
	|            }
	|            return superView;
	|        }
	|
	|        internal void PositionToplevels()
	|        {
	|            PositionToplevel(this);
	|            foreach (var top in Subviews)
	|            {
	|                if (top is Toplevel)
	|                {
	|                    PositionToplevel((Toplevel)top);
	|                }
	|                else if (top.GetType().Name == ""ContentView"")
	|                {
	|                    foreach (var subTop in top.Subviews.Where(v => v is Toplevel))
	|                    {
	|                        PositionToplevel((Toplevel)subTop);
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Virtual method enabling implementation of specific positions for inherited <see cref=""Toplevel""/> views.
	|        /// </summary>
	|        /// <param name=""top"">The toplevel.</param>
	|        public virtual void PositionToplevel(Toplevel top)
	|        {
	|            var superView = EnsureVisibleBounds(top, top.Frame.X, top.Frame.Y,
	|                out int nx, out int ny, out _, out View sb);
	|            if (superView != null && superView == top && superView == Application.Top)
	|            {
	|                return;
	|            }
	|            bool layoutSubviews = false;
	|            if ((superView != null || (top != Application.Top && top.Modal)
	|                || (superView == null && top.IsMdiChild))
	|                && (nx != top.Frame.X || ny != top.Frame.Y) && top.LayoutStyle == LayoutStyle.Computed)
	|            {
	|
	|                if ((top.X == null || top.X is Pos.PosAbsolute) && top.Frame.X != nx)
	|                {
	|                    top.X = nx;
	|                    layoutSubviews = true;
	|                }
	|                if ((top.Y == null || top.Y is Pos.PosAbsolute) && top.Frame.Y != ny)
	|                {
	|                    top.Y = ny;
	|                    layoutSubviews = true;
	|                }
	|            }
	|
	|            if (sb != null && ny + top.Frame.Height != superView.Frame.Height - (sb.Visible ? 1 : 0)
	|                && top.Height is Dim.DimFill && -top.Height.Anchor(0) < 1)
	|            {
	|
	|                top.Height = Dim.Fill(sb.Visible ? 1 : 0);
	|                layoutSubviews = true;
	|            }
	|
	|            if (layoutSubviews)
	|            {
	|                superView.LayoutSubviews();
	|            }
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            if (!Visible)
	|            {
	|                return;
	|            }
	|
	|            if (!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded)
	|            {
	|                Driver.SetAttribute(GetNormalColor());
	|
	|                // This is the Application.Top. Clear just the region we're being asked to redraw 
	|                // (the bounds passed to us).
	|                Clear();
	|                Driver.SetAttribute(Enabled ? Colors.Base.Normal : Colors.Base.Disabled);
	|
	|                LayoutSubviews();
	|                PositionToplevels();
	|
	|                if (this == Application.MdiTop)
	|                {
	|                    foreach (var top in Application.MdiChildes.AsEnumerable().Reverse())
	|                    {
	|                        if (top.Frame.IntersectsWith(bounds))
	|                        {
	|                            if (top != this && !top.IsCurrentTop && !OutsideTopFrame(top) && top.Visible)
	|                            {
	|                                top.SetNeedsLayout();
	|                                top.SetNeedsDisplay(top.Bounds);
	|                                top.Redraw(top.Bounds);
	|                            }
	|                        }
	|                    }
	|                }
	|
	|                foreach (var view in Subviews)
	|                {
	|                    if (view.Frame.IntersectsWith(bounds) && !OutsideTopFrame(this))
	|                    {
	|                        view.SetNeedsLayout();
	|                        view.SetNeedsDisplay(view.Bounds);
	|                        //view.Redraw (view.Bounds);
	|                    }
	|                }
	|
	|                ClearLayoutNeeded();
	|                ClearNeedsDisplay();
	|            }
	|
	|            base.Redraw(Bounds);
	|        }
	|
	|        internal bool OutsideTopFrame(Toplevel top)
	|        {
	|            if (top.Frame.X > Driver.Cols || top.Frame.Y > Driver.Rows)
	|            {
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        internal static Point? dragPosition;
	|        Point start;
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent mouseEvent)
	|        {
	|            if (!CanFocus)
	|            {
	|                return true;
	|            }
	|
	|            //System.Diagnostics.Debug.WriteLine ($""dragPosition before: {dragPosition.HasValue}"");
	|
	|            int nx, ny;
	|            if (!dragPosition.HasValue && (mouseEvent.Flags == MouseFlags.Button1Pressed
	|                || mouseEvent.Flags == MouseFlags.Button2Pressed
	|                || mouseEvent.Flags == MouseFlags.Button3Pressed))
	|            {
	|
	|                SetFocus();
	|                Application.EnsuresTopOnFront();
	|
	|                // Only start grabbing if the user clicks on the title bar.
	|                if (mouseEvent.Y == 0 && mouseEvent.Flags == MouseFlags.Button1Pressed)
	|                {
	|                    start = new Point(mouseEvent.X, mouseEvent.Y);
	|                    Application.GrabMouse(this);
	|                    nx = mouseEvent.X - mouseEvent.OfX;
	|                    ny = mouseEvent.Y - mouseEvent.OfY;
	|                    dragPosition = new Point(nx, ny);
	|                }
	|
	|                //System.Diagnostics.Debug.WriteLine ($""Starting at {dragPosition}"");
	|                return true;
	|            }
	|            else if (mouseEvent.Flags == (MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) ||
	|              mouseEvent.Flags == MouseFlags.Button3Pressed)
	|            {
	|                if (dragPosition.HasValue)
	|                {
	|                    if (SuperView == null)
	|                    {
	|                        // Redraw the entire app window using just our Frame. Since we are 
	|                        // Application.Top, and our Frame always == our Bounds (Location is always (0,0))
	|                        // our Frame is actually view-relative (which is what Redraw takes).
	|                        // We need to pass all the view bounds because since the windows was 
	|                        // moved around, we don't know exactly what was the affected region.
	|                        Application.Top.SetNeedsDisplay();
	|                    }
	|                    else
	|                    {
	|                        SuperView.SetNeedsDisplay();
	|                    }
	|                    EnsureVisibleBounds(this, mouseEvent.X + (SuperView == null ? mouseEvent.OfX - start.X : Frame.X - start.X),
	|                        mouseEvent.Y + (SuperView == null ? mouseEvent.OfY - start.Y : Frame.Y - start.Y),
	|                        out nx, out ny, out _, out _);
	|
	|                    dragPosition = new Point(nx, ny);
	|                    X = nx;
	|                    Y = ny;
	|                    //System.Diagnostics.Debug.WriteLine ($""Drag: nx:{nx},ny:{ny}"");
	|
	|                    SetNeedsDisplay();
	|                    return true;
	|                }
	|            }
	|
	|            if (mouseEvent.Flags.HasFlag(MouseFlags.Button1Released) && dragPosition.HasValue)
	|            {
	|                dragPosition = null;
	|                Application.UngrabMouse();
	|            }
	|
	|            //System.Diagnostics.Debug.WriteLine ($""dragPosition after: {dragPosition.HasValue}"");
	|            //System.Diagnostics.Debug.WriteLine ($""Toplevel: {mouseEvent}"");
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Invoked by <see cref=""Application.Begin""/> as part of  <see cref=""Application.Run(Toplevel, Func{Exception, bool})""/> 
	|        /// after the views have been laid out, and before the views are drawn for the first time.
	|        /// </summary>
	|        public virtual void WillPresent()
	|        {
	|            FocusFirst();
	|        }
	|
	|        /// <summary>
	|        /// Move to the next Mdi child from the <see cref=""Application.MdiTop""/>.
	|        /// </summary>
	|        public virtual void MoveNext()
	|        {
	|            Application.MoveNext();
	|        }
	|
	|        /// <summary>
	|        /// Move to the previous Mdi child from the <see cref=""Application.MdiTop""/>.
	|        /// </summary>
	|        public virtual void MovePrevious()
	|        {
	|            Application.MovePrevious();
	|        }
	|
	|        /// <summary>
	|        /// Stops and closes this <see cref=""Toplevel""/>. If this Toplevel is the top-most Toplevel, 
	|        /// <see cref=""Application.RequestStop(Toplevel)""/> will be called, causing the application to exit.
	|        /// </summary>
	|        public virtual void RequestStop()
	|        {
	|            if (IsMdiContainer && Running
	|                && (Application.Current == this
	|                || Application.Current?.Modal == false
	|                || Application.Current?.Modal == true && Application.Current?.Running == false))
	|            {
	|
	|                foreach (var child in Application.MdiChildes)
	|                {
	|                    var ev = new ToplevelClosingEventArgs(this);
	|                    if (child.OnClosing(ev))
	|                    {
	|                        return;
	|                    }
	|                    child.Running = false;
	|                    Application.RequestStop(child);
	|                }
	|                Running = false;
	|                Application.RequestStop(this);
	|            }
	|            else if (IsMdiContainer && Running && Application.Current?.Modal == true && Application.Current?.Running == true)
	|            {
	|                var ev = new ToplevelClosingEventArgs(Application.Current);
	|                if (OnClosing(ev))
	|                {
	|                    return;
	|                }
	|                Application.RequestStop(Application.Current);
	|            }
	|            else if (!IsMdiContainer && Running && (!Modal || (Modal && Application.Current != this)))
	|            {
	|                var ev = new ToplevelClosingEventArgs(this);
	|                if (OnClosing(ev))
	|                {
	|                    return;
	|                }
	|                Running = false;
	|                Application.RequestStop(this);
	|            }
	|            else
	|            {
	|                Application.RequestStop(Application.Current);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Stops and closes the <see cref=""Toplevel""/> specified by <paramref name=""top""/>. If <paramref name=""top""/> is the top-most Toplevel, 
	|        /// <see cref=""Application.RequestStop(Toplevel)""/> will be called, causing the application to exit.
	|        /// </summary>
	|        /// <param name=""top"">The toplevel to request stop.</param>
	|        public virtual void RequestStop(Toplevel top)
	|        {
	|            top.RequestStop();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void PositionCursor()
	|        {
	|            if (!IsMdiContainer)
	|            {
	|                base.PositionCursor();
	|                if (Focused == null)
	|                {
	|                    EnsureFocus();
	|                    if (Focused == null)
	|                    {
	|                        Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|                    }
	|                }
	|                return;
	|            }
	|
	|            if (Focused == null)
	|            {
	|                foreach (var top in Application.MdiChildes)
	|                {
	|                    if (top != this && top.Visible)
	|                    {
	|                        top.SetFocus();
	|                        return;
	|                    }
	|                }
	|            }
	|            base.PositionCursor();
	|            if (Focused == null)
	|            {
	|                Driver.SetCursorVisibility(CursorVisibility.Invisible);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the current visible Toplevel Mdi child that matches the arguments pattern.
	|        /// </summary>
	|        /// <param name=""type"">The type.</param>
	|        /// <param name=""exclude"">The strings to exclude.</param>
	|        /// <returns>The matched view.</returns>
	|        public View GetTopMdiChild(Type type = null, string[] exclude = null)
	|        {
	|            if (Application.MdiTop == null)
	|            {
	|                return null;
	|            }
	|
	|            foreach (var top in Application.MdiChildes)
	|            {
	|                if (type != null && top.GetType() == type
	|                    && exclude?.Contains(top.Data.ToString()) == false)
	|                {
	|                    return top;
	|                }
	|                else if ((type != null && top.GetType() != type)
	|                  || (exclude?.Contains(top.Data.ToString()) == true))
	|                {
	|                    continue;
	|                }
	|                return top;
	|            }
	|            return null;
	|        }
	|
	|        /// <summary>
	|        /// Shows the Mdi child indicated by <paramref name=""top""/>, setting it as <see cref=""Application.Current""/>.
	|        /// </summary>
	|        /// <param name=""top"">The Toplevel.</param>
	|        /// <returns><c>true</c> if the toplevel can be shown or <c>false</c> if not.</returns>
	|        public virtual bool ShowChild(Toplevel top = null)
	|        {
	|            if (Application.MdiTop != null)
	|            {
	|                return Application.ShowChild(top == null ? this : top);
	|            }
	|            return false;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            return MostFocused?.OnEnter(view) ?? base.OnEnter(view);
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnLeave(View view)
	|        {
	|            return MostFocused?.OnLeave(view) ?? base.OnLeave(view);
	|        }
	|
	|        ///<inheritdoc/>
	|        protected override void Dispose(bool disposing)
	|        {
	|            Application.GrabbingMouse -= Application_GrabbingMouse;
	|            Application.UnGrabbingMouse -= Application_UnGrabbingMouse;
	|
	|            dragPosition = null;
	|            base.Dispose(disposing);
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Implements the <see cref=""IEqualityComparer{T}""/> for comparing two <see cref=""Toplevel""/>s
	|    /// used by <see cref=""StackExtensions""/>.
	|    /// </summary>
	|    public class ToplevelEqualityComparer : IEqualityComparer<Toplevel>
	|    {
	|        /// <summary>Determines whether the specified objects are equal.</summary>
	|        /// <param name=""x"">The first object of type <see cref=""Toplevel"" /> to compare.</param>
	|        /// <param name=""y"">The second object of type <see cref=""Toplevel"" /> to compare.</param>
	|        /// <returns>
	|        ///     <see langword=""true"" /> if the specified objects are equal; otherwise, <see langword=""false"" />.</returns>
	|        public bool Equals(Toplevel x, Toplevel y)
	|        {
	|            if (y == null && x == null)
	|                return true;
	|            else if (x == null || y == null)
	|                return false;
	|            else if (x.Id == y.Id)
	|                return true;
	|            else
	|                return false;
	|        }
	|
	|        /// <summary>Returns a hash code for the specified object.</summary>
	|        /// <param name=""obj"">The <see cref=""Toplevel"" /> for which a hash code is to be returned.</param>
	|        /// <returns>A hash code for the specified object.</returns>
	|        /// <exception cref=""ArgumentNullException"">The type of <paramref name=""obj"" /> 
	|        /// is a reference type and <paramref name=""obj"" /> is <see langword=""null"" />.</exception>
	|        public int GetHashCode(Toplevel obj)
	|        {
	|            if (obj == null)
	|                throw new ArgumentNullException();
	|
	|            int hCode = 0;
	|            if (int.TryParse(obj.Id.ToString(), out int result))
	|            {
	|                hCode = result;
	|            }
	|            return hCode.GetHashCode();
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Implements the <see cref=""IComparer{T}""/> to sort the <see cref=""Toplevel""/> 
	|    /// from the <see cref=""Application.MdiChildes""/> if needed.
	|    /// </summary>
	|    public sealed class ToplevelComparer : IComparer<Toplevel>
	|    {
	|        /// <summary>Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.</summary>
	|        /// <param name=""x"">The first object to compare.</param>
	|        /// <param name=""y"">The second object to compare.</param>
	|        /// <returns>A signed integer that indicates the relative values of <paramref name=""x"" /> and <paramref name=""y"" />, as shown in the following table.Value Meaning Less than zero
	|        ///             <paramref name=""x"" /> is less than <paramref name=""y"" />.Zero
	|        ///             <paramref name=""x"" /> equals <paramref name=""y"" />.Greater than zero
	|        ///             <paramref name=""x"" /> is greater than <paramref name=""y"" />.</returns>
	|        public int Compare(Toplevel x, Toplevel y)
	|        {
	|            if (ReferenceEquals(x, y))
	|                return 0;
	|            else if (x == null)
	|                return -1;
	|            else if (y == null)
	|                return 1;
	|            else
	|                return string.Compare(x.Id.ToString(), y.Id.ToString());
	|        }
	|    }
	|    /// <summary>
	|    /// <see cref=""EventArgs""/> implementation for the <see cref=""Toplevel.Closing""/> event.
	|    /// </summary>
	|    public class ToplevelClosingEventArgs : EventArgs
	|    {
	|        /// <summary>
	|        /// The toplevel requesting stop.
	|        /// </summary>
	|        public View RequestingTop { get; }
	|        /// <summary>
	|        /// Provides an event cancellation option.
	|        /// </summary>
	|        public bool Cancel { get; set; }
	|
	|        /// <summary>
	|        /// Initializes the event arguments with the requesting toplevel.
	|        /// </summary>
	|        /// <param name=""requestingTop"">The <see cref=""RequestingTop""/>.</param>
	|        public ToplevelClosingEventArgs(Toplevel requestingTop)
	|        {
	|            RequestingTop = requestingTop;
	|        }
	|    }
	|    //=======================================================================
	|    // This code is based on http://objectlistview.sourceforge.net (GPLv3 tree/list controls 
	|    // by phillip.piper@gmail.com). Phillip has explicitly granted permission for his design
	|    // and code to be used in this library under the MIT license.
	|
	|    /// <summary>
	|    /// Interface for all non generic members of <see cref=""TreeView{T}""/>.
	|    /// 
	|    /// <a href=""https://gui-cs.github.io/Terminal.Gui/articles/treeview.html"">See TreeView Deep Dive for more information</a>.
	|    /// </summary>
	|    public interface ITreeView
	|    {
	|        /// <summary>
	|        /// Contains options for changing how the tree is rendered.
	|        /// </summary>
	|        TreeStyle Style { get; set; }
	|
	|        /// <summary>
	|        /// Removes all objects from the tree and clears selection.
	|        /// </summary>
	|        void ClearObjects();
	|
	|        /// <summary>
	|        /// Sets a flag indicating this view needs to be redisplayed because its state has changed.
	|        /// </summary>
	|        void SetNeedsDisplay();
	|    }
	|
	|    /// <summary>
	|    /// Convenience implementation of generic <see cref=""TreeView{T}""/> for any tree were all nodes
	|    /// implement <see cref=""ITreeNode""/>.
	|    /// 
	|    /// <a href=""https://gui-cs.github.io/Terminal.Gui/articles/treeview.html"">See TreeView Deep Dive for more information</a>.
	|    /// </summary>
	|    public class TreeView : TreeView<ITreeNode>
	|    {
	|
	|        /// <summary>
	|        /// Creates a new instance of the tree control with absolute positioning and initialises
	|        /// <see cref=""TreeBuilder{T}""/> with default <see cref=""ITreeNode""/> based builder.
	|        /// </summary>
	|        public TreeView()
	|        {
	|            TreeBuilder = new TreeNodeBuilder();
	|            AspectGetter = o => o == null ? ""Null"" : (o.Text ?? o?.ToString() ?? ""Unamed Node"");
	|        }
	|    }
	|
	|    /// <summary>
	|    /// Hierarchical tree view with expandable branches. Branch objects are dynamically determined
	|    /// when expanded using a user defined <see cref=""ITreeBuilder{T}""/>.
	|    /// 
	|    /// <a href=""https://gui-cs.github.io/Terminal.Gui/articles/treeview.html"">See TreeView Deep Dive for more information</a>.
	|    /// </summary>
	|    public class TreeView<T> : View, ITreeView where T : class
	|    {
	|        private int scrollOffsetVertical;
	|        private int scrollOffsetHorizontal;
	|
	|        /// <summary>
	|        /// Determines how sub branches of the tree are dynamically built at runtime as the user
	|        /// expands root nodes.
	|        /// </summary>
	|        /// <value></value>
	|        public ITreeBuilder<T> TreeBuilder { get; set; }
	|
	|        /// <summary>
	|        /// private variable for <see cref=""SelectedObject""/>
	|        /// </summary>
	|        T selectedObject;
	|
	|        /// <summary>
	|        /// Contains options for changing how the tree is rendered.
	|        /// </summary>
	|        public TreeStyle Style { get; set; } = new TreeStyle();
	|
	|        /// <summary>
	|        /// True to allow multiple objects to be selected at once.
	|        /// </summary>
	|        /// <value></value>
	|        public bool MultiSelect { get; set; } = true;
	|
	|        /// <summary>
	|        /// Maximum number of nodes that can be expanded in any given branch.
	|        /// </summary>
	|        public int MaxDepth { get; set; } = 100;
	|
	|        /// <summary>
	|        /// True makes a letter key press navigate to the next visible branch that begins with
	|        /// that letter/digit.
	|        /// </summary>
	|        /// <value></value>
	|        public bool AllowLetterBasedNavigation { get; set; } = true;
	|
	|        /// <summary>
	|        /// The currently selected object in the tree. When <see cref=""MultiSelect""/> is true this
	|        /// is the object at which the cursor is at.
	|        /// </summary>
	|        public T SelectedObject
	|        {
	|            get => selectedObject;
	|            set
	|            {
	|                var oldValue = selectedObject;
	|                selectedObject = value;
	|
	|                if (!ReferenceEquals(oldValue, value))
	|                {
	|                    OnSelectionChanged(new SelectionChangedEventArgs<T>(this, oldValue, value));
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This event is raised when an object is activated e.g. by double clicking or 
	|        /// pressing <see cref=""ObjectActivationKey""/>.
	|        /// </summary>
	|        public event Action<ObjectActivatedEventArgs<T>> ObjectActivated;
	|
	|        /// <summary>
	|        /// Key which when pressed triggers <see cref=""TreeView{T}.ObjectActivated""/>.
	|        /// Defaults to Enter.
	|        /// </summary>
	|        public Key ObjectActivationKey
	|        {
	|            get => objectActivationKey;
	|            set
	|            {
	|                if (objectActivationKey != value)
	|                {
	|                    ReplaceKeyBinding(ObjectActivationKey, value);
	|                    objectActivationKey = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Mouse event to trigger <see cref=""TreeView{T}.ObjectActivated""/>.
	|        /// Defaults to double click (<see cref=""MouseFlags.Button1DoubleClicked""/>).
	|        /// Set to null to disable this feature.
	|        /// </summary>
	|        /// <value></value>
	|        public MouseFlags? ObjectActivationButton { get; set; } = MouseFlags.Button1DoubleClicked;
	|
	|        /// <summary>
	|        /// Delegate for multi colored tree views. Return the <see cref=""ColorScheme""/> to use
	|        /// for each passed object or null to use the default.
	|        /// </summary>
	|        public Func<T, ColorScheme> ColorGetter { get; set; }
	|
	|        /// <summary>
	|        /// Secondary selected regions of tree when <see cref=""MultiSelect""/> is true.
	|        /// </summary>
	|        private Stack<TreeSelection<T>> multiSelectedRegions = new Stack<TreeSelection<T>>();
	|
	|        /// <summary>
	|        /// Cached result of <see cref=""BuildLineMap""/>
	|        /// </summary>
	|        private IReadOnlyCollection<Branch<T>> cachedLineMap;
	|
	|        /// <summary>
	|        /// Error message to display when the control is not properly initialized at draw time 
	|        /// (nodes added but no tree builder set).
	|        /// </summary>
	|        public static ustring NoBuilderError = ""ERROR: TreeBuilder Not Set"";
	|        private Key objectActivationKey = Key.Enter;
	|
	|        /// <summary>
	|        /// Called when the <see cref=""SelectedObject""/> changes.
	|        /// </summary>
	|        public event EventHandler<SelectionChangedEventArgs<T>> SelectionChanged;
	|
	|        /// <summary>
	|        /// The root objects in the tree, note that this collection is of root objects only.
	|        /// </summary>
	|        public IEnumerable<T> Objects { get => roots.Keys; }
	|
	|        /// <summary>
	|        /// Map of root objects to the branches under them. All objects have 
	|        /// a <see cref=""Branch{T}""/> even if that branch has no children.
	|        /// </summary>
	|        internal Dictionary<T, Branch<T>> roots { get; set; } = new Dictionary<T, Branch<T>>();
	|
	|        /// <summary>
	|        /// The amount of tree view that has been scrolled off the top of the screen (by the user 
	|        /// scrolling down).
	|        /// </summary>
	|        /// <remarks>Setting a value of less than 0 will result in a offset of 0. To see changes 
	|        /// in the UI call <see cref=""View.SetNeedsDisplay()""/>.</remarks>
	|        public int ScrollOffsetVertical
	|        {
	|            get => scrollOffsetVertical;
	|            set
	|            {
	|                scrollOffsetVertical = Math.Max(0, value);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The amount of tree view that has been scrolled to the right (horizontally).
	|        /// </summary>
	|        /// <remarks>Setting a value of less than 0 will result in a offset of 0. To see changes 
	|        /// in the UI call <see cref=""View.SetNeedsDisplay()""/>.</remarks>
	|        public int ScrollOffsetHorizontal
	|        {
	|            get => scrollOffsetHorizontal;
	|            set
	|            {
	|                scrollOffsetHorizontal = Math.Max(0, value);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The current number of rows in the tree (ignoring the controls bounds).
	|        /// </summary>
	|        public int ContentHeight => BuildLineMap().Count();
	|
	|        /// <summary>
	|        /// Returns the string representation of model objects hosted in the tree. Default 
	|        /// implementation is to call <see cref=""object.ToString""/>.
	|        /// </summary>
	|        /// <value></value>
	|        public AspectGetterDelegate<T> AspectGetter { get; set; } = (o) => o.ToString() ?? """";
	|
	|        CursorVisibility desiredCursorVisibility = CursorVisibility.Invisible;
	|
	|        /// <summary>
	|        /// Interface for filtering which lines of the tree are displayed
	|        ///  e.g. to provide text searching.  Defaults to <see langword=""null""/>
	|        /// (no filtering).
	|        /// </summary>
	|        public ITreeViewFilter<T> Filter = null;
	|
	|        /// <summary>
	|        /// Get / Set the wished cursor when the tree is focused.
	|        /// Only applies when <see cref=""MultiSelect""/> is true.
	|        /// Defaults to <see cref=""CursorVisibility.Invisible""/>.
	|        /// </summary>
	|        public CursorVisibility DesiredCursorVisibility
	|        {
	|            get
	|            {
	|                return MultiSelect ? desiredCursorVisibility : CursorVisibility.Invisible;
	|            }
	|            set
	|            {
	|                if (desiredCursorVisibility != value)
	|                {
	|                    desiredCursorVisibility = value;
	|                    if (HasFocus)
	|                    {
	|                        Application.Driver.SetCursorVisibility(DesiredCursorVisibility);
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Creates a new tree view with absolute positioning. 
	|        /// Use <see cref=""AddObjects(IEnumerable{T})""/> to set set root objects for the tree.
	|        /// Children will not be rendered until you set <see cref=""TreeBuilder""/>.
	|        /// </summary>
	|        public TreeView() : base()
	|        {
	|            CanFocus = true;
	|
	|            // Things this view knows how to do
	|            AddCommand(Command.PageUp, () => { MovePageUp(false); return true; });
	|            AddCommand(Command.PageDown, () => { MovePageDown(false); return true; });
	|            AddCommand(Command.PageUpExtend, () => { MovePageUp(true); return true; });
	|            AddCommand(Command.PageDownExtend, () => { MovePageDown(true); return true; });
	|            AddCommand(Command.Expand, () => { Expand(); return true; });
	|            AddCommand(Command.ExpandAll, () => { ExpandAll(SelectedObject); return true; });
	|            AddCommand(Command.Collapse, () => { CursorLeft(false); return true; });
	|            AddCommand(Command.CollapseAll, () => { CursorLeft(true); return true; });
	|            AddCommand(Command.LineUp, () => { AdjustSelection(-1, false); return true; });
	|            AddCommand(Command.LineUpExtend, () => { AdjustSelection(-1, true); return true; });
	|            AddCommand(Command.LineUpToFirstBranch, () => { AdjustSelectionToBranchStart(); return true; });
	|
	|            AddCommand(Command.LineDown, () => { AdjustSelection(1, false); return true; });
	|            AddCommand(Command.LineDownExtend, () => { AdjustSelection(1, true); return true; });
	|            AddCommand(Command.LineDownToLastBranch, () => { AdjustSelectionToBranchEnd(); return true; });
	|
	|            AddCommand(Command.TopHome, () => { GoToFirst(); return true; });
	|            AddCommand(Command.BottomEnd, () => { GoToEnd(); return true; });
	|            AddCommand(Command.SelectAll, () => { SelectAll(); return true; });
	|
	|            AddCommand(Command.ScrollUp, () => { ScrollUp(); return true; });
	|            AddCommand(Command.ScrollDown, () => { ScrollDown(); return true; });
	|            AddCommand(Command.Accept, () => { ActivateSelectedObjectIfAny(); return true; });
	|
	|            // Default keybindings for this view
	|            AddKeyBinding(Key.PageUp, Command.PageUp);
	|            AddKeyBinding(Key.PageDown, Command.PageDown);
	|            AddKeyBinding(Key.PageUp | Key.ShiftMask, Command.PageUpExtend);
	|            AddKeyBinding(Key.PageDown | Key.ShiftMask, Command.PageDownExtend);
	|            AddKeyBinding(Key.CursorRight, Command.Expand);
	|            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.ExpandAll);
	|            AddKeyBinding(Key.CursorLeft, Command.Collapse);
	|            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.CollapseAll);
	|
	|            AddKeyBinding(Key.CursorUp, Command.LineUp);
	|            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LineUpExtend);
	|            AddKeyBinding(Key.CursorUp | Key.CtrlMask, Command.LineUpToFirstBranch);
	|
	|            AddKeyBinding(Key.CursorDown, Command.LineDown);
	|            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.LineDownExtend);
	|            AddKeyBinding(Key.CursorDown | Key.CtrlMask, Command.LineDownToLastBranch);
	|
	|            AddKeyBinding(Key.Home, Command.TopHome);
	|            AddKeyBinding(Key.End, Command.BottomEnd);
	|            AddKeyBinding(Key.A | Key.CtrlMask, Command.SelectAll);
	|            AddKeyBinding(ObjectActivationKey, Command.Accept);
	|        }
	|
	|        /// <summary>
	|        /// Initialises <see cref=""TreeBuilder""/>.Creates a new tree view with absolute 
	|        /// positioning. Use <see cref=""AddObjects(IEnumerable{T})""/> to set set root 
	|        /// objects for the tree.
	|        /// </summary>
	|        public TreeView(ITreeBuilder<T> builder) : this()
	|        {
	|            TreeBuilder = builder;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);
	|
	|            return base.OnEnter(view);
	|        }
	|
	|        /// <summary>
	|        /// Adds a new root level object unless it is already a root of the tree.
	|        /// </summary>
	|        /// <param name=""o""></param>
	|        public void AddObject(T o)
	|        {
	|            if (!roots.ContainsKey(o))
	|            {
	|                roots.Add(o, new Branch<T>(this, null, o));
	|                InvalidateLineMap();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Removes all objects from the tree and clears <see cref=""SelectedObject""/>.
	|        /// </summary>
	|        public void ClearObjects()
	|        {
	|            SelectedObject = default(T);
	|            multiSelectedRegions.Clear();
	|            roots = new Dictionary<T, Branch<T>>();
	|            InvalidateLineMap();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Removes the given root object from the tree
	|        /// </summary>
	|        /// <remarks>If <paramref name=""o""/> is the currently <see cref=""SelectedObject""/> then the
	|        /// selection is cleared</remarks>.
	|        /// <param name=""o""></param>
	|        public void Remove(T o)
	|        {
	|            if (roots.ContainsKey(o))
	|            {
	|                roots.Remove(o);
	|                InvalidateLineMap();
	|                SetNeedsDisplay();
	|
	|                if (Equals(SelectedObject, o))
	|                {
	|                    SelectedObject = default(T);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Adds many new root level objects. Objects that are already root objects are ignored.
	|        /// </summary>
	|        /// <param name=""collection"">Objects to add as new root level objects.</param>.\
	|        public void AddObjects(IEnumerable<T> collection)
	|        {
	|            bool objectsAdded = false;
	|
	|            foreach (var o in collection)
	|            {
	|                if (!roots.ContainsKey(o))
	|                {
	|                    roots.Add(o, new Branch<T>(this, null, o));
	|                    objectsAdded = true;
	|                }
	|            }
	|
	|            if (objectsAdded)
	|            {
	|                InvalidateLineMap();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Refreshes the state of the object <paramref name=""o""/> in the tree. This will 
	|        /// recompute children, string representation etc.
	|        /// </summary>
	|        /// <remarks>This has no effect if the object is not exposed in the tree.</remarks>
	|        /// <param name=""o""></param>
	|        /// <param name=""startAtTop"">True to also refresh all ancestors of the objects branch 
	|        /// (starting with the root). False to refresh only the passed node.</param>
	|        public void RefreshObject(T o, bool startAtTop = false)
	|        {
	|            var branch = ObjectToBranch(o);
	|            if (branch != null)
	|            {
	|                branch.Refresh(startAtTop);
	|                InvalidateLineMap();
	|                SetNeedsDisplay();
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Rebuilds the tree structure for all exposed objects starting with the root objects.
	|        /// Call this method when you know there are changes to the tree but don't know which 
	|        /// objects have changed (otherwise use <see cref=""RefreshObject(T, bool)""/>).
	|        /// </summary>
	|        public void RebuildTree()
	|        {
	|            foreach (var branch in roots.Values)
	|            {
	|                branch.Rebuild();
	|            }
	|
	|            InvalidateLineMap();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Returns the currently expanded children of the passed object. Returns an empty
	|        /// collection if the branch is not exposed or not expanded.
	|        /// </summary>
	|        /// <param name=""o"">An object in the tree.</param>
	|        /// <returns></returns>
	|        public IEnumerable<T> GetChildren(T o)
	|        {
	|            var branch = ObjectToBranch(o);
	|
	|            if (branch == null || !branch.IsExpanded)
	|            {
	|                return new T[0];
	|            }
	|
	|            return branch.ChildBranches?.Values?.Select(b => b.Model)?.ToArray() ?? new T[0];
	|        }
	|        /// <summary>
	|        /// Returns the parent object of <paramref name=""o""/> in the tree. Returns null if 
	|        /// the object is not exposed in the tree.
	|        /// </summary>
	|        /// <param name=""o"">An object in the tree.</param>
	|        /// <returns></returns>
	|        public T GetParent(T o)
	|        {
	|            return ObjectToBranch(o)?.Parent?.Model;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            if (roots == null)
	|            {
	|                return;
	|            }
	|
	|            if (TreeBuilder == null)
	|            {
	|                Move(0, 0);
	|                Driver.AddStr(NoBuilderError);
	|                return;
	|            }
	|
	|            var map = BuildLineMap();
	|
	|            for (int line = 0; line < bounds.Height; line++)
	|            {
	|
	|                var idxToRender = ScrollOffsetVertical + line;
	|
	|                // Is there part of the tree view to render?
	|                if (idxToRender < map.Count)
	|                {
	|                    // Render the line
	|                    map.ElementAt(idxToRender).Draw(Driver, ColorScheme, line, bounds.Width);
	|                }
	|                else
	|                {
	|
	|                    // Else clear the line to prevent stale symbols due to scrolling etc
	|                    Move(0, line);
	|                    Driver.SetAttribute(GetNormalColor());
	|                    Driver.AddStr(new string(' ', bounds.Width));
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the index of the object <paramref name=""o""/> if it is currently exposed (it's 
	|        /// parent(s) have been expanded). This can be used with <see cref=""ScrollOffsetVertical""/>
	|        /// and <see cref=""View.SetNeedsDisplay()""/> to scroll to a specific object.
	|        /// </summary>
	|        /// <remarks>Uses the Equals method and returns the first index at which the object is found
	|        /// or -1 if it is not found.</remarks>
	|        /// <param name=""o"">An object that appears in your tree and is currently exposed.</param>
	|        /// <returns>The index the object was found at or -1 if it is not currently revealed or
	|        /// not in the tree at all.</returns>
	|        public int GetScrollOffsetOf(T o)
	|        {
	|            var map = BuildLineMap();
	|            for (int i = 0; i < map.Count; i++)
	|            {
	|                if (map.ElementAt(i).Model.Equals(o))
	|                {
	|                    return i;
	|                }
	|            }
	|
	|            //object not found
	|            return -1;
	|        }
	|
	|        /// <summary>
	|        /// Returns the maximum width line in the tree including prefix and expansion symbols.
	|        /// </summary>
	|        /// <param name=""visible"">True to consider only rows currently visible (based on window
	|        /// bounds and <see cref=""ScrollOffsetVertical""/>. False to calculate the width of 
	|        /// every exposed branch in the tree.</param>
	|        /// <returns></returns>
	|        public int GetContentWidth(bool visible)
	|        {
	|            var map = BuildLineMap();
	|
	|            if (map.Count == 0)
	|            {
	|                return 0;
	|            }
	|
	|            if (visible)
	|            {
	|
	|                //Somehow we managed to scroll off the end of the control
	|                if (ScrollOffsetVertical >= map.Count)
	|                {
	|                    return 0;
	|                }
	|
	|                // If control has no height to it then there is no visible area for content
	|                if (Bounds.Height == 0)
	|                {
	|                    return 0;
	|                }
	|
	|                return map.Skip(ScrollOffsetVertical).Take(Bounds.Height).Max(b => b.GetWidth(Driver));
	|            }
	|            else
	|            {
	|
	|                return map.Max(b => b.GetWidth(Driver));
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Calculates all currently visible/expanded branches (including leafs) and outputs them 
	|        /// by index from the top of the screen.
	|        /// </summary>
	|        /// <remarks>Index 0 of the returned array is the first item that should be visible in the
	|        /// top of the control, index 1 is the next etc.</remarks>
	|        /// <returns></returns>
	|        private IReadOnlyCollection<Branch<T>> BuildLineMap()
	|        {
	|            if (cachedLineMap != null)
	|            {
	|                return cachedLineMap;
	|            }
	|
	|            List<Branch<T>> toReturn = new List<Branch<T>>();
	|
	|            foreach (var root in roots.Values)
	|            {
	|
	|                var toAdd = AddToLineMap(root, false, out var isMatch);
	|                if (isMatch)
	|                {
	|                    toReturn.AddRange(toAdd);
	|                }
	|            }
	|
	|            cachedLineMap = new ReadOnlyCollection<Branch<T>>(toReturn);
	|
	|            // Update the collection used for search-typing
	|            KeystrokeNavigator.Collection = cachedLineMap.Select(b => AspectGetter(b.Model)).ToArray();
	|            return cachedLineMap;
	|        }
	|
	|        private bool IsFilterMatch(Branch<T> branch)
	|        {
	|            return Filter?.IsMatch(branch.Model) ?? true;
	|        }
	|
	|        private IEnumerable<Branch<T>> AddToLineMap(Branch<T> currentBranch, bool parentMatches, out bool match)
	|        {
	|            bool weMatch = IsFilterMatch(currentBranch);
	|            bool anyChildMatches = false;
	|
	|            var toReturn = new List<Branch<T>>();
	|            var children = new List<Branch<T>>();
	|
	|            if (currentBranch.IsExpanded)
	|            {
	|                foreach (var subBranch in currentBranch.ChildBranches.Values)
	|                {
	|
	|                    foreach (var sub in AddToLineMap(subBranch, weMatch, out var childMatch))
	|                    {
	|
	|                        if (childMatch)
	|                        {
	|                            children.Add(sub);
	|                            anyChildMatches = true;
	|                        }
	|                    }
	|                }
	|            }
	|
	|            if (parentMatches || weMatch || anyChildMatches)
	|            {
	|                match = true;
	|                toReturn.Add(currentBranch);
	|            }
	|            else
	|            {
	|                match = false;
	|            }
	|
	|            toReturn.AddRange(children);
	|            return toReturn;
	|        }
	|
	|        /// <summary>
	|        /// Gets the <see cref=""CollectionNavigator""/> that searches the <see cref=""Objects""/> collection as
	|        /// the user types.
	|        /// </summary>
	|        public CollectionNavigator KeystrokeNavigator { get; private set; } = new CollectionNavigator();
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            try
	|            {
	|                // First of all deal with any registered keybindings
	|                var result = InvokeKeybindings(keyEvent);
	|                if (result != null)
	|                {
	|                    return (bool)result;
	|                }
	|
	|                // If not a keybinding, is the key a searchable key press?
	|                if (CollectionNavigator.IsCompatibleKey(keyEvent) && AllowLetterBasedNavigation)
	|                {
	|                    IReadOnlyCollection<Branch<T>> map;
	|
	|                    // If there has been a call to InvalidateMap since the last time
	|                    // we need a new one to reflect the new exposed tree state
	|                    map = BuildLineMap();
	|
	|                    // Find the current selected object within the tree
	|                    var current = map.IndexOf(b => b.Model == SelectedObject);
	|                    var newIndex = KeystrokeNavigator?.GetNextMatchingItem(current, (char)keyEvent.KeyValue);
	|
	|                    if (newIndex is int && newIndex != -1)
	|                    {
	|                        SelectedObject = map.ElementAt((int)newIndex).Model;
	|                        EnsureVisible(selectedObject);
	|                        SetNeedsDisplay();
	|                        return true;
	|                    }
	|                }
	|            }
	|            finally
	|            {
	|                PositionCursor();
	|            }
	|
	|            return base.ProcessKey(keyEvent);
	|        }
	|
	|
	|        /// <summary>
	|        /// <para>Triggers the <see cref=""ObjectActivated""/> event with the <see cref=""SelectedObject""/>.</para>
	|        /// 
	|        /// <para>This method also ensures that the selected object is visible.</para>
	|        /// </summary>
	|        public void ActivateSelectedObjectIfAny()
	|        {
	|            var o = SelectedObject;
	|
	|            if (o != null)
	|            {
	|                OnObjectActivated(new ObjectActivatedEventArgs<T>(this, o));
	|                PositionCursor();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// <para>
	|        /// Returns the Y coordinate within the <see cref=""View.Bounds""/> of the
	|        /// tree at which <paramref name=""toFind""/> would be displayed or null if
	|        /// it is not currently exposed (e.g. its parent is collapsed).
	|        /// </para>
	|        /// <para>
	|        /// Note that the returned value can be negative if the TreeView is scrolled
	|        /// down and the <paramref name=""toFind""/> object is off the top of the view.
	|        /// </para>
	|        /// </summary>
	|        /// <param name=""toFind""></param>
	|        /// <returns></returns>
	|        public int? GetObjectRow(T toFind)
	|        {
	|            var idx = BuildLineMap().IndexOf(o => o.Model.Equals(toFind));
	|
	|            if (idx == -1)
	|                return null;
	|
	|            return idx - ScrollOffsetVertical;
	|        }
	|
	|        /// <summary>
	|        /// <para>Moves the <see cref=""SelectedObject""/> to the next item that begins with <paramref name=""character""/>.</para>
	|        /// <para>This method will loop back to the start of the tree if reaching the end without finding a match.</para>
	|        /// </summary>
	|        /// <param name=""character"">The first character of the next item you want selected.</param>
	|        /// <param name=""caseSensitivity"">Case sensitivity of the search.</param>
	|        public void AdjustSelectionToNextItemBeginningWith(char character, StringComparison caseSensitivity = StringComparison.CurrentCultureIgnoreCase)
	|        {
	|            // search for next branch that begins with that letter
	|            var characterAsStr = character.ToString();
	|            AdjustSelectionToNext(b => AspectGetter(b.Model).StartsWith(characterAsStr, caseSensitivity));
	|
	|            PositionCursor();
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection up by the height of the control (1 page).
	|        /// </summary>
	|        /// <param name=""expandSelection"">True if the navigation should add the covered nodes to the selected current selection.</param>
	|        /// <exception cref=""NotImplementedException""></exception>
	|        public void MovePageUp(bool expandSelection = false)
	|        {
	|            AdjustSelection(-Bounds.Height, expandSelection);
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection down by the height of the control (1 page).
	|        /// </summary>
	|        /// <param name=""expandSelection"">True if the navigation should add the covered nodes to the selected current selection.</param>
	|        /// <exception cref=""NotImplementedException""></exception>
	|        public void MovePageDown(bool expandSelection = false)
	|        {
	|            AdjustSelection(Bounds.Height, expandSelection);
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view area down a single line without changing the current selection.
	|        /// </summary>
	|        public void ScrollDown()
	|        {
	|            if (ScrollOffsetVertical <= ContentHeight - 2)
	|            {
	|                ScrollOffsetVertical++;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Scrolls the view area up a single line without changing the current selection.
	|        /// </summary>
	|        public void ScrollUp()
	|        {
	|            if (scrollOffsetVertical > 0)
	|            {
	|                ScrollOffsetVertical--;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Raises the <see cref=""ObjectActivated""/> event.
	|        /// </summary>
	|        /// <param name=""e""></param>
	|        protected virtual void OnObjectActivated(ObjectActivatedEventArgs<T> e)
	|        {
	|            ObjectActivated?.Invoke(e);
	|        }
	|
	|        /// <summary>
	|        /// Returns the object in the tree list that is currently visible.
	|        /// at the provided row. Returns null if no object is at that location.
	|        /// <remarks>
	|        /// </remarks>
	|        /// If you have screen coordinates then use <see cref=""View.ScreenToView(int, int)""/>
	|        /// to translate these into the client area of the <see cref=""TreeView{T}""/>.
	|        /// </summary>
	|        /// <param name=""row"">The row of the <see cref=""View.Bounds""/> of the <see cref=""TreeView{T}""/>.</param>
	|        /// <returns>The object currently displayed on this row or null.</returns>
	|        public T GetObjectOnRow(int row)
	|        {
	|            return HitTest(row)?.Model;
	|        }
	|
	|        ///<inheritdoc/>
	|        public override bool MouseEvent(MouseEvent me)
	|        {
	|            // If it is not an event we care about
	|            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) &&
	|                !me.Flags.HasFlag(ObjectActivationButton ?? MouseFlags.Button1DoubleClicked) &&
	|                !me.Flags.HasFlag(MouseFlags.WheeledDown) &&
	|                !me.Flags.HasFlag(MouseFlags.WheeledUp) &&
	|                !me.Flags.HasFlag(MouseFlags.WheeledRight) &&
	|                !me.Flags.HasFlag(MouseFlags.WheeledLeft))
	|            {
	|
	|                // do nothing
	|                return false;
	|            }
	|
	|            if (!HasFocus && CanFocus)
	|            {
	|                SetFocus();
	|            }
	|
	|            if (me.Flags == MouseFlags.WheeledDown)
	|            {
	|
	|                ScrollDown();
	|
	|                return true;
	|            }
	|            else if (me.Flags == MouseFlags.WheeledUp)
	|            {
	|                ScrollUp();
	|
	|                return true;
	|            }
	|
	|            if (me.Flags == MouseFlags.WheeledRight)
	|            {
	|
	|                ScrollOffsetHorizontal++;
	|                SetNeedsDisplay();
	|
	|                return true;
	|            }
	|            else if (me.Flags == MouseFlags.WheeledLeft)
	|            {
	|                ScrollOffsetHorizontal--;
	|                SetNeedsDisplay();
	|
	|                return true;
	|            }
	|
	|            if (me.Flags.HasFlag(MouseFlags.Button1Clicked))
	|            {
	|
	|                // The line they clicked on a branch
	|                var clickedBranch = HitTest(me.Y);
	|
	|                if (clickedBranch == null)
	|                {
	|                    return false;
	|                }
	|
	|                bool isExpandToggleAttempt = clickedBranch.IsHitOnExpandableSymbol(Driver, me.X);
	|
	|                // If we are already selected (double click)
	|                if (Equals(SelectedObject, clickedBranch.Model))
	|                {
	|                    isExpandToggleAttempt = true;
	|                }
	|
	|                // if they clicked on the +/- expansion symbol
	|                if (isExpandToggleAttempt)
	|                {
	|
	|                    if (clickedBranch.IsExpanded)
	|                    {
	|                        clickedBranch.Collapse();
	|                        InvalidateLineMap();
	|                    }
	|                    else
	|                    if (clickedBranch.CanExpand())
	|                    {
	|                        clickedBranch.Expand();
	|                        InvalidateLineMap();
	|                    }
	|                    else
	|                    {
	|                        SelectedObject = clickedBranch.Model; // It is a leaf node
	|                        multiSelectedRegions.Clear();
	|                    }
	|                }
	|                else
	|                {
	|                    // It is a first click somewhere in the current line that doesn't look like an expansion/collapse attempt
	|                    SelectedObject = clickedBranch.Model;
	|                    multiSelectedRegions.Clear();
	|                }
	|
	|                SetNeedsDisplay();
	|                return true;
	|            }
	|
	|            // If it is activation via mouse (e.g. double click)
	|            if (ObjectActivationButton.HasValue && me.Flags.HasFlag(ObjectActivationButton.Value))
	|            {
	|                // The line they clicked on a branch
	|                var clickedBranch = HitTest(me.Y);
	|
	|                if (clickedBranch == null)
	|                {
	|                    return false;
	|                }
	|
	|                // Double click changes the selection to the clicked node as well as triggering
	|                // activation otherwise it feels wierd
	|                SelectedObject = clickedBranch.Model;
	|                SetNeedsDisplay();
	|
	|                // trigger activation event				
	|                OnObjectActivated(new ObjectActivatedEventArgs<T>(this, clickedBranch.Model));
	|
	|                // mouse event is handled.
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Returns the branch at the given <paramref name=""y""/> client
	|        /// coordinate e.g. following a click event.
	|        /// </summary>
	|        /// <param name=""y"">Client Y position in the controls bounds.</param>
	|        /// <returns>The clicked branch or null if outside of tree region.</returns>
	|        private Branch<T> HitTest(int y)
	|        {
	|            var map = BuildLineMap();
	|
	|            var idx = y + ScrollOffsetVertical;
	|
	|            // click is outside any visible nodes
	|            if (idx < 0 || idx >= map.Count)
	|            {
	|                return null;
	|            }
	|
	|            // The line they clicked on
	|            return map.ElementAt(idx);
	|        }
	|
	|        /// <summary>
	|        /// Positions the cursor at the start of the selected objects line (if visible).
	|        /// </summary>
	|        public override void PositionCursor()
	|        {
	|            if (CanFocus && HasFocus && Visible && SelectedObject != null)
	|            {
	|
	|                var map = BuildLineMap();
	|                var idx = map.IndexOf(b => b.Model.Equals(SelectedObject));
	|
	|                // if currently selected line is visible
	|                if (idx - ScrollOffsetVertical >= 0 && idx - ScrollOffsetVertical < Bounds.Height)
	|                {
	|                    Move(0, idx - ScrollOffsetVertical);
	|                }
	|                else
	|                {
	|                    base.PositionCursor();
	|                }
	|
	|            }
	|            else
	|            {
	|                base.PositionCursor();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Determines systems behaviour when the left arrow key is pressed. Default behaviour is
	|        /// to collapse the current tree node if possible otherwise changes selection to current 
	|        /// branches parent.
	|        /// </summary>
	|        protected virtual void CursorLeft(bool ctrl)
	|        {
	|            if (IsExpanded(SelectedObject))
	|            {
	|
	|                if (ctrl)
	|                {
	|                    CollapseAll(SelectedObject);
	|                }
	|                else
	|                {
	|                    Collapse(SelectedObject);
	|                }
	|            }
	|            else
	|            {
	|                var parent = GetParent(SelectedObject);
	|
	|                if (parent != null)
	|                {
	|                    SelectedObject = parent;
	|                    AdjustSelection(0);
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedObject""/> to the first root object and resets 
	|        /// the <see cref=""ScrollOffsetVertical""/> to 0.
	|        /// </summary>
	|        public void GoToFirst()
	|        {
	|            ScrollOffsetVertical = 0;
	|            SelectedObject = roots.Keys.FirstOrDefault();
	|
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedObject""/> to the last object in the tree and scrolls so
	|        /// that it is visible.
	|        /// </summary>
	|        public void GoToEnd()
	|        {
	|            var map = BuildLineMap();
	|            ScrollOffsetVertical = Math.Max(0, map.Count - Bounds.Height + 1);
	|            SelectedObject = map.LastOrDefault()?.Model;
	|
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Changes the <see cref=""SelectedObject""/> to <paramref name=""toSelect""/> and scrolls to ensure
	|        /// it is visible. Has no effect if <paramref name=""toSelect""/> is not exposed in the tree (e.g. 
	|        /// its parents are collapsed).
	|        /// </summary>
	|        /// <param name=""toSelect""></param>
	|        public void GoTo(T toSelect)
	|        {
	|            if (ObjectToBranch(toSelect) == null)
	|            {
	|                return;
	|            }
	|
	|            SelectedObject = toSelect;
	|            EnsureVisible(toSelect);
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// The number of screen lines to move the currently selected object by. Supports negative values.
	|        /// <paramref name=""offset""/>. Each branch occupies 1 line on screen.
	|        /// </summary>
	|        /// <remarks>If nothing is currently selected or the selected object is no longer in the tree
	|        /// then the first object in the tree is selected instead.</remarks>
	|        /// <param name=""offset"">Positive to move the selection down the screen, negative to move it up</param>
	|        /// <param name=""expandSelection"">True to expand the selection (assuming 
	|        /// <see cref=""MultiSelect""/> is enabled). False to replace.</param>
	|        public void AdjustSelection(int offset, bool expandSelection = false)
	|        {
	|            // if it is not a shift click or we don't allow multi select
	|            if (!expandSelection || !MultiSelect)
	|            {
	|                multiSelectedRegions.Clear();
	|            }
	|
	|            if (SelectedObject == null)
	|            {
	|                SelectedObject = roots.Keys.FirstOrDefault();
	|            }
	|            else
	|            {
	|                var map = BuildLineMap();
	|
	|                var idx = map.IndexOf(b => b.Model.Equals(SelectedObject));
	|
	|                if (idx == -1)
	|                {
	|                    // The current selection has disapeared!
	|                    SelectedObject = roots.Keys.FirstOrDefault();
	|                }
	|                else
	|                {
	|                    var newIdx = Math.Min(Math.Max(0, idx + offset), map.Count - 1);
	|
	|                    var newBranch = map.ElementAt(newIdx);
	|
	|                    // If it is a multi selection
	|                    if (expandSelection && MultiSelect)
	|                    {
	|                        if (multiSelectedRegions.Any())
	|                        {
	|                            // expand the existing head selection
	|                            var head = multiSelectedRegions.Pop();
	|                            multiSelectedRegions.Push(new TreeSelection<T>(head.Origin, newIdx, map));
	|                        }
	|                        else
	|                        {
	|                            // or start a new multi selection region
	|                            multiSelectedRegions.Push(new TreeSelection<T>(map.ElementAt(idx), newIdx, map));
	|                        }
	|                    }
	|
	|                    SelectedObject = newBranch.Model;
	|
	|                    EnsureVisible(SelectedObject);
	|                }
	|            }
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection to the first child in the currently selected level.
	|        /// </summary>
	|        public void AdjustSelectionToBranchStart()
	|        {
	|            var o = SelectedObject;
	|            if (o == null)
	|            {
	|                return;
	|            }
	|
	|            var map = BuildLineMap();
	|
	|            int currentIdx = map.IndexOf(b => Equals(b.Model, o));
	|
	|            if (currentIdx == -1)
	|            {
	|                return;
	|            }
	|
	|            var currentBranch = map.ElementAt(currentIdx);
	|            var next = currentBranch;
	|
	|            for (; currentIdx >= 0; currentIdx--)
	|            {
	|                //if it is the beginning of the current depth of branch
	|                if (currentBranch.Depth != next.Depth)
	|                {
	|
	|                    SelectedObject = currentBranch.Model;
	|                    EnsureVisible(currentBranch.Model);
	|                    SetNeedsDisplay();
	|                    return;
	|                }
	|
	|                // look at next branch up for consideration
	|                currentBranch = next;
	|                next = map.ElementAt(currentIdx);
	|            }
	|
	|            // We ran all the way to top of tree
	|            GoToFirst();
	|        }
	|
	|        /// <summary>
	|        /// Moves the selection to the last child in the currently selected level.
	|        /// </summary>
	|        public void AdjustSelectionToBranchEnd()
	|        {
	|            var o = SelectedObject;
	|            if (o == null)
	|            {
	|                return;
	|            }
	|
	|            var map = BuildLineMap();
	|
	|            int currentIdx = map.IndexOf(b => Equals(b.Model, o));
	|
	|            if (currentIdx == -1)
	|            {
	|                return;
	|            }
	|
	|            var currentBranch = map.ElementAt(currentIdx);
	|            var next = currentBranch;
	|
	|            for (; currentIdx < map.Count; currentIdx++)
	|            {
	|                //if it is the end of the current depth of branch
	|                if (currentBranch.Depth != next.Depth)
	|                {
	|
	|                    SelectedObject = currentBranch.Model;
	|                    EnsureVisible(currentBranch.Model);
	|                    SetNeedsDisplay();
	|                    return;
	|                }
	|
	|                // look at next branch for consideration
	|                currentBranch = next;
	|                next = map.ElementAt(currentIdx);
	|            }
	|            GoToEnd();
	|        }
	|
	|
	|        /// <summary>
	|        /// Sets the selection to the next branch that matches the <paramref name=""predicate""/>.
	|        /// </summary>
	|        /// <param name=""predicate""></param>
	|        private void AdjustSelectionToNext(Func<Branch<T>, bool> predicate)
	|        {
	|            var map = BuildLineMap();
	|
	|            // empty map means we can't select anything anyway
	|            if (map.Count == 0)
	|            {
	|                return;
	|            }
	|
	|            // Start searching from the first element in the map
	|            var idxStart = 0;
	|
	|            // or the current selected branch
	|            if (SelectedObject != null)
	|            {
	|                idxStart = map.IndexOf(b => Equals(b.Model, SelectedObject));
	|            }
	|
	|            // if currently selected object mysteriously vanished, search from beginning
	|            if (idxStart == -1)
	|            {
	|                idxStart = 0;
	|            }
	|
	|            // loop around all indexes and back to first index
	|            for (int idxCur = (idxStart + 1) % map.Count; idxCur != idxStart; idxCur = (idxCur + 1) % map.Count)
	|            {
	|                if (predicate(map.ElementAt(idxCur)))
	|                {
	|                    SelectedObject = map.ElementAt(idxCur).Model;
	|                    EnsureVisible(map.ElementAt(idxCur).Model);
	|                    SetNeedsDisplay();
	|                    return;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Adjusts the <see cref=""ScrollOffsetVertical""/> to ensure the given
	|        /// <paramref name=""model""/> is visible. Has no effect if already visible.
	|        /// </summary>
	|        public void EnsureVisible(T model)
	|        {
	|            var map = BuildLineMap();
	|
	|            var idx = map.IndexOf(b => Equals(b.Model, model));
	|
	|            if (idx == -1)
	|            {
	|                return;
	|            }
	|
	|
	|            /*this -1 allows for possible horizontal scroll bar in the last row of the control*/
	|            int leaveSpace = Style.LeaveLastRow ? 1 : 0;
	|
	|            if (idx < ScrollOffsetVertical)
	|            {
	|                //if user has scrolled up too far to see their selection
	|                ScrollOffsetVertical = idx;
	|            }
	|            else if (idx >= ScrollOffsetVertical + Bounds.Height - leaveSpace)
	|            {
	|
	|                //if user has scrolled off bottom of visible tree
	|                ScrollOffsetVertical = Math.Max(0, (idx + 1) - (Bounds.Height - leaveSpace));
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Expands the currently <see cref=""SelectedObject""/>.
	|        /// </summary>
	|        public void Expand()
	|        {
	|            Expand(SelectedObject);
	|        }
	|
	|        /// <summary>
	|        /// Expands the supplied object if it is contained in the tree (either as a root object or 
	|        /// as an exposed branch object).
	|        /// </summary>
	|        /// <param name=""toExpand"">The object to expand.</param>
	|        public void Expand(T toExpand)
	|        {
	|            if (toExpand == null)
	|            {
	|                return;
	|            }
	|
	|            ObjectToBranch(toExpand)?.Expand();
	|            InvalidateLineMap();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Expands the supplied object and all child objects.
	|        /// </summary>
	|        /// <param name=""toExpand"">The object to expand.</param>
	|        public void ExpandAll(T toExpand)
	|        {
	|            if (toExpand == null)
	|            {
	|                return;
	|            }
	|
	|            ObjectToBranch(toExpand)?.ExpandAll();
	|            InvalidateLineMap();
	|            SetNeedsDisplay();
	|        }
	|        /// <summary>
	|        /// Fully expands all nodes in the tree, if the tree is very big and built dynamically this
	|        /// may take a while (e.g. for file system).
	|        /// </summary>
	|        public void ExpandAll()
	|        {
	|            foreach (var item in roots)
	|            {
	|                item.Value.ExpandAll();
	|            }
	|
	|            InvalidateLineMap();
	|            SetNeedsDisplay();
	|        }
	|        /// <summary>
	|        /// Returns true if the given object <paramref name=""o""/> is exposed in the tree and can be
	|        /// expanded otherwise false.
	|        /// </summary>
	|        /// <param name=""o""></param>
	|        /// <returns></returns>
	|        public bool CanExpand(T o)
	|        {
	|            return ObjectToBranch(o)?.CanExpand() ?? false;
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the given object <paramref name=""o""/> is exposed in the tree and 
	|        /// expanded otherwise false.
	|        /// </summary>
	|        /// <param name=""o""></param>
	|        /// <returns></returns>
	|        public bool IsExpanded(T o)
	|        {
	|            return ObjectToBranch(o)?.IsExpanded ?? false;
	|        }
	|
	|        /// <summary>
	|        /// Collapses the <see cref=""SelectedObject""/>
	|        /// </summary>
	|        public void Collapse()
	|        {
	|            Collapse(selectedObject);
	|        }
	|
	|        /// <summary>
	|        /// Collapses the supplied object if it is currently expanded .
	|        /// </summary>
	|        /// <param name=""toCollapse"">The object to collapse.</param>
	|        public void Collapse(T toCollapse)
	|        {
	|            CollapseImpl(toCollapse, false);
	|        }
	|
	|        /// <summary>
	|        /// Collapses the supplied object if it is currently expanded. Also collapses all children
	|        /// branches (this will only become apparent when/if the user expands it again).
	|        /// </summary>
	|        /// <param name=""toCollapse"">The object to collapse.</param>
	|        public void CollapseAll(T toCollapse)
	|        {
	|            CollapseImpl(toCollapse, true);
	|        }
	|
	|        /// <summary>
	|        /// Collapses all root nodes in the tree.
	|        /// </summary>
	|        public void CollapseAll()
	|        {
	|            foreach (var item in roots)
	|            {
	|                item.Value.Collapse();
	|            }
	|
	|            InvalidateLineMap();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Implementation of <see cref=""Collapse(T)""/> and <see cref=""CollapseAll(T)""/>. Performs
	|        /// operation and updates selection if disapeared.
	|        /// </summary>
	|        /// <param name=""toCollapse""></param>
	|        /// <param name=""all""></param>
	|        protected void CollapseImpl(T toCollapse, bool all)
	|        {
	|            if (toCollapse == null)
	|            {
	|                return;
	|            }
	|
	|            var branch = ObjectToBranch(toCollapse);
	|
	|            // Nothing to collapse
	|            if (branch == null)
	|            {
	|                return;
	|            }
	|
	|            if (all)
	|            {
	|                branch.CollapseAll();
	|            }
	|            else
	|            {
	|                branch.Collapse();
	|            }
	|
	|            if (SelectedObject != null && ObjectToBranch(SelectedObject) == null)
	|            {
	|                // If the old selection suddenly became invalid then clear it
	|                SelectedObject = null;
	|            }
	|
	|            InvalidateLineMap();
	|            SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Clears any cached results of the tree state.
	|        /// </summary>
	|        public void InvalidateLineMap()
	|        {
	|            cachedLineMap = null;
	|        }
	|
	|        /// <summary>
	|        /// Returns the corresponding <see cref=""Branch{T}""/> in the tree for
	|        /// <paramref name=""toFind""/>. This will not work for objects hidden
	|        /// by their parent being collapsed.
	|        /// </summary>
	|        /// <param name=""toFind""></param>
	|        /// <returns>The branch for <paramref name=""toFind""/> or null if it is not currently 
	|        /// exposed in the tree.</returns>
	|        private Branch<T> ObjectToBranch(T toFind)
	|        {
	|            return BuildLineMap().FirstOrDefault(o => o.Model.Equals(toFind));
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the <paramref name=""model""/> is either the 
	|        /// <see cref=""SelectedObject""/> or part of a <see cref=""MultiSelect""/>.
	|        /// </summary>
	|        /// <param name=""model""></param>
	|        /// <returns></returns>
	|        public bool IsSelected(T model)
	|        {
	|            return Equals(SelectedObject, model) ||
	|                (MultiSelect && multiSelectedRegions.Any(s => s.Contains(model)));
	|        }
	|
	|        /// <summary>
	|        /// Returns <see cref=""SelectedObject""/> (if not null) and all multi selected objects if 
	|        /// <see cref=""MultiSelect""/> is true
	|        /// </summary>
	|        /// <returns></returns>
	|        public IEnumerable<T> GetAllSelectedObjects()
	|        {
	|            var map = BuildLineMap();
	|
	|            // To determine multi selected objects, start with the line map, that avoids yielding 
	|            // hidden nodes that were selected then the parent collapsed e.g. programmatically or
	|            // with mouse click
	|            if (MultiSelect)
	|            {
	|                foreach (var m in map.Select(b => b.Model).Where(IsSelected))
	|                {
	|                    yield return m;
	|                }
	|            }
	|            else
	|            {
	|                if (SelectedObject != null)
	|                {
	|                    yield return SelectedObject;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Selects all objects in the tree when <see cref=""MultiSelect""/> is enabled otherwise 
	|        /// does nothing.
	|        /// </summary>
	|        public void SelectAll()
	|        {
	|            if (!MultiSelect)
	|            {
	|                return;
	|            }
	|
	|            multiSelectedRegions.Clear();
	|
	|            var map = BuildLineMap();
	|
	|            if (map.Count == 0)
	|            {
	|                return;
	|            }
	|
	|            multiSelectedRegions.Push(new TreeSelection<T>(map.ElementAt(0), map.Count, map));
	|            SetNeedsDisplay();
	|
	|            OnSelectionChanged(new SelectionChangedEventArgs<T>(this, SelectedObject, SelectedObject));
	|        }
	|
	|        /// <summary>
	|        /// Raises the SelectionChanged event.
	|        /// </summary>
	|        /// <param name=""e""></param>
	|        protected virtual void OnSelectionChanged(SelectionChangedEventArgs<T> e)
	|        {
	|            SelectionChanged?.Invoke(this, e);
	|        }
	|    }
	|
	|    class TreeSelection<T> where T : class
	|    {
	|
	|        public Branch<T> Origin { get; }
	|
	|        private HashSet<T> included = new HashSet<T>();
	|
	|        /// <summary>
	|        /// Creates a new selection between two branches in the tree
	|        /// </summary>
	|        /// <param name=""from""></param>
	|        /// <param name=""toIndex""></param>
	|        /// <param name=""map""></param>
	|        public TreeSelection(Branch<T> from, int toIndex, IReadOnlyCollection<Branch<T>> map)
	|        {
	|            Origin = from;
	|            included.Add(Origin.Model);
	|
	|            var oldIdx = map.IndexOf(from);
	|
	|            var lowIndex = Math.Min(oldIdx, toIndex);
	|            var highIndex = Math.Max(oldIdx, toIndex);
	|
	|            // Select everything between the old and new indexes
	|            foreach (var alsoInclude in map.Skip(lowIndex).Take(highIndex - lowIndex))
	|            {
	|                included.Add(alsoInclude.Model);
	|            }
	|
	|        }
	|        public bool Contains(T model)
	|        {
	|            return included.Contains(model);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// <see cref=""ITreeViewFilter{T}""/> implementation which searches the
	|    /// <see cref=""TreeView{T}.AspectGetter""/> of the model for the given
	|    /// <see cref=""Text""/>.
	|    /// </summary>
	|    /// <typeparam name=""T""></typeparam>
	|    public class TreeViewTextFilter<T> : ITreeViewFilter<T> where T : class
	|    {
	|        readonly TreeView<T> _forTree;
	|
	|        /// <summary>
	|        /// Creates a new instance of the filter for use with <paramref name=""forTree""/>.
	|        /// Set <see cref=""Text""/> to begin filtering.
	|        /// </summary>
	|        /// <param name=""forTree""></param>
	|        /// <exception cref=""ArgumentNullException""></exception>
	|        public TreeViewTextFilter(TreeView<T> forTree)
	|        {
	|            _forTree = forTree ?? throw new ArgumentNullException(nameof(forTree));
	|        }
	|
	|        /// <summary>
	|        /// The case sensitivity of the search match. 
	|        /// Defaults to <see cref=""StringComparison.OrdinalIgnoreCase""/>.
	|        /// </summary>
	|        public StringComparison Comparer { get; set; } = StringComparison.OrdinalIgnoreCase;
	|        private string text;
	|
	|        /// <summary>
	|        /// The text that will be searched for in the <see cref=""TreeView{T}""/>
	|        /// </summary>
	|        public string Text
	|        {
	|            get { return text; }
	|            set
	|            {
	|                text = value;
	|                RefreshTreeView();
	|            }
	|        }
	|
	|        private void RefreshTreeView()
	|        {
	|            _forTree.InvalidateLineMap();
	|            _forTree.SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Returns <typeparamref name=""T""/> if there is no <see cref=""Text""/> or
	|        /// the text matches the <see cref=""TreeView{T}.AspectGetter""/> of the
	|        /// <paramref name=""model""/>.
	|        /// </summary>
	|        /// <param name=""model""></param>
	|        /// <returns></returns>
	|        public bool IsMatch(T model)
	|        {
	|            if (string.IsNullOrWhiteSpace(Text))
	|            {
	|                return true;
	|            }
	|
	|            return _forTree.AspectGetter(model)?.IndexOf(Text, Comparer) != -1;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // mainloop.cs: Simple managed mainloop implementation.
	|    //
	|
	|    /// <summary>
	|    /// Unix main loop, suitable for using on Posix systems
	|    /// </summary>
	|    /// <remarks>
	|    /// In addition to the general functions of the mainloop, the Unix version
	|    /// can watch file descriptors using the AddWatch methods.
	|    /// </remarks>
	|    internal class UnixMainLoop : IMainLoopDriver
	|    {
	|        public UnixMainLoop(ConsoleDriver consoleDriver = null)
	|        {
	|            // UnixDriver doesn't use the consoleDriver parameter, but the WindowsDriver does.
	|        }
	|
	|        public const int KEY_RESIZE = unchecked((int)0xffffffffffffffff);
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        struct Pollfd
	|        {
	|            public int fd;
	|            public short events, revents;
	|        }
	|
	|        /// <summary>
	|        ///	Condition on which to wake up from file descriptor activity.  These match the Linux/BSD poll definitions.
	|        /// </summary>
	|        [Flags]
	|        public enum Condition : short
	|        {
	|            /// <summary>
	|            /// There is data to read
	|            /// </summary>
	|            PollIn = 1,
	|            /// <summary>
	|            /// Writing to the specified descriptor will not block
	|            /// </summary>
	|            PollOut = 4,
	|            /// <summary>
	|            /// There is urgent data to read
	|            /// </summary>
	|            PollPri = 2,
	|            /// <summary>
	|            ///  Error condition on output
	|            /// </summary>
	|            PollErr = 8,
	|            /// <summary>
	|            /// Hang-up on output
	|            /// </summary>
	|            PollHup = 16,
	|            /// <summary>
	|            /// File descriptor is not open.
	|            /// </summary>
	|            PollNval = 32
	|        }
	|
	|        class Watch
	|        {
	|            public int File;
	|            public Condition Condition;
	|            public Func<MainLoop, bool> Callback;
	|        }
	|
	|        Dictionary<int, Watch> descriptorWatchers = new Dictionary<int, Watch>();
	|
	|        [DllImport(""libc"")]
	|        extern static int poll([In, Out] Pollfd[] ufds, uint nfds, int timeout);
	|
	|        [DllImport(""libc"")]
	|        extern static int pipe([In, Out] int[] pipes);
	|
	|        [DllImport(""libc"")]
	|        extern static int read(int fd, IntPtr buf, IntPtr n);
	|
	|        [DllImport(""libc"")]
	|        extern static int write(int fd, IntPtr buf, IntPtr n);
	|
	|        Pollfd[] pollmap;
	|        bool poll_dirty = true;
	|        int[] wakeupPipes = new int[2];
	|        static IntPtr ignore = Marshal.AllocHGlobal(1);
	|        MainLoop mainLoop;
	|        bool winChanged;
	|
	|        public Action WinChanged;
	|
	|        void IMainLoopDriver.Wakeup()
	|        {
	|            write(wakeupPipes[1], ignore, (IntPtr)1);
	|        }
	|
	|        void IMainLoopDriver.Setup(MainLoop mainLoop)
	|        {
	|            this.mainLoop = mainLoop;
	|            pipe(wakeupPipes);
	|            AddWatch(wakeupPipes[0], Condition.PollIn, ml =>
	|            {
	|                read(wakeupPipes[0], ignore, (IntPtr)1);
	|                return true;
	|            });
	|        }
	|
	|        /// <summary>
	|        ///	Removes an active watch from the mainloop.
	|        /// </summary>
	|        /// <remarks>
	|        ///	The token parameter is the value returned from AddWatch
	|        /// </remarks>
	|        public void RemoveWatch(object token)
	|        {
	|            var watch = token as Watch;
	|            if (watch == null)
	|                return;
	|            descriptorWatchers.Remove(watch.File);
	|        }
	|
	|        /// <summary>
	|        ///  Watches a file descriptor for activity.
	|        /// </summary>
	|        /// <remarks>
	|        ///  When the condition is met, the provided callback
	|        ///  is invoked.  If the callback returns false, the
	|        ///  watch is automatically removed.
	|        ///
	|        ///  The return value is a token that represents this watch, you can
	|        ///  use this token to remove the watch by calling RemoveWatch.
	|        /// </remarks>
	|        public object AddWatch(int fileDescriptor, Condition condition, Func<MainLoop, bool> callback)
	|        {
	|            if (callback == null)
	|                throw new ArgumentNullException(nameof(callback));
	|
	|            var watch = new Watch() { Condition = condition, Callback = callback, File = fileDescriptor };
	|            descriptorWatchers[fileDescriptor] = watch;
	|            poll_dirty = true;
	|            return watch;
	|        }
	|
	|        void UpdatePollMap()
	|        {
	|            if (!poll_dirty)
	|                return;
	|            poll_dirty = false;
	|
	|            pollmap = new Pollfd[descriptorWatchers.Count];
	|            int i = 0;
	|            foreach (var fd in descriptorWatchers.Keys)
	|            {
	|                pollmap[i].fd = fd;
	|                pollmap[i].events = (short)descriptorWatchers[fd].Condition;
	|                i++;
	|            }
	|        }
	|
	|        bool IMainLoopDriver.EventsPending(bool wait)
	|        {
	|            UpdatePollMap();
	|
	|            bool checkTimersResult = CheckTimers(wait, out var pollTimeout);
	|
	|            var n = poll(pollmap, (uint)pollmap.Length, pollTimeout);
	|
	|            if (n == KEY_RESIZE)
	|            {
	|                winChanged = true;
	|            }
	|
	|            return checkTimersResult || n >= KEY_RESIZE;
	|        }
	|
	|        bool CheckTimers(bool wait, out int pollTimeout)
	|        {
	|            long now = DateTime.UtcNow.Ticks;
	|
	|            if (mainLoop.timeouts.Count > 0)
	|            {
	|                pollTimeout = (int)((mainLoop.timeouts.Keys[0] - now) / TimeSpan.TicksPerMillisecond);
	|                if (pollTimeout < 0)
	|                {
	|                    // This avoids 'poll' waiting infinitely if 'pollTimeout < 0' until some action is detected
	|                    // This can occur after IMainLoopDriver.Wakeup is executed where the pollTimeout is less than 0
	|                    // and no event occurred in elapsed time when the 'poll' is start running again.
	|                    /*
	|					The 'poll' function in the C standard library uses a signed integer as the timeout argument, where:
	|
	|					    - A positive value specifies a timeout in milliseconds.
	|					    - A value of 0 means the poll function will return immediately, checking for events and not waiting.
	|					    - A value of -1 means the poll function will wait indefinitely until an event occurs or an error occurs.
	|					    - A negative value other than -1 typically indicates an error.
	|					 */
	|                    pollTimeout = 0;
	|                    return true;
	|                }
	|            }
	|            else
	|                pollTimeout = -1;
	|
	|            if (!wait)
	|                pollTimeout = 0;
	|
	|            int ic;
	|            lock (mainLoop.idleHandlers)
	|            {
	|                ic = mainLoop.idleHandlers.Count;
	|            }
	|
	|            return ic > 0;
	|        }
	|
	|        void IMainLoopDriver.MainIteration()
	|        {
	|            if (winChanged)
	|            {
	|                winChanged = false;
	|                WinChanged?.Invoke();
	|            }
	|            if (pollmap != null)
	|            {
	|                foreach (var p in pollmap)
	|                {
	|                    Watch watch;
	|
	|                    if (p.revents == 0)
	|                        continue;
	|
	|                    if (!descriptorWatchers.TryGetValue(p.fd, out watch))
	|                        continue;
	|                    if (!watch.Callback(this.mainLoop))
	|                        descriptorWatchers.Remove(p.fd);
	|                }
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Determines the LayoutStyle for a <see cref=""View""/>, if Absolute, during <see cref=""View.LayoutSubviews""/>, the
	|    /// value from the <see cref=""View.Frame""/> will be used, if the value is Computed, then <see cref=""View.Frame""/>
	|    /// will be updated from the X, Y <see cref=""Pos""/> objects and the Width and Height <see cref=""Dim""/> objects.
	|    /// </summary>
	|    public enum LayoutStyle
	|    {
	|        /// <summary>
	|        /// The position and size of the view are based on the Frame value.
	|        /// </summary>
	|        Absolute,
	|
	|        /// <summary>
	|        /// The position and size of the view will be computed based on the
	|        /// X, Y, Width and Height properties and set on the Frame.
	|        /// </summary>
	|        Computed
	|    }
	|
	|    /// <summary>
	|    /// View is the base class for all views on the screen and represents a visible element that can render itself and 
	|    /// contains zero or more nested views.
	|    /// </summary>
	|    /// <remarks>
	|    /// <para>
	|    ///    The View defines the base functionality for user interface elements in Terminal.Gui. Views
	|    ///    can contain one or more subviews, can respond to user input and render themselves on the screen.
	|    /// </para>
	|    /// <para>
	|    ///    Views supports two layout styles: <see cref=""LayoutStyle.Absolute""/> or <see cref=""LayoutStyle.Computed""/>. 
	|    ///    The choice as to which layout style is used by the View 
	|    ///    is determined when the View is initialized. To create a View using Absolute layout, call a constructor that takes a
	|    ///    Rect parameter to specify the absolute position and size (the View.<see cref=""View.Frame ""/>). To create a View 
	|    ///    using Computed layout use a constructor that does not take a Rect parameter and set the X, Y, Width and Height 
	|    ///    properties on the view. Both approaches use coordinates that are relative to the container they are being added to. 
	|    /// </para>
	|    /// <para>
	|    ///    To switch between Absolute and Computed layout, use the <see cref=""LayoutStyle""/> property. 
	|    /// </para>
	|    /// <para>
	|    ///    Computed layout is more flexible and supports dynamic console apps where controls adjust layout
	|    ///    as the terminal resizes or other Views change size or position. The X, Y, Width and Height 
	|    ///    properties are Dim and Pos objects that dynamically update the position of a view.
	|    ///    The X and Y properties are of type <see cref=""Pos""/>
	|    ///    and you can use either absolute positions, percentages or anchor
	|    ///    points. The Width and Height properties are of type
	|    ///    <see cref=""Dim""/> and can use absolute position,
	|    ///    percentages and anchors. These are useful as they will take
	|    ///    care of repositioning views when view's frames are resized or
	|    ///    if the terminal size changes.
	|    /// </para>
	|    /// <para>
	|    ///    Absolute layout requires specifying coordinates and sizes of Views explicitly, and the
	|    ///    View will typically stay in a fixed position and size. To change the position and size use the
	|    ///    <see cref=""Frame""/> property.
	|    /// </para>
	|    /// <para>
	|    ///    Subviews (child views) can be added to a View by calling the <see cref=""Add(View)""/> method. 
	|    ///    The container of a View can be accessed with the <see cref=""SuperView""/> property.
	|    /// </para>
	|    /// <para>
	|    ///    To flag a region of the View's <see cref=""Bounds""/> to be redrawn call <see cref=""SetNeedsDisplay(Rect)""/>. 
	|    ///    To flag the entire view for redraw call <see cref=""SetNeedsDisplay()""/>.
	|    /// </para>
	|    /// <para>
	|    ///    Views have a <see cref=""ColorScheme""/> property that defines the default colors that subviews
	|    ///    should use for rendering. This ensures that the views fit in the context where
	|    ///    they are being used, and allows for themes to be plugged in. For example, the
	|    ///    default colors for windows and toplevels uses a blue background, while it uses
	|    ///    a white background for dialog boxes and a red background for errors.
	|    /// </para>
	|    /// <para>
	|    ///    Subclasses should not rely on <see cref=""ColorScheme""/> being
	|    ///    set at construction time. If a <see cref=""ColorScheme""/> is not set on a view, the view will inherit the
	|    ///    value from its <see cref=""SuperView""/> and the value might only be valid once a view has been
	|    ///    added to a SuperView. 
	|    /// </para>
	|    /// <para>
	|    ///    By using  <see cref=""ColorScheme""/> applications will work both
	|    ///    in color as well as black and white displays.
	|    /// </para>
	|    /// <para>
	|    ///    Views that are focusable should implement the <see cref=""PositionCursor""/> to make sure that
	|    ///    the cursor is placed in a location that makes sense. Unix terminals do not have
	|    ///    a way of hiding the cursor, so it can be distracting to have the cursor left at
	|    ///    the last focused view. So views should make sure that they place the cursor
	|    ///    in a visually sensible place.
	|    /// </para>
	|    /// <para>
	|    ///    The <see cref=""LayoutSubviews""/> method is invoked when the size or layout of a view has
	|    ///    changed. The default processing system will keep the size and dimensions
	|    ///    for views that use the <see cref=""LayoutStyle.Absolute""/>, and will recompute the
	|    ///    frames for the vies that use <see cref=""LayoutStyle.Computed""/>.
	|    /// </para>
	|    /// </remarks>
	|    public partial class View : Responder, ISupportInitializeNotification
	|    {
	|        //*master//
	|        public ScriptEngine.Machine.IValue Tag { get; set; }
	|        //master*//
	|
	|        internal enum Direction
	|        {
	|            Forward,
	|            Backward
	|        }
	|
	|        // container == SuperView
	|        View container = null;
	|        View focused = null;
	|        Direction focusDirection;
	|        bool autoSize;
	|
	|        ShortcutHelper shortcutHelper;
	|
	|        /// <summary>
	|        /// Event fired when a subview is being added to this view.
	|        /// </summary>
	|        public event Action<View> Added;
	|
	|        /// <summary>
	|        /// Event fired when a subview is being removed from this view.
	|        /// </summary>
	|        public event Action<View> Removed;
	|
	|        /// <summary>
	|        /// Event fired when the view gets focus.
	|        /// </summary>
	|        public event Action<FocusEventArgs> Enter;
	|
	|        /// <summary>
	|        /// Event fired when the view looses focus.
	|        /// </summary>
	|        public event Action<FocusEventArgs> Leave;
	|
	|        /// <summary>
	|        /// Event fired when the view receives the mouse event for the first time.
	|        /// </summary>
	|        public event Action<MouseEventArgs> MouseEnter;
	|
	|        /// <summary>
	|        /// Event fired when the view receives a mouse event for the last time.
	|        /// </summary>
	|        public event Action<MouseEventArgs> MouseLeave;
	|
	|        /// <summary>
	|        /// Event fired when a mouse event is generated.
	|        /// </summary>
	|        public event Action<MouseEventArgs> MouseClick;
	|
	|        /// <summary>
	|        /// Event fired when the <see cref=""CanFocus""/> value is being changed.
	|        /// </summary>
	|        public event Action CanFocusChanged;
	|
	|        /// <summary>
	|        /// Event fired when the <see cref=""Enabled""/> value is being changed.
	|        /// </summary>
	|        public event Action EnabledChanged;
	|
	|        /// <summary>
	|        /// Event fired when the <see cref=""Visible""/> value is being changed.
	|        /// </summary>
	|        public event Action VisibleChanged;
	|
	|        /// <summary>
	|        /// Event invoked when the <see cref=""HotKey""/> is changed.
	|        /// </summary>
	|        public event Action<Key> HotKeyChanged;
	|
	|        Key hotKey = Key.Null;
	|
	|        /// <summary>
	|        /// Gets or sets the HotKey defined for this view. A user pressing HotKey on the keyboard while this view has focus will cause the Clicked event to fire.
	|        /// </summary>
	|        public virtual Key HotKey
	|        {
	|            get => hotKey;
	|            set
	|            {
	|                if (hotKey != value)
	|                {
	|                    hotKey = TextFormatter.HotKey = (value == Key.Unknown ? Key.Null : value);
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the specifier character for the hotkey (e.g. '_'). Set to '\xffff' to disable hotkey support for this View instance. The default is '\xffff'. 
	|        /// </summary>
	|        public virtual Rune HotKeySpecifier
	|        {
	|            get => TextFormatter.HotKeySpecifier;
	|            set
	|            {
	|                TextFormatter.HotKeySpecifier = value;
	|                SetHotKey();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This is the global setting that can be used as a global shortcut to invoke an action if provided.
	|        /// </summary>
	|        public Key Shortcut
	|        {
	|            get => shortcutHelper.Shortcut;
	|            set
	|            {
	|                if (shortcutHelper.Shortcut != value && (ShortcutHelper.PostShortcutValidation(value) || value == Key.Null))
	|                {
	|                    shortcutHelper.Shortcut = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The keystroke combination used in the <see cref=""Shortcut""/> as string.
	|        /// </summary>
	|        public ustring ShortcutTag => ShortcutHelper.GetShortcutTag(shortcutHelper.Shortcut);
	|
	|        /// <summary>
	|        /// The action to run if the <see cref=""Shortcut""/> is defined.
	|        /// </summary>
	|        public virtual Action ShortcutAction { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets arbitrary data for the view.
	|        /// </summary>
	|        /// <remarks>This property is not used internally.</remarks>
	|        public object Data { get; set; }
	|
	|        internal Direction FocusDirection
	|        {
	|            get => SuperView?.FocusDirection ?? focusDirection;
	|            set
	|            {
	|                if (SuperView != null)
	|                    SuperView.FocusDirection = value;
	|                else
	|                    focusDirection = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Points to the current driver in use by the view, it is a convenience property
	|        /// for simplifying the development of new views.
	|        /// </summary>
	|        public static ConsoleDriver Driver => Application.Driver;
	|
	|        static readonly IList<View> empty = new List<View>(0).AsReadOnly();
	|
	|        // This is null, and allocated on demand.
	|        List<View> subviews;
	|
	|        /// <summary>
	|        /// This returns a list of the subviews contained by this view.
	|        /// </summary>
	|        /// <value>The subviews.</value>
	|        public IList<View> Subviews => subviews?.AsReadOnly() ?? empty;
	|
	|        // Internally, we use InternalSubviews rather than subviews, as we do not expect us
	|        // to make the same mistakes our users make when they poke at the Subviews.
	|        internal IList<View> InternalSubviews => subviews ?? empty;
	|
	|        // This is null, and allocated on demand.
	|        List<View> tabIndexes;
	|
	|        /// <summary>
	|        /// Configurable keybindings supported by the control
	|        /// </summary>
	|        private Dictionary<Key, Command[]> KeyBindings { get; set; } = new Dictionary<Key, Command[]>();
	|        private Dictionary<Command, Func<bool?>> CommandImplementations { get; set; } = new Dictionary<Command, Func<bool?>>();
	|
	|        /// <summary>
	|        /// This returns a tab index list of the subviews contained by this view.
	|        /// </summary>
	|        /// <value>The tabIndexes.</value>
	|        public IList<View> TabIndexes => tabIndexes?.AsReadOnly() ?? empty;
	|
	|        int tabIndex = -1;
	|
	|        /// <summary>
	|        /// Indicates the index of the current <see cref=""View""/> from the <see cref=""TabIndexes""/> list.
	|        /// </summary>
	|        public int TabIndex
	|        {
	|            get { return tabIndex; }
	|            set
	|            {
	|                if (!CanFocus)
	|                {
	|                    tabIndex = -1;
	|                    return;
	|                }
	|                else if (SuperView?.tabIndexes == null || SuperView?.tabIndexes.Count == 1)
	|                {
	|                    tabIndex = 0;
	|                    return;
	|                }
	|                else if (tabIndex == value && TabIndexes.IndexOf(this) == value)
	|                {
	|                    return;
	|                }
	|                tabIndex = value > SuperView.tabIndexes.Count - 1 ? SuperView.tabIndexes.Count - 1 : value < 0 ? 0 : value;
	|                tabIndex = GetTabIndex(tabIndex);
	|                if (SuperView.tabIndexes.IndexOf(this) != tabIndex)
	|                {
	|                    SuperView.tabIndexes.Remove(this);
	|                    SuperView.tabIndexes.Insert(tabIndex, this);
	|                    SetTabIndex();
	|                }
	|            }
	|        }
	|
	|        int GetTabIndex(int idx)
	|        {
	|            var i = 0;
	|            foreach (var v in SuperView.tabIndexes)
	|            {
	|                if (v.tabIndex == -1 || v == this)
	|                {
	|                    continue;
	|                }
	|                i++;
	|            }
	|            return Math.Min(i, idx);
	|        }
	|
	|        void SetTabIndex()
	|        {
	|            var i = 0;
	|            foreach (var v in SuperView.tabIndexes)
	|            {
	|                if (v.tabIndex == -1)
	|                {
	|                    continue;
	|                }
	|                v.tabIndex = i;
	|                i++;
	|            }
	|        }
	|
	|        bool tabStop = true;
	|
	|        /// <summary>
	|        /// This only be <see langword=""true""/> if the <see cref=""CanFocus""/> is also <see langword=""true""/> 
	|        /// and the focus can be avoided by setting this to <see langword=""false""/>
	|        /// </summary>
	|        public bool TabStop
	|        {
	|            get => tabStop;
	|            set
	|            {
	|                if (tabStop == value)
	|                {
	|                    return;
	|                }
	|                tabStop = CanFocus && value;
	|            }
	|        }
	|
	|        bool oldCanFocus;
	|        int oldTabIndex;
	|
	|        /// <inheritdoc/>
	|        public override bool CanFocus
	|        {
	|            get => base.CanFocus;
	|            set
	|            {
	|                if (!addingView && IsInitialized && SuperView?.CanFocus == false && value)
	|                {
	|                    throw new InvalidOperationException(""Cannot set CanFocus to true if the SuperView CanFocus is false!"");
	|                }
	|                if (base.CanFocus != value)
	|                {
	|                    base.CanFocus = value;
	|
	|                    switch (value)
	|                    {
	|                        case false when tabIndex > -1:
	|                            TabIndex = -1;
	|                            break;
	|                        case true when SuperView?.CanFocus == false && addingView:
	|                            SuperView.CanFocus = true;
	|                            break;
	|                    }
	|
	|                    if (value && tabIndex == -1)
	|                    {
	|                        TabIndex = SuperView != null ? SuperView.tabIndexes.IndexOf(this) : -1;
	|                    }
	|                    TabStop = value;
	|
	|                    if (!value && SuperView?.Focused == this)
	|                    {
	|                        SuperView.focused = null;
	|                    }
	|                    if (!value && HasFocus)
	|                    {
	|                        SetHasFocus(false, this);
	|                        SuperView?.EnsureFocus();
	|                        if (SuperView != null && SuperView.Focused == null)
	|                        {
	|                            SuperView.FocusNext();
	|                            if (SuperView.Focused == null && Application.Current != null)
	|                            {
	|                                Application.Current.FocusNext();
	|                            }
	|                            Application.EnsuresTopOnFront();
	|                        }
	|                    }
	|                    if (subviews != null && IsInitialized)
	|                    {
	|                        foreach (var view in subviews)
	|                        {
	|                            if (view.CanFocus != value)
	|                            {
	|                                if (!value)
	|                                {
	|                                    view.oldCanFocus = view.CanFocus;
	|                                    view.oldTabIndex = view.tabIndex;
	|                                    view.CanFocus = false;
	|                                    view.tabIndex = -1;
	|                                }
	|                                else
	|                                {
	|                                    if (addingView)
	|                                    {
	|                                        view.addingView = true;
	|                                    }
	|                                    view.CanFocus = view.oldCanFocus;
	|                                    view.tabIndex = view.oldTabIndex;
	|                                    view.addingView = false;
	|                                }
	|                            }
	|                        }
	|
	|                        if (SuperView is Toplevel && Application.Current?.Focused != SuperView)
	|                        {
	|                            Application.EnsuresTopOnFront();
	|                        }
	|                    }
	|                    OnCanFocusChanged();
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        internal Rect NeedDisplay { get; private set; } = Rect.Empty;
	|
	|        // The frame for the object. Superview relative.
	|        Rect frame;
	|
	|        /// <summary>
	|        /// Gets or sets an identifier for the view;
	|        /// </summary>
	|        /// <value>The identifier.</value>
	|        /// <remarks>The id should be unique across all Views that share a SuperView.</remarks>
	|        public ustring Id { get; set; } = """";
	|
	|        /// <summary>
	|        /// Returns a value indicating if this View is currently on Top (Active)
	|        /// </summary>
	|        public bool IsCurrentTop => Application.Current == this;
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""View""/> wants mouse position reports.
	|        /// </summary>
	|        /// <value><see langword=""true""/> if want mouse position reports; otherwise, <see langword=""false""/>.</value>
	|        public virtual bool WantMousePositionReports { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets a value indicating whether this <see cref=""View""/> want continuous button pressed event.
	|        /// </summary>
	|        public virtual bool WantContinuousButtonPressed { get; set; }
	|
	|        /// <summary>
	|        /// Gets or sets the frame for the view. The frame is relative to the view's container (<see cref=""SuperView""/>).
	|        /// </summary>
	|        /// <value>The frame.</value>
	|        /// <remarks>
	|        /// <para>
	|        ///    Change the Frame when using the <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> layout style to move or resize views. 
	|        /// </para>
	|        /// <para>
	|        ///    Altering the Frame of a view will trigger the redrawing of the
	|        ///    view as well as the redrawing of the affected regions of the <see cref=""SuperView""/>.
	|        /// </para>
	|        /// </remarks>
	|        public virtual Rect Frame
	|        {
	|            get => frame;
	|            set
	|            {
	|                frame = value;
	|                TextFormatter.Size = GetBoundsTextFormatterSize();
	|                SetNeedsLayout();
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        ///// <summary>
	|        ///// Gets an enumerator that enumerates the subviews in this view.
	|        ///// </summary>
	|        ///// <returns>The enumerator.</returns>
	|        //public IEnumerator GetEnumerator ()
	|        //{
	|        //	foreach (var v in InternalSubviews)
	|        //		yield return v;
	|        //}
	|
	|        LayoutStyle layoutStyle;
	|
	|        /// <summary>
	|        /// Controls how the View's <see cref=""Frame""/> is computed during the LayoutSubviews method, if the style is set to
	|        /// <see cref=""Terminal.Gui.LayoutStyle.Absolute""/>, 
	|        /// LayoutSubviews does not change the <see cref=""Frame""/>. If the style is <see cref=""Terminal.Gui.LayoutStyle.Computed""/>
	|        /// the <see cref=""Frame""/> is updated using
	|        /// the <see cref=""X""/>, <see cref=""Y""/>, <see cref=""Width""/>, and <see cref=""Height""/> properties.
	|        /// </summary>
	|        /// <value>The layout style.</value>
	|        public LayoutStyle LayoutStyle
	|        {
	|            get => layoutStyle;
	|            set
	|            {
	|                layoutStyle = value;
	|                SetNeedsLayout();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// The bounds represent the View-relative rectangle used for this view; the area inside of the view.
	|        /// </summary>
	|        /// <value>The bounds.</value>
	|        /// <remarks>
	|        /// <para>
	|        /// Updates to the Bounds update the <see cref=""Frame""/>,
	|        /// and has the same side effects as updating the <see cref=""Frame""/>.
	|        /// </para>
	|        /// <para>
	|        /// Because <see cref=""Bounds""/> coordinates are relative to the upper-left corner of the <see cref=""View""/>, 
	|        /// the coordinates of the upper-left corner of the rectangle returned by this property are (0,0). 
	|        /// Use this property to obtain the size and coordinates of the client area of the 
	|        /// control for tasks such as drawing on the surface of the control.
	|        /// </para>
	|        /// </remarks>
	|        public Rect Bounds
	|        {
	|            get => new Rect(Point.Empty, Frame.Size);
	|            set => Frame = new Rect(frame.Location, value.Size);
	|        }
	|
	|        Pos x, y;
	|
	|        /// <summary>
	|        /// Gets or sets the X position for the view (the column). Only used if the <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Computed""/>.
	|        /// </summary>
	|        /// <value>The X Position.</value>
	|        /// <remarks>
	|        /// If <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> changing this property has no effect and its value is indeterminate. 
	|        /// </remarks>
	|        public Pos X
	|        {
	|            get => x;
	|            set
	|            {
	|                if (ForceValidatePosDim && !ValidatePosDim(x, value))
	|                {
	|                    throw new ArgumentException();
	|                }
	|
	|                x = value;
	|
	|                ProcessResizeView();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the Y position for the view (the row). Only used if the <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Computed""/>.
	|        /// </summary>
	|        /// <value>The y position (line).</value>
	|        /// <remarks>
	|        /// If <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> changing this property has no effect and its value is indeterminate. 
	|        /// </remarks>
	|        public Pos Y
	|        {
	|            get => y;
	|            set
	|            {
	|                if (ForceValidatePosDim && !ValidatePosDim(y, value))
	|                {
	|                    throw new ArgumentException();
	|                }
	|
	|                y = value;
	|
	|                ProcessResizeView();
	|            }
	|        }
	|        Dim width, height;
	|
	|        /// <summary>
	|        /// Gets or sets the width of the view. Only used the <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Computed""/>.
	|        /// </summary>
	|        /// <value>The width.</value>
	|        /// <remarks>
	|        /// If <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> changing this property has no effect and its value is indeterminate. 
	|        /// </remarks>
	|        public Dim Width
	|        {
	|            get => width;
	|            set
	|            {
	|                if (ForceValidatePosDim && !ValidatePosDim(width, value))
	|                {
	|                    throw new ArgumentException(""ForceValidatePosDim is enabled"", nameof(Width));
	|                }
	|
	|                width = value;
	|
	|                if (ForceValidatePosDim)
	|                {
	|                    var isValidNewAutSize = autoSize && IsValidAutoSizeWidth(width);
	|
	|                    if (IsAdded && autoSize && !isValidNewAutSize)
	|                    {
	|                        throw new InvalidOperationException(""Must set AutoSize to false before set the Width."");
	|                    }
	|                }
	|                ProcessResizeView();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the height of the view. Only used the <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Computed""/>.
	|        /// </summary>
	|        /// <value>The height.</value>
	|        /// If <see cref=""LayoutStyle""/> is <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> changing this property has no effect and its value is indeterminate. 
	|        public Dim Height
	|        {
	|            get => height;
	|            set
	|            {
	|                if (ForceValidatePosDim && !ValidatePosDim(height, value))
	|                {
	|                    throw new ArgumentException(""ForceValidatePosDim is enabled"", nameof(Height));
	|                }
	|
	|                height = value;
	|
	|                if (ForceValidatePosDim)
	|                {
	|                    var isValidNewAutSize = autoSize && IsValidAutoSizeHeight(height);
	|
	|                    if (IsAdded && autoSize && !isValidNewAutSize)
	|                    {
	|                        throw new InvalidOperationException(""Must set AutoSize to false before set the Height."");
	|                    }
	|                }
	|                ProcessResizeView();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Forces validation with <see cref=""Terminal.Gui.LayoutStyle.Computed""/> layout
	|        ///  to avoid breaking the <see cref=""Pos""/> and <see cref=""Dim""/> settings.
	|        /// </summary>
	|        public bool ForceValidatePosDim { get; set; }
	|
	|        bool ValidatePosDim(object oldValue, object newValue)
	|        {
	|            if (!IsInitialized || layoutStyle == LayoutStyle.Absolute || oldValue == null || oldValue.GetType() == newValue.GetType() || this is Toplevel)
	|            {
	|                return true;
	|            }
	|            if (layoutStyle == LayoutStyle.Computed)
	|            {
	|                if (oldValue.GetType() != newValue.GetType() && !(newValue is Pos.PosAbsolute || newValue is Dim.DimAbsolute))
	|                {
	|                    return true;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Verifies if the minimum width or height can be sets in the view.
	|        /// </summary>
	|        /// <param name=""size"">The size.</param>
	|        /// <returns><see langword=""true""/> if the size can be set, <see langword=""false""/> otherwise.</returns>
	|        public bool GetMinWidthHeight(out Size size)
	|        {
	|            size = Size.Empty;
	|
	|            if (!AutoSize && !ustring.IsNullOrEmpty(TextFormatter.Text))
	|            {
	|                switch (TextFormatter.IsVerticalDirection(TextDirection))
	|                {
	|                    case true:
	|                        var colWidth = TextFormatter.GetSumMaxCharWidth(new List<ustring> { TextFormatter.Text }, 0, 1);
	|                        if (frame.Width < colWidth && (Width == null || (Bounds.Width >= 0 && Width is Dim.DimAbsolute
	|                            && Width.Anchor(0) >= 0 && Width.Anchor(0) < colWidth)))
	|                        {
	|                            size = new Size(colWidth, Bounds.Height);
	|                            return true;
	|                        }
	|                        break;
	|                    default:
	|                        if (frame.Height < 1 && (Height == null || (Height is Dim.DimAbsolute && Height.Anchor(0) == 0)))
	|                        {
	|                            size = new Size(Bounds.Width, 1);
	|                            return true;
	|                        }
	|                        break;
	|                }
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Sets the minimum width or height if the view can be resized.
	|        /// </summary>
	|        /// <returns><see langword=""true""/> if the size can be set, <see langword=""false""/> otherwise.</returns>
	|        public bool SetMinWidthHeight()
	|        {
	|            if (GetMinWidthHeight(out Size size))
	|            {
	|                Bounds = new Rect(Bounds.Location, size);
	|                TextFormatter.Size = GetBoundsTextFormatterSize();
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the <see cref=""Terminal.Gui.TextFormatter""/> which can be handled differently by any derived class.
	|        /// </summary>
	|        public TextFormatter TextFormatter { get; set; }
	|
	|        /// <summary>
	|        /// Returns the container for this view, or null if this view has not been added to a container.
	|        /// </summary>
	|        /// <value>The super view.</value>
	|        public View SuperView => container;
	|
	|        /// <summary>
	|        /// Initializes a new instance of a <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> <see cref=""View""/> class with the absolute
	|        /// dimensions specified in the <see langword=""frame""/> parameter. 
	|        /// </summary>
	|        /// <param name=""frame"">The region covered by this view.</param>
	|        /// <remarks>
	|        /// This constructor initialize a View with a <see cref=""LayoutStyle""/> of <see cref=""Terminal.Gui.LayoutStyle.Absolute""/>.
	|        /// Use <see cref=""View""/> to initialize a View with  <see cref=""LayoutStyle""/> of <see cref=""Terminal.Gui.LayoutStyle.Computed""/> 
	|        /// </remarks>
	|        public View(Rect frame)
	|        {
	|            Initialize(ustring.Empty, frame, LayoutStyle.Absolute, TextDirection.LeftRight_TopBottom);
	|        }
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""View""/> using <see cref=""Terminal.Gui.LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///   Use <see cref=""X""/>, <see cref=""Y""/>, <see cref=""Width""/>, and <see cref=""Height""/> properties to dynamically control the size and location of the view.
	|        ///   The <see cref=""View""/> will be created using <see cref=""Terminal.Gui.LayoutStyle.Computed""/>
	|        ///   coordinates. The initial size (<see cref=""View.Frame""/>) will be 
	|        ///   adjusted to fit the contents of <see cref=""Text""/>, including newlines ('\n') for multiple lines. 
	|        /// </para>
	|        /// <para>
	|        ///   If <see cref=""Height""/> is greater than one, word wrapping is provided.
	|        /// </para>
	|        /// <para>
	|        ///   This constructor initialize a View with a <see cref=""LayoutStyle""/> of <see cref=""Terminal.Gui.LayoutStyle.Computed""/>. 
	|        ///   Use <see cref=""X""/>, <see cref=""Y""/>, <see cref=""Width""/>, and <see cref=""Height""/> properties to dynamically control the size and location of the view.
	|        /// </para>
	|        /// </remarks>
	|        public View() : this(text: string.Empty, direction: TextDirection.LeftRight_TopBottom) { }
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""View""/> using <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///   The <see cref=""View""/> will be created at the given
	|        ///   coordinates with the given string. The size (<see cref=""View.Frame""/>) will be 
	|        ///   adjusted to fit the contents of <see cref=""Text""/>, including newlines ('\n') for multiple lines. 
	|        /// </para>
	|        /// <para>
	|        ///   No line wrapping is provided.
	|        /// </para>
	|        /// </remarks>
	|        /// <param name=""x"">column to locate the View.</param>
	|        /// <param name=""y"">row to locate the View.</param>
	|        /// <param name=""text"">text to initialize the <see cref=""Text""/> property with.</param>
	|        public View(int x, int y, ustring text) : this(TextFormatter.CalcRect(x, y, text), text) { }
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""View""/> using <see cref=""Terminal.Gui.LayoutStyle.Absolute""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///   The <see cref=""View""/> will be created at the given
	|        ///   coordinates with the given string. The initial size (<see cref=""View.Frame""/>) will be 
	|        ///   adjusted to fit the contents of <see cref=""Text""/>, including newlines ('\n') for multiple lines. 
	|        /// </para>
	|        /// <para>
	|        ///   If <c>rect.Height</c> is greater than one, word wrapping is provided.
	|        /// </para>
	|        /// </remarks>
	|        /// <param name=""rect"">Location.</param>
	|        /// <param name=""text"">text to initialize the <see cref=""Text""/> property with.</param>
	|        /// <param name=""border"">The <see cref=""Border""/>.</param>
	|        public View(Rect rect, ustring text, Border border = null)
	|        {
	|            Initialize(text, rect, LayoutStyle.Absolute, TextDirection.LeftRight_TopBottom, border);
	|        }
	|
	|        /// <summary>
	|        ///   Initializes a new instance of <see cref=""View""/> using <see cref=""Terminal.Gui.LayoutStyle.Computed""/> layout.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///   The <see cref=""View""/> will be created using <see cref=""Terminal.Gui.LayoutStyle.Computed""/>
	|        ///   coordinates with the given string. The initial size (<see cref=""View.Frame""/>) will be 
	|        ///   adjusted to fit the contents of <see cref=""Text""/>, including newlines ('\n') for multiple lines. 
	|        /// </para>
	|        /// <para>
	|        ///   If <see cref=""Height""/> is greater than one, word wrapping is provided.
	|        /// </para>
	|        /// </remarks>
	|        /// <param name=""text"">text to initialize the <see cref=""Text""/> property with.</param>
	|        /// <param name=""direction"">The text direction.</param>
	|        /// <param name=""border"">The <see cref=""Border""/>.</param>
	|        public View(ustring text, TextDirection direction = TextDirection.LeftRight_TopBottom, Border border = null)
	|        {
	|            Initialize(text, Rect.Empty, LayoutStyle.Computed, direction, border);
	|        }
	|
	|        void Initialize(ustring text, Rect rect, LayoutStyle layoutStyle = LayoutStyle.Computed,
	|            TextDirection direction = TextDirection.LeftRight_TopBottom, Border border = null)
	|        {
	|            TextFormatter = new TextFormatter();
	|            TextFormatter.HotKeyChanged += TextFormatter_HotKeyChanged;
	|            TextDirection = direction;
	|            Border = border;
	|            if (Border != null)
	|            {
	|                Border.Child = this;
	|            }
	|            shortcutHelper = new ShortcutHelper();
	|            CanFocus = false;
	|            TabIndex = -1;
	|            TabStop = false;
	|            LayoutStyle = layoutStyle;
	|            // BUGBUG: CalcRect doesn't account for line wrapping
	|
	|            var r = rect.IsEmpty ? TextFormatter.CalcRect(0, 0, text, direction) : rect;
	|            Frame = r;
	|
	|            Text = text;
	|            UpdateTextFormatterText();
	|            ProcessResizeView();
	|        }
	|
	|        /// <summary>
	|        /// Can be overridden if the <see cref=""Terminal.Gui.TextFormatter.Text""/> has
	|        ///  different format than the default.
	|        /// </summary>
	|        protected virtual void UpdateTextFormatterText()
	|        {
	|            TextFormatter.Text = text;
	|        }
	|
	|        /// <summary>
	|        /// Can be overridden if the view resize behavior is
	|        ///  different than the default.
	|        /// </summary>
	|        protected virtual void ProcessResizeView()
	|        {
	|            var actX = x is Pos.PosAbsolute ? x.Anchor(0) : frame.X;
	|            var actY = y is Pos.PosAbsolute ? y.Anchor(0) : frame.Y;
	|            Rect oldFrame = frame;
	|
	|            if (AutoSize)
	|            {
	|                var s = GetAutoSize();
	|                var w = width is Dim.DimAbsolute && width.Anchor(0) > s.Width ? width.Anchor(0) : s.Width;
	|                var h = height is Dim.DimAbsolute && height.Anchor(0) > s.Height ? height.Anchor(0) : s.Height;
	|                frame = new Rect(new Point(actX, actY), new Size(w, h));
	|            }
	|            else
	|            {
	|                var w = width is Dim.DimAbsolute ? width.Anchor(0) : frame.Width;
	|                var h = height is Dim.DimAbsolute ? height.Anchor(0) : frame.Height;
	|                frame = new Rect(new Point(actX, actY), new Size(w, h));
	|                SetMinWidthHeight();
	|            }
	|            TextFormatter.Size = GetBoundsTextFormatterSize();
	|            SetNeedsLayout();
	|            SetNeedsDisplay();
	|        }
	|
	|        void TextFormatter_HotKeyChanged(Key obj)
	|        {
	|            HotKeyChanged?.Invoke(obj);
	|        }
	|
	|        /// <summary>
	|        /// Sets a flag indicating this view needs to be redisplayed because its state has changed.
	|        /// </summary>
	|        public void SetNeedsDisplay()
	|        {
	|            SetNeedsDisplay(Bounds);
	|        }
	|
	|        internal bool LayoutNeeded { get; private set; } = true;
	|
	|        internal void SetNeedsLayout()
	|        {
	|            if (LayoutNeeded)
	|                return;
	|            LayoutNeeded = true;
	|            if (SuperView == null)
	|                return;
	|            SuperView.SetNeedsLayout();
	|            foreach (var view in Subviews)
	|            {
	|                view.SetNeedsLayout();
	|            }
	|            TextFormatter.NeedsFormat = true;
	|        }
	|
	|        /// <summary>
	|        /// Removes the <see cref=""SetNeedsLayout""/> setting on this view.
	|        /// </summary>
	|        protected void ClearLayoutNeeded()
	|        {
	|            LayoutNeeded = false;
	|        }
	|
	|        /// <summary>
	|        /// Flags the view-relative region on this View as needing to be repainted.
	|        /// </summary>
	|        /// <param name=""region"">The view-relative region that must be flagged for repaint.</param>
	|        public void SetNeedsDisplay(Rect region)
	|        {
	|            if (NeedDisplay.IsEmpty)
	|                NeedDisplay = region;
	|            else
	|            {
	|                var x = Math.Min(NeedDisplay.X, region.X);
	|                var y = Math.Min(NeedDisplay.Y, region.Y);
	|                var w = Math.Max(NeedDisplay.Width, region.Width);
	|                var h = Math.Max(NeedDisplay.Height, region.Height);
	|                NeedDisplay = new Rect(x, y, w, h);
	|            }
	|            container?.SetChildNeedsDisplay();
	|
	|            if (subviews == null)
	|                return;
	|
	|            foreach (var view in subviews)
	|                if (view.Frame.IntersectsWith(region))
	|                {
	|                    var childRegion = Rect.Intersect(view.Frame, region);
	|                    childRegion.X -= view.Frame.X;
	|                    childRegion.Y -= view.Frame.Y;
	|                    view.SetNeedsDisplay(childRegion);
	|                }
	|        }
	|
	|        internal bool ChildNeedsDisplay { get; private set; }
	|
	|        /// <summary>
	|        /// Indicates that any child views (in the <see cref=""Subviews""/> list) need to be repainted.
	|        /// </summary>
	|        public void SetChildNeedsDisplay()
	|        {
	|            ChildNeedsDisplay = true;
	|            if (container != null)
	|                container.SetChildNeedsDisplay();
	|        }
	|
	|        internal bool addingView;
	|
	|        /// <summary>
	|        ///   Adds a subview (child) to this view.
	|        /// </summary>
	|        /// <remarks>
	|        /// The Views that have been added to this view can be retrieved via the <see cref=""Subviews""/> property. 
	|        /// See also <seealso cref=""Remove(View)""/> <seealso cref=""RemoveAll""/> 
	|        /// </remarks>
	|        public virtual void Add(View view)
	|        {
	|            if (view == null)
	|                return;
	|            if (subviews == null)
	|            {
	|                subviews = new List<View>();
	|            }
	|            if (tabIndexes == null)
	|            {
	|                tabIndexes = new List<View>();
	|            }
	|            subviews.Add(view);
	|            tabIndexes.Add(view);
	|            view.container = this;
	|            if (view.CanFocus)
	|            {
	|                addingView = true;
	|                if (SuperView?.CanFocus == false)
	|                {
	|                    SuperView.addingView = true;
	|                    SuperView.CanFocus = true;
	|                    SuperView.addingView = false;
	|                }
	|                CanFocus = true;
	|                view.tabIndex = tabIndexes.IndexOf(view);
	|                addingView = false;
	|            }
	|            if (view.Enabled && !Enabled)
	|            {
	|                view.oldEnabled = true;
	|                view.Enabled = false;
	|            }
	|            SetNeedsLayout();
	|            SetNeedsDisplay();
	|            OnAdded(view);
	|            if (IsInitialized)
	|            {
	|                view.BeginInit();
	|                view.EndInit();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Adds the specified views (children) to the view.
	|        /// </summary>
	|        /// <param name=""views"">Array of one or more views (can be optional parameter).</param>
	|        /// <remarks>
	|        /// The Views that have been added to this view can be retrieved via the <see cref=""Subviews""/> property. 
	|        /// See also <seealso cref=""Remove(View)""/> <seealso cref=""RemoveAll""/> 
	|        /// </remarks>
	|        public void Add(params View[] views)
	|        {
	|            if (views == null)
	|                return;
	|            foreach (var view in views)
	|                Add(view);
	|        }
	|
	|        /// <summary>
	|        ///   Removes all subviews (children) added via <see cref=""Add(View)""/> or <see cref=""Add(View[])""/> from this View.
	|        /// </summary>
	|        public virtual void RemoveAll()
	|        {
	|            if (subviews == null)
	|                return;
	|
	|            while (subviews.Count > 0)
	|            {
	|                Remove(subviews[0]);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Removes a subview added via <see cref=""Add(View)""/> or <see cref=""Add(View[])""/> from this View.
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        public virtual void Remove(View view)
	|        {
	|            if (view == null || subviews == null)
	|                return;
	|
	|            var touched = view.Frame;
	|            subviews.Remove(view);
	|            tabIndexes.Remove(view);
	|            view.container = null;
	|            view.tabIndex = -1;
	|            SetNeedsLayout();
	|            SetNeedsDisplay();
	|            foreach (var v in subviews)
	|            {
	|                if (v.Frame.IntersectsWith(touched))
	|                    view.SetNeedsDisplay();
	|            }
	|            OnRemoved(view);
	|            if (focused == view)
	|            {
	|                focused = null;
	|            }
	|        }
	|
	|        void PerformActionForSubview(View subview, Action<View> action)
	|        {
	|            if (subviews.Contains(subview))
	|            {
	|                action(subview);
	|            }
	|
	|            SetNeedsDisplay();
	|            subview.SetNeedsDisplay();
	|        }
	|
	|        /// <summary>
	|        /// Brings the specified subview to the front so it is drawn on top of any other views.
	|        /// </summary>
	|        /// <param name=""subview"">The subview to send to the front</param>
	|        /// <remarks>
	|        ///   <seealso cref=""SendSubviewToBack""/>.
	|        /// </remarks>
	|        public void BringSubviewToFront(View subview)
	|        {
	|            PerformActionForSubview(subview, x =>
	|            {
	|                subviews.Remove(x);
	|                subviews.Add(x);
	|            });
	|        }
	|
	|        /// <summary>
	|        /// Sends the specified subview to the front so it is the first view drawn
	|        /// </summary>
	|        /// <param name=""subview"">The subview to send to the front</param>
	|        /// <remarks>
	|        ///   <seealso cref=""BringSubviewToFront(View)""/>.
	|        /// </remarks>
	|        public void SendSubviewToBack(View subview)
	|        {
	|            PerformActionForSubview(subview, x =>
	|            {
	|                subviews.Remove(x);
	|                subviews.Insert(0, subview);
	|            });
	|        }
	|
	|        /// <summary>
	|        /// Moves the subview backwards in the hierarchy, only one step
	|        /// </summary>
	|        /// <param name=""subview"">The subview to send backwards</param>
	|        /// <remarks>
	|        /// If you want to send the view all the way to the back use SendSubviewToBack.
	|        /// </remarks>
	|        public void SendSubviewBackwards(View subview)
	|        {
	|            PerformActionForSubview(subview, x =>
	|            {
	|                var idx = subviews.IndexOf(x);
	|                if (idx > 0)
	|                {
	|                    subviews.Remove(x);
	|                    subviews.Insert(idx - 1, x);
	|                }
	|            });
	|        }
	|
	|        /// <summary>
	|        /// Moves the subview backwards in the hierarchy, only one step
	|        /// </summary>
	|        /// <param name=""subview"">The subview to send backwards</param>
	|        /// <remarks>
	|        /// If you want to send the view all the way to the back use SendSubviewToBack.
	|        /// </remarks>
	|        public void BringSubviewForward(View subview)
	|        {
	|            PerformActionForSubview(subview, x =>
	|            {
	|                var idx = subviews.IndexOf(x);
	|                if (idx + 1 < subviews.Count)
	|                {
	|                    subviews.Remove(x);
	|                    subviews.Insert(idx + 1, x);
	|                }
	|            });
	|        }
	|
	|        /// <summary>
	|        ///   Clears the view region with the current color.
	|        /// </summary>
	|        /// <remarks>
	|        ///   <para>
	|        ///     This clears the entire region used by this view.
	|        ///   </para>
	|        /// </remarks>
	|        public void Clear()
	|        {
	|            var h = Frame.Height;
	|            var w = Frame.Width;
	|            for (var line = 0; line < h; line++)
	|            {
	|                Move(0, line);
	|                for (var col = 0; col < w; col++)
	|                    Driver.AddRune(' ');
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Clears the specified region with the current color. 
	|        /// </summary>
	|        /// <remarks>
	|        /// </remarks>
	|        /// <param name=""regionScreen"">The screen-relative region to clear.</param>
	|        public void Clear(Rect regionScreen)
	|        {
	|            var h = regionScreen.Height;
	|            var w = regionScreen.Width;
	|            for (var line = regionScreen.Y; line < regionScreen.Y + h; line++)
	|            {
	|                Driver.Move(regionScreen.X, line);
	|                for (var col = 0; col < w; col++)
	|                    Driver.AddRune(' ');
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Converts a view-relative (col,row) position to a screen-relative position (col,row). The values are optionally clamped to the screen dimensions.
	|        /// </summary>
	|        /// <param name=""col"">View-relative column.</param>
	|        /// <param name=""row"">View-relative row.</param>
	|        /// <param name=""rcol"">Absolute column; screen-relative.</param>
	|        /// <param name=""rrow"">Absolute row; screen-relative.</param>
	|        /// <param name=""clipped"">Whether to clip the result of the ViewToScreen method, if set to <see langword=""true""/>, the rcol, rrow values are clamped to the screen (terminal) dimensions (0..TerminalDim-1).</param>
	|        internal void ViewToScreen(int col, int row, out int rcol, out int rrow, bool clipped = false)
	|        {
	|            // Computes the real row, col relative to the screen.
	|            rrow = row + frame.Y;
	|            rcol = col + frame.X;
	|
	|            var curContainer = container;
	|            while (curContainer != null)
	|            {
	|                rrow += curContainer.frame.Y;
	|                rcol += curContainer.frame.X;
	|                curContainer = curContainer.container;
	|            }
	|
	|            // The following ensures that the cursor is always in the screen boundaries.
	|            if (clipped)
	|            {
	|                rrow = Math.Min(rrow, Driver.Rows - 1);
	|                rcol = Math.Min(rcol, Driver.Cols - 1);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Converts a point from screen-relative coordinates to view-relative coordinates.
	|        /// </summary>
	|        /// <returns>The mapped point.</returns>
	|        /// <param name=""x"">X screen-coordinate point.</param>
	|        /// <param name=""y"">Y screen-coordinate point.</param>
	|        public Point ScreenToView(int x, int y)
	|        {
	|            if (SuperView == null)
	|            {
	|                return new Point(x - Frame.X, y - frame.Y);
	|            }
	|            else
	|            {
	|                var parent = SuperView.ScreenToView(x, y);
	|                return new Point(parent.X - frame.X, parent.Y - frame.Y);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Converts a region in view-relative coordinates to screen-relative coordinates.
	|        /// </summary>
	|        internal Rect ViewToScreen(Rect region)
	|        {
	|            ViewToScreen(region.X, region.Y, out var x, out var y, clipped: false);
	|            return new Rect(x, y, region.Width, region.Height);
	|        }
	|
	|        // Clips a rectangle in screen coordinates to the dimensions currently available on the screen
	|        internal Rect ScreenClip(Rect regionScreen)
	|        {
	|            var x = regionScreen.X < 0 ? 0 : regionScreen.X;
	|            var y = regionScreen.Y < 0 ? 0 : regionScreen.Y;
	|            var w = regionScreen.X + regionScreen.Width >= Driver.Cols ? Driver.Cols - regionScreen.X : regionScreen.Width;
	|            var h = regionScreen.Y + regionScreen.Height >= Driver.Rows ? Driver.Rows - regionScreen.Y : regionScreen.Height;
	|
	|            return new Rect(x, y, w, h);
	|        }
	|
	|        /// <summary>
	|        /// Sets the <see cref=""ConsoleDriver""/>'s clip region to the current View's <see cref=""Bounds""/>.
	|        /// </summary>
	|        /// <returns>The existing driver's clip region, which can be then re-applied by setting <c><see cref=""Driver""/>.Clip</c> (<see cref=""ConsoleDriver.Clip""/>).</returns>
	|        /// <remarks>
	|        /// <see cref=""Bounds""/> is View-relative.
	|        /// </remarks>
	|        public Rect ClipToBounds()
	|        {
	|            return SetClip(Bounds);
	|        }
	|
	|        /// <summary>
	|        /// Sets the clip region to the specified view-relative region.
	|        /// </summary>
	|        /// <returns>The previous screen-relative clip region.</returns>
	|        /// <param name=""region"">View-relative clip region.</param>
	|        public Rect SetClip(Rect region)
	|        {
	|            var previous = Driver.Clip;
	|            Driver.Clip = Rect.Intersect(previous, ViewToScreen(region));
	|            return previous;
	|        }
	|
	|        /// <summary>
	|        /// Draws a frame in the current view, clipped by the boundary of this view
	|        /// </summary>
	|        /// <param name=""region"">View-relative region for the frame to be drawn.</param>
	|        /// <param name=""padding"">The padding to add around the outside of the drawn frame.</param>
	|        /// <param name=""fill"">If set to <see langword=""true""/> it fill will the contents.</param>
	|        public void DrawFrame(Rect region, int padding = 0, bool fill = false)
	|        {
	|            var scrRect = ViewToScreen(region);
	|            var savedClip = ClipToBounds();
	|            Driver.DrawWindowFrame(scrRect, padding + 1, padding + 1, padding + 1, padding + 1, border: true, fill: fill);
	|            Driver.Clip = savedClip;
	|        }
	|
	|        /// <summary>
	|        /// Utility function to draw strings that contain a hotkey.
	|        /// </summary>
	|        /// <param name=""text"">String to display, the hotkey specifier before a letter flags the next letter as the hotkey.</param>
	|        /// <param name=""hotColor"">Hot color.</param>
	|        /// <param name=""normalColor"">Normal color.</param>
	|        /// <remarks>
	|        /// <para>The hotkey is any character following the hotkey specifier, which is the underscore ('_') character by default.</para>
	|        /// <para>The hotkey specifier can be changed via <see cref=""HotKeySpecifier""/></para>
	|        /// </remarks>
	|        public void DrawHotString(ustring text, Attribute hotColor, Attribute normalColor)
	|        {
	|            var hotkeySpec = HotKeySpecifier == (Rune)0xffff ? (Rune)'_' : HotKeySpecifier;
	|            Application.Driver.SetAttribute(normalColor);
	|            foreach (var rune in text)
	|            {
	|                if (rune == hotkeySpec)
	|                {
	|                    Application.Driver.SetAttribute(hotColor);
	|                    continue;
	|                }
	|                Application.Driver.AddRune(rune);
	|                Application.Driver.SetAttribute(normalColor);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Utility function to draw strings that contains a hotkey using a <see cref=""ColorScheme""/> and the ""focused"" state.
	|        /// </summary>
	|        /// <param name=""text"">String to display, the underscore before a letter flags the next letter as the hotkey.</param>
	|        /// <param name=""focused"">If set to <see langword=""true""/> this uses the focused colors from the color scheme, otherwise the regular ones.</param>
	|        /// <param name=""scheme"">The color scheme to use.</param>
	|        public void DrawHotString(ustring text, bool focused, ColorScheme scheme)
	|        {
	|            if (focused)
	|                DrawHotString(text, scheme.HotFocus, scheme.Focus);
	|            else
	|                DrawHotString(text, Enabled ? scheme.HotNormal : scheme.Disabled, Enabled ? scheme.Normal : scheme.Disabled);
	|        }
	|
	|        /// <summary>
	|        /// This moves the cursor to the specified column and row in the view.
	|        /// </summary>
	|        /// <returns>The move.</returns>
	|        /// <param name=""col"">Col.</param>
	|        /// <param name=""row"">Row.</param>
	|        /// <param name=""clipped"">Whether to clip the result of the ViewToScreen method,
	|        ///  if set to <see langword=""true""/>, the col, row values are clamped to the screen (terminal) dimensions (0..TerminalDim-1).</param>
	|        public void Move(int col, int row, bool clipped = false)
	|        {
	|            if (Driver.Rows == 0)
	|            {
	|                return;
	|            }
	|
	|            ViewToScreen(col, row, out var rCol, out var rRow, clipped);
	|            Driver.Move(rCol, rRow);
	|        }
	|
	|        /// <summary>
	|        ///   Positions the cursor in the right position based on the currently focused view in the chain.
	|        /// </summary>
	|        ///    Views that are focusable should override <see cref=""PositionCursor""/> to ensure
	|        ///    the cursor is placed in a location that makes sense. Unix terminals do not have
	|        ///    a way of hiding the cursor, so it can be distracting to have the cursor left at
	|        ///    the last focused view. Views should make sure that they place the cursor
	|        ///    in a visually sensible place.
	|        public virtual void PositionCursor()
	|        {
	|            if (!CanBeVisible(this) || !Enabled)
	|            {
	|                return;
	|            }
	|
	|            if (focused == null && SuperView != null)
	|            {
	|                SuperView.EnsureFocus();
	|            }
	|            else if (focused?.Visible == true && focused?.Enabled == true && focused?.Frame.Width > 0 && focused.Frame.Height > 0)
	|            {
	|                focused.PositionCursor();
	|            }
	|            else if (focused?.Visible == true && focused?.Enabled == false)
	|            {
	|                focused = null;
	|            }
	|            else if (CanFocus && HasFocus && Visible && Frame.Width > 0 && Frame.Height > 0)
	|            {
	|                Move(TextFormatter.HotKeyPos == -1 ? 0 : TextFormatter.CursorPosition, 0);
	|            }
	|            else
	|            {
	|                Move(frame.X, frame.Y);
	|            }
	|        }
	|
	|        bool hasFocus;
	|
	|        /// <inheritdoc/>
	|        public override bool HasFocus => hasFocus;
	|
	|        void SetHasFocus(bool value, View view, bool force = false)
	|        {
	|            if (hasFocus != value || force)
	|            {
	|                hasFocus = value;
	|                if (value)
	|                {
	|                    OnEnter(view);
	|                }
	|                else
	|                {
	|                    OnLeave(view);
	|                }
	|                SetNeedsDisplay();
	|            }
	|
	|            // Remove focus down the chain of subviews if focus is removed
	|            if (!value && focused != null)
	|            {
	|                var f = focused;
	|                f.OnLeave(view);
	|                f.SetHasFocus(false, view);
	|                focused = null;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Defines the event arguments for <see cref=""SetFocus(View)""/>
	|        /// </summary>
	|        public class FocusEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// Constructs.
	|            /// </summary>
	|            /// <param name=""view"">The view that gets or loses focus.</param>
	|            public FocusEventArgs(View view) { View = view; }
	|            /// <summary>
	|            /// Indicates if the current focus event has already been processed and the driver should stop notifying any other event subscriber.
	|            /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
	|            /// </summary>
	|            public bool Handled { get; set; }
	|            /// <summary>
	|            /// Indicates the current view that gets or loses focus.
	|            /// </summary>
	|            public View View { get; set; }
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a subview is being added to this view.
	|        /// </summary>
	|        /// <param name=""view"">The subview being added.</param>
	|        public virtual void OnAdded(View view)
	|        {
	|            view.IsAdded = true;
	|            view.x = view.x ?? view.frame.X;
	|            view.y = view.y ?? view.frame.Y;
	|            view.width = view.width ?? view.frame.Width;
	|            view.height = view.height ?? view.frame.Height;
	|
	|            view.Added?.Invoke(this);
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a subview is being removed from this view.
	|        /// </summary>
	|        /// <param name=""view"">The subview being removed.</param>
	|        public virtual void OnRemoved(View view)
	|        {
	|            view.IsAdded = false;
	|            view.Removed?.Invoke(this);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool OnEnter(View view)
	|        {
	|            var args = new FocusEventArgs(view);
	|            Enter?.Invoke(args);
	|            if (args.Handled)
	|                return true;
	|            if (base.OnEnter(view))
	|                return true;
	|
	|            return false;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool OnLeave(View view)
	|        {
	|            var args = new FocusEventArgs(view);
	|            Leave?.Invoke(args);
	|            if (args.Handled)
	|                return true;
	|            if (base.OnLeave(view))
	|                return true;
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Returns the currently focused view inside this view, or null if nothing is focused.
	|        /// </summary>
	|        /// <value>The focused.</value>
	|        public View Focused => focused;
	|
	|        /// <summary>
	|        /// Returns the most focused view in the chain of subviews (the leaf view that has the focus).
	|        /// </summary>
	|        /// <value>The most focused View.</value>
	|        public View MostFocused
	|        {
	|            get
	|            {
	|                if (Focused == null)
	|                    return null;
	|                var most = Focused.MostFocused;
	|                if (most != null)
	|                    return most;
	|                return Focused;
	|            }
	|        }
	|
	|        ColorScheme colorScheme;
	|
	|        /// <summary>
	|        /// The color scheme for this view, if it is not defined, it returns the <see cref=""SuperView""/>'s
	|        /// color scheme.
	|        /// </summary>
	|        public virtual ColorScheme ColorScheme
	|        {
	|            get
	|            {
	|                if (colorScheme == null)
	|                {
	|                    return SuperView?.ColorScheme;
	|                }
	|                return colorScheme;
	|            }
	|            set
	|            {
	|                if (colorScheme != value)
	|                {
	|                    colorScheme = value;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Displays the specified character in the specified column and row of the View.
	|        /// </summary>
	|        /// <param name=""col"">Column (view-relative).</param>
	|        /// <param name=""row"">Row (view-relative).</param>
	|        /// <param name=""ch"">Ch.</param>
	|        public void AddRune(int col, int row, Rune ch)
	|        {
	|            if (row < 0 || col < 0)
	|                return;
	|            if (row > frame.Height - 1 || col > frame.Width - 1)
	|                return;
	|            Move(col, row);
	|            Driver.AddRune(ch);
	|        }
	|
	|        /// <summary>
	|        /// Removes the <see cref=""SetNeedsDisplay()""/> and the <see cref=""ChildNeedsDisplay""/> setting on this view.
	|        /// </summary>
	|        protected void ClearNeedsDisplay()
	|        {
	|            NeedDisplay = Rect.Empty;
	|            ChildNeedsDisplay = false;
	|        }
	|
	|        /// <summary>
	|        /// Redraws this view and its subviews; only redraws the views that have been flagged for a re-display.
	|        /// </summary>
	|        /// <param name=""bounds"">The bounds (view-relative region) to redraw.</param>
	|        /// <remarks>
	|        /// <para>
	|        ///    Always use <see cref=""Bounds""/> (view-relative) when calling <see cref=""Redraw(Rect)""/>, NOT <see cref=""Frame""/> (superview-relative).
	|        /// </para>
	|        /// <para>
	|        ///    Views should set the color that they want to use on entry, as otherwise this will inherit
	|        ///    the last color that was set globally on the driver.
	|        /// </para>
	|        /// <para>
	|        ///    Overrides of <see cref=""Redraw""/> must ensure they do not set <c>Driver.Clip</c> to a clip region
	|        ///    larger than the <ref name=""bounds""/> parameter, as this will cause the driver to clip the entire region.
	|        /// </para>
	|        /// </remarks>
	|        public virtual void Redraw(Rect bounds)
	|        {
	|            if (!CanBeVisible(this))
	|            {
	|                return;
	|            }
	|
	|            var clipRect = new Rect(Point.Empty, frame.Size);
	|
	|            if (ColorScheme != null)
	|            {
	|                Driver.SetAttribute(HasFocus ? GetFocusColor() : GetNormalColor());
	|            }
	|
	|            if (!IgnoreBorderPropertyOnRedraw && Border != null)
	|            {
	|                Border.DrawContent(this);
	|            }
	|            else if (ustring.IsNullOrEmpty(TextFormatter.Text) &&
	|              (GetType().IsNestedPublic && !IsOverridden(this, ""Redraw"") || GetType().Name == ""View"") &&
	|              (!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded))
	|            {
	|
	|                if (ColorScheme != null)
	|                {
	|                    Driver.SetAttribute(GetNormalColor());
	|                    Clear();
	|                    SetChildNeedsDisplay();
	|                }
	|            }
	|
	|            if (!ustring.IsNullOrEmpty(TextFormatter.Text))
	|            {
	|                Rect containerBounds = GetContainerBounds();
	|                Clear(ViewToScreen(GetNeedDisplay(containerBounds)));
	|                SetChildNeedsDisplay();
	|                // Draw any Text
	|                if (TextFormatter != null)
	|                {
	|                    TextFormatter.NeedsFormat = true;
	|                }
	|                TextFormatter?.Draw(ViewToScreen(Bounds), HasFocus ? GetFocusColor() : GetNormalColor(),
	|                    HasFocus ? ColorScheme.HotFocus : GetHotNormalColor(),
	|                    containerBounds);
	|            }
	|
	|            // Invoke DrawContentEvent
	|            OnDrawContent(bounds);
	|
	|            if (subviews != null)
	|            {
	|                foreach (var view in subviews)
	|                {
	|                    if (!view.NeedDisplay.IsEmpty || view.ChildNeedsDisplay || view.LayoutNeeded)
	|                    {
	|                        if (view.Frame.IntersectsWith(clipRect) && (view.Frame.IntersectsWith(bounds) || bounds.X < 0 || bounds.Y < 0))
	|                        {
	|                            if (view.LayoutNeeded)
	|                                view.LayoutSubviews();
	|
	|                            // Draw the subview
	|                            // Use the view's bounds (view-relative; Location will always be (0,0)
	|                            if (view.Visible && view.Frame.Width > 0 && view.Frame.Height > 0)
	|                            {
	|                                var rect = view.Bounds;
	|                                view.OnDrawContent(rect);
	|                                view.Redraw(rect);
	|                                view.OnDrawContentComplete(rect);
	|                            }
	|                        }
	|                        view.NeedDisplay = Rect.Empty;
	|                        view.ChildNeedsDisplay = false;
	|                    }
	|                }
	|            }
	|
	|            // Invoke DrawContentCompleteEvent
	|            OnDrawContentComplete(bounds);
	|
	|            ClearLayoutNeeded();
	|            ClearNeedsDisplay();
	|        }
	|
	|        Rect GetNeedDisplay(Rect containerBounds)
	|        {
	|            Rect rect = NeedDisplay;
	|            if (!containerBounds.IsEmpty)
	|            {
	|                rect.Width = Math.Min(NeedDisplay.Width, containerBounds.Width);
	|                rect.Height = Math.Min(NeedDisplay.Height, containerBounds.Height);
	|            }
	|
	|            return rect;
	|        }
	|
	|        Rect GetContainerBounds()
	|        {
	|            var containerBounds = SuperView == null ? default : SuperView.ViewToScreen(SuperView.Bounds);
	|            var driverClip = Driver == null ? Rect.Empty : Driver.Clip;
	|            containerBounds.X = Math.Max(containerBounds.X, driverClip.X);
	|            containerBounds.Y = Math.Max(containerBounds.Y, driverClip.Y);
	|            var lenOffset = (driverClip.X + driverClip.Width) - (containerBounds.X + containerBounds.Width);
	|            if (containerBounds.X + containerBounds.Width > driverClip.X + driverClip.Width)
	|            {
	|                containerBounds.Width = Math.Max(containerBounds.Width + lenOffset, 0);
	|            }
	|            else
	|            {
	|                containerBounds.Width = Math.Min(containerBounds.Width, driverClip.Width);
	|            }
	|            lenOffset = (driverClip.Y + driverClip.Height) - (containerBounds.Y + containerBounds.Height);
	|            if (containerBounds.Y + containerBounds.Height > driverClip.Y + driverClip.Height)
	|            {
	|                containerBounds.Height = Math.Max(containerBounds.Height + lenOffset, 0);
	|            }
	|            else
	|            {
	|                containerBounds.Height = Math.Min(containerBounds.Height, driverClip.Height);
	|            }
	|            return containerBounds;
	|        }
	|
	|        /// <summary>
	|        /// Event invoked when the content area of the View is to be drawn.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        /// Will be invoked before any subviews added with <see cref=""Add(View)""/> have been drawn.
	|        /// </para>
	|        /// <para>
	|        /// Rect provides the view-relative rectangle describing the currently visible viewport into the <see cref=""View""/>.
	|        /// </para>
	|        /// </remarks>
	|        public event Action<Rect> DrawContent;
	|
	|        /// <summary>
	|        /// Enables overrides to draw infinitely scrolled content and/or a background behind added controls. 
	|        /// </summary>
	|        /// <param name=""viewport"">The view-relative rectangle describing the currently visible viewport into the <see cref=""View""/></param>
	|        /// <remarks>
	|        /// This method will be called before any subviews added with <see cref=""Add(View)""/> have been drawn. 
	|        /// </remarks>
	|        public virtual void OnDrawContent(Rect viewport)
	|        {
	|            DrawContent?.Invoke(viewport);
	|        }
	|
	|        /// <summary>
	|        /// Event invoked when the content area of the View is completed drawing.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        /// Will be invoked after any subviews removed with <see cref=""Remove(View)""/> have been completed drawing.
	|        /// </para>
	|        /// <para>
	|        /// Rect provides the view-relative rectangle describing the currently visible viewport into the <see cref=""View""/>.
	|        /// </para>
	|        /// </remarks>
	|        public event Action<Rect> DrawContentComplete;
	|
	|        /// <summary>
	|        /// Enables overrides after completed drawing infinitely scrolled content and/or a background behind removed controls.
	|        /// </summary>
	|        /// <param name=""viewport"">The view-relative rectangle describing the currently visible viewport into the <see cref=""View""/></param>
	|        /// <remarks>
	|        /// This method will be called after any subviews removed with <see cref=""Remove(View)""/> have been completed drawing.
	|        /// </remarks>
	|        public virtual void OnDrawContentComplete(Rect viewport)
	|        {
	|            DrawContentComplete?.Invoke(viewport);
	|        }
	|
	|        /// <summary>
	|        /// Causes the specified subview to have focus.
	|        /// </summary>
	|        /// <param name=""view"">View.</param>
	|        void SetFocus(View view)
	|        {
	|            if (view == null)
	|                return;
	|            //Console.WriteLine ($""Request to focus {view}"");
	|            if (!view.CanFocus || !view.Visible || !view.Enabled)
	|                return;
	|            if (focused?.hasFocus == true && focused == view)
	|                return;
	|
	|            // Make sure that this view is a subview
	|            View c;
	|            for (c = view.container; c != null; c = c.container)
	|                if (c == this)
	|                    break;
	|            if (c == null)
	|                throw new ArgumentException(""the specified view is not part of the hierarchy of this view"");
	|
	|            if (focused != null)
	|                focused.SetHasFocus(false, view);
	|
	|            var f = focused;
	|            focused = view;
	|            focused.SetHasFocus(true, f);
	|            focused.EnsureFocus();
	|
	|            // Send focus upwards
	|            SuperView?.SetFocus(this);
	|        }
	|
	|        /// <summary>
	|        /// Causes the specified view and the entire parent hierarchy to have the focused order updated.
	|        /// </summary>
	|        public void SetFocus()
	|        {
	|            if (!CanBeVisible(this) || !Enabled)
	|            {
	|                if (HasFocus)
	|                {
	|                    SetHasFocus(false, this);
	|                }
	|                return;
	|            }
	|
	|            SuperView?.SetFocus(this);
	|        }
	|
	|        /// <summary>
	|        /// Defines the event arguments for <see cref=""KeyEvent""/>
	|        /// </summary>
	|        public class KeyEventEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// Constructs.
	|            /// </summary>
	|            /// <param name=""ke""></param>
	|            public KeyEventEventArgs(KeyEvent ke) => KeyEvent = ke;
	|            /// <summary>
	|            /// The <see cref=""KeyEvent""/> for the event.
	|            /// </summary>
	|            public KeyEvent KeyEvent { get; set; }
	|            /// <summary>
	|            /// Indicates if the current Key event has already been processed and the driver should stop notifying any other event subscriber.
	|            /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
	|            /// </summary>
	|            public bool Handled { get; set; } = false;
	|        }
	|
	|        /// <summary>
	|        /// Invoked when a character key is pressed and occurs after the key up event.
	|        /// </summary>
	|        public event Action<KeyEventEventArgs> KeyPress;
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessKey(KeyEvent keyEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            var args = new KeyEventEventArgs(keyEvent);
	|            KeyPress?.Invoke(args);
	|            if (args.Handled)
	|                return true;
	|            if (Focused?.Enabled == true)
	|            {
	|                Focused?.KeyPress?.Invoke(args);
	|                if (args.Handled)
	|                    return true;
	|            }
	|
	|            return Focused?.Enabled == true && Focused?.ProcessKey(keyEvent) == true;
	|        }
	|
	|        /// <summary>
	|        /// Invokes any binding that is registered on this <see cref=""View""/>
	|        /// and matches the <paramref name=""keyEvent""/>
	|        /// </summary>
	|        /// <param name=""keyEvent"">The key event passed.</param>
	|        protected bool? InvokeKeybindings(KeyEvent keyEvent)
	|        {
	|            bool? toReturn = null;
	|
	|            if (KeyBindings.ContainsKey(keyEvent.Key))
	|            {
	|
	|                foreach (var command in KeyBindings[keyEvent.Key])
	|                {
	|
	|                    if (!CommandImplementations.ContainsKey(command))
	|                    {
	|                        throw new NotSupportedException($""A KeyBinding was set up for the command {command} ({keyEvent.Key}) but that command is not supported by this View ({GetType().Name})"");
	|                    }
	|
	|                    // each command has its own return value
	|                    var thisReturn = CommandImplementations[command]();
	|
	|                    // if we haven't got anything yet, the current command result should be used
	|                    if (toReturn == null)
	|                    {
	|                        toReturn = thisReturn;
	|                    }
	|
	|                    // if ever see a true then that's what we will return
	|                    if (thisReturn ?? false)
	|                    {
	|                        toReturn = true;
	|                    }
	|                }
	|            }
	|
	|            return toReturn;
	|        }
	|
	|
	|        /// <summary>
	|        /// <para>Adds a new key combination that will trigger the given <paramref name=""command""/>
	|        /// (if supported by the View - see <see cref=""GetSupportedCommands""/>)
	|        /// </para>
	|        /// <para>If the key is already bound to a different <see cref=""Command""/> it will be
	|        /// rebound to this one</para>
	|        /// <remarks>Commands are only ever applied to the current <see cref=""View""/>(i.e. this feature
	|        /// cannot be used to switch focus to another view and perform multiple commands there) </remarks>
	|        /// </summary>
	|        /// <param name=""key""></param>
	|        /// <param name=""command"">The command(s) to run on the <see cref=""View""/> when <paramref name=""key""/> is pressed.
	|        /// When specifying multiple commands, all commands will be applied in sequence. The bound <paramref name=""key""/> strike
	|        /// will be consumed if any took effect.</param>
	|        public void AddKeyBinding(Key key, params Command[] command)
	|        {
	|            if (command.Length == 0)
	|            {
	|                throw new ArgumentException(""At least one command must be specified"", nameof(command));
	|            }
	|
	|            if (KeyBindings.ContainsKey(key))
	|            {
	|                KeyBindings[key] = command;
	|            }
	|            else
	|            {
	|                KeyBindings.Add(key, command);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Replaces a key combination already bound to <see cref=""Command""/>.
	|        /// </summary>
	|        /// <param name=""fromKey"">The key to be replaced.</param>
	|        /// <param name=""toKey"">The new key to be used.</param>
	|        protected void ReplaceKeyBinding(Key fromKey, Key toKey)
	|        {
	|            if (KeyBindings.ContainsKey(fromKey))
	|            {
	|                var value = KeyBindings[fromKey];
	|                KeyBindings.Remove(fromKey);
	|                KeyBindings[toKey] = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Checks if the key binding already exists.
	|        /// </summary>
	|        /// <param name=""key"">The key to check.</param>
	|        /// <returns><see langword=""true""/> If the key already exist, <see langword=""false""/> otherwise.</returns>
	|        public bool ContainsKeyBinding(Key key)
	|        {
	|            return KeyBindings.ContainsKey(key);
	|        }
	|
	|        /// <summary>
	|        /// Removes all bound keys from the View and resets the default bindings.
	|        /// </summary>
	|        public void ClearKeybindings()
	|        {
	|            KeyBindings.Clear();
	|        }
	|
	|        /// <summary>
	|        /// Clears the existing keybinding (if any) for the given <paramref name=""key""/>.
	|        /// </summary>
	|        /// <param name=""key""></param>
	|        public void ClearKeybinding(Key key)
	|        {
	|            KeyBindings.Remove(key);
	|        }
	|
	|        /// <summary>
	|        /// Removes all key bindings that trigger the given command. Views can have multiple different
	|        /// keys bound to the same command and this method will clear all of them.
	|        /// </summary>
	|        /// <param name=""command""></param>
	|        public void ClearKeybinding(params Command[] command)
	|        {
	|            foreach (var kvp in KeyBindings.Where(kvp => kvp.Value.SequenceEqual(command)).ToArray())
	|            {
	|                KeyBindings.Remove(kvp.Key);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// <para>States that the given <see cref=""View""/> supports a given <paramref name=""command""/>
	|        /// and what <paramref name=""f""/> to perform to make that command happen
	|        /// </para>
	|        /// <para>If the <paramref name=""command""/> already has an implementation the <paramref name=""f""/>
	|        /// will replace the old one</para>
	|        /// </summary>
	|        /// <param name=""command"">The command.</param>
	|        /// <param name=""f"">The function.</param>
	|        protected void AddCommand(Command command, Func<bool?> f)
	|        {
	|            // if there is already an implementation of this command
	|            if (CommandImplementations.ContainsKey(command))
	|            {
	|                // replace that implementation
	|                CommandImplementations[command] = f;
	|            }
	|            else
	|            {
	|                // else record how to perform the action (this should be the normal case)
	|                CommandImplementations.Add(command, f);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns all commands that are supported by this <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns></returns>
	|        public IEnumerable<Command> GetSupportedCommands()
	|        {
	|            return CommandImplementations.Keys;
	|        }
	|
	|        /// <summary>
	|        /// Gets the key used by a command.
	|        /// </summary>
	|        /// <param name=""command"">The command to search.</param>
	|        /// <returns>The <see cref=""Key""/> used by a <see cref=""Command""/></returns>
	|        public Key GetKeyFromCommand(params Command[] command)
	|        {
	|            return KeyBindings.First(kb => kb.Value.SequenceEqual(command)).Key;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessHotKey(KeyEvent keyEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            var args = new KeyEventEventArgs(keyEvent);
	|            if (MostFocused?.Enabled == true)
	|            {
	|                MostFocused?.KeyPress?.Invoke(args);
	|                if (args.Handled)
	|                    return true;
	|            }
	|            if (MostFocused?.Enabled == true && MostFocused?.ProcessKey(keyEvent) == true)
	|                return true;
	|            if (subviews == null || subviews.Count == 0)
	|                return false;
	|
	|            foreach (var view in subviews)
	|                if (view.Enabled && view.ProcessHotKey(keyEvent))
	|                    return true;
	|            return false;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool ProcessColdKey(KeyEvent keyEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            var args = new KeyEventEventArgs(keyEvent);
	|            KeyPress?.Invoke(args);
	|            if (args.Handled)
	|                return true;
	|            if (MostFocused?.Enabled == true)
	|            {
	|                MostFocused?.KeyPress?.Invoke(args);
	|                if (args.Handled)
	|                    return true;
	|            }
	|            if (MostFocused?.Enabled == true && MostFocused?.ProcessKey(keyEvent) == true)
	|                return true;
	|            if (subviews == null || subviews.Count == 0)
	|                return false;
	|
	|            foreach (var view in subviews)
	|                if (view.Enabled && view.ProcessColdKey(keyEvent))
	|                    return true;
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Invoked when a key is pressed.
	|        /// </summary>
	|        public event Action<KeyEventEventArgs> KeyDown;
	|
	|        /// <inheritdoc/>
	|        public override bool OnKeyDown(KeyEvent keyEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            var args = new KeyEventEventArgs(keyEvent);
	|            KeyDown?.Invoke(args);
	|            if (args.Handled)
	|            {
	|                return true;
	|            }
	|            if (Focused?.Enabled == true)
	|            {
	|                Focused.KeyDown?.Invoke(args);
	|                if (args.Handled)
	|                {
	|                    return true;
	|                }
	|                if (Focused?.OnKeyDown(keyEvent) == true)
	|                {
	|                    return true;
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Invoked when a key is released.
	|        /// </summary>
	|        public event Action<KeyEventEventArgs> KeyUp;
	|
	|        /// <inheritdoc/>
	|        public override bool OnKeyUp(KeyEvent keyEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return false;
	|            }
	|
	|            var args = new KeyEventEventArgs(keyEvent);
	|            KeyUp?.Invoke(args);
	|            if (args.Handled)
	|            {
	|                return true;
	|            }
	|            if (Focused?.Enabled == true)
	|            {
	|                Focused.KeyUp?.Invoke(args);
	|                if (args.Handled)
	|                {
	|                    return true;
	|                }
	|                if (Focused?.OnKeyUp(keyEvent) == true)
	|                {
	|                    return true;
	|                }
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Finds the first view in the hierarchy that wants to get the focus if nothing is currently focused, otherwise, does nothing.
	|        /// </summary>
	|        public void EnsureFocus()
	|        {
	|            if (focused == null && subviews?.Count > 0)
	|            {
	|                if (FocusDirection == Direction.Forward)
	|                {
	|                    FocusFirst();
	|                }
	|                else
	|                {
	|                    FocusLast();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Focuses the first focusable subview if one exists.
	|        /// </summary>
	|        public void FocusFirst()
	|        {
	|            if (!CanBeVisible(this))
	|            {
	|                return;
	|            }
	|
	|            if (tabIndexes == null)
	|            {
	|                SuperView?.SetFocus(this);
	|                return;
	|            }
	|
	|            foreach (var view in tabIndexes)
	|            {
	|                if (view.CanFocus && view.tabStop && view.Visible && view.Enabled)
	|                {
	|                    SetFocus(view);
	|                    return;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Focuses the last focusable subview if one exists.
	|        /// </summary>
	|        public void FocusLast()
	|        {
	|            if (!CanBeVisible(this))
	|            {
	|                return;
	|            }
	|
	|            if (tabIndexes == null)
	|            {
	|                SuperView?.SetFocus(this);
	|                return;
	|            }
	|
	|            for (var i = tabIndexes.Count; i > 0;)
	|            {
	|                i--;
	|
	|                var v = tabIndexes[i];
	|                if (v.CanFocus && v.tabStop && v.Visible && v.Enabled)
	|                {
	|                    SetFocus(v);
	|                    return;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Focuses the previous view.
	|        /// </summary>
	|        /// <returns><see langword=""true""/> if previous was focused, <see langword=""false""/> otherwise.</returns>
	|        public bool FocusPrev()
	|        {
	|            if (!CanBeVisible(this))
	|            {
	|                return false;
	|            }
	|
	|            FocusDirection = Direction.Backward;
	|            if (tabIndexes == null || tabIndexes.Count == 0)
	|                return false;
	|
	|            if (focused == null)
	|            {
	|                FocusLast();
	|                return focused != null;
	|            }
	|
	|            var focusedIdx = -1;
	|            for (var i = tabIndexes.Count; i > 0;)
	|            {
	|                i--;
	|                var w = tabIndexes[i];
	|
	|                if (w.HasFocus)
	|                {
	|                    if (w.FocusPrev())
	|                        return true;
	|                    focusedIdx = i;
	|                    continue;
	|                }
	|                if (w.CanFocus && focusedIdx != -1 && w.tabStop && w.Visible && w.Enabled)
	|                {
	|                    focused.SetHasFocus(false, w);
	|
	|                    if (w.CanFocus && w.tabStop && w.Visible && w.Enabled)
	|                        w.FocusLast();
	|
	|                    SetFocus(w);
	|                    return true;
	|                }
	|            }
	|            if (focused != null)
	|            {
	|                focused.SetHasFocus(false, this);
	|                focused = null;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Focuses the next view.
	|        /// </summary>
	|        /// <returns><see langword=""true""/> if next was focused, <see langword=""false""/> otherwise.</returns>
	|        public bool FocusNext()
	|        {
	|            if (!CanBeVisible(this))
	|            {
	|                return false;
	|            }
	|
	|            FocusDirection = Direction.Forward;
	|            if (tabIndexes == null || tabIndexes.Count == 0)
	|                return false;
	|
	|            if (focused == null)
	|            {
	|                FocusFirst();
	|                return focused != null;
	|            }
	|            var n = tabIndexes.Count;
	|            var focusedIdx = -1;
	|            for (var i = 0; i < n; i++)
	|            {
	|                var w = tabIndexes[i];
	|
	|                if (w.HasFocus)
	|                {
	|                    if (w.FocusNext())
	|                        return true;
	|                    focusedIdx = i;
	|                    continue;
	|                }
	|                if (w.CanFocus && focusedIdx != -1 && w.tabStop && w.Visible && w.Enabled)
	|                {
	|                    focused.SetHasFocus(false, w);
	|
	|                    if (w.CanFocus && w.tabStop && w.Visible && w.Enabled)
	|                        w.FocusFirst();
	|
	|                    SetFocus(w);
	|                    return true;
	|                }
	|            }
	|            if (focused != null)
	|            {
	|                focused.SetHasFocus(false, this);
	|                focused = null;
	|            }
	|            return false;
	|        }
	|
	|        View GetMostFocused(View view)
	|        {
	|            if (view == null)
	|            {
	|                return null;
	|            }
	|
	|            return view.focused != null ? GetMostFocused(view.focused) : view;
	|        }
	|
	|        /// <summary>
	|        /// Sets the View's <see cref=""Frame""/> to the relative coordinates if its container, given the <see cref=""Frame""/> for its container.
	|        /// </summary>
	|        /// <param name=""hostFrame"">The screen-relative frame for the host.</param>
	|        /// <remarks>
	|        /// Reminder: <see cref=""Frame""/> is superview-relative; <see cref=""Bounds""/> is view-relative.
	|        /// </remarks>
	|        internal void SetRelativeLayout(Rect hostFrame)
	|        {
	|            int actW, actH, actX, actY;
	|            var s = Size.Empty;
	|
	|            if (AutoSize)
	|            {
	|                s = GetAutoSize();
	|            }
	|
	|            if (x is Pos.PosCenter)
	|            {
	|                if (width == null)
	|                {
	|                    actW = AutoSize ? s.Width : hostFrame.Width;
	|                }
	|                else
	|                {
	|                    actW = width.Anchor(hostFrame.Width);
	|                    actW = AutoSize && s.Width > actW ? s.Width : actW;
	|                }
	|                actX = x.Anchor(hostFrame.Width - actW);
	|            }
	|            else
	|            {
	|                actX = x?.Anchor(hostFrame.Width) ?? 0;
	|
	|                actW = Math.Max(CalculateActualWidth(width, hostFrame, actX, s), 0);
	|            }
	|
	|            if (y is Pos.PosCenter)
	|            {
	|                if (height == null)
	|                {
	|                    actH = AutoSize ? s.Height : hostFrame.Height;
	|                }
	|                else
	|                {
	|                    actH = height.Anchor(hostFrame.Height);
	|                    actH = AutoSize && s.Height > actH ? s.Height : actH;
	|                }
	|                actY = y.Anchor(hostFrame.Height - actH);
	|            }
	|            else
	|            {
	|                actY = y?.Anchor(hostFrame.Height) ?? 0;
	|
	|                actH = Math.Max(CalculateActualHeight(height, hostFrame, actY, s), 0);
	|            }
	|
	|            var r = new Rect(actX, actY, actW, actH);
	|            if (Frame != r)
	|            {
	|                Frame = r;
	|                if (!SetMinWidthHeight())
	|                    TextFormatter.Size = GetBoundsTextFormatterSize();
	|            }
	|        }
	|
	|        private int CalculateActualWidth(Dim width, Rect hostFrame, int actX, Size s)
	|        {
	|            int actW;
	|            switch (width)
	|            {
	|                case null:
	|                    actW = AutoSize ? s.Width : hostFrame.Width;
	|                    break;
	|                case Dim.DimCombine combine:
	|                    int leftActW = CalculateActualWidth(combine.left, hostFrame, actX, s);
	|                    int rightActW = CalculateActualWidth(combine.right, hostFrame, actX, s);
	|                    if (combine.add)
	|                    {
	|                        actW = leftActW + rightActW;
	|                    }
	|                    else
	|                    {
	|                        actW = leftActW - rightActW;
	|                    }
	|                    actW = AutoSize && s.Width > actW ? s.Width : actW;
	|                    break;
	|                case Dim.DimFactor factor when !factor.IsFromRemaining():
	|                    actW = width.Anchor(hostFrame.Width);
	|                    actW = AutoSize && s.Width > actW ? s.Width : actW;
	|                    break;
	|                default:
	|                    actW = Math.Max(width.Anchor(hostFrame.Width - actX), 0);
	|                    actW = AutoSize && s.Width > actW ? s.Width : actW;
	|                    break;
	|            }
	|
	|            return actW;
	|        }
	|
	|        private int CalculateActualHeight(Dim height, Rect hostFrame, int actY, Size s)
	|        {
	|            int actH;
	|            switch (height)
	|            {
	|                case null:
	|                    actH = AutoSize ? s.Height : hostFrame.Height;
	|                    break;
	|                case Dim.DimCombine combine:
	|                    int leftActH = CalculateActualHeight(combine.left, hostFrame, actY, s);
	|                    int rightActH = CalculateActualHeight(combine.right, hostFrame, actY, s);
	|                    if (combine.add)
	|                    {
	|                        actH = leftActH + rightActH;
	|                    }
	|                    else
	|                    {
	|                        actH = leftActH - rightActH;
	|                    }
	|                    actH = AutoSize && s.Height > actH ? s.Height : actH;
	|                    break;
	|                case Dim.DimFactor factor when !factor.IsFromRemaining():
	|                    actH = height.Anchor(hostFrame.Height);
	|                    actH = AutoSize && s.Height > actH ? s.Height : actH;
	|                    break;
	|                default:
	|                    actH = Math.Max(height.Anchor(hostFrame.Height - actY), 0);
	|                    actH = AutoSize && s.Height > actH ? s.Height : actH;
	|                    break;
	|            }
	|
	|            return actH;
	|        }
	|
	|        // https://en.wikipedia.org/wiki/Topological_sorting
	|        List<View> TopologicalSort(IEnumerable<View> nodes, ICollection<(View From, View To)> edges)
	|        {
	|            var result = new List<View>();
	|
	|            // Set of all nodes with no incoming edges
	|            var noEdgeNodes = new HashSet<View>(nodes.Where(n => edges.All(e => !e.To.Equals(n))));
	|
	|            while (noEdgeNodes.Any())
	|            {
	|                //  remove a node n from S
	|                var n = noEdgeNodes.First();
	|                noEdgeNodes.Remove(n);
	|
	|                // add n to tail of L
	|                if (n != this?.SuperView)
	|                    result.Add(n);
	|
	|                // for each node m with an edge e from n to m do
	|                foreach (var e in edges.Where(e => e.From.Equals(n)).ToArray())
	|                {
	|                    var m = e.To;
	|
	|                    // remove edge e from the graph
	|                    edges.Remove(e);
	|
	|                    // if m has no other incoming edges then
	|                    if (edges.All(me => !me.To.Equals(m)) && m != this?.SuperView)
	|                    {
	|                        // insert m into S
	|                        noEdgeNodes.Add(m);
	|                    }
	|                }
	|            }
	|
	|            if (edges.Any())
	|            {
	|                (var from, var to) = edges.First();
	|                if (from != Application.Top)
	|                {
	|                    if (!ReferenceEquals(from, to))
	|                    {
	|                        throw new InvalidOperationException($""TopologicalSort (for Pos/Dim) cannot find {from} linked with {to}. Did you forget to add it to {this}?"");
	|                    }
	|                    else
	|                    {
	|                        throw new InvalidOperationException(""TopologicalSort encountered a recursive cycle in the relative Pos/Dim in the views of "" + this);
	|                    }
	|                }
	|            }
	|
	|            // return L (a topologically sorted order)
	|            return result;
	|        }
	|
	|        /// <summary>
	|        /// Event arguments for the <see cref=""LayoutComplete""/> event.
	|        /// </summary>
	|        public class LayoutEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// The view-relative bounds of the <see cref=""View""/> before it was laid out.
	|            /// </summary>
	|            public Rect OldBounds { get; set; }
	|        }
	|
	|        /// <summary>
	|        /// Fired after the View's <see cref=""LayoutSubviews""/> method has completed. 
	|        /// </summary>
	|        /// <remarks>
	|        /// Subscribe to this event to perform tasks when the <see cref=""View""/> has been resized or the layout has otherwise changed.
	|        /// </remarks>
	|        public event Action<LayoutEventArgs> LayoutStarted;
	|
	|        /// <summary>
	|        /// Raises the <see cref=""LayoutStarted""/> event. Called from  <see cref=""LayoutSubviews""/> before any subviews have been laid out.
	|        /// </summary>
	|        internal virtual void OnLayoutStarted(LayoutEventArgs args)
	|        {
	|            LayoutStarted?.Invoke(args);
	|        }
	|
	|        /// <summary>
	|        /// Fired after the View's <see cref=""LayoutSubviews""/> method has completed. 
	|        /// </summary>
	|        /// <remarks>
	|        /// Subscribe to this event to perform tasks when the <see cref=""View""/> has been resized or the layout has otherwise changed.
	|        /// </remarks>
	|        public event Action<LayoutEventArgs> LayoutComplete;
	|
	|        /// <summary>
	|        /// Event called only once when the <see cref=""View""/> is being initialized for the first time.
	|        /// Allows configurations and assignments to be performed before the <see cref=""View""/> being shown.
	|        /// This derived from <see cref=""ISupportInitializeNotification""/> to allow notify all the views that are being initialized.
	|        /// </summary>
	|        public event EventHandler Initialized;
	|
	|        /// <summary>
	|        /// Raises the <see cref=""LayoutComplete""/> event. Called from  <see cref=""LayoutSubviews""/> before all sub-views have been laid out.
	|        /// </summary>
	|        internal virtual void OnLayoutComplete(LayoutEventArgs args)
	|        {
	|            LayoutComplete?.Invoke(args);
	|        }
	|
	|        /// <summary>
	|        /// Invoked when a view starts executing or when the dimensions of the view have changed, for example in
	|        /// response to the container view or terminal resizing.
	|        /// </summary>
	|        /// <remarks>
	|        /// Calls <see cref=""OnLayoutComplete""/> (which raises the <see cref=""LayoutComplete""/> event) before it returns.
	|        /// </remarks>
	|        public virtual void LayoutSubviews()
	|        {
	|            if (!LayoutNeeded)
	|            {
	|                return;
	|            }
	|
	|            var oldBounds = Bounds;
	|            OnLayoutStarted(new LayoutEventArgs() { OldBounds = oldBounds });
	|
	|            TextFormatter.Size = GetBoundsTextFormatterSize();
	|
	|
	|            // Sort out the dependencies of the X, Y, Width, Height properties
	|            var nodes = new HashSet<View>();
	|            var edges = new HashSet<(View, View)>();
	|
	|            void CollectPos(Pos pos, View from, ref HashSet<View> nNodes, ref HashSet<(View, View)> nEdges)
	|            {
	|                switch (pos)
	|                {
	|                    case Pos.PosView pv:
	|                        if (pv.Target != this)
	|                        {
	|                            nEdges.Add((pv.Target, from));
	|                        }
	|                        foreach (var v in from.InternalSubviews)
	|                        {
	|                            CollectAll(v, ref nNodes, ref nEdges);
	|                        }
	|                        return;
	|                    case Pos.PosCombine pc:
	|                        foreach (var v in from.InternalSubviews)
	|                        {
	|                            CollectPos(pc.left, from, ref nNodes, ref nEdges);
	|                            CollectPos(pc.right, from, ref nNodes, ref nEdges);
	|                        }
	|                        break;
	|                }
	|            }
	|
	|            void CollectDim(Dim dim, View from, ref HashSet<View> nNodes, ref HashSet<(View, View)> nEdges)
	|            {
	|                switch (dim)
	|                {
	|                    case Dim.DimView dv:
	|                        if (dv.Target != this)
	|                        {
	|                            nEdges.Add((dv.Target, from));
	|                        }
	|                        foreach (var v in from.InternalSubviews)
	|                        {
	|                            CollectAll(v, ref nNodes, ref nEdges);
	|                        }
	|                        return;
	|                    case Dim.DimCombine dc:
	|                        foreach (var v in from.InternalSubviews)
	|                        {
	|                            CollectDim(dc.left, from, ref nNodes, ref nEdges);
	|                            CollectDim(dc.right, from, ref nNodes, ref nEdges);
	|                        }
	|                        break;
	|                }
	|            }
	|
	|            void CollectAll(View from, ref HashSet<View> nNodes, ref HashSet<(View, View)> nEdges)
	|            {
	|                foreach (var v in from.InternalSubviews)
	|                {
	|                    nNodes.Add(v);
	|                    if (v.layoutStyle != LayoutStyle.Computed)
	|                    {
	|                        continue;
	|                    }
	|                    CollectPos(v.X, v, ref nNodes, ref nEdges);
	|                    CollectPos(v.Y, v, ref nNodes, ref nEdges);
	|                    CollectDim(v.Width, v, ref nNodes, ref nEdges);
	|                    CollectDim(v.Height, v, ref nNodes, ref nEdges);
	|                }
	|            }
	|
	|            CollectAll(this, ref nodes, ref edges);
	|
	|            var ordered = TopologicalSort(nodes, edges);
	|
	|            foreach (var v in ordered)
	|            {
	|                if (v.LayoutStyle == LayoutStyle.Computed)
	|                {
	|                    v.SetRelativeLayout(v?.SuperView.Frame ?? Frame);
	|                }
	|
	|                v.LayoutSubviews();
	|                v.LayoutNeeded = false;
	|            }
	|
	|            if (SuperView != null && SuperView == Application.Top && LayoutNeeded
	|                && ordered.Count == 0 && LayoutStyle == LayoutStyle.Computed)
	|            {
	|                SetRelativeLayout(SuperView.Frame);
	|            }
	|
	|            LayoutNeeded = false;
	|
	|            OnLayoutComplete(new LayoutEventArgs() { OldBounds = oldBounds });
	|        }
	|
	|        ustring text;
	|
	|        /// <summary>
	|        ///   The text displayed by the <see cref=""View""/>.
	|        /// </summary>
	|        /// <remarks>
	|        /// <para>
	|        ///  If provided, the text will be drawn before any subviews are drawn.
	|        /// </para>
	|        /// <para>
	|        ///  The text will be drawn starting at the view origin (0, 0) and will be formatted according
	|        ///  to the <see cref=""TextAlignment""/> property. If the view's height is greater than 1, the
	|        ///  text will word-wrap to additional lines if it does not fit horizontally. If the view's height
	|        ///  is 1, the text will be clipped.
	|        /// </para>
	|        /// <para>
	|        ///  Set the <see cref=""HotKeySpecifier""/> to enable hotkey support. To disable hotkey support set <see cref=""HotKeySpecifier""/> to
	|        ///  <c>(Rune)0xffff</c>.
	|        /// </para>
	|        /// </remarks>
	|        public virtual ustring Text
	|        {
	|            get => text;
	|            set
	|            {
	|                text = value;
	|                SetHotKey();
	|                UpdateTextFormatterText();
	|                ProcessResizeView();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a flag that determines whether the View will be automatically resized to fit the <see cref=""Text""/>.
	|        /// The default is <see langword=""false""/>. Set to <see langword=""true""/> to turn on AutoSize. If <see cref=""AutoSize""/> is <see langword=""true""/> the <see cref=""Width""/>
	|        /// and <see cref=""Height""/> will always be used if the text size is lower. If the text size is higher the bounds will
	|        /// be resized to fit it.
	|        /// In addition, if <see cref=""ForceValidatePosDim""/> is <see langword=""true""/> the new values of <see cref=""Width""/> and
	|        /// <see cref=""Height""/> must be of the same types of the existing one to avoid breaking the <see cref=""Dim""/> settings.
	|        /// </summary>
	|        public virtual bool AutoSize
	|        {
	|            get => autoSize;
	|            set
	|            {
	|                var v = ResizeView(value);
	|                TextFormatter.AutoSize = v;
	|                if (autoSize != v)
	|                {
	|                    autoSize = v;
	|                    TextFormatter.NeedsFormat = true;
	|                    UpdateTextFormatterText();
	|                    ProcessResizeView();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets a flag that determines whether <see cref=""Terminal.Gui.TextFormatter.Text""/> will have trailing spaces preserved
	|        /// or not when <see cref=""Terminal.Gui.TextFormatter.WordWrap""/> is enabled. If <see langword=""true""/> 
	|        /// any trailing spaces will be trimmed when either the <see cref=""Text""/> property is changed or 
	|        /// when <see cref=""Terminal.Gui.TextFormatter.WordWrap""/> is set to <see langword=""true""/>.
	|        /// The default is <see langword=""false""/>.
	|        /// </summary>
	|        public virtual bool PreserveTrailingSpaces
	|        {
	|            get => TextFormatter.PreserveTrailingSpaces;
	|            set
	|            {
	|                if (TextFormatter.PreserveTrailingSpaces != value)
	|                {
	|                    TextFormatter.PreserveTrailingSpaces = value;
	|                    TextFormatter.NeedsFormat = true;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets how the View's <see cref=""Text""/> is aligned horizontally when drawn. Changing this property will redisplay the <see cref=""View""/>.
	|        /// </summary>
	|        /// <value>The text alignment.</value>
	|        public virtual TextAlignment TextAlignment
	|        {
	|            get => TextFormatter.Alignment;
	|            set
	|            {
	|                TextFormatter.Alignment = value;
	|                UpdateTextFormatterText();
	|                ProcessResizeView();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets how the View's <see cref=""Text""/> is aligned vertically when drawn. Changing this property will redisplay the <see cref=""View""/>.
	|        /// </summary>
	|        /// <value>The text alignment.</value>
	|        public virtual VerticalTextAlignment VerticalTextAlignment
	|        {
	|            get => TextFormatter.VerticalAlignment;
	|            set
	|            {
	|                TextFormatter.VerticalAlignment = value;
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets the direction of the View's <see cref=""Text""/>. Changing this property will redisplay the <see cref=""View""/>.
	|        /// </summary>
	|        /// <value>The text alignment.</value>
	|        public virtual TextDirection TextDirection
	|        {
	|            get => TextFormatter.Direction;
	|            set
	|            {
	|                if (TextFormatter.Direction != value)
	|                {
	|                    var isValidOldAutSize = autoSize && IsValidAutoSize(out var _);
	|                    var directionChanged = TextFormatter.IsHorizontalDirection(TextFormatter.Direction)
	|                        != TextFormatter.IsHorizontalDirection(value);
	|
	|                    TextFormatter.Direction = value;
	|                    UpdateTextFormatterText();
	|
	|                    if ((!ForceValidatePosDim && directionChanged && AutoSize)
	|                        || (ForceValidatePosDim && directionChanged && AutoSize && isValidOldAutSize))
	|                    {
	|                        ProcessResizeView();
	|                    }
	|                    else if (directionChanged && IsAdded)
	|                    {
	|                        SetWidthHeight(Bounds.Size);
	|                        SetMinWidthHeight();
	|                    }
	|                    else
	|                    {
	|                        SetMinWidthHeight();
	|                    }
	|                    TextFormatter.Size = GetBoundsTextFormatterSize();
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or sets if  the <see cref=""View""/> was already initialized.
	|        /// This derived from <see cref=""ISupportInitializeNotification""/> to allow notify all the views that are being initialized.
	|        /// </summary>
	|        public virtual bool IsInitialized { get; set; }
	|
	|        /// <summary>
	|        /// Gets information if the view was already added to the <see cref=""SuperView""/>.
	|        /// </summary>
	|        public bool IsAdded { get; private set; }
	|
	|        bool oldEnabled;
	|
	|        /// <inheritdoc/>
	|        public override bool Enabled
	|        {
	|            get => base.Enabled;
	|            set
	|            {
	|                if (base.Enabled != value)
	|                {
	|                    if (value)
	|                    {
	|                        if (SuperView == null || SuperView?.Enabled == true)
	|                        {
	|                            base.Enabled = value;
	|                        }
	|                    }
	|                    else
	|                    {
	|                        base.Enabled = value;
	|                    }
	|                    if (!value && HasFocus)
	|                    {
	|                        SetHasFocus(false, this);
	|                    }
	|                    OnEnabledChanged();
	|                    SetNeedsDisplay();
	|
	|                    if (subviews != null)
	|                    {
	|                        foreach (var view in subviews)
	|                        {
	|                            if (!value)
	|                            {
	|                                view.oldEnabled = view.Enabled;
	|                                view.Enabled = false;
	|                            }
	|                            else
	|                            {
	|                                view.Enabled = view.oldEnabled;
	|                                view.addingView = false;
	|                            }
	|                        }
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets or sets whether a view is cleared if the <see cref=""Visible""/> property is <see langword=""false""/>.
	|        /// </summary>
	|        public bool ClearOnVisibleFalse { get; set; } = true;
	|
	|        /// <inheritdoc/>>
	|        public override bool Visible
	|        {
	|            get => base.Visible;
	|            set
	|            {
	|                if (base.Visible != value)
	|                {
	|                    base.Visible = value;
	|                    if (!value)
	|                    {
	|                        if (HasFocus)
	|                        {
	|                            SetHasFocus(false, this);
	|                        }
	|                        if (ClearOnVisibleFalse)
	|                        {
	|                            Clear();
	|                        }
	|                    }
	|                    OnVisibleChanged();
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        Border border;
	|
	|        /// <inheritdoc/>
	|        public virtual Border Border
	|        {
	|            get => border;
	|            set
	|            {
	|                if (border != value)
	|                {
	|                    border = value;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Get or sets whether the view will use <see cref=""Terminal.Gui.Border""/> (if <see cref=""Border""/> is set) to draw 
	|        /// a border. If <see langword=""false""/> (the default),
	|        /// <see cref=""View.Redraw(Rect)""/> will call <see cref=""Border.DrawContent(View, bool)""/>
	|        /// to draw the view's border. If <see langword=""true""/> no border is drawn (and the view is expected to draw the border
	|        /// itself).
	|        /// </summary>
	|        public virtual bool IgnoreBorderPropertyOnRedraw { get; set; }
	|
	|        /// <summary>
	|        /// Pretty prints the View
	|        /// </summary>
	|        /// <returns></returns>
	|        public override string ToString()
	|        {
	|            return $""{GetType().Name}({Id})({Frame})"";
	|        }
	|
	|        void SetHotKey()
	|        {
	|            TextFormatter.FindHotKey(text, HotKeySpecifier, true, out _, out var hk);
	|            if (hotKey != hk)
	|            {
	|                HotKey = hk;
	|            }
	|        }
	|
	|        bool ResizeView(bool autoSize)
	|        {
	|            if (!autoSize)
	|            {
	|                return false;
	|            }
	|
	|            var aSize = true;
	|            var nBoundsSize = GetAutoSize();
	|            if (nBoundsSize != Bounds.Size)
	|            {
	|                if (ForceValidatePosDim)
	|                {
	|                    aSize = SetWidthHeight(nBoundsSize);
	|                }
	|                else
	|                {
	|                    Bounds = new Rect(Bounds.X, Bounds.Y, nBoundsSize.Width, nBoundsSize.Height);
	|                }
	|            }
	|            TextFormatter.Size = GetBoundsTextFormatterSize();
	|            return aSize;
	|        }
	|
	|        bool SetWidthHeight(Size nBounds)
	|        {
	|            var aSize = false;
	|            var canSizeW = SetWidth(nBounds.Width - GetHotKeySpecifierLength(), out var rW);
	|            var canSizeH = SetHeight(nBounds.Height - GetHotKeySpecifierLength(false), out var rH);
	|            if (canSizeW)
	|            {
	|                aSize = true;
	|                width = rW;
	|            }
	|            if (canSizeH)
	|            {
	|                aSize = true;
	|                height = rH;
	|            }
	|            if (aSize)
	|            {
	|                Bounds = new Rect(Bounds.X, Bounds.Y, canSizeW ? rW : Bounds.Width, canSizeH ? rH : Bounds.Height);
	|                TextFormatter.Size = GetBoundsTextFormatterSize();
	|            }
	|
	|            return aSize;
	|        }
	|
	|        /// <summary>
	|        /// Gets the size to fit all text if <see cref=""AutoSize""/> is true.
	|        /// </summary>
	|        /// <returns>The <see cref=""Size""/></returns>
	|        public Size GetAutoSize()
	|        {
	|            var rect = TextFormatter.CalcRect(Bounds.X, Bounds.Y, TextFormatter.Text, TextFormatter.Direction);
	|            return new Size(rect.Size.Width - GetHotKeySpecifierLength(),
	|                rect.Size.Height - GetHotKeySpecifierLength(false));
	|        }
	|
	|        bool IsValidAutoSize(out Size autoSize)
	|        {
	|            var rect = TextFormatter.CalcRect(frame.X, frame.Y, TextFormatter.Text, TextDirection);
	|            autoSize = new Size(rect.Size.Width - GetHotKeySpecifierLength(),
	|                rect.Size.Height - GetHotKeySpecifierLength(false));
	|            return !(ForceValidatePosDim && (!(Width is Dim.DimAbsolute) || !(Height is Dim.DimAbsolute))
	|                || frame.Size.Width != rect.Size.Width - GetHotKeySpecifierLength()
	|                || frame.Size.Height != rect.Size.Height - GetHotKeySpecifierLength(false));
	|        }
	|
	|        bool IsValidAutoSizeWidth(Dim width)
	|        {
	|            var rect = TextFormatter.CalcRect(frame.X, frame.Y, TextFormatter.Text, TextDirection);
	|            var dimValue = width.Anchor(0);
	|            return !(ForceValidatePosDim && (!(width is Dim.DimAbsolute)) || dimValue != rect.Size.Width
	|                - GetHotKeySpecifierLength());
	|        }
	|
	|        bool IsValidAutoSizeHeight(Dim height)
	|        {
	|            var rect = TextFormatter.CalcRect(frame.X, frame.Y, TextFormatter.Text, TextDirection);
	|            var dimValue = height.Anchor(0);
	|            return !(ForceValidatePosDim && (!(height is Dim.DimAbsolute)) || dimValue != rect.Size.Height
	|                - GetHotKeySpecifierLength(false));
	|        }
	|
	|        /// <summary>
	|        /// Get the width or height of the <see cref=""Terminal.Gui.TextFormatter.HotKeySpecifier""/> length.
	|        /// </summary>
	|        /// <param name=""isWidth""><see langword=""true""/> if is the width (default) <see langword=""false""/> if is the height.</param>
	|        /// <returns>The length of the <see cref=""Terminal.Gui.TextFormatter.HotKeySpecifier""/>.</returns>
	|        public int GetHotKeySpecifierLength(bool isWidth = true)
	|        {
	|            if (isWidth)
	|            {
	|                return TextFormatter.IsHorizontalDirection(TextDirection) &&
	|                    TextFormatter.Text?.Contains(HotKeySpecifier) == true
	|                    ? Math.Max(Rune.ColumnWidth(HotKeySpecifier), 0) : 0;
	|            }
	|            else
	|            {
	|                return TextFormatter.IsVerticalDirection(TextDirection) &&
	|                    TextFormatter.Text?.Contains(HotKeySpecifier) == true
	|                    ? Math.Max(Rune.ColumnWidth(HotKeySpecifier), 0) : 0;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Gets the bounds size from a <see cref=""Terminal.Gui.TextFormatter.Size""/>.
	|        /// </summary>
	|        /// <returns>The bounds size minus the <see cref=""Terminal.Gui.TextFormatter.HotKeySpecifier""/> length.</returns>
	|        public Size GetTextFormatterBoundsSize()
	|        {
	|            return new Size(TextFormatter.Size.Width - GetHotKeySpecifierLength(),
	|                TextFormatter.Size.Height - GetHotKeySpecifierLength(false));
	|        }
	|
	|        /// <summary>
	|        /// Gets the text formatter size from a <see cref=""Bounds""/> size.
	|        /// </summary>
	|        /// <returns>The text formatter size more the <see cref=""Terminal.Gui.TextFormatter.HotKeySpecifier""/> length.</returns>
	|        public Size GetBoundsTextFormatterSize()
	|        {
	|            if (ustring.IsNullOrEmpty(TextFormatter.Text))
	|                return Bounds.Size;
	|
	|            return new Size(frame.Size.Width + GetHotKeySpecifierLength(),
	|                frame.Size.Height + GetHotKeySpecifierLength(false));
	|        }
	|
	|        /// <summary>
	|        /// Specifies the event arguments for <see cref=""MouseEvent""/>. This is a higher-level construct
	|        /// than the wrapped <see cref=""MouseEvent""/> class and is used for the events defined on <see cref=""View""/>
	|        /// and subclasses of View (e.g. <see cref=""View.MouseEnter""/> and <see cref=""View.MouseClick""/>).
	|        /// </summary>
	|        public class MouseEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// Constructs.
	|            /// </summary>
	|            /// <param name=""me""></param>
	|            public MouseEventArgs(MouseEvent me) => MouseEvent = me;
	|            /// <summary>
	|            /// The <see cref=""MouseEvent""/> for the event.
	|            /// </summary>
	|            public MouseEvent MouseEvent { get; set; }
	|
	|            /// <summary>
	|            /// Indicates if the current mouse event has already been processed and the driver should stop notifying any other event subscriber.
	|            /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
	|            /// </summary>
	|            /// <remarks>This property forwards to the <see cref=""MouseEvent.Handled""/> property and is provided as a convenience and for
	|            /// backwards compatibility</remarks>
	|            public bool Handled
	|            {
	|                get => MouseEvent.Handled;
	|                set => MouseEvent.Handled = value;
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool OnMouseEnter(MouseEvent mouseEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return true;
	|            }
	|
	|            if (!CanBeVisible(this))
	|            {
	|                return false;
	|            }
	|
	|            var args = new MouseEventArgs(mouseEvent);
	|            MouseEnter?.Invoke(args);
	|
	|            return args.Handled || base.OnMouseEnter(mouseEvent);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool OnMouseLeave(MouseEvent mouseEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return true;
	|            }
	|
	|            if (!CanBeVisible(this))
	|            {
	|                return false;
	|            }
	|
	|            var args = new MouseEventArgs(mouseEvent);
	|            MouseLeave?.Invoke(args);
	|
	|            return args.Handled || base.OnMouseLeave(mouseEvent);
	|        }
	|
	|        /// <summary>
	|        /// Method invoked when a mouse event is generated
	|        /// </summary>
	|        /// <param name=""mouseEvent""></param>
	|        /// <returns><see langword=""true""/>, if the event was handled, <see langword=""false""/> otherwise.</returns>
	|        public virtual bool OnMouseEvent(MouseEvent mouseEvent)
	|        {
	|            if (!Enabled)
	|            {
	|                return true;
	|            }
	|
	|            if (!CanBeVisible(this))
	|            {
	|                return false;
	|            }
	|
	|            if ((mouseEvent.Flags & MouseFlags.Button1Clicked) != 0 || (mouseEvent.Flags & MouseFlags.Button2Clicked) != 0
	|                || (mouseEvent.Flags & MouseFlags.Button3Clicked) != 0 || (mouseEvent.Flags & MouseFlags.Button4Clicked) != 0)
	|            {
	|
	|                var args = new MouseEventArgs(mouseEvent);
	|                if (OnMouseClick(args))
	|                {
	|                    return true;
	|                }
	|            }
	|            if (MouseEvent(mouseEvent))
	|                return true;
	|
	|            if (mouseEvent.Flags == MouseFlags.Button1Clicked)
	|            {
	|                if (CanFocus && !HasFocus && SuperView != null)
	|                {
	|                    SuperView.SetFocus(this);
	|                    SetNeedsDisplay();
	|                }
	|
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Invokes the MouseClick event.
	|        /// </summary>
	|        protected bool OnMouseClick(MouseEventArgs args)
	|        {
	|            if (!Enabled)
	|            {
	|                return true;
	|            }
	|
	|            MouseClick?.Invoke(args);
	|            return args.Handled;
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void OnCanFocusChanged() => CanFocusChanged?.Invoke();
	|
	|        /// <inheritdoc/>
	|        public override void OnEnabledChanged() => EnabledChanged?.Invoke();
	|
	|        /// <inheritdoc/>
	|        public override void OnVisibleChanged() => VisibleChanged?.Invoke();
	|
	|        /// <inheritdoc/>
	|        protected override void Dispose(bool disposing)
	|        {
	|            height = null;
	|            width = null;
	|            x = null;
	|            y = null;
	|            for (var i = InternalSubviews.Count - 1; i >= 0; i--)
	|            {
	|                var subview = InternalSubviews[i];
	|                Remove(subview);
	|                subview.Dispose();
	|            }
	|            base.Dispose(disposing);
	|            System.Diagnostics.Debug.Assert(InternalSubviews.Count == 0);
	|        }
	|
	|        /// <summary>
	|        /// This derived from <see cref=""ISupportInitializeNotification""/> to allow notify all the views that are beginning initialized.
	|        /// </summary>
	|        public void BeginInit()
	|        {
	|            if (!IsInitialized)
	|            {
	|                oldCanFocus = CanFocus;
	|                oldTabIndex = tabIndex;
	|            }
	|            if (subviews?.Count > 0)
	|            {
	|                foreach (var view in subviews)
	|                {
	|                    if (!view.IsInitialized)
	|                    {
	|                        view.BeginInit();
	|                    }
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This derived from <see cref=""ISupportInitializeNotification""/> to allow notify all the views that are ending initialized.
	|        /// </summary>
	|        public void EndInit()
	|        {
	|            IsInitialized = true;
	|            if (subviews?.Count > 0)
	|            {
	|                foreach (var view in subviews)
	|                {
	|                    if (!view.IsInitialized)
	|                    {
	|                        view.EndInit();
	|                    }
	|                }
	|            }
	|            Initialized?.Invoke(this, EventArgs.Empty);
	|        }
	|
	|        bool CanBeVisible(View view)
	|        {
	|            if (!view.Visible)
	|            {
	|                return false;
	|            }
	|            for (var c = view.SuperView; c != null; c = c.SuperView)
	|            {
	|                if (!c.Visible)
	|                {
	|                    return false;
	|                }
	|            }
	|
	|            return true;
	|        }
	|
	|        bool CanSetWidth(int desiredWidth, out int resultWidth)
	|        {
	|            var w = desiredWidth;
	|            bool canSetWidth;
	|            if (Width is Dim.DimCombine || Width is Dim.DimView || Width is Dim.DimFill)
	|            {
	|                // It's a Dim.DimCombine and so can't be assigned. Let it have it's width anchored.
	|                w = Width.Anchor(w);
	|                canSetWidth = !ForceValidatePosDim;
	|            }
	|            else if (Width is Dim.DimFactor factor)
	|            {
	|                // Tries to get the SuperView width otherwise the view width.
	|                var sw = SuperView != null ? SuperView.Frame.Width : w;
	|                if (factor.IsFromRemaining())
	|                {
	|                    sw -= Frame.X;
	|                }
	|                w = Width.Anchor(sw);
	|                canSetWidth = !ForceValidatePosDim;
	|            }
	|            else
	|            {
	|                canSetWidth = true;
	|            }
	|            resultWidth = w;
	|
	|            return canSetWidth;
	|        }
	|
	|        bool CanSetHeight(int desiredHeight, out int resultHeight)
	|        {
	|            var h = desiredHeight;
	|            bool canSetHeight;
	|            switch (Height)
	|            {
	|                case Dim.DimCombine _:
	|                case Dim.DimView _:
	|                case Dim.DimFill _:
	|                    // It's a Dim.DimCombine and so can't be assigned. Let it have it's height anchored.
	|                    h = Height.Anchor(h);
	|                    canSetHeight = !ForceValidatePosDim;
	|                    break;
	|                case Dim.DimFactor factor:
	|                    // Tries to get the SuperView height otherwise the view height.
	|                    var sh = SuperView != null ? SuperView.Frame.Height : h;
	|                    if (factor.IsFromRemaining())
	|                    {
	|                        sh -= Frame.Y;
	|                    }
	|                    h = Height.Anchor(sh);
	|                    canSetHeight = !ForceValidatePosDim;
	|                    break;
	|                default:
	|                    canSetHeight = true;
	|                    break;
	|            }
	|            resultHeight = h;
	|
	|            return canSetHeight;
	|        }
	|
	|        /// <summary>
	|        /// Calculate the width based on the <see cref=""Width""/> settings.
	|        /// </summary>
	|        /// <param name=""desiredWidth"">The desired width.</param>
	|        /// <param name=""resultWidth"">The real result width.</param>
	|        /// <returns><see langword=""true""/> if the width can be directly assigned, <see langword=""false""/> otherwise.</returns>
	|        public bool SetWidth(int desiredWidth, out int resultWidth)
	|        {
	|            return CanSetWidth(desiredWidth, out resultWidth);
	|        }
	|
	|        /// <summary>
	|        /// Calculate the height based on the <see cref=""Height""/> settings.
	|        /// </summary>
	|        /// <param name=""desiredHeight"">The desired height.</param>
	|        /// <param name=""resultHeight"">The real result height.</param>
	|        /// <returns><see langword=""true""/> if the height can be directly assigned, <see langword=""false""/> otherwise.</returns>
	|        public bool SetHeight(int desiredHeight, out int resultHeight)
	|        {
	|            return CanSetHeight(desiredHeight, out resultHeight);
	|        }
	|
	|        /// <summary>
	|        /// Gets the current width based on the <see cref=""Width""/> settings.
	|        /// </summary>
	|        /// <param name=""currentWidth"">The real current width.</param>
	|        /// <returns><see langword=""true""/> if the width can be directly assigned, <see langword=""false""/> otherwise.</returns>
	|        public bool GetCurrentWidth(out int currentWidth)
	|        {
	|            SetRelativeLayout(SuperView?.frame ?? frame);
	|            currentWidth = frame.Width;
	|
	|            return CanSetWidth(0, out _);
	|        }
	|
	|        /// <summary>
	|        /// Calculate the height based on the <see cref=""Height""/> settings.
	|        /// </summary>
	|        /// <param name=""currentHeight"">The real current height.</param>
	|        /// <returns><see langword=""true""/> if the height can be directly assigned, <see langword=""false""/> otherwise.</returns>
	|        public bool GetCurrentHeight(out int currentHeight)
	|        {
	|            SetRelativeLayout(SuperView?.frame ?? frame);
	|            currentHeight = frame.Height;
	|
	|            return CanSetHeight(0, out _);
	|        }
	|
	|        /// <summary>
	|        /// Determines the current <see cref=""ColorScheme""/> based on the <see cref=""Enabled""/> value.
	|        /// </summary>
	|        /// <returns><see cref=""Terminal.Gui.ColorScheme.Normal""/> if <see cref=""Enabled""/> is <see langword=""true""/>
	|        /// or <see cref=""Terminal.Gui.ColorScheme.Disabled""/> if <see cref=""Enabled""/> is <see langword=""false""/>.
	|        /// If it's overridden can return other values.</returns>
	|        public virtual Attribute GetNormalColor()
	|        {
	|            return Enabled ? ColorScheme.Normal : ColorScheme.Disabled;
	|        }
	|
	|        /// <summary>
	|        /// Determines the current <see cref=""ColorScheme""/> based on the <see cref=""Enabled""/> value.
	|        /// </summary>
	|        /// <returns><see cref=""Terminal.Gui.ColorScheme.Focus""/> if <see cref=""Enabled""/> is <see langword=""true""/>
	|        /// or <see cref=""Terminal.Gui.ColorScheme.Disabled""/> if <see cref=""Enabled""/> is <see langword=""false""/>.
	|        /// If it's overridden can return other values.</returns>
	|        public virtual Attribute GetFocusColor()
	|        {
	|            return Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
	|        }
	|
	|        /// <summary>
	|        /// Determines the current <see cref=""ColorScheme""/> based on the <see cref=""Enabled""/> value.
	|        /// </summary>
	|        /// <returns><see cref=""Terminal.Gui.ColorScheme.HotNormal""/> if <see cref=""Enabled""/> is <see langword=""true""/>
	|        /// or <see cref=""Terminal.Gui.ColorScheme.Disabled""/> if <see cref=""Enabled""/> is <see langword=""false""/>.
	|        /// If it's overridden can return other values.</returns>
	|        public virtual Attribute GetHotNormalColor()
	|        {
	|            return Enabled ? ColorScheme.HotNormal : ColorScheme.Disabled;
	|        }
	|
	|        /// <summary>
	|        /// Get the top superview of a given <see cref=""View""/>.
	|        /// </summary>
	|        /// <returns>The superview view.</returns>
	|        public View GetTopSuperView()
	|        {
	|            View top = Application.Top;
	|            for (var v = this?.SuperView; v != null; v = v.SuperView)
	|            {
	|                top = v;
	|            }
	|
	|            return top;
	|        }
	|    }
	|    //=======================================================================
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel@gnome.org)
	|    //
	|    // NOTE: Window is functionally identical to FrameView with the following exceptions. 
	|    //  - Window is a Toplevel
	|    //  - FrameView Does not support padding (but should)
	|    //  - FrameView Does not support mouse dragging
	|    //  - FrameView Does not support IEnumerable
	|    // Any udpates done here should probably be done in FrameView as well; TODO: Merge these classes
	|
	|    /// <summary>
	|    /// A <see cref=""Toplevel""/> <see cref=""View""/> that draws a border around its <see cref=""View.Frame""/> with a <see cref=""Title""/> at the top.
	|    /// </summary>
	|    /// <remarks>
	|    /// The 'client area' of a <see cref=""Window""/> is a rectangle deflated by one or more rows/columns from <see cref=""View.Bounds""/>. A this time there is no
	|    /// API to determine this rectangle.
	|    /// </remarks>
	|    public class Window : Toplevel
	|    {
	|        View contentView;
	|        ustring title = ustring.Empty;
	|
	|        /// <summary>
	|        /// The title to be displayed for this window.
	|        /// </summary>
	|        /// <value>The title</value>
	|        public ustring Title
	|        {
	|            get => title;
	|            set
	|            {
	|                if (!OnTitleChanging(title, value))
	|                {
	|                    var old = title;
	|                    title = value;
	|                    if (Border != null)
	|                    {
	|                        Border.Title = title;
	|                    }
	|                    OnTitleChanged(old, title);
	|                }
	|                SetNeedsDisplay();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override Border Border
	|        {
	|            get => base.Border;
	|            set
	|            {
	|                if (base.Border != null && base.Border.Child != null && value.Child == null)
	|                {
	|                    value.Child = base.Border.Child;
	|                }
	|                base.Border = value;
	|                if (value == null)
	|                {
	|                    return;
	|                }
	|                Rect frame;
	|                if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
	|                {
	|                    frame = Rect.Empty;
	|                }
	|                else
	|                {
	|                    frame = Frame;
	|                }
	|                AdjustContentView(frame);
	|
	|                Border.BorderChanged += Border_BorderChanged;
	|            }
	|        }
	|
	|        void Border_BorderChanged(Border border)
	|        {
	|            Rect frame;
	|            if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
	|            {
	|                frame = Rect.Empty;
	|            }
	|            else
	|            {
	|                frame = Frame;
	|            }
	|            AdjustContentView(frame);
	|        }
	|
	|        /// <summary>
	|        /// ContentView is an internal implementation detail of Window. It is used to host Views added with <see cref=""Add(View)""/>. 
	|        /// Its ONLY reason for being is to provide a simple way for Window to expose to those SubViews that the Window's Bounds 
	|        /// are actually deflated due to the border. 
	|        /// </summary>
	|        class ContentView : View
	|        {
	|            Window instance;
	|
	|            public ContentView(Rect frame, Window instance) : base(frame)
	|            {
	|                Initialize(instance);
	|            }
	|            public ContentView(Window instance) : base()
	|            {
	|                Initialize(instance);
	|            }
	|
	|            private void Initialize(Window instance)
	|            {
	|                this.instance = instance;
	|                CanFocus = this.instance.CanFocus;
	|                Driver?.SetCursorVisibility(CursorVisibility.Invisible);
	|            }
	|
	|            public override void OnCanFocusChanged()
	|            {
	|                if (HasFocus && MostFocused == null && CanFocus && Visible)
	|                {
	|                    EnsureFocus();
	|                }
	|
	|                base.OnCanFocusChanged();
	|            }
	|
	|            public override bool OnMouseEvent(MouseEvent mouseEvent)
	|            {
	|                return instance.OnMouseEvent(mouseEvent);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Gui.Window""/> class with an optional title using <see cref=""LayoutStyle.Absolute""/> positioning.
	|        /// </summary>
	|        /// <param name=""frame"">Superview-relative rectangle specifying the location and size</param>
	|        /// <param name=""title"">Title</param>
	|        /// <remarks>
	|        /// This constructor initializes a Window with a <see cref=""LayoutStyle""/> of <see cref=""LayoutStyle.Absolute""/>. Use constructors
	|        /// that do not take <c>Rect</c> parameters to initialize a Window with <see cref=""LayoutStyle.Computed""/>. 
	|        /// </remarks>
	|        public Window(Rect frame, ustring title = null) : this(frame, title, padding: 0, border: null)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Window""/> class with an optional title using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        /// <param name=""title"">Title.</param>
	|        /// <remarks>
	|        ///   This constructor initializes a View with a <see cref=""LayoutStyle""/> of <see cref=""LayoutStyle.Computed""/>. 
	|        ///   Use <see cref=""View.X""/>, <see cref=""View.Y""/>, <see cref=""View.Width""/>, and <see cref=""View.Height""/> properties to dynamically control the size and location of the view.
	|        /// </remarks>
	|        public Window(ustring title = null) : this(title, padding: 0, border: null)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Window""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        public Window() : this(title: null) { }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Window""/> using <see cref=""LayoutStyle.Absolute""/> positioning with the specified frame for its location, with the specified frame padding,
	|        /// and an optional title.
	|        /// </summary>
	|        /// <param name=""frame"">Superview-relative rectangle specifying the location and size</param>
	|        /// <param name=""title"">Title</param>
	|        /// <param name=""padding"">Number of characters to use for padding of the drawn frame.</param>
	|        /// <param name=""border"">The <see cref=""Border""/>.</param>
	|        /// <remarks>
	|        /// This constructor initializes a Window with a <see cref=""LayoutStyle""/> of <see cref=""LayoutStyle.Absolute""/>. Use constructors
	|        /// that do not take <c>Rect</c> parameters to initialize a Window with  <see cref=""LayoutStyle""/> of <see cref=""LayoutStyle.Computed""/> 
	|        /// </remarks>
	|        public Window(Rect frame, ustring title = null, int padding = 0, Border border = null) : base(frame)
	|        {
	|            Initialize(title, frame, padding, border);
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Window""/> using <see cref=""LayoutStyle.Computed""/> positioning,
	|        /// and an optional title.
	|        /// </summary>
	|        /// <param name=""title"">Title.</param>
	|        /// <param name=""padding"">Number of characters to use for padding of the drawn frame.</param>
	|        /// <param name=""border"">The <see cref=""Border""/>.</param>
	|        /// <remarks>
	|        ///   This constructor initializes a View with a <see cref=""LayoutStyle""/> of <see cref=""LayoutStyle.Computed""/>. 
	|        ///   Use <see cref=""View.X""/>, <see cref=""View.Y""/>, <see cref=""View.Width""/>, and <see cref=""View.Height""/> properties to dynamically control the size and location of the view.
	|        /// </remarks>
	|        public Window(ustring title = null, int padding = 0, Border border = null) : base()
	|        {
	|            Initialize(title, Rect.Empty, padding, border);
	|        }
	|
	|        void Initialize(ustring title, Rect frame, int padding = 0, Border border = null)
	|        {
	|            CanFocus = true;
	|            ColorScheme = Colors.Base;
	|            if (title == null) title = ustring.Empty;
	|            Title = title;
	|            if (border == null)
	|            {
	|                Border = new Border()
	|                {
	|                    BorderStyle = BorderStyle.Single,
	|                    Padding = new Thickness(padding),
	|                    Title = title
	|                };
	|            }
	|            else
	|            {
	|                Border = border;
	|                if (ustring.IsNullOrEmpty(border.Title))
	|                {
	|                    border.Title = title;
	|                }
	|            }
	|            AdjustContentView(frame);
	|        }
	|
	|        void AdjustContentView(Rect frame)
	|        {
	|            var borderLength = Border.DrawMarginFrame ? 1 : 0;
	|            var sumPadding = Border.GetSumThickness();
	|            var wp = new Point();
	|            var wb = new Size();
	|            if (frame == Rect.Empty)
	|            {
	|                wp.X = borderLength + sumPadding.Left;
	|                wp.Y = borderLength + sumPadding.Top;
	|                wb.Width = borderLength + sumPadding.Right;
	|                wb.Height = borderLength + sumPadding.Bottom;
	|                if (contentView == null)
	|                {
	|                    contentView = new ContentView(this)
	|                    {
	|                        X = wp.X,
	|                        Y = wp.Y,
	|                        Width = Dim.Fill(wb.Width),
	|                        Height = Dim.Fill(wb.Height)
	|                    };
	|                }
	|                else
	|                {
	|                    contentView.X = wp.X;
	|                    contentView.Y = wp.Y;
	|                    contentView.Width = Dim.Fill(wb.Width);
	|                    contentView.Height = Dim.Fill(wb.Height);
	|                }
	|            }
	|            else
	|            {
	|                wb.Width = (2 * borderLength) + sumPadding.Right + sumPadding.Left;
	|                wb.Height = (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
	|                var cFrame = new Rect(borderLength + sumPadding.Left, borderLength + sumPadding.Top, frame.Width - wb.Width, frame.Height - wb.Height);
	|                if (contentView == null)
	|                {
	|                    contentView = new ContentView(cFrame, this);
	|                }
	|                else
	|                {
	|                    contentView.Frame = cFrame;
	|                }
	|            }
	|            if (Subviews?.Count == 0)
	|                base.Add(contentView);
	|            Border.Child = contentView;
	|        }
	|
	|        ///// <summary>
	|        ///// Enumerates the various <see cref=""View""/>s in the embedded <see cref=""ContentView""/>.
	|        ///// </summary>
	|        ///// <returns>The enumerator.</returns>
	|        //public new IEnumerator GetEnumerator ()
	|        //{
	|        //	return contentView.GetEnumerator ();
	|        //}
	|
	|        /// <inheritdoc/>
	|        public override void Add(View view)
	|        {
	|            contentView.Add(view);
	|            if (view.CanFocus)
	|            {
	|                CanFocus = true;
	|                if (contentView.HasFocus && contentView.MostFocused == null)
	|                {
	|                    view.SetFocus();
	|                }
	|            }
	|            AddMenuStatusBar(view);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void Remove(View view)
	|        {
	|            if (view == null)
	|            {
	|                return;
	|            }
	|
	|            SetNeedsDisplay();
	|            if (view == contentView)
	|            {
	|                base.Remove(view);
	|            }
	|            else
	|            {
	|                contentView.Remove(view);
	|            }
	|
	|            RemoveMenuStatusBar(view);
	|            if (view != contentView && Focused == null)
	|            {
	|                FocusFirst();
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void RemoveAll()
	|        {
	|            contentView.RemoveAll();
	|        }
	|
	|        ///<inheritdoc/>
	|        public override void Redraw(Rect bounds)
	|        {
	|            if (!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded)
	|            {
	|                Driver.SetAttribute(GetNormalColor());
	|                Clear();
	|                var savedFrame = Frame;
	|                PositionToplevels();
	|                if (Application.MdiTop != null && SuperView == null && this != Application.Top && LayoutStyle == LayoutStyle.Computed)
	|                {
	|                    SetRelativeLayout(Application.Top.Frame);
	|                    if (Frame != savedFrame)
	|                    {
	|                        Application.Top.SetNeedsDisplay();
	|                        Application.Top.Redraw(Application.Top.Bounds);
	|                        Redraw(Bounds);
	|                    }
	|                }
	|                LayoutSubviews();
	|                if (this == Application.MdiTop)
	|                {
	|                    foreach (var top in Application.MdiChildes.AsEnumerable().Reverse())
	|                    {
	|                        if (top.Frame.IntersectsWith(bounds))
	|                        {
	|                            if (top != this && !top.IsCurrentTop && !OutsideTopFrame(top) && top.Visible)
	|                            {
	|                                top.SetNeedsLayout();
	|                                top.SetNeedsDisplay(top.Bounds);
	|                                top.Redraw(top.Bounds);
	|                            }
	|                        }
	|                    }
	|                }
	|                contentView.SetNeedsDisplay();
	|            }
	|            var savedClip = contentView.ClipToBounds();
	|
	|            // Redraw our contentView
	|            contentView.Redraw(!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded ? contentView.Bounds : bounds);
	|            Driver.Clip = savedClip;
	|
	|            ClearLayoutNeeded();
	|            ClearNeedsDisplay();
	|
	|            Driver.SetAttribute(GetNormalColor());
	|            Border.DrawContent(this, false);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override void OnCanFocusChanged()
	|        {
	|            if (contentView != null)
	|            {
	|                contentView.CanFocus = CanFocus;
	|            }
	|            base.OnCanFocusChanged();
	|        }
	|
	|        /// <summary>
	|        ///   The text displayed by the <see cref=""Label""/>.
	|        /// </summary>
	|        public override ustring Text
	|        {
	|            get => contentView?.Text;
	|            set
	|            {
	|                base.Text = value;
	|                if (contentView != null)
	|                {
	|                    contentView.Text = value;
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Controls the text-alignment property of the label, changing it will redisplay the <see cref=""Label""/>.
	|        /// </summary>
	|        /// <value>The text alignment.</value>
	|        public override TextAlignment TextAlignment
	|        {
	|            get => contentView.TextAlignment;
	|            set
	|            {
	|                base.TextAlignment = contentView.TextAlignment = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// An <see cref=""EventArgs""/> which allows passing a cancelable new <see cref=""Title""/> value event.
	|        /// </summary>
	|        public class TitleEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// The new Window Title.
	|            /// </summary>
	|            public ustring NewTitle { get; set; }
	|
	|            /// <summary>
	|            /// The old Window Title.
	|            /// </summary>
	|            public ustring OldTitle { get; set; }
	|
	|            /// <summary>
	|            /// Flag which allows cancelling the Title change.
	|            /// </summary>
	|            public bool Cancel { get; set; }
	|
	|            /// <summary>
	|            /// Initializes a new instance of <see cref=""TitleEventArgs""/>
	|            /// </summary>
	|            /// <param name=""oldTitle"">The <see cref=""Window.Title""/> that is/has been replaced.</param>
	|            /// <param name=""newTitle"">The new <see cref=""Window.Title""/> to be replaced.</param>
	|            public TitleEventArgs(ustring oldTitle, ustring newTitle)
	|            {
	|                OldTitle = oldTitle;
	|                NewTitle = newTitle;
	|            }
	|        }
	|        /// <summary>
	|        /// Called before the <see cref=""Window.Title""/> changes. Invokes the <see cref=""TitleChanging""/> event, which can be cancelled.
	|        /// </summary>
	|        /// <param name=""oldTitle"">The <see cref=""Window.Title""/> that is/has been replaced.</param>
	|        /// <param name=""newTitle"">The new <see cref=""Window.Title""/> to be replaced.</param>
	|        /// <returns>`true` if an event handler cancelled the Title change.</returns>
	|        public virtual bool OnTitleChanging(ustring oldTitle, ustring newTitle)
	|        {
	|            var args = new TitleEventArgs(oldTitle, newTitle);
	|            TitleChanging?.Invoke(args);
	|            return args.Cancel;
	|        }
	|
	|        /// <summary>
	|        /// Event fired when the <see cref=""Window.Title""/> is changing. Set <see cref=""TitleEventArgs.Cancel""/> to 
	|        /// `true` to cancel the Title change.
	|        /// </summary>
	|        public event Action<TitleEventArgs> TitleChanging;
	|
	|        /// <summary>
	|        /// Called when the <see cref=""Window.Title""/> has been changed. Invokes the <see cref=""TitleChanged""/> event.
	|        /// </summary>
	|        /// <param name=""oldTitle"">The <see cref=""Window.Title""/> that is/has been replaced.</param>
	|        /// <param name=""newTitle"">The new <see cref=""Window.Title""/> to be replaced.</param>
	|        public virtual void OnTitleChanged(ustring oldTitle, ustring newTitle)
	|        {
	|            var args = new TitleEventArgs(oldTitle, newTitle);
	|            TitleChanged?.Invoke(args);
	|        }
	|
	|        /// <summary>
	|        /// Event fired after the <see cref=""Window.Title""/> has been changed. 
	|        /// </summary>
	|        public event Action<TitleEventArgs> TitleChanged;
	|    }
	|    //=======================================================================
	|    //
	|    // WindowsDriver.cs: Windows specific driver
	|    //
	|
	|    internal class WindowsConsole
	|    {
	|        public const int STD_OUTPUT_HANDLE = -11;
	|        public const int STD_INPUT_HANDLE = -10;
	|        public const int STD_ERROR_HANDLE = -12;
	|
	|        internal IntPtr InputHandle, OutputHandle;
	|        IntPtr screenBuffer;
	|        readonly uint originalConsoleMode;
	|        CursorVisibility? initialCursorVisibility = null;
	|        CursorVisibility? currentCursorVisibility = null;
	|        CursorVisibility? pendingCursorVisibility = null;
	|
	|        public WindowsConsole()
	|        {
	|            InputHandle = GetStdHandle(STD_INPUT_HANDLE);
	|            OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
	|            originalConsoleMode = ConsoleMode;
	|            var newConsoleMode = originalConsoleMode;
	|            newConsoleMode |= (uint)(ConsoleModes.EnableMouseInput | ConsoleModes.EnableExtendedFlags);
	|            newConsoleMode &= ~(uint)ConsoleModes.EnableQuickEditMode;
	|            newConsoleMode &= ~(uint)ConsoleModes.EnableProcessedInput;
	|            ConsoleMode = newConsoleMode;
	|        }
	|
	|        public CharInfo[] OriginalStdOutChars;
	|
	|        public bool WriteToConsole(Size size, CharInfo[] charInfoBuffer, Coord coords, SmallRect window)
	|        {
	|            if (!IsWindowsTerminal && screenBuffer == IntPtr.Zero)
	|            {
	|                ReadFromConsoleOutput(size, coords, ref window);
	|            }
	|
	|            if (!initialCursorVisibility.HasValue && GetCursorVisibility(out CursorVisibility visibility))
	|            {
	|                initialCursorVisibility = visibility;
	|            }
	|
	|            return WriteConsoleOutput(IsWindowsTerminal ? OutputHandle : screenBuffer, charInfoBuffer, coords, new Coord() { X = window.Left, Y = window.Top }, ref window);
	|        }
	|
	|        public void ReadFromConsoleOutput(Size size, Coord coords, ref SmallRect window)
	|        {
	|            screenBuffer = CreateConsoleScreenBuffer(
	|                DesiredAccess.GenericRead | DesiredAccess.GenericWrite,
	|                ShareMode.FileShareRead | ShareMode.FileShareWrite,
	|                IntPtr.Zero,
	|                1,
	|                IntPtr.Zero
	|            );
	|            if (screenBuffer == INVALID_HANDLE_VALUE)
	|            {
	|                var err = Marshal.GetLastWin32Error();
	|
	|                if (err != 0)
	|                    throw new System.ComponentModel.Win32Exception(err);
	|            }
	|
	|            if (!SetConsoleActiveScreenBuffer(screenBuffer))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|
	|            OriginalStdOutChars = new CharInfo[size.Height * size.Width];
	|
	|            if (!ReadConsoleOutput(screenBuffer, OriginalStdOutChars, coords, new Coord() { X = 0, Y = 0 }, ref window))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|        }
	|
	|        public bool SetCursorPosition(Coord position)
	|        {
	|            return SetConsoleCursorPosition(IsWindowsTerminal ? OutputHandle : screenBuffer, position);
	|        }
	|
	|        public void SetInitialCursorVisibility()
	|        {
	|            if (initialCursorVisibility.HasValue == false && GetCursorVisibility(out CursorVisibility visibility))
	|            {
	|                initialCursorVisibility = visibility;
	|            }
	|        }
	|
	|        public bool GetCursorVisibility(out CursorVisibility visibility)
	|        {
	|            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) == IntPtr.Zero)
	|            {
	|                visibility = CursorVisibility.Invisible;
	|                return false;
	|            }
	|            if (!GetConsoleCursorInfo(IsWindowsTerminal ? OutputHandle : screenBuffer, out ConsoleCursorInfo info))
	|            {
	|                var err = Marshal.GetLastWin32Error();
	|                if (err != 0)
	|                {
	|                    throw new System.ComponentModel.Win32Exception(err);
	|                }
	|                visibility = Gui.CursorVisibility.Default;
	|
	|                return false;
	|            }
	|
	|            if (!info.bVisible)
	|                visibility = CursorVisibility.Invisible;
	|            else if (info.dwSize > 50)
	|                visibility = CursorVisibility.Box;
	|            else
	|                visibility = CursorVisibility.Underline;
	|
	|            return true;
	|        }
	|
	|        public bool EnsureCursorVisibility()
	|        {
	|            if (initialCursorVisibility.HasValue && pendingCursorVisibility.HasValue && SetCursorVisibility(pendingCursorVisibility.Value))
	|            {
	|                pendingCursorVisibility = null;
	|
	|                return true;
	|            }
	|
	|            return false;
	|        }
	|
	|        public void ForceRefreshCursorVisibility()
	|        {
	|            if (currentCursorVisibility.HasValue)
	|            {
	|                pendingCursorVisibility = currentCursorVisibility;
	|                currentCursorVisibility = null;
	|            }
	|        }
	|
	|        public bool SetCursorVisibility(CursorVisibility visibility)
	|        {
	|            if (initialCursorVisibility.HasValue == false)
	|            {
	|                pendingCursorVisibility = visibility;
	|
	|                return false;
	|            }
	|
	|            if (currentCursorVisibility.HasValue == false || currentCursorVisibility.Value != visibility)
	|            {
	|                ConsoleCursorInfo info = new ConsoleCursorInfo
	|                {
	|                    dwSize = (uint)visibility & 0x00FF,
	|                    bVisible = ((uint)visibility & 0xFF00) != 0
	|                };
	|
	|                if (!SetConsoleCursorInfo(IsWindowsTerminal ? OutputHandle : screenBuffer, ref info))
	|                    return false;
	|
	|                currentCursorVisibility = visibility;
	|            }
	|
	|            return true;
	|        }
	|
	|        public void Cleanup()
	|        {
	|            if (initialCursorVisibility.HasValue)
	|            {
	|                SetCursorVisibility(initialCursorVisibility.Value);
	|            }
	|
	|            ConsoleMode = originalConsoleMode;
	|            if (!SetConsoleActiveScreenBuffer(OutputHandle))
	|            {
	|                var err = Marshal.GetLastWin32Error();
	|                Console.WriteLine(""Error: {0}"", err);
	|            }
	|
	|            if (screenBuffer != IntPtr.Zero)
	|            {
	|                CloseHandle(screenBuffer);
	|            }
	|
	|            screenBuffer = IntPtr.Zero;
	|        }
	|
	|        internal Size GetConsoleBufferWindow(out Point position)
	|        {
	|            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) == IntPtr.Zero)
	|            {
	|                position = Point.Empty;
	|                return Size.Empty;
	|            }
	|
	|            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
	|            csbi.cbSize = (uint)Marshal.SizeOf(csbi);
	|            if (!GetConsoleScreenBufferInfoEx((IsWindowsTerminal ? OutputHandle : screenBuffer), ref csbi))
	|            {
	|                //throw new System.ComponentModel.Win32Exception (Marshal.GetLastWin32Error ());
	|                position = Point.Empty;
	|                return Size.Empty;
	|            }
	|            var sz = new Size(csbi.srWindow.Right - csbi.srWindow.Left + 1,
	|                csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
	|            position = new Point(csbi.srWindow.Left, csbi.srWindow.Top);
	|
	|            return sz;
	|        }
	|
	|        internal Size GetConsoleOutputWindow(out Point position)
	|        {
	|            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
	|            csbi.cbSize = (uint)Marshal.SizeOf(csbi);
	|            if (!GetConsoleScreenBufferInfoEx(OutputHandle, ref csbi))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|            var sz = new Size(csbi.srWindow.Right - csbi.srWindow.Left + 1,
	|                csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
	|            position = new Point(csbi.srWindow.Left, csbi.srWindow.Top);
	|
	|            return sz;
	|        }
	|
	|        internal Size SetConsoleWindow(short cols, short rows)
	|        {
	|            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
	|            csbi.cbSize = (uint)Marshal.SizeOf(csbi);
	|
	|            if (!GetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|            var maxWinSize = GetLargestConsoleWindowSize(IsWindowsTerminal ? OutputHandle : screenBuffer);
	|            var newCols = Math.Min(cols, maxWinSize.X);
	|            var newRows = Math.Min(rows, maxWinSize.Y);
	|            csbi.dwSize = new Coord(newCols, Math.Max(newRows, (short)1));
	|            csbi.srWindow = new SmallRect(0, 0, newCols, newRows);
	|            csbi.dwMaximumWindowSize = new Coord(newCols, newRows);
	|            if (!SetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|            var winRect = new SmallRect(0, 0, (short)(newCols - 1), (short)Math.Max(newRows - 1, 0));
	|            if (!SetConsoleWindowInfo(OutputHandle, true, ref winRect))
	|            {
	|                //throw new System.ComponentModel.Win32Exception (Marshal.GetLastWin32Error ());
	|                return new Size(cols, rows);
	|            }
	|            SetConsoleOutputWindow(csbi);
	|            return new Size(winRect.Right + 1, newRows - 1 < 0 ? 0 : winRect.Bottom + 1);
	|        }
	|
	|        void SetConsoleOutputWindow(CONSOLE_SCREEN_BUFFER_INFOEX csbi)
	|        {
	|            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) != IntPtr.Zero && !SetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|        }
	|
	|        internal Size SetConsoleOutputWindow(out Point position)
	|        {
	|            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) == IntPtr.Zero)
	|            {
	|                position = Point.Empty;
	|                return Size.Empty;
	|            }
	|
	|            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
	|            csbi.cbSize = (uint)Marshal.SizeOf(csbi);
	|            if (!GetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|            var sz = new Size(csbi.srWindow.Right - csbi.srWindow.Left + 1,
	|                Math.Max(csbi.srWindow.Bottom - csbi.srWindow.Top + 1, 0));
	|            position = new Point(csbi.srWindow.Left, csbi.srWindow.Top);
	|            SetConsoleOutputWindow(csbi);
	|            var winRect = new SmallRect(0, 0, (short)(sz.Width - 1), (short)Math.Max(sz.Height - 1, 0));
	|            if (!SetConsoleScreenBufferInfoEx(OutputHandle, ref csbi))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|            if (!SetConsoleWindowInfo(OutputHandle, true, ref winRect))
	|            {
	|                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
	|            }
	|
	|            return sz;
	|        }
	|
	|        //bool ContinueListeningForConsoleEvents = true;
	|
	|        internal bool IsWindowsTerminal { get; set; }
	|
	|        public uint ConsoleMode
	|        {
	|            get
	|            {
	|                GetConsoleMode(InputHandle, out uint v);
	|                return v;
	|            }
	|            set
	|            {
	|                SetConsoleMode(InputHandle, value);
	|            }
	|        }
	|
	|        [Flags]
	|        public enum ConsoleModes : uint
	|        {
	|            EnableProcessedInput = 1,
	|            EnableMouseInput = 16,
	|            EnableQuickEditMode = 64,
	|            EnableExtendedFlags = 128,
	|        }
	|
	|        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
	|        public struct KeyEventRecord
	|        {
	|            [FieldOffset(0), MarshalAs(UnmanagedType.Bool)]
	|            public bool bKeyDown;
	|            [FieldOffset(4), MarshalAs(UnmanagedType.U2)]
	|            public ushort wRepeatCount;
	|            [FieldOffset(6), MarshalAs(UnmanagedType.U2)]
	|            public ushort wVirtualKeyCode;
	|            [FieldOffset(8), MarshalAs(UnmanagedType.U2)]
	|            public ushort wVirtualScanCode;
	|            [FieldOffset(10)]
	|            public char UnicodeChar;
	|            [FieldOffset(12), MarshalAs(UnmanagedType.U4)]
	|            public ControlKeyState dwControlKeyState;
	|        }
	|
	|        [Flags]
	|        public enum ButtonState
	|        {
	|            Button1Pressed = 1,
	|            Button2Pressed = 4,
	|            Button3Pressed = 8,
	|            Button4Pressed = 16,
	|            RightmostButtonPressed = 2
	|        }
	|
	|        [Flags]
	|        public enum ControlKeyState
	|        {
	|            RightAltPressed = 1,
	|            LeftAltPressed = 2,
	|            RightControlPressed = 4,
	|            LeftControlPressed = 8,
	|            ShiftPressed = 16,
	|            NumlockOn = 32,
	|            ScrolllockOn = 64,
	|            CapslockOn = 128,
	|            EnhancedKey = 256
	|        }
	|
	|        [Flags]
	|        public enum EventFlags
	|        {
	|            MouseMoved = 1,
	|            DoubleClick = 2,
	|            MouseWheeled = 4,
	|            MouseHorizontalWheeled = 8
	|        }
	|
	|        [StructLayout(LayoutKind.Explicit)]
	|        public struct MouseEventRecord
	|        {
	|            [FieldOffset(0)]
	|            public Coord MousePosition;
	|            [FieldOffset(4)]
	|            public ButtonState ButtonState;
	|            [FieldOffset(8)]
	|            public ControlKeyState ControlKeyState;
	|            [FieldOffset(12)]
	|            public EventFlags EventFlags;
	|
	|            public override string ToString()
	|            {
	|                return $""[Mouse({MousePosition},{ButtonState},{ControlKeyState},{EventFlags}"";
	|            }
	|        }
	|
	|        public struct WindowBufferSizeRecord
	|        {
	|            public Coord size;
	|
	|            public WindowBufferSizeRecord(short x, short y)
	|            {
	|                this.size = new Coord(x, y);
	|            }
	|
	|            public override string ToString() => $""[WindowBufferSize{size}"";
	|        }
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct MenuEventRecord
	|        {
	|            public uint dwCommandId;
	|        }
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct FocusEventRecord
	|        {
	|            public uint bSetFocus;
	|        }
	|
	|        public enum EventType : ushort
	|        {
	|            Focus = 0x10,
	|            Key = 0x1,
	|            Menu = 0x8,
	|            Mouse = 2,
	|            WindowBufferSize = 4
	|        }
	|
	|        [StructLayout(LayoutKind.Explicit)]
	|        public struct InputRecord
	|        {
	|            [FieldOffset(0)]
	|            public EventType EventType;
	|            [FieldOffset(4)]
	|            public KeyEventRecord KeyEvent;
	|            [FieldOffset(4)]
	|            public MouseEventRecord MouseEvent;
	|            [FieldOffset(4)]
	|            public WindowBufferSizeRecord WindowBufferSizeEvent;
	|            [FieldOffset(4)]
	|            public MenuEventRecord MenuEvent;
	|            [FieldOffset(4)]
	|            public FocusEventRecord FocusEvent;
	|
	|            public override string ToString()
	|            {
	|                switch (EventType)
	|                {
	|                    case EventType.Focus:
	|                        return FocusEvent.ToString();
	|                    case EventType.Key:
	|                        return KeyEvent.ToString();
	|                    case EventType.Menu:
	|                        return MenuEvent.ToString();
	|                    case EventType.Mouse:
	|                        return MouseEvent.ToString();
	|                    case EventType.WindowBufferSize:
	|                        return WindowBufferSizeEvent.ToString();
	|                    default:
	|                        return ""Unknown event type: "" + EventType;
	|                }
	|            }
	|        };
	|
	|        [Flags]
	|        enum ShareMode : uint
	|        {
	|            FileShareRead = 1,
	|            FileShareWrite = 2,
	|        }
	|
	|        [Flags]
	|        enum DesiredAccess : uint
	|        {
	|            GenericRead = 2147483648,
	|            GenericWrite = 1073741824,
	|        }
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct ConsoleScreenBufferInfo
	|        {
	|            public Coord dwSize;
	|            public Coord dwCursorPosition;
	|            public ushort wAttributes;
	|            public SmallRect srWindow;
	|            public Coord dwMaximumWindowSize;
	|        }
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct Coord
	|        {
	|            public short X;
	|            public short Y;
	|
	|            public Coord(short X, short Y)
	|            {
	|                this.X = X;
	|                this.Y = Y;
	|            }
	|            public override string ToString() => $""({X},{Y})"";
	|        };
	|
	|        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
	|        public struct CharUnion
	|        {
	|            [FieldOffset(0)] public char UnicodeChar;
	|            [FieldOffset(0)] public byte AsciiChar;
	|        }
	|
	|        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
	|        public struct CharInfo
	|        {
	|            [FieldOffset(0)] public CharUnion Char;
	|            [FieldOffset(2)] public ushort Attributes;
	|        }
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct SmallRect
	|        {
	|            public short Left;
	|            public short Top;
	|            public short Right;
	|            public short Bottom;
	|
	|            public SmallRect(short left, short top, short right, short bottom)
	|            {
	|                Left = left;
	|                Top = top;
	|                Right = right;
	|                Bottom = bottom;
	|            }
	|
	|            public static void MakeEmpty(ref SmallRect rect)
	|            {
	|                rect.Left = -1;
	|            }
	|
	|            public static void Update(ref SmallRect rect, short col, short row)
	|            {
	|                if (rect.Left == -1)
	|                {
	|                    //System.Diagnostics.Debugger.Log (0, ""debug"", $""damager From Empty {col},{row}\n"");
	|                    rect.Left = rect.Right = col;
	|                    rect.Bottom = rect.Top = row;
	|                    return;
	|                }
	|                if (col >= rect.Left && col <= rect.Right && row >= rect.Top && row <= rect.Bottom)
	|                    return;
	|                if (col < rect.Left)
	|                    rect.Left = col;
	|                if (col > rect.Right)
	|                    rect.Right = col;
	|                if (row < rect.Top)
	|                    rect.Top = row;
	|                if (row > rect.Bottom)
	|                    rect.Bottom = row;
	|                //System.Diagnostics.Debugger.Log (0, ""debug"", $""Expanding {rect.ToString ()}\n"");
	|            }
	|
	|            public override string ToString()
	|            {
	|                return $""Left={Left},Top={Top},Right={Right},Bottom={Bottom}"";
	|            }
	|        }
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct ConsoleKeyInfoEx
	|        {
	|            public ConsoleKeyInfo consoleKeyInfo;
	|            public bool CapsLock;
	|            public bool NumLock;
	|            public bool Scrolllock;
	|
	|            public ConsoleKeyInfoEx(ConsoleKeyInfo consoleKeyInfo, bool capslock, bool numlock, bool scrolllock)
	|            {
	|                this.consoleKeyInfo = consoleKeyInfo;
	|                CapsLock = capslock;
	|                NumLock = numlock;
	|                Scrolllock = scrolllock;
	|            }
	|        }
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern IntPtr GetStdHandle(int nStdHandle);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool CloseHandle(IntPtr handle);
	|
	|        [DllImport(""kernel32.dll"", EntryPoint = ""ReadConsoleInputW"", CharSet = CharSet.Unicode)]
	|        public static extern bool ReadConsoleInput(
	|            IntPtr hConsoleInput,
	|            IntPtr lpBuffer,
	|            uint nLength,
	|            out uint lpNumberOfEventsRead);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true, CharSet = CharSet.Unicode)]
	|        static extern bool ReadConsoleOutput(
	|            IntPtr hConsoleOutput,
	|            [Out] CharInfo[] lpBuffer,
	|            Coord dwBufferSize,
	|            Coord dwBufferCoord,
	|            ref SmallRect lpReadRegion
	|        );
	|
	|        [DllImport(""kernel32.dll"", EntryPoint = ""WriteConsoleOutput"", SetLastError = true, CharSet = CharSet.Unicode)]
	|        static extern bool WriteConsoleOutput(
	|            IntPtr hConsoleOutput,
	|            CharInfo[] lpBuffer,
	|            Coord dwBufferSize,
	|            Coord dwBufferCoord,
	|            ref SmallRect lpWriteRegion
	|        );
	|
	|        [DllImport(""kernel32.dll"")]
	|        static extern bool SetConsoleCursorPosition(IntPtr hConsoleOutput, Coord dwCursorPosition);
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct ConsoleCursorInfo
	|        {
	|            public uint dwSize;
	|            public bool bVisible;
	|        }
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool SetConsoleCursorInfo(IntPtr hConsoleOutput, [In] ref ConsoleCursorInfo lpConsoleCursorInfo);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool GetConsoleCursorInfo(IntPtr hConsoleOutput, out ConsoleCursorInfo lpConsoleCursorInfo);
	|
	|        [DllImport(""kernel32.dll"")]
	|        static extern bool GetConsoleMode(IntPtr hConsoleHandle, out uint lpMode);
	|
	|
	|        [DllImport(""kernel32.dll"")]
	|        static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint dwMode);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern IntPtr CreateConsoleScreenBuffer(
	|            DesiredAccess dwDesiredAccess,
	|            ShareMode dwShareMode,
	|            IntPtr secutiryAttributes,
	|            uint flags,
	|            IntPtr screenBufferData
	|        );
	|
	|        internal static IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool SetConsoleActiveScreenBuffer(IntPtr Handle);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool GetNumberOfConsoleInputEvents(IntPtr handle, out uint lpcNumberOfEvents);
	|        public uint InputEventCount
	|        {
	|            get
	|            {
	|                GetNumberOfConsoleInputEvents(InputHandle, out uint v);
	|                return v;
	|            }
	|        }
	|
	|        public InputRecord[] ReadConsoleInput()
	|        {
	|            const int bufferSize = 1;
	|            var pRecord = Marshal.AllocHGlobal(Marshal.SizeOf<InputRecord>() * bufferSize);
	|            try
	|            {
	|                ReadConsoleInput(InputHandle, pRecord, bufferSize,
	|                    out var numberEventsRead);
	|
	|                return numberEventsRead == 0
	|                    ? null
	|                    : new[] { Marshal.PtrToStructure<InputRecord>(pRecord) };
	|            }
	|            catch (Exception)
	|            {
	|                return null;
	|            }
	|            finally
	|            {
	|                Marshal.FreeHGlobal(pRecord);
	|            }
	|        }
	|
	|#if false      // Not needed on the constructor. Perhaps could be used on resizing. To study.                                                                                     
	|		[DllImport (""kernel32.dll"", ExactSpelling = true)]
	|		static extern IntPtr GetConsoleWindow ();
	|
	|		[DllImport (""user32.dll"", CharSet = CharSet.Auto, SetLastError = true)]
	|		static extern bool ShowWindow (IntPtr hWnd, int nCmdShow);
	|
	|		public const int HIDE = 0;
	|		public const int MAXIMIZE = 3;
	|		public const int MINIMIZE = 6;
	|		public const int RESTORE = 9;
	|
	|		internal void ShowWindow (int state)
	|		{
	|			IntPtr thisConsole = GetConsoleWindow ();
	|			ShowWindow (thisConsole, state);
	|		}
	|#endif
	|        // See: https://github.com/gui-cs/Terminal.Gui/issues/357
	|
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct CONSOLE_SCREEN_BUFFER_INFOEX
	|        {
	|            public uint cbSize;
	|            public Coord dwSize;
	|            public Coord dwCursorPosition;
	|            public ushort wAttributes;
	|            public SmallRect srWindow;
	|            public Coord dwMaximumWindowSize;
	|            public ushort wPopupAttributes;
	|            public bool bFullscreenSupported;
	|
	|            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
	|            public COLORREF[] ColorTable;
	|        }
	|
	|        [StructLayout(LayoutKind.Explicit, Size = 4)]
	|        public struct COLORREF
	|        {
	|            public COLORREF(byte r, byte g, byte b)
	|            {
	|                Value = 0;
	|                R = r;
	|                G = g;
	|                B = b;
	|            }
	|
	|            public COLORREF(uint value)
	|            {
	|                R = 0;
	|                G = 0;
	|                B = 0;
	|                Value = value & 0x00FFFFFF;
	|            }
	|
	|            [FieldOffset(0)]
	|            public byte R;
	|            [FieldOffset(1)]
	|            public byte G;
	|            [FieldOffset(2)]
	|            public byte B;
	|
	|            [FieldOffset(0)]
	|            public uint Value;
	|        }
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool GetConsoleScreenBufferInfoEx(IntPtr hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFOEX csbi);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool SetConsoleScreenBufferInfoEx(IntPtr hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFOEX ConsoleScreenBufferInfo);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern bool SetConsoleWindowInfo(
	|            IntPtr hConsoleOutput,
	|            bool bAbsolute,
	|            [In] ref SmallRect lpConsoleWindow);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern Coord GetLargestConsoleWindowSize(
	|            IntPtr hConsoleOutput);
	|    }
	|
	|    internal class WindowsDriver : ConsoleDriver
	|    {
	|        static bool sync = false;
	|        WindowsConsole.CharInfo[] OutputBuffer;
	|        int cols, rows, left, top;
	|        WindowsConsole.SmallRect damageRegion;
	|        IClipboard clipboard;
	|        int[,,] contents;
	|        readonly bool isWindowsTerminal;
	|
	|        public override int Cols => cols;
	|        public override int Rows => rows;
	|        public override int Left => left;
	|        public override int Top => top;
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool EnableConsoleScrolling { get; set; }
	|        [Obsolete(""This API is deprecated"", false)]
	|        public override bool HeightAsBuffer { get; set; }
	|        public override IClipboard Clipboard => clipboard;
	|        public override int[,,] Contents => contents;
	|
	|        public WindowsConsole WinConsole { get; private set; }
	|
	|        Action<KeyEvent> keyHandler;
	|        Action<KeyEvent> keyDownHandler;
	|        Action<KeyEvent> keyUpHandler;
	|        Action<MouseEvent> mouseHandler;
	|
	|        public WindowsDriver()
	|        {
	|            WinConsole = new WindowsConsole();
	|            clipboard = new WindowsClipboard();
	|
	|            WinConsole.IsWindowsTerminal = isWindowsTerminal = Environment.GetEnvironmentVariable(""WT_SESSION"") != null || Environment.GetEnvironmentVariable(""VSAPPIDNAME"") != null;
	|        }
	|
	|        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
	|        {
	|            this.keyHandler = keyHandler;
	|            this.keyDownHandler = keyDownHandler;
	|            this.keyUpHandler = keyUpHandler;
	|            this.mouseHandler = mouseHandler;
	|
	|            var mLoop = mainLoop.Driver as WindowsMainLoop;
	|
	|            mLoop.ProcessInput = (e) => ProcessInput(e);
	|
	|            mLoop.WinChanged = (e) =>
	|            {
	|                ChangeWin(e);
	|            };
	|        }
	|
	|        private void ChangeWin(Size e)
	|        {
	|            var w = e.Width;
	|            if (w == cols - 3 && e.Height < rows)
	|            {
	|                w += 3;
	|            }
	|            var newSize = WinConsole.SetConsoleWindow(
	|                (short)Math.Max(w, 16), (short)Math.Max(e.Height, 0));
	|
	|            left = 0;
	|            top = 0;
	|            cols = newSize.Width;
	|            rows = newSize.Height;
	|            ResizeScreen();
	|            UpdateOffScreen();
	|            TerminalResized.Invoke();
	|        }
	|
	|        void ProcessInput(WindowsConsole.InputRecord inputEvent)
	|        {
	|            switch (inputEvent.EventType)
	|            {
	|                case WindowsConsole.EventType.Key:
	|                    var fromPacketKey = inputEvent.KeyEvent.wVirtualKeyCode == (uint)ConsoleKey.Packet;
	|                    if (fromPacketKey)
	|                    {
	|                        inputEvent.KeyEvent = FromVKPacketToKeyEventRecord(inputEvent.KeyEvent);
	|                    }
	|                    var map = MapKey(ToConsoleKeyInfoEx(inputEvent.KeyEvent));
	|                    //var ke = inputEvent.KeyEvent;
	|                    //System.Diagnostics.Debug.WriteLine ($""fromPacketKey: {fromPacketKey}"");
	|                    //if (ke.UnicodeChar == '\0') {
	|                    //	System.Diagnostics.Debug.WriteLine (""UnicodeChar: 0'\\0'"");
	|                    //} else if (ke.UnicodeChar == 13) {
	|                    //	System.Diagnostics.Debug.WriteLine (""UnicodeChar: 13'\\n'"");
	|                    //} else {
	|                    //	System.Diagnostics.Debug.WriteLine ($""UnicodeChar: {(uint)ke.UnicodeChar}'{ke.UnicodeChar}'"");
	|                    //}
	|                    //System.Diagnostics.Debug.WriteLine ($""bKeyDown: {ke.bKeyDown}"");
	|                    //System.Diagnostics.Debug.WriteLine ($""dwControlKeyState: {ke.dwControlKeyState}"");
	|                    //System.Diagnostics.Debug.WriteLine ($""wRepeatCount: {ke.wRepeatCount}"");
	|                    //System.Diagnostics.Debug.WriteLine ($""wVirtualKeyCode: {ke.wVirtualKeyCode}"");
	|                    //System.Diagnostics.Debug.WriteLine ($""wVirtualScanCode: {ke.wVirtualScanCode}"");
	|
	|                    if (map == (Key)0xffffffff)
	|                    {
	|                        KeyEvent key = new KeyEvent();
	|
	|                        // Shift = VK_SHIFT = 0x10
	|                        // Ctrl = VK_CONTROL = 0x11
	|                        // Alt = VK_MENU = 0x12
	|
	|                        if (inputEvent.KeyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.CapslockOn))
	|                        {
	|                            inputEvent.KeyEvent.dwControlKeyState &= ~WindowsConsole.ControlKeyState.CapslockOn;
	|                        }
	|
	|                        if (inputEvent.KeyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.ScrolllockOn))
	|                        {
	|                            inputEvent.KeyEvent.dwControlKeyState &= ~WindowsConsole.ControlKeyState.ScrolllockOn;
	|                        }
	|
	|                        if (inputEvent.KeyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.NumlockOn))
	|                        {
	|                            inputEvent.KeyEvent.dwControlKeyState &= ~WindowsConsole.ControlKeyState.NumlockOn;
	|                        }
	|
	|                        switch (inputEvent.KeyEvent.dwControlKeyState)
	|                        {
	|                            case WindowsConsole.ControlKeyState.RightAltPressed:
	|                            case WindowsConsole.ControlKeyState.RightAltPressed |
	|                            WindowsConsole.ControlKeyState.LeftControlPressed |
	|                            WindowsConsole.ControlKeyState.EnhancedKey:
	|                            case WindowsConsole.ControlKeyState.EnhancedKey:
	|                                key = new KeyEvent(Key.CtrlMask | Key.AltMask, keyModifiers);
	|                                break;
	|                            case WindowsConsole.ControlKeyState.LeftAltPressed:
	|                                key = new KeyEvent(Key.AltMask, keyModifiers);
	|                                break;
	|                            case WindowsConsole.ControlKeyState.RightControlPressed:
	|                            case WindowsConsole.ControlKeyState.LeftControlPressed:
	|                                key = new KeyEvent(Key.CtrlMask, keyModifiers);
	|                                break;
	|                            case WindowsConsole.ControlKeyState.ShiftPressed:
	|                                key = new KeyEvent(Key.ShiftMask, keyModifiers);
	|                                break;
	|                            case WindowsConsole.ControlKeyState.NumlockOn:
	|                                break;
	|                            case WindowsConsole.ControlKeyState.ScrolllockOn:
	|                                break;
	|                            case WindowsConsole.ControlKeyState.CapslockOn:
	|                                break;
	|                            default:
	|                                switch (inputEvent.KeyEvent.wVirtualKeyCode)
	|                                {
	|                                    case 0x10:
	|                                        key = new KeyEvent(Key.ShiftMask, keyModifiers);
	|                                        break;
	|                                    case 0x11:
	|                                        key = new KeyEvent(Key.CtrlMask, keyModifiers);
	|                                        break;
	|                                    case 0x12:
	|                                        key = new KeyEvent(Key.AltMask, keyModifiers);
	|                                        break;
	|                                    default:
	|                                        key = new KeyEvent(Key.Unknown, keyModifiers);
	|                                        break;
	|                                }
	|                                break;
	|                        }
	|
	|                        if (inputEvent.KeyEvent.bKeyDown)
	|                            keyDownHandler(key);
	|                        else
	|                            keyUpHandler(key);
	|                    }
	|                    else
	|                    {
	|                        if (inputEvent.KeyEvent.bKeyDown)
	|                        {
	|                            // May occurs using SendKeys
	|                            if (keyModifiers == null)
	|                                keyModifiers = new KeyModifiers();
	|                            // Key Down - Fire KeyDown Event and KeyStroke (ProcessKey) Event
	|                            keyDownHandler(new KeyEvent(map, keyModifiers));
	|                            keyHandler(new KeyEvent(map, keyModifiers));
	|                        }
	|                        else
	|                        {
	|                            keyUpHandler(new KeyEvent(map, keyModifiers));
	|                        }
	|                    }
	|                    if (!inputEvent.KeyEvent.bKeyDown && (inputEvent.KeyEvent.dwControlKeyState == 0 || inputEvent.KeyEvent.dwControlKeyState == WindowsConsole.ControlKeyState.EnhancedKey))
	|                    {
	|                        keyModifiers = null;
	|                    }
	|                    break;
	|
	|                case WindowsConsole.EventType.Mouse:
	|                    var me = ToDriverMouse(inputEvent.MouseEvent);
	|                    mouseHandler(me);
	|                    if (processButtonClick)
	|                    {
	|                        mouseHandler(
	|                            new MouseEvent()
	|                            {
	|                                X = me.X,
	|                                Y = me.Y,
	|                                Flags = ProcessButtonClick(inputEvent.MouseEvent)
	|                            });
	|                    }
	|                    break;
	|
	|                case WindowsConsole.EventType.Focus:
	|                    keyModifiers = null;
	|                    break;
	|            }
	|        }
	|
	|        WindowsConsole.ButtonState? lastMouseButtonPressed = null;
	|        bool isButtonPressed = false;
	|        bool isButtonReleased = false;
	|        bool isButtonDoubleClicked = false;
	|        Point? point;
	|        Point pointMove;
	|        //int buttonPressedCount;
	|        bool isOneFingerDoubleClicked = false;
	|        bool processButtonClick;
	|
	|        MouseEvent ToDriverMouse(WindowsConsole.MouseEventRecord mouseEvent)
	|        {
	|            MouseFlags mouseFlag = MouseFlags.AllEvents;
	|
	|            //System.Diagnostics.Debug.WriteLine (
	|            //	$""X:{mouseEvent.MousePosition.X};Y:{mouseEvent.MousePosition.Y};ButtonState:{mouseEvent.ButtonState};EventFlags:{mouseEvent.EventFlags}"");
	|
	|            if (isButtonDoubleClicked || isOneFingerDoubleClicked)
	|            {
	|                Application.MainLoop.AddIdle(() =>
	|                {
	|                    Task.Run(async () => await ProcessButtonDoubleClickedAsync());
	|                    return false;
	|                });
	|            }
	|
	|            // The ButtonState member of the MouseEvent structure has bit corresponding to each mouse button.
	|            // This will tell when a mouse button is pressed. When the button is released this event will
	|            // be fired with it's bit set to 0. So when the button is up ButtonState will be 0.
	|            // To map to the correct driver events we save the last pressed mouse button so we can
	|            // map to the correct clicked event.
	|            if ((lastMouseButtonPressed != null || isButtonReleased) && mouseEvent.ButtonState != 0)
	|            {
	|                lastMouseButtonPressed = null;
	|                //isButtonPressed = false;
	|                isButtonReleased = false;
	|            }
	|
	|            var p = new Point()
	|            {
	|                X = mouseEvent.MousePosition.X,
	|                Y = mouseEvent.MousePosition.Y
	|            };
	|
	|            //if (!isButtonPressed && buttonPressedCount < 2
	|            //	&& mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved
	|            //	&& (mouseEvent.ButtonState == WindowsConsole.ButtonState.Button1Pressed
	|            //	|| mouseEvent.ButtonState == WindowsConsole.ButtonState.Button2Pressed
	|            //	|| mouseEvent.ButtonState == WindowsConsole.ButtonState.Button3Pressed)) {
	|
	|            //	lastMouseButtonPressed = mouseEvent.ButtonState;
	|            //	buttonPressedCount++;
	|            //} else if (!isButtonPressed && buttonPressedCount > 0 && mouseEvent.ButtonState == 0
	|            //	&& mouseEvent.EventFlags == 0) {
	|
	|            //	buttonPressedCount++;
	|            //}
	|            //System.Diagnostics.Debug.WriteLine ($""isButtonPressed: {isButtonPressed};buttonPressedCount: {buttonPressedCount};lastMouseButtonPressed: {lastMouseButtonPressed}"");
	|            //System.Diagnostics.Debug.WriteLine ($""isOneFingerDoubleClicked: {isOneFingerDoubleClicked}"");
	|
	|            //if (buttonPressedCount == 1 && lastMouseButtonPressed != null && p == point
	|            //	&& lastMouseButtonPressed == WindowsConsole.ButtonState.Button1Pressed
	|            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button2Pressed
	|            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button3Pressed) {
	|
	|            //	switch (lastMouseButtonPressed) {
	|            //	case WindowsConsole.ButtonState.Button1Pressed:
	|            //		mouseFlag = MouseFlags.Button1DoubleClicked;
	|            //		break;
	|
	|            //	case WindowsConsole.ButtonState.Button2Pressed:
	|            //		mouseFlag = MouseFlags.Button2DoubleClicked;
	|            //		break;
	|
	|            //	case WindowsConsole.ButtonState.Button3Pressed:
	|            //		mouseFlag = MouseFlags.Button3DoubleClicked;
	|            //		break;
	|            //	}
	|            //	isOneFingerDoubleClicked = true;
	|
	|            //} else if (buttonPressedCount == 3 && lastMouseButtonPressed != null && isOneFingerDoubleClicked && p == point
	|            //	&& lastMouseButtonPressed == WindowsConsole.ButtonState.Button1Pressed
	|            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button2Pressed
	|            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button3Pressed) {
	|
	|            //	switch (lastMouseButtonPressed) {
	|            //	case WindowsConsole.ButtonState.Button1Pressed:
	|            //		mouseFlag = MouseFlags.Button1TripleClicked;
	|            //		break;
	|
	|            //	case WindowsConsole.ButtonState.Button2Pressed:
	|            //		mouseFlag = MouseFlags.Button2TripleClicked;
	|            //		break;
	|
	|            //	case WindowsConsole.ButtonState.Button3Pressed:
	|            //		mouseFlag = MouseFlags.Button3TripleClicked;
	|            //		break;
	|            //	}
	|            //	buttonPressedCount = 0;
	|            //	lastMouseButtonPressed = null;
	|            //	isOneFingerDoubleClicked = false;
	|            //	isButtonReleased = false;
	|
	|            //}
	|            if ((mouseEvent.ButtonState != 0 && mouseEvent.EventFlags == 0 && lastMouseButtonPressed == null && !isButtonDoubleClicked) ||
	|                 (lastMouseButtonPressed == null && mouseEvent.EventFlags.HasFlag(WindowsConsole.EventFlags.MouseMoved) &&
	|                 mouseEvent.ButtonState != 0 && !isButtonReleased && !isButtonDoubleClicked))
	|            {
	|                switch (mouseEvent.ButtonState)
	|                {
	|                    case WindowsConsole.ButtonState.Button1Pressed:
	|                        mouseFlag = MouseFlags.Button1Pressed;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.Button2Pressed:
	|                        mouseFlag = MouseFlags.Button2Pressed;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.RightmostButtonPressed:
	|                        mouseFlag = MouseFlags.Button3Pressed;
	|                        break;
	|                }
	|
	|                if (point == null)
	|                    point = p;
	|
	|                if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved)
	|                {
	|                    mouseFlag |= MouseFlags.ReportMousePosition;
	|                    isButtonReleased = false;
	|                    processButtonClick = false;
	|                }
	|                lastMouseButtonPressed = mouseEvent.ButtonState;
	|                isButtonPressed = true;
	|
	|                if ((mouseFlag & MouseFlags.ReportMousePosition) == 0)
	|                {
	|                    Application.MainLoop.AddIdle(() =>
	|                    {
	|                        Task.Run(async () => await ProcessContinuousButtonPressedAsync(mouseFlag));
	|                        return false;
	|                    });
	|                }
	|
	|            }
	|            else if (lastMouseButtonPressed != null && mouseEvent.EventFlags == 0
	|              && !isButtonReleased && !isButtonDoubleClicked && !isOneFingerDoubleClicked)
	|            {
	|                switch (lastMouseButtonPressed)
	|                {
	|                    case WindowsConsole.ButtonState.Button1Pressed:
	|                        mouseFlag = MouseFlags.Button1Released;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.Button2Pressed:
	|                        mouseFlag = MouseFlags.Button2Released;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.RightmostButtonPressed:
	|                        mouseFlag = MouseFlags.Button3Released;
	|                        break;
	|                }
	|                isButtonPressed = false;
	|                isButtonReleased = true;
	|                if (point != null && (((Point)point).X == mouseEvent.MousePosition.X && ((Point)point).Y == mouseEvent.MousePosition.Y))
	|                {
	|                    processButtonClick = true;
	|                }
	|                else
	|                {
	|                    point = null;
	|                }
	|            }
	|            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved
	|              && !isOneFingerDoubleClicked && isButtonReleased && p == point)
	|            {
	|
	|                mouseFlag = ProcessButtonClick(mouseEvent);
	|
	|            }
	|            else if (mouseEvent.EventFlags.HasFlag(WindowsConsole.EventFlags.DoubleClick))
	|            {
	|                switch (mouseEvent.ButtonState)
	|                {
	|                    case WindowsConsole.ButtonState.Button1Pressed:
	|                        mouseFlag = MouseFlags.Button1DoubleClicked;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.Button2Pressed:
	|                        mouseFlag = MouseFlags.Button2DoubleClicked;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.RightmostButtonPressed:
	|                        mouseFlag = MouseFlags.Button3DoubleClicked;
	|                        break;
	|                }
	|                isButtonDoubleClicked = true;
	|            }
	|            else if (mouseEvent.EventFlags == 0 && mouseEvent.ButtonState != 0 && isButtonDoubleClicked)
	|            {
	|                switch (mouseEvent.ButtonState)
	|                {
	|                    case WindowsConsole.ButtonState.Button1Pressed:
	|                        mouseFlag = MouseFlags.Button1TripleClicked;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.Button2Pressed:
	|                        mouseFlag = MouseFlags.Button2TripleClicked;
	|                        break;
	|
	|                    case WindowsConsole.ButtonState.RightmostButtonPressed:
	|                        mouseFlag = MouseFlags.Button3TripleClicked;
	|                        break;
	|                }
	|                isButtonDoubleClicked = false;
	|            }
	|            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseWheeled)
	|            {
	|                switch ((int)mouseEvent.ButtonState)
	|                {
	|                    case int v when v > 0:
	|                        mouseFlag = MouseFlags.WheeledUp;
	|                        break;
	|
	|                    case int v when v < 0:
	|                        mouseFlag = MouseFlags.WheeledDown;
	|                        break;
	|                }
	|
	|            }
	|            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseWheeled &&
	|              mouseEvent.ControlKeyState == WindowsConsole.ControlKeyState.ShiftPressed)
	|            {
	|                switch ((int)mouseEvent.ButtonState)
	|                {
	|                    case int v when v > 0:
	|                        mouseFlag = MouseFlags.WheeledLeft;
	|                        break;
	|
	|                    case int v when v < 0:
	|                        mouseFlag = MouseFlags.WheeledRight;
	|                        break;
	|                }
	|
	|            }
	|            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseHorizontalWheeled)
	|            {
	|                switch ((int)mouseEvent.ButtonState)
	|                {
	|                    case int v when v < 0:
	|                        mouseFlag = MouseFlags.WheeledLeft;
	|                        break;
	|
	|                    case int v when v > 0:
	|                        mouseFlag = MouseFlags.WheeledRight;
	|                        break;
	|                }
	|
	|            }
	|            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved)
	|            {
	|                mouseFlag = MouseFlags.ReportMousePosition;
	|                if (mouseEvent.MousePosition.X != pointMove.X || mouseEvent.MousePosition.Y != pointMove.Y)
	|                {
	|                    pointMove = new Point(mouseEvent.MousePosition.X, mouseEvent.MousePosition.Y);
	|                }
	|            }
	|            else if (mouseEvent.ButtonState == 0 && mouseEvent.EventFlags == 0)
	|            {
	|                mouseFlag = 0;
	|            }
	|
	|            mouseFlag = SetControlKeyStates(mouseEvent, mouseFlag);
	|
	|            //System.Diagnostics.Debug.WriteLine (
	|            //	$""point.X:{(point != null ? ((Point)point).X : -1)};point.Y:{(point != null ? ((Point)point).Y : -1)}"");
	|
	|            return new MouseEvent()
	|            {
	|                X = mouseEvent.MousePosition.X,
	|                Y = mouseEvent.MousePosition.Y,
	|                Flags = mouseFlag
	|            };
	|        }
	|
	|        MouseFlags ProcessButtonClick(WindowsConsole.MouseEventRecord mouseEvent)
	|        {
	|            MouseFlags mouseFlag = 0;
	|            switch (lastMouseButtonPressed)
	|            {
	|                case WindowsConsole.ButtonState.Button1Pressed:
	|                    mouseFlag = MouseFlags.Button1Clicked;
	|                    break;
	|
	|                case WindowsConsole.ButtonState.Button2Pressed:
	|                    mouseFlag = MouseFlags.Button2Clicked;
	|                    break;
	|
	|                case WindowsConsole.ButtonState.RightmostButtonPressed:
	|                    mouseFlag = MouseFlags.Button3Clicked;
	|                    break;
	|            }
	|            point = new Point()
	|            {
	|                X = mouseEvent.MousePosition.X,
	|                Y = mouseEvent.MousePosition.Y
	|            };
	|            lastMouseButtonPressed = null;
	|            isButtonReleased = false;
	|            processButtonClick = false;
	|            point = null;
	|            return mouseFlag;
	|        }
	|
	|        async Task ProcessButtonDoubleClickedAsync()
	|        {
	|            await Task.Delay(300);
	|            isButtonDoubleClicked = false;
	|            isOneFingerDoubleClicked = false;
	|            //buttonPressedCount = 0;
	|        }
	|
	|        async Task ProcessContinuousButtonPressedAsync(MouseFlags mouseFlag)
	|        {
	|            while (isButtonPressed)
	|            {
	|                await Task.Delay(100);
	|                var me = new MouseEvent()
	|                {
	|                    X = pointMove.X,
	|                    Y = pointMove.Y,
	|                    Flags = mouseFlag
	|                };
	|
	|                var view = Application.WantContinuousButtonPressedView;
	|                if (view == null)
	|                {
	|                    break;
	|                }
	|                if (isButtonPressed && (mouseFlag & MouseFlags.ReportMousePosition) == 0)
	|                {
	|                    Application.MainLoop.Invoke(() => mouseHandler(me));
	|                }
	|            }
	|        }
	|
	|        static MouseFlags SetControlKeyStates(WindowsConsole.MouseEventRecord mouseEvent, MouseFlags mouseFlag)
	|        {
	|            if (mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightControlPressed) ||
	|                mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftControlPressed))
	|                mouseFlag |= MouseFlags.ButtonCtrl;
	|
	|            if (mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.ShiftPressed))
	|                mouseFlag |= MouseFlags.ButtonShift;
	|
	|            if (mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightAltPressed) ||
	|                 mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftAltPressed))
	|                mouseFlag |= MouseFlags.ButtonAlt;
	|            return mouseFlag;
	|        }
	|
	|        KeyModifiers keyModifiers;
	|
	|        public WindowsConsole.ConsoleKeyInfoEx ToConsoleKeyInfoEx(WindowsConsole.KeyEventRecord keyEvent)
	|        {
	|            var state = keyEvent.dwControlKeyState;
	|
	|            bool shift = (state & WindowsConsole.ControlKeyState.ShiftPressed) != 0;
	|            bool alt = (state & (WindowsConsole.ControlKeyState.LeftAltPressed | WindowsConsole.ControlKeyState.RightAltPressed)) != 0;
	|            bool control = (state & (WindowsConsole.ControlKeyState.LeftControlPressed | WindowsConsole.ControlKeyState.RightControlPressed)) != 0;
	|            bool capslock = (state & (WindowsConsole.ControlKeyState.CapslockOn)) != 0;
	|            bool numlock = (state & (WindowsConsole.ControlKeyState.NumlockOn)) != 0;
	|            bool scrolllock = (state & (WindowsConsole.ControlKeyState.ScrolllockOn)) != 0;
	|
	|            if (keyModifiers == null)
	|                keyModifiers = new KeyModifiers();
	|            if (shift)
	|                keyModifiers.Shift = shift;
	|            if (alt)
	|                keyModifiers.Alt = alt;
	|            if (control)
	|                keyModifiers.Ctrl = control;
	|            if (capslock)
	|                keyModifiers.Capslock = capslock;
	|            if (numlock)
	|                keyModifiers.Numlock = numlock;
	|            if (scrolllock)
	|                keyModifiers.Scrolllock = scrolllock;
	|
	|            var ConsoleKeyInfo = new ConsoleKeyInfo(keyEvent.UnicodeChar, (ConsoleKey)keyEvent.wVirtualKeyCode, shift, alt, control);
	|
	|            return new WindowsConsole.ConsoleKeyInfoEx(ConsoleKeyInfo, capslock, numlock, scrolllock);
	|        }
	|
	|        public WindowsConsole.KeyEventRecord FromVKPacketToKeyEventRecord(WindowsConsole.KeyEventRecord keyEvent)
	|        {
	|            if (keyEvent.wVirtualKeyCode != (uint)ConsoleKey.Packet)
	|            {
	|                return keyEvent;
	|            }
	|
	|            var mod = new ConsoleModifiers();
	|            if (keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.ShiftPressed))
	|            {
	|                mod |= ConsoleModifiers.Shift;
	|            }
	|            if (keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightAltPressed) ||
	|                keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftAltPressed))
	|            {
	|                mod |= ConsoleModifiers.Alt;
	|            }
	|            if (keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftControlPressed) ||
	|                keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightControlPressed))
	|            {
	|                mod |= ConsoleModifiers.Control;
	|            }
	|            var keyChar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(keyEvent.UnicodeChar, mod, out uint virtualKey, out uint scanCode);
	|
	|            return new WindowsConsole.KeyEventRecord
	|            {
	|                UnicodeChar = (char)keyChar,
	|                bKeyDown = keyEvent.bKeyDown,
	|                dwControlKeyState = keyEvent.dwControlKeyState,
	|                wRepeatCount = keyEvent.wRepeatCount,
	|                wVirtualKeyCode = (ushort)virtualKey,
	|                wVirtualScanCode = (ushort)scanCode
	|            };
	|        }
	|
	|        public Key MapKey(WindowsConsole.ConsoleKeyInfoEx keyInfoEx)
	|        {
	|            var keyInfo = keyInfoEx.consoleKeyInfo;
	|            switch (keyInfo.Key)
	|            {
	|                case ConsoleKey.Escape:
	|                    return MapKeyModifiers(keyInfo, Key.Esc);
	|                case ConsoleKey.Tab:
	|                    return keyInfo.Modifiers == ConsoleModifiers.Shift ? Key.BackTab : Key.Tab;
	|                case ConsoleKey.Clear:
	|                    return MapKeyModifiers(keyInfo, Key.Clear);
	|                case ConsoleKey.Home:
	|                    return MapKeyModifiers(keyInfo, Key.Home);
	|                case ConsoleKey.End:
	|                    return MapKeyModifiers(keyInfo, Key.End);
	|                case ConsoleKey.LeftArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorLeft);
	|                case ConsoleKey.RightArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorRight);
	|                case ConsoleKey.UpArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorUp);
	|                case ConsoleKey.DownArrow:
	|                    return MapKeyModifiers(keyInfo, Key.CursorDown);
	|                case ConsoleKey.PageUp:
	|                    return MapKeyModifiers(keyInfo, Key.PageUp);
	|                case ConsoleKey.PageDown:
	|                    return MapKeyModifiers(keyInfo, Key.PageDown);
	|                case ConsoleKey.Enter:
	|                    return MapKeyModifiers(keyInfo, Key.Enter);
	|                case ConsoleKey.Spacebar:
	|                    return MapKeyModifiers(keyInfo, keyInfo.KeyChar == 0 ? Key.Space : (Key)keyInfo.KeyChar);
	|                case ConsoleKey.Backspace:
	|                    return MapKeyModifiers(keyInfo, Key.Backspace);
	|                case ConsoleKey.Delete:
	|                    return MapKeyModifiers(keyInfo, Key.DeleteChar);
	|                case ConsoleKey.Insert:
	|                    return MapKeyModifiers(keyInfo, Key.InsertChar);
	|                case ConsoleKey.PrintScreen:
	|                    return MapKeyModifiers(keyInfo, Key.PrintScreen);
	|
	|                case ConsoleKey.NumPad0:
	|                    return keyInfoEx.NumLock ? Key.D0 : Key.InsertChar;
	|                case ConsoleKey.NumPad1:
	|                    return keyInfoEx.NumLock ? Key.D1 : Key.End;
	|                case ConsoleKey.NumPad2:
	|                    return keyInfoEx.NumLock ? Key.D2 : Key.CursorDown;
	|                case ConsoleKey.NumPad3:
	|                    return keyInfoEx.NumLock ? Key.D3 : Key.PageDown;
	|                case ConsoleKey.NumPad4:
	|                    return keyInfoEx.NumLock ? Key.D4 : Key.CursorLeft;
	|                case ConsoleKey.NumPad5:
	|                    return keyInfoEx.NumLock ? Key.D5 : (Key)((uint)keyInfo.KeyChar);
	|                case ConsoleKey.NumPad6:
	|                    return keyInfoEx.NumLock ? Key.D6 : Key.CursorRight;
	|                case ConsoleKey.NumPad7:
	|                    return keyInfoEx.NumLock ? Key.D7 : Key.Home;
	|                case ConsoleKey.NumPad8:
	|                    return keyInfoEx.NumLock ? Key.D8 : Key.CursorUp;
	|                case ConsoleKey.NumPad9:
	|                    return keyInfoEx.NumLock ? Key.D9 : Key.PageUp;
	|
	|                case ConsoleKey.Oem1:
	|                case ConsoleKey.Oem2:
	|                case ConsoleKey.Oem3:
	|                case ConsoleKey.Oem4:
	|                case ConsoleKey.Oem5:
	|                case ConsoleKey.Oem6:
	|                case ConsoleKey.Oem7:
	|                case ConsoleKey.Oem8:
	|                case ConsoleKey.Oem102:
	|                case ConsoleKey.OemPeriod:
	|                case ConsoleKey.OemComma:
	|                case ConsoleKey.OemPlus:
	|                case ConsoleKey.OemMinus:
	|                    if (keyInfo.KeyChar == 0)
	|                        return Key.Unknown;
	|
	|                    return (Key)((uint)keyInfo.KeyChar);
	|            }
	|
	|            var key = keyInfo.Key;
	|            //var alphaBase = ((keyInfo.Modifiers == ConsoleModifiers.Shift) ^ (keyInfoEx.CapsLock)) ? 'A' : 'a';
	|
	|            if (key >= ConsoleKey.A && key <= ConsoleKey.Z)
	|            {
	|                var delta = key - ConsoleKey.A;
	|                if (keyInfo.Modifiers == ConsoleModifiers.Control)
	|                {
	|                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.A + delta));
	|                }
	|                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
	|                {
	|                    return (Key)(((uint)Key.AltMask) | ((uint)Key.A + delta));
	|                }
	|                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
	|                {
	|                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
	|                }
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    if (keyInfo.KeyChar == 0 || (keyInfo.KeyChar != 0 && keyInfo.KeyChar >= 1 && keyInfo.KeyChar <= 26))
	|                    {
	|                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
	|                    }
	|                }
	|                //return (Key)((uint)alphaBase + delta);
	|                return (Key)((uint)keyInfo.KeyChar);
	|            }
	|            if (key >= ConsoleKey.D0 && key <= ConsoleKey.D9)
	|            {
	|                var delta = key - ConsoleKey.D0;
	|                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
	|                {
	|                    return (Key)(((uint)Key.AltMask) | ((uint)Key.D0 + delta));
	|                }
	|                if (keyInfo.Modifiers == ConsoleModifiers.Control)
	|                {
	|                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.D0 + delta));
	|                }
	|                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
	|                {
	|                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
	|                }
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    if (keyInfo.KeyChar == 0 || keyInfo.KeyChar == 30 || keyInfo.KeyChar == ((uint)Key.D0 + delta))
	|                    {
	|                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
	|                    }
	|                }
	|                return (Key)((uint)keyInfo.KeyChar);
	|            }
	|            if (key >= ConsoleKey.F1 && key <= ConsoleKey.F12)
	|            {
	|                var delta = key - ConsoleKey.F1;
	|                if ((keyInfo.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
	|                {
	|                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.F1 + delta));
	|                }
	|
	|                return (Key)((uint)Key.F1 + delta);
	|            }
	|            if (keyInfo.KeyChar != 0)
	|            {
	|                return MapKeyModifiers(keyInfo, (Key)((uint)keyInfo.KeyChar));
	|            }
	|
	|            return (Key)(0xffffffff);
	|        }
	|
	|        private Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
	|        {
	|            Key keyMod = new Key();
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
	|                keyMod = Key.ShiftMask;
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
	|                keyMod |= Key.CtrlMask;
	|            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
	|                keyMod |= Key.AltMask;
	|
	|            return keyMod != Key.Null ? keyMod | key : key;
	|        }
	|
	|        public override void Init(Action terminalResized)
	|        {
	|            TerminalResized = terminalResized;
	|
	|            try
	|            {
	|                // Needed for Windows Terminal
	|                // ESC [ ? 1047 h  Save cursor position and activate xterm alternative buffer (no backscroll)
	|                // ESC [ ? 1047 l  Restore cursor position and restore xterm working buffer (with backscroll)
	|                // ESC [ ? 1048 h  Save cursor position
	|                // ESC [ ? 1048 l  Restore cursor position
	|                // ESC [ ? 1049 h  Activate xterm alternative buffer (no backscroll)
	|                // ESC [ ? 1049 l  Restore xterm working buffer (with backscroll)
	|                // Per Issue #2264 using the alternative screen buffer is required for Windows Terminal to not 
	|                // wipe out the backscroll buffer when the application exits.
	|                if (isWindowsTerminal)
	|                {
	|                    Console.Out.Write(""\x1b[?1049h"");
	|                }
	|
	|                var winSize = WinConsole.GetConsoleOutputWindow(out Point pos);
	|                cols = winSize.Width;
	|                rows = winSize.Height;
	|                WindowsConsole.SmallRect.MakeEmpty(ref damageRegion);
	|
	|                CurrentAttribute = MakeColor(Color.White, Color.Black);
	|                InitalizeColorSchemes();
	|
	|                CurrentAttribute = MakeColor(Color.White, Color.Black);
	|                InitalizeColorSchemes();
	|
	|                OutputBuffer = new WindowsConsole.CharInfo[Rows * Cols];
	|                Clip = new Rect(0, 0, Cols, Rows);
	|                damageRegion = new WindowsConsole.SmallRect()
	|                {
	|                    Top = 0,
	|                    Left = 0,
	|                    Bottom = (short)Rows,
	|                    Right = (short)Cols
	|                };
	|
	|                UpdateOffScreen();
	|
	|            }
	|            catch (Win32Exception e)
	|            {
	|                throw new InvalidOperationException(""The Windows Console output window is not available."", e);
	|            }
	|        }
	|
	|        public override void ResizeScreen()
	|        {
	|            OutputBuffer = new WindowsConsole.CharInfo[Rows * Cols];
	|            Clip = new Rect(0, 0, Cols, Rows);
	|            damageRegion = new WindowsConsole.SmallRect()
	|            {
	|                Top = 0,
	|                Left = 0,
	|                Bottom = (short)Rows,
	|                Right = (short)Cols
	|            };
	|            WinConsole.ForceRefreshCursorVisibility();
	|        }
	|
	|        public override void UpdateOffScreen()
	|        {
	|            contents = new int[rows, cols, 3];
	|            for (int row = 0; row < rows; row++)
	|            {
	|                for (int col = 0; col < cols; col++)
	|                {
	|                    int position = row * cols + col;
	|                    OutputBuffer[position].Attributes = (ushort)Colors.TopLevel.Normal;
	|                    OutputBuffer[position].Char.UnicodeChar = ' ';
	|                    contents[row, col, 0] = OutputBuffer[position].Char.UnicodeChar;
	|                    contents[row, col, 1] = OutputBuffer[position].Attributes;
	|                    contents[row, col, 2] = 0;
	|                }
	|            }
	|        }
	|
	|        int ccol, crow;
	|        public override void Move(int col, int row)
	|        {
	|            ccol = col;
	|            crow = row;
	|        }
	|
	|        int GetOutputBufferPosition()
	|        {
	|            return crow * Cols + ccol;
	|        }
	|
	|        public override void AddRune(Rune rune)
	|        {
	|            rune = MakePrintable(rune);
	|            var runeWidth = Rune.ColumnWidth(rune);
	|            var position = GetOutputBufferPosition();
	|            var validClip = IsValidContent(ccol, crow, Clip);
	|
	|            if (validClip)
	|            {
	|                if (runeWidth == 0 && ccol > 0)
	|                {
	|                    var r = contents[crow, ccol - 1, 0];
	|                    var s = new string(new char[] { (char)r, (char)rune });
	|                    string sn;
	|                    if (!s.IsNormalized())
	|                    {
	|                        sn = s.Normalize();
	|                    }
	|                    else
	|                    {
	|                        sn = s;
	|                    }
	|                    var c = sn[0];
	|                    var prevPosition = crow * Cols + (ccol - 1);
	|                    OutputBuffer[prevPosition].Char.UnicodeChar = c;
	|                    contents[crow, ccol - 1, 0] = c;
	|                    OutputBuffer[prevPosition].Attributes = (ushort)CurrentAttribute;
	|                    contents[crow, ccol - 1, 1] = CurrentAttribute;
	|                    contents[crow, ccol - 1, 2] = 1;
	|                    WindowsConsole.SmallRect.Update(ref damageRegion, (short)(ccol - 1), (short)crow);
	|                }
	|                else
	|                {
	|                    if (runeWidth < 2 && ccol > 0
	|                        && Rune.ColumnWidth((char)contents[crow, ccol - 1, 0]) > 1)
	|                    {
	|
	|                        var prevPosition = crow * Cols + (ccol - 1);
	|                        OutputBuffer[prevPosition].Char.UnicodeChar = ' ';
	|                        contents[crow, ccol - 1, 0] = (int)(uint)' ';
	|
	|                    }
	|                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
	|                      && Rune.ColumnWidth((char)contents[crow, ccol, 0]) > 1)
	|                    {
	|
	|                        var prevPosition = GetOutputBufferPosition() + 1;
	|                        OutputBuffer[prevPosition].Char.UnicodeChar = (char)' ';
	|                        contents[crow, ccol + 1, 0] = (int)(uint)' ';
	|
	|                    }
	|                    if (runeWidth > 1 && ccol == Clip.Right - 1)
	|                    {
	|                        OutputBuffer[position].Char.UnicodeChar = (char)' ';
	|                        contents[crow, ccol, 0] = (int)(uint)' ';
	|                    }
	|                    else
	|                    {
	|                        OutputBuffer[position].Char.UnicodeChar = (char)rune;
	|                        contents[crow, ccol, 0] = (int)(uint)rune;
	|                    }
	|                    OutputBuffer[position].Attributes = (ushort)CurrentAttribute;
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 1;
	|                    WindowsConsole.SmallRect.Update(ref damageRegion, (short)ccol, (short)crow);
	|                }
	|            }
	|
	|            if (runeWidth < 0 || runeWidth > 0)
	|            {
	|                ccol++;
	|            }
	|
	|            if (runeWidth > 1)
	|            {
	|                if (validClip && ccol < Clip.Right)
	|                {
	|                    position = GetOutputBufferPosition();
	|                    OutputBuffer[position].Attributes = (ushort)CurrentAttribute;
	|                    OutputBuffer[position].Char.UnicodeChar = (char)0x00;
	|                    contents[crow, ccol, 0] = (int)(uint)0x00;
	|                    contents[crow, ccol, 1] = CurrentAttribute;
	|                    contents[crow, ccol, 2] = 0;
	|                }
	|                ccol++;
	|            }
	|
	|            if (sync)
	|            {
	|                UpdateScreen();
	|            }
	|        }
	|
	|        public override void AddStr(ustring str)
	|        {
	|            foreach (var rune in str)
	|                AddRune(rune);
	|        }
	|
	|        public override void SetAttribute(Attribute c)
	|        {
	|            base.SetAttribute(c);
	|        }
	|
	|        public override Attribute MakeColor(Color foreground, Color background)
	|        {
	|            return MakeColor((ConsoleColor)foreground, (ConsoleColor)background);
	|        }
	|
	|        Attribute MakeColor(ConsoleColor f, ConsoleColor b)
	|        {
	|            // Encode the colors into the int value.
	|            return new Attribute(
	|                value: ((int)f | (int)b << 4),
	|                foreground: (Color)f,
	|                background: (Color)b
	|            );
	|        }
	|
	|        public override Attribute MakeAttribute(Color fore, Color back)
	|        {
	|            return MakeColor((ConsoleColor)fore, (ConsoleColor)back);
	|        }
	|
	|        public override void Refresh()
	|        {
	|            UpdateScreen();
	|
	|            WinConsole.SetInitialCursorVisibility();
	|
	|            UpdateCursor();
	|#if false
	|			var bufferCoords = new WindowsConsole.Coord (){
	|				X = (short)Clip.Width,
	|				Y = (short)Clip.Height
	|			};
	|
	|			var window = new WindowsConsole.SmallRect (){
	|				Top = 0,
	|				Left = 0,
	|				Right = (short)Clip.Right,
	|				Bottom = (short)Clip.Bottom
	|			};
	|
	|			UpdateCursor();
	|			WinConsole.WriteToConsole (OutputBuffer, bufferCoords, window);
	|#endif
	|        }
	|
	|        public override void UpdateScreen()
	|        {
	|            if (damageRegion.Left == -1)
	|                return;
	|
	|            var windowSize = WinConsole.GetConsoleBufferWindow(out _);
	|            if (!windowSize.IsEmpty && (windowSize.Width != Cols || windowSize.Height != Rows))
	|                return;
	|
	|            var bufferCoords = new WindowsConsole.Coord()
	|            {
	|                X = (short)Clip.Width,
	|                Y = (short)Clip.Height
	|            };
	|
	|            WinConsole.WriteToConsole(new Size(Cols, Rows), OutputBuffer, bufferCoords, damageRegion);
	|
	|            // System.Diagnostics.Debugger.Log (0, ""debug"", $""Region={damageRegion.Right - damageRegion.Left},{damageRegion.Bottom - damageRegion.Top}\n"");
	|            WindowsConsole.SmallRect.MakeEmpty(ref damageRegion);
	|        }
	|
	|        CursorVisibility savedCursorVisibility;
	|
	|        public override void UpdateCursor()
	|        {
	|            if (ccol < 0 || crow < 0 || ccol > Cols || crow > Rows)
	|            {
	|                GetCursorVisibility(out CursorVisibility cursorVisibility);
	|                savedCursorVisibility = cursorVisibility;
	|                SetCursorVisibility(CursorVisibility.Invisible);
	|                return;
	|            }
	|
	|            SetCursorVisibility(savedCursorVisibility);
	|            var position = new WindowsConsole.Coord()
	|            {
	|                X = (short)ccol,
	|                Y = (short)crow
	|            };
	|            WinConsole.SetCursorPosition(position);
	|        }
	|
	|        public override void End()
	|        {
	|            WinConsole.Cleanup();
	|            WinConsole = null;
	|
	|            // Disable alternative screen buffer.
	|            if (isWindowsTerminal)
	|            {
	|                Console.Out.Write(""\x1b[?1049l"");
	|            }
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool GetCursorVisibility(out CursorVisibility visibility)
	|        {
	|            return WinConsole.GetCursorVisibility(out visibility);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool SetCursorVisibility(CursorVisibility visibility)
	|        {
	|            savedCursorVisibility = visibility;
	|            return WinConsole.SetCursorVisibility(visibility);
	|        }
	|
	|        /// <inheritdoc/>
	|        public override bool EnsureCursorVisibility()
	|        {
	|            return WinConsole.EnsureCursorVisibility();
	|        }
	|
	|        public override void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
	|        {
	|            WindowsConsole.InputRecord input = new WindowsConsole.InputRecord
	|            {
	|                EventType = WindowsConsole.EventType.Key
	|            };
	|
	|            WindowsConsole.KeyEventRecord keyEvent = new WindowsConsole.KeyEventRecord
	|            {
	|                bKeyDown = true
	|            };
	|            WindowsConsole.ControlKeyState controlKey = new WindowsConsole.ControlKeyState();
	|            if (shift)
	|            {
	|                controlKey |= WindowsConsole.ControlKeyState.ShiftPressed;
	|                keyEvent.UnicodeChar = '\0';
	|                keyEvent.wVirtualKeyCode = 16;
	|            }
	|            if (alt)
	|            {
	|                controlKey |= WindowsConsole.ControlKeyState.LeftAltPressed;
	|                controlKey |= WindowsConsole.ControlKeyState.RightAltPressed;
	|                keyEvent.UnicodeChar = '\0';
	|                keyEvent.wVirtualKeyCode = 18;
	|            }
	|            if (control)
	|            {
	|                controlKey |= WindowsConsole.ControlKeyState.LeftControlPressed;
	|                controlKey |= WindowsConsole.ControlKeyState.RightControlPressed;
	|                keyEvent.UnicodeChar = '\0';
	|                keyEvent.wVirtualKeyCode = 17;
	|            }
	|            keyEvent.dwControlKeyState = controlKey;
	|
	|            input.KeyEvent = keyEvent;
	|
	|            if (shift || alt || control)
	|            {
	|                ProcessInput(input);
	|            }
	|
	|            keyEvent.UnicodeChar = keyChar;
	|            if ((uint)key < 255)
	|            {
	|                keyEvent.wVirtualKeyCode = (ushort)key;
	|            }
	|            else
	|            {
	|                keyEvent.wVirtualKeyCode = '\0';
	|            }
	|
	|            input.KeyEvent = keyEvent;
	|
	|            try
	|            {
	|                ProcessInput(input);
	|            }
	|            catch (OverflowException) { }
	|            finally
	|            {
	|                keyEvent.bKeyDown = false;
	|                input.KeyEvent = keyEvent;
	|                ProcessInput(input);
	|            }
	|        }
	|
	|        public override bool GetColors(int value, out Color foreground, out Color background)
	|        {
	|            bool hasColor = false;
	|            foreground = default;
	|            background = default;
	|            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
	|                .OfType<ConsoleColor>()
	|                .Select(s => (int)s);
	|            if (values.Contains((value >> 4) & 0xffff))
	|            {
	|                hasColor = true;
	|                background = (Color)(ConsoleColor)((value >> 4) & 0xffff);
	|            }
	|            if (values.Contains(value - ((int)background << 4)))
	|            {
	|                hasColor = true;
	|                foreground = (Color)(ConsoleColor)(value - ((int)background << 4));
	|            }
	|            return hasColor;
	|        }
	|
	|        #region Unused
	|        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
	|        {
	|        }
	|
	|        public override void SetColors(short foregroundColorId, short backgroundColorId)
	|        {
	|        }
	|
	|        public override void Suspend()
	|        {
	|        }
	|
	|        public override void StartReportingMouseMoves()
	|        {
	|        }
	|
	|        public override void StopReportingMouseMoves()
	|        {
	|        }
	|
	|        public override void UncookMouse()
	|        {
	|        }
	|
	|        public override void CookMouse()
	|        {
	|        }
	|        #endregion
	|    }
	|
	|    /// <summary>
	|    /// Mainloop intended to be used with the <see cref=""WindowsDriver""/>, and can
	|    /// only be used on Windows.
	|    /// </summary>
	|    /// <remarks>
	|    /// This implementation is used for WindowsDriver.
	|    /// </remarks>
	|    internal class WindowsMainLoop : IMainLoopDriver
	|    {
	|        ManualResetEventSlim eventReady = new ManualResetEventSlim(false);
	|        ManualResetEventSlim waitForProbe = new ManualResetEventSlim(false);
	|        ManualResetEventSlim winChange = new ManualResetEventSlim(false);
	|        MainLoop mainLoop;
	|        ConsoleDriver consoleDriver;
	|        WindowsConsole winConsole;
	|        bool winChanged;
	|        Size windowSize;
	|        CancellationTokenSource tokenSource = new CancellationTokenSource();
	|
	|        // The records that we keep fetching
	|        Queue<WindowsConsole.InputRecord[]> resultQueue = new Queue<WindowsConsole.InputRecord[]>();
	|
	|        /// <summary>
	|        /// Invoked when a Key is pressed or released.
	|        /// </summary>
	|        public Action<WindowsConsole.InputRecord> ProcessInput;
	|
	|        /// <summary>
	|        /// Invoked when the window is changed.
	|        /// </summary>
	|        public Action<Size> WinChanged;
	|
	|        public WindowsMainLoop(ConsoleDriver consoleDriver = null)
	|        {
	|            this.consoleDriver = consoleDriver ?? throw new ArgumentNullException(""Console driver instance must be provided."");
	|            winConsole = ((WindowsDriver)consoleDriver).WinConsole;
	|        }
	|
	|        void IMainLoopDriver.Setup(MainLoop mainLoop)
	|        {
	|            this.mainLoop = mainLoop;
	|            Task.Run(WindowsInputHandler);
	|            Task.Run(CheckWinChange);
	|        }
	|
	|        void WindowsInputHandler()
	|        {
	|            while (true)
	|            {
	|                waitForProbe.Wait();
	|                waitForProbe.Reset();
	|
	|                if (resultQueue?.Count == 0)
	|                {
	|                    resultQueue.Enqueue(winConsole.ReadConsoleInput());
	|                }
	|
	|                eventReady.Set();
	|            }
	|        }
	|
	|        void CheckWinChange()
	|        {
	|            while (true)
	|            {
	|                winChange.Wait();
	|                winChange.Reset();
	|                WaitWinChange();
	|                winChanged = true;
	|                eventReady.Set();
	|            }
	|        }
	|
	|        void WaitWinChange()
	|        {
	|            while (true)
	|            {
	|                // Wait for a while then check if screen has changed sizes
	|                Task.Delay(500).Wait();
	|                windowSize = winConsole.GetConsoleBufferWindow(out _);
	|                if (windowSize != Size.Empty && windowSize.Width != consoleDriver.Cols
	|                    || windowSize.Height != consoleDriver.Rows)
	|                {
	|                    return;
	|                }
	|            }
	|        }
	|
	|        void IMainLoopDriver.Wakeup()
	|        {
	|            //tokenSource.Cancel ();
	|            eventReady.Set();
	|        }
	|
	|        bool IMainLoopDriver.EventsPending(bool wait)
	|        {
	|            waitForProbe.Set();
	|            winChange.Set();
	|
	|            if (CheckTimers(wait, out var waitTimeout))
	|            {
	|                return true;
	|            }
	|
	|            try
	|            {
	|                if (!tokenSource.IsCancellationRequested)
	|                {
	|                    eventReady.Wait(waitTimeout, tokenSource.Token);
	|                }
	|            }
	|            catch (OperationCanceledException)
	|            {
	|                return true;
	|            }
	|            finally
	|            {
	|                eventReady.Reset();
	|            }
	|
	|            if (!tokenSource.IsCancellationRequested)
	|            {
	|                return resultQueue.Count > 0 || CheckTimers(wait, out _) || winChanged;
	|            }
	|
	|            tokenSource.Dispose();
	|            tokenSource = new CancellationTokenSource();
	|            return true;
	|        }
	|
	|        bool CheckTimers(bool wait, out int waitTimeout)
	|        {
	|            long now = DateTime.UtcNow.Ticks;
	|
	|            if (mainLoop.timeouts.Count > 0)
	|            {
	|                waitTimeout = (int)((mainLoop.timeouts.Keys[0] - now) / TimeSpan.TicksPerMillisecond);
	|                if (waitTimeout < 0)
	|                    return true;
	|            }
	|            else
	|            {
	|                waitTimeout = -1;
	|            }
	|
	|            if (!wait)
	|                waitTimeout = 0;
	|
	|            int ic;
	|            lock (mainLoop.idleHandlers)
	|            {
	|                ic = mainLoop.idleHandlers.Count;
	|            }
	|
	|            return ic > 0;
	|        }
	|
	|        void IMainLoopDriver.MainIteration()
	|        {
	|            while (resultQueue.Count > 0)
	|            {
	|                var inputRecords = resultQueue.Dequeue();
	|                if (inputRecords != null && inputRecords.Length > 0)
	|                {
	|                    var inputEvent = inputRecords[0];
	|                    ProcessInput?.Invoke(inputEvent);
	|                }
	|            }
	|            if (winChanged)
	|            {
	|                winChanged = false;
	|                WinChanged?.Invoke(windowSize);
	|            }
	|        }
	|    }
	|
	|    class WindowsClipboard : ClipboardBase
	|    {
	|        public WindowsClipboard()
	|        {
	|            IsSupported = CheckClipboardIsAvailable();
	|        }
	|
	|        private static bool CheckClipboardIsAvailable()
	|        {
	|            // Attempt to open the clipboard
	|            if (OpenClipboard(IntPtr.Zero))
	|            {
	|                // Clipboard is available
	|                // Close the clipboard after use
	|                CloseClipboard();
	|
	|                return true;
	|            }
	|            // Clipboard is not available
	|            return false;
	|        }
	|
	|        public override bool IsSupported { get; }
	|
	|        protected override string GetClipboardDataImpl()
	|        {
	|            //if (!IsClipboardFormatAvailable (cfUnicodeText))
	|            //	return null;
	|
	|            try
	|            {
	|                if (!OpenClipboard(IntPtr.Zero))
	|                    return null;
	|
	|                IntPtr handle = GetClipboardData(cfUnicodeText);
	|                if (handle == IntPtr.Zero)
	|                    return null;
	|
	|                IntPtr pointer = IntPtr.Zero;
	|
	|                try
	|                {
	|                    pointer = GlobalLock(handle);
	|                    if (pointer == IntPtr.Zero)
	|                        return null;
	|
	|                    int size = GlobalSize(handle);
	|                    byte[] buff = new byte[size];
	|
	|                    Marshal.Copy(pointer, buff, 0, size);
	|
	|                    return System.Text.Encoding.Unicode.GetString(buff)
	|                        .TrimEnd('\0');
	|                }
	|                finally
	|                {
	|                    if (pointer != IntPtr.Zero)
	|                        GlobalUnlock(handle);
	|                }
	|            }
	|            finally
	|            {
	|                CloseClipboard();
	|            }
	|        }
	|
	|        protected override void SetClipboardDataImpl(string text)
	|        {
	|            OpenClipboard();
	|
	|            EmptyClipboard();
	|            IntPtr hGlobal = default;
	|            try
	|            {
	|                var bytes = (text.Length + 1) * 2;
	|                hGlobal = Marshal.AllocHGlobal(bytes);
	|
	|                if (hGlobal == default)
	|                {
	|                    ThrowWin32();
	|                }
	|
	|                var target = GlobalLock(hGlobal);
	|
	|                if (target == default)
	|                {
	|                    ThrowWin32();
	|                }
	|
	|                try
	|                {
	|                    Marshal.Copy(text.ToCharArray(), 0, target, text.Length);
	|                }
	|                finally
	|                {
	|                    GlobalUnlock(target);
	|                }
	|
	|                if (SetClipboardData(cfUnicodeText, hGlobal) == default)
	|                {
	|                    ThrowWin32();
	|                }
	|
	|                hGlobal = default;
	|            }
	|            finally
	|            {
	|                if (hGlobal != default)
	|                {
	|                    Marshal.FreeHGlobal(hGlobal);
	|                }
	|
	|                CloseClipboard();
	|            }
	|        }
	|
	|        void OpenClipboard()
	|        {
	|            var num = 10;
	|            while (true)
	|            {
	|                if (OpenClipboard(default))
	|                {
	|                    break;
	|                }
	|
	|                if (--num == 0)
	|                {
	|                    ThrowWin32();
	|                }
	|
	|                Thread.Sleep(100);
	|            }
	|        }
	|
	|        const uint cfUnicodeText = 13;
	|
	|        void ThrowWin32()
	|        {
	|            throw new Win32Exception(Marshal.GetLastWin32Error());
	|        }
	|
	|        [DllImport(""User32.dll"", SetLastError = true)]
	|        [return: MarshalAs(UnmanagedType.Bool)]
	|        static extern bool IsClipboardFormatAvailable(uint format);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern int GlobalSize(IntPtr handle);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        static extern IntPtr GlobalLock(IntPtr hMem);
	|
	|        [DllImport(""kernel32.dll"", SetLastError = true)]
	|        [return: MarshalAs(UnmanagedType.Bool)]
	|        static extern bool GlobalUnlock(IntPtr hMem);
	|
	|        [DllImport(""user32.dll"", SetLastError = true)]
	|        [return: MarshalAs(UnmanagedType.Bool)]
	|        static extern bool OpenClipboard(IntPtr hWndNewOwner);
	|
	|        [DllImport(""user32.dll"", SetLastError = true)]
	|        [return: MarshalAs(UnmanagedType.Bool)]
	|        static extern bool CloseClipboard();
	|
	|        [DllImport(""user32.dll"", SetLastError = true)]
	|        static extern IntPtr SetClipboardData(uint uFormat, IntPtr data);
	|
	|        [DllImport(""user32.dll"")]
	|        static extern bool EmptyClipboard();
	|
	|        [DllImport(""user32.dll"", SetLastError = true)]
	|        static extern IntPtr GetClipboardData(uint uFormat);
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Provides navigation and a user interface (UI) to collect related data across multiple steps. Each step (<see cref=""WizardStep""/>) can host 
	|    /// arbitrary <see cref=""View""/>s, much like a <see cref=""Dialog""/>. Each step also has a pane for help text. Along the
	|    /// bottom of the Wizard view are customizable buttons enabling the user to navigate forward and backward through the Wizard. 
	|    /// </summary>
	|    /// <remarks>
	|    /// The Wizard can be displayed either as a modal (pop-up) <see cref=""Window""/> (like <see cref=""Dialog""/>) or as an embedded <see cref=""View""/>. 
	|    /// 
	|    /// By default, <see cref=""Wizard.Modal""/> is <c>true</c>. In this case launch the Wizard with <c>Application.Run(wizard)</c>. 
	|    /// 
	|    /// See <see cref=""Wizard.Modal""/> for more details.
	|    /// </remarks>
	|    /// <example>
	|    /// <code>
	|    /// using Terminal.Gui;
	|    /// using NStack;
	|    /// 
	|    /// Application.Init();
	|    /// 
	|    /// var wizard = new Wizard ($""Setup Wizard"");
	|    /// 
	|    /// // Add 1st step
	|    /// var firstStep = new Wizard.WizardStep (""End User License Agreement"");
	|    /// wizard.AddStep(firstStep);
	|    /// firstStep.NextButtonText = ""Accept!"";
	|    /// firstStep.HelpText = ""This is the End User License Agreement."";
	|    /// 
	|    /// // Add 2nd step
	|    /// var secondStep = new Wizard.WizardStep (""Second Step"");
	|    /// wizard.AddStep(secondStep);
	|    /// secondStep.HelpText = ""This is the help text for the Second Step."";
	|    /// var lbl = new Label (""Name:"") { AutoSize = true };
	|    /// secondStep.Add(lbl);
	|    /// 
	|    /// var name = new TextField () { X = Pos.Right (lbl) + 1, Width = Dim.Fill () - 1 };
	|    /// secondStep.Add(name);
	|    /// 
	|    /// wizard.Finished += (args) =>
	|    /// {
	|    ///     MessageBox.Query(""Wizard"", $""Finished. The Name entered is '{name.Text}'"", ""Ok"");
	|    ///     Application.RequestStop();
	|    /// };
	|    /// 
	|    /// Application.Top.Add (wizard);
	|    /// Application.Run ();
	|    /// Application.Shutdown ();
	|    /// </code>
	|    /// </example>
	|    public class Wizard : Dialog
	|    {
	|        /// <summary>
	|        /// Represents a basic step that is displayed in a <see cref=""Wizard""/>. The <see cref=""WizardStep""/> view is divided horizontally in two. On the left is the
	|        /// content view where <see cref=""View""/>s can be added,  On the right is the help for the step.
	|        /// Set <see cref=""WizardStep.HelpText""/> to set the help text. If the help text is empty the help pane will not
	|        /// be shown. 
	|        /// 
	|        /// If there are no Views added to the WizardStep the <see cref=""HelpText""/> (if not empty) will fill the wizard step. 
	|        /// </summary>
	|        /// <remarks>
	|        /// If <see cref=""Button""/>s are added, do not set <see cref=""Button.IsDefault""/> to true as this will conflict
	|        /// with the Next button of the Wizard.
	|        /// 
	|        /// Subscribe to the <see cref=""View.VisibleChanged""/> event to be notified when the step is active; see also: <see cref=""Wizard.StepChanged""/>.
	|        /// 
	|        /// To enable or disable a step from being shown to the user, set <see cref=""View.Enabled""/>.
	|        /// 
	|        /// </remarks>
	|        public class WizardStep : FrameView
	|        {
	|            /// <summary>
	|            /// The title of the <see cref=""WizardStep""/>. 
	|            /// </summary>
	|            /// <remarks>The Title is only displayed when the <see cref=""Wizard""/> is used as a modal pop-up (see <see cref=""Wizard.Modal""/>.</remarks>
	|            public new ustring Title
	|            {
	|                get => title;
	|                set
	|                {
	|                    if (!OnTitleChanging(title, value))
	|                    {
	|                        var old = title;
	|                        title = value;
	|                        OnTitleChanged(old, title);
	|                    }
	|                    base.Title = value;
	|                    SetNeedsDisplay();
	|                }
	|            }
	|
	|            private ustring title = ustring.Empty;
	|
	|            /// <summary>
	|            /// An <see cref=""EventArgs""/> which allows passing a cancelable new <see cref=""Title""/> value event.
	|            /// </summary>
	|            public class TitleEventArgs : EventArgs
	|            {
	|                /// <summary>
	|                /// The new Window Title.
	|                /// </summary>
	|                public ustring NewTitle { get; set; }
	|
	|                /// <summary>
	|                /// The old Window Title.
	|                /// </summary>
	|                public ustring OldTitle { get; set; }
	|
	|                /// <summary>
	|                /// Flag which allows cancelling the Title change.
	|                /// </summary>
	|                public bool Cancel { get; set; }
	|
	|                /// <summary>
	|                /// Initializes a new instance of <see cref=""TitleEventArgs""/>
	|                /// </summary>
	|                /// <param name=""oldTitle"">The <see cref=""Title""/> that is/has been replaced.</param>
	|                /// <param name=""newTitle"">The new <see cref=""Title""/> to be replaced.</param>
	|                public TitleEventArgs(ustring oldTitle, ustring newTitle)
	|                {
	|                    OldTitle = oldTitle;
	|                    NewTitle = newTitle;
	|                }
	|            }
	|
	|            /// <summary>
	|            /// Called before the <see cref=""Title""/> changes. Invokes the <see cref=""TitleChanging""/> event, which can be cancelled.
	|            /// </summary>
	|            /// <param name=""oldTitle"">The <see cref=""Title""/> that is/has been replaced.</param>
	|            /// <param name=""newTitle"">The new <see cref=""Title""/> to be replaced.</param>
	|            /// <returns><c>true</c> if an event handler cancelled the Title change.</returns>
	|            public virtual bool OnTitleChanging(ustring oldTitle, ustring newTitle)
	|            {
	|                var args = new TitleEventArgs(oldTitle, newTitle);
	|                TitleChanging?.Invoke(args);
	|                return args.Cancel;
	|            }
	|
	|            /// <summary>
	|            /// Event fired when the <see cref=""Title""/> is changing. Set <see cref=""TitleEventArgs.Cancel""/> to 
	|            /// <c>true</c> to cancel the Title change.
	|            /// </summary>
	|            public event Action<TitleEventArgs> TitleChanging;
	|
	|            /// <summary>
	|            /// Called when the <see cref=""Title""/> has been changed. Invokes the <see cref=""TitleChanged""/> event.
	|            /// </summary>
	|            /// <param name=""oldTitle"">The <see cref=""Title""/> that is/has been replaced.</param>
	|            /// <param name=""newTitle"">The new <see cref=""Title""/> to be replaced.</param>
	|            public virtual void OnTitleChanged(ustring oldTitle, ustring newTitle)
	|            {
	|                var args = new TitleEventArgs(oldTitle, newTitle);
	|                TitleChanged?.Invoke(args);
	|            }
	|
	|            /// <summary>
	|            /// Event fired after the <see cref=""Title""/> has been changed. 
	|            /// </summary>
	|            public event Action<TitleEventArgs> TitleChanged;
	|
	|            /// <summary>
	|            /// WizardContentView is an internal implementation detail of Window. It is used to host Views added with <see cref=""Add(View)""/>. 
	|            /// Its ONLY reason for being is to provide a simple way for Window to expose to those SubViews that the Window's Bounds 
	|            /// are actually deflated due to the border. 
	|            /// </summary>
	|            class WizardContentView : View { }
	|
	|            private WizardContentView contentView = new WizardContentView();
	|
	|            /// <summary>
	|            /// Sets or gets help text for the <see cref=""WizardStep""/>.If <see cref=""WizardStep.HelpText""/> is empty
	|            /// the help pane will not be visible and the content will fill the entire WizardStep.
	|            /// </summary>
	|            /// <remarks>The help text is displayed using a read-only <see cref=""TextView""/>.</remarks>
	|            public ustring HelpText
	|            {
	|                get => helpTextView.Text;
	|                set
	|                {
	|                    helpTextView.Text = value;
	|                    ShowHide();
	|                    SetNeedsDisplay();
	|                }
	|            }
	|            private TextView helpTextView = new TextView();
	|
	|            /// <summary>
	|            /// Sets or gets the text for the back button. The back button will only be visible on 
	|            /// steps after the first step.
	|            /// </summary>
	|            /// <remarks>The default text is ""Back""</remarks>
	|            public ustring BackButtonText { get; set; } = ustring.Empty;
	|
	|            /// <summary>
	|            /// Sets or gets the text for the next/finish button.
	|            /// </summary>
	|            /// <remarks>The default text is ""Next..."" if the Pane is not the last pane. Otherwise it is ""Finish""</remarks>
	|            public ustring NextButtonText { get; set; } = ustring.Empty;
	|
	|            /// <summary>
	|            /// Initializes a new instance of the <see cref=""Wizard""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|            /// </summary>
	|            /// <param name=""title"">Title for the Step. Will be appended to the containing Wizard's title as 
	|            /// ""Wizard Title - Wizard Step Title"" when this step is active.</param>
	|            /// <remarks>
	|            /// </remarks>
	|            public WizardStep(ustring title)
	|            {
	|                this.Title = title; // this.Title holds just the ""Wizard Title""; base.Title holds ""Wizard Title - Step Title""
	|                this.Border.BorderStyle = BorderStyle.Rounded;
	|
	|                base.Add(contentView);
	|
	|                helpTextView.ReadOnly = true;
	|                helpTextView.WordWrap = true;
	|                base.Add(helpTextView);
	|
	|                ShowHide();
	|
	|                var scrollBar = new ScrollBarView(helpTextView, true);
	|
	|                scrollBar.ChangedPosition += () =>
	|                {
	|                    helpTextView.TopRow = scrollBar.Position;
	|                    if (helpTextView.TopRow != scrollBar.Position)
	|                    {
	|                        scrollBar.Position = helpTextView.TopRow;
	|                    }
	|                    helpTextView.SetNeedsDisplay();
	|                };
	|
	|                scrollBar.OtherScrollBarView.ChangedPosition += () =>
	|                {
	|                    helpTextView.LeftColumn = scrollBar.OtherScrollBarView.Position;
	|                    if (helpTextView.LeftColumn != scrollBar.OtherScrollBarView.Position)
	|                    {
	|                        scrollBar.OtherScrollBarView.Position = helpTextView.LeftColumn;
	|                    }
	|                    helpTextView.SetNeedsDisplay();
	|                };
	|
	|                scrollBar.VisibleChanged += () =>
	|                {
	|                    if (scrollBar.Visible && helpTextView.RightOffset == 0)
	|                    {
	|                        helpTextView.RightOffset = 1;
	|                    }
	|                    else if (!scrollBar.Visible && helpTextView.RightOffset == 1)
	|                    {
	|                        helpTextView.RightOffset = 0;
	|                    }
	|                };
	|
	|                scrollBar.OtherScrollBarView.VisibleChanged += () =>
	|                {
	|                    if (scrollBar.OtherScrollBarView.Visible && helpTextView.BottomOffset == 0)
	|                    {
	|                        helpTextView.BottomOffset = 1;
	|                    }
	|                    else if (!scrollBar.OtherScrollBarView.Visible && helpTextView.BottomOffset == 1)
	|                    {
	|                        helpTextView.BottomOffset = 0;
	|                    }
	|                };
	|
	|                helpTextView.DrawContent += (e) =>
	|                {
	|                    scrollBar.Size = helpTextView.Lines;
	|                    scrollBar.Position = helpTextView.TopRow;
	|                    if (scrollBar.OtherScrollBarView != null)
	|                    {
	|                        scrollBar.OtherScrollBarView.Size = helpTextView.Maxlength;
	|                        scrollBar.OtherScrollBarView.Position = helpTextView.LeftColumn;
	|                    }
	|                    scrollBar.LayoutSubviews();
	|                    scrollBar.Refresh();
	|                };
	|                base.Add(scrollBar);
	|            }
	|
	|            /// <summary>
	|            /// Does the work to show and hide the contentView and helpView as appropriate
	|            /// </summary>
	|            internal void ShowHide()
	|            {
	|                contentView.Height = Dim.Fill();
	|                helpTextView.Height = Dim.Fill();
	|                helpTextView.Width = Dim.Fill();
	|
	|                if (contentView.InternalSubviews?.Count > 0)
	|                {
	|                    if (helpTextView.Text.Length > 0)
	|                    {
	|                        contentView.Width = Dim.Percent(70);
	|                        helpTextView.X = Pos.Right(contentView);
	|                        helpTextView.Width = Dim.Fill();
	|
	|                    }
	|                    else
	|                    {
	|                        contentView.Width = Dim.Percent(100);
	|                    }
	|                }
	|                else
	|                {
	|                    if (helpTextView.Text.Length > 0)
	|                    {
	|                        helpTextView.X = 0;
	|                    }
	|                    else
	|                    {
	|                        // Error - no pane shown
	|                    }
	|
	|                }
	|                contentView.Visible = contentView.InternalSubviews?.Count > 0;
	|                helpTextView.Visible = helpTextView.Text.Length > 0;
	|            }
	|
	|            /// <summary>
	|            /// Add the specified <see cref=""View""/> to the <see cref=""WizardStep""/>. 
	|            /// </summary>
	|            /// <param name=""view""><see cref=""View""/> to add to this container</param>
	|            public override void Add(View view)
	|            {
	|                contentView.Add(view);
	|                if (view.CanFocus)
	|                    CanFocus = true;
	|                ShowHide();
	|            }
	|
	|            /// <summary>
	|            ///   Removes a <see cref=""View""/> from <see cref=""WizardStep""/>.
	|            /// </summary>
	|            /// <remarks>
	|            /// </remarks>
	|            public override void Remove(View view)
	|            {
	|                if (view == null)
	|                    return;
	|
	|                SetNeedsDisplay();
	|                var touched = view.Frame;
	|                if (view == contentView || view.GetType().Name == ""ContentView"")
	|                {
	|                    base.Remove(view);
	|                }
	|                else
	|                {
	|                    contentView.Remove(view);
	|                }
	|
	|                if (contentView.InternalSubviews.Count < 1)
	|                    this.CanFocus = false;
	|                ShowHide();
	|            }
	|
	|            /// <summary>
	|            ///   Removes all <see cref=""View""/>s from the <see cref=""WizardStep""/>.
	|            /// </summary>
	|            /// <remarks>
	|            /// </remarks>
	|            public override void RemoveAll()
	|            {
	|                contentView.RemoveAll();
	|                ShowHide();
	|            }
	|
	|        } // end of WizardStep class
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Wizard""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        /// <remarks>
	|        /// The Wizard will be vertically and horizontally centered in the container.
	|        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> change size and position.
	|        /// </remarks>
	|        public Wizard() : this(ustring.Empty)
	|        {
	|        }
	|
	|        /// <summary>
	|        /// Initializes a new instance of the <see cref=""Wizard""/> class using <see cref=""LayoutStyle.Computed""/> positioning.
	|        /// </summary>
	|        /// <param name=""title"">Sets the <see cref=""Title""/> for the Wizard.</param>
	|        /// <remarks>
	|        /// The Wizard will be vertically and horizontally centered in the container.
	|        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> change size and position.
	|        /// </remarks>
	|        public Wizard(ustring title) : base(title)
	|        {
	|            wizardTitle = title;
	|            // Using Justify causes the Back and Next buttons to be hard justified against
	|            // the left and right edge
	|            ButtonAlignment = ButtonAlignments.Justify;
	|            this.Border.BorderStyle = BorderStyle.Double;
	|            this.Border.Padding = new Thickness(0);
	|
	|            //// Add a horiz separator
	|            //var separator = new LineView (Graphs.Orientation.Horizontal) {
	|            //	Y = Pos.AnchorEnd (2)
	|            //};
	|            //Add (separator);
	|
	|            // BUGBUG: Space is to work around https://github.com/gui-cs/Terminal.Gui/issues/1812
	|            backBtn = new Button(Strings.wzBack) { AutoSize = true };
	|            AddButton(backBtn);
	|
	|            nextfinishBtn = new Button(Strings.wzFinish) { AutoSize = true };
	|            nextfinishBtn.IsDefault = true;
	|            AddButton(nextfinishBtn);
	|
	|            backBtn.Clicked += BackBtn_Clicked;
	|            nextfinishBtn.Clicked += NextfinishBtn_Clicked;
	|
	|            Loaded += Wizard_Loaded;
	|            Closing += Wizard_Closing;
	|
	|            if (Modal)
	|            {
	|                ClearKeybinding(Command.QuitToplevel);
	|                AddKeyBinding(Key.Esc, Command.QuitToplevel);
	|            }
	|
	|            Initialized += (s, e) => Wizard_Loaded();
	|        }
	|
	|        private void Wizard_Loaded()
	|        {
	|            CurrentStep = GetFirstStep(); // gets the first step if CurrentStep == null
	|        }
	|
	|        private bool finishedPressed = false;
	|
	|        private void Wizard_Closing(ToplevelClosingEventArgs obj)
	|        {
	|            if (!finishedPressed)
	|            {
	|                var args = new WizardButtonEventArgs();
	|                Cancelled?.Invoke(args);
	|            }
	|        }
	|
	|        private void NextfinishBtn_Clicked()
	|        {
	|            if (CurrentStep == GetLastStep())
	|            {
	|                var args = new WizardButtonEventArgs();
	|                Finished?.Invoke(args);
	|                if (!args.Cancel)
	|                {
	|                    finishedPressed = true;
	|                    if (IsCurrentTop)
	|                    {
	|                        Application.RequestStop(this);
	|                    }
	|                    else
	|                    {
	|                        // Wizard was created as a non-modal (just added to another View). 
	|                        // Do nothing
	|                    }
	|                }
	|            }
	|            else
	|            {
	|                var args = new WizardButtonEventArgs();
	|                MovingNext?.Invoke(args);
	|                if (!args.Cancel)
	|                {
	|                    GoNext();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// <see cref=""Wizard""/> is derived from <see cref=""Dialog""/> and Dialog causes <c>Esc</c> to call
	|        /// <see cref=""Application.RequestStop(Toplevel)""/>, closing the Dialog. Wizard overrides <see cref=""Responder.ProcessKey(KeyEvent)""/>
	|        /// to instead fire the <see cref=""Cancelled""/> event when Wizard is being used as a non-modal (see <see cref=""Wizard.Modal""/>.
	|        /// See <see cref=""Responder.ProcessKey(KeyEvent)""/> for more.
	|        /// </summary>
	|        /// <param name=""kb""></param>
	|        /// <returns></returns>
	|        public override bool ProcessKey(KeyEvent kb)
	|        {
	|            if (!Modal)
	|            {
	|                switch (kb.Key)
	|                {
	|                    case Key.Esc:
	|                        var args = new WizardButtonEventArgs();
	|                        Cancelled?.Invoke(args);
	|                        return false;
	|                }
	|            }
	|            return base.ProcessKey(kb);
	|        }
	|
	|        /// <summary>
	|        /// Causes the wizad to move to the next enabled step (or last step if <see cref=""CurrentStep""/> is not set). 
	|        /// If there is no previous step, does nothing.
	|        /// </summary>
	|        public void GoNext()
	|        {
	|            var nextStep = GetNextStep();
	|            if (nextStep != null)
	|            {
	|                GoToStep(nextStep);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the next enabled <see cref=""WizardStep""/> after the current step. Takes into account steps which
	|        /// are disabled. If <see cref=""CurrentStep""/> is <c>null</c> returns the first enabled step.
	|        /// </summary>
	|        /// <returns>The next step after the current step, if there is one; otherwise returns <c>null</c>, which 
	|        /// indicates either there are no enabled steps or the current step is the last enabled step.</returns>
	|        public WizardStep GetNextStep()
	|        {
	|            LinkedListNode<WizardStep> step = null;
	|            if (CurrentStep == null)
	|            {
	|                // Get first step, assume it is next
	|                step = steps.First;
	|            }
	|            else
	|            {
	|                // Get the step after current
	|                step = steps.Find(CurrentStep);
	|                if (step != null)
	|                {
	|                    step = step.Next;
	|                }
	|            }
	|
	|            // step now points to the potential next step
	|            while (step != null)
	|            {
	|                if (step.Value.Enabled)
	|                {
	|                    return step.Value;
	|                }
	|                step = step.Next;
	|            }
	|            return null;
	|        }
	|
	|        private void BackBtn_Clicked()
	|        {
	|            var args = new WizardButtonEventArgs();
	|            MovingBack?.Invoke(args);
	|            if (!args.Cancel)
	|            {
	|                GoBack();
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Causes the wizad to move to the previous enabled step (or first step if <see cref=""CurrentStep""/> is not set). 
	|        /// If there is no previous step, does nothing.
	|        /// </summary>
	|        public void GoBack()
	|        {
	|            var previous = GetPreviousStep();
	|            if (previous != null)
	|            {
	|                GoToStep(previous);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns the first enabled <see cref=""WizardStep""/> before the current step. Takes into account steps which
	|        /// are disabled. If <see cref=""CurrentStep""/> is <c>null</c> returns the last enabled step.
	|        /// </summary>
	|        /// <returns>The first step ahead of the current step, if there is one; otherwise returns <c>null</c>, which 
	|        /// indicates either there are no enabled steps or the current step is the first enabled step.</returns>
	|        public WizardStep GetPreviousStep()
	|        {
	|            LinkedListNode<WizardStep> step = null;
	|            if (CurrentStep == null)
	|            {
	|                // Get last step, assume it is previous
	|                step = steps.Last;
	|            }
	|            else
	|            {
	|                // Get the step before current
	|                step = steps.Find(CurrentStep);
	|                if (step != null)
	|                {
	|                    step = step.Previous;
	|                }
	|            }
	|
	|            // step now points to the potential previous step
	|            while (step != null)
	|            {
	|                if (step.Value.Enabled)
	|                {
	|                    return step.Value;
	|                }
	|                step = step.Previous;
	|            }
	|            return null;
	|        }
	|
	|        /// <summary>
	|        /// Returns the first enabled step in the Wizard
	|        /// </summary>
	|        /// <returns>The last enabled step</returns>
	|        public WizardStep GetFirstStep()
	|        {
	|            return steps.FirstOrDefault(s => s.Enabled);
	|        }
	|
	|        /// <summary>
	|        /// Returns the last enabled step in the Wizard
	|        /// </summary>
	|        /// <returns>The last enabled step</returns>
	|        public WizardStep GetLastStep()
	|        {
	|            return steps.LastOrDefault(s => s.Enabled);
	|        }
	|
	|        private LinkedList<WizardStep> steps = new LinkedList<WizardStep>();
	|        private WizardStep currentStep = null;
	|
	|        /// <summary>
	|        /// If the <see cref=""CurrentStep""/> is not the first step in the wizard, this button causes
	|        /// the <see cref=""MovingBack""/> event to be fired and the wizard moves to the previous step. 
	|        /// </summary>
	|        /// <remarks>
	|        /// Use the <see cref=""MovingBack""></see> event to be notified when the user attempts to go back.
	|        /// </remarks>
	|        public Button BackButton { get => backBtn; }
	|        private Button backBtn;
	|
	|        /// <summary>
	|        /// If the <see cref=""CurrentStep""/> is the last step in the wizard, this button causes
	|        /// the <see cref=""Finished""/> event to be fired and the wizard to close. If the step is not the last step,
	|        /// the <see cref=""MovingNext""/> event will be fired and the wizard will move next step. 
	|        /// </summary>
	|        /// <remarks>
	|        /// Use the <see cref=""MovingNext""></see> and <see cref=""Finished""></see> events to be notified 
	|        /// when the user attempts go to the next step or finish the wizard.
	|        /// </remarks>
	|        public Button NextFinishButton { get => nextfinishBtn; }
	|        private Button nextfinishBtn;
	|
	|        /// <summary>
	|        /// Adds a step to the wizard. The Next and Back buttons navigate through the added steps in the
	|        /// order they were added.
	|        /// </summary>
	|        /// <param name=""newStep""></param>
	|        /// <remarks>The ""Next..."" button of the last step added will read ""Finish"" (unless changed from default).</remarks>
	|        public void AddStep(WizardStep newStep)
	|        {
	|            SizeStep(newStep);
	|
	|            newStep.EnabledChanged += UpdateButtonsAndTitle;
	|            newStep.TitleChanged += (args) => UpdateButtonsAndTitle();
	|            steps.AddLast(newStep);
	|            this.Add(newStep);
	|            UpdateButtonsAndTitle();
	|        }
	|
	|        /// <summary>
	|        /// The title of the Wizard, shown at the top of the Wizard with "" - currentStep.Title"" appended.
	|        /// </summary>
	|        /// <remarks>
	|        /// The Title is only displayed when the <see cref=""Wizard""/> <see cref=""Wizard.Modal""/> is set to <c>false</c>.
	|        /// </remarks>
	|        public new ustring Title
	|        {
	|            get
	|            {
	|                // The base (Dialog) Title holds the full title (""Wizard Title - Step Title"")
	|                return base.Title;
	|            }
	|            set
	|            {
	|                wizardTitle = value;
	|                base.Title = $""{wizardTitle}{(steps.Count > 0 && currentStep != null ? "" - "" + currentStep.Title : string.Empty)}"";
	|            }
	|        }
	|        private ustring wizardTitle = ustring.Empty;
	|
	|        /// <summary>	
	|        /// <see cref=""EventArgs""/> for <see cref=""WizardStep""/> transition events.
	|        /// </summary>
	|        public class WizardButtonEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// Set to true to cancel the transition to the next step.
	|            /// </summary>
	|            public bool Cancel { get; set; }
	|
	|            /// <summary>
	|            /// Initializes a new instance of <see cref=""WizardButtonEventArgs""/>
	|            /// </summary>
	|            public WizardButtonEventArgs()
	|            {
	|                Cancel = false;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Raised when the Back button in the <see cref=""Wizard""/> is clicked. The Back button is always
	|        /// the first button in the array of Buttons passed to the <see cref=""Wizard""/> constructor, if any.
	|        /// </summary>
	|        public event Action<WizardButtonEventArgs> MovingBack;
	|
	|        /// <summary>
	|        /// Raised when the Next/Finish button in the <see cref=""Wizard""/> is clicked (or the user presses Enter). 
	|        /// The Next/Finish button is always the last button in the array of Buttons passed to the <see cref=""Wizard""/> constructor, 
	|        /// if any. This event is only raised if the <see cref=""CurrentStep""/> is the last Step in the Wizard flow 
	|        /// (otherwise the <see cref=""Finished""/> event is raised).
	|        /// </summary>
	|        public event Action<WizardButtonEventArgs> MovingNext;
	|
	|        /// <summary>
	|        /// Raised when the Next/Finish button in the <see cref=""Wizard""/> is clicked. The Next/Finish button is always
	|        /// the last button in the array of Buttons passed to the <see cref=""Wizard""/> constructor, if any. This event is only
	|        /// raised if the <see cref=""CurrentStep""/> is the last Step in the Wizard flow 
	|        /// (otherwise the <see cref=""Finished""/> event is raised).
	|        /// </summary>
	|        public event Action<WizardButtonEventArgs> Finished;
	|
	|        /// <summary>
	|        /// Raised when the user has cancelled the <see cref=""Wizard""/> by pressin the Esc key. 
	|        /// To prevent a modal (<see cref=""Wizard.Modal""/> is <c>true</c>) Wizard from
	|        /// closing, cancel the event by setting <see cref=""WizardButtonEventArgs.Cancel""/> to 
	|        /// <c>true</c> before returning from the event handler.
	|        /// </summary>
	|        public event Action<WizardButtonEventArgs> Cancelled;
	|
	|        /// <summary>
	|        /// <see cref=""EventArgs""/> for <see cref=""WizardStep""/> events.
	|        /// </summary>
	|        public class StepChangeEventArgs : EventArgs
	|        {
	|            /// <summary>
	|            /// The current (or previous) <see cref=""WizardStep""/>.
	|            /// </summary>
	|            public WizardStep OldStep { get; }
	|
	|            /// <summary>
	|            /// The <see cref=""WizardStep""/> the <see cref=""Wizard""/> is changing to or has changed to.
	|            /// </summary>
	|            public WizardStep NewStep { get; }
	|
	|            /// <summary>
	|            /// Event handlers can set to true before returning to cancel the step transition.
	|            /// </summary>
	|            public bool Cancel { get; set; }
	|
	|            /// <summary>
	|            /// Initializes a new instance of <see cref=""StepChangeEventArgs""/>
	|            /// </summary>
	|            /// <param name=""oldStep"">The current <see cref=""WizardStep""/>.</param>
	|            /// <param name=""newStep"">The new <see cref=""WizardStep""/>.</param>
	|            public StepChangeEventArgs(WizardStep oldStep, WizardStep newStep)
	|            {
	|                OldStep = oldStep;
	|                NewStep = newStep;
	|                Cancel = false;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// This event is raised when the current <see cref=""CurrentStep""/>) is about to change. Use <see cref=""StepChangeEventArgs.Cancel""/> 
	|        /// to abort the transition.
	|        /// </summary>
	|        public event Action<StepChangeEventArgs> StepChanging;
	|
	|        /// <summary>
	|        /// This event is raised after the <see cref=""Wizard""/> has changed the <see cref=""CurrentStep""/>. 
	|        /// </summary>
	|        public event Action<StepChangeEventArgs> StepChanged;
	|
	|        /// <summary>
	|        /// Gets or sets the currently active <see cref=""WizardStep""/>.
	|        /// </summary>
	|        public WizardStep CurrentStep
	|        {
	|            get => currentStep;
	|            set
	|            {
	|                GoToStep(value);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Called when the <see cref=""Wizard""/> is about to transition to another <see cref=""WizardStep""/>. Fires the <see cref=""StepChanging""/> event. 
	|        /// </summary>
	|        /// <param name=""oldStep"">The step the Wizard is about to change from</param>
	|        /// <param name=""newStep"">The step the Wizard is about to change to</param>
	|        /// <returns>True if the change is to be cancelled.</returns>
	|        public virtual bool OnStepChanging(WizardStep oldStep, WizardStep newStep)
	|        {
	|            var args = new StepChangeEventArgs(oldStep, newStep);
	|            StepChanging?.Invoke(args);
	|            return args.Cancel;
	|        }
	|
	|        /// <summary>
	|        /// Called when the <see cref=""Wizard""/> has completed transition to a new <see cref=""WizardStep""/>. Fires the <see cref=""StepChanged""/> event. 
	|        /// </summary>
	|        /// <param name=""oldStep"">The step the Wizard changed from</param>
	|        /// <param name=""newStep"">The step the Wizard has changed to</param>
	|        /// <returns>True if the change is to be cancelled.</returns>
	|        public virtual bool OnStepChanged(WizardStep oldStep, WizardStep newStep)
	|        {
	|            var args = new StepChangeEventArgs(oldStep, newStep);
	|            StepChanged?.Invoke(args);
	|            return args.Cancel;
	|        }
	|
	|        /// <summary>
	|        /// Changes to the specified <see cref=""WizardStep""/>.
	|        /// </summary>
	|        /// <param name=""newStep"">The step to go to.</param>
	|        /// <returns>True if the transition to the step succeeded. False if the step was not found or the operation was cancelled.</returns>
	|        public bool GoToStep(WizardStep newStep)
	|        {
	|            if (OnStepChanging(currentStep, newStep) || (newStep != null && !newStep.Enabled))
	|            {
	|                return false;
	|            }
	|
	|            // Hide all but the new step
	|            foreach (WizardStep step in steps)
	|            {
	|                step.Visible = (step == newStep);
	|                step.ShowHide();
	|            }
	|
	|            var oldStep = currentStep;
	|            currentStep = newStep;
	|
	|            if (currentStep is null)
	|            {
	|                return false;
	|            }
	|
	|            UpdateButtonsAndTitle();
	|
	|            // Set focus to the nav buttons
	|            if (backBtn.HasFocus)
	|            {
	|                backBtn.SetFocus();
	|            }
	|            else
	|            {
	|                nextfinishBtn.SetFocus();
	|            }
	|
	|            if (OnStepChanged(oldStep, currentStep))
	|            {
	|                // For correctness we do this, but it's meaningless because there's nothing to cancel
	|                return false;
	|            }
	|
	|            return true;
	|        }
	|
	|        private void UpdateButtonsAndTitle()
	|        {
	|            if (CurrentStep == null) return;
	|
	|            base.Title = $""{wizardTitle}{(steps.Count > 0 ? "" - "" + CurrentStep.Title : string.Empty)}"";
	|
	|            // Configure the Back button
	|            backBtn.Text = CurrentStep.BackButtonText != ustring.Empty ? CurrentStep.BackButtonText : Strings.wzBack; // ""_Back"";
	|            backBtn.Visible = (CurrentStep != GetFirstStep());
	|
	|            // Configure the Next/Finished button
	|            if (CurrentStep == GetLastStep())
	|            {
	|                nextfinishBtn.Text = CurrentStep.NextButtonText != ustring.Empty ? CurrentStep.NextButtonText : Strings.wzFinish; // ""Fi_nish"";
	|            }
	|            else
	|            {
	|                nextfinishBtn.Text = CurrentStep.NextButtonText != ustring.Empty ? CurrentStep.NextButtonText : Strings.wzNext; // ""_Next..."";
	|            }
	|
	|            SizeStep(CurrentStep);
	|
	|            SetNeedsLayout();
	|            LayoutSubviews();
	|            Redraw(Bounds);
	|        }
	|
	|        private void SizeStep(WizardStep step)
	|        {
	|            if (Modal)
	|            {
	|                // If we're modal, then we expand the WizardStep so that the top and side 
	|                // borders and not visible. The bottom border is the separator above the buttons.
	|                step.X = step.Y = -1;
	|                step.Height = Dim.Fill(1); // for button frame
	|                step.Width = Dim.Fill(-1);
	|            }
	|            else
	|            {
	|                // If we're not a modal, then we show the border around the WizardStep
	|                step.X = step.Y = 0;
	|                step.Height = Dim.Fill(1); // for button frame
	|                step.Width = Dim.Fill(0);
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Determines whether the <see cref=""Wizard""/> is displayed as modal pop-up or not.
	|        /// 
	|        /// The default is <c>true</c>. The Wizard will be shown with a frame with <see cref=""Title""/> and will behave like
	|        /// any <see cref=""Toplevel""/> window.
	|        /// 
	|        /// If set to <c>false</c> the Wizard will have no frame and will behave like any embedded <see cref=""View""/>.
	|        /// 
	|        /// To use Wizard as an embedded View 
	|        /// <list type=""number"">
	|        /// <item><description>Set <see cref=""Modal""/> to <c>false</c>.</description></item>
	|        /// <item><description>Add the Wizard to a containing view with <see cref=""View.Add(View)""/>.</description></item>
	|        /// </list>
	|        /// 
	|        /// If a non-Modal Wizard is added to the application after <see cref=""Application.Run(Func{Exception, bool})""/> has been called
	|        /// the first step must be explicitly set by setting <see cref=""CurrentStep""/> to <see cref=""GetNextStep()""/>:
	|        /// <code>
	|        ///    wizard.CurrentStep = wizard.GetNextStep();
	|        /// </code>
	|        /// </summary>
	|        public new bool Modal
	|        {
	|            get => base.Modal;
	|            set
	|            {
	|                base.Modal = value;
	|                foreach (var step in steps)
	|                {
	|                    SizeStep(step);
	|                }
	|                if (base.Modal)
	|                {
	|                    ColorScheme = Colors.Dialog;
	|                    Border.BorderStyle = BorderStyle.Rounded;
	|                    Border.Effect3D = true;
	|                    Border.DrawMarginFrame = true;
	|                }
	|                else
	|                {
	|                    if (SuperView != null)
	|                    {
	|                        ColorScheme = SuperView.ColorScheme;
	|                    }
	|                    else
	|                    {
	|                        ColorScheme = Colors.Base;
	|                    }
	|                    CanFocus = true;
	|                    Border.Effect3D = false;
	|                    Border.BorderStyle = BorderStyle.None;
	|                    Border.DrawMarginFrame = false;
	|                }
	|            }
	|        }
	|    }
	|}//namespace Terminal.Gui
	|//=======================================================================
	|namespace Terminal.Gui.Trees
	|{
	|
	|    /// <summary>
	|    /// Delegates of this type are used to fetch string representations of user's model objects
	|    /// </summary>
	|    /// <param name=""toRender"">The object that is being rendered</param>
	|    /// <returns></returns>
	|    public delegate string AspectGetterDelegate<T>(T toRender) where T : class;
	|    //=======================================================================
	|    class Branch<T> where T : class
	|    {
	|        /// <summary>
	|        /// True if the branch is expanded to reveal child branches.
	|        /// </summary>
	|        public bool IsExpanded { get; set; }
	|
	|        /// <summary>
	|        /// The users object that is being displayed by this branch of the tree.
	|        /// </summary>
	|        public T Model { get; private set; }
	|
	|        /// <summary>
	|        /// The depth of the current branch.  Depth of 0 indicates root level branches.
	|        /// </summary>
	|        public int Depth { get; private set; } = 0;
	|
	|        /// <summary>
	|        /// The children of the current branch.  This is null until the first call to 
	|        /// <see cref=""FetchChildren""/> to avoid enumerating the entire underlying hierarchy.
	|        /// </summary>
	|        public Dictionary<T, Branch<T>> ChildBranches { get; set; }
	|
	|        /// <summary>
	|        /// The parent <see cref=""Branch{T}""/> or null if it is a root.
	|        /// </summary>
	|        public Branch<T> Parent { get; private set; }
	|
	|        private TreeView<T> tree;
	|
	|        /// <summary>
	|        /// Declares a new branch of <paramref name=""tree""/> in which the users object 
	|        /// <paramref name=""model""/> is presented.
	|        /// </summary>
	|        /// <param name=""tree"">The UI control in which the branch resides.</param>
	|        /// <param name=""parentBranchIfAny"">Pass null for root level branches, otherwise
	|        /// pass the parent.</param>
	|        /// <param name=""model"">The user's object that should be displayed.</param>
	|        public Branch(TreeView<T> tree, Branch<T> parentBranchIfAny, T model)
	|        {
	|            this.tree = tree;
	|            this.Model = model;
	|
	|            if (parentBranchIfAny != null)
	|            {
	|                Depth = parentBranchIfAny.Depth + 1;
	|                Parent = parentBranchIfAny;
	|            }
	|        }
	|
	|
	|        /// <summary>
	|        /// Fetch the children of this branch. This method populates <see cref=""ChildBranches""/>.
	|        /// </summary>
	|        public virtual void FetchChildren()
	|        {
	|            if (tree.TreeBuilder == null)
	|            {
	|                return;
	|            }
	|
	|            IEnumerable<T> children;
	|
	|            if (Depth >= tree.MaxDepth)
	|            {
	|                children = Enumerable.Empty<T>();
	|            }
	|            else
	|            {
	|                children = tree.TreeBuilder.GetChildren(this.Model) ?? Enumerable.Empty<T>();
	|            }
	|
	|            this.ChildBranches = children.ToDictionary(k => k, val => new Branch<T>(tree, this, val));
	|        }
	|
	|        /// <summary>
	|        /// Returns the width of the line including prefix and the results 
	|        /// of <see cref=""TreeView{T}.AspectGetter""/> (the line body).
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual int GetWidth(ConsoleDriver driver)
	|        {
	|            return
	|                GetLinePrefix(driver).Sum(Rune.ColumnWidth) +
	|                Rune.ColumnWidth(GetExpandableSymbol(driver)) +
	|                (tree.AspectGetter(Model) ?? """").Length;
	|        }
	|
	|        /// <summary>
	|        /// Renders the current <see cref=""Model""/> on the specified line <paramref name=""y""/>.
	|        /// </summary>
	|        /// <param name=""driver""></param>
	|        /// <param name=""colorScheme""></param>
	|        /// <param name=""y""></param>
	|        /// <param name=""availableWidth""></param>
	|        public virtual void Draw(ConsoleDriver driver, ColorScheme colorScheme, int y, int availableWidth)
	|        {
	|            // true if the current line of the tree is the selected one and control has focus
	|            bool isSelected = tree.IsSelected(Model);
	|
	|            Attribute textColor = isSelected ? (tree.HasFocus ? colorScheme.Focus : colorScheme.HotNormal) : colorScheme.Normal;
	|            Attribute symbolColor = tree.Style.HighlightModelTextOnly ? colorScheme.Normal : textColor;
	|
	|            // Everything on line before the expansion run and branch text
	|            Rune[] prefix = GetLinePrefix(driver).ToArray();
	|            Rune expansion = GetExpandableSymbol(driver);
	|            string lineBody = tree.AspectGetter(Model) ?? """";
	|
	|            tree.Move(0, y);
	|
	|            // if we have scrolled to the right then bits of the prefix will have dispeared off the screen
	|            int toSkip = tree.ScrollOffsetHorizontal;
	|
	|            driver.SetAttribute(symbolColor);
	|            // Draw the line prefix (all parallel lanes or whitespace and an expand/collapse/leaf symbol)
	|            foreach (Rune r in prefix)
	|            {
	|
	|                if (toSkip > 0)
	|                {
	|                    toSkip--;
	|                }
	|                else
	|                {
	|                    driver.AddRune(r);
	|                    availableWidth -= Rune.ColumnWidth(r);
	|                }
	|            }
	|
	|            // pick color for expanded symbol
	|            if (tree.Style.ColorExpandSymbol || tree.Style.InvertExpandSymbolColors)
	|            {
	|                Attribute color = symbolColor;
	|
	|                if (tree.Style.ColorExpandSymbol)
	|                {
	|                    if (isSelected)
	|                    {
	|                        color = tree.Style.HighlightModelTextOnly ? colorScheme.HotNormal : (tree.HasFocus ? tree.ColorScheme.HotFocus : tree.ColorScheme.HotNormal);
	|                    }
	|                    else
	|                    {
	|                        color = tree.ColorScheme.HotNormal;
	|                    }
	|                }
	|                else
	|                {
	|                    color = symbolColor;
	|                }
	|
	|                if (tree.Style.InvertExpandSymbolColors)
	|                {
	|                    color = new Attribute(color.Background, color.Foreground);
	|                }
	|
	|                driver.SetAttribute(color);
	|            }
	|
	|            if (toSkip > 0)
	|            {
	|                toSkip--;
	|            }
	|            else
	|            {
	|                driver.AddRune(expansion);
	|                availableWidth -= Rune.ColumnWidth(expansion);
	|            }
	|
	|            // horizontal scrolling has already skipped the prefix but now must also skip some of the line body
	|            if (toSkip > 0)
	|            {
	|                if (toSkip > lineBody.Length)
	|                {
	|                    lineBody = """";
	|                }
	|                else
	|                {
	|                    lineBody = lineBody.Substring(toSkip);
	|                }
	|            }
	|
	|            // If body of line is too long
	|            if (lineBody.Sum(l => Rune.ColumnWidth(l)) > availableWidth)
	|            {
	|                // remaining space is zero and truncate the line
	|                lineBody = new string(lineBody.TakeWhile(c => (availableWidth -= Rune.ColumnWidth(c)) >= 0).ToArray());
	|                availableWidth = 0;
	|            }
	|            else
	|            {
	|
	|                // line is short so remaining width will be whatever comes after the line body
	|                availableWidth -= lineBody.Length;
	|            }
	|
	|
	|            // default behaviour is for model to use the color scheme
	|            // of the tree view
	|            var modelColor = textColor;
	|
	|            // if custom color delegate invoke it
	|            if (tree.ColorGetter != null)
	|            {
	|                var modelScheme = tree.ColorGetter(Model);
	|
	|                // if custom color scheme is defined for this Model
	|                if (modelScheme != null)
	|                {
	|                    // use it
	|                    modelColor = isSelected ? modelScheme.Focus : modelScheme.Normal;
	|                }
	|            }
	|
	|            driver.SetAttribute(modelColor);
	|            driver.AddStr(lineBody);
	|
	|            if (availableWidth > 0)
	|            {
	|                driver.SetAttribute(symbolColor);
	|                driver.AddStr(new string(' ', availableWidth));
	|            }
	|            driver.SetAttribute(colorScheme.Normal);
	|        }
	|
	|        /// <summary>
	|        /// Gets all characters to render prior to the current branches line.  This includes indentation
	|        /// whitespace and any tree branches (if enabled).
	|        /// </summary>
	|        /// <param name=""driver""></param>
	|        /// <returns></returns>
	|        private IEnumerable<Rune> GetLinePrefix(ConsoleDriver driver)
	|        {
	|            // If not showing line branches or this is a root object.
	|            if (!tree.Style.ShowBranchLines)
	|            {
	|                for (int i = 0; i < Depth; i++)
	|                {
	|                    yield return new Rune(' ');
	|                }
	|
	|                yield break;
	|            }
	|
	|            // yield indentations with runes appropriate to the state of the parents
	|            foreach (var cur in GetParentBranches().Reverse())
	|            {
	|                if (cur.IsLast())
	|                {
	|                    yield return new Rune(' ');
	|                }
	|                else
	|                {
	|                    yield return driver.VLine;
	|                }
	|
	|                yield return new Rune(' ');
	|            }
	|
	|            if (IsLast())
	|            {
	|                yield return driver.LLCorner;
	|            }
	|            else
	|            {
	|                yield return driver.LeftTee;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns all parents starting with the immediate parent and ending at the root.
	|        /// </summary>
	|        /// <returns></returns>
	|        private IEnumerable<Branch<T>> GetParentBranches()
	|        {
	|            var cur = Parent;
	|
	|            while (cur != null)
	|            {
	|                yield return cur;
	|                cur = cur.Parent;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Returns an appropriate symbol for displaying next to the string representation of 
	|        /// the <see cref=""Model""/> object to indicate whether it <see cref=""IsExpanded""/> or
	|        /// not (or it is a leaf).
	|        /// </summary>
	|        /// <param name=""driver""></param>
	|        /// <returns></returns>
	|        public Rune GetExpandableSymbol(ConsoleDriver driver)
	|        {
	|            var leafSymbol = tree.Style.ShowBranchLines ? driver.HLine : ' ';
	|
	|            if (IsExpanded)
	|            {
	|                return tree.Style.CollapseableSymbol ?? leafSymbol;
	|            }
	|
	|            if (CanExpand())
	|            {
	|                return tree.Style.ExpandableSymbol ?? leafSymbol;
	|            }
	|
	|            return leafSymbol;
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the current branch can be expanded according to 
	|        /// the <see cref=""TreeBuilder{T}""/> or cached children already fetched.
	|        /// </summary>
	|        /// <returns></returns>
	|        public bool CanExpand()
	|        {
	|            // if we do not know the children yet
	|            if (ChildBranches == null)
	|            {
	|
	|                //if there is a rapid method for determining whether there are children
	|                if (tree.TreeBuilder.SupportsCanExpand)
	|                {
	|                    return tree.TreeBuilder.CanExpand(Model);
	|                }
	|
	|                //there is no way of knowing whether we can expand without fetching the children
	|                FetchChildren();
	|            }
	|
	|            //we fetched or already know the children, so return whether we have any
	|            return ChildBranches.Any();
	|        }
	|
	|        /// <summary>
	|        /// Expands the current branch if possible.
	|        /// </summary>
	|        public void Expand()
	|        {
	|            if (ChildBranches == null)
	|            {
	|                FetchChildren();
	|            }
	|
	|            if (ChildBranches.Any())
	|            {
	|                IsExpanded = true;
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Marks the branch as collapsed (<see cref=""IsExpanded""/> false).
	|        /// </summary>
	|        public void Collapse()
	|        {
	|            IsExpanded = false;
	|        }
	|
	|        /// <summary>
	|        /// Refreshes cached knowledge in this branch e.g. what children an object has.
	|        /// </summary>
	|        /// <param name=""startAtTop"">True to also refresh all <see cref=""Parent""/> 
	|        /// branches (starting with the root).</param>
	|        public void Refresh(bool startAtTop)
	|        {
	|            // if we must go up and refresh from the top down
	|            if (startAtTop)
	|            {
	|                Parent?.Refresh(true);
	|            }
	|
	|            // we don't want to loose the state of our children so lets be selective about how we refresh
	|            //if we don't know about any children yet just use the normal method
	|            if (ChildBranches == null)
	|            {
	|                FetchChildren();
	|            }
	|            else
	|            {
	|                // we already knew about some children so preserve the state of the old children
	|
	|                // first gather the new Children
	|                var newChildren = tree.TreeBuilder?.GetChildren(this.Model) ?? Enumerable.Empty<T>();
	|
	|                // Children who no longer appear need to go
	|                foreach (var toRemove in ChildBranches.Keys.Except(newChildren).ToArray())
	|                {
	|                    ChildBranches.Remove(toRemove);
	|
	|                    //also if the user has this node selected (its disapearing) so lets change selection to us (the parent object) to be helpful
	|                    if (Equals(tree.SelectedObject, toRemove))
	|                    {
	|                        tree.SelectedObject = Model;
	|                    }
	|                }
	|
	|                // New children need to be added
	|                foreach (var newChild in newChildren)
	|                {
	|                    // If we don't know about the child yet we need a new branch
	|                    if (!ChildBranches.ContainsKey(newChild))
	|                    {
	|                        ChildBranches.Add(newChild, new Branch<T>(tree, this, newChild));
	|                    }
	|                    else
	|                    {
	|                        //we already have this object but update the reference anyway incase Equality match but the references are new
	|                        ChildBranches[newChild].Model = newChild;
	|                    }
	|                }
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Calls <see cref=""Refresh(bool)""/> on the current branch and all expanded children.
	|        /// </summary>
	|        internal void Rebuild()
	|        {
	|            Refresh(false);
	|
	|            // if we know about our children
	|            if (ChildBranches != null)
	|            {
	|                if (IsExpanded)
	|                {
	|                    //if we are expanded we need to updatethe visible children
	|                    foreach (var child in ChildBranches)
	|                    {
	|                        child.Value.Rebuild();
	|                    }
	|
	|                }
	|                else
	|                {
	|                    // we are not expanded so should forget about children because they may not exist anymore
	|                    ChildBranches = null;
	|                }
	|            }
	|
	|        }
	|
	|        /// <summary>
	|        /// Returns true if this branch has parents and it is the last node of it's parents 
	|        /// branches (or last root of the tree).
	|        /// </summary>
	|        /// <returns></returns>
	|        private bool IsLast()
	|        {
	|            if (Parent == null)
	|            {
	|                return this == tree.roots.Values.LastOrDefault();
	|            }
	|
	|            return Parent.ChildBranches.Values.LastOrDefault() == this;
	|        }
	|
	|        /// <summary>
	|        /// Returns true if the given x offset on the branch line is the +/- symbol.  Returns 
	|        /// false if not showing expansion symbols or leaf node etc.
	|        /// </summary>
	|        /// <param name=""driver""></param>
	|        /// <param name=""x""></param>
	|        /// <returns></returns>
	|        internal bool IsHitOnExpandableSymbol(ConsoleDriver driver, int x)
	|        {
	|            // if leaf node then we cannot expand
	|            if (!CanExpand())
	|            {
	|                return false;
	|            }
	|
	|            // if we could theoretically expand
	|            if (!IsExpanded && tree.Style.ExpandableSymbol != null)
	|            {
	|                return x == GetLinePrefix(driver).Count();
	|            }
	|
	|            // if we could theoretically collapse
	|            if (IsExpanded && tree.Style.CollapseableSymbol != null)
	|            {
	|                return x == GetLinePrefix(driver).Count();
	|            }
	|
	|            return false;
	|        }
	|
	|        /// <summary>
	|        /// Expands the current branch and all children branches.
	|        /// </summary>
	|        internal void ExpandAll()
	|        {
	|            Expand();
	|
	|            if (ChildBranches != null)
	|            {
	|                foreach (var child in ChildBranches)
	|                {
	|                    child.Value.ExpandAll();
	|                }
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Collapses the current branch and all children branches (even though those branches are 
	|        /// no longer visible they retain collapse/expansion state).
	|        /// </summary>
	|        internal void CollapseAll()
	|        {
	|            Collapse();
	|
	|            if (ChildBranches != null)
	|            {
	|                foreach (var child in ChildBranches)
	|                {
	|                    child.Value.CollapseAll();
	|                }
	|            }
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Implementation of <see cref=""ITreeBuilder{T}""/> that uses user defined functions
	|    /// </summary>
	|    public class DelegateTreeBuilder<T> : TreeBuilder<T>
	|    {
	|        private Func<T, IEnumerable<T>> childGetter;
	|        private Func<T, bool> canExpand;
	|
	|        /// <summary>
	|        /// Constructs an implementation of <see cref=""ITreeBuilder{T}""/> that calls the user 
	|        /// defined method <paramref name=""childGetter""/> to determine children
	|        /// </summary>
	|        /// <param name=""childGetter""></param>
	|        /// <returns></returns>
	|        public DelegateTreeBuilder(Func<T, IEnumerable<T>> childGetter) : base(false)
	|        {
	|            this.childGetter = childGetter;
	|        }
	|
	|        /// <summary>
	|        /// Constructs an implementation of <see cref=""ITreeBuilder{T}""/> that calls the user 
	|        /// defined method <paramref name=""childGetter""/> to determine children 
	|        /// and <paramref name=""canExpand""/> to determine expandability
	|        /// </summary>
	|        /// <param name=""childGetter""></param>
	|        /// <param name=""canExpand""></param>
	|        /// <returns></returns>
	|        public DelegateTreeBuilder(Func<T, IEnumerable<T>> childGetter, Func<T, bool> canExpand) : base(true)
	|        {
	|            this.childGetter = childGetter;
	|            this.canExpand = canExpand;
	|        }
	|
	|        /// <summary>
	|        /// Returns whether a node can be expanded based on the delegate passed during construction
	|        /// </summary>
	|        /// <param name=""toExpand""></param>
	|        /// <returns></returns>
	|        public override bool CanExpand(T toExpand)
	|        {
	|            return canExpand?.Invoke(toExpand) ?? base.CanExpand(toExpand);
	|        }
	|
	|        /// <summary>
	|        /// Returns children using the delegate method passed during construction
	|        /// </summary>
	|        /// <param name=""forObject""></param>
	|        /// <returns></returns>
	|        public override IEnumerable<T> GetChildren(T forObject)
	|        {
	|            return childGetter.Invoke(forObject);
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Interface for supplying data to a <see cref=""TreeView{T}""/> on demand as root level nodes
	|    /// are expanded by the user
	|    /// </summary>
	|    public interface ITreeBuilder<T>
	|    {
	|        /// <summary>
	|        /// Returns true if <see cref=""CanExpand""/> is implemented by this class
	|        /// </summary>
	|        /// <value></value>
	|        bool SupportsCanExpand { get; }
	|
	|        /// <summary>
	|        /// Returns true/false for whether a model has children.  This method should be implemented
	|        /// when <see cref=""GetChildren""/> is an expensive operation otherwise 
	|        /// <see cref=""SupportsCanExpand""/> should return false (in which case this method will not
	|        /// be called)
	|        /// </summary>
	|        /// <remarks>Only implement this method if you have a very fast way of determining whether 
	|        /// an object can have children e.g. checking a Type (directories can always be expanded)
	|        /// </remarks>
	|        /// <param name=""toExpand""></param>
	|        /// <returns></returns>
	|        bool CanExpand(T toExpand);
	|
	|        /// <summary>
	|        /// Returns all children of a given <paramref name=""forObject""/> which should be added to the 
	|        /// tree as new branches underneath it
	|        /// </summary>
	|        /// <param name=""forObject""></param>
	|        /// <returns></returns>
	|        IEnumerable<T> GetChildren(T forObject);
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Event args for the <see cref=""TreeView{T}.ObjectActivated""/> event
	|    /// </summary>
	|    /// <typeparam name=""T""></typeparam>
	|    public class ObjectActivatedEventArgs<T> where T : class
	|    {
	|
	|        /// <summary>
	|        /// The tree in which the activation occurred
	|        /// </summary>
	|        /// <value></value>
	|        public TreeView<T> Tree { get; }
	|
	|        /// <summary>
	|        /// The object that was selected at the time of activation
	|        /// </summary>
	|        /// <value></value>
	|        public T ActivatedObject { get; }
	|
	|
	|        /// <summary>
	|        /// Creates a new instance documenting activation of the <paramref name=""activated""/> object
	|        /// </summary>
	|        /// <param name=""tree"">Tree in which the activation is happening</param>
	|        /// <param name=""activated"">What object is being activated</param>
	|        public ObjectActivatedEventArgs(TreeView<T> tree, T activated)
	|        {
	|            Tree = tree;
	|            ActivatedObject = activated;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Event arguments describing a change in selected object in a tree view
	|    /// </summary>
	|    public class SelectionChangedEventArgs<T> : EventArgs where T : class
	|    {
	|        /// <summary>
	|        /// The view in which the change occurred
	|        /// </summary>
	|        public TreeView<T> Tree { get; }
	|
	|        /// <summary>
	|        /// The previously selected value (can be null)
	|        /// </summary>
	|        public T OldValue { get; }
	|
	|        /// <summary>
	|        /// The newly selected value in the <see cref=""Tree""/> (can be null)
	|        /// </summary>
	|        public T NewValue { get; }
	|
	|        /// <summary>
	|        /// Creates a new instance of event args describing a change of selection 
	|        /// in <paramref name=""tree""/>
	|        /// </summary>
	|        /// <param name=""tree""></param>
	|        /// <param name=""oldValue""></param>
	|        /// <param name=""newValue""></param>
	|        public SelectionChangedEventArgs(TreeView<T> tree, T oldValue, T newValue)
	|        {
	|            Tree = tree;
	|            OldValue = oldValue;
	|            NewValue = newValue;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Abstract implementation of <see cref=""ITreeBuilder{T}""/>.
	|    /// </summary>
	|    public abstract class TreeBuilder<T> : ITreeBuilder<T>
	|    {
	|
	|        /// <inheritdoc/>
	|        public bool SupportsCanExpand { get; protected set; } = false;
	|
	|        /// <summary>
	|        /// Override this method to return a rapid answer as to whether <see cref=""GetChildren(T)""/> 
	|        /// returns results.  If you are implementing this method ensure you passed true in base 
	|        /// constructor or set <see cref=""SupportsCanExpand""/>
	|        /// </summary>
	|        /// <param name=""toExpand""></param>
	|        /// <returns></returns>
	|        public virtual bool CanExpand(T toExpand)
	|        {
	|
	|            return GetChildren(toExpand).Any();
	|        }
	|
	|        /// <inheritdoc/>
	|        public abstract IEnumerable<T> GetChildren(T forObject);
	|
	|        /// <summary>
	|        /// Constructs base and initializes <see cref=""SupportsCanExpand""/>
	|        /// </summary>
	|        /// <param name=""supportsCanExpand"">Pass true if you intend to 
	|        /// implement <see cref=""CanExpand(T)""/> otherwise false</param>
	|        public TreeBuilder(bool supportsCanExpand)
	|        {
	|            SupportsCanExpand = supportsCanExpand;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Interface to implement when you want the regular (non generic) <see cref=""TreeView""/>
	|    /// to automatically determine children for your class (without having to specify 
	|    /// an <see cref=""ITreeBuilder{T}""/>)
	|    /// </summary>
	|    public interface ITreeNode
	|    {
	|        /// <summary>
	|        /// Text to display when rendering the node
	|        /// </summary>
	|        string Text { get; set; }
	|
	|        /// <summary>
	|        /// The children of your class which should be rendered underneath it when expanded
	|        /// </summary>
	|        /// <value></value>
	|        IList<ITreeNode> Children { get; }
	|
	|        /// <summary>
	|        /// Optionally allows you to store some custom data/class here.
	|        /// </summary>
	|        object Tag { get; set; }
	|    }
	|
	|    /// <summary>
	|    /// Simple class for representing nodes, use with regular (non generic) <see cref=""TreeView""/>.
	|    /// </summary>
	|    public class TreeNode : ITreeNode
	|    {
	|        /// <summary>
	|        /// Children of the current node
	|        /// </summary>
	|        /// <returns></returns>
	|        public virtual IList<ITreeNode> Children { get; set; } = new List<ITreeNode>();
	|
	|        /// <summary>
	|        /// Text to display in tree node for current entry
	|        /// </summary>
	|        /// <value></value>
	|        public virtual string Text { get; set; }
	|
	|        /// <summary>
	|        /// Optionally allows you to store some custom data/class here.
	|        /// </summary>
	|        public object Tag { get; set; }
	|
	|        /// <summary>
	|        /// returns <see cref=""Text""/>
	|        /// </summary>
	|        /// <returns></returns>
	|        public override string ToString()
	|        {
	|            return Text ?? ""Unamed Node"";
	|        }
	|
	|        /// <summary>
	|        /// Initialises a new instance with no <see cref=""Text""/>
	|        /// </summary>
	|        public TreeNode()
	|        {
	|
	|        }
	|        /// <summary>
	|        /// Initialises a new instance and sets starting <see cref=""Text""/>
	|        /// </summary>
	|        public TreeNode(string text)
	|        {
	|            Text = text;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// <see cref=""ITreeBuilder{T}""/> implementation for <see cref=""ITreeNode""/> objects
	|    /// </summary>
	|    public class TreeNodeBuilder : TreeBuilder<ITreeNode>
	|    {
	|
	|        /// <summary>
	|        /// Initialises a new instance of builder for any model objects of 
	|        /// Type <see cref=""ITreeNode""/>
	|        /// </summary>
	|        public TreeNodeBuilder() : base(false)
	|        {
	|
	|        }
	|
	|        /// <summary>
	|        /// Returns <see cref=""ITreeNode.Children""/> from <paramref name=""model""/>
	|        /// </summary>
	|        /// <param name=""model""></param>
	|        /// <returns></returns>
	|        public override IEnumerable<ITreeNode> GetChildren(ITreeNode model)
	|        {
	|            return model.Children;
	|        }
	|    }
	|    //=======================================================================
	|    /// <summary>
	|    /// Defines rendering options that affect how the tree is displayed.
	|    /// </summary>
	|    public class TreeStyle
	|    {
	|
	|        /// <summary>
	|        /// <see langword=""true""/> to render vertical lines under expanded nodes to show which node belongs to which 
	|        /// parent. <see langword=""false""/> to use only whitespace.
	|        /// </summary>
	|        /// <value></value>
	|        public bool ShowBranchLines { get; set; } = true;
	|
	|        /// <summary>
	|        /// Symbol to use for branch nodes that can be expanded to indicate this to the user. 
	|        /// Defaults to '+'. Set to null to hide.
	|        /// </summary>
	|        public Rune? ExpandableSymbol { get; set; } = '+';
	|
	|        /// <summary>
	|        /// Symbol to use for branch nodes that can be collapsed (are currently expanded).
	|        /// Defaults to '-'. Set to null to hide.
	|        /// </summary>
	|        public Rune? CollapseableSymbol { get; set; } = '-';
	|
	|        /// <summary>
	|        /// Set to <see langword=""true""/> to highlight expand/collapse symbols in hot key color.
	|        /// </summary>
	|        public bool ColorExpandSymbol { get; set; }
	|
	|        /// <summary>
	|        /// Invert console colours used to render the expand symbol.
	|        /// </summary>
	|        public bool InvertExpandSymbolColors { get; set; }
	|
	|        /// <summary>
	|        /// <see langword=""true""/> to leave the last row of the control free for overwritting (e.g. by a scrollbar)
	|        /// When <see langword=""true""/> scrolling will be triggered on the second last row of the control rather than.
	|        /// the last.
	|        /// </summary>
	|        /// <value></value>
	|        public bool LeaveLastRow { get; set; }
	|
	|        /// <summary>
	|        /// Set to <see langword=""true""/> to cause the selected item to be rendered with only the <see cref=""Branch{T}.Model""/> text
	|        /// to be highlighted. If <see langword=""false""/> (the default), the entire row will be highlighted.
	|        /// </summary>
	|        public bool HighlightModelTextOnly { get; set; } = false;
	|    }
	|}//namespace Terminal.Gui.Trees
	|//=======================================================================
	|//
	|// TODO:
	|// * FindNCurses needs to remove the old probing code
	|// * Removal of that proxy code
	|// * Need to implement reading pointers with the new API
	|// * Can remove the manual Dlopen features
	|// * initscr() diagnostics based on DLL can be fixed
	|//
	|// binding.cs.in: Core binding for curses.
	|//
	|// This file attempts to call into ncurses without relying on Mono's
	|// dllmap, so it will work with .NET Core.  This means that it needs
	|// two sets of bindings, one for ""ncurses"" which works on OSX, and one
	|// that works against ""libncursesw.so.5"" which is what you find on
	|// assorted Linux systems.
	|//
	|// Additionally, I do not want to rely on an external native library
	|// which is why all this pain to bind two separate ncurses is here.
	|//
	|// Authors:
	|//   Miguel de Icaza (miguel.de.icaza@gmail.com)
	|//
	|// Copyright (C) 2007 Novell (http://www.novell.com)
	|//
	|// Permission is hereby granted, free of charge, to any person obtaining
	|// a copy of this software and associated documentation files (the
	|// ""Software""), to deal in the Software without restriction, including
	|// without limitation the rights to use, copy, modify, merge, publish,
	|// distribute, sublicense, and/or sell copies of the Software, and to
	|// permit persons to whom the Software is furnished to do so, subject to
	|// the following conditions:
	|// 
	|// The above copyright notice and this permission notice shall be
	|// included in all copies or substantial portions of the Software.
	|// 
	|// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
	|// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	|// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	|// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	|// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	|// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	|// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	|//
	|
	|//#define USE_IOCTL
	|
	|
	|namespace Unix.Terminal
	|{
	|#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
	|    public partial class Curses
	|    {
	|#if USE_IOCTL
	|
	|		[StructLayout (LayoutKind.Sequential)]
	|		public struct winsize {
	|			public ushort ws_row;
	|			public ushort ws_col;
	|			public ushort ws_xpixel;   /* unused */
	|			public ushort ws_ypixel;   /* unused */
	|		};
	|#endif
	|        [StructLayout(LayoutKind.Sequential)]
	|        public struct MouseEvent
	|        {
	|            public short ID;
	|            public int X, Y, Z;
	|            public Event ButtonState;
	|        }
	|
	|        static int lines, cols;
	|        static Window main_window;
	|        static IntPtr curses_handle, curscr_ptr, lines_ptr, cols_ptr;
	|
	|        // If true, uses the DllImport into ""ncurses"", otherwise ""libncursesw.so.5""
	|        //static bool use_naked_driver;
	|
	|        static UnmanagedLibrary curses_library;
	|        static NativeMethods methods;
	|
	|
	|        [DllImport(""libc"")]
	|        public extern static int setlocale(int cate, [MarshalAs(UnmanagedType.LPStr)] string locale);
	|#if USE_IOCTL
	|
	|		[DllImport (""libc"")]
	|		public extern static int ioctl (int fd, int cmd, out winsize argp);
	|#endif
	|        static void LoadMethods()
	|        {
	|            var libs = UnmanagedLibrary.IsMacOSPlatform ? new string[] { ""libncurses.dylib"" } : new string[] { ""libncursesw.so.6"", ""libncursesw.so.5"" };
	|            var attempts = 1;
	|            while (true)
	|            {
	|                try
	|                {
	|                    curses_library = new UnmanagedLibrary(libs, false);
	|                    methods = new NativeMethods(curses_library);
	|                    break;
	|                }
	|                catch (Exception ex)
	|                {
	|
	|                    if (attempts == 1)
	|                    {
	|                        attempts++;
	|                        var (exitCode, result) = ClipboardProcessRunner.Bash(""cat /etc/os-release"", waitForOutput: true);
	|                        if (exitCode == 0 && result.Contains(""opensuse""))
	|                        {
	|                            libs[0] = ""libncursesw.so.5"";
	|                        }
	|                    }
	|                    else
	|                    {
	|                        throw ex.GetBaseException();
	|                    }
	|                }
	|            }
	|        }
	|
	|        static void FindNCurses()
	|        {
	|            LoadMethods();
	|            curses_handle = methods.UnmanagedLibrary.NativeLibraryHandle;
	|
	|            stdscr = read_static_ptr(""stdscr"");
	|            curscr_ptr = get_ptr(""curscr"");
	|            lines_ptr = get_ptr(""LINES"");
	|            cols_ptr = get_ptr(""COLS"");
	|        }
	|
	|        static public Window initscr()
	|        {
	|            setlocale(LC_ALL, """");
	|            FindNCurses();
	|
	|            // Prevents the terminal from being locked after exiting.
	|            reset_shell_mode();
	|
	|            main_window = new Window(methods.initscr());
	|            try
	|            {
	|                console_sharp_get_dims(out lines, out cols);
	|            }
	|            catch (DllNotFoundException)
	|            {
	|                endwin();
	|                Console.Error.WriteLine(""Unable to find the @MONO_CURSES@ native library\n"" +
	|                             ""this is different than the managed mono-curses.dll\n\n"" +
	|                             ""Typically you need to install to a LD_LIBRARY_PATH directory\n"" +
	|                             ""or DYLD_LIBRARY_PATH directory or run /sbin/ldconfig"");
	|                Environment.Exit(1);
	|            }
	|            return main_window;
	|        }
	|
	|        public static int Lines
	|        {
	|            get
	|            {
	|                return lines;
	|            }
	|        }
	|
	|        public static int Cols
	|        {
	|            get
	|            {
	|                return cols;
	|            }
	|        }
	|
	|        //
	|        // Returns true if the window changed since the last invocation, as a
	|        // side effect, the Lines and Cols properties are updated
	|        //
	|        public static bool CheckWinChange()
	|        {
	|            int l, c;
	|
	|            console_sharp_get_dims(out l, out c);
	|
	|            if (l < 1)
	|            {
	|                l = 1;
	|            }
	|            if (l != lines || c != cols)
	|            {
	|                lines = l;
	|                cols = c;
	|                return true;
	|            }
	|            return false;
	|        }
	|
	|        public static int addstr(string format, params object[] args)
	|        {
	|            var s = string.Format(format, args);
	|            return addwstr(s);
	|        }
	|
	|        static char[] r = new char[1];
	|
	|        //
	|        // Have to wrap the native addch, as it can not
	|        // display unicode characters, we have to use addstr
	|        // for that.   but we need addch to render special ACS
	|        // characters
	|        //
	|        public static int addch(int ch)
	|        {
	|            if (ch < 127 || ch > 0xffff)
	|                return methods.addch(ch);
	|            char c = (char)ch;
	|            return addwstr(new String(c, 1));
	|        }
	|
	|        public static int mvaddch(int y, int x, int ch)
	|        {
	|            if (ch < 127 || ch > 0xffff)
	|                return methods.mvaddch(y, x, ch);
	|            char c = (char)ch;
	|            return mvaddwstr(y, x, new String(c, 1));
	|        }
	|
	|        static IntPtr stdscr;
	|
	|        static IntPtr get_ptr(string key)
	|        {
	|            var ptr = curses_library.LoadSymbol(key);
	|
	|            if (ptr == IntPtr.Zero)
	|                throw new Exception(""Could not load the key "" + key);
	|            return ptr;
	|        }
	|
	|        internal static IntPtr read_static_ptr(string key)
	|        {
	|            var ptr = get_ptr(key);
	|            return Marshal.ReadIntPtr(ptr);
	|        }
	|
	|        internal static IntPtr console_sharp_get_stdscr() => stdscr;
	|
	|        internal static IntPtr console_sharp_get_curscr()
	|        {
	|            return Marshal.ReadIntPtr(curscr_ptr);
	|        }
	|
	|        internal static void console_sharp_get_dims(out int lines, out int cols)
	|        {
	|#if USE_IOCTL
	|
	|			if (UnmanagedLibrary.IsMacOSPlatform) {
	|				int cmd = TIOCGWINSZ_MAC;
	|
	|				if (ioctl (1, cmd, out winsize ws) == 0) {
	|					lines = ws.ws_row;
	|					cols = ws.ws_col;
	|
	|					if (lines == Lines && cols == Cols) {
	|						return;
	|					}
	|
	|					resizeterm (lines, cols);
	|				} else {
	|					lines = Lines;
	|					cols = Cols;
	|				}
	|			} else {
	|				lines = Marshal.ReadInt32 (lines_ptr);
	|				cols = Marshal.ReadInt32 (cols_ptr);
	|			}
	|#else
	|            lines = Marshal.ReadInt32(lines_ptr);
	|            cols = Marshal.ReadInt32(cols_ptr);
	|#endif
	|            //int cmd;
	|            //if (UnmanagedLibrary.IsMacOSPlatform) {
	|            //	cmd = TIOCGWINSZ_MAC;
	|            //} else {
	|            //	cmd = TIOCGWINSZ;
	|            //}
	|
	|            //if (ioctl (1, cmd, out winsize ws) == 0) {
	|            //	lines = ws.ws_row;
	|            //	cols = ws.ws_col;
	|
	|            //	if (lines == Lines && cols == Cols) {
	|            //		return;
	|            //	}
	|
	|            //	resizeterm (lines, cols);
	|            //} else {
	|            //	lines = Lines;
	|            //	cols = Cols;
	|            //}
	|        }
	|
	|        public static Event mousemask(Event newmask, out Event oldmask)
	|        {
	|            IntPtr e;
	|            var ret = (Event)(methods.mousemask((IntPtr)newmask, out e));
	|            oldmask = (Event)e;
	|            return ret;
	|        }
	|
	|        // We encode ESC + char (what Alt-char generates) as 0x2000 + char
	|        public const int KeyAlt = 0x2000;
	|
	|        static public int IsAlt(int key)
	|        {
	|            if ((key & KeyAlt) != 0)
	|                return key & ~KeyAlt;
	|            return 0;
	|        }
	|
	|        public static int StartColor() => methods.start_color();
	|        public static bool HasColors => methods.has_colors();
	|        public static int InitColorPair(short pair, short foreground, short background) => methods.init_pair(pair, foreground, background);
	|        public static int UseDefaultColors() => methods.use_default_colors();
	|        public static int ColorPairs => methods.COLOR_PAIRS();
	|
	|        //
	|        // The proxy methods to call into each version
	|        //
	|        static public int endwin() => methods.endwin();
	|        static public bool isendwin() => methods.isendwin();
	|        static public int cbreak() => methods.cbreak();
	|        static public int nocbreak() => methods.nocbreak();
	|        static public int echo() => methods.echo();
	|        static public int noecho() => methods.noecho();
	|        static public int halfdelay(int t) => methods.halfdelay(t);
	|        static public int raw() => methods.raw();
	|        static public int noraw() => methods.noraw();
	|        static public void noqiflush() => methods.noqiflush();
	|        static public void qiflush() => methods.qiflush();
	|        static public int typeahead(IntPtr fd) => methods.typeahead(fd);
	|        static public int timeout(int delay) => methods.timeout(delay);
	|        static public int wtimeout(IntPtr win, int delay) => methods.wtimeout(win, delay);
	|        static public int notimeout(IntPtr win, bool bf) => methods.notimeout(win, bf);
	|        static public int keypad(IntPtr win, bool bf) => methods.keypad(win, bf);
	|        static public int meta(IntPtr win, bool bf) => methods.meta(win, bf);
	|        static public int intrflush(IntPtr win, bool bf) => methods.intrflush(win, bf);
	|        static public int clearok(IntPtr win, bool bf) => methods.clearok(win, bf);
	|        static public int idlok(IntPtr win, bool bf) => methods.idlok(win, bf);
	|        static public void idcok(IntPtr win, bool bf) => methods.idcok(win, bf);
	|        static public void immedok(IntPtr win, bool bf) => methods.immedok(win, bf);
	|        static public int leaveok(IntPtr win, bool bf) => methods.leaveok(win, bf);
	|        static public int wsetscrreg(IntPtr win, int top, int bot) => methods.wsetscrreg(win, top, bot);
	|        static public int scrollok(IntPtr win, bool bf) => methods.scrollok(win, bf);
	|        static public int nl() => methods.nl();
	|        static public int nonl() => methods.nonl();
	|        static public int setscrreg(int top, int bot) => methods.setscrreg(top, bot);
	|        static public int refresh() => methods.refresh();
	|        static public int doupdate() => methods.doupdate();
	|        static public int wrefresh(IntPtr win) => methods.wrefresh(win);
	|        static public int redrawwin(IntPtr win) => methods.redrawwin(win);
	|        //static public int wredrawwin (IntPtr win, int beg_line, int num_lines) => methods.wredrawwin (win, beg_line, num_lines);
	|        static public int wnoutrefresh(IntPtr win) => methods.wnoutrefresh(win);
	|        static public int move(int line, int col) => methods.move(line, col);
	|        static public int curs_set(int visibility) => methods.curs_set(visibility);
	|        //static public int addch (int ch) => methods.addch (ch);
	|        static public int addwstr(string s) => methods.addwstr(s);
	|        static public int mvaddwstr(int y, int x, string s) => methods.mvaddwstr(y, x, s);
	|        static public int wmove(IntPtr win, int line, int col) => methods.wmove(win, line, col);
	|        static public int waddch(IntPtr win, int ch) => methods.waddch(win, ch);
	|        static public int attron(int attrs) => methods.attron(attrs);
	|        static public int attroff(int attrs) => methods.attroff(attrs);
	|        static public int attrset(int attrs) => methods.attrset(attrs);
	|        static public int getch() => methods.getch();
	|        static public int get_wch(out int sequence) => methods.get_wch(out sequence);
	|        static public int ungetch(int ch) => methods.ungetch(ch);
	|        static public int mvgetch(int y, int x) => methods.mvgetch(y, x);
	|        static public bool has_colors() => methods.has_colors();
	|        static public int start_color() => methods.start_color();
	|        static public int init_pair(short pair, short f, short b) => methods.init_pair(pair, f, b);
	|        static public int use_default_colors() => methods.use_default_colors();
	|        static public int COLOR_PAIRS() => methods.COLOR_PAIRS();
	|        static public uint getmouse(out MouseEvent ev) => methods.getmouse(out ev);
	|        static public uint ungetmouse(ref MouseEvent ev) => methods.ungetmouse(ref ev);
	|        static public int mouseinterval(int interval) => methods.mouseinterval(interval);
	|        static public bool is_term_resized(int lines, int columns) => methods.is_term_resized(lines, columns);
	|        static public int resize_term(int lines, int columns) => methods.resize_term(lines, columns);
	|        static public int resizeterm(int lines, int columns) => methods.resizeterm(lines, columns);
	|        static public void use_env(bool f) => methods.use_env(f);
	|        static public int flushinp() => methods.flushinp();
	|        static public int def_prog_mode() => methods.def_prog_mode();
	|        static public int def_shell_mode() => methods.def_shell_mode();
	|        static public int reset_prog_mode() => methods.reset_prog_mode();
	|        static public int reset_shell_mode() => methods.reset_shell_mode();
	|        static public int savetty() => methods.savetty();
	|        static public int resetty() => methods.resetty();
	|        static public int set_escdelay(int size) => methods.set_escdelay(size);
	|        static public int nodelay(IntPtr win, bool bf) => methods.nodelay(win, bf);
	|    }
	|
	|#pragma warning disable RCS1102 // Make class static.
	|    internal class Delegates
	|    {
	|#pragma warning restore RCS1102 // Make class static.
	|#pragma warning disable CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
	|        public delegate IntPtr initscr();
	|        public delegate int endwin();
	|        public delegate bool isendwin();
	|        public delegate int cbreak();
	|        public delegate int nocbreak();
	|        public delegate int echo();
	|        public delegate int noecho();
	|        public delegate int halfdelay(int t);
	|        public delegate int raw();
	|        public delegate int noraw();
	|        public delegate void noqiflush();
	|        public delegate void qiflush();
	|        public delegate int typeahead(IntPtr fd);
	|        public delegate int timeout(int delay);
	|        public delegate int wtimeout(IntPtr win, int delay);
	|        public delegate int notimeout(IntPtr win, bool bf);
	|        public delegate int keypad(IntPtr win, bool bf);
	|        public delegate int meta(IntPtr win, bool bf);
	|        public delegate int intrflush(IntPtr win, bool bf);
	|        public delegate int clearok(IntPtr win, bool bf);
	|        public delegate int idlok(IntPtr win, bool bf);
	|        public delegate void idcok(IntPtr win, bool bf);
	|        public delegate void immedok(IntPtr win, bool bf);
	|        public delegate int leaveok(IntPtr win, bool bf);
	|        public delegate int wsetscrreg(IntPtr win, int top, int bot);
	|        public delegate int scrollok(IntPtr win, bool bf);
	|        public delegate int nl();
	|        public delegate int nonl();
	|        public delegate int setscrreg(int top, int bot);
	|        public delegate int refresh();
	|        public delegate int doupdate();
	|        public delegate int wrefresh(IntPtr win);
	|        public delegate int redrawwin(IntPtr win);
	|        //public delegate int wredrawwin (IntPtr win, int beg_line, int num_lines);
	|        public delegate int wnoutrefresh(IntPtr win);
	|        public delegate int move(int line, int col);
	|        public delegate int curs_set(int visibility);
	|        public delegate int addch(int ch);
	|        public delegate int mvaddch(int y, int x, int ch);
	|        public delegate int addwstr([MarshalAs(UnmanagedType.LPWStr)] string s);
	|        public delegate int mvaddwstr(int y, int x, [MarshalAs(UnmanagedType.LPWStr)] string s);
	|        public delegate int wmove(IntPtr win, int line, int col);
	|        public delegate int waddch(IntPtr win, int ch);
	|        public delegate int attron(int attrs);
	|        public delegate int attroff(int attrs);
	|        public delegate int attrset(int attrs);
	|        public delegate int getch();
	|        public delegate int get_wch(out int sequence);
	|        public delegate int ungetch(int ch);
	|        public delegate int mvgetch(int y, int x);
	|        public delegate bool has_colors();
	|        public delegate int start_color();
	|        public delegate int init_pair(short pair, short f, short b);
	|        public delegate int use_default_colors();
	|        public delegate int COLOR_PAIRS();
	|        public delegate uint getmouse(out Curses.MouseEvent ev);
	|        public delegate uint ungetmouse(ref Curses.MouseEvent ev);
	|        public delegate int mouseinterval(int interval);
	|        public delegate IntPtr mousemask(IntPtr newmask, out IntPtr oldMask);
	|        public delegate bool is_term_resized(int lines, int columns);
	|        public delegate int resize_term(int lines, int columns);
	|        public delegate int resizeterm(int lines, int columns);
	|        public delegate void use_env(bool f);
	|        public delegate int flushinp();
	|        public delegate int def_prog_mode();
	|        public delegate int def_shell_mode();
	|        public delegate int reset_prog_mode();
	|        public delegate int reset_shell_mode();
	|        public delegate int savetty();
	|        public delegate int resetty();
	|        public delegate int set_escdelay(int size);
	|        public delegate int nodelay(IntPtr win, bool bf);
	|    }
	|
	|    internal class NativeMethods
	|    {
	|        public readonly Delegates.initscr initscr;
	|        public readonly Delegates.endwin endwin;
	|        public readonly Delegates.isendwin isendwin;
	|        public readonly Delegates.cbreak cbreak;
	|        public readonly Delegates.nocbreak nocbreak;
	|        public readonly Delegates.echo echo;
	|        public readonly Delegates.noecho noecho;
	|        public readonly Delegates.halfdelay halfdelay;
	|        public readonly Delegates.raw raw;
	|        public readonly Delegates.noraw noraw;
	|        public readonly Delegates.noqiflush noqiflush;
	|        public readonly Delegates.qiflush qiflush;
	|        public readonly Delegates.typeahead typeahead;
	|        public readonly Delegates.timeout timeout;
	|        public readonly Delegates.wtimeout wtimeout;
	|        public readonly Delegates.notimeout notimeout;
	|        public readonly Delegates.keypad keypad;
	|        public readonly Delegates.meta meta;
	|        public readonly Delegates.intrflush intrflush;
	|        public readonly Delegates.clearok clearok;
	|        public readonly Delegates.idlok idlok;
	|        public readonly Delegates.idcok idcok;
	|        public readonly Delegates.immedok immedok;
	|        public readonly Delegates.leaveok leaveok;
	|        public readonly Delegates.wsetscrreg wsetscrreg;
	|        public readonly Delegates.scrollok scrollok;
	|        public readonly Delegates.nl nl;
	|        public readonly Delegates.nonl nonl;
	|        public readonly Delegates.setscrreg setscrreg;
	|        public readonly Delegates.refresh refresh;
	|        public readonly Delegates.doupdate doupdate;
	|        public readonly Delegates.wrefresh wrefresh;
	|        public readonly Delegates.redrawwin redrawwin;
	|        //public readonly Delegates.wredrawwin wredrawwin;
	|        public readonly Delegates.wnoutrefresh wnoutrefresh;
	|        public readonly Delegates.move move;
	|        public readonly Delegates.curs_set curs_set;
	|        public readonly Delegates.addch addch;
	|        public readonly Delegates.mvaddch mvaddch;
	|        public readonly Delegates.addwstr addwstr;
	|        public readonly Delegates.mvaddwstr mvaddwstr;
	|        public readonly Delegates.wmove wmove;
	|        public readonly Delegates.waddch waddch;
	|        public readonly Delegates.attron attron;
	|        public readonly Delegates.attroff attroff;
	|        public readonly Delegates.attrset attrset;
	|        public readonly Delegates.getch getch;
	|        public readonly Delegates.get_wch get_wch;
	|        public readonly Delegates.ungetch ungetch;
	|        public readonly Delegates.mvgetch mvgetch;
	|        public readonly Delegates.has_colors has_colors;
	|        public readonly Delegates.start_color start_color;
	|        public readonly Delegates.init_pair init_pair;
	|        public readonly Delegates.use_default_colors use_default_colors;
	|        public readonly Delegates.COLOR_PAIRS COLOR_PAIRS;
	|        public readonly Delegates.getmouse getmouse;
	|        public readonly Delegates.ungetmouse ungetmouse;
	|        public readonly Delegates.mouseinterval mouseinterval;
	|        public readonly Delegates.mousemask mousemask;
	|        public readonly Delegates.is_term_resized is_term_resized;
	|        public readonly Delegates.resize_term resize_term;
	|        public readonly Delegates.resizeterm resizeterm;
	|        public readonly Delegates.use_env use_env;
	|        public readonly Delegates.flushinp flushinp;
	|        public readonly Delegates.def_prog_mode def_prog_mode;
	|        public readonly Delegates.def_shell_mode def_shell_mode;
	|        public readonly Delegates.reset_prog_mode reset_prog_mode;
	|        public readonly Delegates.reset_shell_mode reset_shell_mode;
	|        public readonly Delegates.savetty savetty;
	|        public readonly Delegates.resetty resetty;
	|        public readonly Delegates.set_escdelay set_escdelay;
	|        public readonly Delegates.nodelay nodelay;
	|        public UnmanagedLibrary UnmanagedLibrary;
	|
	|        public NativeMethods(UnmanagedLibrary lib)
	|        {
	|            this.UnmanagedLibrary = lib;
	|            initscr = lib.GetNativeMethodDelegate<Delegates.initscr>(""initscr"");
	|            endwin = lib.GetNativeMethodDelegate<Delegates.endwin>(""endwin"");
	|            isendwin = lib.GetNativeMethodDelegate<Delegates.isendwin>(""isendwin"");
	|            cbreak = lib.GetNativeMethodDelegate<Delegates.cbreak>(""cbreak"");
	|            nocbreak = lib.GetNativeMethodDelegate<Delegates.nocbreak>(""nocbreak"");
	|            echo = lib.GetNativeMethodDelegate<Delegates.echo>(""echo"");
	|            noecho = lib.GetNativeMethodDelegate<Delegates.noecho>(""noecho"");
	|            halfdelay = lib.GetNativeMethodDelegate<Delegates.halfdelay>(""halfdelay"");
	|            raw = lib.GetNativeMethodDelegate<Delegates.raw>(""raw"");
	|            noraw = lib.GetNativeMethodDelegate<Delegates.noraw>(""noraw"");
	|            noqiflush = lib.GetNativeMethodDelegate<Delegates.noqiflush>(""noqiflush"");
	|            qiflush = lib.GetNativeMethodDelegate<Delegates.qiflush>(""qiflush"");
	|            typeahead = lib.GetNativeMethodDelegate<Delegates.typeahead>(""typeahead"");
	|            timeout = lib.GetNativeMethodDelegate<Delegates.timeout>(""timeout"");
	|            wtimeout = lib.GetNativeMethodDelegate<Delegates.wtimeout>(""wtimeout"");
	|            notimeout = lib.GetNativeMethodDelegate<Delegates.notimeout>(""notimeout"");
	|            keypad = lib.GetNativeMethodDelegate<Delegates.keypad>(""keypad"");
	|            meta = lib.GetNativeMethodDelegate<Delegates.meta>(""meta"");
	|            intrflush = lib.GetNativeMethodDelegate<Delegates.intrflush>(""intrflush"");
	|            clearok = lib.GetNativeMethodDelegate<Delegates.clearok>(""clearok"");
	|            idlok = lib.GetNativeMethodDelegate<Delegates.idlok>(""idlok"");
	|            idcok = lib.GetNativeMethodDelegate<Delegates.idcok>(""idcok"");
	|            immedok = lib.GetNativeMethodDelegate<Delegates.immedok>(""immedok"");
	|            leaveok = lib.GetNativeMethodDelegate<Delegates.leaveok>(""leaveok"");
	|            wsetscrreg = lib.GetNativeMethodDelegate<Delegates.wsetscrreg>(""wsetscrreg"");
	|            scrollok = lib.GetNativeMethodDelegate<Delegates.scrollok>(""scrollok"");
	|            nl = lib.GetNativeMethodDelegate<Delegates.nl>(""nl"");
	|            nonl = lib.GetNativeMethodDelegate<Delegates.nonl>(""nonl"");
	|            setscrreg = lib.GetNativeMethodDelegate<Delegates.setscrreg>(""setscrreg"");
	|            refresh = lib.GetNativeMethodDelegate<Delegates.refresh>(""refresh"");
	|            doupdate = lib.GetNativeMethodDelegate<Delegates.doupdate>(""doupdate"");
	|            wrefresh = lib.GetNativeMethodDelegate<Delegates.wrefresh>(""wrefresh"");
	|            redrawwin = lib.GetNativeMethodDelegate<Delegates.redrawwin>(""redrawwin"");
	|            //wredrawwin = lib.GetNativeMethodDelegate<Delegates.wredrawwin> (""wredrawwin"");
	|            wnoutrefresh = lib.GetNativeMethodDelegate<Delegates.wnoutrefresh>(""wnoutrefresh"");
	|            move = lib.GetNativeMethodDelegate<Delegates.move>(""move"");
	|            curs_set = lib.GetNativeMethodDelegate<Delegates.curs_set>(""curs_set"");
	|            addch = lib.GetNativeMethodDelegate<Delegates.addch>(""addch"");
	|            mvaddch = lib.GetNativeMethodDelegate<Delegates.mvaddch>(""mvaddch"");
	|            addwstr = lib.GetNativeMethodDelegate<Delegates.addwstr>(""addwstr"");
	|            mvaddwstr = lib.GetNativeMethodDelegate<Delegates.mvaddwstr>(""mvaddwstr"");
	|            wmove = lib.GetNativeMethodDelegate<Delegates.wmove>(""wmove"");
	|            waddch = lib.GetNativeMethodDelegate<Delegates.waddch>(""waddch"");
	|            attron = lib.GetNativeMethodDelegate<Delegates.attron>(""attron"");
	|            attroff = lib.GetNativeMethodDelegate<Delegates.attroff>(""attroff"");
	|            attrset = lib.GetNativeMethodDelegate<Delegates.attrset>(""attrset"");
	|            getch = lib.GetNativeMethodDelegate<Delegates.getch>(""getch"");
	|            get_wch = lib.GetNativeMethodDelegate<Delegates.get_wch>(""get_wch"");
	|            ungetch = lib.GetNativeMethodDelegate<Delegates.ungetch>(""ungetch"");
	|            mvgetch = lib.GetNativeMethodDelegate<Delegates.mvgetch>(""mvgetch"");
	|            has_colors = lib.GetNativeMethodDelegate<Delegates.has_colors>(""has_colors"");
	|            start_color = lib.GetNativeMethodDelegate<Delegates.start_color>(""start_color"");
	|            init_pair = lib.GetNativeMethodDelegate<Delegates.init_pair>(""init_pair"");
	|            use_default_colors = lib.GetNativeMethodDelegate<Delegates.use_default_colors>(""use_default_colors"");
	|            COLOR_PAIRS = lib.GetNativeMethodDelegate<Delegates.COLOR_PAIRS>(""COLOR_PAIRS"");
	|            getmouse = lib.GetNativeMethodDelegate<Delegates.getmouse>(""getmouse"");
	|            ungetmouse = lib.GetNativeMethodDelegate<Delegates.ungetmouse>(""ungetmouse"");
	|            mouseinterval = lib.GetNativeMethodDelegate<Delegates.mouseinterval>(""mouseinterval"");
	|            mousemask = lib.GetNativeMethodDelegate<Delegates.mousemask>(""mousemask"");
	|            is_term_resized = lib.GetNativeMethodDelegate<Delegates.is_term_resized>(""is_term_resized"");
	|            resize_term = lib.GetNativeMethodDelegate<Delegates.resize_term>(""resize_term"");
	|            resizeterm = lib.GetNativeMethodDelegate<Delegates.resizeterm>(""resizeterm"");
	|            use_env = lib.GetNativeMethodDelegate<Delegates.use_env>(""use_env"");
	|            flushinp = lib.GetNativeMethodDelegate<Delegates.flushinp>(""flushinp"");
	|            def_prog_mode = lib.GetNativeMethodDelegate<Delegates.def_prog_mode>(""def_prog_mode"");
	|            def_shell_mode = lib.GetNativeMethodDelegate<Delegates.def_shell_mode>(""def_shell_mode"");
	|            reset_prog_mode = lib.GetNativeMethodDelegate<Delegates.reset_prog_mode>(""reset_prog_mode"");
	|            reset_shell_mode = lib.GetNativeMethodDelegate<Delegates.reset_shell_mode>(""reset_shell_mode"");
	|            savetty = lib.GetNativeMethodDelegate<Delegates.savetty>(""savetty"");
	|            resetty = lib.GetNativeMethodDelegate<Delegates.resetty>(""resetty"");
	|            set_escdelay = lib.GetNativeMethodDelegate<Delegates.set_escdelay>(""set_escdelay"");
	|            nodelay = lib.GetNativeMethodDelegate<Delegates.nodelay>(""nodelay"");
	|        }
	|    }
	|#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	|#pragma warning restore CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
	|    //=======================================================================
	|    /*
	|     * This file is autogenerated by the attrib.c program, do not edit
	|     */
	|
	|    //#define XTERM1006
	|
	|#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
	|    public partial class Curses
	|    {
	|        public const int A_NORMAL = unchecked((int)0x0);
	|        public const int A_STANDOUT = unchecked((int)0x10000);
	|        public const int A_UNDERLINE = unchecked((int)0x20000);
	|        public const int A_REVERSE = unchecked((int)0x40000);
	|        public const int A_BLINK = unchecked((int)0x80000);
	|        public const int A_DIM = unchecked((int)0x100000);
	|        public const int A_BOLD = unchecked((int)0x200000);
	|        public const int A_PROTECT = unchecked((int)0x1000000);
	|        public const int A_INVIS = unchecked((int)0x800000);
	|        public const int ACS_LLCORNER = unchecked((int)0x40006d);
	|        public const int ACS_LRCORNER = unchecked((int)0x40006a);
	|        public const int ACS_HLINE = unchecked((int)0x400071);
	|        public const int ACS_ULCORNER = unchecked((int)0x40006c);
	|        public const int ACS_URCORNER = unchecked((int)0x40006b);
	|        public const int ACS_VLINE = unchecked((int)0x400078);
	|        public const int ACS_LTEE = unchecked((int)0x400074);
	|        public const int ACS_RTEE = unchecked((int)0x400075);
	|        public const int ACS_BTEE = unchecked((int)0x400076);
	|        public const int ACS_TTEE = unchecked((int)0x400077);
	|        public const int ACS_PLUS = unchecked((int)0x40006e);
	|        public const int ACS_S1 = unchecked((int)0x40006f);
	|        public const int ACS_S9 = unchecked((int)0x400073);
	|        public const int ACS_DIAMOND = unchecked((int)0x400060);
	|        public const int ACS_CKBOARD = unchecked((int)0x400061);
	|        public const int ACS_DEGREE = unchecked((int)0x400066);
	|        public const int ACS_PLMINUS = unchecked((int)0x400067);
	|        public const int ACS_BULLET = unchecked((int)0x40007e);
	|        public const int ACS_LARROW = unchecked((int)0x40002c);
	|        public const int ACS_RARROW = unchecked((int)0x40002b);
	|        public const int ACS_DARROW = unchecked((int)0x40002e);
	|        public const int ACS_UARROW = unchecked((int)0x40002d);
	|        public const int ACS_BOARD = unchecked((int)0x400068);
	|        public const int ACS_LANTERN = unchecked((int)0x400069);
	|        public const int ACS_BLOCK = unchecked((int)0x400030);
	|        public const int COLOR_BLACK = unchecked((int)0x0);
	|        public const int COLOR_RED = unchecked((int)0x1);
	|        public const int COLOR_GREEN = unchecked((int)0x2);
	|        public const int COLOR_YELLOW = unchecked((int)0x3);
	|        public const int COLOR_BLUE = unchecked((int)0x4);
	|        public const int COLOR_MAGENTA = unchecked((int)0x5);
	|        public const int COLOR_CYAN = unchecked((int)0x6);
	|        public const int COLOR_WHITE = unchecked((int)0x7);
	|        public const int COLOR_GRAY = unchecked((int)0x8);
	|        public const int KEY_CODE_YES = unchecked((int)0x100);
	|        public const int ERR = unchecked((int)0xffffffff);
	|        public const int TIOCGWINSZ = unchecked((int)0x5413);
	|        public const int TIOCGWINSZ_MAC = unchecked((int)0x40087468);
	|
	|        [Flags]
	|        public enum Event : long
	|        {
	|            Button1Pressed = unchecked((int)0x2),
	|            Button1Released = unchecked((int)0x1),
	|            Button1Clicked = unchecked((int)0x4),
	|            Button1DoubleClicked = unchecked((int)0x8),
	|            Button1TripleClicked = unchecked((int)0x10),
	|            Button2Pressed = unchecked((int)0x40),
	|            Button2Released = unchecked((int)0x20),
	|            Button2Clicked = unchecked((int)0x80),
	|            Button2DoubleClicked = unchecked((int)0x100),
	|            Button2TripleClicked = unchecked((int)0x200),
	|            Button3Pressed = unchecked((int)0x800),
	|            Button3Released = unchecked((int)0x400),
	|            Button3Clicked = unchecked((int)0x1000),
	|            Button3DoubleClicked = unchecked((int)0x2000),
	|            Button3TripleClicked = unchecked((int)0x4000),
	|            ButtonWheeledUp = unchecked((int)0x10000),
	|            ButtonWheeledDown = unchecked((int)0x200000),
	|            Button4Pressed = unchecked((int)0x80000),
	|            Button4Released = unchecked((int)0x40000),
	|            Button4Clicked = unchecked((int)0x100000),
	|            Button4DoubleClicked = unchecked((int)0x20000),
	|            Button4TripleClicked = unchecked((int)0x400000),
	|            ButtonShift = unchecked((int)0x4000000),
	|            ButtonCtrl = unchecked((int)0x2000000),
	|            ButtonAlt = unchecked((int)0x8000000),
	|            ReportMousePosition = unchecked((int)0x10000000),
	|            AllEvents = unchecked((int)0x7ffffff),
	|        }
	|#if XTERM1006
	|		public const int LeftRightUpNPagePPage= unchecked((int)0x8);
	|		public const int DownEnd = unchecked((int)0x6);
	|		public const int Home = unchecked((int)0x7);
	|#else
	|        public const int LeftRightUpNPagePPage = unchecked((int)0x0);
	|        public const int DownEnd = unchecked((int)0x0);
	|        public const int Home = unchecked((int)0x0);
	|#endif
	|        public const int KeyBackspace = unchecked((int)0x107);
	|        public const int KeyUp = unchecked((int)0x103);
	|        public const int KeyDown = unchecked((int)0x102);
	|        public const int KeyLeft = unchecked((int)0x104);
	|        public const int KeyRight = unchecked((int)0x105);
	|        public const int KeyNPage = unchecked((int)0x152);
	|        public const int KeyPPage = unchecked((int)0x153);
	|        public const int KeyHome = unchecked((int)0x106);
	|        public const int KeyMouse = unchecked((int)0x199);
	|        public const int KeyCSI = unchecked((int)0x5b);
	|        public const int KeySS3 = unchecked((int)0x4f);
	|        public const int KeyEnd = unchecked((int)0x168);
	|        public const int KeyDeleteChar = unchecked((int)0x14a);
	|        public const int KeyInsertChar = unchecked((int)0x14b);
	|        public const int KeyTab = unchecked((int)0x009);
	|        public const int KeyBackTab = unchecked((int)0x161);
	|        public const int KeyF1 = unchecked((int)0x109);
	|        public const int KeyF2 = unchecked((int)0x10a);
	|        public const int KeyF3 = unchecked((int)0x10b);
	|        public const int KeyF4 = unchecked((int)0x10c);
	|        public const int KeyF5 = unchecked((int)0x10d);
	|        public const int KeyF6 = unchecked((int)0x10e);
	|        public const int KeyF7 = unchecked((int)0x10f);
	|        public const int KeyF8 = unchecked((int)0x110);
	|        public const int KeyF9 = unchecked((int)0x111);
	|        public const int KeyF10 = unchecked((int)0x112);
	|        public const int KeyF11 = unchecked((int)0x113);
	|        public const int KeyF12 = unchecked((int)0x114);
	|        public const int KeyResize = unchecked((int)0x19a);
	|        public const int ShiftKeyUp = unchecked((int)0x151);
	|        public const int ShiftKeyDown = unchecked((int)0x150);
	|        public const int ShiftKeyLeft = unchecked((int)0x189);
	|        public const int ShiftKeyRight = unchecked((int)0x192);
	|        public const int ShiftKeyNPage = unchecked((int)0x18c);
	|        public const int ShiftKeyPPage = unchecked((int)0x18e);
	|        public const int ShiftKeyHome = unchecked((int)0x187);
	|        public const int ShiftKeyEnd = unchecked((int)0x182);
	|        public const int AltKeyUp = unchecked((int)0x234 + LeftRightUpNPagePPage);
	|        public const int AltKeyDown = unchecked((int)0x20b + DownEnd);
	|        public const int AltKeyLeft = unchecked((int)0x21f + LeftRightUpNPagePPage);
	|        public const int AltKeyRight = unchecked((int)0x22e + LeftRightUpNPagePPage);
	|        public const int AltKeyNPage = unchecked((int)0x224 + LeftRightUpNPagePPage);
	|        public const int AltKeyPPage = unchecked((int)0x229 + LeftRightUpNPagePPage);
	|        public const int AltKeyHome = unchecked((int)0x215 + Home);
	|        public const int AltKeyEnd = unchecked((int)0x210 + DownEnd);
	|        public const int CtrlKeyUp = unchecked((int)0x236 + LeftRightUpNPagePPage);
	|        public const int CtrlKeyDown = unchecked((int)0x20d + DownEnd);
	|        public const int CtrlKeyLeft = unchecked((int)0x221 + LeftRightUpNPagePPage);
	|        public const int CtrlKeyRight = unchecked((int)0x230 + LeftRightUpNPagePPage);
	|        public const int CtrlKeyNPage = unchecked((int)0x226 + LeftRightUpNPagePPage);
	|        public const int CtrlKeyPPage = unchecked((int)0x22b + LeftRightUpNPagePPage);
	|        public const int CtrlKeyHome = unchecked((int)0x217 + Home);
	|        public const int CtrlKeyEnd = unchecked((int)0x212 + DownEnd);
	|        public const int ShiftCtrlKeyUp = unchecked((int)0x237 + LeftRightUpNPagePPage);
	|        public const int ShiftCtrlKeyDown = unchecked((int)0x20e + DownEnd);
	|        public const int ShiftCtrlKeyLeft = unchecked((int)0x222 + LeftRightUpNPagePPage);
	|        public const int ShiftCtrlKeyRight = unchecked((int)0x231 + LeftRightUpNPagePPage);
	|        public const int ShiftCtrlKeyNPage = unchecked((int)0x227 + LeftRightUpNPagePPage);
	|        public const int ShiftCtrlKeyPPage = unchecked((int)0x22c + LeftRightUpNPagePPage);
	|        public const int ShiftCtrlKeyHome = unchecked((int)0x218 + Home);
	|        public const int ShiftCtrlKeyEnd = unchecked((int)0x213 + DownEnd);
	|        public const int ShiftAltKeyUp = unchecked((int)0x235 + LeftRightUpNPagePPage);
	|        public const int ShiftAltKeyDown = unchecked((int)0x20c + DownEnd);
	|        public const int ShiftAltKeyLeft = unchecked((int)0x220 + LeftRightUpNPagePPage);
	|        public const int ShiftAltKeyRight = unchecked((int)0x22f + LeftRightUpNPagePPage);
	|        public const int ShiftAltKeyNPage = unchecked((int)0x225 + LeftRightUpNPagePPage);
	|        public const int ShiftAltKeyPPage = unchecked((int)0x22a + LeftRightUpNPagePPage);
	|        public const int ShiftAltKeyHome = unchecked((int)0x216 + Home);
	|        public const int ShiftAltKeyEnd = unchecked((int)0x211 + DownEnd);
	|        public const int AltCtrlKeyNPage = unchecked((int)0x228 + LeftRightUpNPagePPage);
	|        public const int AltCtrlKeyPPage = unchecked((int)0x22d + LeftRightUpNPagePPage);
	|        public const int AltCtrlKeyHome = unchecked((int)0x219 + Home);
	|        public const int AltCtrlKeyEnd = unchecked((int)0x214 + DownEnd);
	|
	|        // see #949
	|        static public int LC_ALL { get; private set; }
	|        static Curses()
	|        {
	|            LC_ALL = System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.OSX) ? 0 : 6;
	|        }
	|
	|        static public int ColorPair(int n)
	|        {
	|            return 0 + n * 256;
	|        }
	|    }
	|#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	|    //=======================================================================
	|    //
	|    // handles.cs: OO wrappers for some curses objects
	|    //
	|    // Authors:
	|    //   Miguel de Icaza (miguel.de.icaza@gmail.com)
	|    //
	|    // Copyright (C) 2007 Novell (http://www.novell.com)
	|    //
	|    // Permission is hereby granted, free of charge, to any person obtaining
	|    // a copy of this software and associated documentation files (the
	|    // ""Software""), to deal in the Software without restriction, including
	|    // without limitation the rights to use, copy, modify, merge, publish,
	|    // distribute, sublicense, and/or sell copies of the Software, and to
	|    // permit persons to whom the Software is furnished to do so, subject to
	|    // the following conditions:
	|    // 
	|    // The above copyright notice and this permission notice shall be
	|    // included in all copies or substantial portions of the Software.
	|    // 
	|    // THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
	|    // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	|    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	|    // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	|    // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	|    // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	|    // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	|    //
	|
	|#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
	|    public partial class Curses
	|    {
	|        public class Window
	|        {
	|            public readonly IntPtr Handle;
	|            static Window curscr;
	|            static Window stdscr;
	|
	|            static Window()
	|            {
	|                Curses.initscr();
	|                stdscr = new Window(Curses.console_sharp_get_stdscr());
	|                curscr = new Window(Curses.console_sharp_get_curscr());
	|            }
	|
	|            internal Window(IntPtr handle)
	|            {
	|                Handle = handle;
	|            }
	|
	|            static public Window Standard
	|            {
	|                get
	|                {
	|                    return stdscr;
	|                }
	|            }
	|
	|            static public Window Current
	|            {
	|                get
	|                {
	|                    return curscr;
	|                }
	|            }
	|
	|
	|            public int wtimeout(int delay)
	|            {
	|                return Curses.wtimeout(Handle, delay);
	|            }
	|
	|            public int notimeout(bool bf)
	|            {
	|                return Curses.notimeout(Handle, bf);
	|            }
	|
	|            public int keypad(bool bf)
	|            {
	|                return Curses.keypad(Handle, bf);
	|            }
	|
	|            public int meta(bool bf)
	|            {
	|                return Curses.meta(Handle, bf);
	|            }
	|
	|            public int intrflush(bool bf)
	|            {
	|                return Curses.intrflush(Handle, bf);
	|            }
	|
	|            public int clearok(bool bf)
	|            {
	|                return Curses.clearok(Handle, bf);
	|            }
	|
	|            public int idlok(bool bf)
	|            {
	|                return Curses.idlok(Handle, bf);
	|            }
	|
	|            public void idcok(bool bf)
	|            {
	|                Curses.idcok(Handle, bf);
	|            }
	|
	|            public void immedok(bool bf)
	|            {
	|                Curses.immedok(Handle, bf);
	|            }
	|
	|            public int leaveok(bool bf)
	|            {
	|                return Curses.leaveok(Handle, bf);
	|            }
	|
	|            public int setscrreg(int top, int bot)
	|            {
	|                return Curses.wsetscrreg(Handle, top, bot);
	|            }
	|
	|            public int scrollok(bool bf)
	|            {
	|                return Curses.scrollok(Handle, bf);
	|            }
	|
	|            public int wrefresh()
	|            {
	|                return Curses.wrefresh(Handle);
	|            }
	|
	|            public int redrawwin()
	|            {
	|                return Curses.redrawwin(Handle);
	|            }
	|
	|#if false
	|			public int wredrawwin (int beg_line, int num_lines)
	|			{
	|				return Curses.wredrawwin (Handle, beg_line, num_lines);
	|			}
	|#endif
	|            public int wnoutrefresh()
	|            {
	|                return Curses.wnoutrefresh(Handle);
	|            }
	|
	|            public int move(int line, int col)
	|            {
	|                return Curses.wmove(Handle, line, col);
	|            }
	|
	|            public int addch(char ch)
	|            {
	|                return Curses.waddch(Handle, ch);
	|            }
	|
	|            public int refresh()
	|            {
	|                return Curses.wrefresh(Handle);
	|            }
	|        }
	|
	|        // Currently unused, to do later
	|        internal class Screen
	|        {
	|            public readonly IntPtr Handle;
	|
	|            internal Screen(IntPtr handle)
	|            {
	|                Handle = handle;
	|            }
	|        }
	|
	|#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	|    }
	|    //=======================================================================
	|    // Copyright 2015 gRPC authors.
	|    //
	|    // Licensed under the Apache License, Version 2.0 (the ""License"");
	|    // you may not use this file except in compliance with the License.
	|    // You may obtain a copy of the License at
	|    //
	|    //	 http://www.apache.org/licenses/LICENSE-2.0
	|    //
	|    // Unless required by applicable law or agreed to in writing, software
	|    // distributed under the License is distributed on an ""AS IS"" BASIS,
	|    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	|    // See the License for the specific language governing permissions and
	|    // limitations under the License.
	|    //#define GUICS
	|
	|    /// <summary>
	|    /// Represents a dynamically loaded unmanaged library in a (partially) platform independent manner.
	|    /// First, the native library is loaded using dlopen (on Unix systems) or using LoadLibrary (on Windows).
	|    /// dlsym or GetProcAddress are then used to obtain symbol addresses. <c>Marshal.GetDelegateForFunctionPointer</c>
	|    /// transforms the addresses into delegates to native methods.
	|    /// See http://stackoverflow.com/questions/13461989/p-invoke-to-dynamically-loaded-library-on-mono.
	|    /// </summary>
	|    internal class UnmanagedLibrary
	|    {
	|        const string UnityEngineApplicationClassName = ""UnityEngine.Application, UnityEngine"";
	|        const string XamarinAndroidObjectClassName = ""Java.Lang.Object, Mono.Android"";
	|        const string XamarinIOSObjectClassName = ""Foundation.NSObject, Xamarin.iOS"";
	|        static bool IsWindows, IsLinux, IsMacOS;
	|        static bool Is64Bit;
	|#if GUICS
	|        static bool IsMono;
	|#else
	|        static bool IsMono, IsUnity, IsXamarinIOS, IsXamarinAndroid, IsXamarin;
	|#endif
	|        static bool IsNetCore;
	|
	|        public static bool IsMacOSPlatform => IsMacOS;
	|
	|        [DllImport(""libc"")]
	|        static extern int uname(IntPtr buf);
	|
	|        static string GetUname()
	|        {
	|            var buffer = Marshal.AllocHGlobal(8192);
	|            try
	|            {
	|                if (uname(buffer) == 0)
	|                {
	|                    return Marshal.PtrToStringAnsi(buffer);
	|                }
	|                return string.Empty;
	|            }
	|            catch
	|            {
	|                return string.Empty;
	|            }
	|            finally
	|            {
	|                if (buffer != IntPtr.Zero)
	|                {
	|                    Marshal.FreeHGlobal(buffer);
	|                }
	|            }
	|        }
	|
	|        static UnmanagedLibrary()
	|        {
	|            var platform = Environment.OSVersion.Platform;
	|
	|            IsMacOS = (platform == PlatformID.Unix && GetUname() == ""Darwin"");
	|            IsLinux = (platform == PlatformID.Unix && !IsMacOS);
	|            IsWindows = (platform == PlatformID.Win32NT || platform == PlatformID.Win32S || platform == PlatformID.Win32Windows);
	|            Is64Bit = Marshal.SizeOf(typeof(IntPtr)) == 8;
	|            IsMono = Type.GetType(""Mono.Runtime"") != null;
	|            if (!IsMono)
	|            {
	|                IsNetCore = Type.GetType(""System.MathF"") != null;
	|            }
	|#if GUICS
	|            //IsUnity = IsXamarinIOS = IsXamarinAndroid = IsXamarin = false;
	|#else
	|            IsUnity = Type.GetType(UnityEngineApplicationClassName) != null;
	|            IsXamarinIOS = Type.GetType(XamarinIOSObjectClassName) != null;
	|            IsXamarinAndroid = Type.GetType(XamarinAndroidObjectClassName) != null;
	|            IsXamarin = IsXamarinIOS || IsXamarinAndroid;
	|#endif
	|
	|        }
	|
	|        // flags for dlopen
	|        const int RTLD_LAZY = 1;
	|        const int RTLD_GLOBAL = 8;
	|
	|        readonly string libraryPath;
	|        readonly IntPtr handle;
	|
	|        public IntPtr NativeLibraryHandle => handle;
	|
	|        //
	|        // if isFullPath is set to true, the provided array of libraries are full paths
	|        // and are tested for the file existing, otherwise the file is merely the name
	|        // of the shared library that we pass to dlopen
	|        //
	|        public UnmanagedLibrary(string[] libraryPathAlternatives, bool isFullPath)
	|        {
	|            if (isFullPath)
	|            {
	|                this.libraryPath = FirstValidLibraryPath(libraryPathAlternatives);
	|                this.handle = PlatformSpecificLoadLibrary(this.libraryPath);
	|            }
	|            else
	|            {
	|                foreach (var lib in libraryPathAlternatives)
	|                {
	|                    this.handle = PlatformSpecificLoadLibrary(lib);
	|                    if (this.handle != IntPtr.Zero)
	|                        break;
	|                }
	|            }
	|
	|            if (this.handle == IntPtr.Zero)
	|            {
	|                throw new IOException($""Error loading native library \""{string.Join("", "", libraryPathAlternatives)}\"""");
	|            }
	|        }
	|
	|        /// <summary>
	|        /// Loads symbol in a platform specific way.
	|        /// </summary>
	|        /// <param name=""symbolName""></param>
	|        /// <returns></returns>
	|        public IntPtr LoadSymbol(string symbolName)
	|        {
	|            if (IsWindows)
	|            {
	|                // See http://stackoverflow.com/questions/10473310 for background on this.
	|                if (Is64Bit)
	|                {
	|                    return Windows.GetProcAddress(this.handle, symbolName);
	|                }
	|                else
	|                {
	|                    // Yes, we could potentially predict the size... but it's a lot simpler to just try
	|                    // all the candidates. Most functions have a suffix of @0, @4 or @8 so we won't be trying
	|                    // many options - and if it takes a little bit longer to fail if we've really got the wrong
	|                    // library, that's not a big problem. This is only called once per function in the native library.
	|                    symbolName = ""_"" + symbolName + ""@"";
	|                    for (int stackSize = 0; stackSize < 128; stackSize += 4)
	|                    {
	|                        IntPtr candidate = Windows.GetProcAddress(this.handle, symbolName + stackSize);
	|                        if (candidate != IntPtr.Zero)
	|                        {
	|                            return candidate;
	|                        }
	|                    }
	|                    // Fail.
	|                    return IntPtr.Zero;
	|                }
	|            }
	|            if (IsLinux)
	|            {
	|                if (IsMono)
	|                {
	|                    return Mono.dlsym(this.handle, symbolName);
	|                }
	|                if (IsNetCore)
	|                {
	|                    return CoreCLR.dlsym(this.handle, symbolName);
	|                }
	|                return Linux.dlsym(this.handle, symbolName);
	|            }
	|            if (IsMacOS)
	|            {
	|                return MacOSX.dlsym(this.handle, symbolName);
	|            }
	|            throw new InvalidOperationException(""Unsupported platform."");
	|        }
	|
	|        public T GetNativeMethodDelegate<T>(string methodName)
	|            where T : class
	|        {
	|            var ptr = LoadSymbol(methodName);
	|            if (ptr == IntPtr.Zero)
	|            {
	|                throw new MissingMethodException(string.Format(""The native method \""{0}\"" does not exist"", methodName));
	|            }
	|            return Marshal.GetDelegateForFunctionPointer<T>(ptr);  // non-generic version is obsolete
	|        }
	|
	|        /// <summary>
	|        /// Loads library in a platform specific way.
	|        /// </summary>
	|        static IntPtr PlatformSpecificLoadLibrary(string libraryPath)
	|        {
	|            if (IsWindows)
	|            {
	|                return Windows.LoadLibrary(libraryPath);
	|            }
	|            if (IsLinux)
	|            {
	|                if (IsMono)
	|                {
	|                    return Mono.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
	|                }
	|                if (IsNetCore)
	|                {
	|                    try
	|                    {
	|                        return CoreCLR.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
	|                    }
	|                    catch (Exception)
	|                    {
	|
	|                        IsNetCore = false;
	|                    }
	|                }
	|                return Linux.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
	|            }
	|            if (IsMacOS)
	|            {
	|                return MacOSX.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
	|            }
	|            throw new InvalidOperationException(""Unsupported platform."");
	|        }
	|
	|        static string FirstValidLibraryPath(string[] libraryPathAlternatives)
	|        {
	|            foreach (var path in libraryPathAlternatives)
	|            {
	|                if (File.Exists(path))
	|                {
	|                    return path;
	|                }
	|            }
	|            throw new FileNotFoundException(
	|                String.Format(""Error loading native library. Not found in any of the possible locations: {0}"",
	|                string.Join("","", libraryPathAlternatives)));
	|        }
	|
	|        static class Windows
	|        {
	|            [DllImport(""kernel32.dll"")]
	|            internal static extern IntPtr LoadLibrary(string filename);
	|
	|            [DllImport(""kernel32.dll"")]
	|            internal static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
	|        }
	|
	|        static class Linux
	|        {
	|            [DllImport(""libdl.so"")]
	|            internal static extern IntPtr dlopen(string filename, int flags);
	|
	|            [DllImport(""libdl.so"")]
	|            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
	|        }
	|
	|        static class MacOSX
	|        {
	|            [DllImport(""libSystem.dylib"")]
	|            internal static extern IntPtr dlopen(string filename, int flags);
	|
	|            [DllImport(""libSystem.dylib"")]
	|            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
	|        }
	|
	|        /// <summary>
	|        /// On Linux systems, using using dlopen and dlsym results in
	|        /// DllNotFoundException(""libdl.so not found"") if libc6-dev
	|        /// is not installed. As a workaround, we load symbols for
	|        /// dlopen and dlsym from the current process as on Linux
	|        /// Mono sure is linked against these symbols.
	|        /// </summary>
	|        static class Mono
	|        {
	|            [DllImport(""__Internal"")]
	|            internal static extern IntPtr dlopen(string filename, int flags);
	|
	|            [DllImport(""__Internal"")]
	|            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
	|        }
	|
	|        /// <summary>
	|        /// Similarly as for Mono on Linux, we load symbols for
	|        /// dlopen and dlsym from the ""libcoreclr.so"",
	|        /// to avoid the dependency on libc-dev Linux.
	|        /// </summary>
	|        static class CoreCLR
	|        {
	|#if NET6_0_OR_GREATER
	|			// Custom resolver to support true single-file apps
	|			// (those which run directly from bundle; in-memory).
	|			//	 -1 on Unix means self-referencing binary (libcoreclr.so)
	|			//	 0 means fallback to CoreCLR's internal resolution
	|			// Note: meaning of -1 stay the same even for non-single-file form factors.
	|			static CoreCLR() =>  NativeLibrary.SetDllImportResolver(typeof(CoreCLR).Assembly,
	|				(string libraryName, Assembly assembly, DllImportSearchPath? searchPath) =>
	|					libraryName == ""libcoreclr.so"" ? (IntPtr)(-1) : IntPtr.Zero);
	|#endif
	|            [DllImport(""libcoreclr.so"")]
	|            internal static extern IntPtr dlopen(string filename, int flags);
	|
	|            [DllImport(""libcoreclr.so"")]
	|            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
	|        }
	|    }
	|}//namespace Unix.Terminal
	|//=======================================================================
	|//------------------------------------------------------------------------------
	|// <auto-generated>
	|//     This code was generated by a tool.
	|//     Runtime Version:4.0.30319.42000
	|//
	|//     Changes to this file may cause incorrect behavior and will be lost if
	|//     the code is regenerated.
	|// </auto-generated>
	|//------------------------------------------------------------------------------
	|
	|namespace Terminal.Gui.Resources
	|{
	|    /// <summary>
	|    ///   A strongly-typed resource class, for looking up localized strings, etc.
	|    /// </summary>
	|    // This class was auto-generated by the StronglyTypedResourceBuilder
	|    // class via a tool like ResGen or Visual Studio.
	|    // To add or remove a member, edit your .ResX file then rerun ResGen
	|    // with the /str option, or rebuild your VS project.
	|    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""System.Resources.Tools.StronglyTypedResourceBuilder"", ""17.0.0.0"")]
	|    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
	|    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
	|    internal class Strings
	|    {
	|
	|        private static global::System.Resources.ResourceManager resourceMan;
	|
	|        private static global::System.Globalization.CultureInfo resourceCulture;
	|
	|        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(""Microsoft.Performance"", ""CA1811:AvoidUncalledPrivateCode"")]
	|        internal Strings()
	|        {
	|        }
	|
	|        /// <summary>
	|        ///   Returns the cached ResourceManager instance used by this class.
	|        /// </summary>
	|        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
	|        internal static global::System.Resources.ResourceManager ResourceManager
	|        {
	|            get
	|            {
	|                if (object.ReferenceEquals(resourceMan, null))
	|                {
	|                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(""Terminal.Gui.Resources.Strings"", typeof(Strings).Assembly);
	|                    resourceMan = temp;
	|                }
	|                return resourceMan;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Overrides the current thread's CurrentUICulture property for all
	|        ///   resource lookups using this strongly typed resource class.
	|        /// </summary>
	|        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
	|        internal static global::System.Globalization.CultureInfo Culture
	|        {
	|            get
	|            {
	|                return resourceCulture;
	|            }
	|            set
	|            {
	|                resourceCulture = value;
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Copy.
	|        /// </summary>
	|        internal static string ctxCopy
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""ctxCopy"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Cu_t.
	|        /// </summary>
	|        internal static string ctxCut
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""ctxCut"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Delete All.
	|        /// </summary>
	|        internal static string ctxDeleteAll
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""ctxDeleteAll"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Paste.
	|        /// </summary>
	|        internal static string ctxPaste
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""ctxPaste"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Redo.
	|        /// </summary>
	|        internal static string ctxRedo
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""ctxRedo"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Select All.
	|        /// </summary>
	|        internal static string ctxSelectAll
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""ctxSelectAll"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Undo.
	|        /// </summary>
	|        internal static string ctxUndo
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""ctxUndo"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Directory.
	|        /// </summary>
	|        internal static string fdDirectory
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""fdDirectory"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to File.
	|        /// </summary>
	|        internal static string fdFile
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""fdFile"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Open.
	|        /// </summary>
	|        internal static string fdOpen
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""fdOpen"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Save.
	|        /// </summary>
	|        internal static string fdSave
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""fdSave"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Save as.
	|        /// </summary>
	|        internal static string fdSaveAs
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""fdSaveAs"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Select folder.
	|        /// </summary>
	|        internal static string fdSelectFolder
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""fdSelectFolder"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Select Mixed.
	|        /// </summary>
	|        internal static string fdSelectMixed
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""fdSelectMixed"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Back.
	|        /// </summary>
	|        internal static string wzBack
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""wzBack"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to Fi_nish.
	|        /// </summary>
	|        internal static string wzFinish
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""wzFinish"", resourceCulture);
	|            }
	|        }
	|
	|        /// <summary>
	|        ///   Looks up a localized string similar to _Next....
	|        /// </summary>
	|        internal static string wzNext
	|        {
	|            get
	|            {
	|                return ResourceManager.GetString(""wzNext"", resourceCulture);
	|            }
	|        }
	|    }
	|}//namespace Terminal.Gui.Resources
	|";
	ТекстДокХХХ = Новый ТекстовыйДокумент;
	ТекстДокХХХ.УстановитьТекст(СтрФайла);
	ТекстДокХХХ.Записать(КаталогВыгрузки + "\TuiSupport.cs");
КонецПроцедуры//СоздатьФайлТФ

КаталогСправки = "C:\444\OneScriptTerminalGui\docs\OSTGui";// без слэша в конце
КаталогВыгрузки = "C:\444\ВыгрузкаTUI";// без слэша в конце
СписокНеизменныхКлассов = Новый СписокЗначений();

ВыгрузкаTUI();
