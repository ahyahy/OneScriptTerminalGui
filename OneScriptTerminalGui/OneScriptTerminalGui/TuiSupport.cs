using NStack;
using Rune = System.Rune;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Management;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System;
using Terminal.Gui.Graphs;
using Terminal.Gui.Resources;
using Terminal.Gui.TextValidateProviders;
using Terminal.Gui.Trees;
using Terminal.Gui;
using Unix.Terminal;
using static Terminal.Gui.Graphs.PathAnnotation;
//// Alias Console to MockConsole so we don't accidentally use Console
//using Console = Terminal.Gui.FakeConsole;

//=======================================================================
namespace Terminal.Gui.Graphs
{
    /// <summary>
    /// <para>Describes an overlay element that is rendered either before or
    /// after a series.</para>
    /// 
    /// <para>Annotations can be positioned either in screen space (e.g.
    /// a legend) or in graph space (e.g. a line showing high point)
    /// </para>
    /// <para>Unlike <see cref="ISeries"/>, annotations are allowed to
    /// draw into graph margins
    /// </para>
    /// </summary>
    public interface IAnnotation
    {
        /// <summary>
        /// True if annotation should be drawn before <see cref="ISeries"/>.  This
        /// allowes Series and later annotations to potentially draw over the top
        /// of this annotation.
        /// </summary>
        bool BeforeSeries { get; }

        /// <summary>
        /// Called once after series have been rendered (or before if <see cref="BeforeSeries"/> is true).
        /// Use <see cref="View.Driver"/> to draw and <see cref="View.Bounds"/> to avoid drawing outside of
        /// graph
        /// </summary>
        /// <param name="graph"></param>
        void Render(GraphView graph);
    }


    /// <summary>
    /// Displays text at a given position (in screen space or graph space)
    /// </summary>
    public class TextAnnotation : IAnnotation
    {

        /// <summary>
        /// The location on screen to draw the <see cref="Text"/> regardless
        /// of scroll/zoom settings.  This overrides <see cref="GraphPosition"/>
        /// if specified.
        /// </summary>
        public Point? ScreenPosition { get; set; }

        /// <summary>
        /// The location in graph space to draw the <see cref="Text"/>.  This
        /// annotation will only show if the point is in the current viewable
        /// area of the graph presented in the <see cref="GraphView"/>
        /// </summary>
        public PointF GraphPosition { get; set; }

        /// <summary>
        /// Text to display on the graph
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// True to add text before plotting series.  Defaults to false
        /// </summary>
        public bool BeforeSeries { get; set; }

        /// <summary>
        /// Draws the annotation
        /// </summary>
        /// <param name="graph"></param>
        public void Render(GraphView graph)
        {
            if (ScreenPosition.HasValue)
            {
                DrawText(graph, ScreenPosition.Value.X, ScreenPosition.Value.Y);
                return;
            }

            var screenPos = graph.GraphSpaceToScreen(GraphPosition);
            DrawText(graph, screenPos.X, screenPos.Y);
        }

        /// <summary>
        /// Draws the <see cref="Text"/> at the given coordinates with truncation to avoid
        /// spilling over <see name="View.Bounds"/> of the <paramref name="graph"/>
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="x">Screen x position to start drawing string</param>
        /// <param name="y">Screen y position to start drawing string</param>
        protected void DrawText(GraphView graph, int x, int y)
        {
            // the draw point is out of control bounds
            if (!graph.Bounds.Contains(new Point(x, y)))
            {
                return;
            }

            // There is no text to draw
            if (string.IsNullOrWhiteSpace(Text))
            {
                return;
            }

            graph.Move(x, y);

            int availableWidth = graph.Bounds.Width - x;

            if (availableWidth <= 0)
            {
                return;
            }

            if (Text.Length < availableWidth)
            {
                View.Driver.AddStr(Text);
            }
            else
            {
                View.Driver.AddStr(Text.Substring(0, availableWidth));
            }
        }
    }

    /// <summary>
    /// A box containing symbol definitions e.g. meanings for colors in a graph.
    /// The 'Key' to the graph
    /// </summary>
    public class LegendAnnotation : IAnnotation
    {

        /// <summary>
        /// True to draw a solid border around the legend.
        /// Defaults to true.  This border will be within the
        /// <see cref="Bounds"/> and so reduces the width/height
        /// available for text by 2
        /// </summary>
        public bool Border { get; set; } = true;

        /// <summary>
        /// Defines the screen area available for the legend to render in
        /// </summary>
        public Rect Bounds { get; set; }

        /// <summary>
        /// Returns false i.e. Lengends render after series
        /// </summary>
        public bool BeforeSeries => false;

        /// <summary>
        /// Ordered collection of entries that are rendered in the legend.
        /// </summary>
        List<Tuple<GraphCellToRender, string>> entries = new List<Tuple<GraphCellToRender, string>>();

        /// <summary>
        /// Creates a new empty legend at the given screen coordinates
        /// </summary>
        /// <param name="legendBounds">Defines the area available for the legend to render in
        /// (within the graph).  This is in screen units (i.e. not graph space)</param>
        public LegendAnnotation(Rect legendBounds)
        {
            Bounds = legendBounds;
        }

        /// <summary>
        /// Draws the Legend and all entries into the area within <see cref="Bounds"/>
        /// </summary>
        /// <param name="graph"></param>
        public void Render(GraphView graph)
        {
            if (Border)
            {
                graph.DrawFrame(Bounds, 0, true);
            }

            // start the legend at
            int y = Bounds.Top + (Border ? 1 : 0);
            int x = Bounds.Left + (Border ? 1 : 0);

            // how much horizontal space is available for writing legend entries?
            int availableWidth = Bounds.Width - (Border ? 2 : 0);
            int availableHeight = Bounds.Height - (Border ? 2 : 0);

            int linesDrawn = 0;

            foreach (var entry in entries)
            {

                if (entry.Item1.Color.HasValue)
                {
                    Application.Driver.SetAttribute(entry.Item1.Color.Value);
                }
                else
                {
                    graph.SetDriverColorToGraphColor();
                }

                // add the symbol
                graph.AddRune(x, y + linesDrawn, entry.Item1.Rune);

                // switch to normal coloring (for the text)
                graph.SetDriverColorToGraphColor();

                // add the text
                graph.Move(x + 1, y + linesDrawn);

                string str = TextFormatter.ClipOrPad(entry.Item2, availableWidth - 1);
                Application.Driver.AddStr(str);

                linesDrawn++;

                // Legend has run out of space
                if (linesDrawn >= availableHeight)
                {
                    break;
                }
            }
        }


        /// <summary>
        /// Adds an entry into the legend.  Duplicate entries are permissable
        /// </summary>
        /// <param name="graphCellToRender">The symbol appearing on the graph that should appear in the legend</param>
        /// <param name="text">Text to render on this line of the legend.  Will be truncated
        /// if outside of Legend <see cref="Bounds"/></param>
        public void AddEntry(GraphCellToRender graphCellToRender, string text)
        {
            entries.Add(Tuple.Create(graphCellToRender, text));
        }
    }

    /// <summary>
    /// Sequence of lines to connect points e.g. of a <see cref="ScatterSeries"/>
    /// </summary>
    public class PathAnnotation : IAnnotation
    {

        /// <summary>
        /// Points that should be connected.  Lines will be drawn between points in the order
        /// they appear in the list
        /// </summary>
        public List<PointF> Points { get; set; } = new List<PointF>();

        /// <summary>
        /// Color for the line that connects points
        /// </summary>
        public Attribute? LineColor { get; set; }

        /// <summary>
        /// The symbol that gets drawn along the line, defaults to '.'
        /// </summary>
        public Rune LineRune { get; set; } = new Rune('.');

        /// <summary>
        /// True to add line before plotting series.  Defaults to false
        /// </summary>
        public bool BeforeSeries { get; set; }


        /// <summary>
        /// Draws lines connecting each of the <see cref="Points"/>
        /// </summary>
        /// <param name="graph"></param>
        public void Render(GraphView graph)
        {
            View.Driver.SetAttribute(LineColor ?? graph.ColorScheme.Normal);

            foreach (var line in PointsToLines())
            {

                var start = graph.GraphSpaceToScreen(line.Start);
                var end = graph.GraphSpaceToScreen(line.End);
                graph.DrawLine(start, end, LineRune);
            }
        }

        /// <summary>
        /// Generates lines joining <see cref="Points"/> 
        /// </summary>
        /// <returns></returns>
        private IEnumerable<LineF> PointsToLines()
        {
            for (int i = 0; i < Points.Count - 1; i++)
            {
                yield return new LineF(Points[i], Points[i + 1]);
            }
        }

        /// <summary>
        /// Describes two points in graph space and a line between them
        /// </summary>
        public class LineF
        {
            /// <summary>
            /// The start of the line
            /// </summary>
            public PointF Start { get; }

            /// <summary>
            /// The end point of the line
            /// </summary>
            public PointF End { get; }

            /// <summary>
            /// Creates a new line between the points
            /// </summary>
            public LineF(PointF start, PointF end)
            {
                this.Start = start;
                this.End = end;
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Renders a continuous line with grid line ticks and labels
    /// </summary>
    public abstract class Axis
    {
        /// <summary>
        /// Default value for <see cref="ShowLabelsEvery"/>
        /// </summary>
        const uint DefaultShowLabelsEvery = 5;

        /// <summary>
        /// Direction of the axis
        /// </summary>
        /// <value></value>
        public Orientation Orientation { get; }

        /// <summary>
        /// Number of units of graph space between ticks on axis. 0 for no ticks
        /// </summary>
        /// <value></value>
        public float Increment { get; set; } = 1;

        /// <summary>
        /// The number of <see cref="Increment"/> before an label is added.
        /// 0 = never show labels
        /// </summary>
        public uint ShowLabelsEvery { get; set; } = DefaultShowLabelsEvery;

        /// <summary>
        /// True to render axis.  Defaults to true
        /// </summary>
        public bool Visible { get; set; } = true;

        /// <summary>
        /// Allows you to control what label text is rendered for a given <see cref="Increment"/>
        /// when <see cref="ShowLabelsEvery"/> is above 0
        /// </summary>
        public LabelGetterDelegate LabelGetter;

        /// <summary>
        /// Displayed below/to left of labels (see <see cref="Orientation"/>).
        /// If text is not visible, check <see cref="GraphView.MarginBottom"/> / <see cref="GraphView.MarginLeft"/>
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// The minimum axis point to show.  Defaults to null (no minimum)
        /// </summary>
        public float? Minimum { get; set; }

        /// <summary>
        /// Populates base properties and sets the read only <see cref="Orientation"/>
        /// </summary>
        /// <param name="orientation"></param>
        protected Axis(Orientation orientation)
        {
            Orientation = orientation;
            LabelGetter = DefaultLabelGetter;
        }

        /// <summary>
        /// Draws the solid line of the axis
        /// </summary>
        /// <param name="graph"></param>
        public abstract void DrawAxisLine(GraphView graph);

        /// <summary>
        /// Draws a single cell of the solid line of the axis
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        protected abstract void DrawAxisLine(GraphView graph, int x, int y);

        /// <summary>
        /// Draws labels and axis <see cref="Increment"/> ticks
        /// </summary>
        /// <param name="graph"></param>

        public abstract void DrawAxisLabels(GraphView graph);

        /// <summary>
        /// Draws a custom label <paramref name="text"/> at <paramref name="screenPosition"/> units
        /// along the axis (X or Y depending on <see cref="Orientation"/>)
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="screenPosition"></param>
        /// <param name="text"></param>
        public abstract void DrawAxisLabel(GraphView graph, int screenPosition, string text);

        /// <summary>
        /// Resets all configurable properties of the axis to default values
        /// </summary>
        public virtual void Reset()
        {
            Increment = 1;
            ShowLabelsEvery = DefaultShowLabelsEvery;
            Visible = true;
            Text = "";
            LabelGetter = DefaultLabelGetter;
            Minimum = null;
        }

        private string DefaultLabelGetter(AxisIncrementToRender toRender)
        {
            return toRender.Value.ToString("N0");
        }
    }

    /// <summary>
    /// The horizontal (x axis) of a <see cref="GraphView"/>
    /// </summary>
    public class HorizontalAxis : Axis
    {

        /// <summary>
        /// Creates a new instance of axis with an <see cref="Orientation"/> of <see cref="Orientation.Horizontal"/>
        /// </summary>
        public HorizontalAxis() : base(Orientation.Horizontal)
        {
        }


        /// <summary>
        /// Draws the horizontal axis line
        /// </summary>
        /// <param name="graph"></param>
        public override void DrawAxisLine(GraphView graph)
        {
            if (!Visible)
            {
                return;
            }
            var bounds = graph.Bounds;

            graph.Move(0, 0);

            var y = GetAxisYPosition(graph);

            // start the x axis at left of screen (either 0 or margin)
            var xStart = (int)graph.MarginLeft;

            // but if the x axis has a minmum (minimum is in graph space units)
            if (Minimum.HasValue)
            {

                // start at the screen location of the minimum
                var minimumScreenX = graph.GraphSpaceToScreen(new PointF(Minimum.Value, y)).X;

                // unless that is off the screen to the left
                xStart = Math.Max(xStart, minimumScreenX);
            }

            for (int i = xStart; i < bounds.Width; i++)
            {

                DrawAxisLine(graph, i, y);
            }
        }


        /// <summary>
        /// Draws a horizontal axis line at the given <paramref name="x"/>, <paramref name="y"/> 
        /// screen coordinates
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        protected override void DrawAxisLine(GraphView graph, int x, int y)
        {
            graph.Move(x, y);
            Application.Driver.AddRune(Application.Driver.HLine);
        }

        /// <summary>
        /// Draws the horizontal x axis labels and <see cref="Axis.Increment"/> ticks
        /// </summary>
        public override void DrawAxisLabels(GraphView graph)
        {
            if (!Visible || Increment == 0)
            {
                return;
            }

            var bounds = graph.Bounds;

            var labels = GetLabels(graph, bounds);

            foreach (var label in labels)
            {
                DrawAxisLabel(graph, label.ScreenLocation, label.Text);
            }

            // if there is a title
            if (!string.IsNullOrWhiteSpace(Text))
            {

                string toRender = Text;

                // if label is too long
                if (toRender.Length > graph.Bounds.Width)
                {
                    toRender = toRender.Substring(0, graph.Bounds.Width);
                }

                graph.Move(graph.Bounds.Width / 2 - (toRender.Length / 2), graph.Bounds.Height - 1);
                Application.Driver.AddStr(toRender);
            }
        }

        /// <summary>
        /// Draws the given <paramref name="text"/> on the axis at x <paramref name="screenPosition"/>.
        /// For the screen y position use <see cref="GetAxisYPosition(GraphView)"/>
        /// </summary>
        /// <param name="graph">Graph being drawn onto</param>
        /// <param name="screenPosition">Number of screen columns along the axis to take before rendering</param>
        /// <param name="text">Text to render under the axis tick</param>
        public override void DrawAxisLabel(GraphView graph, int screenPosition, string text)
        {
            var driver = Application.Driver;
            var y = GetAxisYPosition(graph);

            graph.Move(screenPosition, y);

            // draw the tick on the axis
            driver.AddRune(driver.TopTee);

            // and the label text
            if (!string.IsNullOrWhiteSpace(text))
            {

                // center the label but don't draw it outside bounds of the graph
                int drawAtX = Math.Max(0, screenPosition - (text.Length / 2));
                string toRender = text;

                // this is how much space is left
                int xSpaceAvailable = graph.Bounds.Width - drawAtX;

                // There is no space for the label at all!
                if (xSpaceAvailable <= 0)
                {
                    return;
                }

                // if we are close to right side of graph, don't overspill
                if (toRender.Length > xSpaceAvailable)
                {
                    toRender = toRender.Substring(0, xSpaceAvailable);
                }

                graph.Move(drawAtX, Math.Min(y + 1, graph.Bounds.Height - 1));
                driver.AddStr(toRender);
            }
        }

        private IEnumerable<AxisIncrementToRender> GetLabels(GraphView graph, Rect bounds)
        {
            // if no labels
            if (Increment == 0)
            {
                yield break;
            }

            int labels = 0;
            int y = GetAxisYPosition(graph);

            var start = graph.ScreenToGraphSpace((int)graph.MarginLeft, y);
            var end = graph.ScreenToGraphSpace(bounds.Width, y);

            // don't draw labels below the minimum
            if (Minimum.HasValue)
            {
                start.X = Math.Max(start.X, Minimum.Value);
            }

            var current = start;

            while (current.X < end.X)
            {

                int screenX = graph.GraphSpaceToScreen(new PointF(current.X, current.Y)).X;

                // The increment we will render (normally a top T unicode symbol)
                var toRender = new AxisIncrementToRender(Orientation, screenX, current.X);

                // Not every increment has to have a label
                if (ShowLabelsEvery != 0)
                {

                    // if this increment does also needs a label
                    if (labels++ % ShowLabelsEvery == 0)
                    {
                        toRender.Text = LabelGetter(toRender);
                    };
                }

                // Label or no label definetly render it
                yield return toRender;


                current.X += Increment;
            }
        }
        /// <summary>
        /// Returns the Y screen position of the origin (typically 0,0) of graph space.
        /// Return value is bounded by the screen i.e. the axis is always rendered even
        /// if the origin is offscreen.
        /// </summary>
        /// <param name="graph"></param>
        public int GetAxisYPosition(GraphView graph)
        {
            // find the origin of the graph in screen space (this allows for 'crosshair' style
            // graphs where positive and negative numbers visible
            var origin = graph.GraphSpaceToScreen(new PointF(0, 0));

            // float the X axis so that it accurately represents the origin of the graph
            // but anchor it to top/bottom if the origin is offscreen
            return Math.Min(Math.Max(0, origin.Y), graph.Bounds.Height - ((int)graph.MarginBottom + 1));
        }
    }

    /// <summary>
    /// The vertical (i.e. Y axis) of a <see cref="GraphView"/>
    /// </summary>
    public class VerticalAxis : Axis
    {


        /// <summary>
        /// Creates a new <see cref="Orientation.Vertical"/> axis
        /// </summary>
        public VerticalAxis() : base(Orientation.Vertical)
        {
        }

        /// <summary>
        /// Draws the vertical axis line
        /// </summary>
        /// <param name="graph"></param>
        public override void DrawAxisLine(GraphView graph)
        {
            if (!Visible)
            {
                return;
            }
            Rect bounds = graph.Bounds;

            var x = GetAxisXPosition(graph);

            var yEnd = GetAxisYEnd(graph);

            // don't draw down further than the control bounds
            yEnd = Math.Min(yEnd, bounds.Height - (int)graph.MarginBottom);

            // Draw solid line
            for (int i = 0; i < yEnd; i++)
            {

                DrawAxisLine(graph, x, i);
            }
        }

        /// <summary>
        /// Draws a vertical axis line at the given <paramref name="x"/>, <paramref name="y"/> 
        /// screen coordinates
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        protected override void DrawAxisLine(GraphView graph, int x, int y)
        {
            graph.Move(x, y);
            Application.Driver.AddRune(Application.Driver.VLine);
        }

        private int GetAxisYEnd(GraphView graph)
        {
            // draw down the screen (0 is top of screen)
            // end at the bottom of the screen

            //unless there is a minimum 
            if (Minimum.HasValue)
            {
                return graph.GraphSpaceToScreen(new PointF(0, Minimum.Value)).Y;
            }

            return graph.Bounds.Height;
        }


        /// <summary>
        /// Draws axis <see cref="Axis.Increment"/> markers and labels
        /// </summary>
        /// <param name="graph"></param>
        public override void DrawAxisLabels(GraphView graph)
        {
            if (!Visible || Increment == 0)
            {
                return;
            }

            var bounds = graph.Bounds;
            var labels = GetLabels(graph, bounds);

            foreach (var label in labels)
            {

                DrawAxisLabel(graph, label.ScreenLocation, label.Text);
            }

            // if there is a title
            if (!string.IsNullOrWhiteSpace(Text))
            {

                string toRender = Text;

                // if label is too long
                if (toRender.Length > graph.Bounds.Height)
                {
                    toRender = toRender.Substring(0, graph.Bounds.Height);
                }

                // Draw it 1 letter at a time vertically down row 0 of the control
                int startDrawingAtY = graph.Bounds.Height / 2 - (toRender.Length / 2);

                for (int i = 0; i < toRender.Length; i++)
                {

                    graph.Move(0, startDrawingAtY + i);
                    Application.Driver.AddRune(toRender[i]);
                }

            }
        }

        private IEnumerable<AxisIncrementToRender> GetLabels(GraphView graph, Rect bounds)
        {
            // if no labels
            if (Increment == 0)
            {
                yield break;
            }

            int labels = 0;
            int x = GetAxisXPosition(graph);

            // remember screen space is top down so the lowest graph
            // space value is at the bottom of the screen
            var start = graph.ScreenToGraphSpace(x, bounds.Height - (1 + (int)graph.MarginBottom));
            var end = graph.ScreenToGraphSpace(x, 0);

            // don't draw labels below the minimum
            if (Minimum.HasValue)
            {
                start.Y = Math.Max(start.Y, Minimum.Value);
            }

            var current = start;

            while (current.Y < end.Y)
            {

                int screenY = graph.GraphSpaceToScreen(new PointF(current.X, current.Y)).Y;

                // Create the axis symbol
                var toRender = new AxisIncrementToRender(Orientation, screenY, current.Y);

                // and the label (if we are due one)
                if (ShowLabelsEvery != 0)
                {

                    // if this increment also needs a label
                    if (labels++ % ShowLabelsEvery == 0)
                    {
                        toRender.Text = LabelGetter(toRender);
                    };
                }

                // draw the axis symbol (and label if it has one)
                yield return toRender;


                current.Y += Increment;
            }
        }

        /// <summary>
        /// Draws the given <paramref name="text"/> on the axis at y <paramref name="screenPosition"/>.
        /// For the screen x position use <see cref="GetAxisXPosition(GraphView)"/>
        /// </summary>
        /// <param name="graph">Graph being drawn onto</param>
        /// <param name="screenPosition">Number of rows from the top of the screen (i.e. down the axis) before rendering</param>
        /// <param name="text">Text to render to the left of the axis tick.  Ensure to 
        /// set <see cref="GraphView.MarginLeft"/> or <see cref="GraphView.ScrollOffset"/> sufficient that it is visible</param>
        public override void DrawAxisLabel(GraphView graph, int screenPosition, string text)
        {
            var x = GetAxisXPosition(graph);
            var labelThickness = text.Length;

            graph.Move(x, screenPosition);

            // draw the tick on the axis
            Application.Driver.AddRune(Application.Driver.RightTee);

            // and the label text
            if (!string.IsNullOrWhiteSpace(text))
            {
                graph.Move(Math.Max(0, x - labelThickness), screenPosition);
                Application.Driver.AddStr(text);
            }
        }

        /// <summary>
        /// Returns the X screen position of the origin (typically 0,0) of graph space.
        /// Return value is bounded by the screen i.e. the axis is always rendered even
        /// if the origin is offscreen.
        /// </summary>
        /// <param name="graph"></param>
        public int GetAxisXPosition(GraphView graph)
        {
            // find the origin of the graph in screen space (this allows for 'crosshair' style
            // graphs where positive and negative numbers visible
            var origin = graph.GraphSpaceToScreen(new PointF(0, 0));

            // float the Y axis so that it accurately represents the origin of the graph
            // but anchor it to left/right if the origin is offscreen
            return Math.Min(Math.Max((int)graph.MarginLeft, origin.X), graph.Bounds.Width - 1);
        }
    }


    /// <summary>
    /// A location on an axis of a <see cref="GraphView"/> that may
    /// or may not have a label associated with it
    /// </summary>
    public class AxisIncrementToRender
    {

        /// <summary>
        /// Direction of the parent axis
        /// </summary>
        public Orientation Orientation { get; }

        /// <summary>
        /// The screen location (X or Y depending on <see cref="Orientation"/>) that the
        /// increment will be rendered at
        /// </summary>
        public int ScreenLocation { get; }

        /// <summary>
        /// The value at this position on the axis in graph space
        /// </summary>
        public float Value { get; }

        private string _text = "";

        /// <summary>
        /// The text (if any) that should be displayed at this axis increment
        /// </summary>
        /// <value></value>
        internal string Text
        {
            get => _text;
            set { _text = value ?? ""; }
        }

        /// <summary>
        /// Describe a new section of an axis that requires an axis increment
        /// symbol and/or label
        /// </summary>
        /// <param name="orientation"></param>
        /// <param name="screen"></param>
        /// <param name="value"></param>
        public AxisIncrementToRender(Orientation orientation, int screen, float value)
        {
            Orientation = orientation;
            ScreenLocation = screen;
            Value = value;
        }
    }

    /// <summary>
    /// Delegate for custom formatting of axis labels.  Determines what should be displayed at a given label
    /// </summary>
    /// <param name="toRender">The axis increment to which the label is attached</param>
    /// <returns></returns>
    public delegate string LabelGetterDelegate(AxisIncrementToRender toRender);
    //=======================================================================
    /// <summary>
    /// Describes how to render a single row/column of a <see cref="GraphView"/> based
    /// on the value(s) in <see cref="ISeries"/> at that location
    /// </summary>
    public class GraphCellToRender
    {

        /// <summary>
        /// The character to render in the console
        /// </summary>
        public Rune Rune { get; set; }

        /// <summary>
        /// Optional color to render the <see cref="Rune"/> with
        /// </summary>
        public Attribute? Color { get; set; }

        /// <summary>
        /// Creates instance and sets <see cref="Rune"/> with default graph coloring
        /// </summary>
        /// <param name="rune"></param>
        public GraphCellToRender(Rune rune)
        {
            Rune = rune;
        }
        /// <summary>
        /// Creates instance and sets <see cref="Rune"/> with custom graph coloring
        /// </summary>
        /// <param name="rune"></param>
        /// <param name="color"></param>
        public GraphCellToRender(Rune rune, Attribute color) : this(rune)
        {
            Color = color;
        }
        /// <summary>
        /// Creates instance and sets <see cref="Rune"/> and <see cref="Color"/> (or default if null)
        /// </summary>
        public GraphCellToRender(Rune rune, Attribute? color) : this(rune)
        {
            Color = color;
        }
    }
    //=======================================================================
    /// <summary>
    /// Facilitates box drawing and line intersection detection
    /// and rendering.  Does not support diagonal lines.
    /// </summary>
    public class LineCanvas
    {


        private List<StraightLine> lines = new List<StraightLine>();

        Dictionary<IntersectionRuneType, IntersectionRuneResolver> runeResolvers = new Dictionary<IntersectionRuneType, IntersectionRuneResolver> {
            {IntersectionRuneType.ULCorner,new ULIntersectionRuneResolver()},
            {IntersectionRuneType.URCorner,new URIntersectionRuneResolver()},
            {IntersectionRuneType.LLCorner,new LLIntersectionRuneResolver()},
            {IntersectionRuneType.LRCorner,new LRIntersectionRuneResolver()},

            {IntersectionRuneType.TopTee,new TopTeeIntersectionRuneResolver()},
            {IntersectionRuneType.LeftTee,new LeftTeeIntersectionRuneResolver()},
            {IntersectionRuneType.RightTee,new RightTeeIntersectionRuneResolver()},
            {IntersectionRuneType.BottomTee,new BottomTeeIntersectionRuneResolver()},


            {IntersectionRuneType.Crosshair,new CrosshairIntersectionRuneResolver()},
			// TODO: Add other resolvers
		};

        /// <summary>
        /// Add a new line to the canvas starting at <paramref name="from"/>.
        /// Use positive <paramref name="length"/> for Right and negative for Left
        /// when <see cref="Orientation"/> is <see cref="Orientation.Horizontal"/>.
        /// Use positive <paramref name="length"/> for Down and negative for Up
        /// when <see cref="Orientation"/> is <see cref="Orientation.Vertical"/>.
        /// </summary>
        /// <param name="from">Starting point.</param>
        /// <param name="length">Length of line.  0 for a dot.  
        /// Positive for Down/Right.  Negative for Up/Left.</param>
        /// <param name="orientation">Direction of the line.</param>
        /// <param name="style">The style of line to use</param>
        public void AddLine(Point from, int length, Orientation orientation, BorderStyle style)
        {
            lines.Add(new StraightLine(from, length, orientation, style));
        }
        /// <summary>
        /// Evaluate all currently defined lines that lie within 
        /// <paramref name="inArea"/> and map that
        /// shows what characters (if any) should be rendered at each
        /// point so that all lines connect up correctly with appropriate
        /// intersection symbols.
        /// <returns></returns>
        /// </summary>
        /// <param name="inArea"></param>
        /// <returns>Mapping of all the points within <paramref name="inArea"/> to
        /// line or intersection runes which should be drawn there.</returns>
        public Dictionary<Point, Rune> GenerateImage(Rect inArea)
        {
            var map = new Dictionary<Point, Rune>();

            // walk through each pixel of the bitmap
            for (int y = inArea.Y; y < inArea.Height; y++)
            {
                for (int x = inArea.X; x < inArea.Width; x++)
                {

                    var intersects = lines
                        .Select(l => l.Intersects(x, y))
                        .Where(i => i != null)
                        .ToArray();

                    // TODO: use Driver and LineStyle to map
                    var rune = GetRuneForIntersects(Application.Driver, intersects);

                    if (rune != null)
                    {
                        map.Add(new Point(x, y), rune.Value);
                    }
                }
            }

            return map;
        }

        private abstract class IntersectionRuneResolver
        {
            readonly Rune round;
            readonly Rune doubleH;
            readonly Rune doubleV;
            readonly Rune doubleBoth;
            readonly Rune normal;

            public IntersectionRuneResolver(Rune round, Rune doubleH, Rune doubleV, Rune doubleBoth, Rune normal)
            {
                this.round = round;
                this.doubleH = doubleH;
                this.doubleV = doubleV;
                this.doubleBoth = doubleBoth;
                this.normal = normal;
            }

            public Rune? GetRuneForIntersects(ConsoleDriver driver, IntersectionDefinition[] intersects)
            {
                var useRounded = intersects.Any(i => i.Line.Style == BorderStyle.Rounded && i.Line.Length != 0);

                bool doubleHorizontal = intersects.Any(l => l.Line.Orientation == Orientation.Horizontal && l.Line.Style == BorderStyle.Double);
                bool doubleVertical = intersects.Any(l => l.Line.Orientation == Orientation.Vertical && l.Line.Style == BorderStyle.Double);


                if (doubleHorizontal)
                {
                    return doubleVertical ? doubleBoth : doubleH;
                }

                if (doubleVertical)
                {
                    return doubleV;
                }

                return useRounded ? round : normal;
            }
        }

        private class ULIntersectionRuneResolver : IntersectionRuneResolver
        {
            public ULIntersectionRuneResolver() :
                base('╭', '╒', '╓', '╔', '┌')
            {

            }
        }
        private class URIntersectionRuneResolver : IntersectionRuneResolver
        {

            public URIntersectionRuneResolver() :
                base('╮', '╕', '╖', '╗', '┐')
            {

            }
        }
        private class LLIntersectionRuneResolver : IntersectionRuneResolver
        {

            public LLIntersectionRuneResolver() :
                base('╰', '╘', '╙', '╚', '└')
            {

            }
        }
        private class LRIntersectionRuneResolver : IntersectionRuneResolver
        {
            public LRIntersectionRuneResolver() :
                base('╯', '╛', '╜', '╝', '┘')
            {

            }
        }

        private class TopTeeIntersectionRuneResolver : IntersectionRuneResolver
        {
            public TopTeeIntersectionRuneResolver() :
                base('┬', '╤', '╥', '╦', '┬')
            {

            }
        }
        private class LeftTeeIntersectionRuneResolver : IntersectionRuneResolver
        {
            public LeftTeeIntersectionRuneResolver() :
                base('├', '╞', '╟', '╠', '├')
            {

            }
        }
        private class RightTeeIntersectionRuneResolver : IntersectionRuneResolver
        {
            public RightTeeIntersectionRuneResolver() :
                base('┤', '╡', '╢', '╣', '┤')
            {

            }
        }
        private class BottomTeeIntersectionRuneResolver : IntersectionRuneResolver
        {
            public BottomTeeIntersectionRuneResolver() :
                base('┴', '╧', '╨', '╩', '┴')
            {

            }
        }
        private class CrosshairIntersectionRuneResolver : IntersectionRuneResolver
        {
            public CrosshairIntersectionRuneResolver() :
                base('┼', '╪', '╫', '╬', '┼')
            {

            }
        }

        private Rune? GetRuneForIntersects(ConsoleDriver driver, IntersectionDefinition[] intersects)
        {
            if (!intersects.Any())
                return null;

            var runeType = GetRuneTypeForIntersects(intersects);

            if (runeResolvers.ContainsKey(runeType))
            {
                return runeResolvers[runeType].GetRuneForIntersects(driver, intersects);
            }

            // TODO: Remove these two once we have all of the below ported to IntersectionRuneResolvers
            var useDouble = intersects.Any(i => i.Line.Style == BorderStyle.Double && i.Line.Length != 0);
            var useRounded = intersects.Any(i => i.Line.Style == BorderStyle.Rounded && i.Line.Length != 0);

            // TODO: maybe make these resolvers to for simplicity?
            // or for dotted lines later on or that kind of thing?
            switch (runeType)
            {
                case IntersectionRuneType.None:
                    return null;
                case IntersectionRuneType.Dot:
                    return (Rune)'.';
                case IntersectionRuneType.HLine:
                    return useDouble ? driver.HDLine : driver.HLine;
                case IntersectionRuneType.VLine:
                    return useDouble ? driver.VDLine : driver.VLine;
                default: throw new Exception("Could not find resolver or switch case for " + nameof(runeType) + ":" + runeType);
            }
        }


        private IntersectionRuneType GetRuneTypeForIntersects(IntersectionDefinition[] intersects)
        {
            if (intersects.All(i => i.Line.Length == 0))
            {
                return IntersectionRuneType.Dot;
            }

            // ignore dots
            intersects = intersects.Where(i => i.Type != IntersectionType.Dot).ToArray();

            var set = new HashSet<IntersectionType>(intersects.Select(i => i.Type));

            #region Crosshair Conditions
            if (Has(set,
                IntersectionType.PassOverHorizontal,
                IntersectionType.PassOverVertical
                ))
            {
                return IntersectionRuneType.Crosshair;
            }

            if (Has(set,
                IntersectionType.PassOverVertical,
                IntersectionType.StartLeft,
                IntersectionType.StartRight
                ))
            {
                return IntersectionRuneType.Crosshair;
            }

            if (Has(set,
                IntersectionType.PassOverHorizontal,
                IntersectionType.StartUp,
                IntersectionType.StartDown
                ))
            {
                return IntersectionRuneType.Crosshair;
            }


            if (Has(set,
                IntersectionType.StartLeft,
                IntersectionType.StartRight,
                IntersectionType.StartUp,
                IntersectionType.StartDown))
            {
                return IntersectionRuneType.Crosshair;
            }
            #endregion


            #region Corner Conditions
            if (Exactly(set,
                IntersectionType.StartRight,
                IntersectionType.StartDown))
            {
                return IntersectionRuneType.ULCorner;
            }

            if (Exactly(set,
                IntersectionType.StartLeft,
                IntersectionType.StartDown))
            {
                return IntersectionRuneType.URCorner;
            }

            if (Exactly(set,
                IntersectionType.StartUp,
                IntersectionType.StartLeft))
            {
                return IntersectionRuneType.LRCorner;
            }

            if (Exactly(set,
                IntersectionType.StartUp,
                IntersectionType.StartRight))
            {
                return IntersectionRuneType.LLCorner;
            }
            #endregion Corner Conditions

            #region T Conditions
            if (Has(set,
                IntersectionType.PassOverHorizontal,
                IntersectionType.StartDown))
            {
                return IntersectionRuneType.TopTee;
            }
            if (Has(set,
                IntersectionType.StartRight,
                IntersectionType.StartLeft,
                IntersectionType.StartDown))
            {
                return IntersectionRuneType.TopTee;
            }

            if (Has(set,
                IntersectionType.PassOverHorizontal,
                IntersectionType.StartUp))
            {
                return IntersectionRuneType.BottomTee;
            }
            if (Has(set,
                IntersectionType.StartRight,
                IntersectionType.StartLeft,
                IntersectionType.StartUp))
            {
                return IntersectionRuneType.BottomTee;
            }


            if (Has(set,
                IntersectionType.PassOverVertical,
                IntersectionType.StartRight))
            {
                return IntersectionRuneType.LeftTee;
            }
            if (Has(set,
                IntersectionType.StartRight,
                IntersectionType.StartDown,
                IntersectionType.StartUp))
            {
                return IntersectionRuneType.LeftTee;
            }


            if (Has(set,
                IntersectionType.PassOverVertical,
                IntersectionType.StartLeft))
            {
                return IntersectionRuneType.RightTee;
            }
            if (Has(set,
                IntersectionType.StartLeft,
                IntersectionType.StartDown,
                IntersectionType.StartUp))
            {
                return IntersectionRuneType.RightTee;
            }
            #endregion

            if (All(intersects, Orientation.Horizontal))
            {
                return IntersectionRuneType.HLine;
            }

            if (All(intersects, Orientation.Vertical))
            {
                return IntersectionRuneType.VLine;
            }

            return IntersectionRuneType.Dot;
        }

        private bool All(IntersectionDefinition[] intersects, Orientation orientation)
        {
            return intersects.All(i => i.Line.Orientation == orientation);
        }

        /// <summary>
        /// Returns true if the <paramref name="intersects"/> collection has all the <paramref name="types"/>
        /// specified (i.e. AND).
        /// </summary>
        /// <param name="intersects"></param>
        /// <param name="types"></param>
        /// <returns></returns>
        private bool Has(HashSet<IntersectionType> intersects, params IntersectionType[] types)
        {
            return types.All(t => intersects.Contains(t));
        }

        /// <summary>
        /// Returns true if all requested <paramref name="types"/> appear in <paramref name="intersects"/>
        /// and there are no additional <see cref="IntersectionRuneType"/>
        /// </summary>
        /// <param name="intersects"></param>
        /// <param name="types"></param>
        /// <returns></returns>
        private bool Exactly(HashSet<IntersectionType> intersects, params IntersectionType[] types)
        {
            return intersects.SetEquals(types);
        }

        class IntersectionDefinition
        {
            /// <summary>
            /// The point at which the intersection happens
            /// </summary>
            public Point Point { get; }

            /// <summary>
            /// Defines how <see cref="Line"/> position relates
            /// to <see cref="Point"/>.
            /// </summary>
            public IntersectionType Type { get; }

            /// <summary>
            /// The line that intersects <see cref="Point"/>
            /// </summary>
            public StraightLine Line { get; }

            public IntersectionDefinition(Point point, IntersectionType type, StraightLine line)
            {
                Point = point;
                Type = type;
                Line = line;
            }
        }

        /// <summary>
        /// The type of Rune that we will use before considering
        /// double width, curved borders etc
        /// </summary>
        enum IntersectionRuneType
        {
            None,
            Dot,
            ULCorner,
            URCorner,
            LLCorner,
            LRCorner,
            TopTee,
            BottomTee,
            RightTee,
            LeftTee,
            Crosshair,
            HLine,
            VLine,
        }

        enum IntersectionType
        {
            /// <summary>
            /// There is no intersection
            /// </summary>
            None,

            /// <summary>
            ///  A line passes directly over this point traveling along
            ///  the horizontal axis
            /// </summary>
            PassOverHorizontal,

            /// <summary>
            ///  A line passes directly over this point traveling along
            ///  the vertical axis
            /// </summary>
            PassOverVertical,

            /// <summary>
            /// A line starts at this point and is traveling up
            /// </summary>
            StartUp,

            /// <summary>
            /// A line starts at this point and is traveling right
            /// </summary>
            StartRight,

            /// <summary>
            /// A line starts at this point and is traveling down
            /// </summary>
            StartDown,

            /// <summary>
            /// A line starts at this point and is traveling left
            /// </summary>
            StartLeft,

            /// <summary>
            /// A line exists at this point who has 0 length
            /// </summary>
            Dot
        }

        class StraightLine
        {
            public Point Start { get; }
            public int Length { get; }
            public Orientation Orientation { get; }
            public BorderStyle Style { get; }

            public StraightLine(Point start, int length, Orientation orientation, BorderStyle style)
            {
                this.Start = start;
                this.Length = length;
                this.Orientation = orientation;
                this.Style = style;
            }

            internal IntersectionDefinition Intersects(int x, int y)
            {
                if (IsDot())
                {
                    if (StartsAt(x, y))
                    {
                        return new IntersectionDefinition(Start, IntersectionType.Dot, this);
                    }
                    else
                    {
                        return null;
                    }
                }

                switch (Orientation)
                {
                    case Orientation.Horizontal: return IntersectsHorizontally(x, y);
                    case Orientation.Vertical: return IntersectsVertically(x, y);
                    default: throw new ArgumentOutOfRangeException(nameof(Orientation));
                }

            }

            private IntersectionDefinition IntersectsHorizontally(int x, int y)
            {
                if (Start.Y != y)
                {
                    return null;
                }
                else
                {
                    if (StartsAt(x, y))
                    {

                        return new IntersectionDefinition(
                            Start,
                            Length < 0 ? IntersectionType.StartLeft : IntersectionType.StartRight,
                            this
                            );

                    }

                    if (EndsAt(x, y))
                    {

                        return new IntersectionDefinition(
                            Start,
                            Length < 0 ? IntersectionType.StartRight : IntersectionType.StartLeft,
                            this
                            );

                    }
                    else
                    {
                        var xmin = Math.Min(Start.X, Start.X + Length);
                        var xmax = Math.Max(Start.X, Start.X + Length);

                        if (xmin < x && xmax > x)
                        {
                            return new IntersectionDefinition(
                            new Point(x, y),
                            IntersectionType.PassOverHorizontal,
                            this
                            );
                        }
                    }

                    return null;
                }
            }

            private IntersectionDefinition IntersectsVertically(int x, int y)
            {
                if (Start.X != x)
                {
                    return null;
                }
                else
                {
                    if (StartsAt(x, y))
                    {

                        return new IntersectionDefinition(
                            Start,
                            Length < 0 ? IntersectionType.StartUp : IntersectionType.StartDown,
                            this
                            );

                    }

                    if (EndsAt(x, y))
                    {

                        return new IntersectionDefinition(
                            Start,
                            Length < 0 ? IntersectionType.StartDown : IntersectionType.StartUp,
                            this
                            );

                    }
                    else
                    {
                        var ymin = Math.Min(Start.Y, Start.Y + Length);
                        var ymax = Math.Max(Start.Y, Start.Y + Length);

                        if (ymin < y && ymax > y)
                        {
                            return new IntersectionDefinition(
                            new Point(x, y),
                            IntersectionType.PassOverVertical,
                            this
                            );
                        }
                    }

                    return null;
                }
            }

            private bool EndsAt(int x, int y)
            {
                if (Orientation == Orientation.Horizontal)
                {
                    return Start.X + Length == x && Start.Y == y;
                }

                return Start.X == x && Start.Y + Length == y;
            }

            private bool StartsAt(int x, int y)
            {
                return Start.X == x && Start.Y == y;
            }

            private bool IsDot()
            {
                return Length == 0;
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Direction of an element (horizontal or vertical)
    /// </summary>
    public enum Orientation
    {

        /// <summary>
        /// Left to right 
        /// </summary>
        Horizontal,

        /// <summary>
        /// Bottom to top
        /// </summary>
        Vertical
    }
    //=======================================================================
    /// <summary>
    /// Describes a series of data that can be rendered into a <see cref="GraphView"/>>
    /// </summary>
    public interface ISeries
    {

        /// <summary>
        /// Draws the <paramref name="graphBounds"/> section of a series into the
        /// <paramref name="graph"/> view <paramref name="drawBounds"/>
        /// </summary>
        /// <param name="graph">Graph series is to be drawn onto</param>
        /// <param name="drawBounds">Visible area of the graph in Console Screen units (excluding margins)</param>
        /// <param name="graphBounds">Visible area of the graph in Graph space units</param>
        void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds);
    }


    /// <summary>
    /// Series composed of any number of discrete data points 
    /// </summary>
    public class ScatterSeries : ISeries
    {
        /// <summary>
        /// Collection of each discrete point in the series
        /// </summary>
        /// <returns></returns>
        public List<PointF> Points { get; set; } = new List<PointF>();

        /// <summary>
        /// The color and character that will be rendered in the console
        /// when there are point(s) in the corresponding graph space.
        /// Defaults to uncolored 'x'
        /// </summary>
        public GraphCellToRender Fill { get; set; } = new GraphCellToRender('x');

        /// <summary>
        /// Draws all points directly onto the graph
        /// </summary>
        public void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds)
        {
            if (Fill.Color.HasValue)
            {
                Application.Driver.SetAttribute(Fill.Color.Value);
            }

            foreach (var p in Points.Where(p => graphBounds.Contains(p)))
            {

                var screenPoint = graph.GraphSpaceToScreen(p);
                graph.AddRune(screenPoint.X, screenPoint.Y, Fill.Rune);
            }

        }

    }


    /// <summary>
    /// Collection of <see cref="BarSeries"/> in which bars are clustered by category
    /// </summary>
    public class MultiBarSeries : ISeries
    {

        BarSeries[] subSeries;

        /// <summary>
        /// Sub collections.  Each series contains the bars for a different category.  Thus 
        /// SubSeries[0].Bars[0] is the first bar on the axis and SubSeries[1].Bars[0] is the
        /// second etc
        /// </summary>
        public IReadOnlyCollection<BarSeries> SubSeries { get => new ReadOnlyCollection<BarSeries>(subSeries); }

        /// <summary>
        /// The number of units of graph space between bars.  Should be 
        /// less than <see cref="BarSeries.BarEvery"/>
        /// </summary>
        public float Spacing { get; }

        /// <summary>
        /// Creates a new series of clustered bars.
        /// </summary>
        /// <param name="numberOfBarsPerCategory">Each category has this many bars</param>
        /// <param name="barsEvery">How far appart to put each category (in graph space)</param>
        /// <param name="spacing">How much spacing between bars in a category (should be less than <paramref name="barsEvery"/>/<paramref name="numberOfBarsPerCategory"/>)</param>
        /// <param name="colors">Array of colors that define bar color in each category.  Length must match <paramref name="numberOfBarsPerCategory"/></param>
        public MultiBarSeries(int numberOfBarsPerCategory, float barsEvery, float spacing, Attribute[] colors = null)
        {
            subSeries = new BarSeries[numberOfBarsPerCategory];

            if (colors != null && colors.Length != numberOfBarsPerCategory)
            {
                throw new ArgumentException("Number of colors must match the number of bars", nameof(numberOfBarsPerCategory));
            }


            for (int i = 0; i < numberOfBarsPerCategory; i++)
            {
                subSeries[i] = new BarSeries();
                subSeries[i].BarEvery = barsEvery;
                subSeries[i].Offset = i * spacing;

                // Only draw labels for the first bar in each category
                subSeries[i].DrawLabels = i == 0;

                if (colors != null)
                {
                    subSeries[i].OverrideBarColor = colors[i];
                }
            }
            Spacing = spacing;
        }

        /// <summary>
        /// Adds a new cluster of bars
        /// </summary>
        /// <param name="label"></param>
        /// <param name="fill"></param>
        /// <param name="values">Values for each bar in category, must match the number of bars per category</param>
        public void AddBars(string label, Rune fill, params float[] values)
        {
            if (values.Length != subSeries.Length)
            {
                throw new ArgumentException("Number of values must match the number of bars per category", nameof(values));
            }

            for (int i = 0; i < values.Length; i++)
            {
                subSeries[i].Bars.Add(new BarSeries.Bar(label,
                    new GraphCellToRender(fill), values[i]));
            }
        }

        /// <summary>
        /// Draws all <see cref="SubSeries"/>
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="drawBounds"></param>
        /// <param name="graphBounds"></param>
        public void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds)
        {
            foreach (var bar in subSeries)
            {
                bar.DrawSeries(graph, drawBounds, graphBounds);
            }

        }
    }

    /// <summary>
    /// Series of bars positioned at regular intervals
    /// </summary>
    public class BarSeries : ISeries
    {

        /// <summary>
        /// Ordered collection of graph bars to position along axis
        /// </summary>
        public List<Bar> Bars { get; set; } = new List<Bar>();

        /// <summary>
        /// Determines the spacing of bars along the axis. Defaults to 1 i.e. 
        /// every 1 unit of graph space a bar is rendered.  Note that you should
        /// also consider <see cref="GraphView.CellSize"/> when changing this.
        /// </summary>
        public float BarEvery { get; set; } = 1;

        /// <summary>
        /// Direction bars protrude from the corresponding axis.
        /// Defaults to vertical
        /// </summary>
        public Orientation Orientation { get; set; } = Orientation.Vertical;

        /// <summary>
        /// The number of units of graph space along the axis before rendering the first bar
        /// (and subsequent bars - see <see cref="BarEvery"/>).  Defaults to 0
        /// </summary>
        public float Offset { get; set; } = 0;

        /// <summary>
        /// Overrides the <see cref="Bar.Fill"/> with a fixed color
        /// </summary>
        public Attribute? OverrideBarColor { get; set; }

        /// <summary>
        /// True to draw <see cref="Bar.Text"/> along the axis under the bar.  Defaults
        /// to true.
        /// </summary>
        public bool DrawLabels { get; set; } = true;

        /// <summary>
        /// Applies any color overriding
        /// </summary>
        /// <param name="graphCellToRender"></param>
        /// <returns></returns>
        protected virtual GraphCellToRender AdjustColor(GraphCellToRender graphCellToRender)
        {
            if (OverrideBarColor.HasValue)
            {
                graphCellToRender.Color = OverrideBarColor;
            }

            return graphCellToRender;
        }

        /// <summary>
        /// Draws bars that are currently in the <paramref name="drawBounds"/>
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="drawBounds">Screen area of the graph excluding margins</param>
        /// <param name="graphBounds">Graph space area that should be drawn into <paramref name="drawBounds"/></param>
        public virtual void DrawSeries(GraphView graph, Rect drawBounds, RectangleF graphBounds)
        {
            for (int i = 0; i < Bars.Count; i++)
            {

                float xStart = Orientation == Orientation.Horizontal ? 0 : Offset + ((i + 1) * BarEvery);
                float yStart = Orientation == Orientation.Horizontal ? Offset + ((i + 1) * BarEvery) : 0;

                float endX = Orientation == Orientation.Horizontal ? Bars[i].Value : xStart;
                float endY = Orientation == Orientation.Horizontal ? yStart : Bars[i].Value;

                // translate to screen positions
                var screenStart = graph.GraphSpaceToScreen(new PointF(xStart, yStart));
                var screenEnd = graph.GraphSpaceToScreen(new PointF(endX, endY));

                // Start the bar from wherever the axis is
                if (Orientation == Orientation.Horizontal)
                {

                    screenStart.X = graph.AxisY.GetAxisXPosition(graph);

                    // dont draw bar off the right of the control
                    screenEnd.X = Math.Min(graph.Bounds.Width - 1, screenEnd.X);

                    // if bar is off the screen
                    if (screenStart.Y < 0 || screenStart.Y > drawBounds.Height - graph.MarginBottom)
                    {
                        continue;
                    }
                }
                else
                {

                    // Start the axis
                    screenStart.Y = graph.AxisX.GetAxisYPosition(graph);

                    // dont draw bar up above top of control
                    screenEnd.Y = Math.Max(0, screenEnd.Y);

                    // if bar is off the screen
                    if (screenStart.X < graph.MarginLeft || screenStart.X > graph.MarginLeft + drawBounds.Width - 1)
                    {
                        continue;
                    }
                }

                // draw the bar unless it has no height
                if (Bars[i].Value != 0)
                {
                    DrawBarLine(graph, screenStart, screenEnd, Bars[i]);
                }

                // If we are drawing labels and the bar has one
                if (DrawLabels && !string.IsNullOrWhiteSpace(Bars[i].Text))
                {

                    // Add the label to the relevant axis
                    if (Orientation == Orientation.Horizontal)
                    {

                        graph.AxisY.DrawAxisLabel(graph, screenStart.Y, Bars[i].Text);
                    }
                    else if (Orientation == Orientation.Vertical)
                    {

                        graph.AxisX.DrawAxisLabel(graph, screenStart.X, Bars[i].Text);
                    }
                }
            }

        }

        /// <summary>
        /// Override to do custom drawing of the bar e.g. to apply varying color or changing the fill
        /// symbol mid bar.
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="start">Screen position of the start of the bar</param>
        /// <param name="end">Screen position of the end of the bar</param>
        /// <param name="beingDrawn">The Bar that occupies this space and is being drawn</param>
        protected virtual void DrawBarLine(GraphView graph, Point start, Point end, Bar beingDrawn)
        {
            var adjusted = AdjustColor(beingDrawn.Fill);

            if (adjusted.Color.HasValue)
            {
                Application.Driver.SetAttribute(adjusted.Color.Value);
            }

            graph.DrawLine(start, end, adjusted.Rune);

            graph.SetDriverColorToGraphColor();
        }

        /// <summary>
        /// A single bar in a <see cref="BarSeries"/>
        /// </summary>
        public class Bar
        {

            /// <summary>
            /// Optional text that describes the bar.  This will be rendered on the corresponding
            /// <see cref="Axis"/> unless <see cref="DrawLabels"/> is false
            /// </summary>
            public string Text { get; set; }

            /// <summary>
            /// The color and character that will be rendered in the console
            /// when the bar extends over it
            /// </summary>
            public GraphCellToRender Fill { get; set; }

            /// <summary>
            /// The value in graph space X/Y (depending on <see cref="Orientation"/>) to which the bar extends.
            /// </summary>
            public float Value { get; }

            /// <summary>
            /// Creates a new instance of a single bar rendered in the given <paramref name="fill"/> that extends
            /// out <paramref name="value"/> graph space units in the default <see cref="Orientation"/>
            /// </summary>
            /// <param name="text"></param>
            /// <param name="fill"></param>
            /// <param name="value"></param>
            public Bar(string text, GraphCellToRender fill, float value)
            {
                Text = text;
                Fill = fill;
                Value = value;
            }
        }
    }
}//namespace Terminal.Gui.Graphs
//=======================================================================
//
// Core.cs: The core engine for gui.cs
//
// Authors:
//   Miguel de Icaza (miguel@gnome.org)
//
// Pending:
//   - Check for NeedDisplay on the hierarchy and repaint
//   - Layout support
//   - "Colors" type or "Attributes" type?
//   - What to surface as "BackgroundCOlor" when clearing a window, an attribute or colors?
//
// Optimizations
//   - Add rendering limitation to the exposed area

namespace Terminal.Gui
{

    /// <summary>
    /// A static, singleton class providing the main application driver for Terminal.Gui apps. 
    /// </summary>
    /// <example>
    /// <code>
    /// // A simple Terminal.Gui app that creates a window with a frame and title with 
    /// // 5 rows/columns of padding.
    /// Application.Init();
    /// var win = new Window ("Hello World - CTRL-Q to quit") {
    ///     X = 5,
    ///     Y = 5,
    ///     Width = Dim.Fill (5),
    ///     Height = Dim.Fill (5)
    /// };
    /// Application.Top.Add(win);
    /// Application.Run();
    /// Application.Shutdown();
    /// </code>
    /// </example>
    /// <remarks>
    ///   <para>
    ///     Creates a instance of <see cref="Terminal.Gui.MainLoop"/> to process input events, handle timers and
    ///     other sources of data. It is accessible via the <see cref="MainLoop"/> property.
    ///   </para>
    ///   <para>
    ///     You can hook up to the <see cref="Iteration"/> event to have your method
    ///     invoked on each iteration of the <see cref="Terminal.Gui.MainLoop"/>.
    ///   </para>
    ///   <para>
    ///     When invoked sets the SynchronizationContext to one that is tied
    ///     to the MainLoop, allowing user code to use async/await.
    ///   </para>
    /// </remarks>
    public static class Application
    {
        static readonly Stack<Toplevel> toplevels = new Stack<Toplevel>();

        /// <summary>
        /// The current <see cref="ConsoleDriver"/> in use.
        /// </summary>
        public static ConsoleDriver Driver;

        /// <summary>
        /// Gets all the Mdi childes which represent all the not modal <see cref="Toplevel"/> from the <see cref="MdiTop"/>.
        /// </summary>
        public static List<Toplevel> MdiChildes
        {
            get
            {
                List<Toplevel> mdiChildes = new List<Toplevel>();
                if (MdiTop != null)
                {
                    foreach (var top in toplevels)
                    {
                        if (top != MdiTop && !top.Modal)
                        {
                            mdiChildes.Add(top);
                        }
                    }
                }
                return mdiChildes;
            }
        }

        /// <summary>
        /// The <see cref="Toplevel"/> object used for the application on startup which <see cref="Toplevel.IsMdiContainer"/> is true.
        /// </summary>
        public static Toplevel MdiTop
        {
            get
            {
                if (Top?.IsMdiContainer == true)
                {
                    return Top;
                }
                return null;
            }
        }

        /// <summary>
        /// The <see cref="Toplevel"/> object used for the application on startup (<seealso cref="Application.Top"/>)
        /// </summary>
        /// <value>The top.</value>
        public static Toplevel Top { get; private set; }

        /// <summary>
        /// The current <see cref="Toplevel"/> object. This is updated when <see cref="Application.Run(Func{Exception, bool})"/> enters and leaves to point to the current <see cref="Toplevel"/> .
        /// </summary>
        /// <value>The current.</value>
        public static Toplevel Current { get; private set; }

        /// <summary>
        /// The current <see cref="View"/> object that wants continuous mouse button pressed events.
        /// </summary>
        public static View WantContinuousButtonPressedView { get; private set; }

        /// <summary>
        /// The current <see cref="ConsoleDriver.EnableConsoleScrolling"/> used in the terminal.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If <see langword="false"/> (the default) the height of the Terminal.Gui application (<see cref="ConsoleDriver.Rows"/>) 
        /// tracks to the height of the visible console view when the console is resized. In this case 
        /// scrolling in the console will be disabled and all <see cref="ConsoleDriver.Rows"/> will remain visible.
        /// </para>
        /// <para>
        /// If <see langword="true"/> then height of the Terminal.Gui application <see cref="ConsoleDriver.Rows"/> only tracks 
        /// the height of the visible console view when the console is made larger (the application will only grow in height, never shrink). 
        /// In this case console scrolling is enabled and the contents (<see cref="ConsoleDriver.Rows"/> high) will scroll
        /// as the console scrolls. 
        /// </para>
        /// <para>This API is deprecated and has no impact when enabled.</para>
        /// <para>This API was previously named 'HeightAsBuffer` but was renamed to make its purpose more clear.</para>
        /// </remarks>
        [Obsolete("This API is deprecated and has no impact when enabled.", false)]
        public static bool EnableConsoleScrolling { get; set; }

        /// <summary>
        /// This API is deprecated; use <see cref="EnableConsoleScrolling"/> instead.
        /// </summary>
        [Obsolete("This API is deprecated and has no impact when enabled.", false)]
        public static bool HeightAsBuffer { get; set; }

        static Key alternateForwardKey = Key.PageDown | Key.CtrlMask;

        /// <summary>
        /// Alternative key to navigate forwards through views. Ctrl+Tab is the primary key.
        /// </summary>
        public static Key AlternateForwardKey
        {
            get => alternateForwardKey;
            set
            {
                if (alternateForwardKey != value)
                {
                    var oldKey = alternateForwardKey;
                    alternateForwardKey = value;
                    OnAlternateForwardKeyChanged(oldKey);
                }
            }
        }

        static void OnAlternateForwardKeyChanged(Key oldKey)
        {
            foreach (var top in toplevels.ToArray())
            {
                top.OnAlternateForwardKeyChanged(oldKey);
            }
        }

        static Key alternateBackwardKey = Key.PageUp | Key.CtrlMask;

        /// <summary>
        /// Alternative key to navigate backwards through views. Shift+Ctrl+Tab is the primary key.
        /// </summary>
        public static Key AlternateBackwardKey
        {
            get => alternateBackwardKey;
            set
            {
                if (alternateBackwardKey != value)
                {
                    var oldKey = alternateBackwardKey;
                    alternateBackwardKey = value;
                    OnAlternateBackwardKeyChanged(oldKey);
                }
            }
        }

        static void OnAlternateBackwardKeyChanged(Key oldKey)
        {
            foreach (var top in toplevels.ToArray())
            {
                top.OnAlternateBackwardKeyChanged(oldKey);
            }
        }

        static Key quitKey = Key.Q | Key.CtrlMask;

        /// <summary>
        /// Gets or sets the key to quit the application.
        /// </summary>
        public static Key QuitKey
        {
            get => quitKey;
            set
            {
                if (quitKey != value)
                {
                    var oldKey = quitKey;
                    quitKey = value;
                    OnQuitKeyChanged(oldKey);
                }
            }
        }

        private static List<CultureInfo> supportedCultures;

        /// <summary>
        /// Gets all supported cultures by the application without the invariant language.
        /// </summary>
        public static List<CultureInfo> SupportedCultures => supportedCultures;

        static void OnQuitKeyChanged(Key oldKey)
        {
            // Duplicate the list so if it changes during enumeration we're safe
            foreach (var top in toplevels.ToArray())
            {
                top.OnQuitKeyChanged(oldKey);
            }
        }

        /// <summary>
        /// The <see cref="MainLoop"/>  driver for the application
        /// </summary>
        /// <value>The main loop.</value>
        public static MainLoop MainLoop { get; private set; }

        /// <summary>
        /// Disable or enable the mouse. The mouse is enabled by default.
        /// </summary>
        public static bool IsMouseDisabled { get; set; }

        /// <summary>
        /// Set to true to cause the RunLoop method to exit after the first iterations.
        /// Set to false (the default) to cause the RunLoop to continue running until Application.RequestStop() is called.
        /// </summary>
        public static bool ExitRunLoopAfterFirstIteration { get; set; } = false;

        /// <summary>
        /// Notify that a new <see cref="RunState"/> was created (<see cref="Begin(Toplevel)"/> was called). The token is created in 
        /// <see cref="Begin(Toplevel)"/> and this event will be fired before that function exits.
        /// </summary>
        /// <remarks>
        ///	If <see cref="ExitRunLoopAfterFirstIteration"/> is <see langword="true"/> callers to
        ///	<see cref="Begin(Toplevel)"/> must also subscribe to <see cref="NotifyStopRunState"/>
        ///	and manually dispose of the <see cref="RunState"/> token when the application is done.
        /// </remarks>
        public static event Action<RunState> NotifyNewRunState;

        /// <summary>
        /// Notify that a existent <see cref="RunState"/> is stopping (<see cref="End(RunState)"/> was called).
        /// </summary>
        /// <remarks>
        ///	If <see cref="ExitRunLoopAfterFirstIteration"/> is <see langword="true"/> callers to
        ///	<see cref="Begin(Toplevel)"/> must also subscribe to <see cref="NotifyStopRunState"/>
        ///	and manually dispose of the <see cref="RunState"/> token when the application is done.
        /// </remarks>
        public static event Action<Toplevel> NotifyStopRunState;

        /// <summary>
        ///   This event is raised on each iteration of the <see cref="MainLoop"/>. 
        /// </summary>
        /// <remarks>
        ///   See also <see cref="Timeout"/>
        /// </remarks>
        public static Action Iteration;

        /// <summary>
        /// Returns a rectangle that is centered in the screen for the provided size.
        /// </summary>
        /// <returns>The centered rect.</returns>
        /// <param name="size">Size for the rectangle.</param>
        public static Rect MakeCenteredRect(Size size)
        {
            return new Rect(new Point((Driver.Cols - size.Width) / 2, (Driver.Rows - size.Height) / 2), size);
        }

        //
        // provides the sync context set while executing code in Terminal.Gui, to let
        // users use async/await on their code
        //
        class MainLoopSyncContext : SynchronizationContext
        {
            readonly MainLoop mainLoop;

            public MainLoopSyncContext(MainLoop mainLoop)
            {
                this.mainLoop = mainLoop;
            }

            public override SynchronizationContext CreateCopy()
            {
                return new MainLoopSyncContext(MainLoop);
            }

            public override void Post(SendOrPostCallback d, object state)
            {
                mainLoop.AddIdle(() =>
                {
                    d(state);
                    return false;
                });
                //mainLoop.Driver.Wakeup ();
            }

            public override void Send(SendOrPostCallback d, object state)
            {
                if (Thread.CurrentThread.ManagedThreadId == _mainThreadId)
                {
                    d(state);
                }
                else
                {
                    var wasExecuted = false;
                    mainLoop.Invoke(() =>
                    {
                        d(state);
                        wasExecuted = true;
                    });
                    while (!wasExecuted)
                    {
                        Thread.Sleep(15);
                    }
                }
            }
        }

        /// <summary>
        /// If <see langword="true"/>, forces the use of the System.Console-based (see <see cref="NetDriver"/>) driver. The default is <see langword="false"/>.
        /// </summary>
        public static bool UseSystemConsole { get; set; } = false;

        //*master//
        //////// For Unit testing - ignores UseSystemConsole
        //////internal static bool ForceFakeConsole;
        //master*//

        /// <summary>
        /// Initializes a new instance of <see cref="Terminal.Gui"/> Application. 
        /// </summary>
        /// <para>
        /// Call this method once per instance (or after <see cref="Shutdown"/> has been called).
        /// </para>
        /// <para>
        /// This function loads the right <see cref="ConsoleDriver"/> for the platform, 
        /// Creates a <see cref="Toplevel"/>. and assigns it to <see cref="Top"/>
        /// </para>
        /// <para>
        /// <see cref="Shutdown"/> must be called when the application is closing (typically after <see cref="Run(Func{Exception, bool})"/> has 
        /// returned) to ensure resources are cleaned up and terminal settings restored.
        /// </para>
        /// <para>
        /// The <see cref="Run{T}(Func{Exception, bool}, ConsoleDriver, IMainLoopDriver)"/> function 
        /// combines <see cref="Init(ConsoleDriver, IMainLoopDriver)"/> and <see cref="Run(Toplevel, Func{Exception, bool})"/>
        /// into a single call. An applciation cam use <see cref="Run{T}(Func{Exception, bool}, ConsoleDriver, IMainLoopDriver)"/> 
        /// without explicitly calling <see cref="Init(ConsoleDriver, IMainLoopDriver)"/>.
        /// </para>
        /// <param name="driver">
        /// The <see cref="ConsoleDriver"/> to use. If not specified the default driver for the
        /// platform will be used (see <see cref="WindowsDriver"/>, <see cref="CursesDriver"/>, and <see cref="NetDriver"/>).</param>
        /// <param name="mainLoopDriver">
        /// Specifies the <see cref="MainLoop"/> to use. 
        /// Must not be <see langword="null"/> if <paramref name="driver"/> is not <see langword="null"/>.
        /// </param>
        public static void Init(ConsoleDriver driver = null, IMainLoopDriver mainLoopDriver = null) => InternalInit(() => Toplevel.Create(), driver, mainLoopDriver);

        internal static bool _initialized = false;
        internal static int _mainThreadId = -1;

        // INTERNAL function for initializing an app with a Toplevel factory object, driver, and mainloop.
        //
        // Called from:
        // 
        // Init() - When the user wants to use the default Toplevel. calledViaRunT will be false, causing all state to be reset.
        // Run<T>() - When the user wants to use a custom Toplevel. calledViaRunT will be true, enabling Run<T>() to be called without calling Init first.
        // Unit Tests - To initialize the app with a custom Toplevel, using the FakeDriver. calledViaRunT will be false, causing all state to be reset.
        // 
        // calledViaRunT: If false (default) all state will be reset. If true the state will not be reset.
        internal static void InternalInit(Func<Toplevel> topLevelFactory, ConsoleDriver driver = null, IMainLoopDriver mainLoopDriver = null, bool calledViaRunT = false)
        {
            if (_initialized && driver == null) return;

            if (_initialized)
            {
                throw new InvalidOperationException("Init has already been called and must be bracketed by Shutdown.");
            }

            // Note in this case, we don't verify the type of the Toplevel created by new T(). 
            // Used only for start debugging on Unix.
            //#if DEBUG
            //			while (!System.Diagnostics.Debugger.IsAttached) {
            //				System.Threading.Thread.Sleep (100);
            //			}
            //			System.Diagnostics.Debugger.Break ();
            //#endif

            if (!calledViaRunT)
            {
                // Reset all class variables (Application is a singleton).
                ResetState();
            }

            // For UnitTests
            if (driver != null)
            {
                //if (mainLoopDriver == null) {
                //	throw new ArgumentNullException ("InternalInit mainLoopDriver cannot be null if driver is provided.");
                //}
                //if (!(driver is FakeDriver)) {
                //	throw new InvalidOperationException ("InternalInit can only be called with FakeDriver.");
                //}
                Driver = driver;
            }

            if (Driver == null)
            {
                var p = Environment.OSVersion.Platform;
                //if (ForceFakeConsole)
                //{
                //    // For Unit Testing only
                //    Driver = new FakeDriver();
                //}
                //else if (UseSystemConsole)

                if (UseSystemConsole)
                {
                    Driver = new NetDriver();
                }
                else if (p == PlatformID.Win32NT || p == PlatformID.Win32S || p == PlatformID.Win32Windows)
                {
                    Driver = new WindowsDriver();
                }
                else
                {
                    Driver = new CursesDriver();
                }
                if (Driver == null)
                {
                    throw new InvalidOperationException("Init could not determine the ConsoleDriver to use.");
                }
            }

            if (mainLoopDriver == null)
            {
                // TODO: Move this logic into ConsoleDriver
                if (Driver is FakeDriver)
                {
                    mainLoopDriver = new FakeMainLoop(Driver);
                }
                else if (Driver is NetDriver)
                {
                    mainLoopDriver = new NetMainLoop(Driver);
                }
                else if (Driver is WindowsDriver)
                {
                    mainLoopDriver = new WindowsMainLoop(Driver);
                }
                else if (Driver is CursesDriver)
                {
                    mainLoopDriver = new UnixMainLoop(Driver);
                }
                if (mainLoopDriver == null)
                {
                    throw new InvalidOperationException("Init could not determine the MainLoopDriver to use.");
                }
            }

            MainLoop = new MainLoop(mainLoopDriver);

            try
            {
                Driver.Init(TerminalResized);
            }
            catch (InvalidOperationException ex)
            {
                // This is a case where the driver is unable to initialize the console.
                // This can happen if the console is already in use by another process or
                // if running in unit tests.
                // In this case, we want to throw a more specific exception.
                throw new InvalidOperationException("Unable to initialize the console. This can happen if the console is already in use by another process or in unit tests.", ex);
            }

            SynchronizationContext.SetSynchronizationContext(new MainLoopSyncContext(MainLoop));

            Top = topLevelFactory();
            Current = Top;
            supportedCultures = GetSupportedCultures();
            _mainThreadId = Thread.CurrentThread.ManagedThreadId;
            _initialized = true;
        }

        /// <summary>
        /// Captures the execution state for the provided <see cref="Toplevel"/> view.
        /// </summary>
        public class RunState : IDisposable
        {
            /// <summary>
            /// Initializes a new <see cref="RunState"/> class.
            /// </summary>
            /// <param name="view"></param>
            public RunState(Toplevel view)
            {
                Toplevel = view;
            }
            /// <summary>
            /// The <see cref="Toplevel"/> belong to this <see cref="RunState"/>.
            /// </summary>
            public Toplevel Toplevel { get; internal set; }

#if DEBUG_IDISPOSABLE
			/// <summary>
			/// For debug purposes to verify objects are being disposed properly
			/// </summary>
			public bool WasDisposed = false;
			/// <summary>
			/// For debug purposes to verify objects are being disposed properly
			/// </summary>
			public int DisposedCount = 0;
			/// <summary>
			/// For debug purposes
			/// </summary>
			public static List<RunState> Instances = new List<RunState> ();
			/// <summary>
			/// For debug purposes
			/// </summary>
			public RunState ()
			{
				Instances.Add (this);
			}
#endif

            /// <summary>
            /// Releases all resource used by the <see cref="Application.RunState"/> object.
            /// </summary>
            /// <remarks>
            /// Call <see cref="Dispose()"/> when you are finished using the <see cref="Application.RunState"/>. 
            /// </remarks>
            /// <remarks>
            /// <see cref="Dispose()"/> method leaves the <see cref="Application.RunState"/> in an unusable state. After
            /// calling <see cref="Dispose()"/>, you must release all references to the
            /// <see cref="Application.RunState"/> so the garbage collector can reclaim the memory that the
            /// <see cref="Application.RunState"/> was occupying.
            /// </remarks>
            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
#if DEBUG_IDISPOSABLE
				WasDisposed = true;
#endif
            }

            /// <summary>
            /// Releases all resource used by the <see cref="Application.RunState"/> object.
            /// </summary>
            /// <param name="disposing">If set to <see langword="true"/> we are disposing and should dispose held objects.</param>
            protected virtual void Dispose(bool disposing)
            {
                if (Toplevel != null && disposing)
                {
                    Toplevel.Dispose();
                    Toplevel = null;
                }
            }
        }

        static void ProcessKeyEvent(KeyEvent ke)
        {
            if (RootKeyEvent?.Invoke(ke) ?? false)
            {
                return;
            }

            var chain = toplevels.Where(t => t.Visible).ToList();
            foreach (var topLevel in chain)
            {
                if (topLevel.ProcessHotKey(ke))
                {
                    EnsuresMdiTopOnFrontIfMdiTopMostFocused();
                    return;
                }
                if (topLevel.Modal)
                    break;
            }

            foreach (var topLevel in chain)
            {
                if (topLevel.ProcessKey(ke))
                    return;
                if (topLevel.Modal)
                    break;
            }

            foreach (var topLevel in chain)
            {
                // Process the key normally
                if (topLevel.ProcessColdKey(ke))
                    return;
                if (topLevel.Modal)
                    break;
            }
        }

        static void ProcessKeyDownEvent(KeyEvent ke)
        {
            var chain = toplevels.ToList();
            foreach (var topLevel in chain)
            {
                if (topLevel.OnKeyDown(ke))
                    return;
                if (topLevel.Modal)
                    break;
            }
        }


        static void ProcessKeyUpEvent(KeyEvent ke)
        {
            var chain = toplevels.ToList();
            foreach (var topLevel in chain)
            {
                if (topLevel.OnKeyUp(ke))
                    return;
                if (topLevel.Modal)
                    break;
            }
        }

        static View FindDeepestTop(Toplevel start, int x, int y, out int resx, out int resy)
        {
            var startFrame = start.Frame;

            if (!startFrame.Contains(x, y))
            {
                resx = 0;
                resy = 0;
                return null;
            }

            if (toplevels != null)
            {
                int count = toplevels.Count;
                if (count > 0)
                {
                    var rx = x - startFrame.X;
                    var ry = y - startFrame.Y;
                    foreach (var t in toplevels)
                    {
                        if (t != Current)
                        {
                            if (t != start && t.Visible && t.Frame.Contains(rx, ry))
                            {
                                start = t;
                                break;
                            }
                        }
                    }
                }
            }
            resx = x - startFrame.X;
            resy = y - startFrame.Y;
            return start;
        }

        static View FindDeepestMdiView(View start, int x, int y, out int resx, out int resy)
        {
            if (start.GetType().BaseType != typeof(Toplevel)
                && !((Toplevel)start).IsMdiContainer)
            {
                resx = 0;
                resy = 0;
                return null;
            }

            var startFrame = start.Frame;

            if (!startFrame.Contains(x, y))
            {
                resx = 0;
                resy = 0;
                return null;
            }

            int count = toplevels.Count;
            for (int i = count - 1; i >= 0; i--)
            {
                foreach (var top in toplevels)
                {
                    var rx = x - startFrame.X;
                    var ry = y - startFrame.Y;
                    if (top.Visible && top.Frame.Contains(rx, ry))
                    {
                        var deep = FindDeepestView(top, rx, ry, out resx, out resy);
                        if (deep == null)
                            return FindDeepestMdiView(top, rx, ry, out resx, out resy);
                        if (deep != MdiTop)
                            return deep;
                    }
                }
            }
            resx = x - startFrame.X;
            resy = y - startFrame.Y;
            return start;
        }

        static View FindDeepestView(View start, int x, int y, out int resx, out int resy)
        {
            var startFrame = start.Frame;

            if (!startFrame.Contains(x, y))
            {
                resx = 0;
                resy = 0;
                return null;
            }

            if (start.InternalSubviews != null)
            {
                int count = start.InternalSubviews.Count;
                if (count > 0)
                {
                    var rx = x - startFrame.X;
                    var ry = y - startFrame.Y;
                    for (int i = count - 1; i >= 0; i--)
                    {
                        View v = start.InternalSubviews[i];
                        if (v.Visible && v.Frame.Contains(rx, ry))
                        {
                            var deep = FindDeepestView(v, rx, ry, out resx, out resy);
                            if (deep == null)
                                return v;
                            return deep;
                        }
                    }
                }
            }
            resx = x - startFrame.X;
            resy = y - startFrame.Y;
            return start;
        }

        static View FindTopFromView(View view)
        {
            View top = view?.SuperView != null && view?.SuperView != Top
                ? view.SuperView : view;

            while (top?.SuperView != null && top?.SuperView != Top)
            {
                top = top.SuperView;
            }
            return top;
        }

        static View mouseGrabView;

        /// <summary>
        /// The view that grabbed the mouse, to where will be routed all the mouse events.
        /// </summary>
        public static View MouseGrabView => mouseGrabView;

        /// <summary>
        /// Invoked when a view wants to grab the mouse; can be canceled.
        /// </summary>
        public static event Func<View, bool> GrabbingMouse;

        /// <summary>
        /// Invoked when a view wants ungrab the mouse; can be canceled.
        /// </summary>
        public static event Func<View, bool> UnGrabbingMouse;

        /// <summary>
        /// Event to be invoked when a view grab the mouse.
        /// </summary>
        public static event Action<View> GrabbedMouse;

        /// <summary>
        /// Event to be invoked when a view ungrab the mouse.
        /// </summary>
        public static event Action<View> UnGrabbedMouse;

        /// <summary>
        /// Grabs the mouse, forcing all mouse events to be routed to the specified view until UngrabMouse is called.
        /// </summary>
        /// <returns>The grab.</returns>
        /// <param name="view">View that will receive all mouse events until UngrabMouse is invoked.</param>
        public static void GrabMouse(View view)
        {
            if (view == null)
                return;
            if (!OnGrabbingMouse(view))
            {
                OnGrabbedMouse(view);
                mouseGrabView = view;
                Driver.UncookMouse();
            }
        }

        /// <summary>
        /// Releases the mouse grab, so mouse events will be routed to the view on which the mouse is.
        /// </summary>
        public static void UngrabMouse()
        {
            if (mouseGrabView == null)
                return;
            if (!OnUnGrabbingMouse(mouseGrabView))
            {
                OnUnGrabbedMouse(mouseGrabView);
                mouseGrabView = null;
                Driver.CookMouse();
            }
        }

        static bool OnGrabbingMouse(View view)
        {
            if (view == null || GrabbingMouse == null)
                return false;
            return (bool)(GrabbingMouse?.Invoke(view));
        }

        static bool OnUnGrabbingMouse(View view)
        {
            if (view == null || UnGrabbingMouse == null)
                return false;
            return (bool)(UnGrabbingMouse?.Invoke(view));
        }

        static void OnGrabbedMouse(View view)
        {
            if (view == null)
                return;
            GrabbedMouse?.Invoke(view);
        }

        static void OnUnGrabbedMouse(View view)
        {
            if (view == null)
                return;
            UnGrabbedMouse?.Invoke(view);
        }

        /// <summary>
        /// Merely a debugging aid to see the raw mouse events
        /// </summary>
        public static Action<MouseEvent> RootMouseEvent;

        /// <summary>
        /// <para>
        /// Called for new KeyPress events before any processing is performed or
        /// views evaluate.  Use for global key handling and/or debugging.
        /// </para>
        /// <para>Return true to suppress the KeyPress event</para>
        /// </summary>
        public static Func<KeyEvent, bool> RootKeyEvent;

        static View lastMouseOwnerView;

        static void ProcessMouseEvent(MouseEvent me)
        {
            if (IsMouseDisabled)
            {
                return;
            }

            EnsuresMdiTopOnFrontIfMdiTopMostFocused();
            var view = FindDeepestView(Current, me.X, me.Y, out int rx, out int ry);

            if (view != null && view.WantContinuousButtonPressed)
                WantContinuousButtonPressedView = view;
            else
                WantContinuousButtonPressedView = null;
            if (view != null)
            {
                me.View = view;
            }
            RootMouseEvent?.Invoke(me);

            if (me.Handled)
            {
                return;
            }

            if (mouseGrabView != null)
            {
                if (view == null)
                {
                    view = mouseGrabView;
                }

                var newxy = mouseGrabView.ScreenToView(me.X, me.Y);
                var nme = new MouseEvent()
                {
                    X = newxy.X,
                    Y = newxy.Y,
                    Flags = me.Flags,
                    OfX = me.X - newxy.X,
                    OfY = me.Y - newxy.Y,
                    View = view
                };
                if (OutsideFrame(new Point(nme.X, nme.Y), mouseGrabView.Frame))
                {
                    lastMouseOwnerView?.OnMouseLeave(me);
                }
                //System.Diagnostics.Debug.WriteLine ($"{nme.Flags};{nme.X};{nme.Y};{mouseGrabView}");
                if (mouseGrabView?.OnMouseEvent(nme) == true)
                {
                    return;
                }
            }

            if ((view == null || view == MdiTop || view.SuperView == MdiTop) && !Current.Modal && MdiTop != null
                && me.Flags != MouseFlags.ReportMousePosition && me.Flags != 0)
            {

                var top = FindDeepestTop(Top, me.X, me.Y, out _, out _);
                view = FindDeepestView(top, me.X, me.Y, out rx, out ry);

                if (view != null && view != MdiTop && top != Current && top.MostFocused != null
                    && top.MostFocused.GetType().Name != "ContentView")
                {

                    MoveCurrent((Toplevel)top);
                }
            }

            if (view != null)
            {
                var nme = new MouseEvent()
                {
                    X = rx,
                    Y = ry,
                    Flags = me.Flags,
                    OfX = 0,
                    OfY = 0,
                    View = view
                };

                if (lastMouseOwnerView == null)
                {
                    lastMouseOwnerView = view;
                    view.OnMouseEnter(nme);
                }
                else if (lastMouseOwnerView != view)
                {
                    lastMouseOwnerView.OnMouseLeave(nme);
                    view.OnMouseEnter(nme);
                    lastMouseOwnerView = view;
                }

                if (!view.WantMousePositionReports && me.Flags == MouseFlags.ReportMousePosition)
                    return;

                if (view.WantContinuousButtonPressed)
                    WantContinuousButtonPressedView = view;
                else
                    WantContinuousButtonPressedView = null;

                // Should we bubbled up the event, if it is not handled?
                if (view.OnMouseEvent(nme))
                {
                    EnsuresMdiTopOnFrontIfMdiTopMostFocused();
                }

                EnsuresTopOnFront();
            }
        }

        static void EnsuresMdiTopOnFrontIfMdiTopMostFocused()
        {
            if (MdiTop != null && Current != MdiTop && MdiTop.MostFocused != null
                && MdiTop.MostFocused.GetType().Name != "ContentView")
            {

                MoveCurrent(Top);
            }
        }

        // Only return true if the Current has changed.
        static bool MoveCurrent(Toplevel top)
        {
            // The Current is modal and the top is not modal toplevel then
            // the Current must be moved above the first not modal toplevel.
            if (MdiTop != null && top != MdiTop && top != Current && Current?.Modal == true && !toplevels.Peek().Modal)
            {
                lock (toplevels)
                {
                    toplevels.MoveTo(Current, 0, new ToplevelEqualityComparer());
                }
                var index = 0;
                var savedToplevels = toplevels.ToArray();
                foreach (var t in savedToplevels)
                {
                    if (!t.Modal && t != Current && t != top && t != savedToplevels[index])
                    {
                        lock (toplevels)
                        {
                            toplevels.MoveTo(top, index, new ToplevelEqualityComparer());
                        }
                    }
                    index++;
                }
                return false;
            }
            // The Current and the top are both not running toplevel then
            // the top must be moved above the first not running toplevel.
            if (MdiTop != null && top != MdiTop && top != Current && Current?.Running == false && !top.Running)
            {
                lock (toplevels)
                {
                    toplevels.MoveTo(Current, 0, new ToplevelEqualityComparer());
                }
                var index = 0;
                foreach (var t in toplevels.ToArray())
                {
                    if (!t.Running && t != Current && index > 0)
                    {
                        lock (toplevels)
                        {
                            toplevels.MoveTo(top, index - 1, new ToplevelEqualityComparer());
                        }
                    }
                    index++;
                }
                return false;
            }
            if ((MdiTop != null && top?.Modal == true && toplevels.Peek() != top)
                || (MdiTop != null && Current != MdiTop && Current?.Modal == false && top == MdiTop)
                || (MdiTop != null && Current?.Modal == false && top != Current)
                || (MdiTop != null && Current?.Modal == true && top == MdiTop))
            {
                lock (toplevels)
                {
                    toplevels.MoveTo(top, 0, new ToplevelEqualityComparer());
                    Current = top;
                }
            }
            return true;
        }

        static bool OutsideFrame(Point p, Rect r)
        {
            return p.X < 0 || p.X > r.Width - 1 || p.Y < 0 || p.Y > r.Height - 1;
        }

        /// <summary>
        /// Building block API: Prepares the provided <see cref="Toplevel"/>  for execution.
        /// </summary>
        /// <returns>The <see cref="RunState"/> handle that needs to be passed to the <see cref="End(RunState)"/> method upon completion.</returns>
        /// <param name="toplevel">The <see cref="Toplevel"/> to prepare execution for.</param>
        /// <remarks>
        ///  This method prepares the provided toplevel for running with the focus,
        ///  it adds this to the list of toplevels, sets up the mainloop to process the
        ///  event, lays out the subviews, focuses the first element, and draws the
        ///  toplevel in the screen. This is usually followed by executing
        ///  the <see cref="RunLoop"/> method, and then the <see cref="End(RunState)"/> method upon termination which will
        ///   undo these changes.
        /// </remarks>
        public static RunState Begin(Toplevel toplevel)
        {
            if (toplevel == null)
            {
                throw new ArgumentNullException(nameof(toplevel));
            }
            else if (toplevel.IsMdiContainer && MdiTop != toplevel && MdiTop != null)
            {
                throw new InvalidOperationException("Only one Mdi Container is allowed.");
            }

            var rs = new RunState(toplevel);

            if (toplevel is ISupportInitializeNotification initializableNotification &&
                !initializableNotification.IsInitialized)
            {
                initializableNotification.BeginInit();
                initializableNotification.EndInit();
            }
            else if (toplevel is ISupportInitialize initializable)
            {
                initializable.BeginInit();
                initializable.EndInit();
            }

            lock (toplevels)
            {
                // If Top was already initialized with Init, and Begin has never been called
                // Top was not added to the toplevels Stack. It will thus never get disposed.
                // Clean it up here:
                if (Top != null && toplevel != Top && !toplevels.Contains(Top))
                {
                    Top.Dispose();
                    Top = null;
                }
                else if (Top != null && toplevel != Top && toplevels.Contains(Top))
                {
                    Top.OnLeave(toplevel);
                }
                if (string.IsNullOrEmpty(toplevel.Id.ToString()))
                {
                    var count = 1;
                    var id = (toplevels.Count + count).ToString();
                    while (toplevels.Count > 0 && toplevels.FirstOrDefault(x => x.Id.ToString() == id) != null)
                    {
                        count++;
                        id = (toplevels.Count + count).ToString();
                    }
                    toplevel.Id = (toplevels.Count + count).ToString();

                    toplevels.Push(toplevel);
                }
                else
                {
                    var dup = toplevels.FirstOrDefault(x => x.Id.ToString() == toplevel.Id);
                    if (dup == null)
                    {
                        toplevels.Push(toplevel);
                    }
                }

                if (toplevels.FindDuplicates(new ToplevelEqualityComparer()).Count > 0)
                {
                    throw new ArgumentException("There are duplicates toplevels Id's");
                }
            }
            // Fix $520 - Set Top = toplevel if Top == null
            if (Top == null || toplevel.IsMdiContainer)
            {
                Top = toplevel;
            }

            var refreshDriver = true;
            if (MdiTop == null || toplevel.IsMdiContainer || (Current?.Modal == false && toplevel.Modal)
                || (Current?.Modal == false && !toplevel.Modal) || (Current?.Modal == true && toplevel.Modal))
            {

                if (toplevel.Visible)
                {
                    Current = toplevel;
                    SetCurrentAsTop();
                }
                else
                {
                    refreshDriver = false;
                }
            }
            else if ((MdiTop != null && toplevel != MdiTop && Current?.Modal == true && !toplevels.Peek().Modal)
              || (MdiTop != null && toplevel != MdiTop && Current?.Running == false))
            {
                refreshDriver = false;
                MoveCurrent(toplevel);
            }
            else
            {
                refreshDriver = false;
                MoveCurrent(Current);
            }

            Driver.PrepareToRun(MainLoop, ProcessKeyEvent, ProcessKeyDownEvent, ProcessKeyUpEvent, ProcessMouseEvent);
            if (toplevel.LayoutStyle == LayoutStyle.Computed)
                toplevel.SetRelativeLayout(new Rect(0, 0, Driver.Cols, Driver.Rows));
            toplevel.LayoutSubviews();
            toplevel.PositionToplevels();
            toplevel.WillPresent();
            EnsuresTopOnFront();
            if (refreshDriver)
            {
                MdiTop?.OnChildLoaded(toplevel);
                toplevel.OnLoaded();
                Refresh();
            }

            NotifyNewRunState?.Invoke(rs);
            return rs;
        }

        /// <summary>
        /// Building block API: completes the execution of a <see cref="Toplevel"/> that was started with <see cref="Begin(Toplevel)"/> .
        /// </summary>
        /// <param name="runState">The <see cref="RunState"/> returned by the <see cref="Begin(Toplevel)"/> method.</param>
        public static void End(RunState runState)
        {
            if (runState == null)
                throw new ArgumentNullException(nameof(runState));

            if (MdiTop != null)
            {
                MdiTop.OnChildUnloaded(runState.Toplevel);
            }
            else
            {
                runState.Toplevel.OnUnloaded();
            }

            // End the RunState.Toplevel 
            // First, take it off the toplevel Stack
            if (toplevels.Count > 0)
            {
                if (toplevels.Peek() != runState.Toplevel)
                {
                    // If there the top of the stack is not the RunState.Toplevel then
                    // this call to End is not balanced with the call to Begin that started the RunState
                    throw new ArgumentException("End must be balanced with calls to Begin");
                }
                toplevels.Pop();
            }

            // Notify that it is closing
            runState.Toplevel?.OnClosed(runState.Toplevel);

            // If there is a MdiTop that is not the RunState.Toplevel then runstate.TopLevel 
            // is a child of MidTop and we should notify the MdiTop that it is closing
            if (MdiTop != null && !(runState.Toplevel).Modal && runState.Toplevel != MdiTop)
            {
                MdiTop.OnChildClosed(runState.Toplevel);
            }

            // Set Current and Top to the next TopLevel on the stack
            if (toplevels.Count == 0)
            {
                Current = null;
                Top = null;
            }
            else
            {
                Current = toplevels.Peek();
                if (toplevels.Count == 1 && Current == MdiTop)
                {
                    MdiTop.OnAllChildClosed();
                }
                else
                {
                    SetCurrentAsTop();
                    runState.Toplevel.OnLeave(Current);
                    Current.OnEnter(runState.Toplevel);
                }
                Refresh();
            }

            runState.Dispose();
        }

        /// <summary>
        /// Shutdown an application initialized with <see cref="Init(ConsoleDriver, IMainLoopDriver)"/>.
        /// </summary>
        /// <remarks>
        /// Shutdown must be called for every call to <see cref="Init(ConsoleDriver, IMainLoopDriver)"/> or <see cref="Application.Run(Toplevel, Func{Exception, bool})"/>
        /// to ensure all resources are cleaned up (Disposed) and terminal settings are restored.
        /// </remarks>
        public static void Shutdown()
        {
            ResetState();
        }

        // Encapsulate all setting of initial state for Application; Having
        // this in a function like this ensures we don't make mistakes in
        // guaranteeing that the state of this singleton is deterministic when Init
        // starts running and after Shutdown returns.
        static void ResetState()
        {
            // Shutdown is the bookend for Init. As such it needs to clean up all resources
            // Init created. Apps that do any threading will need to code defensively for this.
            // e.g. see Issue #537
            foreach (var t in toplevels)
            {
                t.Running = false;
                t.Dispose();
            }
            toplevels.Clear();
            Current = null;
            Top?.Dispose();
            Top = null;

            // BUGBUG: MdiTop is not cleared here, but it should be?

            Driver?.End();
            Driver = null;
            MainLoop = null;
            Iteration = null;
            RootMouseEvent = null;
            RootKeyEvent = null;
            Resized = null;
            _mainThreadId = -1;
            NotifyNewRunState = null;
            NotifyStopRunState = null;
            _initialized = false;
            mouseGrabView = null;

            // Reset synchronization context to allow the user to run async/await,
            // as the main loop has been ended, the synchronization context from 
            // gui.cs does no longer process any callbacks. See #1084 for more details:
            // (https://github.com/gui-cs/Terminal.Gui/issues/1084).
            SynchronizationContext.SetSynchronizationContext(syncContext: null);
        }


        static void Redraw(View view)
        {
            view.Redraw(view.Bounds);
            Driver.Refresh();
        }

        /// <summary>
        /// Triggers a refresh of the entire display.
        /// </summary>
        public static void Refresh()
        {
            Driver.UpdateOffScreen();
            View last = null;
            foreach (var v in toplevels.Reverse())
            {
                if (v.Visible)
                {
                    v.SetNeedsDisplay();
                    v.Redraw(v.Bounds);
                }
                last = v;
            }
            last?.PositionCursor();
            Driver.Refresh();
        }



        /// <summary>
        ///   Building block API: Runs the <see cref="MainLoop"/> for the created <see cref="Toplevel"/>.
        /// </summary>
        /// <remarks>
        ///   Use the <paramref name="wait"/> parameter to control whether this is a blocking or non-blocking call.
        /// </remarks>
        /// <param name="state">The state returned by the <see cref="Begin(Toplevel)"/> method.</param>
        /// <param name="wait">By default this is <see langword="true"/> which will execute the runloop waiting for events, 
        /// if set to <see langword="false"/>, a single iteration will execute.</param>
        public static void RunLoop(RunState state, bool wait = true)
        {
            if (state == null)
                throw new ArgumentNullException(nameof(state));
            if (state.Toplevel == null)
                throw new ObjectDisposedException("state");

            bool firstIteration = true;
            for (state.Toplevel.Running = true; state.Toplevel.Running;)
            {
                if (ExitRunLoopAfterFirstIteration && !firstIteration)
                {
                    return;
                }
                RunMainLoopIteration(ref state, wait, ref firstIteration);
            }
        }

        /// <summary>
        /// Run one iteration of the <see cref="MainLoop"/>.
        /// </summary>
        /// <param name="state">The state returned by <see cref="Begin(Toplevel)"/>.</param>
        /// <param name="wait">If <see langword="true"/> will execute the runloop waiting for events. If <see langword="true"/>
        /// will return after a single iteration.</param>
        /// <param name="firstIteration">Set to <see langword="true"/> if this is the first run loop iteration. Upon return,
        /// it will be set to <see langword="false"/> if at least one iteration happened.</param>
        public static void RunMainLoopIteration(ref RunState state, bool wait, ref bool firstIteration)
        {
            //*master//
            // Весь оригинальный код метода поместим в попытку, потому что иногда 
            // нужно в обработчике сценария завершить приложение, а оно генерирует ошибки.
            //////if (MainLoop.EventsPending(wait))
            //////{
            //////    // Notify Toplevel it's ready
            //////    if (firstIteration)
            //////    {
            //////        state.Toplevel.OnReady();
            //////    }

            //////    MainLoop.MainIteration();
            //////    Iteration?.Invoke();

            //////    EnsureModalOrVisibleAlwaysOnTop(state.Toplevel);
            //////    if (!EnsuresNotModalNotRunningAndNotCurrent(state.Toplevel))
            //////    {
            //////        EnsuresMdiChildOnFrontIfMdiTopNotMostFocused();
            //////    }
            //////    if ((state.Toplevel != Current && Current?.Modal == true)
            //////        || (state.Toplevel != Current && Current?.Modal == false))
            //////    {

            //////        MdiTop?.OnDeactivate(state.Toplevel);
            //////        state.Toplevel = Current;
            //////        MdiTop?.OnActivate(state.Toplevel);
            //////        Top.SetChildNeedsDisplay();
            //////        Refresh();
            //////    }
            //////    if (Driver.EnsureCursorVisibility())
            //////    {
            //////        state.Toplevel.SetNeedsDisplay();
            //////    }
            //////}
            //////else if (!wait)
            //////{
            //////    return;
            //////}
            //////firstIteration = false;

            //////if (state.Toplevel != Top
            //////    && (!Top.NeedDisplay.IsEmpty || Top.ChildNeedsDisplay || Top.LayoutNeeded))
            //////{
            //////    Top.Redraw(Top.Bounds);
            //////    foreach (var top in toplevels.Reverse())
            //////    {
            //////        if (top != Top && top != state.Toplevel)
            //////        {
            //////            top.SetNeedsDisplay();
            //////            top.Redraw(top.Bounds);
            //////        }
            //////    }
            //////    state.Toplevel.SetNeedsDisplay(state.Toplevel.Bounds);
            //////}
            //////if (!state.Toplevel.NeedDisplay.IsEmpty || state.Toplevel.ChildNeedsDisplay || state.Toplevel.LayoutNeeded
            //////    || MdiChildNeedsDisplay())
            //////{

            //////    bool isTopNeedsDisplay;
            //////    do
            //////    {
            //////        state.Toplevel.Redraw(state.Toplevel.Bounds);
            //////        if (DebugDrawBounds)
            //////        {
            //////            DrawBounds(state.Toplevel);
            //////        }
            //////        state.Toplevel.PositionCursor();
            //////        Driver.Refresh();
            //////        isTopNeedsDisplay = IsTopNeedsDisplay(state.Toplevel);
            //////        if (isTopNeedsDisplay)
            //////        {
            //////            Top.Redraw(Top.Bounds);
            //////            state.Toplevel.SetNeedsDisplay();
            //////        }
            //////    } while (isTopNeedsDisplay);
            //////}
            //////else
            //////{
            //////    Driver.UpdateCursor();
            //////}

            //////bool IsTopNeedsDisplay(Toplevel toplevel)
            //////{
            //////    if (toplevel != Top && !toplevel.Modal
            //////        && (!Top.NeedDisplay.IsEmpty || Top.ChildNeedsDisplay || Top.LayoutNeeded))
            //////    {

            //////        return true;
            //////    }
            //////    return false;
            //////}

            try
            {
                if (MainLoop.EventsPending(wait))
                {
                    // Notify Toplevel it's ready
                    if (firstIteration)
                    {
                        state.Toplevel.OnReady();
                    }

                    MainLoop.MainIteration();
                    Iteration?.Invoke();

                    EnsureModalOrVisibleAlwaysOnTop(state.Toplevel);
                    if (!EnsuresNotModalNotRunningAndNotCurrent(state.Toplevel))
                    {
                        EnsuresMdiChildOnFrontIfMdiTopNotMostFocused();
                    }
                    if ((state.Toplevel != Current && Current?.Modal == true)
                        || (state.Toplevel != Current && Current?.Modal == false))
                    {

                        MdiTop?.OnDeactivate(state.Toplevel);
                        state.Toplevel = Current;
                        MdiTop?.OnActivate(state.Toplevel);
                        Top.SetChildNeedsDisplay();
                        Refresh();
                    }
                    if (Driver.EnsureCursorVisibility())
                    {
                        state.Toplevel.SetNeedsDisplay();
                    }
                }
                else if (!wait)
                {
                    return;
                }
                firstIteration = false;

                if (state.Toplevel != Top
                    && (!Top.NeedDisplay.IsEmpty || Top.ChildNeedsDisplay || Top.LayoutNeeded))
                {
                    Top.Redraw(Top.Bounds);
                    foreach (var top in toplevels.Reverse())
                    {
                        if (top != Top && top != state.Toplevel)
                        {
                            top.SetNeedsDisplay();
                            top.Redraw(top.Bounds);
                        }
                    }
                    state.Toplevel.SetNeedsDisplay(state.Toplevel.Bounds);
                }
                if (!state.Toplevel.NeedDisplay.IsEmpty || state.Toplevel.ChildNeedsDisplay || state.Toplevel.LayoutNeeded
                    || MdiChildNeedsDisplay())
                {

                    bool isTopNeedsDisplay;
                    do
                    {
                        state.Toplevel.Redraw(state.Toplevel.Bounds);
                        if (DebugDrawBounds)
                        {
                            DrawBounds(state.Toplevel);
                        }
                        state.Toplevel.PositionCursor();
                        Driver.Refresh();
                        isTopNeedsDisplay = IsTopNeedsDisplay(state.Toplevel);
                        if (isTopNeedsDisplay)
                        {
                            Top.Redraw(Top.Bounds);
                            state.Toplevel.SetNeedsDisplay();
                        }
                    } while (isTopNeedsDisplay);
                }
                else
                {
                    Driver.UpdateCursor();
                }

                bool IsTopNeedsDisplay(Toplevel toplevel)
                {
                    if (toplevel != Top && !toplevel.Modal
                        && (!Top.NeedDisplay.IsEmpty || Top.ChildNeedsDisplay || Top.LayoutNeeded))
                    {

                        return true;
                    }
                    return false;
                }
            }
            catch { }
            //master*//
        }

        static void EnsuresMdiChildOnFrontIfMdiTopNotMostFocused()
        {
            if (MdiTop != null && Current == MdiTop && (MdiTop.MostFocused == null
                || MdiTop.MostFocused.GetType().Name == "ContentView"))
            {

                MoveNext();
            }
        }

        static void EnsureModalOrVisibleAlwaysOnTop(Toplevel toplevel)
        {
            if (!toplevel.Running || (toplevel == Current && toplevel.Visible) || MdiTop == null || toplevels.Peek().Modal)
            {
                return;
            }

            foreach (var top in toplevels.Reverse())
            {
                if (top.Modal && top != Current)
                {
                    MoveCurrent(top);
                    return;
                }
            }
            if (!toplevel.Visible && toplevel == Current)
            {
                MoveNext();
            }
        }

        static bool EnsuresNotModalNotRunningAndNotCurrent(Toplevel curRunStateTop)
        {
            if (MdiTop == null || !curRunStateTop.Running)
            {
                return false;
            }

            foreach (var top in toplevels)
            {
                if (!top.IsMdiContainer && top?.Running == false && top != Current && top?.Modal == false)
                {
                    MoveCurrent(top);
                    return true;
                }
            }

            return false;
        }

        static bool MdiChildNeedsDisplay()
        {
            if (MdiTop == null)
            {
                return false;
            }

            foreach (var top in toplevels)
            {
                if (top != Current && top.Visible && (!top.NeedDisplay.IsEmpty || top.ChildNeedsDisplay || top.LayoutNeeded))
                {
                    MdiTop.SetChildNeedsDisplay();
                    return true;
                }
            }
            return false;
        }

        internal static bool DebugDrawBounds = false;

        // Need to look into why this does not work properly.
        static void DrawBounds(View v)
        {
            v.DrawFrame(v.Frame, padding: 0, fill: false);
            if (v.InternalSubviews != null && v.InternalSubviews.Count > 0)
                foreach (var sub in v.InternalSubviews)
                    DrawBounds(sub);
        }

        /// <summary>
        /// Runs the application by calling <see cref="Run(Toplevel, Func{Exception, bool})"/> with the value of <see cref="Top"/>.
        /// </summary>
        /// <remarks>
        /// See <see cref="Run(Toplevel, Func{Exception, bool})"/> for more details.
        /// </remarks>
        public static void Run(Func<Exception, bool> errorHandler = null)
        {
            Run(Top, errorHandler);
        }

        /// <summary>
        /// Runs the application by calling <see cref="Run(Toplevel, Func{Exception, bool})"/> 
        /// with a new instance of the specified <see cref="Toplevel"/>-derived class.
        /// <para>
        /// Calling <see cref="Init(ConsoleDriver, IMainLoopDriver)"/> first is not needed as this function will initialze the application.
        /// </para>
        /// <para>
        /// <see cref="Shutdown"/> must be called when the application is closing (typically after Run> has 
        /// returned) to ensure resources are cleaned up and terminal settings restored.
        /// </para>
        /// </summary>
        /// <remarks>
        /// See <see cref="Run(Toplevel, Func{Exception, bool})"/> for more details.
        /// </remarks>
        /// <param name="errorHandler"></param>
        /// <param name="driver">The <see cref="ConsoleDriver"/> to use. If not specified the default driver for the
        /// platform will be used (<see cref="WindowsDriver"/>, <see cref="CursesDriver"/>, or <see cref="NetDriver"/>).
        /// This parameteter must be <see langword="null"/> if <see cref="Init(ConsoleDriver, IMainLoopDriver)"/> has already been called. 
        /// </param>
        /// <param name="mainLoopDriver">Specifies the <see cref="MainLoop"/> to use.</param>
        public static void Run<T>(Func<Exception, bool> errorHandler = null, ConsoleDriver driver = null, IMainLoopDriver mainLoopDriver = null) where T : Toplevel, new()
        {
            if (_initialized)
            {
                if (Driver != null)
                {
                    // Init() has been called and we have a driver, so just run the app.
                    var top = new T();
                    var type = top.GetType().BaseType;
                    while (type != typeof(Toplevel) && type != typeof(object))
                    {
                        type = type.BaseType;
                    }
                    if (type != typeof(Toplevel))
                    {
                        throw new ArgumentException($"{top.GetType().Name} must be derived from TopLevel");
                    }
                    Run(top, errorHandler);
                }
                else
                {
                    // This codepath should be impossible because Init(null, null) will select the platform default driver
                    throw new InvalidOperationException("Init() completed without a driver being set (this should be impossible); Run<T>() cannot be called.");
                }
            }
            else
            {
                // Init() has NOT been called.
                InternalInit(() => new T(), driver, mainLoopDriver, calledViaRunT: true);
                Run(Top, errorHandler);
            }
        }

        /// <summary>
        ///   Runs the main loop on the given <see cref="Toplevel"/> container.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     This method is used to start processing events
        ///     for the main application, but it is also used to
        ///     run other modal <see cref="View"/>s such as <see cref="Dialog"/> boxes.
        ///   </para>
        ///   <para>
        ///     To make a <see cref="Run(Toplevel, Func{Exception, bool})"/> stop execution, call <see cref="Application.RequestStop"/>.
        ///   </para>
        ///   <para>
        ///     Calling <see cref="Run(Toplevel, Func{Exception, bool})"/> is equivalent to calling <see cref="Begin(Toplevel)"/>, followed by <see cref="RunLoop(RunState, bool)"/>,
        ///     and then calling <see cref="End(RunState)"/>.
        ///   </para>
        ///   <para>
        ///     Alternatively, to have a program control the main loop and 
        ///     process events manually, call <see cref="Begin(Toplevel)"/> to set things up manually and then
        ///     repeatedly call <see cref="RunLoop(RunState, bool)"/> with the wait parameter set to false. By doing this
        ///     the <see cref="RunLoop(RunState, bool)"/> method will only process any pending events, timers, idle handlers and
        ///     then return control immediately.
        ///   </para>
        ///   <para>
        ///     RELEASE builds only: When <paramref name="errorHandler"/> is <see langword="null"/> any exeptions will be rethrown.  
        ///     Otheriwse, if <paramref name="errorHandler"/> will be called. If <paramref name="errorHandler"/> 
        ///     returns <see langword="true"/> the <see cref="RunLoop(RunState, bool)"/> will resume; otherwise 
        ///     this method will exit.
        ///   </para>
        /// </remarks>
        /// <param name="view">The <see cref="Toplevel"/> to run modally.</param>
        /// <param name="errorHandler">RELEASE builds only: Handler for any unhandled exceptions (resumes when returns true, rethrows when null).</param>
        public static void Run(Toplevel view, Func<Exception, bool> errorHandler = null)
        {
            var resume = true;
            while (resume)
            {
#if !DEBUG
				try {
#endif
                resume = false;
                var runToken = Begin(view);
                // If ExitRunLoopAfterFirstIteration is true then the user must dispose of the runToken
                // by using NotifyStopRunState event.
                RunLoop(runToken);
                if (!ExitRunLoopAfterFirstIteration)
                {
                    End(runToken);
                }
#if !DEBUG
				}
				catch (Exception error)
				{
					if (errorHandler == null)
					{
						throw;
					}
					resume = errorHandler(error);
				}
#endif
            }
        }

        /// <summary>
        /// Stops running the most recent <see cref="Toplevel"/> or the <paramref name="top"/> if provided.
        /// </summary>
        /// <param name="top">The toplevel to request stop.</param>
        /// <remarks>
        ///   <para>
        ///   This will cause <see cref="Application.Run(Func{Exception, bool})"/> to return.
        ///   </para>
        ///   <para>
        ///     Calling <see cref="Application.RequestStop"/> is equivalent to setting the <see cref="Toplevel.Running"/> property on the currently running <see cref="Toplevel"/> to false.
        ///   </para>
        /// </remarks>
        public static void RequestStop(Toplevel top = null)
        {
            if (MdiTop == null || top == null || (MdiTop == null && top != null))
            {
                top = Current;
            }

            if (MdiTop != null && top.IsMdiContainer && top?.Running == true
                && (Current?.Modal == false || (Current?.Modal == true && Current?.Running == false)))
            {

                MdiTop.RequestStop();
            }
            else if (MdiTop != null && top != Current && Current?.Running == true && Current?.Modal == true
              && top.Modal && top.Running)
            {

                var ev = new ToplevelClosingEventArgs(Current);
                Current.OnClosing(ev);
                if (ev.Cancel)
                {
                    return;
                }
                ev = new ToplevelClosingEventArgs(top);
                top.OnClosing(ev);
                if (ev.Cancel)
                {
                    return;
                }
                Current.Running = false;
                OnNotifyStopRunState(Current);
                top.Running = false;
                OnNotifyStopRunState(top);
            }
            else if ((MdiTop != null && top != MdiTop && top != Current && Current?.Modal == false
              && Current?.Running == true && !top.Running)
              || (MdiTop != null && top != MdiTop && top != Current && Current?.Modal == false
              && Current?.Running == false && !top.Running && toplevels.ToArray()[1].Running))
            {

                MoveCurrent(top);
            }
            else if (MdiTop != null && Current != top && Current?.Running == true && !top.Running
              && Current?.Modal == true && top.Modal)
            {
                // The Current and the top are both modal so needed to set the Current.Running to false too.
                Current.Running = false;
                OnNotifyStopRunState(Current);
            }
            else if (MdiTop != null && Current == top && MdiTop?.Running == true && Current?.Running == true && top.Running
              && Current?.Modal == true && top.Modal)
            {
                // The MdiTop was requested to stop inside a modal toplevel which is the Current and top,
                // both are the same, so needed to set the Current.Running to false too.
                Current.Running = false;
                OnNotifyStopRunState(Current);
            }
            else
            {
                Toplevel currentTop;
                if (top == Current || (Current?.Modal == true && !top.Modal))
                {
                    currentTop = Current;
                }
                else
                {
                    currentTop = top;
                }
                if (!currentTop.Running)
                {
                    return;
                }
                var ev = new ToplevelClosingEventArgs(currentTop);
                currentTop.OnClosing(ev);
                if (ev.Cancel)
                {
                    return;
                }
                currentTop.Running = false;
                OnNotifyStopRunState(currentTop);
            }
        }

        static void OnNotifyStopRunState(Toplevel top)
        {
            if (ExitRunLoopAfterFirstIteration)
            {
                NotifyStopRunState?.Invoke(top);
            }
        }

        /// <summary>
        /// Event arguments for the <see cref="Application.Resized"/> event.
        /// </summary>
        public class ResizedEventArgs : EventArgs
        {
            /// <summary>
            /// The number of rows in the resized terminal.
            /// </summary>
            public int Rows { get; set; }
            /// <summary>
            /// The number of columns in the resized terminal.
            /// </summary>
            public int Cols { get; set; }
        }

        /// <summary>
        /// Invoked when the terminal was resized. The new size of the terminal is provided.
        /// </summary>
        public static Action<ResizedEventArgs> Resized;

        static void TerminalResized()
        {
            var full = new Rect(0, 0, Driver.Cols, Driver.Rows);
            SetToplevelsSize(full);
            Resized?.Invoke(new ResizedEventArgs() { Cols = full.Width, Rows = full.Height });
            Driver.Clip = full;
            foreach (var t in toplevels)
            {
                t.SetRelativeLayout(full);
                t.LayoutSubviews();
                t.PositionToplevels();
                t.OnResized(full.Size);
            }
            Refresh();
        }

        static void SetToplevelsSize(Rect full)
        {
            if (MdiTop == null)
            {
                foreach (var t in toplevels)
                {
                    if (t?.SuperView == null && !t.Modal)
                    {
                        t.Frame = full;
                        t.Width = full.Width;
                        t.Height = full.Height;
                    }
                }
            }
            else
            {
                Top.Frame = full;
                Top.Width = full.Width;
                Top.Height = full.Height;
            }
        }

        static bool SetCurrentAsTop()
        {
            if (MdiTop == null && Current != Top && Current?.SuperView == null && Current?.Modal == false)
            {
                if (Current.Frame != new Rect(0, 0, Driver.Cols, Driver.Rows))
                {
                    Current.Frame = new Rect(0, 0, Driver.Cols, Driver.Rows);
                }
                Top = Current;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Move to the next Mdi child from the <see cref="MdiTop"/>.
        /// </summary>
        public static void MoveNext()
        {
            if (MdiTop != null && !Current.Modal)
            {
                lock (toplevels)
                {
                    toplevels.MoveNext();
                    var isMdi = false;
                    while (toplevels.Peek() == MdiTop || !toplevels.Peek().Visible)
                    {
                        if (!isMdi && toplevels.Peek() == MdiTop)
                        {
                            isMdi = true;
                        }
                        else if (isMdi && toplevels.Peek() == MdiTop)
                        {
                            MoveCurrent(Top);
                            break;
                        }
                        toplevels.MoveNext();
                    }
                    Current = toplevels.Peek();
                }
            }
        }

        /// <summary>
        /// Move to the previous Mdi child from the <see cref="MdiTop"/>.
        /// </summary>
        public static void MovePrevious()
        {
            if (MdiTop != null && !Current.Modal)
            {
                lock (toplevels)
                {
                    toplevels.MovePrevious();
                    var isMdi = false;
                    while (toplevels.Peek() == MdiTop || !toplevels.Peek().Visible)
                    {
                        if (!isMdi && toplevels.Peek() == MdiTop)
                        {
                            isMdi = true;
                        }
                        else if (isMdi && toplevels.Peek() == MdiTop)
                        {
                            MoveCurrent(Top);
                            break;
                        }
                        toplevels.MovePrevious();
                    }
                    Current = toplevels.Peek();
                }
            }
        }

        internal static bool ShowChild(Toplevel top)
        {
            if (Current == top)
            {
                return false;
            }

            if (top.Visible && MdiTop != null && Current?.Modal == false)
            {
                lock (toplevels)
                {
                    toplevels.MoveTo(top, 0, new ToplevelEqualityComparer());
                    Current = top;
                }
                return true;
            }
            return false;
        }

        /// <summary>
        /// Wakes up the mainloop that might be waiting on input, must be thread safe.
        /// </summary>
        public static void DoEvents()
        {
            MainLoop.Driver.Wakeup();
        }

        /// <summary>
        /// Ensures that the superview of the most focused view is on front.
        /// </summary>
        public static void EnsuresTopOnFront()
        {
            if (MdiTop != null)
            {
                return;
            }
            var top = FindTopFromView(Top?.MostFocused);
            if (top != null && Top.Subviews.Count > 1 && Top.Subviews[Top.Subviews.Count - 1] != top)
            {
                Top.BringSubviewToFront(top);
            }
        }

        internal static List<CultureInfo> GetSupportedCultures()
        {
            CultureInfo[] culture = CultureInfo.GetCultures(CultureTypes.AllCultures);

            // Get the assembly
            Assembly assembly = Assembly.GetExecutingAssembly();

            //Find the location of the assembly
            string assemblyLocation = AppDomain.CurrentDomain.BaseDirectory;

            // Find the resource file name of the assembly
            string resourceFilename = $"{Path.GetFileNameWithoutExtension(assembly.Location)}.resources.dll";

            // Return all culture for which satellite folder found with culture code.
            return culture.Where(cultureInfo =>
                assemblyLocation != null &&
                Directory.Exists(Path.Combine(assemblyLocation, cultureInfo.Name)) &&
                File.Exists(Path.Combine(assemblyLocation, cultureInfo.Name, resourceFilename))
            ).ToList();
        }
    }
    //=======================================================================
    /// <summary>
    /// Renders an overlay on another view at a given point that allows selecting
    /// from a range of 'autocomplete' options.
    /// </summary>
    public abstract class Autocomplete : IAutocomplete
    {

        private class Popup : View
        {
            Autocomplete autocomplete;

            public Popup(Autocomplete autocomplete)
            {
                this.autocomplete = autocomplete;
                CanFocus = true;
                WantMousePositionReports = true;
            }

            public override Rect Frame
            {
                get => base.Frame;
                set
                {
                    base.Frame = value;
                    X = value.X;
                    Y = value.Y;
                    Width = value.Width;
                    Height = value.Height;
                }
            }

            public override void Redraw(Rect bounds)
            {
                if (autocomplete.LastPopupPos == null)
                {
                    return;
                }

                autocomplete.RenderOverlay((Point)autocomplete.LastPopupPos);
            }

            public override bool MouseEvent(MouseEvent mouseEvent)
            {
                return autocomplete.MouseEvent(mouseEvent);
            }
        }

        private View top, popup;
        private bool closed;
        int toRenderLength;

        private Point? LastPopupPos { get; set; }

        private ColorScheme colorScheme;
        private View hostControl;

        /// <summary>
        /// The host control to handle.
        /// </summary>
        public virtual View HostControl
        {
            get => hostControl;
            set
            {
                hostControl = value;
                top = hostControl.SuperView;
                if (top != null)
                {
                    top.DrawContent += Top_DrawContent;
                    top.DrawContentComplete += Top_DrawContentComplete;
                    top.Removed += Top_Removed;
                }
            }
        }

        private void Top_Removed(View obj)
        {
            Visible = false;
            ManipulatePopup();
        }

        private void Top_DrawContentComplete(Rect obj)
        {
            ManipulatePopup();
        }

        private void Top_DrawContent(Rect obj)
        {
            if (!closed)
            {
                ReopenSuggestions();
            }
            ManipulatePopup();
            if (Visible)
            {
                top.BringSubviewToFront(popup);
            }
        }

        private void ManipulatePopup()
        {
            if (Visible && popup == null)
            {
                popup = new Popup(this)
                {
                    Frame = Rect.Empty
                };
                top?.Add(popup);
            }

            if (!Visible && popup != null)
            {
                top.Remove(popup);
                popup.Dispose();
                popup = null;
            }
        }

        /// <summary>
        /// Gets or sets If the popup is displayed inside or outside the host limits.
        /// </summary>
        public bool PopupInsideContainer { get; set; } = true;

        /// <summary>
        /// The maximum width of the autocomplete dropdown
        /// </summary>
        public virtual int MaxWidth { get; set; } = 10;

        /// <summary>
        /// The maximum number of visible rows in the autocomplete dropdown to render
        /// </summary>
        public virtual int MaxHeight { get; set; } = 6;

        /// <summary>
        /// True if the autocomplete should be considered open and visible
        /// </summary>
        public virtual bool Visible { get; set; }

        /// <summary>
        /// The strings that form the current list of suggestions to render
        /// based on what the user has typed so far.
        /// </summary>
        public virtual ReadOnlyCollection<string> Suggestions { get; set; } = new ReadOnlyCollection<string>(new string[0]);

        /// <summary>
        /// The full set of all strings that can be suggested.
        /// </summary>
        /// <returns></returns>
        public virtual List<string> AllSuggestions { get; set; } = new List<string>();

        /// <summary>
        /// The currently selected index into <see cref="Suggestions"/> that the user has highlighted
        /// </summary>
        public virtual int SelectedIdx { get; set; }

        /// <summary>
        /// When more suggestions are available than can be rendered the user
        /// can scroll down the dropdown list.  This indicates how far down they
        /// have gone
        /// </summary>
        public virtual int ScrollOffset { get; set; }

        /// <summary>
        /// The colors to use to render the overlay.  Accessing this property before
        /// the Application has been initialized will cause an error
        /// </summary>
        public virtual ColorScheme ColorScheme
        {
            get
            {
                if (colorScheme == null)
                {
                    colorScheme = Colors.Menu;
                }
                return colorScheme;
            }
            set
            {
                colorScheme = value;
            }
        }

        /// <summary>
        /// The key that the user must press to accept the currently selected autocomplete suggestion
        /// </summary>
        public virtual Key SelectionKey { get; set; } = Key.Enter;

        /// <summary>
        /// The key that the user can press to close the currently popped autocomplete menu
        /// </summary>
        public virtual Key CloseKey { get; set; } = Key.Esc;

        /// <summary>
        /// The key that the user can press to reopen the currently popped autocomplete menu
        /// </summary>
        public virtual Key Reopen { get; set; } = Key.Space | Key.CtrlMask | Key.AltMask;

        /// <summary>
        /// Renders the autocomplete dialog inside or outside the given <see cref="HostControl"/> at the
        /// given point.
        /// </summary>
        /// <param name="renderAt"></param>
        public virtual void RenderOverlay(Point renderAt)
        {
            if (!Visible || HostControl?.HasFocus == false || Suggestions.Count == 0)
            {
                LastPopupPos = null;
                Visible = false;
                return;
            }

            LastPopupPos = renderAt;

            int height, width;

            if (PopupInsideContainer)
            {
                // don't overspill vertically
                height = Math.Min(HostControl.Bounds.Height - renderAt.Y, MaxHeight);
                // There is no space below, lets see if can popup on top
                if (height < Suggestions.Count && HostControl.Bounds.Height - renderAt.Y >= height)
                {
                    // Verifies that the upper limit available is greater than the lower limit
                    if (renderAt.Y > HostControl.Bounds.Height - renderAt.Y)
                    {
                        renderAt.Y = Math.Max(renderAt.Y - Math.Min(Suggestions.Count + 1, MaxHeight + 1), 0);
                        height = Math.Min(Math.Min(Suggestions.Count, MaxHeight), LastPopupPos.Value.Y - 1);
                    }
                }
            }
            else
            {
                // don't overspill vertically
                height = Math.Min(Math.Min(top.Bounds.Height - HostControl.Frame.Bottom, MaxHeight), Suggestions.Count);
                // There is no space below, lets see if can popup on top
                if (height < Suggestions.Count && HostControl.Frame.Y - top.Frame.Y >= height)
                {
                    // Verifies that the upper limit available is greater than the lower limit
                    if (HostControl.Frame.Y > top.Bounds.Height - HostControl.Frame.Y)
                    {
                        renderAt.Y = Math.Max(HostControl.Frame.Y - Math.Min(Suggestions.Count, MaxHeight), 0);
                        height = Math.Min(Math.Min(Suggestions.Count, MaxHeight), HostControl.Frame.Y);
                    }
                }
                else
                {
                    renderAt.Y = HostControl.Frame.Bottom;
                }
            }

            if (ScrollOffset > Suggestions.Count - height)
            {
                ScrollOffset = 0;
            }
            var toRender = Suggestions.Skip(ScrollOffset).Take(height).ToArray();
            toRenderLength = toRender.Length;

            if (toRender.Length == 0)
            {
                return;
            }

            width = Math.Min(MaxWidth, toRender.Max(s => s.Length));

            if (PopupInsideContainer)
            {
                // don't overspill horizontally, let's see if can be displayed on the left
                if (width > HostControl.Bounds.Width - renderAt.X)
                {
                    // Verifies that the left limit available is greater than the right limit
                    if (renderAt.X > HostControl.Bounds.Width - renderAt.X)
                    {
                        renderAt.X -= Math.Min(width, LastPopupPos.Value.X);
                        width = Math.Min(width, LastPopupPos.Value.X);
                    }
                    else
                    {
                        width = Math.Min(width, HostControl.Bounds.Width - renderAt.X);
                    }
                }
            }
            else
            {
                // don't overspill horizontally, let's see if can be displayed on the left
                if (width > top.Bounds.Width - (renderAt.X + HostControl.Frame.X))
                {
                    // Verifies that the left limit available is greater than the right limit
                    if (renderAt.X + HostControl.Frame.X > top.Bounds.Width - (renderAt.X + HostControl.Frame.X))
                    {
                        renderAt.X -= Math.Min(width, LastPopupPos.Value.X);
                        width = Math.Min(width, LastPopupPos.Value.X);
                    }
                    else
                    {
                        width = Math.Min(width, top.Bounds.Width - renderAt.X);
                    }
                }
            }

            if (PopupInsideContainer)
            {
                popup.Frame = new Rect(
                    new Point(HostControl.Frame.X + renderAt.X, HostControl.Frame.Y + renderAt.Y),
                    new Size(width, height));
            }
            else
            {
                popup.Frame = new Rect(
                    new Point(HostControl.Frame.X + renderAt.X, renderAt.Y),
                    new Size(width, height));
            }

            popup.Move(0, 0);

            for (int i = 0; i < toRender.Length; i++)
            {

                if (i == SelectedIdx - ScrollOffset)
                {
                    Application.Driver.SetAttribute(ColorScheme.Focus);
                }
                else
                {
                    Application.Driver.SetAttribute(ColorScheme.Normal);
                }

                popup.Move(0, i);

                var text = TextFormatter.ClipOrPad(toRender[i], width);

                Application.Driver.AddStr(text);
            }
        }

        /// <summary>
        /// Updates <see cref="SelectedIdx"/> to be a valid index within <see cref="Suggestions"/>
        /// </summary>
        public virtual void EnsureSelectedIdxIsValid()
        {
            SelectedIdx = Math.Max(0, Math.Min(Suggestions.Count - 1, SelectedIdx));

            // if user moved selection up off top of current scroll window
            if (SelectedIdx < ScrollOffset)
            {
                ScrollOffset = SelectedIdx;
            }

            // if user moved selection down past bottom of current scroll window
            while (toRenderLength > 0 && SelectedIdx >= ScrollOffset + toRenderLength)
            {
                ScrollOffset++;
            }
        }

        /// <summary>
        /// Handle key events before <see cref="HostControl"/> e.g. to make key events like
        /// up/down apply to the autocomplete control instead of changing the cursor position in
        /// the underlying text view.
        /// </summary>
        /// <param name="kb">The key event.</param>
        /// <returns><c>true</c>if the key can be handled <c>false</c>otherwise.</returns>
        public virtual bool ProcessKey(KeyEvent kb)
        {
            if (IsWordChar((char)kb.Key))
            {
                Visible = true;
                closed = false;
                return false;
            }

            if (kb.Key == Reopen)
            {
                return ReopenSuggestions();
            }

            if (closed || Suggestions.Count == 0)
            {
                Visible = false;
                if (!closed)
                {
                    Close();
                }
                return false;
            }

            if (kb.Key == Key.CursorDown)
            {
                MoveDown();
                return true;
            }

            if (kb.Key == Key.CursorUp)
            {
                MoveUp();
                return true;
            }

            if (kb.Key == Key.CursorLeft || kb.Key == Key.CursorRight)
            {
                GenerateSuggestions(kb.Key == Key.CursorLeft ? -1 : 1);
                if (Suggestions.Count == 0)
                {
                    Visible = false;
                    if (!closed)
                    {
                        Close();
                    }
                }
                return false;
            }

            if (kb.Key == SelectionKey)
            {
                return Select();
            }

            if (kb.Key == CloseKey)
            {
                Close();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Handle mouse events before <see cref="HostControl"/> e.g. to make mouse events like
        /// report/click apply to the autocomplete control instead of changing the cursor position in
        /// the underlying text view.
        /// </summary>
        /// <param name="me">The mouse event.</param>
        /// <param name="fromHost">If was called from the popup or from the host.</param>
        /// <returns><c>true</c>if the mouse can be handled <c>false</c>otherwise.</returns>
        public virtual bool MouseEvent(MouseEvent me, bool fromHost = false)
        {
            if (fromHost)
            {
                if (!Visible)
                {
                    return false;
                }
                GenerateSuggestions();
                if (Visible && Suggestions.Count == 0)
                {
                    Visible = false;
                    HostControl?.SetNeedsDisplay();
                    return true;
                }
                else if (!Visible && Suggestions.Count > 0)
                {
                    Visible = true;
                    HostControl?.SetNeedsDisplay();
                    Application.UngrabMouse();
                    return false;
                }
                else
                {
                    // not in the popup
                    if (Visible && HostControl != null)
                    {
                        Visible = false;
                        closed = false;
                    }
                    HostControl?.SetNeedsDisplay();
                }
                return false;
            }

            if (popup == null || Suggestions.Count == 0)
            {
                ManipulatePopup();
                return false;
            }

            if (me.Flags == MouseFlags.ReportMousePosition)
            {
                RenderSelectedIdxByMouse(me);
                return true;
            }

            if (me.Flags == MouseFlags.Button1Clicked)
            {
                SelectedIdx = me.Y - ScrollOffset;
                return Select();
            }

            if (me.Flags == MouseFlags.WheeledDown)
            {
                MoveDown();
                return true;
            }

            if (me.Flags == MouseFlags.WheeledUp)
            {
                MoveUp();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Render the current selection in the Autocomplete context menu by the mouse reporting.
        /// </summary>
        /// <param name="me"></param>
        protected void RenderSelectedIdxByMouse(MouseEvent me)
        {
            if (SelectedIdx != me.Y - ScrollOffset)
            {
                SelectedIdx = me.Y - ScrollOffset;
                if (LastPopupPos != null)
                {
                    RenderOverlay((Point)LastPopupPos);
                }
            }
        }

        /// <summary>
        /// Clears <see cref="Suggestions"/>
        /// </summary>
        public virtual void ClearSuggestions()
        {
            Suggestions = Enumerable.Empty<string>().ToList().AsReadOnly();
        }


        /// <summary>
        /// Populates <see cref="Suggestions"/> with all strings in <see cref="AllSuggestions"/> that
        /// match with the current cursor position/text in the <see cref="HostControl"/>
        /// </summary>
        /// <param name="columnOffset">The column offset.</param>
        public virtual void GenerateSuggestions(int columnOffset = 0)
        {
            // if there is nothing to pick from
            if (AllSuggestions.Count == 0)
            {
                ClearSuggestions();
                return;
            }

            var currentWord = GetCurrentWord(columnOffset);

            if (string.IsNullOrWhiteSpace(currentWord))
            {
                ClearSuggestions();
            }
            else
            {
                Suggestions = AllSuggestions.Where(o =>
               o.StartsWith(currentWord, StringComparison.CurrentCultureIgnoreCase) &&
               !o.Equals(currentWord, StringComparison.CurrentCultureIgnoreCase)
                ).ToList().AsReadOnly();

                EnsureSelectedIdxIsValid();
            }
        }


        /// <summary>
        /// Return true if the given symbol should be considered part of a word
        /// and can be contained in matches.  Base behavior is to use <see cref="char.IsLetterOrDigit(char)"/>
        /// </summary>
        /// <param name="rune"></param>
        /// <returns></returns>
        public virtual bool IsWordChar(Rune rune)
        {
            return Char.IsLetterOrDigit((char)rune);
        }

        /// <summary>
        /// Completes the autocomplete selection process.  Called when user hits the <see cref="SelectionKey"/>.
        /// </summary>
        /// <returns></returns>
        protected bool Select()
        {
            if (SelectedIdx >= 0 && SelectedIdx < Suggestions.Count)
            {
                var accepted = Suggestions[SelectedIdx];

                return InsertSelection(accepted);

            }

            return false;
        }

        /// <summary>
        /// Called when the user confirms a selection at the current cursor location in
        /// the <see cref="HostControl"/>.  The <paramref name="accepted"/> string
        /// is the full autocomplete word to be inserted.  Typically a host will have to
        /// remove some characters such that the <paramref name="accepted"/> string 
        /// completes the word instead of simply being appended.
        /// </summary>
        /// <param name="accepted"></param>
        /// <returns>True if the insertion was possible otherwise false</returns>
        protected virtual bool InsertSelection(string accepted)
        {
            var typedSoFar = GetCurrentWord() ?? "";

            if (typedSoFar.Length < accepted.Length)
            {

                // delete the text
                for (int i = 0; i < typedSoFar.Length; i++)
                {
                    DeleteTextBackwards();
                }

                InsertText(accepted);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Returns the currently selected word from the <see cref="HostControl"/>.
        /// <para>
        /// When overriding this method views can make use of <see cref="IdxToWord(List{Rune}, int, int)"/>
        /// </para>
        /// </summary>
        /// <param name="columnOffset">The column offset.</param>
        /// <returns></returns>
        protected abstract string GetCurrentWord(int columnOffset = 0);

        /// <summary>
        /// <para>
        /// Given a <paramref name="line"/> of characters, returns the word which ends at <paramref name="idx"/> 
        /// or null.  Also returns null if the <paramref name="idx"/> is positioned in the middle of a word.
        /// </para>
        /// 
        /// <para>
        /// Use this method to determine whether autocomplete should be shown when the cursor is at
        /// a given point in a line and to get the word from which suggestions should be generated.
        /// Use the <paramref name="columnOffset"/> to indicate if search the word at left (negative),
        /// at right (positive) or at the current column (zero) which is the default.
        /// </para>
        /// </summary>
        /// <param name="line"></param>
        /// <param name="idx"></param>
        /// <param name="columnOffset"></param>
        /// <returns></returns>
        protected virtual string IdxToWord(List<Rune> line, int idx, int columnOffset = 0)
        {
            StringBuilder sb = new StringBuilder();
            var endIdx = idx;

            // get the ending word index
            while (endIdx < line.Count)
            {
                if (IsWordChar(line[endIdx]))
                {
                    endIdx++;
                }
                else
                {
                    break;
                }
            }

            // It isn't a word char then there is no way to autocomplete that word
            if (endIdx == idx && columnOffset != 0)
            {
                return null;
            }

            // we are at the end of a word.  Work out what has been typed so far
            while (endIdx-- > 0)
            {
                if (IsWordChar(line[endIdx]))
                {
                    sb.Insert(0, (char)line[endIdx]);
                }
                else
                {
                    break;
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Deletes the text backwards before insert the selected text in the <see cref="HostControl"/>.
        /// </summary>
        protected abstract void DeleteTextBackwards();

        /// <summary>
        /// Inser the selected text in the <see cref="HostControl"/>.
        /// </summary>
        /// <param name="accepted"></param>
        protected abstract void InsertText(string accepted);

        /// <summary>
        /// Closes the Autocomplete context menu if it is showing and <see cref="ClearSuggestions"/>
        /// </summary>
        protected void Close()
        {
            ClearSuggestions();
            Visible = false;
            closed = true;
            HostControl?.SetNeedsDisplay();
            ManipulatePopup();
        }

        /// <summary>
        /// Moves the selection in the Autocomplete context menu up one
        /// </summary>
        protected void MoveUp()
        {
            SelectedIdx--;
            if (SelectedIdx < 0)
            {
                SelectedIdx = Suggestions.Count - 1;
            }
            EnsureSelectedIdxIsValid();
            HostControl?.SetNeedsDisplay();
        }

        /// <summary>
        /// Moves the selection in the Autocomplete context menu down one
        /// </summary>
        protected void MoveDown()
        {
            SelectedIdx++;
            if (SelectedIdx > Suggestions.Count - 1)
            {
                SelectedIdx = 0;
            }
            EnsureSelectedIdxIsValid();
            HostControl?.SetNeedsDisplay();
        }

        /// <summary>
        /// Reopen the popup after it has been closed.
        /// </summary>
        /// <returns></returns>
        protected bool ReopenSuggestions()
        {
            GenerateSuggestions();
            if (Suggestions.Count > 0)
            {
                Visible = true;
                closed = false;
                HostControl?.SetNeedsDisplay();
                return true;
            }
            return false;
        }
    }
    //=======================================================================
    /// <summary>
    /// Specifies the border style for a <see cref="View"/> and to be used by the <see cref="Border"/> class.
    /// </summary>
    public enum BorderStyle
    {
        /// <summary>
        /// No border is drawn.
        /// </summary>
        None,
        /// <summary>
        /// The border is drawn with a single line limits.
        /// </summary>
        Single,
        /// <summary>
        /// The border is drawn with a double line limits.
        /// </summary>
        Double,
        /// <summary>
        /// The border is drawn with a single line and rounded corners limits.
        /// </summary>
        Rounded
    }

    /// <summary>
    /// Describes the thickness of a frame around a rectangle. Four <see cref="int"/> values describe
    ///  the <see cref="Left"/>, <see cref="Top"/>, <see cref="Right"/>, and <see cref="Bottom"/> sides
    ///  of the rectangle, respectively.
    /// </summary>
    public struct Thickness
    {
        /// <summary>
        /// Gets or sets the width, in integers, of the left side of the bounding rectangle.
        /// </summary>
        public int Left;
        /// <summary>
        /// Gets or sets the width, in integers, of the upper side of the bounding rectangle.
        /// </summary>
        public int Top;
        /// <summary>
        /// Gets or sets the width, in integers, of the right side of the bounding rectangle.
        /// </summary>
        public int Right;
        /// <summary>
        /// Gets or sets the width, in integers, of the lower side of the bounding rectangle.
        /// </summary>
        public int Bottom;

        /// <summary>
        /// Initializes a new instance of the <see cref="Thickness"/> structure that has the
        ///  specified uniform length on each side.
        /// </summary>
        /// <param name="length"></param>
        public Thickness(int length)
        {
            if (length < 0)
            {
                throw new ArgumentException("Invalid value for this property.");
            }

            Left = Top = Right = Bottom = length;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Thickness"/> structure that has specific
        ///  lengths (supplied as a <see cref="int"/>) applied to each side of the rectangle.
        /// </summary>
        /// <param name="left"></param>
        /// <param name="top"></param>
        /// <param name="right"></param>
        /// <param name="bottom"></param>
        public Thickness(int left, int top, int right, int bottom)
        {
            if (left < 0 || top < 0 || right < 0 || bottom < 0)
            {
                throw new ArgumentException("Invalid value for this property.");
            }

            Left = left;
            Top = top;
            Right = right;
            Bottom = bottom;
        }

        /// <summary>Returns the fully qualified type name of this instance.</summary>
        /// <returns>The fully qualified type name.</returns>
        public override string ToString()
        {
            return $"(Left={Left},Top={Top},Right={Right},Bottom={Bottom})";
        }
    }

    /// <summary>
    /// Draws a border, background, or both around another element.
    /// </summary>
    public class Border
    {
        private int marginFrame => DrawMarginFrame ? 1 : 0;

        /// <summary>
        /// A sealed <see cref="Toplevel"/> derived class to implement <see cref="Border"/> feature.
        /// This is only a wrapper to get borders on a toplevel and is recommended using another
        /// derived, like <see cref="Window"/> where is possible to have borders with or without
        /// border line or spacing around.
        /// </summary>
        public sealed class ToplevelContainer : Toplevel
        {
            /// <inheritdoc/>
            public override Border Border
            {
                get => base.Border;
                set
                {
                    if (base.Border != null && base.Border.Child != null && value.Child == null)
                    {
                        value.Child = base.Border.Child;
                    }
                    base.Border = value;
                    if (value == null)
                    {
                        return;
                    }
                    Rect frame;
                    if (Border.Child != null && (Border.Child.Width is Dim || Border.Child.Height is Dim))
                    {
                        frame = Rect.Empty;
                    }
                    else
                    {
                        frame = Frame;
                    }
                    AdjustContentView(frame);

                    Border.BorderChanged += Border_BorderChanged;
                }
            }

            void Border_BorderChanged(Border border)
            {
                Rect frame;
                if (Border.Child != null && (Border.Child.Width is Dim || Border.Child.Height is Dim))
                {
                    frame = Rect.Empty;
                }
                else
                {
                    frame = Frame;
                }
                AdjustContentView(frame);
            }

            /// <summary>
            /// Initializes with default null values.
            /// </summary>
            public ToplevelContainer() : this(null, string.Empty) { }

            /// <summary>
            /// Initializes a <see cref="ToplevelContainer"/> with a <see cref="LayoutStyle.Computed"/>
            /// </summary>
            /// <param name="border">The border.</param>
            /// <param name="title">The title.</param>
            public ToplevelContainer(Border border, string title = null)
            {
                Initialize(Rect.Empty, border, title ?? string.Empty);
            }

            /// <summary>
            /// Initializes a <see cref="ToplevelContainer"/> with a <see cref="LayoutStyle.Absolute"/>
            /// </summary>
            /// <param name="frame">The frame.</param>
            /// <param name="border">The border.</param>
            /// <param name="title">The title.</param>
            public ToplevelContainer(Rect frame, Border border, string title = null) : base(frame)
            {
                Initialize(frame, border, title ?? string.Empty);
            }

            private void Initialize(Rect frame, Border border, string title)
            {
                ColorScheme = Colors.TopLevel;
                if (border == null)
                {
                    Border = new Border()
                    {
                        BorderStyle = BorderStyle.Single,
                        Title = (ustring)title
                    };
                }
                else
                {
                    Border = border;
                }
                AdjustContentView(frame);
            }

            void AdjustContentView(Rect frame)
            {
                var borderLength = Border.DrawMarginFrame ? 1 : 0;
                var sumPadding = Border.GetSumThickness();
                var wp = new Point();
                var wb = new Size();
                if (frame == Rect.Empty)
                {
                    wp.X = borderLength + sumPadding.Left;
                    wp.Y = borderLength + sumPadding.Top;
                    wb.Width = borderLength + sumPadding.Right;
                    wb.Height = borderLength + sumPadding.Bottom;
                    if (Border.Child == null)
                    {
                        Border.Child = new ChildContentView(this)
                        {
                            X = wp.X,
                            Y = wp.Y,
                            Width = Dim.Fill(wb.Width),
                            Height = Dim.Fill(wb.Height)
                        };
                    }
                    else
                    {
                        Border.Child.X = wp.X;
                        Border.Child.Y = wp.Y;
                        Border.Child.Width = Dim.Fill(wb.Width);
                        Border.Child.Height = Dim.Fill(wb.Height);
                    }
                }
                else
                {
                    wb.Width = (2 * borderLength) + sumPadding.Right + sumPadding.Left;
                    wb.Height = (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
                    var cFrame = new Rect(borderLength + sumPadding.Left, borderLength + sumPadding.Top, frame.Width - wb.Width, frame.Height - wb.Height);
                    if (Border.Child == null)
                    {
                        Border.Child = new ChildContentView(cFrame, this);
                    }
                    else
                    {
                        Border.Child.Frame = cFrame;
                    }
                }
                if (Subviews?.Count == 0)
                    base.Add(Border.Child);
                Border.ChildContainer = this;
            }

            /// <inheritdoc/>
            public override void Add(View view)
            {
                Border.Child.Add(view);
                if (view.CanFocus)
                {
                    CanFocus = true;
                }
                AddMenuStatusBar(view);
            }

            /// <inheritdoc/>
            public override void Remove(View view)
            {
                if (view == null)
                {
                    return;
                }

                SetNeedsDisplay();
                var touched = view.Frame;
                if (view == Border.Child)
                {
                    base.Remove(view);
                }
                else
                {
                    Border.Child.Remove(view);
                }

                if (Border.Child.InternalSubviews.Count < 1)
                {
                    CanFocus = false;
                }
                RemoveMenuStatusBar(view);
            }

            /// <inheritdoc/>
            public override void RemoveAll()
            {
                Border.Child.RemoveAll();
            }

            /// <inheritdoc/>
            public override void Redraw(Rect bounds)
            {
                if (!NeedDisplay.IsEmpty)
                {
                    Driver.SetAttribute(GetNormalColor());
                    Clear();
                }
                var savedClip = Border.Child.ClipToBounds();
                Border.Child.Redraw(Border.Child.Bounds);
                Driver.Clip = savedClip;

                ClearLayoutNeeded();
                ClearNeedsDisplay();

                Driver.SetAttribute(GetNormalColor());
                Border.DrawContent(this, false);
                if (HasFocus)
                    Driver.SetAttribute(ColorScheme.HotNormal);
                if (Border.DrawMarginFrame)
                {
                    if (!ustring.IsNullOrEmpty(Border.Title))
                        Border.DrawTitle(this);
                    else
                        Border.DrawTitle(this, Frame);
                }
                Driver.SetAttribute(GetNormalColor());

                // Checks if there are any SuperView view which intersect with this window.
                if (SuperView != null)
                {
                    SuperView.SetNeedsLayout();
                    SuperView.SetNeedsDisplay();
                }
            }

            /// <inheritdoc/>
            public override void OnCanFocusChanged()
            {
                if (Border?.Child != null)
                {
                    Border.Child.CanFocus = CanFocus;
                }
                base.OnCanFocusChanged();
            }
        }

        private class ChildContentView : View
        {
            View instance;

            public ChildContentView(Rect frame, View instance) : base(frame)
            {
                this.instance = instance;
            }
            public ChildContentView(View instance)
            {
                this.instance = instance;
            }

            public override bool MouseEvent(MouseEvent mouseEvent)
            {
                return instance.MouseEvent(mouseEvent);
            }
        }

        /// <summary>
        /// Invoked when any property of Border changes (except <see cref="Child"/>).
        /// </summary>
        public event Action<Border> BorderChanged;

        private BorderStyle borderStyle;
        private bool drawMarginFrame;
        private Thickness borderThickness;
        private Color? borderBrush;
        private Color? background;
        private Thickness padding;
        private bool effect3D;
        private Point effect3DOffset = new Point(1, 1);
        private Attribute? effect3DBrush;
        private ustring title = ustring.Empty;
        private View child;

        /// <summary>
        /// Specifies the <see cref="Gui.BorderStyle"/> for a view.
        /// </summary>
        public BorderStyle BorderStyle
        {
            get => borderStyle;
            set
            {
                if (value != BorderStyle.None && !drawMarginFrame)
                {
                    // Ensures drawn the border lines.
                    drawMarginFrame = true;
                }
                borderStyle = value;
                OnBorderChanged();
            }
        }

        /// <summary>
        /// Gets or sets if a margin frame is drawn around the <see cref="Child"/> regardless the <see cref="BorderStyle"/>
        /// </summary>
        public bool DrawMarginFrame
        {
            get => drawMarginFrame;
            set
            {
                if (borderStyle != BorderStyle.None
                    && (!value || !drawMarginFrame))
                {
                    // Ensures drawn the border lines.
                    drawMarginFrame = true;
                }
                else
                {
                    drawMarginFrame = value;
                }
                OnBorderChanged();
            }
        }

        /// <summary>
        /// Gets or sets the relative <see cref="Thickness"/> of a <see cref="Border"/>.
        /// </summary>
        public Thickness BorderThickness
        {
            get => borderThickness;
            set
            {
                borderThickness = value;
                OnBorderChanged();
            }
        }

        /// <summary>
        /// Gets or sets the <see cref="Color"/> that draws the outer border color.
        /// </summary>
        public Color BorderBrush
        {
            get => borderBrush != null ? (Color)borderBrush : (Color)(-1);
            set
            {
                if (Enum.IsDefined(typeof(Color), value))
                {
                    borderBrush = value;
                    OnBorderChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets the <see cref="Color"/> that fills the area between the bounds of a <see cref="Border"/>.
        /// </summary>
        public Color Background
        {
            get => background != null ? (Color)background : (Color)(-1);
            set
            {
                if (Enum.IsDefined(typeof(Color), value))
                {
                    background = value;
                    OnBorderChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets a <see cref="Thickness"/> value that describes the amount of space between a
        ///  <see cref="Border"/> and its child element.
        /// </summary>
        public Thickness Padding
        {
            get => padding;
            set
            {
                padding = value;
                OnBorderChanged();
            }
        }

        /// <summary>
        /// Gets the rendered width of this element.
        /// </summary>
        public int ActualWidth
        {
            get
            {
                var driver = Application.Driver;
                if (Parent?.Border == null)
                {
                    return Math.Min(Child?.Frame.Width + (2 * marginFrame) + Padding.Right
                        + BorderThickness.Right + Padding.Left + BorderThickness.Left ?? 0, driver.Cols);
                }
                return Math.Min(Parent.Frame.Width, driver.Cols);
            }
        }
        /// <summary>
        /// Gets the rendered height of this element.
        /// </summary>
        public int ActualHeight
        {
            get
            {
                var driver = Application.Driver;
                if (Parent?.Border == null)
                {
                    return Math.Min(Child?.Frame.Height + (2 * marginFrame) + Padding.Bottom
                        + BorderThickness.Bottom + Padding.Top + BorderThickness.Top ?? 0, driver.Rows);
                }
                return Math.Min(Parent.Frame.Height, driver.Rows);
            }
        }

        /// <summary>
        /// Gets or sets the single child element of a <see cref="View"/>.
        /// </summary>
        public View Child
        {
            get => child;
            set
            {
                child = value;
                if (child != null && Parent != null)
                {
                    Parent.Removed += Parent_Removed;
                }
            }
        }

        private void Parent_Removed(View obj)
        {
            if (borderBrush != null)
            {
                BorderBrush = default;
            }
            if (background != null)
            {
                Background = default;
            }
            child.Removed -= Parent_Removed;
        }

        /// <summary>
        /// Gets the parent <see cref="Child"/> parent if any.
        /// </summary>
        public View Parent { get => Child?.SuperView; }

        /// <summary>
        /// Gets or private sets by the <see cref="ToplevelContainer"/>
        /// </summary>
        public ToplevelContainer ChildContainer { get; private set; }

        /// <summary>
        /// Gets or sets the 3D effect around the <see cref="Border"/>.
        /// </summary>
        public bool Effect3D
        {
            get => effect3D;
            set
            {
                effect3D = value;
                OnBorderChanged();
            }
        }

        /// <summary>
        /// Get or sets the offset start position for the <see cref="Effect3D"/>
        /// </summary>
        public Point Effect3DOffset
        {
            get => effect3DOffset;
            set
            {
                effect3DOffset = value;
                OnBorderChanged();
            }
        }
        /// <summary>
        /// Gets or sets the color for the <see cref="Border"/>
        /// </summary>
        public Attribute? Effect3DBrush
        {
            get => effect3DBrush;
            set
            {
                effect3DBrush = value;
                OnBorderChanged();
            }
        }

        /// <summary>
        /// The title to be displayed for this view.
        /// </summary>
        public ustring Title
        {
            get => title;
            set
            {
                title = value;
                OnBorderChanged();
            }
        }

        /// <summary>
        /// Calculate the sum of the <see cref="Padding"/> and the <see cref="BorderThickness"/>
        /// </summary>
        /// <returns>The total of the <see cref="Border"/> <see cref="Thickness"/></returns>
        public Thickness GetSumThickness()
        {
            return new Thickness()
            {
                Left = Padding.Left + BorderThickness.Left,
                Top = Padding.Top + BorderThickness.Top,
                Right = Padding.Right + BorderThickness.Right,
                Bottom = Padding.Bottom + BorderThickness.Bottom
            };
        }

        /// <summary>
        /// Drawn the <see cref="BorderThickness"/> more the <see cref="Padding"/>
        ///  more the <see cref="Border.BorderStyle"/> and the <see cref="Effect3D"/>.
        /// </summary>
        /// <param name="view">The view to draw.</param>
        /// <param name="fill">If it will clear or not the content area.</param>
        public void DrawContent(View view = null, bool fill = true)
        {
            if (Child == null)
            {
                Child = view;
            }
            if (Parent?.Border != null)
            {
                DrawParentBorder(Parent.ViewToScreen(Parent.Bounds), fill);
            }
            else
            {
                DrawChildBorder(Child.ViewToScreen(Child.Bounds), fill);
            }
        }

        /// <summary>
        /// Same as <see cref="DrawContent"/> but drawing full frames for all borders.
        /// </summary>
        public void DrawFullContent()
        {
            var borderThickness = BorderThickness;
            var padding = Padding;
            var marginFrame = DrawMarginFrame ? 1 : 0;
            var driver = Application.Driver;
            Rect scrRect;
            if (Parent?.Border != null)
            {
                scrRect = Parent.ViewToScreen(Parent.Bounds);
            }
            else
            {
                scrRect = Child.ViewToScreen(Child.Bounds);
            }
            Rect borderRect;
            if (Parent?.Border != null)
            {
                borderRect = scrRect;
            }
            else
            {
                borderRect = new Rect()
                {
                    X = scrRect.X - marginFrame - padding.Left - borderThickness.Left,
                    Y = scrRect.Y - marginFrame - padding.Top - borderThickness.Top,
                    Width = ActualWidth,
                    Height = ActualHeight
                };
            }
            var savedAttribute = driver.GetAttribute();

            // Draw 3D effects
            if (Effect3D)
            {
                driver.SetAttribute(GetEffect3DBrush());

                var effectBorder = new Rect()
                {
                    X = borderRect.X + Effect3DOffset.X,
                    Y = borderRect.Y + Effect3DOffset.Y,
                    Width = ActualWidth,
                    Height = ActualHeight
                };
                //Child.Clear (effectBorder);
                for (int r = effectBorder.Y; r < Math.Min(effectBorder.Bottom, driver.Rows); r++)
                {
                    for (int c = effectBorder.X; c < Math.Min(effectBorder.Right, driver.Cols); c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }
            }

            // Draw border thickness
            SetBorderBrush(driver);

            Child.Clear(borderRect);

            borderRect = new Rect()
            {
                X = borderRect.X + borderThickness.Left,
                Y = borderRect.Y + borderThickness.Top,
                Width = Math.Max(borderRect.Width - borderThickness.Right - borderThickness.Left, 0),
                Height = Math.Max(borderRect.Height - borderThickness.Bottom - borderThickness.Top, 0)
            };
            if (borderRect != scrRect)
            {
                // Draw padding
                driver.SetAttribute(new Attribute(Background));
                Child.Clear(borderRect);
            }

            SetBorderBrushBackground(driver);

            // Draw margin frame
            if (DrawMarginFrame)
            {
                if (Parent?.Border != null)
                {
                    var sumPadding = GetSumThickness();
                    borderRect = new Rect()
                    {
                        X = scrRect.X + sumPadding.Left,
                        Y = scrRect.Y + sumPadding.Top,
                        Width = Math.Max(scrRect.Width - sumPadding.Right - sumPadding.Left, 0),
                        Height = Math.Max(scrRect.Height - sumPadding.Bottom - sumPadding.Top, 0)
                    };
                }
                else
                {
                    borderRect = new Rect()
                    {
                        X = borderRect.X + padding.Left,
                        Y = borderRect.Y + padding.Top,
                        Width = Math.Max(borderRect.Width - padding.Right - padding.Left, 0),
                        Height = Math.Max(borderRect.Height - padding.Bottom - padding.Top, 0)
                    };
                }
                if (borderRect.Width > 0 && borderRect.Height > 0)
                {
                    driver.DrawWindowFrame(borderRect, 1, 1, 1, 1, BorderStyle != BorderStyle.None, fill: true, this);
                }
            }
            driver.SetAttribute(savedAttribute);
        }

        private void DrawChildBorder(Rect frame, bool fill = true)
        {
            var drawMarginFrame = DrawMarginFrame ? 1 : 0;
            var sumThickness = GetSumThickness();
            var padding = Padding;
            var effect3DOffset = Effect3DOffset;
            var driver = Application.Driver;

            var savedAttribute = driver.GetAttribute();

            SetBorderBrush(driver);

            // Draw the upper BorderThickness
            for (int r = frame.Y - drawMarginFrame - sumThickness.Top;
                r < frame.Y - drawMarginFrame - padding.Top; r++)
            {
                for (int c = frame.X - drawMarginFrame - sumThickness.Left;
                    c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the left BorderThickness
            for (int r = frame.Y - drawMarginFrame - padding.Top;
                r < Math.Min(frame.Bottom + drawMarginFrame + padding.Bottom, driver.Rows); r++)
            {
                for (int c = frame.X - drawMarginFrame - sumThickness.Left;
                    c < frame.X - drawMarginFrame - padding.Left; c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the right BorderThickness
            for (int r = frame.Y - drawMarginFrame - padding.Top;
                r < Math.Min(frame.Bottom + drawMarginFrame + padding.Bottom, driver.Rows); r++)
            {
                for (int c = frame.Right + drawMarginFrame + padding.Right;
                    c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the lower BorderThickness
            for (int r = frame.Bottom + drawMarginFrame + padding.Bottom;
                r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom, driver.Rows); r++)
            {
                for (int c = frame.X - drawMarginFrame - sumThickness.Left;
                    c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            SetBackground(driver);

            // Draw the upper Padding
            for (int r = frame.Y - drawMarginFrame - padding.Top;
                r < frame.Y - drawMarginFrame; r++)
            {
                for (int c = frame.X - drawMarginFrame - padding.Left;
                    c < Math.Min(frame.Right + drawMarginFrame + padding.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the left Padding
            for (int r = frame.Y - drawMarginFrame;
                r < Math.Min(frame.Bottom + drawMarginFrame, driver.Rows); r++)
            {
                for (int c = frame.X - drawMarginFrame - padding.Left;
                    c < frame.X - drawMarginFrame; c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the right Padding
            for (int r = frame.Y - drawMarginFrame;
                r < Math.Min(frame.Bottom + drawMarginFrame, driver.Rows); r++)
            {
                for (int c = frame.Right + drawMarginFrame;
                    c < Math.Min(frame.Right + drawMarginFrame + padding.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the lower Padding
            for (int r = frame.Bottom + drawMarginFrame;
                r < Math.Min(frame.Bottom + drawMarginFrame + padding.Bottom, driver.Rows); r++)
            {
                for (int c = frame.X - drawMarginFrame - padding.Left;
                    c < Math.Min(frame.Right + drawMarginFrame + padding.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            SetBorderBrushBackground(driver);

            // Draw the MarginFrame
            if (DrawMarginFrame)
            {
                var rect = new Rect()
                {
                    X = frame.X - drawMarginFrame,
                    Y = frame.Y - drawMarginFrame,
                    Width = frame.Width + (2 * drawMarginFrame),
                    Height = frame.Height + (2 * drawMarginFrame)
                };
                if (rect.Width > 0 && rect.Height > 0)
                {
                    driver.DrawWindowFrame(rect, 1, 1, 1, 1, BorderStyle != BorderStyle.None, fill, this);
                    DrawTitle(Child);
                }
            }

            if (Effect3D)
            {
                driver.SetAttribute(GetEffect3DBrush());

                // Draw the upper Effect3D
                for (int r = frame.Y - drawMarginFrame - sumThickness.Top + effect3DOffset.Y;
                    r >= 0 && r < frame.Y - drawMarginFrame - sumThickness.Top; r++)
                {
                    for (int c = frame.X - drawMarginFrame - sumThickness.Left + effect3DOffset.X;
                        c >= 0 && c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right + effect3DOffset.X, driver.Cols); c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }

                // Draw the left Effect3D
                for (int r = frame.Y - drawMarginFrame - sumThickness.Top + effect3DOffset.Y;
                    r >= 0 && r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom + effect3DOffset.Y, driver.Rows); r++)
                {
                    for (int c = frame.X - drawMarginFrame - sumThickness.Left + effect3DOffset.X;
                        c >= 0 && c < frame.X - drawMarginFrame - sumThickness.Left; c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }

                // Draw the right Effect3D
                for (int r = frame.Y - drawMarginFrame - sumThickness.Top + effect3DOffset.Y;
                    r >= 0 && r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom + effect3DOffset.Y, driver.Rows); r++)
                {
                    for (int c = frame.Right + drawMarginFrame + sumThickness.Right;
                        c >= 0 && c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right + effect3DOffset.X, driver.Cols); c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }

                // Draw the lower Effect3D
                for (int r = frame.Bottom + drawMarginFrame + sumThickness.Bottom;
                    r >= 0 && r < Math.Min(frame.Bottom + drawMarginFrame + sumThickness.Bottom + effect3DOffset.Y, driver.Rows); r++)
                {
                    for (int c = frame.X - drawMarginFrame - sumThickness.Left + effect3DOffset.X;
                        c >= 0 && c < Math.Min(frame.Right + drawMarginFrame + sumThickness.Right + effect3DOffset.X, driver.Cols); c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }
            }
            driver.SetAttribute(savedAttribute);
        }

        private void DrawParentBorder(Rect frame, bool fill = true)
        {
            var sumThickness = GetSumThickness();
            var borderThickness = BorderThickness;
            var effect3DOffset = Effect3DOffset;
            var driver = Application.Driver;

            var savedAttribute = driver.GetAttribute();

            SetBorderBrush(driver);

            // Draw the upper BorderThickness
            for (int r = Math.Max(frame.Y, 0);
                r < Math.Min(frame.Y + borderThickness.Top, frame.Bottom); r++)
            {
                for (int c = frame.X;
                    c < Math.Min(frame.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the left BorderThickness
            for (int r = Math.Max(Math.Min(frame.Y + borderThickness.Top, frame.Bottom), 0);
                r < Math.Min(frame.Bottom - borderThickness.Bottom, driver.Rows); r++)
            {
                for (int c = frame.X;
                    c < Math.Min(frame.X + borderThickness.Left, frame.Right); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the right BorderThickness
            for (int r = Math.Max(Math.Min(frame.Y + borderThickness.Top, frame.Bottom), 0);
                r < Math.Min(frame.Bottom - borderThickness.Bottom, driver.Rows); r++)
            {
                for (int c = Math.Max(frame.Right - borderThickness.Right, frame.X);
                    c < Math.Min(frame.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the lower BorderThickness
            for (int r = Math.Max(frame.Bottom - borderThickness.Bottom, frame.Y);
                r < Math.Min(frame.Bottom, driver.Rows); r++)
            {
                for (int c = frame.X;
                    c < Math.Min(frame.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            SetBackground(driver);

            // Draw the upper Padding
            for (int r = Math.Max(frame.Y + borderThickness.Top, 0);
                r < Math.Min(frame.Y + sumThickness.Top, frame.Bottom - borderThickness.Bottom); r++)
            {
                for (int c = frame.X + borderThickness.Left;
                    c < Math.Min(frame.Right - borderThickness.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the left Padding
            for (int r = Math.Max(frame.Y + sumThickness.Top, 0);
                r < Math.Min(frame.Bottom - sumThickness.Bottom, driver.Rows); r++)
            {
                for (int c = frame.X + borderThickness.Left;
                    c < Math.Min(frame.X + sumThickness.Left, frame.Right - borderThickness.Right); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the right Padding
            for (int r = Math.Max(frame.Y + sumThickness.Top, 0);
                r < Math.Min(frame.Bottom - sumThickness.Bottom, driver.Rows); r++)
            {
                for (int c = Math.Max(frame.Right - sumThickness.Right, frame.X + sumThickness.Left);
                    c < Math.Max(frame.Right - borderThickness.Right, frame.X + sumThickness.Left); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            // Draw the lower Padding
            for (int r = Math.Max(frame.Bottom - sumThickness.Bottom, frame.Y + borderThickness.Top);
                r < Math.Min(frame.Bottom - borderThickness.Bottom, driver.Rows); r++)
            {
                for (int c = frame.X + borderThickness.Left;
                    c < Math.Min(frame.Right - borderThickness.Right, driver.Cols); c++)
                {

                    AddRuneAt(driver, c, r, ' ');
                }
            }

            SetBorderBrushBackground(driver);

            // Draw the MarginFrame
            if (DrawMarginFrame)
            {
                var rect = new Rect()
                {
                    X = frame.X + sumThickness.Left,
                    Y = frame.Y + sumThickness.Top,
                    Width = Math.Max(frame.Width - sumThickness.Right - sumThickness.Left, 0),
                    Height = Math.Max(frame.Height - sumThickness.Bottom - sumThickness.Top, 0)
                };
                if (rect.Width > 0 && rect.Height > 0)
                {
                    driver.DrawWindowFrame(rect, 1, 1, 1, 1, BorderStyle != BorderStyle.None, fill, this);
                    DrawTitle(Parent);
                }
            }

            if (Effect3D)
            {
                driver.SetAttribute(GetEffect3DBrush());

                // Draw the upper Effect3D
                for (int r = Math.Max(frame.Y + effect3DOffset.Y, 0);
                    r < frame.Y; r++)
                {
                    for (int c = Math.Max(frame.X + effect3DOffset.X, 0);
                        c < Math.Min(frame.Right + effect3DOffset.X, driver.Cols); c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }

                // Draw the left Effect3D
                for (int r = Math.Max(frame.Y + effect3DOffset.Y, 0);
                    r < Math.Min(frame.Bottom + effect3DOffset.Y, driver.Rows); r++)
                {
                    for (int c = Math.Max(frame.X + effect3DOffset.X, 0);
                        c < frame.X; c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }

                // Draw the right Effect3D
                for (int r = Math.Max(frame.Y + effect3DOffset.Y, 0);
                    r < Math.Min(frame.Bottom + effect3DOffset.Y, driver.Rows); r++)
                {
                    for (int c = frame.Right;
                        c < Math.Min(frame.Right + effect3DOffset.X, driver.Cols); c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }

                // Draw the lower Effect3D
                for (int r = frame.Bottom;
                    r < Math.Min(frame.Bottom + effect3DOffset.Y, driver.Rows); r++)
                {
                    for (int c = Math.Max(frame.X + effect3DOffset.X, 0);
                        c < Math.Min(frame.Right + effect3DOffset.X, driver.Cols); c++)
                    {

                        AddRuneAt(driver, c, r, (Rune)driver.Contents[r, c, 0]);
                    }
                }
            }
            driver.SetAttribute(savedAttribute);
        }

        private void SetBorderBrushBackground(ConsoleDriver driver)
        {
            if (borderBrush != null && background != null)
            {
                driver.SetAttribute(new Attribute(BorderBrush, Background));
            }
            else if (borderBrush != null && background == null)
            {
                driver.SetAttribute(new Attribute(BorderBrush, Parent.ColorScheme.Normal.Background));
            }
            else if (borderBrush == null && background != null)
            {
                driver.SetAttribute(new Attribute(Parent.ColorScheme.Normal.Foreground, Background));
            }
            else
            {
                driver.SetAttribute(Parent.ColorScheme.Normal);
            }
        }

        private void SetBackground(ConsoleDriver driver)
        {
            if (background != null)
            {
                driver.SetAttribute(new Attribute(Background));
            }
            else
            {
                driver.SetAttribute(new Attribute(Parent.ColorScheme.Normal.Background));
            }
        }

        private void SetBorderBrush(ConsoleDriver driver)
        {
            if (borderBrush != null)
            {
                driver.SetAttribute(new Attribute(BorderBrush));
            }
            else
            {
                driver.SetAttribute(new Attribute(Parent.ColorScheme.Normal.Foreground));
            }
        }

        private Attribute GetEffect3DBrush()
        {
            return Effect3DBrush == null
                ? new Attribute(Color.Gray, Color.DarkGray)
                : (Attribute)Effect3DBrush;
        }

        private void AddRuneAt(ConsoleDriver driver, int col, int row, Rune ch)
        {
            if (col < driver.Cols && row < driver.Rows && col > 0 && driver.Contents[row, col, 2] == 0
                && Rune.ColumnWidth((char)driver.Contents[row, col - 1, 0]) > 1)
            {

                driver.Contents[row, col, 1] = driver.GetAttribute();
                return;
            }
            driver.Move(col, row);
            driver.AddRune(ch);
        }

        /// <summary>
        /// Draws the view <see cref="Title"/> to the screen.
        /// </summary>
        /// <param name="view">The view.</param>
        public void DrawTitle(View view)
        {
            var driver = Application.Driver;
            if (DrawMarginFrame)
            {
                SetBorderBrushBackground(driver);
                SetHotNormalBackground(view, driver);
                var padding = view.Border.GetSumThickness();
                Rect scrRect;
                if (view == Child)
                {
                    scrRect = view.ViewToScreen(new Rect(0, 0, view.Frame.Width + 2, view.Frame.Height + 2));
                    scrRect = new Rect(scrRect.X - 1, scrRect.Y - 1, scrRect.Width, scrRect.Height);
                    driver.DrawWindowTitle(scrRect, Title, 0, 0, 0, 0);
                }
                else
                {
                    scrRect = view.ViewToScreen(new Rect(0, 0, view.Frame.Width, view.Frame.Height));
                    driver.DrawWindowTitle(scrRect, Parent.Border.Title,
                        padding.Left, padding.Top, padding.Right, padding.Bottom);
                }
            }
            driver.SetAttribute(Child.GetNormalColor());
        }

        private void SetHotNormalBackground(View view, ConsoleDriver driver)
        {
            if (view.HasFocus)
            {
                if (background != null)
                {
                    driver.SetAttribute(new Attribute(Child.ColorScheme.HotNormal.Foreground, Background));
                }
                else
                {
                    driver.SetAttribute(Child.ColorScheme.HotNormal);
                }
            }
        }

        /// <summary>
        /// Draws the <see cref="View.Text"/> to the screen.
        /// </summary>
        /// <param name="view">The view.</param>
        /// <param name="rect">The frame.</param>
        public void DrawTitle(View view, Rect rect)
        {
            var driver = Application.Driver;
            if (DrawMarginFrame)
            {
                SetBorderBrushBackground(driver);
                SetHotNormalBackground(view, driver);
                var padding = Parent.Border.GetSumThickness();
                var scrRect = Parent.ViewToScreen(new Rect(0, 0, rect.Width, rect.Height));
                driver.DrawWindowTitle(scrRect, view.Text,
                    padding.Left, padding.Top, padding.Right, padding.Bottom);
            }
            driver.SetAttribute(view.GetNormalColor());
        }

        /// <summary>
        /// Invoke the <see cref="BorderChanged"/> event.
        /// </summary>
        public virtual void OnBorderChanged()
        {
            BorderChanged?.Invoke(this);
        }
    }
    //=======================================================================
    //
    // Button.cs: Button control
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    ///   Button is a <see cref="View"/> that provides an item that invokes an <see cref="Action"/> when activated by the user.
    /// </summary>
    /// <remarks>
    /// <para>
    ///   Provides a button showing text invokes an <see cref="Action"/> when clicked on with a mouse
    ///   or when the user presses SPACE, ENTER, or hotkey. The hotkey is the first letter or digit following the first underscore ('_') 
    ///   in the button text. 
    /// </para>
    /// <para>
    ///   Use <see cref="View.HotKeySpecifier"/> to change the hotkey specifier from the default of ('_'). 
    /// </para>
    /// <para>
    ///   If no hotkey specifier is found, the first uppercase letter encountered will be used as the hotkey.
    /// </para>
    /// <para>
    ///   When the button is configured as the default (<see cref="IsDefault"/>) and the user presses
    ///   the ENTER key, if no other <see cref="View"/> processes the <see cref="KeyEvent"/>, the <see cref="Button"/>'s
    ///   <see cref="Action"/> will be invoked.
    /// </para>
    /// </remarks>
    public class Button : View
    {
        bool is_default;
        Rune _leftBracket;
        Rune _rightBracket;
        Rune _leftDefault;
        Rune _rightDefault;

        /// <summary>
        ///   Initializes a new instance of <see cref="Button"/> using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <remarks>
        ///   The width of the <see cref="Button"/> is computed based on the
        ///   text length. The height will always be 1.
        /// </remarks>
        public Button() : this(text: string.Empty, is_default: false) { }

        /// <summary>
        ///   Initializes a new instance of <see cref="Button"/> using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <remarks>
        ///   The width of the <see cref="Button"/> is computed based on the
        ///   text length. The height will always be 1.
        /// </remarks>
        /// <param name="text">The button's text</param>
        /// <param name="is_default">
        ///   If <c>true</c>, a special decoration is used, and the user pressing the enter key 
        ///   in a <see cref="Dialog"/> will implicitly activate this button.
        /// </param>
        public Button(ustring text, bool is_default = false) : base(text)
        {
            Initialize(text, is_default);
        }

        /// <summary>
        ///   Initializes a new instance of <see cref="Button"/> using <see cref="LayoutStyle.Absolute"/> layout, based on the given text
        /// </summary>
        /// <remarks>
        ///   The width of the <see cref="Button"/> is computed based on the
        ///   text length. The height will always be 1.
        /// </remarks>
        /// <param name="x">X position where the button will be shown.</param>
        /// <param name="y">Y position where the button will be shown.</param>
        /// <param name="text">The button's text</param>
        public Button(int x, int y, ustring text) : this(x, y, text, false) { }

        /// <summary>
        ///   Initializes a new instance of <see cref="Button"/> using <see cref="LayoutStyle.Absolute"/> layout, based on the given text.
        /// </summary>
        /// <remarks>
        ///   The width of the <see cref="Button"/> is computed based on the
        ///   text length. The height will always be 1.
        /// </remarks>
        /// <param name="x">X position where the button will be shown.</param>
        /// <param name="y">Y position where the button will be shown.</param>
        /// <param name="text">The button's text</param>
        /// <param name="is_default">
        ///   If <c>true</c>, a special decoration is used, and the user pressing the enter key 
        ///   in a <see cref="Dialog"/> will implicitly activate this button.
        /// </param>
        public Button(int x, int y, ustring text, bool is_default)
            : base(new Rect(x, y, text.RuneCount + 4 + (is_default ? 2 : 0), 1), text)
        {
            Initialize(text, is_default);
        }

        void Initialize(ustring text, bool is_default)
        {
            TextAlignment = TextAlignment.Centered;
            VerticalTextAlignment = VerticalTextAlignment.Middle;

            HotKeySpecifier = new Rune('_');

            _leftBracket = new Rune(Driver != null ? Driver.LeftBracket : '[');
            _rightBracket = new Rune(Driver != null ? Driver.RightBracket : ']');
            _leftDefault = new Rune(Driver != null ? Driver.LeftDefaultIndicator : '<');
            _rightDefault = new Rune(Driver != null ? Driver.RightDefaultIndicator : '>');

            CanFocus = true;
            AutoSize = true;
            this.is_default = is_default;
            Text = text ?? string.Empty;
            UpdateTextFormatterText();
            ProcessResizeView();

            // Things this view knows how to do
            AddCommand(Command.Accept, () => AcceptKey());

            // Default keybindings for this view
            AddKeyBinding(Key.Enter, Command.Accept);
            AddKeyBinding(Key.Space, Command.Accept);
            if (HotKey != Key.Null)
            {
                AddKeyBinding(Key.Space | HotKey, Command.Accept);
            }
        }

        /// <summary>
        /// Gets or sets whether the <see cref="Button"/> is the default action to activate in a dialog.
        /// </summary>
        /// <value><c>true</c> if is default; otherwise, <c>false</c>.</value>
        /// <remarks>
        /// If is <see langword="true"/> the current focused view
        /// will remain focused if the window is not closed.
        /// </remarks>
        public bool IsDefault
        {
            get => is_default;
            set
            {
                is_default = value;
                UpdateTextFormatterText();
                ProcessResizeView();
            }
        }

        /// <inheritdoc/>
        public override Key HotKey
        {
            get => base.HotKey;
            set
            {
                if (base.HotKey != value)
                {
                    var v = value == Key.Unknown ? Key.Null : value;
                    if (base.HotKey != Key.Null && ContainsKeyBinding(Key.Space | base.HotKey))
                    {
                        if (v == Key.Null)
                        {
                            ClearKeybinding(Key.Space | base.HotKey);
                        }
                        else
                        {
                            ReplaceKeyBinding(Key.Space | base.HotKey, Key.Space | v);
                        }
                    }
                    else if (v != Key.Null)
                    {
                        AddKeyBinding(Key.Space | v, Command.Accept);
                    }
                    base.HotKey = TextFormatter.HotKey = v;
                }
            }
        }

        /// <inheritdoc/>
        protected override void UpdateTextFormatterText()
        {
            if (IsDefault)
                TextFormatter.Text = ustring.Make(_leftBracket) + ustring.Make(_leftDefault) + " " + Text + " " + ustring.Make(_rightDefault) + ustring.Make(_rightBracket);
            else
                TextFormatter.Text = ustring.Make(_leftBracket) + " " + Text + " " + ustring.Make(_rightBracket);
        }

        ///<inheritdoc/>
        public override bool ProcessHotKey(KeyEvent kb)
        {
            if (!Enabled)
            {
                return false;
            }

            return ExecuteHotKey(kb);
        }

        ///<inheritdoc/>
        public override bool ProcessColdKey(KeyEvent kb)
        {
            if (!Enabled)
            {
                return false;
            }

            return ExecuteColdKey(kb);
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            if (!Enabled)
            {
                return false;
            }

            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            return base.ProcessKey(kb);
        }

        bool ExecuteHotKey(KeyEvent ke)
        {
            if (ke.Key == (Key.AltMask | HotKey))
            {
                return AcceptKey();
            }
            return false;
        }

        bool ExecuteColdKey(KeyEvent ke)
        {
            if (IsDefault && ke.KeyValue == '\n')
            {
                return AcceptKey();
            }
            return ExecuteHotKey(ke);
        }

        bool AcceptKey()
        {
            if (!IsDefault && !HasFocus)
            {
                SetFocus();
            }
            OnClicked();
            return true;
        }

        /// <summary>
        /// Virtual method to invoke the <see cref="Clicked"/> event.
        /// </summary>
        public virtual void OnClicked()
        {
            Clicked?.Invoke();
        }

        /// <summary>
        ///   Clicked <see cref="Action"/>, raised when the user clicks the primary mouse button within the Bounds of this <see cref="View"/>
        ///   or if the user presses the action key while this view is focused. (TODO: IsDefault)
        /// </summary>
        /// <remarks>
        ///   Client code can hook up to this event, it is
        ///   raised when the button is activated either with
        ///   the mouse or the keyboard.
        /// </remarks>
        public event Action Clicked;

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (me.Flags == MouseFlags.Button1Clicked)
            {
                if (CanFocus && Enabled)
                {
                    if (!HasFocus)
                    {
                        SetFocus();
                        SetNeedsDisplay();
                        Redraw(Bounds);
                    }
                    OnClicked();
                }

                return true;
            }
            return false;
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            if (HotKey == Key.Unknown && Text != "")
            {
                for (int i = 0; i < TextFormatter.Text.RuneCount; i++)
                {
                    if (TextFormatter.Text[i] == Text[0])
                    {
                        Move(i, 0);
                        return;
                    }
                }
            }
            base.PositionCursor();
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }
    }
    //=======================================================================
    //
    // Checkbox.cs: Checkbox control
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    /// The <see cref="CheckBox"/> <see cref="View"/> shows an on/off toggle that the user can set
    /// </summary>
    public class CheckBox : View
    {
        Rune charChecked;
        Rune charUnChecked;
        bool @checked;

        /// <summary>
        ///   Toggled event, raised when the <see cref="CheckBox"/>  is toggled.
        /// </summary>
        /// <remarks>
        ///   Client code can hook up to this event, it is
        ///   raised when the <see cref="CheckBox"/> is activated either with
        ///   the mouse or the keyboard. The passed <c>bool</c> contains the previous state. 
        /// </remarks>
        public event Action<bool> Toggled;

        /// <summary>
        /// Called when the <see cref="Checked"/> property changes. Invokes the <see cref="Toggled"/> event.
        /// </summary>
        public virtual void OnToggled(bool previousChecked)
        {
            Toggled?.Invoke(previousChecked);
        }

        /// <summary>
        /// Initializes a new instance of <see cref="CheckBox"/> based on the given text, using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        public CheckBox() : this(string.Empty) { }

        /// <summary>
        /// Initializes a new instance of <see cref="CheckBox"/> based on the given text, using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <param name="s">S.</param>
        /// <param name="is_checked">If set to <c>true</c> is checked.</param>
        public CheckBox(ustring s, bool is_checked = false) : base()
        {
            Initialize(s, is_checked);
        }

        /// <summary>
        /// Initializes a new instance of <see cref="CheckBox"/> using <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <remarks>
        ///   The size of <see cref="CheckBox"/> is computed based on the
        ///   text length. This <see cref="CheckBox"/> is not toggled.
        /// </remarks>
        public CheckBox(int x, int y, ustring s) : this(x, y, s, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of <see cref="CheckBox"/> using <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <remarks>
        ///   The size of <see cref="CheckBox"/> is computed based on the
        ///   text length. 
        /// </remarks>
        public CheckBox(int x, int y, ustring s, bool is_checked) : base(new Rect(x, y, s.Length, 1))
        {
            Initialize(s, is_checked);
        }

        void Initialize(ustring s, bool is_checked)
        {
            charChecked = new Rune(Driver != null ? Driver.Checked : '√');
            charUnChecked = new Rune(Driver != null ? Driver.UnChecked : '╴');
            Checked = is_checked;
            HotKeySpecifier = new Rune('_');
            CanFocus = true;
            AutoSize = true;
            Text = s;
            UpdateTextFormatterText();
            ProcessResizeView();

            // Things this view knows how to do
            AddCommand(Command.ToggleChecked, () => ToggleChecked());

            // Default keybindings for this view
            AddKeyBinding((Key)' ', Command.ToggleChecked);
            AddKeyBinding(Key.Space, Command.ToggleChecked);
        }

        /// <inheritdoc/>
        protected override void UpdateTextFormatterText()
        {
            switch (TextAlignment)
            {
                case TextAlignment.Left:
                case TextAlignment.Centered:
                case TextAlignment.Justified:
                    TextFormatter.Text = ustring.Make(Checked ? charChecked : charUnChecked) + " " + GetFormatterText();
                    break;
                case TextAlignment.Right:
                    TextFormatter.Text = GetFormatterText() + " " + ustring.Make(Checked ? charChecked : charUnChecked);
                    break;
            }
        }

        ustring GetFormatterText()
        {
            if (AutoSize || ustring.IsNullOrEmpty(Text) || Frame.Width <= 2)
            {
                return Text;
            }
            return Text.RuneSubstring(0, Math.Min(Frame.Width - 2, Text.RuneCount));
        }

        /// <summary>
        ///    The state of the <see cref="CheckBox"/>
        /// </summary>
        public bool Checked
        {
            get => @checked;
            set
            {
                @checked = value;
                UpdateTextFormatterText();
                ProcessResizeView();
            }
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            Move(0, 0);
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            return base.ProcessKey(kb);
        }

        ///<inheritdoc/>
        public override bool ProcessHotKey(KeyEvent kb)
        {
            if (kb.Key == (Key.AltMask | HotKey))
                return ToggleChecked();

            return false;
        }

        bool ToggleChecked()
        {
            if (!HasFocus)
            {
                SetFocus();
            }
            var previousChecked = Checked;
            Checked = !Checked;
            OnToggled(previousChecked);
            SetNeedsDisplay();
            return true;
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) || !CanFocus)
                return false;

            SetFocus();
            var previousChecked = Checked;
            Checked = !Checked;
            OnToggled(previousChecked);
            SetNeedsDisplay();

            return true;
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }
    }
    //=======================================================================
    /// <summary>
    /// Provides cut, copy, and paste support for the OS clipboard.
    /// </summary>
    /// <remarks>
    /// <para>
    /// On Windows, the <see cref="Clipboard"/> class uses the Windows Clipboard APIs via P/Invoke.
    /// </para>
    /// <para>
    /// On Linux, when not running under Windows Subsystem for Linux (WSL),
    /// the <see cref="Clipboard"/> class uses the xclip command line tool. If xclip is not installed,
    /// the clipboard will not work.
    /// </para>
    /// <para>
    /// On Linux, when running under Windows Subsystem for Linux (WSL),
    /// the <see cref="Clipboard"/> class launches Windows' powershell.exe via WSL interop and uses the
    /// "Set-Clipboard" and "Get-Clipboard" Powershell CmdLets. 
    /// </para>
    /// <para>
    /// On the Mac, the <see cref="Clipboard"/> class uses the MacO OS X pbcopy and pbpaste command line tools
    /// and the Mac clipboard APIs vai P/Invoke.
    /// </para>
    /// </remarks>
    public static class Clipboard
    {
        static ustring contents;

        /// <summary>
        /// Gets (copies from) or sets (pastes to) the contents of the OS clipboard.
        /// </summary>
        public static ustring Contents
        {
            get
            {
                try
                {
                    if (IsSupported)
                    {
                        return contents = ustring.Make(Application.Driver.Clipboard.GetClipboardData());
                    }
                    else
                    {
                        return contents;
                    }
                }
                catch (Exception)
                {
                    return contents;
                }
            }
            set
            {
                try
                {
                    if (IsSupported)
                    {
                        if (value == null)
                        {
                            value = string.Empty;
                        }
                        Application.Driver.Clipboard.SetClipboardData(value.ToString());
                    }
                    contents = value;
                }
                catch (NotSupportedException)
                {
                    throw;
                }
                catch (Exception)
                {
                    contents = value;
                }
            }
        }

        /// <summary>
        /// Returns true if the environmental dependencies are in place to interact with the OS clipboard.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public static bool IsSupported { get => Application.Driver.Clipboard.IsSupported; }

        /// <summary>
        /// Copies the contents of the OS clipboard to <paramref name="result"/> if possible.
        /// </summary>
        /// <param name="result">The contents of the OS clipboard if successful, <see cref="string.Empty"/> if not.</param>
        /// <returns><see langword="true"/> the OS clipboard was retrieved, <see langword="false"/> otherwise.</returns>
        public static bool TryGetClipboardData(out string result)
        {
            if (IsSupported && Application.Driver.Clipboard.TryGetClipboardData(out result))
            {
                if (contents != result)
                {
                    contents = result;
                }
                return true;
            }
            result = string.Empty;
            return false;
        }

        /// <summary>
        /// Pastes the <paramref name="text"/> to the OS clipboard if possible.
        /// </summary>
        /// <param name="text">The text to paste to the OS clipboard.</param>
        /// <returns><see langword="true"/> the OS clipboard was set, <see langword="false"/> otherwise.</returns>
        public static bool TrySetClipboardData(string text)
        {
            if (IsSupported && Application.Driver.Clipboard.TrySetClipboardData(text))
            {
                contents = text;
                return true;
            }
            return false;
        }
    }
    //=======================================================================
    /// <summary>
    /// Shared abstract class to enforce rules from the implementation of the <see cref="IClipboard"/> interface.
    /// </summary>
    public abstract class ClipboardBase : IClipboard
    {
        /// <summary>
        /// Returns true if the environmental dependencies are in place to interact with the OS clipboard
        /// </summary>
        public abstract bool IsSupported { get; }

        /// <summary>
        /// Returns the contents of the OS clipboard if possible.
        /// </summary>
        /// <returns>The contents of the OS clipboard if successful.</returns>
        /// <exception cref="NotSupportedException">Thrown if it was not possible to copy from the OS clipboard.</exception>
        public string GetClipboardData()
        {
            try
            {
                return GetClipboardDataImpl();
            }
            catch (NotSupportedException ex)
            {
                throw new NotSupportedException("Failed to copy from the OS clipboard.", ex);
            }
        }

        /// <summary>
        /// Returns the contents of the OS clipboard if possible. Implemented by <see cref="ConsoleDriver"/>-specific subclasses.
        /// </summary>
        /// <returns>The contents of the OS clipboard if successful.</returns>
        /// <exception cref="NotSupportedException">Thrown if it was not possible to copy from the OS clipboard.</exception>
        protected abstract string GetClipboardDataImpl();

        /// <summary>
        /// Pastes the <paramref name="text"/> to the OS clipboard if possible.
        /// </summary>
        /// <param name="text">The text to paste to the OS clipboard.</param>
        /// <exception cref="NotSupportedException">Thrown if it was not possible to paste to the OS clipboard.</exception>
        public void SetClipboardData(string text)
        {
            try
            {
                SetClipboardDataImpl(text);
            }
            catch (NotSupportedException ex)
            {
                throw new NotSupportedException("Failed to paste to the OS clipboard.", ex);
            }
        }

        /// <summary>
        /// Pastes the <paramref name="text"/> to the OS clipboard if possible. Implemented by <see cref="ConsoleDriver"/>-specific subclasses.
        /// </summary>
        /// <param name="text">The text to paste to the OS clipboard.</param>
        /// <exception cref="NotSupportedException">Thrown if it was not possible to paste to the OS clipboard.</exception>
        protected abstract void SetClipboardDataImpl(string text);

        /// <summary>
        /// Copies the contents of the OS clipboard to <paramref name="result"/> if possible.
        /// </summary>
        /// <param name="result">The contents of the OS clipboard if successful, <see cref="string.Empty"/> if not.</param>
        /// <returns><see langword="true"/> the OS clipboard was retrieved, <see langword="false"/> otherwise.</returns>
        public bool TryGetClipboardData(out string result)
        {
            // Don't even try to read because environment is not set up.
            if (!IsSupported)
            {
                result = null;
                return false;
            }

            try
            {
                result = GetClipboardDataImpl();
                while (result == null)
                {
                    result = GetClipboardDataImpl();
                }
                return true;
            }
            catch (NotSupportedException ex)
            {
                System.Diagnostics.Debug.WriteLine($"TryGetClipboardData: {ex.Message}");
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Pastes the <paramref name="text"/> to the OS clipboard if possible.
        /// </summary>
        /// <param name="text">The text to paste to the OS clipboard.</param>
        /// <returns><see langword="true"/> the OS clipboard was set, <see langword="false"/> otherwise.</returns>
        public bool TrySetClipboardData(string text)
        {
            // Don't even try to set because environment is not set up
            if (!IsSupported)
            {
                return false;
            }

            try
            {
                SetClipboardDataImpl(text);
                return true;
            }
            catch (NotSupportedException ex)
            {
                System.Diagnostics.Debug.WriteLine($"TrySetClipboardData: {ex.Message}");
                return false;
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Navigates a collection of items using keystrokes. The keystrokes are used to build a search string. 
    /// The <see cref="SearchString"/> is used to find the next item in the collection that matches the search string
    /// when <see cref="GetNextMatchingItem(int, char)"/> is called.
    /// <para>
    /// If the user types keystrokes that can't be found in the collection, 
    /// the search string is cleared and the next item is found that starts with the last keystroke.
    /// </para>
    /// <para>
    /// If the user pauses keystrokes for a short time (see <see cref="TypingDelay"/>), the search string is cleared.
    /// </para>
    /// </summary>
    public class CollectionNavigator
    {
        /// <summary>
        /// Constructs a new CollectionNavigator.
        /// </summary>
        public CollectionNavigator() { }

        /// <summary>
        /// Constructs a new CollectionNavigator for the given collection.
        /// </summary>
        /// <param name="collection"></param>
        public CollectionNavigator(IEnumerable<object> collection) => Collection = collection;

        DateTime lastKeystroke = DateTime.Now;
        /// <summary>
        /// Gets or sets the number of milliseconds to delay before clearing the search string. The delay is
        /// reset on each call to <see cref="GetNextMatchingItem(int, char)"/>. The default is 500ms.
        /// </summary>
        public int TypingDelay { get; set; } = 500;

        /// <summary>
        /// The compararer function to use when searching the collection.
        /// </summary>
        public StringComparer Comparer { get; set; } = StringComparer.InvariantCultureIgnoreCase;

        /// <summary>
        /// The collection of objects to search. <see cref="object.ToString()"/> is used to search the collection.
        /// </summary>
        public IEnumerable<object> Collection { get; set; }

        /// <summary>
        /// Event arguments for the <see cref="CollectionNavigator.SearchStringChanged"/> event.
        /// </summary>
        public class KeystrokeNavigatorEventArgs
        {
            /// <summary>
            /// he current <see cref="SearchString"/>.
            /// </summary>
            public string SearchString { get; }

            /// <summary>
            /// Initializes a new instance of <see cref="KeystrokeNavigatorEventArgs"/>
            /// </summary>
            /// <param name="searchString">The current <see cref="SearchString"/>.</param>
            public KeystrokeNavigatorEventArgs(string searchString)
            {
                SearchString = searchString;
            }
        }

        /// <summary>
        /// This event is invoked when <see cref="SearchString"/>  changes. Useful for debugging.
        /// </summary>
        public event Action<KeystrokeNavigatorEventArgs> SearchStringChanged;

        private string _searchString = "";
        /// <summary>
        /// Gets the current search string. This includes the set of keystrokes that have been pressed
        /// since the last unsuccessful match or after <see cref="TypingDelay"/>) milliseconds. Useful for debugging.
        /// </summary>
        public string SearchString
        {
            get => _searchString;
            private set
            {
                _searchString = value;
                OnSearchStringChanged(new KeystrokeNavigatorEventArgs(value));
            }
        }

        /// <summary>
        /// Invoked when the <see cref="SearchString"/> changes. Useful for debugging. Invokes the <see cref="SearchStringChanged"/> event.
        /// </summary>
        /// <param name="e"></param>
        public virtual void OnSearchStringChanged(KeystrokeNavigatorEventArgs e)
        {
            SearchStringChanged?.Invoke(e);
        }

        /// <summary>
        /// Gets the index of the next item in the collection that matches the current <see cref="SearchString"/> plus the provided character (typically
        /// from a key press).
        /// </summary>
        /// <param name="currentIndex">The index in the collection to start the search from.</param>
        /// <param name="keyStruck">The character of the key the user pressed.</param>
        /// <returns>The index of the item that matches what the user has typed. 
        /// Returns <see langword="-1"/> if no item in the collection matched.</returns>
        public int GetNextMatchingItem(int currentIndex, char keyStruck)
        {
            AssertCollectionIsNotNull();
            if (!char.IsControl(keyStruck))
            {

                // maybe user pressed 'd' and now presses 'd' again.
                // a candidate search is things that begin with "dd"
                // but if we find none then we must fallback on cycling
                // d instead and discard the candidate state
                string candidateState = "";

                // is it a second or third (etc) keystroke within a short time
                if (SearchString.Length > 0 && DateTime.Now - lastKeystroke < TimeSpan.FromMilliseconds(TypingDelay))
                {
                    // "dd" is a candidate
                    candidateState = SearchString + keyStruck;
                }
                else
                {
                    // its a fresh keystroke after some time
                    // or its first ever key press
                    SearchString = new string(keyStruck, 1);
                }

                var idxCandidate = GetNextMatchingItem(currentIndex, candidateState,
                    // prefer not to move if there are multiple characters e.g. "ca" + 'r' should stay on "car" and not jump to "cart"
                    candidateState.Length > 1);

                if (idxCandidate != -1)
                {
                    // found "dd" so candidate searchstring is accepted
                    lastKeystroke = DateTime.Now;
                    SearchString = candidateState;
                    return idxCandidate;
                }

                //// nothing matches "dd" so discard it as a candidate
                //// and just cycle "d" instead
                lastKeystroke = DateTime.Now;
                idxCandidate = GetNextMatchingItem(currentIndex, candidateState);

                // if a match wasn't found, the user typed a 'wrong' key in their search ("can" + 'z'
                // instead of "can" + 'd').
                if (SearchString.Length > 1 && idxCandidate == -1)
                {
                    // ignore it since we're still within the typing delay
                    // don't add it to SearchString either
                    return currentIndex;
                }

                // if no changes to current state manifested
                if (idxCandidate == currentIndex || idxCandidate == -1)
                {
                    // clear history and treat as a fresh letter
                    ClearSearchString();

                    // match on the fresh letter alone
                    SearchString = new string(keyStruck, 1);
                    idxCandidate = GetNextMatchingItem(currentIndex, SearchString);
                    return idxCandidate == -1 ? currentIndex : idxCandidate;
                }

                // Found another "d" or just leave index as it was
                return idxCandidate;

            }
            else
            {
                // clear state because keypress was a control char
                ClearSearchString();

                // control char indicates no selection
                return -1;
            }
        }

        /// <summary>
        /// Gets the index of the next item in the collection that matches <paramref name="search"/>. 
        /// </summary>
        /// <param name="currentIndex">The index in the collection to start the search from.</param>
        /// <param name="search">The search string to use.</param>
        /// <param name="minimizeMovement">Set to <see langword="true"/> to stop the search on the first match
        /// if there are multiple matches for <paramref name="search"/>.
        /// e.g. "ca" + 'r' should stay on "car" and not jump to "cart". If <see langword="false"/> (the default), 
        /// the next matching item will be returned, even if it is above in the collection.
        /// </param>
        /// <returns>The index of the next matching item or <see langword="-1"/> if no match was found.</returns>
        internal int GetNextMatchingItem(int currentIndex, string search, bool minimizeMovement = false)
        {
            if (string.IsNullOrEmpty(search))
            {
                return -1;
            }
            AssertCollectionIsNotNull();

            // find indexes of items that start with the search text
            int[] matchingIndexes = Collection.Select((item, idx) => (item, idx))
                  .Where(k => k.item?.ToString().StartsWith(search, StringComparison.InvariantCultureIgnoreCase) ?? false)
                  .Select(k => k.idx)
                  .ToArray();

            // if there are items beginning with search
            if (matchingIndexes.Length > 0)
            {
                // is one of them currently selected?
                var currentlySelected = Array.IndexOf(matchingIndexes, currentIndex);

                if (currentlySelected == -1)
                {
                    // we are not currently selecting any item beginning with the search
                    // so jump to first item in list that begins with the letter
                    return matchingIndexes[0];
                }
                else
                {

                    // the current index is part of the matching collection
                    if (minimizeMovement)
                    {
                        // if we would rather not jump around (e.g. user is typing lots of text to get this match)
                        return matchingIndexes[currentlySelected];
                    }

                    // cycle to next (circular)
                    return matchingIndexes[(currentlySelected + 1) % matchingIndexes.Length];
                }
            }

            // nothing starts with the search
            return -1;
        }

        private void AssertCollectionIsNotNull()
        {
            if (Collection == null)
            {
                throw new InvalidOperationException("Collection is null");
            }
        }

        private void ClearSearchString()
        {
            SearchString = "";
            lastKeystroke = DateTime.Now;
        }

        /// <summary>
        /// Returns true if <paramref name="kb"/> is a searchable key
        /// (e.g. letters, numbers etc) that is valid to pass to to this
        /// class for search filtering.
        /// </summary>
        /// <param name="kb"></param>
        /// <returns></returns>
        public static bool IsCompatibleKey(KeyEvent kb)
        {
            return !kb.IsAlt && !kb.IsCapslock && !kb.IsCtrl && !kb.IsScrolllock && !kb.IsNumlock;
        }
    }
    //=======================================================================
    /// <summary>
    /// The <see cref="ColorPicker"/> <see cref="View"/> Color picker.
    /// </summary>
    public class ColorPicker : View
    {
        /// <summary>
        /// Number of colors on a line.
        /// </summary>
        private static readonly int colorsPerLine = 8;

        /// <summary>
        /// Number of color lines.
        /// </summary>
        private static readonly int lineCount = 2;

        /// <summary>
        /// Horizontal zoom.
        /// </summary>
        private static readonly int horizontalZoom = 4;

        /// <summary>
        /// Vertical zoom.
        /// </summary>
        private static readonly int verticalZoom = 2;

        // Cursor runes.
        private static readonly Rune[] cursorRunes = new Rune[]
        {
            0x250C, 0x2500, 0x2500, 0x2510,
            0x2514, 0x2500, 0x2500, 0x2518
        };

        /// <summary>
        /// Cursor for the selected color.
        /// </summary>
        public Point Cursor
        {
            get
            {
                return new Point(selectColorIndex % colorsPerLine, selectColorIndex / colorsPerLine);
            }

            set
            {
                var colorIndex = value.Y * colorsPerLine + value.X;
                SelectedColor = (Color)colorIndex;
            }
        }

        /// <summary>
        /// Fired when a color is picked.
        /// </summary>
        public event Action ColorChanged;

        private int selectColorIndex = (int)Color.Black;

        /// <summary>
        /// Selected color.
        /// </summary>
        public Color SelectedColor
        {
            get
            {
                return (Color)selectColorIndex;
            }

            set
            {
                selectColorIndex = (int)value;
                ColorChanged?.Invoke();
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ColorPicker"/>.
        /// </summary>
        public ColorPicker() : base("Color Picker")
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ColorPicker"/>.
        /// </summary>
        /// <param name="title">Title.</param>
        public ColorPicker(ustring title) : base(title)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ColorPicker"/>.
        /// </summary>
        /// <param name="point">Location point.</param>
        /// <param name="title">Title.</param>
        public ColorPicker(Point point, ustring title) : this(point.X, point.Y, title)
        {
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ColorPicker"/>.
        /// </summary>
        /// <param name="x">X location.</param>
        /// <param name="y">Y location.</param>
        /// <param name="title">Title</param>
        public ColorPicker(int x, int y, ustring title) : base(x, y, title)
        {
            Initialize();
        }

        private void Initialize()
        {
            CanFocus = true;
            Width = colorsPerLine * horizontalZoom;
            Height = lineCount * verticalZoom + 1;

            AddCommands();
            AddKeyBindings();
        }

        /// <summary>
        /// Add the commands.
        /// </summary>
        private void AddCommands()
        {
            AddCommand(Command.Left, () => MoveLeft());
            AddCommand(Command.Right, () => MoveRight());
            AddCommand(Command.LineUp, () => MoveUp());
            AddCommand(Command.LineDown, () => MoveDown());
        }

        /// <summary>
        /// Add the KeyBindinds.
        /// </summary>
        private void AddKeyBindings()
        {
            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.CursorDown, Command.LineDown);
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            base.Redraw(bounds);

            Driver.SetAttribute(HasFocus ? ColorScheme.Focus : GetNormalColor());
            var colorIndex = 0;

            for (var y = 0; y < (Height.Anchor(0) - 1) / verticalZoom; y++)
            {
                for (var x = 0; x < Width.Anchor(0) / horizontalZoom; x++)
                {
                    var foregroundColorIndex = y == 0 ? colorIndex + colorsPerLine : colorIndex - colorsPerLine;
                    Driver.SetAttribute(Driver.MakeAttribute((Color)foregroundColorIndex, (Color)colorIndex));
                    var selected = x == Cursor.X && y == Cursor.Y;
                    DrawColorBox(x, y, selected);
                    colorIndex++;
                }
            }
        }

        /// <summary>
        /// Draw a box for one color.
        /// </summary>
        /// <param name="x">X location.</param>
        /// <param name="y">Y location</param>
        /// <param name="selected"></param>
        private void DrawColorBox(int x, int y, bool selected)
        {
            var index = 0;

            for (var zommedY = 0; zommedY < verticalZoom; zommedY++)
            {
                for (var zommedX = 0; zommedX < horizontalZoom; zommedX++)
                {
                    Move(x * horizontalZoom + zommedX, y * verticalZoom + zommedY + 1);

                    if (selected)
                    {
                        var character = cursorRunes[index];
                        Driver.AddRune(character);
                    }
                    else
                    {
                        Driver.AddRune(' ');
                    }

                    index++;
                }
            }
        }

        /// <summary>
        /// Moves the selected item index to the previous column.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveLeft()
        {
            if (Cursor.X > 0) SelectedColor--;
            return true;
        }

        /// <summary>
        /// Moves the selected item index to the next column.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveRight()
        {
            if (Cursor.X < colorsPerLine - 1) SelectedColor++;
            return true;
        }

        /// <summary>
        /// Moves the selected item index to the previous row.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveUp()
        {
            if (Cursor.Y > 0) SelectedColor -= colorsPerLine;
            return true;
        }

        /// <summary>
        /// Moves the selected item index to the next row.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveDown()
        {
            if (Cursor.Y < lineCount - 1) SelectedColor += colorsPerLine;
            return true;
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            return false;
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) || !CanFocus)
                return false;

            SetFocus();
            Cursor = new Point(me.X / horizontalZoom, (me.Y - 1) / verticalZoom);

            return true;
        }
    }
    //=======================================================================
    //
    // ComboBox.cs: ComboBox control
    //
    // Authors:
    //   Ross Ferguson (ross.c.ferguson@btinternet.com)
    //

    /// <summary>
    /// Provides a drop-down list of items the user can select from.
    /// </summary>
    public class ComboBox : View
    {

        private class ComboListView : ListView
        {
            private int highlighted = -1;
            private bool isFocusing;
            private ComboBox container;
            private bool hideDropdownListOnClick;

            public ComboListView(ComboBox container, bool hideDropdownListOnClick)
            {
                Initialize(container, hideDropdownListOnClick);
            }

            public ComboListView(ComboBox container, Rect rect, IList source, bool hideDropdownListOnClick) : base(rect, source)
            {
                Initialize(container, hideDropdownListOnClick);
            }

            public ComboListView(ComboBox container, IList source, bool hideDropdownListOnClick) : base(source)
            {
                Initialize(container, hideDropdownListOnClick);
            }

            private void Initialize(ComboBox container, bool hideDropdownListOnClick)
            {
                this.container = container ?? throw new ArgumentNullException(nameof(container), "ComboBox container cannot be null.");
                HideDropdownListOnClick = hideDropdownListOnClick;
            }

            public bool HideDropdownListOnClick
            {
                get => hideDropdownListOnClick;
                set => hideDropdownListOnClick = WantContinuousButtonPressed = value;
            }

            public override bool MouseEvent(MouseEvent me)
            {
                var res = false;
                var isMousePositionValid = IsMousePositionValid(me);

                if (isMousePositionValid)
                {
                    res = base.MouseEvent(me);
                }

                if (HideDropdownListOnClick && me.Flags == MouseFlags.Button1Clicked)
                {
                    if (!isMousePositionValid && !isFocusing)
                    {
                        container.isShow = false;
                        container.HideList();
                    }
                    else if (isMousePositionValid)
                    {
                        OnOpenSelectedItem();
                    }
                    else
                    {
                        isFocusing = false;
                    }
                    return true;
                }
                else if (me.Flags == MouseFlags.ReportMousePosition && HideDropdownListOnClick)
                {
                    if (isMousePositionValid)
                    {
                        highlighted = Math.Min(TopItem + me.Y, Source.Count);
                        SetNeedsDisplay();
                    }
                    isFocusing = false;
                    return true;
                }

                return res;
            }

            private bool IsMousePositionValid(MouseEvent me)
            {
                if (me.X >= 0 && me.X < Frame.Width && me.Y >= 0 && me.Y < Frame.Height)
                {
                    return true;
                }
                return false;
            }

            public override void Redraw(Rect bounds)
            {
                var current = ColorScheme.Focus;
                Driver.SetAttribute(current);
                Move(0, 0);
                var f = Frame;
                var item = TopItem;
                bool focused = HasFocus;
                int col = AllowsMarking ? 2 : 0;
                int start = LeftItem;

                for (int row = 0; row < f.Height; row++, item++)
                {
                    bool isSelected = item == container.SelectedItem;
                    bool isHighlighted = hideDropdownListOnClick && item == highlighted;

                    Attribute newcolor;
                    if (isHighlighted || (isSelected && !hideDropdownListOnClick))
                    {
                        newcolor = focused ? ColorScheme.Focus : ColorScheme.HotNormal;
                    }
                    else if (isSelected && hideDropdownListOnClick)
                    {
                        newcolor = focused ? ColorScheme.HotFocus : ColorScheme.HotNormal;
                    }
                    else
                    {
                        newcolor = focused ? GetNormalColor() : GetNormalColor();
                    }

                    if (newcolor != current)
                    {
                        Driver.SetAttribute(newcolor);
                        current = newcolor;
                    }

                    Move(0, row);
                    if (Source == null || item >= Source.Count)
                    {
                        for (int c = 0; c < f.Width; c++)
                            Driver.AddRune(' ');
                    }
                    else
                    {
                        var rowEventArgs = new ListViewRowEventArgs(item);
                        OnRowRender(rowEventArgs);
                        if (rowEventArgs.RowAttribute != null && current != rowEventArgs.RowAttribute)
                        {
                            current = (Attribute)rowEventArgs.RowAttribute;
                            Driver.SetAttribute(current);
                        }
                        if (AllowsMarking)
                        {
                            Driver.AddRune(Source.IsMarked(item) ? (AllowsMultipleSelection ? Driver.Checked : Driver.Selected) : (AllowsMultipleSelection ? Driver.UnChecked : Driver.UnSelected));
                            Driver.AddRune(' ');
                        }
                        Source.Render(this, Driver, isSelected, item, col, row, f.Width - col, start);
                    }
                }
            }

            public override bool OnEnter(View view)
            {
                if (hideDropdownListOnClick)
                {
                    isFocusing = true;
                    highlighted = container.SelectedItem;
                    Application.GrabMouse(this);
                }

                return base.OnEnter(view);
            }

            public override bool OnLeave(View view)
            {
                if (hideDropdownListOnClick)
                {
                    isFocusing = false;
                    highlighted = container.SelectedItem;
                    Application.UngrabMouse();
                }

                return base.OnLeave(view);
            }

            public override bool OnSelectedChanged()
            {
                var res = base.OnSelectedChanged();

                highlighted = SelectedItem;

                return res;
            }
        }

        IListDataSource source;
        /// <summary>
        /// Gets or sets the <see cref="IListDataSource"/> backing this <see cref="ComboBox"/>, enabling custom rendering.
        /// </summary>
        /// <value>The source.</value>
        /// <remarks>
        ///  Use <see cref="SetSource"/> to set a new <see cref="IList"/> source.
        /// </remarks>
        public IListDataSource Source
        {
            get => source;
            set
            {
                source = value;

                // Only need to refresh list if its been added to a container view
                if (SuperView != null && SuperView.Subviews.Contains(this))
                {
                    SelectedItem = -1;
                    search.Text = "";
                    Search_Changed("");
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Sets the source of the <see cref="ComboBox"/> to an <see cref="IList"/>.
        /// </summary>
        /// <value>An object implementing the IList interface.</value>
        /// <remarks>
        ///  Use the <see cref="Source"/> property to set a new <see cref="IListDataSource"/> source and use custome rendering.
        /// </remarks>
        public void SetSource(IList source)
        {
            if (source == null)
            {
                Source = null;
            }
            else
            {
                listview.SetSource(source);
                Source = listview.Source;
            }
        }

        /// <summary>
        /// This event is raised when the selected item in the <see cref="ComboBox"/> has changed.
        /// </summary>
        public event Action<ListViewItemEventArgs> SelectedItemChanged;

        /// <summary>
        /// This event is raised when the drop-down list is expanded.
        /// </summary>
        public event Action Expanded;

        /// <summary>
        /// This event is raised when the drop-down list is collapsed.
        /// </summary>
        public event Action Collapsed;

        /// <summary>
        /// This event is raised when the user Double Clicks on an item or presses ENTER to open the selected item.
        /// </summary>
        public event Action<ListViewItemEventArgs> OpenSelectedItem;

        readonly IList searchset = new List<object>();
        ustring text = "";
        readonly TextField search;
        readonly ComboListView listview;
        bool autoHide = true;
        readonly int minimumHeight = 2;

        /// <summary>
        /// Public constructor
        /// </summary>
        public ComboBox() : this(string.Empty)
        {
        }

        /// <summary>
        /// Public constructor
        /// </summary>
        /// <param name="text"></param>
        public ComboBox(ustring text) : base()
        {
            search = new TextField("");
            listview = new ComboListView(this, HideDropdownListOnClick) { LayoutStyle = LayoutStyle.Computed, CanFocus = true, TabStop = false };

            Initialize();
            Text = text;
        }

        /// <summary>
        /// Public constructor
        /// </summary>
        /// <param name="rect"></param>
        /// <param name="source"></param>
        public ComboBox(Rect rect, IList source) : base(rect)
        {
            search = new TextField("") { Width = rect.Width };
            listview = new ComboListView(this, rect, source, HideDropdownListOnClick) { LayoutStyle = LayoutStyle.Computed, ColorScheme = Colors.Base };

            Initialize();
            SetSource(source);
        }

        /// <summary>
        /// Initialize with the source.
        /// </summary>
        /// <param name="source">The source.</param>
        public ComboBox(IList source) : this(string.Empty)
        {
            search = new TextField("");
            listview = new ComboListView(this, source, HideDropdownListOnClick) { LayoutStyle = LayoutStyle.Computed, ColorScheme = Colors.Base };

            Initialize();
            SetSource(source);
        }

        private void Initialize()
        {
            if (Bounds.Height < minimumHeight && (Height == null || Height is Dim.DimAbsolute))
            {
                Height = minimumHeight;
            }

            search.TextChanged += Search_Changed;

            listview.Y = Pos.Bottom(search);
            listview.OpenSelectedItem += (ListViewItemEventArgs a) => Selected();

            this.Add(search, listview);

            // On resize
            LayoutComplete += (LayoutEventArgs a) =>
            {
                if ((!autoHide && Bounds.Width > 0 && search.Frame.Width != Bounds.Width) ||
                    (autoHide && Bounds.Width > 0 && search.Frame.Width != Bounds.Width - 1))
                {
                    search.Width = listview.Width = autoHide ? Bounds.Width - 1 : Bounds.Width;
                    listview.Height = CalculatetHeight();
                    search.SetRelativeLayout(Bounds);
                    listview.SetRelativeLayout(Bounds);
                }
            };

            listview.SelectedItemChanged += (ListViewItemEventArgs e) =>
            {

                if (!HideDropdownListOnClick && searchset.Count > 0)
                {
                    SetValue(searchset[listview.SelectedItem]);
                }
            };

            Added += (View v) =>
            {

                // Determine if this view is hosted inside a dialog and is the only control
                for (View view = this.SuperView; view != null; view = view.SuperView)
                {
                    if (view is Dialog && SuperView != null && SuperView.Subviews.Count == 1 && SuperView.Subviews[0] == this)
                    {
                        autoHide = false;
                        break;
                    }
                }

                SetNeedsLayout();
                SetNeedsDisplay();
                Search_Changed(Text);
            };

            // Things this view knows how to do
            AddCommand(Command.Accept, () => ActivateSelected());
            AddCommand(Command.ToggleExpandCollapse, () => ExpandCollapse());
            AddCommand(Command.Expand, () => Expand());
            AddCommand(Command.Collapse, () => Collapse());
            AddCommand(Command.LineDown, () => MoveDown());
            AddCommand(Command.LineUp, () => MoveUp());
            AddCommand(Command.PageDown, () => PageDown());
            AddCommand(Command.PageUp, () => PageUp());
            AddCommand(Command.TopHome, () => MoveHome());
            AddCommand(Command.BottomEnd, () => MoveEnd());
            AddCommand(Command.Cancel, () => CancelSelected());
            AddCommand(Command.UnixEmulation, () => UnixEmulation());

            // Default keybindings for this view
            AddKeyBinding(Key.Enter, Command.Accept);
            AddKeyBinding(Key.F4, Command.ToggleExpandCollapse);
            AddKeyBinding(Key.CursorDown, Command.LineDown);
            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.PageDown, Command.PageDown);
            AddKeyBinding(Key.PageUp, Command.PageUp);
            AddKeyBinding(Key.Home, Command.TopHome);
            AddKeyBinding(Key.End, Command.BottomEnd);
            AddKeyBinding(Key.Esc, Command.Cancel);
            AddKeyBinding(Key.U | Key.CtrlMask, Command.UnixEmulation);
        }

        private bool isShow = false;
        private int selectedItem = -1;
        private int lastSelectedItem = -1;
        private bool hideDropdownListOnClick;

        /// <summary>
        /// Gets the index of the currently selected item in the <see cref="Source"/>
        /// </summary>
        /// <value>The selected item or -1 none selected.</value>
        public int SelectedItem
        {
            get => selectedItem;
            set
            {
                if (selectedItem != value && (value == -1
                    || (source != null && value > -1 && value < source.Count)))
                {

                    selectedItem = lastSelectedItem = value;
                    if (selectedItem != -1)
                    {
                        SetValue(source.ToList()[selectedItem].ToString(), true);
                    }
                    else
                    {
                        SetValue("", true);
                    }
                    OnSelectedChanged();
                }
            }
        }

        /// <summary>
        /// Gets the drop down list state, expanded or collapsed.
        /// </summary>
        public bool IsShow => isShow;

        ///<inheritdoc/>
        public new ColorScheme ColorScheme
        {
            get
            {
                return base.ColorScheme;
            }
            set
            {
                listview.ColorScheme = value;
                base.ColorScheme = value;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        ///If set to true its not allow any changes in the text.
        /// </summary>
        public bool ReadOnly
        {
            get => search.ReadOnly;
            set
            {
                search.ReadOnly = value;
                if (search.ReadOnly)
                {
                    if (search.ColorScheme != null)
                    {
                        search.ColorScheme.Normal = search.ColorScheme.Focus;
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets if the drop-down list can be hide with a button click event.
        /// </summary>
        public bool HideDropdownListOnClick
        {
            get => hideDropdownListOnClick;
            set => hideDropdownListOnClick = listview.HideDropdownListOnClick = value;
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (me.X == Bounds.Right - 1 && me.Y == Bounds.Top && me.Flags == MouseFlags.Button1Pressed
                && autoHide)
            {

                if (isShow)
                {
                    isShow = false;
                    HideList();
                }
                else
                {
                    SetSearchSet();

                    isShow = true;
                    ShowList();
                    FocusSelectedItem();
                }

                return true;
            }
            else if (me.Flags == MouseFlags.Button1Pressed)
            {
                if (!search.HasFocus)
                {
                    search.SetFocus();
                }

                return true;
            }

            return false;
        }

        private void FocusSelectedItem()
        {
            listview.SelectedItem = SelectedItem > -1 ? SelectedItem : 0;
            listview.TabStop = true;
            listview.SetFocus();
            OnExpanded();
        }

        /// <summary>
        /// Virtual method which invokes the <see cref="Expanded"/> event.
        /// </summary>
        public virtual void OnExpanded()
        {
            Expanded?.Invoke();
        }

        /// <summary>
        /// Virtual method which invokes the <see cref="Collapsed"/> event.
        /// </summary>
        public virtual void OnCollapsed()
        {
            Collapsed?.Invoke();
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            if (!search.HasFocus && !listview.HasFocus)
            {
                search.SetFocus();
            }

            search.CursorPosition = search.Text.RuneCount;

            return base.OnEnter(view);
        }

        ///<inheritdoc/>
        public override bool OnLeave(View view)
        {
            if (source?.Count > 0 && selectedItem > -1 && selectedItem < source.Count - 1
                && text != source.ToList()[selectedItem].ToString())
            {

                SetValue(source.ToList()[selectedItem].ToString());
            }
            if (autoHide && isShow && view != this && view != search && view != listview)
            {
                isShow = false;
                HideList();
            }
            else if (listview.TabStop)
            {
                listview.TabStop = false;
            }

            return base.OnLeave(view);
        }

        /// <summary>
        /// Invokes the SelectedChanged event if it is defined.
        /// </summary>
        /// <returns></returns>
        public virtual bool OnSelectedChanged()
        {
            // Note: Cannot rely on "listview.SelectedItem != lastSelectedItem" because the list is dynamic. 
            // So we cannot optimize. Ie: Don't call if not changed
            SelectedItemChanged?.Invoke(new ListViewItemEventArgs(SelectedItem, search.Text));

            return true;
        }

        /// <summary>
        /// Invokes the OnOpenSelectedItem event if it is defined.
        /// </summary>
        /// <returns></returns>
        public virtual bool OnOpenSelectedItem()
        {
            var value = search.Text;
            lastSelectedItem = SelectedItem;
            OpenSelectedItem?.Invoke(new ListViewItemEventArgs(SelectedItem, value));

            return true;
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            base.Redraw(bounds);

            if (!autoHide)
            {
                return;
            }

            Driver.SetAttribute(ColorScheme.Focus);
            Move(Bounds.Right - 1, 0);
            Driver.AddRune(Driver.DownArrow);
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent e)
        {
            var result = InvokeKeybindings(e);
            if (result != null)
                return (bool)result;

            return base.ProcessKey(e);
        }

        bool UnixEmulation()
        {
            // Unix emulation
            Reset();
            return true;
        }

        bool CancelSelected()
        {
            search.SetFocus();
            if (ReadOnly || HideDropdownListOnClick)
            {
                SelectedItem = lastSelectedItem;
                if (SelectedItem > -1 && listview.Source?.Count > 0)
                {
                    search.Text = text = listview.Source.ToList()[SelectedItem].ToString();
                }
            }
            else if (!ReadOnly)
            {
                search.Text = text = "";
                selectedItem = lastSelectedItem;
                OnSelectedChanged();
            }
            Collapse();
            return true;
        }

        bool? MoveEnd()
        {
            if (!isShow && search.HasFocus)
            {
                return null;
            }
            if (HasItems())
            {
                listview.MoveEnd();
            }
            return true;
        }

        bool? MoveHome()
        {
            if (!isShow && search.HasFocus)
            {
                return null;
            }
            if (HasItems())
            {
                listview.MoveHome();
            }
            return true;
        }

        bool PageUp()
        {
            if (HasItems())
            {
                listview.MovePageUp();
            }
            return true;
        }

        bool PageDown()
        {
            if (HasItems())
            {
                listview.MovePageDown();
            }
            return true;
        }

        bool? MoveUp()
        {
            if (search.HasFocus)
            { // stop odd behavior on KeyUp when search has focus
                return true;
            }

            if (listview.HasFocus && listview.SelectedItem == 0 && searchset?.Count > 0) // jump back to search
            {
                search.CursorPosition = search.Text.RuneCount;
                search.SetFocus();
                return true;
            }
            return null;
        }

        bool? MoveDown()
        {
            if (search.HasFocus)
            { // jump to list
                if (searchset?.Count > 0)
                {
                    listview.TabStop = true;
                    listview.SetFocus();
                    SetValue(searchset[listview.SelectedItem]);
                }
                else
                {
                    listview.TabStop = false;
                    SuperView?.FocusNext();
                }
                return true;
            }
            return null;
        }

        /// <summary>
        /// Toggles the expand/collapse state of the sublist in the combo box
        /// </summary>
        /// <returns></returns>
        bool ExpandCollapse()
        {
            if (search.HasFocus || listview.HasFocus)
            {
                if (!isShow)
                {
                    return Expand();
                }
                else
                {
                    return Collapse();
                }
            }
            return false;
        }

        bool ActivateSelected()
        {
            if (HasItems())
            {
                Selected();
                return true;
            }
            return false;
        }

        bool HasItems()
        {
            return Source?.Count > 0;
        }

        /// <summary>
        /// Collapses the drop down list.  Returns true if the state chagned or false
        /// if it was already collapsed and no action was taken
        /// </summary>
        public virtual bool Collapse()
        {
            if (!isShow)
            {
                return false;
            }

            isShow = false;
            HideList();
            return true;
        }

        /// <summary>
        /// Expands the drop down list.  Returns true if the state chagned or false
        /// if it was already expanded and no action was taken
        /// </summary>
        public virtual bool Expand()
        {
            if (isShow)
            {
                return false;
            }

            SetSearchSet();
            isShow = true;
            ShowList();
            FocusSelectedItem();

            return true;
        }

        /// <summary>
        /// The currently selected list item
        /// </summary>
        public new ustring Text
        {
            get
            {
                return text;
            }
            set
            {
                SetSearchText(value);
            }
        }

        /// <summary>
        /// Current search text 
        /// </summary>
        public ustring SearchText
        {
            get
            {
                return search.Text;
            }
            set
            {
                SetSearchText(value);
            }
        }

        private void SetValue(object text, bool isFromSelectedItem = false)
        {
            search.TextChanged -= Search_Changed;
            this.text = search.Text = text.ToString();
            search.CursorPosition = 0;
            search.TextChanged += Search_Changed;
            if (!isFromSelectedItem)
            {
                selectedItem = GetSelectedItemFromSource(this.text);
                OnSelectedChanged();
            }
        }

        private void Selected()
        {
            isShow = false;
            listview.TabStop = false;

            if (listview.Source.Count == 0 || (searchset?.Count ?? 0) == 0)
            {
                text = "";
                HideList();
                return;
            }

            SetValue(searchset[listview.SelectedItem]);
            search.CursorPosition = search.Text.ConsoleWidth;
            Search_Changed(search.Text);
            OnOpenSelectedItem();
            Reset(keepSearchText: true);
            HideList();
        }

        private int GetSelectedItemFromSource(ustring value)
        {
            if (source == null)
            {
                return -1;
            }
            for (int i = 0; i < source.Count; i++)
            {
                if (source.ToList()[i].ToString() == value)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Reset to full original list
        /// </summary>
        private void Reset(bool keepSearchText = false)
        {
            if (!keepSearchText)
            {
                SetSearchText(string.Empty);
            }

            ResetSearchSet();

            listview.SetSource(searchset);
            listview.Height = CalculatetHeight();

            if (HasFocus && Subviews.Count > 0)
            {
                search.SetFocus();
            }
        }

        private void SetSearchText(ustring value)
        {
            search.Text = text = value;
        }

        private void ResetSearchSet(bool noCopy = false)
        {
            searchset.Clear();

            if (autoHide || noCopy)
                return;
            SetSearchSet();
        }

        private void SetSearchSet()
        {
            if (Source == null) { return; }
            // force deep copy
            foreach (var item in Source.ToList())
            {
                searchset.Add(item);
            }
        }

        private void Search_Changed(ustring text)
        {
            if (source == null)
            { // Object initialization		
                return;
            }

            if (ustring.IsNullOrEmpty(search.Text) && ustring.IsNullOrEmpty(text))
            {
                ResetSearchSet();
            }
            else if (search.Text != text)
            {
                isShow = true;
                ResetSearchSet(noCopy: true);

                foreach (var item in source.ToList())
                { // Iterate to preserver object type and force deep copy
                    if (item.ToString().StartsWith(search.Text.ToString(), StringComparison.CurrentCultureIgnoreCase))
                    {
                        searchset.Add(item);
                    }
                }
            }

            if (HasFocus)
            {
                ShowList();
            }
            else if (autoHide)
            {
                isShow = false;
                HideList();
            }
        }

        /// <summary>
        /// Show the search list
        /// </summary>
        /// 
        /// Consider making public
        private void ShowList()
        {
            listview.SetSource(searchset);
            listview.Clear(); // Ensure list shrinks in Dialog as you type
            listview.Height = CalculatetHeight();
            SuperView?.BringSubviewToFront(this);
        }

        /// <summary>
        /// Hide the search list
        /// </summary>
        /// 
        /// Consider making public
        private void HideList()
        {
            if (lastSelectedItem != selectedItem)
            {
                OnOpenSelectedItem();
            }
            var rect = listview.ViewToScreen(listview.Bounds);
            Reset(keepSearchText: true);
            listview.Clear(rect);
            listview.TabStop = false;
            SuperView?.SendSubviewToBack(this);
            SuperView?.SetNeedsDisplay(rect);
            OnCollapsed();
        }

        /// <summary>
        /// Internal height of dynamic search list
        /// </summary>
        /// <returns></returns>
        private int CalculatetHeight()
        {
            if (Bounds.Height == 0)
                return 0;

            return Math.Min(Math.Max(Bounds.Height - 1, minimumHeight - 1), searchset?.Count > 0 ? searchset.Count : isShow ? Math.Max(Bounds.Height - 1, minimumHeight - 1) : 0);
        }
    }
    //=======================================================================
    // These classes use a keybinding system based on the design implemented in Scintilla.Net which is an MIT licensed open source project https://github.com/jacobslusser/ScintillaNET/blob/master/src/ScintillaNET/Command.cs

    /// <summary>
    /// Actions which can be performed by the application or bound to keys in a <see cref="View"/> control.
    /// </summary>
    public enum Command
    {

        /// <summary>
        /// Moves down one item (cell, line, etc...).
        /// </summary>
        LineDown,

        /// <summary>
        /// Extends the selection down one (cell, line, etc...).
        /// </summary>
        LineDownExtend,

        /// <summary>
        /// Moves down to the last child node of the branch that holds the current selection.
        /// </summary>
        LineDownToLastBranch,

        /// <summary>
        /// Scrolls down one (cell, line, etc...) (without changing the selection).
        /// </summary>
        ScrollDown,

        // --------------------------------------------------------------------

        /// <summary>
        /// Moves up one (cell, line, etc...).
        /// </summary>
        LineUp,

        /// <summary>
        /// Extends the selection up one item (cell, line, etc...).
        /// </summary>
        LineUpExtend,

        /// <summary>
        /// Moves up to the first child node of the branch that holds the current selection.
        /// </summary>
        LineUpToFirstBranch,

        /// <summary>
        /// Scrolls up one item (cell, line, etc...) (without changing the selection).
        /// </summary>
        ScrollUp,

        /// <summary>
        /// Moves the selection left one by the minimum increment supported by the <see cref="View"/> e.g. single character, cell, item etc.
        /// </summary>
        Left,

        /// <summary>
        /// Scrolls one item (cell, character, etc...) to the left
        /// </summary>
        ScrollLeft,

        /// <summary>
        /// Extends the selection left one by the minimum increment supported by the view e.g. single character, cell, item etc.
        /// </summary>
        LeftExtend,

        /// <summary>
        /// Moves the selection right one by the minimum increment supported by the view e.g. single character, cell, item etc.
        /// </summary>
        Right,

        /// <summary>
        /// Scrolls one item (cell, character, etc...) to the right.
        /// </summary>
        ScrollRight,

        /// <summary>
        /// Extends the selection right one by the minimum increment supported by the view e.g. single character, cell, item etc.
        /// </summary>
        RightExtend,

        /// <summary>
        /// Moves the caret to the start of the previous word.
        /// </summary>
        WordLeft,

        /// <summary>
        /// Extends the selection to the start of the previous word.
        /// </summary>
        WordLeftExtend,

        /// <summary>
        /// Moves the caret to the start of the next word.
        /// </summary>
        WordRight,

        /// <summary>
        /// Extends the selection to the start of the next word.
        /// </summary>
        WordRightExtend,

        /// <summary>
        /// Cuts to the clipboard the characters from the current position to the end of the line.
        /// </summary>
        CutToEndLine,

        /// <summary>
        /// Cuts to the clipboard the characters from the current position to the start of the line.
        /// </summary>
        CutToStartLine,

        /// <summary>
        /// Deletes the characters forwards.
        /// </summary>
        KillWordForwards,

        /// <summary>
        /// Deletes the characters backwards.
        /// </summary>
        KillWordBackwards,

        /// <summary>
        /// Toggles overwrite mode such that newly typed text overwrites the text that is
        /// already there (typically associated with the Insert key).
        /// </summary>
        ToggleOverwrite,


        /// <summary>
        /// Enables overwrite mode such that newly typed text overwrites the text that is
        /// already there (typically associated with the Insert key).
        /// </summary>
        EnableOverwrite,

        /// <summary>
        /// Disables overwrite mode (<see cref="EnableOverwrite"/>)
        /// </summary>
        DisableOverwrite,

        /// <summary>
        /// Move one page down.
        /// </summary>
        PageDown,

        /// <summary>
        /// Move one page page extending the selection to cover revealed objects/characters.
        /// </summary>
        PageDownExtend,

        /// <summary>
        /// Move one page up.
        /// </summary>
        PageUp,

        /// <summary>
        /// Move one page up extending the selection to cover revealed objects/characters.
        /// </summary>
        PageUpExtend,

        /// <summary>
        /// Moves to the top/home.
        /// </summary>
        TopHome,

        /// <summary>
        /// Extends the selection to the top/home.
        /// </summary>
        TopHomeExtend,

        /// <summary>
        /// Moves to the bottom/end.
        /// </summary>
        BottomEnd,

        /// <summary>
        /// Extends the selection to the bottom/end.
        /// </summary>
        BottomEndExtend,

        /// <summary>
        /// Open the selected item.
        /// </summary>
        OpenSelectedItem,

        /// <summary>
        /// Toggle the checked state.
        /// </summary>
        ToggleChecked,

        /// <summary>
        /// Accepts the current state (e.g. selection, button press etc).
        /// </summary>
        Accept,

        /// <summary>
        /// Toggles the Expanded or collapsed state of a a list or item (with subitems).
        /// </summary>
        ToggleExpandCollapse,

        /// <summary>
        /// Expands a list or item (with subitems).
        /// </summary>
        Expand,

        /// <summary>
        /// Recursively Expands all child items and their child items (if any).
        /// </summary>
        ExpandAll,

        /// <summary>
        /// Collapses a list or item (with subitems).
        /// </summary>
        Collapse,

        /// <summary>
        /// Recursively collapses a list items of their children (if any).
        /// </summary>
        CollapseAll,

        /// <summary>
        /// Cancels an action or any temporary states on the control e.g. expanding
        /// a combo list.
        /// </summary>
        Cancel,

        /// <summary>
        /// Unix emulation.
        /// </summary>
        UnixEmulation,

        /// <summary>
        /// Deletes the character on the right.
        /// </summary>
        DeleteCharRight,

        /// <summary>
        /// Deletes the character on the left.
        /// </summary>
        DeleteCharLeft,

        /// <summary>
        /// Selects all objects.
        /// </summary>
        SelectAll,

        /// <summary>
        /// Deletes all objects.
        /// </summary>
        DeleteAll,

        /// <summary>
        /// Moves the cursor to the start of line.
        /// </summary>
        StartOfLine,

        /// <summary>
        /// Extends the selection to the start of line.
        /// </summary>
        StartOfLineExtend,

        /// <summary>
        /// Moves the cursor to the end of line.
        /// </summary>
        EndOfLine,

        /// <summary>
        /// Extends the selection to the end of line.
        /// </summary>
        EndOfLineExtend,

        /// <summary>
        /// Moves the cursor to the top of page.
        /// </summary>
        StartOfPage,

        /// <summary>
        /// Moves the cursor to the bottom of page.
        /// </summary>
        EndOfPage,

        /// <summary>
        /// Moves to the left page.
        /// </summary>
        PageLeft,

        /// <summary>
        /// Moves to the right page.
        /// </summary>
        PageRight,

        /// <summary>
        /// Moves to the left begin.
        /// </summary>
        LeftHome,

        /// <summary>
        /// Extends the selection to the left begin.
        /// </summary>
        LeftHomeExtend,

        /// <summary>
        /// Moves to the right end.
        /// </summary>
        RightEnd,

        /// <summary>
        /// Extends the selection to the right end.
        /// </summary>
        RightEndExtend,

        /// <summary>
        /// Undo changes.
        /// </summary>
        Undo,

        /// <summary>
        /// Redo changes.
        /// </summary>
        Redo,

        /// <summary>
        /// Copies the current selection.
        /// </summary>
        Copy,

        /// <summary>
        /// Cuts the current selection.
        /// </summary>
        Cut,

        /// <summary>
        /// Pastes the current selection.
        /// </summary>
        Paste,

        /// <summary>
        /// Quit a <see cref="Toplevel"/>.
        /// </summary>
        QuitToplevel,

        /// <summary>
        /// Suspend a application (used on Linux).
        /// </summary>
        Suspend,

        /// <summary>
        /// Moves focus to the next view.
        /// </summary>
        NextView,

        /// <summary>
        /// Moves focuss to the previous view.
        /// </summary>
        PreviousView,

        /// <summary>
        /// Moves focus to the next view or toplevel (case of MDI).
        /// </summary>
        NextViewOrTop,

        /// <summary>
        /// Moves focus to the next previous or toplevel (case of MDI).
        /// </summary>
        PreviousViewOrTop,

        /// <summary>
        /// Refresh.
        /// </summary>
        Refresh,

        /// <summary>
        /// Toggles the selection.
        /// </summary>
        ToggleExtend,

        /// <summary>
        /// Inserts a new item.
        /// </summary>
        NewLine,

        /// <summary>
        /// Tabs to the next item.
        /// </summary>
        Tab,

        /// <summary>
        /// Tabs back to the previous item.
        /// </summary>
        BackTab
    }
    //=======================================================================
    //
    // ConsoleDriver.cs: Base class for Terminal.Gui ConsoleDriver implementations.
    //

    /// <summary>
    /// Colors that can be used to set the foreground and background colors in console applications.
    /// </summary>
    /// <remarks>
    /// The <see cref="Attribute.HasValidColors"/> value indicates either no-color has been set or the color is invalid.
    /// </remarks>
    public enum Color
    {
        /// <summary>
        /// The black color.
        /// </summary>
        Black,
        /// <summary>
        /// The blue color.
        /// </summary>
        Blue,
        /// <summary>
        /// The green color.
        /// </summary>
        Green,
        /// <summary>
        /// The cyan color.
        /// </summary>
        Cyan,
        /// <summary>
        /// The red color.
        /// </summary>
        Red,
        /// <summary>
        /// The magenta color.
        /// </summary>
        Magenta,
        /// <summary>
        /// The brown color.
        /// </summary>
        Brown,
        /// <summary>
        /// The gray color.
        /// </summary>
        Gray,
        /// <summary>
        /// The dark gray color.
        /// </summary>
        DarkGray,
        /// <summary>
        /// The bright bBlue color.
        /// </summary>
        BrightBlue,
        /// <summary>
        /// The bright green color.
        /// </summary>
        BrightGreen,
        /// <summary>
        /// The bright cyan color.
        /// </summary>
        BrightCyan,
        /// <summary>
        /// The bright red color.
        /// </summary>
        BrightRed,
        /// <summary>
        /// The bright magenta color.
        /// </summary>
        BrightMagenta,
        /// <summary>
        /// The bright yellow color.
        /// </summary>
        BrightYellow,
        /// <summary>
        /// The White color.
        /// </summary>
        White
    }

    /// <summary>
    /// Indicates the RGB for true colors.
    /// </summary>
    public class TrueColor
    {
        /// <summary>
        /// Red color component.
        /// </summary>
        public int Red { get; }
        /// <summary>
        /// Green color component.
        /// </summary>
        public int Green { get; }
        /// <summary>
        /// Blue color component.
        /// </summary>
        public int Blue { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="TrueColor"/> struct.
        /// </summary>
        /// <param name="red"></param>
        /// <param name="green"></param>
        /// <param name="blue"></param>
        public TrueColor(int red, int green, int blue)
        {
            Red = red;
            Green = green;
            Blue = blue;
        }

        /// <summary>
        /// Converts true color to console color.
        /// </summary>
        /// <returns></returns>
        public Color ToConsoleColor()
        {
            var trueColorMap = new Dictionary<TrueColor, Color>() {
                { new TrueColor (0,0,0),Color.Black},
                { new TrueColor (0, 0, 0x80),Color.Blue},
                { new TrueColor (0, 0x80, 0),Color.Green},
                { new TrueColor (0, 0x80, 0x80),Color.Cyan},
                { new TrueColor (0x80, 0, 0),Color.Red},
                { new TrueColor (0x80, 0, 0x80),Color.Magenta},
                { new TrueColor (0xC1, 0x9C, 0x00),Color.Brown},  // TODO confirm this
				{ new TrueColor (0xC0, 0xC0, 0xC0),Color.Gray},
                { new TrueColor (0x80, 0x80, 0x80),Color.DarkGray},
                { new TrueColor (0, 0, 0xFF),Color.BrightBlue},
                { new TrueColor (0, 0xFF, 0),Color.BrightGreen},
                { new TrueColor (0, 0xFF, 0xFF),Color.BrightCyan},
                { new TrueColor (0xFF, 0, 0),Color.BrightRed},
                { new TrueColor (0xFF, 0, 0xFF),Color.BrightMagenta },
                { new TrueColor (0xFF, 0xFF, 0),Color.BrightYellow},
                { new TrueColor (0xFF, 0xFF, 0xFF),Color.White},
                };
            // Iterate over all colors in the map
            var distances = trueColorMap.Select(
                            k => Tuple.Create(
                                // the candidate we are considering matching against (RGB)
                                k.Key,

                                CalculateDistance(k.Key, this)
                            ));

            // get the closest
            var match = distances.OrderBy(t => t.Item2).First();
            return trueColorMap[match.Item1];
        }

        private float CalculateDistance(TrueColor color1, TrueColor color2)
        {
            // use RGB distance
            return
                Math.Abs(color1.Red - color2.Red) +
                Math.Abs(color1.Green - color2.Green) +
                Math.Abs(color1.Blue - color2.Blue);
        }
    }

    /// <summary>
    /// Attributes are used as elements that contain both a foreground and a background or platform specific features.
    /// </summary>
    /// <remarks>
    ///   <see cref="Attribute"/>s are needed to map colors to terminal capabilities that might lack colors. 
    ///   They encode both the foreground and the background color and are used in the <see cref="ColorScheme"/>
    ///   class to define color schemes that can be used in an application.
    /// </remarks>
    public struct Attribute
    {
        /// <summary>
        /// The <see cref="ConsoleDriver"/>-specific color attribute value. If <see cref="Initialized"/> is <see langword="false"/> 
        /// the value of this property is invalid (typically because the Attribute was created before a driver was loaded)
        /// and the attribute should be re-made (see <see cref="Make(Color, Color)"/>) before it is used.
        /// </summary>
        public int Value { get; }

        /// <summary>
        /// The foreground color.
        /// </summary>
        public Color Foreground { get; }

        /// <summary>
        /// The background color.
        /// </summary>
        public Color Background { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Attribute"/> struct with only the value passed to
        ///   and trying to get the colors if defined.
        /// </summary>
        /// <param name="value">Value.</param>
        public Attribute(int value)
        {
            Color foreground = default;
            Color background = default;

            Initialized = false;
            if (Application.Driver != null)
            {
                Application.Driver.GetColors(value, out foreground, out background);
                Initialized = true;
            }
            Value = value;
            Foreground = foreground;
            Background = background;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Attribute"/> struct.
        /// </summary>
        /// <param name="value">Value.</param>
        /// <param name="foreground">Foreground</param>
        /// <param name="background">Background</param>
        public Attribute(int value, Color foreground, Color background)
        {
            Value = value;
            Foreground = foreground;
            Background = background;
            Initialized = true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Attribute"/> struct.
        /// </summary>
        /// <param name="foreground">Foreground</param>
        /// <param name="background">Background</param>
        public Attribute(Color foreground = new Color(), Color background = new Color())
        {
            var make = Make(foreground, background);
            Initialized = make.Initialized;
            Value = make.Value;
            Foreground = foreground;
            Background = background;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Attribute"/> struct
        ///  with the same colors for the foreground and background.
        /// </summary>
        /// <param name="color">The color.</param>
        public Attribute(Color color) : this(color, color) { }

        /// <summary>
        /// Implicit conversion from an <see cref="Attribute"/> to the underlying, driver-specific, Int32 representation
        /// of the color.
        /// </summary>
        /// <returns>The driver-specific color value stored in the attribute.</returns>
        /// <param name="c">The attribute to convert</param>
        public static implicit operator int(Attribute c)
        {
            if (!c.Initialized) throw new InvalidOperationException("Attribute: Attributes must be initialized by a driver before use.");
            return c.Value;
        }

        /// <summary>
        /// Implicitly convert an driver-specific color value into an <see cref="Attribute"/>
        /// </summary>
        /// <returns>An attribute with the specified driver-specific color value.</returns>
        /// <param name="v">value</param>
        public static implicit operator Attribute(int v) => new Attribute(v);

        /// <summary>
        /// Creates an <see cref="Attribute"/> from the specified foreground and background colors.
        /// </summary>
        /// <remarks>
        /// If a <see cref="ConsoleDriver"/> has not been loaded (<c>Application.Driver == null</c>) this
        /// method will return an attribute with <see cref="Initialized"/> set to  <see langword="false"/>.
        /// </remarks>
        /// <returns>The new attribute.</returns>
        /// <param name="foreground">Foreground color to use.</param>
        /// <param name="background">Background color to use.</param>
        public static Attribute Make(Color foreground, Color background)
        {
            if (Application.Driver == null)
            {
                // Create the attribute, but show it's not been initialized
                return new Attribute(-1, foreground, background)
                {
                    Initialized = false
                };
            }
            return Application.Driver.MakeAttribute(foreground, background);
        }

        /// <summary>
        /// Gets the current <see cref="Attribute"/> from the driver.
        /// </summary>
        /// <returns>The current attribute.</returns>
        public static Attribute Get()
        {
            if (Application.Driver == null)
                throw new InvalidOperationException("The Application has not been initialized");
            return Application.Driver.GetAttribute();
        }

        /// <summary>
        /// If <see langword="true"/> the attribute has been initialized by a <see cref="ConsoleDriver"/> and 
        /// thus has <see cref="Value"/> that is valid for that driver. If <see langword="false"/> the <see cref="Foreground"/>
        /// and <see cref="Background"/> colors may have been set '-1' but
        /// the attribute has not been mapped to a <see cref="ConsoleDriver"/> specific color value.
        /// </summary>
        /// <remarks>
        /// Attributes that have not been initialized must eventually be initialized before being passed to a driver.
        /// </remarks>
        public bool Initialized { get; internal set; }

        /// <summary>
        /// Returns <see langword="true"/> if the Attribute is valid (both foreground and background have valid color values).
        /// </summary>
        /// <returns></returns>
        public bool HasValidColors { get => (int)Foreground > -1 && (int)Background > -1; }
    }

    /// <summary>
    /// Defines the color <see cref="Attribute"/>s for common visible elements in a <see cref="View"/>. 
    /// Containers such as <see cref="Window"/> and <see cref="FrameView"/> use <see cref="ColorScheme"/> to determine
    /// the colors used by sub-views.
    /// </summary>
    /// <remarks>
    /// See also: <see cref="Colors.ColorSchemes"/>.
    /// </remarks>
    public class ColorScheme : IEquatable<ColorScheme>
    {
        Attribute _normal = new Attribute(Color.White, Color.Black);
        Attribute _focus = new Attribute(Color.White, Color.Black);
        Attribute _hotNormal = new Attribute(Color.White, Color.Black);
        Attribute _hotFocus = new Attribute(Color.White, Color.Black);
        Attribute _disabled = new Attribute(Color.White, Color.Black);

        /// <summary>
        /// Used by <see cref="Colors.SetColorScheme(ColorScheme, string)"/> and <see cref="Colors.GetColorScheme(string)"/> to track which ColorScheme 
        /// is being accessed.
        /// </summary>
        internal string schemeBeingSet = "";

        /// <summary>
        /// The foreground and background color for text when the view is not focused, hot, or disabled.
        /// </summary>
        public Attribute Normal
        {
            get { return _normal; }
            set
            {
                if (!value.HasValidColors)
                {
                    return;
                }
                _normal = value;
            }
        }

        /// <summary>
        /// The foreground and background color for text when the view has the focus.
        /// </summary>
        public Attribute Focus
        {
            get { return _focus; }
            set
            {
                if (!value.HasValidColors)
                {
                    return;
                }
                _focus = value;
            }
        }

        /// <summary>
        /// The foreground and background color for text when the view is highlighted (hot).
        /// </summary>
        public Attribute HotNormal
        {
            get { return _hotNormal; }
            set
            {
                if (!value.HasValidColors)
                {
                    return;
                }
                _hotNormal = value;
            }
        }

        /// <summary>
        /// The foreground and background color for text when the view is highlighted (hot) and has focus.
        /// </summary>
        public Attribute HotFocus
        {
            get { return _hotFocus; }
            set
            {
                if (!value.HasValidColors)
                {
                    return;
                }
                _hotFocus = value;
            }
        }

        /// <summary>
        /// The default foreground and background color for text, when the view is disabled.
        /// </summary>
        public Attribute Disabled
        {
            get { return _disabled; }
            set
            {
                if (!value.HasValidColors)
                {
                    return;
                }
                _disabled = value;
            }
        }

        /// <summary>
        /// Compares two <see cref="ColorScheme"/> objects for equality.
        /// </summary>
        /// <param name="obj"></param>
        /// <returns>true if the two objects are equal</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as ColorScheme);
        }

        /// <summary>
        /// Compares two <see cref="ColorScheme"/> objects for equality.
        /// </summary>
        /// <param name="other"></param>
        /// <returns>true if the two objects are equal</returns>
        public bool Equals(ColorScheme other)
        {
            return other != null &&
                   EqualityComparer<Attribute>.Default.Equals(_normal, other._normal) &&
                   EqualityComparer<Attribute>.Default.Equals(_focus, other._focus) &&
                   EqualityComparer<Attribute>.Default.Equals(_hotNormal, other._hotNormal) &&
                   EqualityComparer<Attribute>.Default.Equals(_hotFocus, other._hotFocus) &&
                   EqualityComparer<Attribute>.Default.Equals(_disabled, other._disabled);
        }

        /// <summary>
        /// Returns a hashcode for this instance.
        /// </summary>
        /// <returns>hashcode for this instance</returns>
        public override int GetHashCode()
        {
            int hashCode = -1242460230;
            hashCode = hashCode * -1521134295 + _normal.GetHashCode();
            hashCode = hashCode * -1521134295 + _focus.GetHashCode();
            hashCode = hashCode * -1521134295 + _hotNormal.GetHashCode();
            hashCode = hashCode * -1521134295 + _hotFocus.GetHashCode();
            hashCode = hashCode * -1521134295 + _disabled.GetHashCode();
            return hashCode;
        }

        /// <summary>
        /// Compares two <see cref="ColorScheme"/> objects for equality.
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns><c>true</c> if the two objects are equivalent</returns>
        public static bool operator ==(ColorScheme left, ColorScheme right)
        {
            return EqualityComparer<ColorScheme>.Default.Equals(left, right);
        }

        /// <summary>
        /// Compares two <see cref="ColorScheme"/> objects for inequality.
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns><c>true</c> if the two objects are not equivalent</returns>
        public static bool operator !=(ColorScheme left, ColorScheme right)
        {
            return !(left == right);
        }

        internal void Initialize()
        {
            // If the new scheme was created before a driver was loaded, we need to re-make
            // the attributes
            if (!_normal.Initialized)
            {
                _normal = new Attribute(_normal.Foreground, _normal.Background);
            }
            if (!_focus.Initialized)
            {
                _focus = new Attribute(_focus.Foreground, _focus.Background);
            }
            if (!_hotNormal.Initialized)
            {
                _hotNormal = new Attribute(_hotNormal.Foreground, _hotNormal.Background);
            }
            if (!_hotFocus.Initialized)
            {
                _hotFocus = new Attribute(_hotFocus.Foreground, _hotFocus.Background);
            }
            if (!_disabled.Initialized)
            {
                _disabled = new Attribute(_disabled.Foreground, _disabled.Background);
            }
        }
    }

    /// <summary>
    /// The default <see cref="ColorScheme"/>s for the application.
    /// </summary>
    /// <remarks>
    /// This property can be set in a Theme to change the default <see cref="Colors"/> for the application.
    /// </remarks>
    public static class Colors
    {
        private class SchemeNameComparerIgnoreCase : IEqualityComparer<string>
        {
            public bool Equals(string x, string y)
            {
                if (x != null && y != null)
                {
                    return string.Equals(x, y, StringComparison.InvariantCultureIgnoreCase);
                }
                return false;
            }

            public int GetHashCode(string obj)
            {
                return obj.ToLowerInvariant().GetHashCode();
            }
        }

        static Colors()
        {
            ColorSchemes = Create();
        }

        /// <summary>
        /// Creates a new dictionary of new <see cref="ColorScheme"/> objects.
        /// </summary>
        public static Dictionary<string, ColorScheme> Create()
        {
            // Use reflection to dynamically create the default set of ColorSchemes from the list defined 
            // by the class. 
            return typeof(Colors).GetProperties()
                .Where(p => p.PropertyType == typeof(ColorScheme))
                .Select(p => new KeyValuePair<string, ColorScheme>(p.Name, new ColorScheme()))
                .ToDictionary(t => t.Key, t => t.Value, comparer: new SchemeNameComparerIgnoreCase());
        }

        /// <summary>
        /// The application toplevel color scheme, for the default toplevel views.
        /// </summary>
        /// <remarks>
        /// <para>
        ///	This API will be deprecated in the future. Use <see cref="Colors.ColorSchemes"/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes["TopLevel"];</c>
        /// </para>
        /// </remarks>
        public static ColorScheme TopLevel { get => GetColorScheme(); set => SetColorScheme(value); }

        /// <summary>
        /// The base color scheme, for the default toplevel views.
        /// </summary>
        /// <remarks>
        /// <para>
        ///	This API will be deprecated in the future. Use <see cref="Colors.ColorSchemes"/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes["Base"];</c>
        /// </para>
        /// </remarks>
        public static ColorScheme Base { get => GetColorScheme(); set => SetColorScheme(value); }

        /// <summary>
        /// The dialog color scheme, for standard popup dialog boxes
        /// </summary>
        /// <remarks>
        /// <para>
        ///	This API will be deprecated in the future. Use <see cref="Colors.ColorSchemes"/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes["Dialog"];</c>
        /// </para>
        /// </remarks>
        public static ColorScheme Dialog { get => GetColorScheme(); set => SetColorScheme(value); }

        /// <summary>
        /// The menu bar color
        /// </summary>
        /// <remarks>
        /// <para>
        ///	This API will be deprecated in the future. Use <see cref="Colors.ColorSchemes"/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes["Menu"];</c>
        /// </para>
        /// </remarks>
        public static ColorScheme Menu { get => GetColorScheme(); set => SetColorScheme(value); }

        /// <summary>
        /// The color scheme for showing errors.
        /// </summary>
        /// <remarks>
        /// <para>
        ///	This API will be deprecated in the future. Use <see cref="Colors.ColorSchemes"/> instead (e.g. <c>edit.ColorScheme = Colors.ColorSchemes["Error"];</c>
        /// </para>
        /// </remarks>
        public static ColorScheme Error { get => GetColorScheme(); set => SetColorScheme(value); }

        static ColorScheme GetColorScheme([CallerMemberName] string schemeBeingSet = null)
        {
            return ColorSchemes[schemeBeingSet];
        }

        static void SetColorScheme(ColorScheme colorScheme, [CallerMemberName] string schemeBeingSet = null)
        {
            ColorSchemes[schemeBeingSet] = colorScheme;
            colorScheme.schemeBeingSet = schemeBeingSet;
        }

        /// <summary>
        /// Provides the defined <see cref="ColorScheme"/>s.
        /// </summary>
        public static Dictionary<string, ColorScheme> ColorSchemes { get; private set; }
    }

    /// <summary>
    /// Cursors Visibility that are displayed
    /// </summary>
    // 
    // Hexa value are set as 0xAABBCCDD where :
    //
    //     AA stand for the TERMINFO DECSUSR parameter value to be used under Linux & MacOS
    //     BB stand for the NCurses curs_set parameter value to be used under Linux & MacOS
    //     CC stand for the CONSOLE_CURSOR_INFO.bVisible parameter value to be used under Windows
    //     DD stand for the CONSOLE_CURSOR_INFO.dwSize parameter value to be used under Windows
    //
    public enum CursorVisibility
    {
        /// <summary>
        ///	Cursor caret has default
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Underscore"/>. This default directly depends of the XTerm user configuration settings so it could be Block, I-Beam, Underline with possible blinking.</remarks>
        Default = 0x00010119,

        /// <summary>
        ///	Cursor caret is hidden
        /// </summary>
        Invisible = 0x03000019,

        /// <summary>
        ///	Cursor caret is normally shown as a blinking underline bar _
        /// </summary>
        Underline = 0x03010119,

        /// <summary>
        ///	Cursor caret is normally shown as a underline bar _
        /// </summary>
        /// <remarks>Under Windows, this is equivalent to <see ref="UnderscoreBlinking"/></remarks>
        UnderlineFix = 0x04010119,

        /// <summary>
        ///	Cursor caret is displayed a blinking vertical bar |
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Underscore"/></remarks>
        Vertical = 0x05010119,

        /// <summary>
        ///	Cursor caret is displayed a blinking vertical bar |
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Underscore"/></remarks>
        VerticalFix = 0x06010119,

        /// <summary>
        ///	Cursor caret is displayed as a blinking block ▉
        /// </summary>
        Box = 0x01020164,

        /// <summary>
        ///	Cursor caret is displayed a block ▉
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Block"/></remarks>
        BoxFix = 0x02020164,
    }

    /// <summary>
    /// ConsoleDriver is an abstract class that defines the requirements for a console driver.  
    /// There are currently three implementations: <see cref="CursesDriver"/> (for Unix and Mac), <see cref="WindowsDriver"/>, and <see cref="NetDriver"/> that uses the .NET Console API.
    /// </summary>
    public abstract class ConsoleDriver
    {
        /// <summary>
        /// The handler fired when the terminal is resized.
        /// </summary>
        protected Action TerminalResized;

        /// <summary>
        /// The current number of columns in the terminal.
        /// </summary>
        public abstract int Cols { get; }

        /// <summary>
        /// The current number of rows in the terminal.
        /// </summary>
        public abstract int Rows { get; }

        /// <summary>
        /// The current left in the terminal.
        /// </summary>
        public abstract int Left { get; }

        /// <summary>
        /// The current top in the terminal.
        /// </summary>
        public abstract int Top { get; }

        /// <summary>
        /// Get the operation system clipboard.
        /// </summary>
        public abstract IClipboard Clipboard { get; }

        /// <summary>
        /// <para>
        /// If <see langword="false"/> (the default) the height of the Terminal.Gui application (<see cref="Rows"/>) 
        /// tracks to the height of the visible console view when the console is resized. In this case 
        /// scrolling in the console will be disabled and all <see cref="Rows"/> will remain visible.
        /// </para>
        /// <para>
        /// If <see langword="true"/> then height of the Terminal.Gui application <see cref="Rows"/> only tracks 
        /// the height of the visible console view when the console is made larger (the application will only grow in height, never shrink). 
        /// In this case console scrolling is enabled and the contents (<see cref="Rows"/> high) will scroll
        /// as the console scrolls. 
        /// </para>
        /// </summary>
        /// <remarks>
        /// NOTE: Changes to Windows Terminal prevents this functionality from working. It only really worked on Windows 'conhost' previously.
        /// </remarks>
        [Obsolete("This API is deprecated and has no impact when enabled.", false)]
        public abstract bool EnableConsoleScrolling { get; set; }
        /// <summary>
        /// This API is deprecated and has no impact when enabled.
        /// </summary>
        [Obsolete("This API is deprecated and has no impact when enabled.", false)]
        public abstract bool HeightAsBuffer { get; set; }

        /// <summary>
        /// The format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
        /// </summary>
        public virtual int[,,] Contents { get; }

        /// <summary>
        /// Initializes the driver
        /// </summary>
        /// <param name="terminalResized">Method to invoke when the terminal is resized.</param>
        public abstract void Init(Action terminalResized);
        /// <summary>
        /// Moves the cursor to the specified column and row.
        /// </summary>
        /// <param name="col">Column to move the cursor to.</param>
        /// <param name="row">Row to move the cursor to.</param>
        public abstract void Move(int col, int row);

        /// <summary>
        /// Adds the specified rune to the display at the current cursor position.
        /// </summary>
        /// <param name="rune">Rune to add.</param>
        public abstract void AddRune(Rune rune);

        /// <summary>
        /// Ensures a Rune is not a control character and can be displayed by translating characters below 0x20
        /// to equivalent, printable, Unicode chars.
        /// </summary>
        /// <param name="c">Rune to translate</param>
        /// <returns></returns>
        public static Rune MakePrintable(Rune c)
        {
            if (c <= 0x1F || (c >= 0X7F && c <= 0x9F))
            {
                // ASCII (C0) control characters.
                // C1 control characters (https://www.aivosto.com/articles/control-characters.html#c1)
                return new Rune(c + 0x2400);
            }

            return c;
        }

        /// <summary>
        /// Ensures that the column and line are in a valid range from the size of the driver.
        /// </summary>
        /// <param name="col">The column.</param>
        /// <param name="row">The row.</param>
        /// <param name="clip">The clip.</param>
        /// <returns><c>true</c>if it's a valid range,<c>false</c>otherwise.</returns>
        public bool IsValidContent(int col, int row, Rect clip) =>
            col >= 0 && row >= 0 && col < Cols && row < Rows && clip.Contains(col, row);

        /// <summary>
        /// Adds the <paramref name="str"/> to the display at the cursor position.
        /// </summary>
        /// <param name="str">String.</param>
        public abstract void AddStr(ustring str);

        /// <summary>
        /// Prepare the driver and set the key and mouse events handlers.
        /// </summary>
        /// <param name="mainLoop">The main loop.</param>
        /// <param name="keyHandler">The handler for ProcessKey</param>
        /// <param name="keyDownHandler">The handler for key down events</param>
        /// <param name="keyUpHandler">The handler for key up events</param>
        /// <param name="mouseHandler">The handler for mouse events</param>
        public abstract void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler);

        /// <summary>
        /// Updates the screen to reflect all the changes that have been done to the display buffer
        /// </summary>
        public abstract void Refresh();

        /// <summary>
        /// Updates the location of the cursor position
        /// </summary>
        public abstract void UpdateCursor();

        /// <summary>
        /// Retreive the cursor caret visibility
        /// </summary>
        /// <param name="visibility">The current <see cref="CursorVisibility"/></param>
        /// <returns>true upon success</returns>
        public abstract bool GetCursorVisibility(out CursorVisibility visibility);

        /// <summary>
        /// Change the cursor caret visibility
        /// </summary>
        /// <param name="visibility">The wished <see cref="CursorVisibility"/></param>
        /// <returns>true upon success</returns>
        public abstract bool SetCursorVisibility(CursorVisibility visibility);

        /// <summary>
        /// Ensure the cursor visibility
        /// </summary>
        /// <returns>true upon success</returns>
        public abstract bool EnsureCursorVisibility();

        /// <summary>
        /// Ends the execution of the console driver.
        /// </summary>
        public abstract void End();

        /// <summary>
        /// Resizes the clip area when the screen is resized.
        /// </summary>
        public abstract void ResizeScreen();

        /// <summary>
        /// Reset and recreate the contents and the driver buffer.
        /// </summary>
        public abstract void UpdateOffScreen();

        /// <summary>
        /// Redraws the physical screen with the contents that have been queued up via any of the printing commands.
        /// </summary>
        public abstract void UpdateScreen();

        /// <summary>
        /// The current attribute the driver is using. 
        /// </summary>
        public virtual Attribute CurrentAttribute
        {
            get => currentAttribute;
            set
            {
                if (!value.Initialized && value.HasValidColors && Application.Driver != null)
                {
                    CurrentAttribute = Application.Driver.MakeAttribute(value.Foreground, value.Background);
                    return;
                }
                if (!value.Initialized) Debug.WriteLine("ConsoleDriver.CurrentAttribute: Attributes must be initialized before use.");

                currentAttribute = value;
            }
        }

        /// <summary>
        /// Selects the specified attribute as the attribute to use for future calls to AddRune and AddString.
        /// </summary>
        /// <remarks>
        /// Implementations should call <c>base.SetAttribute(c)</c>.
        /// </remarks>
        /// <param name="c">C.</param>
        public virtual void SetAttribute(Attribute c)
        {
            CurrentAttribute = c;
        }

        /// <summary>
        /// Set Colors from limit sets of colors. Not implemented by any driver: See Issue #2300.
        /// </summary>
        /// <param name="foreground">Foreground.</param>
        /// <param name="background">Background.</param>
        public abstract void SetColors(ConsoleColor foreground, ConsoleColor background);

        // Advanced uses - set colors to any pre-set pairs, you would need to init_color
        // that independently with the R, G, B values.
        /// <summary>
        /// Advanced uses - set colors to any pre-set pairs, you would need to init_color
        /// that independently with the R, G, B values. Not implemented by any driver: See Issue #2300.
        /// </summary>
        /// <param name="foregroundColorId">Foreground color identifier.</param>
        /// <param name="backgroundColorId">Background color identifier.</param>
        public abstract void SetColors(short foregroundColorId, short backgroundColorId);

        /// <summary>
        /// Gets the foreground and background colors based on the value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="foreground">The foreground.</param>
        /// <param name="background">The background.</param>
        /// <returns></returns>
        public abstract bool GetColors(int value, out Color foreground, out Color background);

        /// <summary>
        /// Allows sending keys without typing on a keyboard.
        /// </summary>
        /// <param name="keyChar">The character key.</param>
        /// <param name="key">The key.</param>
        /// <param name="shift">If shift key is sending.</param>
        /// <param name="alt">If alt key is sending.</param>
        /// <param name="control">If control key is sending.</param>
        public abstract void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);

        /// <summary>
        /// Set the handler when the terminal is resized.
        /// </summary>
        /// <param name="terminalResized"></param>
        public void SetTerminalResized(Action terminalResized)
        {
            TerminalResized = terminalResized;
        }

        /// <summary>
        /// Draws the title for a Window-style view incorporating padding. 
        /// </summary>
        /// <param name="region">Screen relative region where the frame will be drawn.</param>
        /// <param name="title">The title for the window. The title will only be drawn if <c>title</c> is not null or empty and paddingTop is greater than 0.</param>
        /// <param name="paddingLeft">Number of columns to pad on the left (if 0 the border will not appear on the left).</param>
        /// <param name="paddingTop">Number of rows to pad on the top (if 0 the border and title will not appear on the top).</param>
        /// <param name="paddingRight">Number of columns to pad on the right (if 0 the border will not appear on the right).</param>
        /// <param name="paddingBottom">Number of rows to pad on the bottom (if 0 the border will not appear on the bottom).</param>
        /// <param name="textAlignment">Not yet implemented.</param>
        /// <remarks></remarks>
        public virtual void DrawWindowTitle(Rect region, ustring title, int paddingLeft, int paddingTop, int paddingRight, int paddingBottom, TextAlignment textAlignment = TextAlignment.Left)
        {
            var width = region.Width - (paddingLeft + 2) * 2;
            if (!ustring.IsNullOrEmpty(title) && width > 4 && region.Y + paddingTop <= region.Y + paddingBottom)
            {
                Move(region.X + 1 + paddingLeft, region.Y + paddingTop);
                AddRune(' ');
                var str = title.Sum(r => Math.Max(Rune.ColumnWidth(r), 1)) >= width
                    ? TextFormatter.Format(title, width - 2, false, false)[0] : title;
                AddStr(str);
                AddRune(' ');
            }
        }

        /// <summary>
        /// Enables diagnostic functions
        /// </summary>
        [Flags]
        public enum DiagnosticFlags : uint
        {
            /// <summary>
            /// All diagnostics off
            /// </summary>
            Off = 0b_0000_0000,
            /// <summary>
            /// When enabled, <see cref="DrawWindowFrame(Rect, int, int, int, int, bool, bool, Border)"/> will draw a 
            /// ruler in the frame for any side with a padding value greater than 0.
            /// </summary>
            FrameRuler = 0b_0000_0001,
            /// <summary>
            /// When Enabled, <see cref="DrawWindowFrame(Rect, int, int, int, int, bool, bool, Border)"/> will use
            /// 'L', 'R', 'T', and 'B' for padding instead of ' '.
            /// </summary>
            FramePadding = 0b_0000_0010,
        }

        /// <summary>
        /// Set flags to enable/disable <see cref="ConsoleDriver"/> diagnostics.
        /// </summary>
        public static DiagnosticFlags Diagnostics { get; set; }

        /// <summary>
        /// Draws a frame for a window with padding and an optional visible border inside the padding. 
        /// </summary>
        /// <param name="region">Screen relative region where the frame will be drawn.</param>
        /// <param name="paddingLeft">Number of columns to pad on the left (if 0 the border will not appear on the left).</param>
        /// <param name="paddingTop">Number of rows to pad on the top (if 0 the border and title will not appear on the top).</param>
        /// <param name="paddingRight">Number of columns to pad on the right (if 0 the border will not appear on the right).</param>
        /// <param name="paddingBottom">Number of rows to pad on the bottom (if 0 the border will not appear on the bottom).</param>
        /// <param name="border">If set to <c>true</c> and any padding dimension is > 0 the border will be drawn.</param>
        /// <param name="fill">If set to <c>true</c> it will clear the content area (the area inside the padding) with the current color, otherwise the content area will be left untouched.</param>
        /// <param name="borderContent">The <see cref="Border"/> to be used if defined.</param>
        public virtual void DrawWindowFrame(Rect region, int paddingLeft = 0, int paddingTop = 0, int paddingRight = 0,
            int paddingBottom = 0, bool border = true, bool fill = false, Border borderContent = null)
        {
            char clearChar = ' ';
            char leftChar = clearChar;
            char rightChar = clearChar;
            char topChar = clearChar;
            char bottomChar = clearChar;

            if ((Diagnostics & DiagnosticFlags.FramePadding) == DiagnosticFlags.FramePadding)
            {
                leftChar = 'L';
                rightChar = 'R';
                topChar = 'T';
                bottomChar = 'B';
                clearChar = 'C';
            }

            void AddRuneAt(int col, int row, Rune ch)
            {
                Move(col, row);
                AddRune(ch);
            }

            // fwidth is count of hLine chars
            int fwidth = (int)(region.Width - (paddingRight + paddingLeft));

            // fheight is count of vLine chars
            int fheight = (int)(region.Height - (paddingBottom + paddingTop));

            // fleft is location of left frame line
            int fleft = region.X + paddingLeft - 1;

            // fright is location of right frame line
            int fright = fleft + fwidth + 1;

            // ftop is location of top frame line
            int ftop = region.Y + paddingTop - 1;

            // fbottom is location of bottom frame line
            int fbottom = ftop + fheight + 1;

            var borderStyle = borderContent == null ? BorderStyle.Single : borderContent.BorderStyle;

            Rune hLine = default, vLine = default,
                uRCorner = default, uLCorner = default, lLCorner = default, lRCorner = default;

            if (border)
            {
                switch (borderStyle)
                {
                    case BorderStyle.None:
                        break;
                    case BorderStyle.Single:
                        hLine = HLine;
                        vLine = VLine;
                        uRCorner = URCorner;
                        uLCorner = ULCorner;
                        lLCorner = LLCorner;
                        lRCorner = LRCorner;
                        break;
                    case BorderStyle.Double:
                        hLine = HDLine;
                        vLine = VDLine;
                        uRCorner = URDCorner;
                        uLCorner = ULDCorner;
                        lLCorner = LLDCorner;
                        lRCorner = LRDCorner;
                        break;
                    case BorderStyle.Rounded:
                        hLine = HRLine;
                        vLine = VRLine;
                        uRCorner = URRCorner;
                        uLCorner = ULRCorner;
                        lLCorner = LLRCorner;
                        lRCorner = LRRCorner;
                        break;
                }
            }
            else
            {
                hLine = vLine = uRCorner = uLCorner = lLCorner = lRCorner = clearChar;
            }

            // Outside top
            if (paddingTop > 1)
            {
                for (int r = region.Y; r < ftop; r++)
                {
                    for (int c = region.X; c < region.X + region.Width; c++)
                    {
                        AddRuneAt(c, r, topChar);
                    }
                }
            }

            // Outside top-left
            for (int c = region.X; c < fleft; c++)
            {
                AddRuneAt(c, ftop, leftChar);
            }

            // Frame top-left corner
            AddRuneAt(fleft, ftop, paddingTop >= 0 ? (paddingLeft >= 0 ? uLCorner : hLine) : leftChar);

            // Frame top
            for (int c = fleft + 1; c < fleft + 1 + fwidth; c++)
            {
                AddRuneAt(c, ftop, paddingTop > 0 ? hLine : topChar);
            }

            // Frame top-right corner
            if (fright > fleft)
            {
                AddRuneAt(fright, ftop, paddingTop >= 0 ? (paddingRight >= 0 ? uRCorner : hLine) : rightChar);
            }

            // Outside top-right corner
            for (int c = fright + 1; c < fright + paddingRight; c++)
            {
                AddRuneAt(c, ftop, rightChar);
            }

            // Left, Fill, Right
            if (fbottom > ftop)
            {
                for (int r = ftop + 1; r < fbottom; r++)
                {
                    // Outside left
                    for (int c = region.X; c < fleft; c++)
                    {
                        AddRuneAt(c, r, leftChar);
                    }

                    // Frame left
                    AddRuneAt(fleft, r, paddingLeft > 0 ? vLine : leftChar);

                    // Fill
                    if (fill)
                    {
                        for (int x = fleft + 1; x < fright; x++)
                        {
                            AddRuneAt(x, r, clearChar);
                        }
                    }

                    // Frame right
                    if (fright > fleft)
                    {
                        var v = vLine;
                        if ((Diagnostics & DiagnosticFlags.FrameRuler) == DiagnosticFlags.FrameRuler)
                        {
                            v = (char)(((int)'0') + ((r - ftop) % 10)); // vLine;
                        }
                        AddRuneAt(fright, r, paddingRight > 0 ? v : rightChar);
                    }

                    // Outside right
                    for (int c = fright + 1; c < fright + paddingRight; c++)
                    {
                        AddRuneAt(c, r, rightChar);
                    }
                }

                // Outside Bottom
                for (int c = region.X; c < region.X + region.Width; c++)
                {
                    AddRuneAt(c, fbottom, leftChar);
                }

                // Frame bottom-left
                AddRuneAt(fleft, fbottom, paddingLeft > 0 ? lLCorner : leftChar);

                if (fright > fleft)
                {
                    // Frame bottom
                    for (int c = fleft + 1; c < fright; c++)
                    {
                        var h = hLine;
                        if ((Diagnostics & DiagnosticFlags.FrameRuler) == DiagnosticFlags.FrameRuler)
                        {
                            h = (char)(((int)'0') + ((c - fleft) % 10)); // hLine;
                        }
                        AddRuneAt(c, fbottom, paddingBottom > 0 ? h : bottomChar);
                    }

                    // Frame bottom-right
                    AddRuneAt(fright, fbottom, paddingRight > 0 ? (paddingBottom > 0 ? lRCorner : hLine) : rightChar);
                }

                // Outside right
                for (int c = fright + 1; c < fright + paddingRight; c++)
                {
                    AddRuneAt(c, fbottom, rightChar);
                }
            }

            // Out bottom - ensure top is always drawn if we overlap
            if (paddingBottom > 0)
            {
                for (int r = fbottom + 1; r < fbottom + paddingBottom; r++)
                {
                    for (int c = region.X; c < region.X + region.Width; c++)
                    {
                        AddRuneAt(c, r, bottomChar);
                    }
                }
            }
        }

        /// <summary>
        /// Draws a frame on the specified region with the specified padding around the frame.
        /// </summary>
        /// <param name="region">Screen relative region where the frame will be drawn.</param>
        /// <param name="padding">Padding to add on the sides.</param>
        /// <param name="fill">If set to <c>true</c> it will clear the contents with the current color, otherwise the contents will be left untouched.</param>
        /// <remarks>This API has been superseded by <see cref="DrawWindowFrame(Rect, int, int, int, int, bool, bool, Border)"/>.</remarks>
        /// <remarks>This API is equivalent to calling <c>DrawWindowFrame(Rect, p - 1, p - 1, p - 1, p - 1)</c>. In other words,
        /// A padding value of 0 means there is actually a one cell border.
        /// </remarks>
        public virtual void DrawFrame(Rect region, int padding, bool fill)
        {
            // DrawFrame assumes the border is always at least one row/col thick
            // DrawWindowFrame assumes a padding of 0 means NO padding and no frame
            DrawWindowFrame(new Rect(region.X, region.Y, region.Width, region.Height),
                padding + 1, padding + 1, padding + 1, padding + 1, border: false, fill: fill);
        }


        /// <summary>
        /// Suspend the application, typically needs to save the state, suspend the app and upon return, reset the console driver.
        /// </summary>
        public abstract void Suspend();

        Rect clip;

        /// <summary>
        /// Controls the current clipping region that AddRune/AddStr is subject to.
        /// </summary>
        /// <value>The clip.</value>
        public Rect Clip
        {
            get => clip;
            set => this.clip = value;
        }

        /// <summary>
        /// Start of mouse moves.
        /// </summary>
        public abstract void StartReportingMouseMoves();

        /// <summary>
        /// Stop reporting mouses moves.
        /// </summary>
        public abstract void StopReportingMouseMoves();

        /// <summary>
        /// Disables the cooked event processing from the mouse driver. 
        /// At startup, it is assumed mouse events are cooked. Not implemented by any driver: See Issue #2300.
        /// </summary>
        public abstract void UncookMouse();

        /// <summary>
        /// Enables the cooked event processing from the mouse driver. Not implemented by any driver: See Issue #2300.
        /// </summary>
        public abstract void CookMouse();

        /// <summary>
        /// Horizontal line character.
        /// </summary>
        public Rune HLine = '\u2500';

        /// <summary>
        /// Vertical line character.
        /// </summary>
        public Rune VLine = '\u2502';

        /// <summary>
        /// Stipple pattern
        /// </summary>
        public Rune Stipple = '\u2591';

        /// <summary>
        /// Diamond character
        /// </summary>
        public Rune Diamond = '\u25ca';

        /// <summary>
        /// Upper left corner
        /// </summary>
        public Rune ULCorner = '\u250C';

        /// <summary>
        /// Lower left corner
        /// </summary>
        public Rune LLCorner = '\u2514';

        /// <summary>
        /// Upper right corner
        /// </summary>
        public Rune URCorner = '\u2510';

        /// <summary>
        /// Lower right corner
        /// </summary>
        public Rune LRCorner = '\u2518';

        /// <summary>
        /// Left tee
        /// </summary>
        public Rune LeftTee = '\u251c';

        /// <summary>
        /// Right tee
        /// </summary>
        public Rune RightTee = '\u2524';

        /// <summary>
        /// Top tee
        /// </summary>
        public Rune TopTee = '\u252c';

        /// <summary>
        /// The bottom tee.
        /// </summary>
        public Rune BottomTee = '\u2534';

        /// <summary>
        /// Checkmark.
        /// </summary>
        public Rune Checked = '\u221a';

        /// <summary>
        /// Un-checked checkmark.
        /// </summary>
        public Rune UnChecked = '\u2574';

        /// <summary>
        /// Selected mark.
        /// </summary>
        public Rune Selected = '\u25cf';

        /// <summary>
        /// Un-selected selected mark.
        /// </summary>
        public Rune UnSelected = '\u25cc';

        /// <summary>
        /// Right Arrow.
        /// </summary>
        public Rune RightArrow = '\u25ba';

        /// <summary>
        /// Left Arrow.
        /// </summary>
        public Rune LeftArrow = '\u25c4';

        /// <summary>
        /// Down Arrow.
        /// </summary>
        public Rune DownArrow = '\u25bc';

        /// <summary>
        /// Up Arrow.
        /// </summary>
        public Rune UpArrow = '\u25b2';

        /// <summary>
        /// Left indicator for default action (e.g. for <see cref="Button"/>).
        /// </summary>
        public Rune LeftDefaultIndicator = '\u25e6';

        /// <summary>
        /// Right indicator for default action (e.g. for <see cref="Button"/>).
        /// </summary>
        public Rune RightDefaultIndicator = '\u25e6';

        /// <summary>
        /// Left frame/bracket (e.g. '[' for <see cref="Button"/>).
        /// </summary>
        public Rune LeftBracket = '[';

        /// <summary>
        /// Right frame/bracket (e.g. ']' for <see cref="Button"/>).
        /// </summary>
        public Rune RightBracket = ']';

        /// <summary>
        /// Blocks Segment indicator for meter views (e.g. <see cref="ProgressBar"/>.
        /// </summary>
        public Rune BlocksMeterSegment = '\u258c';

        /// <summary>
        /// Continuous Segment indicator for meter views (e.g. <see cref="ProgressBar"/>.
        /// </summary>
        public Rune ContinuousMeterSegment = '\u2588';

        /// <summary>
        /// Horizontal double line character.
        /// </summary>
        public Rune HDLine = '\u2550';

        /// <summary>
        /// Vertical double line character.
        /// </summary>
        public Rune VDLine = '\u2551';

        /// <summary>
        /// Upper left double corner
        /// </summary>
        public Rune ULDCorner = '\u2554';

        /// <summary>
        /// Lower left double corner
        /// </summary>
        public Rune LLDCorner = '\u255a';

        /// <summary>
        /// Upper right double corner
        /// </summary>
        public Rune URDCorner = '\u2557';

        /// <summary>
        /// Lower right double corner
        /// </summary>
        public Rune LRDCorner = '\u255d';

        /// <summary>
        /// Horizontal line character for rounded corners.
        /// </summary>
        public Rune HRLine = '\u2500';

        /// <summary>
        /// Vertical line character for rounded corners.
        /// </summary>
        public Rune VRLine = '\u2502';

        /// <summary>
        /// Upper left rounded corner
        /// </summary>
        public Rune ULRCorner = '\u256d';

        /// <summary>
        /// Lower left rounded corner
        /// </summary>
        public Rune LLRCorner = '\u2570';

        /// <summary>
        /// Upper right rounded corner
        /// </summary>
        public Rune URRCorner = '\u256e';

        /// <summary>
        /// Lower right rounded corner
        /// </summary>
        public Rune LRRCorner = '\u256f';
        private Attribute currentAttribute;

        /// <summary>
        /// Make the attribute for the foreground and background colors.
        /// </summary>
        /// <param name="fore">Foreground.</param>
        /// <param name="back">Background.</param>
        /// <returns></returns>
        public abstract Attribute MakeAttribute(Color fore, Color back);

        /// <summary>
        /// Gets the current <see cref="Attribute"/>.
        /// </summary>
        /// <returns>The current attribute.</returns>
        public Attribute GetAttribute() => CurrentAttribute;

        /// <summary>
        /// Make the <see cref="Colors"/> for the <see cref="ColorScheme"/>.
        /// </summary>
        /// <param name="foreground">The foreground color.</param>
        /// <param name="background">The background color.</param>
        /// <returns>The attribute for the foreground and background colors.</returns>
        public abstract Attribute MakeColor(Color foreground, Color background);

        /// <summary>
        /// Ensures all <see cref="Attribute"/>s in <see cref="Colors.ColorSchemes"/> are correctly 
        /// initialized by the driver.
        /// </summary>
        /// <param name="supportsColors">Flag indicating if colors are supported (not used).</param>
        public void InitalizeColorSchemes(bool supportsColors = true)
        {
            // Ensure all Attributes are initialized by the driver
            foreach (var s in Colors.ColorSchemes)
            {
                s.Value.Initialize();
            }

            if (!supportsColors)
            {
                return;
            }


            // Define the default color theme only if the user has not defined one.

            Colors.TopLevel.Normal = MakeColor(Color.BrightGreen, Color.Black);
            Colors.TopLevel.Focus = MakeColor(Color.White, Color.Cyan);
            Colors.TopLevel.HotNormal = MakeColor(Color.Brown, Color.Black);
            Colors.TopLevel.HotFocus = MakeColor(Color.Blue, Color.Cyan);
            Colors.TopLevel.Disabled = MakeColor(Color.DarkGray, Color.Black);

            Colors.Base.Normal = MakeColor(Color.White, Color.Blue);
            Colors.Base.Focus = MakeColor(Color.Black, Color.Gray);
            Colors.Base.HotNormal = MakeColor(Color.BrightCyan, Color.Blue);
            Colors.Base.HotFocus = MakeColor(Color.BrightBlue, Color.Gray);
            Colors.Base.Disabled = MakeColor(Color.DarkGray, Color.Blue);

            Colors.Dialog.Normal = MakeColor(Color.Black, Color.Gray);
            Colors.Dialog.Focus = MakeColor(Color.White, Color.DarkGray);
            Colors.Dialog.HotNormal = MakeColor(Color.Blue, Color.Gray);
            Colors.Dialog.HotFocus = MakeColor(Color.BrightYellow, Color.DarkGray);
            Colors.Dialog.Disabled = MakeColor(Color.Gray, Color.DarkGray);

            Colors.Menu.Normal = MakeColor(Color.White, Color.DarkGray);
            Colors.Menu.Focus = MakeColor(Color.White, Color.Black);
            Colors.Menu.HotNormal = MakeColor(Color.BrightYellow, Color.DarkGray);
            Colors.Menu.HotFocus = MakeColor(Color.BrightYellow, Color.Black);
            Colors.Menu.Disabled = MakeColor(Color.Gray, Color.DarkGray);

            Colors.Error.Normal = MakeColor(Color.Red, Color.White);
            Colors.Error.Focus = MakeColor(Color.Black, Color.BrightRed);
            Colors.Error.HotNormal = MakeColor(Color.Black, Color.White);
            Colors.Error.HotFocus = MakeColor(Color.White, Color.BrightRed);
            Colors.Error.Disabled = MakeColor(Color.DarkGray, Color.White);
        }
    }

    /// <summary>
    /// Helper class for console drivers to invoke shell commands to interact with the clipboard.
    /// Used primarily by CursesDriver, but also used in Unit tests which is why it is in
    /// ConsoleDriver.cs.
    /// </summary>
    internal static class ClipboardProcessRunner
    {
        public static (int exitCode, string result) Bash(string commandLine, string inputText = "", bool waitForOutput = false)
        {
            var arguments = $"-c \"{commandLine}\"";
            var (exitCode, result) = Process("bash", arguments, inputText, waitForOutput);

            return (exitCode, result.TrimEnd());
        }

        public static (int exitCode, string result) Process(string cmd, string arguments, string input = null, bool waitForOutput = true)
        {
            var output = string.Empty;

            using (Process process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = cmd,
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    RedirectStandardInput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                }
            })
            {
                var eventHandled = new TaskCompletionSource<bool>();
                process.Start();
                if (!string.IsNullOrEmpty(input))
                {
                    process.StandardInput.Write(input);
                    process.StandardInput.Close();
                }

                if (!process.WaitForExit(10000))
                {
                    var timeoutError = $@"Process timed out. Command line: {process.StartInfo.FileName} {process.StartInfo.Arguments}.";
                    throw new TimeoutException(timeoutError);
                }

                if (waitForOutput && process.StandardOutput.Peek() != -1)
                {
                    output = process.StandardOutput.ReadToEnd();
                }

                if (process.ExitCode > 0)
                {
                    output = $@"Process failed to run. Command line: {cmd} {arguments}.
										Output: {output}
										Error: {process.StandardError.ReadToEnd()}";
                }

                return (process.ExitCode, output);
            }
        }

        public static bool DoubleWaitForExit(this System.Diagnostics.Process process)
        {
            var result = process.WaitForExit(500);
            if (result)
            {
                process.WaitForExit();
            }
            return result;
        }

        public static bool FileExists(this string value)
        {
            return !string.IsNullOrEmpty(value) && !value.Contains("not found");
        }
    }
    //=======================================================================
    /// <summary>
    /// Helper class to handle the scan code and virtual key from a <see cref="ConsoleKey"/>.
    /// </summary>
    public static class ConsoleKeyMapping
    {
        private class ScanCodeMapping : IEquatable<ScanCodeMapping>
        {
            public uint ScanCode;
            public uint VirtualKey;
            public ConsoleModifiers Modifiers;
            public uint UnicodeChar;

            public ScanCodeMapping(uint scanCode, uint virtualKey, ConsoleModifiers modifiers, uint unicodeChar)
            {
                ScanCode = scanCode;
                VirtualKey = virtualKey;
                Modifiers = modifiers;
                UnicodeChar = unicodeChar;
            }

            public bool Equals(ScanCodeMapping other)
            {
                return (this.ScanCode.Equals(other.ScanCode) &&
                    this.VirtualKey.Equals(other.VirtualKey) &&
                    this.Modifiers.Equals(other.Modifiers) &&
                    this.UnicodeChar.Equals(other.UnicodeChar));
            }
        }

        private static ConsoleModifiers GetModifiers(uint unicodeChar, ConsoleModifiers modifiers, bool isConsoleKey)
        {
            if (modifiers.HasFlag(ConsoleModifiers.Shift) &&
                !modifiers.HasFlag(ConsoleModifiers.Alt) &&
                !modifiers.HasFlag(ConsoleModifiers.Control))
            {

                return ConsoleModifiers.Shift;
            }
            else if (modifiers == (ConsoleModifiers.Alt | ConsoleModifiers.Control))
            {
                return modifiers;
            }
            else if ((!isConsoleKey || (isConsoleKey && (modifiers.HasFlag(ConsoleModifiers.Shift) ||
              modifiers.HasFlag(ConsoleModifiers.Alt) || modifiers.HasFlag(ConsoleModifiers.Control)))) &&
              unicodeChar >= 65 && unicodeChar <= 90)
            {

                return ConsoleModifiers.Shift;
            }
            return 0;
        }

        private static ScanCodeMapping GetScanCode(string propName, uint keyValue, ConsoleModifiers modifiers)
        {
            switch (propName)
            {
                case "UnicodeChar":
                    var sCode = scanCodes.FirstOrDefault((e) => e.UnicodeChar == keyValue && e.Modifiers == modifiers);
                    if (sCode == null && modifiers == (ConsoleModifiers.Alt | ConsoleModifiers.Control))
                    {
                        return scanCodes.FirstOrDefault((e) => e.UnicodeChar == keyValue && e.Modifiers == 0);
                    }
                    return sCode;
                case "VirtualKey":
                    sCode = scanCodes.FirstOrDefault((e) => e.VirtualKey == keyValue && e.Modifiers == modifiers);
                    if (sCode == null && modifiers == (ConsoleModifiers.Alt | ConsoleModifiers.Control))
                    {
                        return scanCodes.FirstOrDefault((e) => e.VirtualKey == keyValue && e.Modifiers == 0);
                    }
                    return sCode;
            }

            return null;
        }

        /// <summary>
        /// Get the <see cref="ConsoleKey"/> from a <see cref="Key"/>.
        /// </summary>
        /// <param name="keyValue">The key value.</param>
        /// <param name="modifiers">The modifiers keys.</param>
        /// <param name="scanCode">The resulting scan code.</param>
        /// <param name="outputChar">The resulting output character.</param>
        /// <returns>The <see cref="ConsoleKey"/> or the <paramref name="outputChar"/>.</returns>
        public static uint GetConsoleKeyFromKey(uint keyValue, ConsoleModifiers modifiers, out uint scanCode, out uint outputChar)
        {
            scanCode = 0;
            outputChar = keyValue;
            if (keyValue == 0)
            {
                return 0;
            }

            uint consoleKey = MapKeyToConsoleKey(keyValue, out bool mappable);
            if (mappable)
            {
                var mod = GetModifiers(keyValue, modifiers, false);
                var scode = GetScanCode("UnicodeChar", keyValue, mod);
                if (scode != null)
                {
                    consoleKey = scode.VirtualKey;
                    scanCode = scode.ScanCode;
                    outputChar = scode.UnicodeChar;
                }
                else
                {
                    consoleKey = consoleKey < 0xff ? (uint)(consoleKey & 0xff | 0xff << 8) : consoleKey;
                }
            }
            else
            {
                var mod = GetModifiers(keyValue, modifiers, false);
                var scode = GetScanCode("VirtualKey", consoleKey, mod);
                if (scode != null)
                {
                    consoleKey = scode.VirtualKey;
                    scanCode = scode.ScanCode;
                    outputChar = scode.UnicodeChar;
                }
            }

            return consoleKey;
        }

        /// <summary>
        /// Get the output character from the <see cref="ConsoleKey"/>.
        /// </summary>
        /// <param name="unicodeChar">The unicode character.</param>
        /// <param name="modifiers">The modifiers keys.</param>
        /// <param name="consoleKey">The resulting console key.</param>
        /// <param name="scanCode">The resulting scan code.</param>
        /// <returns>The output character or the <paramref name="consoleKey"/>.</returns>
        public static uint GetKeyCharFromConsoleKey(uint unicodeChar, ConsoleModifiers modifiers, out uint consoleKey, out uint scanCode)
        {
            uint decodedChar = unicodeChar >> 8 == 0xff ? unicodeChar & 0xff : unicodeChar;
            uint keyChar = decodedChar;
            consoleKey = 0;
            var mod = GetModifiers(decodedChar, modifiers, true);
            scanCode = 0;
            var scode = unicodeChar != 0 && unicodeChar >> 8 != 0xff ? GetScanCode("VirtualKey", decodedChar, mod) : null;
            if (scode != null)
            {
                consoleKey = scode.VirtualKey;
                keyChar = scode.UnicodeChar;
                scanCode = scode.ScanCode;
            }
            if (scode == null)
            {
                scode = unicodeChar != 0 ? GetScanCode("UnicodeChar", decodedChar, mod) : null;
                if (scode != null)
                {
                    consoleKey = scode.VirtualKey;
                    keyChar = scode.UnicodeChar;
                    scanCode = scode.ScanCode;
                }
            }
            if (decodedChar != 0 && scanCode == 0 && char.IsLetter((char)decodedChar))
            {
                string stFormD = ((char)decodedChar).ToString().Normalize(System.Text.NormalizationForm.FormD);
                for (int i = 0; i < stFormD.Length; i++)
                {
                    UnicodeCategory uc = CharUnicodeInfo.GetUnicodeCategory(stFormD[i]);
                    if (uc != UnicodeCategory.NonSpacingMark && uc != UnicodeCategory.OtherLetter)
                    {
                        consoleKey = char.ToUpper(stFormD[i]);
                        scode = GetScanCode("VirtualKey", char.ToUpper(stFormD[i]), 0);
                        if (scode != null)
                        {
                            scanCode = scode.ScanCode;
                        }
                    }
                }
            }

            return keyChar;
        }

        /// <summary>
        /// Maps a <see cref="Key"/> to a <see cref="ConsoleKey"/>.
        /// </summary>
        /// <param name="keyValue">The key value.</param>
        /// <param name="isMappable">If <see langword="true"/> is mapped to a valid character, otherwise <see langword="false"/>.</param>
        /// <returns>The <see cref="ConsoleKey"/> or the <paramref name="keyValue"/>.</returns>
        public static uint MapKeyToConsoleKey(uint keyValue, out bool isMappable)
        {
            isMappable = false;

            switch ((Key)keyValue)
            {
                case Key.Delete:
                    return (uint)ConsoleKey.Delete;
                case Key.CursorUp:
                    return (uint)ConsoleKey.UpArrow;
                case Key.CursorDown:
                    return (uint)ConsoleKey.DownArrow;
                case Key.CursorLeft:
                    return (uint)ConsoleKey.LeftArrow;
                case Key.CursorRight:
                    return (uint)ConsoleKey.RightArrow;
                case Key.PageUp:
                    return (uint)ConsoleKey.PageUp;
                case Key.PageDown:
                    return (uint)ConsoleKey.PageDown;
                case Key.Home:
                    return (uint)ConsoleKey.Home;
                case Key.End:
                    return (uint)ConsoleKey.End;
                case Key.InsertChar:
                    return (uint)ConsoleKey.Insert;
                case Key.DeleteChar:
                    return (uint)ConsoleKey.Delete;
                case Key.F1:
                    return (uint)ConsoleKey.F1;
                case Key.F2:
                    return (uint)ConsoleKey.F2;
                case Key.F3:
                    return (uint)ConsoleKey.F3;
                case Key.F4:
                    return (uint)ConsoleKey.F4;
                case Key.F5:
                    return (uint)ConsoleKey.F5;
                case Key.F6:
                    return (uint)ConsoleKey.F6;
                case Key.F7:
                    return (uint)ConsoleKey.F7;
                case Key.F8:
                    return (uint)ConsoleKey.F8;
                case Key.F9:
                    return (uint)ConsoleKey.F9;
                case Key.F10:
                    return (uint)ConsoleKey.F10;
                case Key.F11:
                    return (uint)ConsoleKey.F11;
                case Key.F12:
                    return (uint)ConsoleKey.F12;
                case Key.F13:
                    return (uint)ConsoleKey.F13;
                case Key.F14:
                    return (uint)ConsoleKey.F14;
                case Key.F15:
                    return (uint)ConsoleKey.F15;
                case Key.F16:
                    return (uint)ConsoleKey.F16;
                case Key.F17:
                    return (uint)ConsoleKey.F17;
                case Key.F18:
                    return (uint)ConsoleKey.F18;
                case Key.F19:
                    return (uint)ConsoleKey.F19;
                case Key.F20:
                    return (uint)ConsoleKey.F20;
                case Key.F21:
                    return (uint)ConsoleKey.F21;
                case Key.F22:
                    return (uint)ConsoleKey.F22;
                case Key.F23:
                    return (uint)ConsoleKey.F23;
                case Key.F24:
                    return (uint)ConsoleKey.F24;
                case Key.BackTab:
                    return (uint)ConsoleKey.Tab;
                case Key.Unknown:
                    isMappable = true;
                    return 0;
            }
            isMappable = true;

            return keyValue;
        }

        /// <summary>
        /// Maps a <see cref="ConsoleKey"/> to a <see cref="Key"/>.
        /// </summary>
        /// <param name="consoleKey">The console key.</param>
        /// <param name="isMappable">If <see langword="true"/> is mapped to a valid character, otherwise <see langword="false"/>.</param>
        /// <returns>The <see cref="Key"/> or the <paramref name="consoleKey"/>.</returns>
        public static Key MapConsoleKeyToKey(ConsoleKey consoleKey, out bool isMappable)
        {
            isMappable = false;

            switch (consoleKey)
            {
                case ConsoleKey.Delete:
                    return Key.Delete;
                case ConsoleKey.UpArrow:
                    return Key.CursorUp;
                case ConsoleKey.DownArrow:
                    return Key.CursorDown;
                case ConsoleKey.LeftArrow:
                    return Key.CursorLeft;
                case ConsoleKey.RightArrow:
                    return Key.CursorRight;
                case ConsoleKey.PageUp:
                    return Key.PageUp;
                case ConsoleKey.PageDown:
                    return Key.PageDown;
                case ConsoleKey.Home:
                    return Key.Home;
                case ConsoleKey.End:
                    return Key.End;
                case ConsoleKey.Insert:
                    return Key.InsertChar;
                case ConsoleKey.F1:
                    return Key.F1;
                case ConsoleKey.F2:
                    return Key.F2;
                case ConsoleKey.F3:
                    return Key.F3;
                case ConsoleKey.F4:
                    return Key.F4;
                case ConsoleKey.F5:
                    return Key.F5;
                case ConsoleKey.F6:
                    return Key.F6;
                case ConsoleKey.F7:
                    return Key.F7;
                case ConsoleKey.F8:
                    return Key.F8;
                case ConsoleKey.F9:
                    return Key.F9;
                case ConsoleKey.F10:
                    return Key.F10;
                case ConsoleKey.F11:
                    return Key.F11;
                case ConsoleKey.F12:
                    return Key.F12;
                case ConsoleKey.F13:
                    return Key.F13;
                case ConsoleKey.F14:
                    return Key.F14;
                case ConsoleKey.F15:
                    return Key.F15;
                case ConsoleKey.F16:
                    return Key.F16;
                case ConsoleKey.F17:
                    return Key.F17;
                case ConsoleKey.F18:
                    return Key.F18;
                case ConsoleKey.F19:
                    return Key.F19;
                case ConsoleKey.F20:
                    return Key.F20;
                case ConsoleKey.F21:
                    return Key.F21;
                case ConsoleKey.F22:
                    return Key.F22;
                case ConsoleKey.F23:
                    return Key.F23;
                case ConsoleKey.F24:
                    return Key.F24;
                case ConsoleKey.Tab:
                    return Key.BackTab;
            }
            isMappable = true;

            return (Key)consoleKey;
        }

        /// <summary>
        /// Maps a <see cref="ConsoleKeyInfo"/> to a <see cref="Key"/>.
        /// </summary>
        /// <param name="keyInfo">The console key info.</param>
        /// <param name="key">The key.</param>
        /// <returns>The <see cref="Key"/> with <see cref="ConsoleModifiers"/> or the <paramref name="key"/></returns>
        public static Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
        {
            Key keyMod = new Key();
            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
                keyMod = Key.ShiftMask;
            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
                keyMod |= Key.CtrlMask;
            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
                keyMod |= Key.AltMask;

            return keyMod != Key.Null ? keyMod | key : key;
        }

        private static HashSet<ScanCodeMapping> scanCodes = new HashSet<ScanCodeMapping> {
            new ScanCodeMapping (1,27,0,27),	// Escape
			new ScanCodeMapping (1,27,ConsoleModifiers.Shift,27),
            new ScanCodeMapping (2,49,0,49),	// D1
			new ScanCodeMapping (2,49,ConsoleModifiers.Shift,33),
            new ScanCodeMapping (3,50,0,50),	// D2
			new ScanCodeMapping (3,50,ConsoleModifiers.Shift,34),
            new ScanCodeMapping (3,50,ConsoleModifiers.Alt | ConsoleModifiers.Control,64),
            new ScanCodeMapping (4,51,0,51),	// D3
			new ScanCodeMapping (4,51,ConsoleModifiers.Shift,35),
            new ScanCodeMapping (4,51,ConsoleModifiers.Alt | ConsoleModifiers.Control,163),
            new ScanCodeMapping (5,52,0,52),	// D4
			new ScanCodeMapping (5,52,ConsoleModifiers.Shift,36),
            new ScanCodeMapping (5,52,ConsoleModifiers.Alt | ConsoleModifiers.Control,167),
            new ScanCodeMapping (6,53,0,53),	// D5
			new ScanCodeMapping (6,53,ConsoleModifiers.Shift,37),
            new ScanCodeMapping (6,53,ConsoleModifiers.Alt | ConsoleModifiers.Control,8364),
            new ScanCodeMapping (7,54,0,54),	// D6
			new ScanCodeMapping (7,54,ConsoleModifiers.Shift,38),
            new ScanCodeMapping (8,55,0,55),	// D7
			new ScanCodeMapping (8,55,ConsoleModifiers.Shift,47),
            new ScanCodeMapping (8,55,ConsoleModifiers.Alt | ConsoleModifiers.Control,123),
            new ScanCodeMapping (9,56,0,56),	// D8
			new ScanCodeMapping (9,56,ConsoleModifiers.Shift,40),
            new ScanCodeMapping (9,56,ConsoleModifiers.Alt | ConsoleModifiers.Control,91),
            new ScanCodeMapping (10,57,0,57),	// D9
			new ScanCodeMapping (10,57,ConsoleModifiers.Shift,41),
            new ScanCodeMapping (10,57,ConsoleModifiers.Alt | ConsoleModifiers.Control,93),
            new ScanCodeMapping (11,48,0,48),	// D0
			new ScanCodeMapping (11,48,ConsoleModifiers.Shift,61),
            new ScanCodeMapping (11,48,ConsoleModifiers.Alt | ConsoleModifiers.Control,125),
            new ScanCodeMapping (12,219,0,39),	// Oem4
			new ScanCodeMapping (12,219,ConsoleModifiers.Shift,63),
            new ScanCodeMapping (13,221,0,171),	// Oem6
			new ScanCodeMapping (13,221,ConsoleModifiers.Shift,187),
            new ScanCodeMapping (14,8,0,8),		// Backspace
			new ScanCodeMapping (14,8,ConsoleModifiers.Shift,8),
            new ScanCodeMapping (15,9,0,9),		// Tab
			new ScanCodeMapping (15,9,ConsoleModifiers.Shift,15),
            new ScanCodeMapping (16,81,0,113),	// Q
			new ScanCodeMapping (16,81,ConsoleModifiers.Shift,81),
            new ScanCodeMapping (17,87,0,119),	// W
			new ScanCodeMapping (17,87,ConsoleModifiers.Shift,87),
            new ScanCodeMapping (18,69,0,101),	// E
			new ScanCodeMapping (18,69,ConsoleModifiers.Shift,69),
            new ScanCodeMapping (19,82,0,114),	// R
			new ScanCodeMapping (19,82,ConsoleModifiers.Shift,82),
            new ScanCodeMapping (20,84,0,116),	// T
			new ScanCodeMapping (20,84,ConsoleModifiers.Shift,84),
            new ScanCodeMapping (21,89,0,121),	// Y
			new ScanCodeMapping (21,89,ConsoleModifiers.Shift,89),
            new ScanCodeMapping (22,85,0,117),	// U
			new ScanCodeMapping (22,85,ConsoleModifiers.Shift,85),
            new ScanCodeMapping (23,73,0,105),	// I
			new ScanCodeMapping (23,73,ConsoleModifiers.Shift,73),
            new ScanCodeMapping (24,79,0,111),	// O
			new ScanCodeMapping (24,79,ConsoleModifiers.Shift,79),
            new ScanCodeMapping (25,80,0,112),	// P
			new ScanCodeMapping (25,80,ConsoleModifiers.Shift,80),
            new ScanCodeMapping (26,187,0,43),	// OemPlus
			new ScanCodeMapping (26,187,ConsoleModifiers.Shift,42),
            new ScanCodeMapping (26,187,ConsoleModifiers.Alt | ConsoleModifiers.Control,168),
            new ScanCodeMapping (27,186,0,180),	// Oem1
			new ScanCodeMapping (27,186,ConsoleModifiers.Shift,96),
            new ScanCodeMapping (28,13,0,13),	// Enter
			new ScanCodeMapping (28,13,ConsoleModifiers.Shift,13),
            new ScanCodeMapping (29,17,0,0),	// Control
			new ScanCodeMapping (29,17,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (30,65,0,97),	// A
			new ScanCodeMapping (30,65,ConsoleModifiers.Shift,65),
            new ScanCodeMapping (31,83,0,115),	// S
			new ScanCodeMapping (31,83,ConsoleModifiers.Shift,83),
            new ScanCodeMapping (32,68,0,100),	// D
			new ScanCodeMapping (32,68,ConsoleModifiers.Shift,68),
            new ScanCodeMapping (33,70,0,102),	// F
			new ScanCodeMapping (33,70,ConsoleModifiers.Shift,70),
            new ScanCodeMapping (34,71,0,103),	// G
			new ScanCodeMapping (34,71,ConsoleModifiers.Shift,71),
            new ScanCodeMapping (35,72,0,104),	// H
			new ScanCodeMapping (35,72,ConsoleModifiers.Shift,72),
            new ScanCodeMapping (36,74,0,106),	// J
			new ScanCodeMapping (36,74,ConsoleModifiers.Shift,74),
            new ScanCodeMapping (37,75,0,107),	// K
			new ScanCodeMapping (37,75,ConsoleModifiers.Shift,75),
            new ScanCodeMapping (38,76,0,108),	// L
			new ScanCodeMapping (38,76,ConsoleModifiers.Shift,76),
            new ScanCodeMapping (39,192,0,231),	// Oem3
			new ScanCodeMapping (39,192,ConsoleModifiers.Shift,199),
            new ScanCodeMapping (40,222,0,186),	// Oem7
			new ScanCodeMapping (40,222,ConsoleModifiers.Shift,170),
            new ScanCodeMapping (41,220,0,92),	// Oem5
			new ScanCodeMapping (41,220,ConsoleModifiers.Shift,124),
            new ScanCodeMapping (42,16,0,0),	// LShift
			new ScanCodeMapping (42,16,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (43,191,0,126),	// Oem2
			new ScanCodeMapping (43,191,ConsoleModifiers.Shift,94),
            new ScanCodeMapping (44,90,0,122),	// Z
			new ScanCodeMapping (44,90,ConsoleModifiers.Shift,90),
            new ScanCodeMapping (45,88,0,120),	// X
			new ScanCodeMapping (45,88,ConsoleModifiers.Shift,88),
            new ScanCodeMapping (46,67,0,99),	// C
			new ScanCodeMapping (46,67,ConsoleModifiers.Shift,67),
            new ScanCodeMapping (47,86,0,118),	// V
			new ScanCodeMapping (47,86,ConsoleModifiers.Shift,86),
            new ScanCodeMapping (48,66,0,98),	// B
			new ScanCodeMapping (48,66,ConsoleModifiers.Shift,66),
            new ScanCodeMapping (49,78,0,110),	// N
			new ScanCodeMapping (49,78,ConsoleModifiers.Shift,78),
            new ScanCodeMapping (50,77,0,109),	// M
			new ScanCodeMapping (50,77,ConsoleModifiers.Shift,77),
            new ScanCodeMapping (51,188,0,44),	// OemComma
			new ScanCodeMapping (51,188,ConsoleModifiers.Shift,59),
            new ScanCodeMapping (52,190,0,46),	// OemPeriod
			new ScanCodeMapping (52,190,ConsoleModifiers.Shift,58),
            new ScanCodeMapping (53,189,0,45),	// OemMinus
			new ScanCodeMapping (53,189,ConsoleModifiers.Shift,95),
            new ScanCodeMapping (54,16,0,0),	// RShift
			new ScanCodeMapping (54,16,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (55,44,0,0),	// PrintScreen
			new ScanCodeMapping (55,44,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (56,18,0,0),	// Alt
			new ScanCodeMapping (56,18,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (57,32,0,32),	// Spacebar
			new ScanCodeMapping (57,32,ConsoleModifiers.Shift,32),
            new ScanCodeMapping (58,20,0,0),	// Caps
			new ScanCodeMapping (58,20,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (59,112,0,0),	// F1
			new ScanCodeMapping (59,112,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (60,113,0,0),	// F2
			new ScanCodeMapping (60,113,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (61,114,0,0),	// F3
			new ScanCodeMapping (61,114,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (62,115,0,0),	// F4
			new ScanCodeMapping (62,115,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (63,116,0,0),	// F5
			new ScanCodeMapping (63,116,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (64,117,0,0),	// F6
			new ScanCodeMapping (64,117,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (65,118,0,0),	// F7
			new ScanCodeMapping (65,118,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (66,119,0,0),	// F8
			new ScanCodeMapping (66,119,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (67,120,0,0),	// F9
			new ScanCodeMapping (67,120,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (68,121,0,0),	// F10
			new ScanCodeMapping (68,121,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (69,144,0,0),	// Num
			new ScanCodeMapping (69,144,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (70,145,0,0),	// Scroll
			new ScanCodeMapping (70,145,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (71,36,0,0),	// Home
			new ScanCodeMapping (71,36,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (72,38,0,0),	// UpArrow
			new ScanCodeMapping (72,38,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (73,33,0,0),	// PageUp
			new ScanCodeMapping (73,33,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (74,109,0,45),	// Subtract
			new ScanCodeMapping (74,109,ConsoleModifiers.Shift,45),
            new ScanCodeMapping (75,37,0,0),	// LeftArrow
			new ScanCodeMapping (75,37,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (76,12,0,0),	// Center
			new ScanCodeMapping (76,12,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (77,39,0,0),	// RightArrow
			new ScanCodeMapping (77,39,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (78,107,0,43),	// Add
			new ScanCodeMapping (78,107,ConsoleModifiers.Shift,43),
            new ScanCodeMapping (79,35,0,0),	// End
			new ScanCodeMapping (79,35,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (80,40,0,0),	// DownArrow
			new ScanCodeMapping (80,40,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (81,34,0,0),	// PageDown
			new ScanCodeMapping (81,34,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (82,45,0,0),	// Insert
			new ScanCodeMapping (82,45,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (83,46,0,0),	// Delete
			new ScanCodeMapping (83,46,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (86,226,0,60),	// OEM 102
			new ScanCodeMapping (86,226,ConsoleModifiers.Shift,62),
            new ScanCodeMapping (87,122,0,0),	// F11
			new ScanCodeMapping (87,122,ConsoleModifiers.Shift,0),
            new ScanCodeMapping (88,123,0,0),	// F12
			new ScanCodeMapping (88,123,ConsoleModifiers.Shift,0)
        };
    }
    //=======================================================================
    /// <summary>
    /// ContextMenu provides a pop-up menu that can be positioned anywhere within a <see cref="View"/>. 
    /// ContextMenu is analogous to <see cref="MenuBar"/> and, once activated, works like a sub-menu 
    /// of a <see cref="MenuBarItem"/> (but can be positioned anywhere).
    /// <para>
    /// By default, a ContextMenu with sub-menus is displayed in a cascading manner, where each sub-menu pops out of the ContextMenu frame
    /// (either to the right or left, depending on where the ContextMenu is relative to the edge of the screen). By setting
    /// <see cref="UseSubMenusSingleFrame"/> to <see langword="true"/>, this behavior can be changed such that all sub-menus are
    /// drawn within the ContextMenu frame.
    /// </para>
    /// <para>
    /// ContextMenus can be activated using the Shift-F10 key (by default; use the <see cref="Key"/> to change to another key).
    /// </para>
    /// <para>
    /// Callers can cause the ContextMenu to be activated on a right-mouse click (or other interaction) by calling <see cref="Show()"/>.
    /// </para>
    /// <para>
    /// ContextMenus are located using screen using screen coordinates and appear above all other Views.
    /// </para>
    /// </summary>
    public sealed class ContextMenu : IDisposable
    {
        private static MenuBar menuBar;
        private Key key = Key.F10 | Key.ShiftMask;
        private MouseFlags mouseFlags = MouseFlags.Button3Clicked;
        private Toplevel container;

        /// <summary>
        /// Initializes a context menu with no menu items.
        /// </summary>
        public ContextMenu() : this(0, 0, new MenuBarItem()) { }

        /// <summary>
        /// Initializes a context menu, with a <see cref="View"/> specifiying the parent/hose of the menu.
        /// </summary>
        /// <param name="host">The host view.</param>
        /// <param name="menuItems">The menu items for the context menu.</param>
        public ContextMenu(View host, MenuBarItem menuItems) :
            this(host.Frame.X, host.Frame.Y, menuItems)
        {
            Host = host;
        }

        /// <summary>
        /// Initializes a context menu with menu items at a specific screen location.
        /// </summary>
        /// <param name="x">The left position (screen relative).</param>
        /// <param name="y">The top position (screen relative).</param>
        /// <param name="menuItems">The menu items.</param>
        public ContextMenu(int x, int y, MenuBarItem menuItems)
        {
            if (IsShow)
            {
                if (menuBar.SuperView != null)
                {
                    Hide();
                }
                IsShow = false;
            }
            MenuItems = menuItems;
            Position = new Point(x, y);
        }

        private void MenuBar_MenuAllClosed()
        {
            Dispose();
        }

        /// <summary>
        /// Disposes the context menu object.
        /// </summary>
        public void Dispose()
        {
            if (IsShow)
            {
                menuBar.MenuAllClosed -= MenuBar_MenuAllClosed;
                menuBar.Dispose();
                menuBar = null;
                IsShow = false;
            }
            if (container != null)
            {
                container.Closing -= Container_Closing;
            }
        }

        /// <summary>
        /// Shows (opens) the ContextMenu, displaying the <see cref="MenuItem"/>s it contains.
        /// </summary>
        public void Show()
        {
            if (menuBar != null)
            {
                Hide();
            }
            container = Application.Current;
            container.Closing += Container_Closing;
            var frame = container.Frame;
            var position = Position;
            if (Host != null)
            {
                Host.ViewToScreen(container.Frame.X, container.Frame.Y, out int x, out int y);
                var pos = new Point(x, y);
                pos.Y += Host.Frame.Height - 1;
                if (position != pos)
                {
                    Position = position = pos;
                }
            }
            var rect = Menu.MakeFrame(position.X, position.Y, MenuItems.Children);
            if (rect.Right >= frame.Right)
            {
                if (frame.Right - rect.Width >= 0 || !ForceMinimumPosToZero)
                {
                    position.X = frame.Right - rect.Width;
                }
                else if (ForceMinimumPosToZero)
                {
                    position.X = 0;
                }
            }
            else if (ForceMinimumPosToZero && position.X < 0)
            {
                position.X = 0;
            }
            if (rect.Bottom >= frame.Bottom)
            {
                if (frame.Bottom - rect.Height - 1 >= 0 || !ForceMinimumPosToZero)
                {
                    if (Host == null)
                    {
                        position.Y = frame.Bottom - rect.Height - 1;
                    }
                    else
                    {
                        Host.ViewToScreen(container.Frame.X, container.Frame.Y, out int x, out int y);
                        var pos = new Point(x, y);
                        position.Y = pos.Y - rect.Height - 1;
                    }
                }
                else if (ForceMinimumPosToZero)
                {
                    position.Y = 0;
                }
            }
            else if (ForceMinimumPosToZero && position.Y < 0)
            {
                position.Y = 0;
            }

            menuBar = new MenuBar(new[] { MenuItems })
            {
                X = position.X,
                Y = position.Y,
                Width = 0,
                Height = 0,
                UseSubMenusSingleFrame = UseSubMenusSingleFrame,
                Key = Key
            };

            menuBar.isContextMenuLoading = true;
            menuBar.MenuAllClosed += MenuBar_MenuAllClosed;
            IsShow = true;
            menuBar.OpenMenu();
        }

        private void Container_Closing(ToplevelClosingEventArgs obj)
        {
            Hide();
        }

        /// <summary>
        /// Hides (closes) the ContextMenu.
        /// </summary>
        public void Hide()
        {
            menuBar?.CleanUp();
            Dispose();
        }

        /// <summary>
        /// Event invoked when the <see cref="ContextMenu.Key"/> is changed.
        /// </summary>
        public event Action<Key> KeyChanged;

        /// <summary>
        /// Event invoked when the <see cref="ContextMenu.MouseFlags"/> is changed.
        /// </summary>
        public event Action<MouseFlags> MouseFlagsChanged;

        /// <summary>
        /// Gets or sets the menu position.
        /// </summary>
        public Point Position { get; set; }

        /// <summary>
        /// Gets or sets the menu items for this context menu.
        /// </summary>
        public MenuBarItem MenuItems { get; set; }

        /// <summary>
        /// <see cref="Gui.Key"/> specifies they keyboard key that will activate the context menu with the keyboard.
        /// </summary>
        public Key Key
        {
            get => key;
            set
            {
                var oldKey = key;
                key = value;
                KeyChanged?.Invoke(oldKey);
            }
        }

        /// <summary>
        /// <see cref="Gui.MouseFlags"/> specifies the mouse action used to activate the context menu by mouse.
        /// </summary>
        public MouseFlags MouseFlags
        {
            get => mouseFlags;
            set
            {
                var oldFlags = mouseFlags;
                mouseFlags = value;
                MouseFlagsChanged?.Invoke(oldFlags);
            }
        }

        /// <summary>
        /// Gets whether the ContextMenu is showing or not.
        /// </summary>
        public static bool IsShow { get; private set; }

        /// <summary>
        /// The host <see cref="View "/> which position will be used,
        /// otherwise if it's null the container will be used.
        /// </summary>
        public View Host { get; set; }

        /// <summary>
        /// Sets or gets whether the context menu be forced to the right, ensuring it is not clipped, if the x position 
        /// is less than zero. The default is <see langword="true"/> which means the context menu will be forced to the right.
        /// If set to <see langword="false"/>, the context menu will be clipped on the left if x is less than zero.
        /// </summary>
        public bool ForceMinimumPosToZero { get; set; } = true;

        /// <summary>
        /// Gets the <see cref="Gui.MenuBar"/> that is hosting this context menu.
        /// </summary>
        public MenuBar MenuBar { get => menuBar; }

        /// <summary>
        /// Gets or sets if sub-menus will be displayed using a "single frame" menu style. If <see langword="true"/>, the ContextMenu
        /// and any sub-menus that would normally cascade will be displayed within a single frame. If <see langword="false"/> (the default),
        /// sub-menus will cascade using separate frames for each level of the menu hierarchy.
        /// </summary>
        public bool UseSubMenusSingleFrame { get; set; }
    }
    //=======================================================================
    //
    // Driver.cs: Curses-based Driver
    //

    /// <summary>
    /// This is the Curses driver for the gui.cs/Terminal framework.
    /// </summary>
    internal class CursesDriver : ConsoleDriver
    {
        public override int Cols => Curses.Cols;
        public override int Rows => Curses.Lines;
        public override int Left => 0;
        public override int Top => 0;
        [Obsolete("This API is deprecated", false)]
        public override bool EnableConsoleScrolling { get; set; }
        [Obsolete("This API is deprecated", false)]
        public override bool HeightAsBuffer { get; set; }
        public override IClipboard Clipboard { get => clipboard; }

        CursorVisibility? initialCursorVisibility = null;
        CursorVisibility? currentCursorVisibility = null;
        IClipboard clipboard;
        int[,,] contents;

        public override int[,,] Contents => contents;

        // Current row, and current col, tracked by Move/AddRune only
        int ccol, crow;
        bool needMove;
        public override void Move(int col, int row)
        {
            ccol = col;
            crow = row;

            if (Clip.Contains(col, row))
            {
                Curses.move(row, col);
                needMove = false;
            }
            else
            {
                Curses.move(Clip.Y, Clip.X);
                needMove = true;
            }
        }

        static bool sync = false;
        public override void AddRune(Rune rune)
        {
            rune = MakePrintable(rune);
            var runeWidth = Rune.ColumnWidth(rune);
            var validClip = IsValidContent(ccol, crow, Clip);

            if (validClip)
            {
                if (needMove)
                {
                    Curses.move(crow, ccol);
                    needMove = false;
                }
                if (runeWidth == 0 && ccol > 0)
                {
                    var r = contents[crow, ccol - 1, 0];
                    var s = new string(new char[] { (char)r, (char)rune });
                    string sn;
                    if (!s.IsNormalized())
                    {
                        sn = s.Normalize();
                    }
                    else
                    {
                        sn = s;
                    }
                    var c = sn[0];
                    Curses.mvaddch(crow, ccol - 1, (int)(uint)c);
                    contents[crow, ccol - 1, 0] = c;
                    contents[crow, ccol - 1, 1] = CurrentAttribute;
                    contents[crow, ccol - 1, 2] = 1;

                }
                else
                {
                    if (runeWidth < 2 && ccol > 0
                        && Rune.ColumnWidth((char)contents[crow, ccol - 1, 0]) > 1)
                    {

                        var curAtttib = CurrentAttribute;
                        Curses.attrset(contents[crow, ccol - 1, 1]);
                        Curses.mvaddch(crow, ccol - 1, (int)(uint)' ');
                        contents[crow, ccol - 1, 0] = (int)(uint)' ';
                        Curses.move(crow, ccol);
                        Curses.attrset(curAtttib);

                    }
                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
                      && Rune.ColumnWidth((char)contents[crow, ccol, 0]) > 1)
                    {

                        var curAtttib = CurrentAttribute;
                        Curses.attrset(contents[crow, ccol + 1, 1]);
                        Curses.mvaddch(crow, ccol + 1, (int)(uint)' ');
                        contents[crow, ccol + 1, 0] = (int)(uint)' ';
                        Curses.move(crow, ccol);
                        Curses.attrset(curAtttib);

                    }
                    if (runeWidth > 1 && ccol == Clip.Right - 1)
                    {
                        Curses.addch((int)(uint)' ');
                        contents[crow, ccol, 0] = (int)(uint)' ';
                    }
                    else
                    {
                        Curses.addch((int)(uint)rune);
                        contents[crow, ccol, 0] = (int)(uint)rune;
                    }
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 1;
                }
            }
            else
            {
                needMove = true;
            }

            if (runeWidth < 0 || runeWidth > 0)
            {
                ccol++;
            }

            if (runeWidth > 1)
            {
                if (validClip && ccol < Clip.Right)
                {
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 0;
                }
                ccol++;
            }

            if (sync)
            {
                UpdateScreen();
            }
        }

        public override void AddStr(ustring str)
        {
            // TODO; optimize this to determine if the str fits in the clip region, and if so, use Curses.addstr directly
            foreach (var rune in str)
                AddRune(rune);
        }

        public override void Refresh()
        {
            Curses.raw();
            Curses.noecho();
            Curses.refresh();
            ProcessWinChange();
        }

        private void ProcessWinChange()
        {
            if (Curses.CheckWinChange())
            {
                ResizeScreen();
                UpdateOffScreen();
                TerminalResized?.Invoke();
            }
        }

        public override void UpdateCursor() => Refresh();

        public override void End()
        {
            StopReportingMouseMoves();
            SetCursorVisibility(CursorVisibility.Default);

            // throws away any typeahead that has been typed by
            // the user and has not yet been read by the program.
            Curses.flushinp();

            Curses.endwin();
        }

        public override void UpdateScreen() => window.redrawwin();

        public override void SetAttribute(Attribute c)
        {
            base.SetAttribute(c);
            Curses.attrset(CurrentAttribute);
        }

        public Curses.Window window;

        //static short last_color_pair = 16;

        /// <summary>
        /// Creates a curses color from the provided foreground and background colors
        /// </summary>
        /// <param name="foreground">Contains the curses attributes for the foreground (color, plus any attributes)</param>
        /// <param name="background">Contains the curses attributes for the background (color, plus any attributes)</param>
        /// <returns></returns>
        public static Attribute MakeColor(short foreground, short background)
        {
            var v = (short)((int)foreground | background << 4);
            //Curses.InitColorPair (++last_color_pair, foreground, background);
            Curses.InitColorPair(v, foreground, background);
            return new Attribute(
                //value: Curses.ColorPair (last_color_pair),
                value: Curses.ColorPair(v),
                //foreground: (Color)foreground,
                foreground: MapCursesColor(foreground),
                //background: (Color)background);
                background: MapCursesColor(background));
        }

        public override Attribute MakeColor(Color fore, Color back)
        {
            return MakeColor((short)MapColor(fore), (short)MapColor(back));
        }

        int[,] colorPairs = new int[16, 16];

        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
        {
            // BUGBUG: This code is never called ?? See Issue #2300
            int f = (short)foreground;
            int b = (short)background;
            var v = colorPairs[f, b];
            if ((v & 0x10000) == 0)
            {
                b &= 0x7;
                bool bold = (f & 0x8) != 0;
                f &= 0x7;

                v = MakeColor((short)f, (short)b) | (bold ? Curses.A_BOLD : 0);
                colorPairs[(int)foreground, (int)background] = v | 0x1000;
            }
            SetAttribute(v & 0xffff);
        }

        Dictionary<int, int> rawPairs = new Dictionary<int, int>();
        public override void SetColors(short foreColorId, short backgroundColorId)
        {
            // BUGBUG: This code is never called ?? See Issue #2300
            int key = ((ushort)foreColorId << 16) | (ushort)backgroundColorId;
            if (!rawPairs.TryGetValue(key, out var v))
            {
                v = MakeColor(foreColorId, backgroundColorId);
                rawPairs[key] = v;
            }
            SetAttribute(v);
        }

        static Key MapCursesKey(int cursesKey)
        {
            switch (cursesKey)
            {
                case Curses.KeyF1: return Key.F1;
                case Curses.KeyF2: return Key.F2;
                case Curses.KeyF3: return Key.F3;
                case Curses.KeyF4: return Key.F4;
                case Curses.KeyF5: return Key.F5;
                case Curses.KeyF6: return Key.F6;
                case Curses.KeyF7: return Key.F7;
                case Curses.KeyF8: return Key.F8;
                case Curses.KeyF9: return Key.F9;
                case Curses.KeyF10: return Key.F10;
                case Curses.KeyF11: return Key.F11;
                case Curses.KeyF12: return Key.F12;
                case Curses.KeyUp: return Key.CursorUp;
                case Curses.KeyDown: return Key.CursorDown;
                case Curses.KeyLeft: return Key.CursorLeft;
                case Curses.KeyRight: return Key.CursorRight;
                case Curses.KeyHome: return Key.Home;
                case Curses.KeyEnd: return Key.End;
                case Curses.KeyNPage: return Key.PageDown;
                case Curses.KeyPPage: return Key.PageUp;
                case Curses.KeyDeleteChar: return Key.DeleteChar;
                case Curses.KeyInsertChar: return Key.InsertChar;
                case Curses.KeyTab: return Key.Tab;
                case Curses.KeyBackTab: return Key.BackTab;
                case Curses.KeyBackspace: return Key.Backspace;
                case Curses.ShiftKeyUp: return Key.CursorUp | Key.ShiftMask;
                case Curses.ShiftKeyDown: return Key.CursorDown | Key.ShiftMask;
                case Curses.ShiftKeyLeft: return Key.CursorLeft | Key.ShiftMask;
                case Curses.ShiftKeyRight: return Key.CursorRight | Key.ShiftMask;
                case Curses.ShiftKeyHome: return Key.Home | Key.ShiftMask;
                case Curses.ShiftKeyEnd: return Key.End | Key.ShiftMask;
                case Curses.ShiftKeyNPage: return Key.PageDown | Key.ShiftMask;
                case Curses.ShiftKeyPPage: return Key.PageUp | Key.ShiftMask;
                case Curses.AltKeyUp: return Key.CursorUp | Key.AltMask;
                case Curses.AltKeyDown: return Key.CursorDown | Key.AltMask;
                case Curses.AltKeyLeft: return Key.CursorLeft | Key.AltMask;
                case Curses.AltKeyRight: return Key.CursorRight | Key.AltMask;
                case Curses.AltKeyHome: return Key.Home | Key.AltMask;
                case Curses.AltKeyEnd: return Key.End | Key.AltMask;
                case Curses.AltKeyNPage: return Key.PageDown | Key.AltMask;
                case Curses.AltKeyPPage: return Key.PageUp | Key.AltMask;
                case Curses.CtrlKeyUp: return Key.CursorUp | Key.CtrlMask;
                case Curses.CtrlKeyDown: return Key.CursorDown | Key.CtrlMask;
                case Curses.CtrlKeyLeft: return Key.CursorLeft | Key.CtrlMask;
                case Curses.CtrlKeyRight: return Key.CursorRight | Key.CtrlMask;
                case Curses.CtrlKeyHome: return Key.Home | Key.CtrlMask;
                case Curses.CtrlKeyEnd: return Key.End | Key.CtrlMask;
                case Curses.CtrlKeyNPage: return Key.PageDown | Key.CtrlMask;
                case Curses.CtrlKeyPPage: return Key.PageUp | Key.CtrlMask;
                case Curses.ShiftCtrlKeyUp: return Key.CursorUp | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftCtrlKeyDown: return Key.CursorDown | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftCtrlKeyLeft: return Key.CursorLeft | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftCtrlKeyRight: return Key.CursorRight | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftCtrlKeyHome: return Key.Home | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftCtrlKeyEnd: return Key.End | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftCtrlKeyNPage: return Key.PageDown | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftCtrlKeyPPage: return Key.PageUp | Key.ShiftMask | Key.CtrlMask;
                case Curses.ShiftAltKeyUp: return Key.CursorUp | Key.ShiftMask | Key.AltMask;
                case Curses.ShiftAltKeyDown: return Key.CursorDown | Key.ShiftMask | Key.AltMask;
                case Curses.ShiftAltKeyLeft: return Key.CursorLeft | Key.ShiftMask | Key.AltMask;
                case Curses.ShiftAltKeyRight: return Key.CursorRight | Key.ShiftMask | Key.AltMask;
                case Curses.ShiftAltKeyNPage: return Key.PageDown | Key.ShiftMask | Key.AltMask;
                case Curses.ShiftAltKeyPPage: return Key.PageUp | Key.ShiftMask | Key.AltMask;
                case Curses.ShiftAltKeyHome: return Key.Home | Key.ShiftMask | Key.AltMask;
                case Curses.ShiftAltKeyEnd: return Key.End | Key.ShiftMask | Key.AltMask;
                case Curses.AltCtrlKeyNPage: return Key.PageDown | Key.AltMask | Key.CtrlMask;
                case Curses.AltCtrlKeyPPage: return Key.PageUp | Key.AltMask | Key.CtrlMask;
                case Curses.AltCtrlKeyHome: return Key.Home | Key.AltMask | Key.CtrlMask;
                case Curses.AltCtrlKeyEnd: return Key.End | Key.AltMask | Key.CtrlMask;
                default: return Key.Unknown;
            }
        }

        KeyModifiers keyModifiers;

        KeyModifiers MapKeyModifiers(Key key)
        {
            if (keyModifiers == null)
                keyModifiers = new KeyModifiers();

            if (!keyModifiers.Shift && (key & Key.ShiftMask) != 0)
                keyModifiers.Shift = true;
            if (!keyModifiers.Alt && (key & Key.AltMask) != 0)
                keyModifiers.Alt = true;
            if (!keyModifiers.Ctrl && (key & Key.CtrlMask) != 0)
                keyModifiers.Ctrl = true;

            return keyModifiers;
        }

        void ProcessInput()
        {
            int wch;
            var code = Curses.get_wch(out wch);
            //System.Diagnostics.Debug.WriteLine ($"code: {code}; wch: {wch}");
            if (code == Curses.ERR)
                return;

            keyModifiers = new KeyModifiers();
            Key k = Key.Null;

            if (code == Curses.KEY_CODE_YES)
            {
                var lastWch = wch;
                while (code == Curses.KEY_CODE_YES && wch == Curses.KeyResize)
                {
                    ProcessWinChange();
                    code = Curses.get_wch(out wch);
                }
                if (wch == 0)
                {
                    return;
                }
                if (wch == Curses.KeyMouse)
                {
                    int wch2 = wch;

                    while (wch2 == Curses.KeyMouse)
                    {
                        KeyEvent key = null;
                        ConsoleKeyInfo[] cki = new ConsoleKeyInfo[] {
                            new ConsoleKeyInfo ((char)Key.Esc, 0, false, false, false),
                            new ConsoleKeyInfo ('[', 0, false, false, false),
                            new ConsoleKeyInfo ('<', 0, false, false, false)
                        };
                        code = 0;
                        GetEscSeq(ref code, ref k, ref wch2, ref key, ref cki);
                    }
                    return;
                }
                k = MapCursesKey(wch);
                if (wch >= 277 && wch <= 288)
                { // Shift+(F1 - F12)
                    wch -= 12;
                    k = Key.ShiftMask | MapCursesKey(wch);
                }
                else if (wch >= 289 && wch <= 300)
                { // Ctrl+(F1 - F12)
                    wch -= 24;
                    k = Key.CtrlMask | MapCursesKey(wch);
                }
                else if (wch >= 301 && wch <= 312)
                { // Ctrl+Shift+(F1 - F12)
                    wch -= 36;
                    k = Key.CtrlMask | Key.ShiftMask | MapCursesKey(wch);
                }
                else if (wch >= 313 && wch <= 324)
                { // Alt+(F1 - F12)
                    wch -= 48;
                    k = Key.AltMask | MapCursesKey(wch);
                }
                else if (wch >= 325 && wch <= 327)
                { // Shift+Alt+(F1 - F3)
                    wch -= 60;
                    k = Key.ShiftMask | Key.AltMask | MapCursesKey(wch);
                }
                else
                {
                    code = Curses.get_wch(out wch);
                    if (code == 0)
                    {
                        switch (wch)
                        {
                            // Shift code.
                            case 16:
                                keyModifiers.Shift = true;
                                break;
                            default:
                                if (lastWch == Curses.KeyResize && wch == 91)
                                {
                                    // Returns this keys to the std input which is a CSI (\x1b[).
                                    Curses.ungetch(91); // [
                                    Curses.ungetch(27); // Esc
                                    return;
                                }
                                else
                                {
                                    throw new Exception();
                                }
                        }
                    }
                }
                keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
                keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
                keyUpHandler(new KeyEvent(k, MapKeyModifiers(k)));
                return;
            }

            // Special handling for ESC, we want to try to catch ESC+letter to simulate alt-letter as well as Alt-Fkey
            if (wch == 27)
            {
                code = Curses.get_wch(out int wch2);

                if (code == Curses.KEY_CODE_YES)
                {
                    k = Key.AltMask | MapCursesKey(wch);
                }
                if (code == 0)
                {
                    KeyEvent key = null;

                    // The ESC-number handling, debatable.
                    // Simulates the AltMask itself by pressing Alt + Space.
                    if (wch2 == (int)Key.Space)
                    {
                        k = Key.AltMask;
                    }
                    else if (wch2 - (int)Key.Space >= (uint)Key.A && wch2 - (int)Key.Space <= (uint)Key.Z)
                    {
                        k = (Key)((uint)Key.AltMask + (wch2 - (int)Key.Space));
                    }
                    else if (wch2 >= (uint)Key.A - 64 && wch2 <= (uint)Key.Z - 64)
                    {
                        k = (Key)((uint)(Key.AltMask | Key.CtrlMask) + (wch2 + 64));
                    }
                    else if (wch2 >= (uint)Key.D0 && wch2 <= (uint)Key.D9)
                    {
                        k = (Key)((uint)Key.AltMask + (uint)Key.D0 + (wch2 - (uint)Key.D0));
                    }
                    else if (wch2 == Curses.KeyCSI)
                    {
                        ConsoleKeyInfo[] cki = new ConsoleKeyInfo[] {
                            new ConsoleKeyInfo ((char)Key.Esc, 0, false, false, false),
                            new ConsoleKeyInfo ('[', 0, false, false, false)
                        };
                        GetEscSeq(ref code, ref k, ref wch2, ref key, ref cki);
                        return;
                    }
                    else
                    {
                        // Unfortunately there are no way to differentiate Ctrl+Alt+alfa and Ctrl+Shift+Alt+alfa.
                        if (((Key)wch2 & Key.CtrlMask) != 0)
                        {
                            keyModifiers.Ctrl = true;
                        }
                        if (wch2 == 0)
                        {
                            k = Key.CtrlMask | Key.AltMask | Key.Space;
                        }
                        else if (wch >= (uint)Key.A && wch <= (uint)Key.Z)
                        {
                            keyModifiers.Shift = true;
                            keyModifiers.Alt = true;
                        }
                        else if (wch2 == Curses.KeySS3)
                        {
                            while (code > -1)
                            {
                                code = Curses.get_wch(out wch2);
                                if (code == 0)
                                {
                                    switch (wch2)
                                    {
                                        case 16:
                                            keyModifiers.Shift = true;
                                            break;
                                        case 108:
                                            k = (Key)'+';
                                            break;
                                        case 109:
                                            k = (Key)'-';
                                            break;
                                        case 112:
                                            k = Key.InsertChar;
                                            break;
                                        case 113:
                                            k = Key.End;
                                            break;
                                        case 114:
                                            k = Key.CursorDown;
                                            break;
                                        case 115:
                                            k = Key.PageDown;
                                            break;
                                        case 116:
                                            k = Key.CursorLeft;
                                            break;
                                        case 117:
                                            k = Key.Clear;
                                            break;
                                        case 118:
                                            k = Key.CursorRight;
                                            break;
                                        case 119:
                                            k = Key.Home;
                                            break;
                                        case 120:
                                            k = Key.CursorUp;
                                            break;
                                        case 121:
                                            k = Key.PageUp;
                                            break;
                                        default:
                                            k = (Key)wch2;
                                            break;
                                    }
                                }
                            }
                        }
                        else if (wch2 < 256)
                        {
                            k = (Key)wch2;
                            keyModifiers.Alt = true;
                        }
                        else
                        {
                            k = (Key)((uint)(Key.AltMask | Key.CtrlMask) + wch2);
                        }
                    }
                    key = new KeyEvent(k, MapKeyModifiers(k));
                    keyDownHandler(key);
                    keyHandler(key);
                }
                else
                {
                    k = Key.Esc;
                    keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
                    keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
                }
            }
            else if (wch == Curses.KeyTab)
            {
                k = MapCursesKey(wch);
                keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
                keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
            }
            else
            {
                // Unfortunately there are no way to differentiate Ctrl+alfa and Ctrl+Shift+alfa.
                k = (Key)wch;
                if (wch == 0)
                {
                    k = Key.CtrlMask | Key.Space;
                }
                else if (wch >= (uint)Key.A - 64 && wch <= (uint)Key.Z - 64)
                {
                    if ((Key)(wch + 64) != Key.J)
                    {
                        k = Key.CtrlMask | (Key)(wch + 64);
                    }
                }
                else if (wch >= (uint)Key.A && wch <= (uint)Key.Z)
                {
                    keyModifiers.Shift = true;
                }
                keyDownHandler(new KeyEvent(k, MapKeyModifiers(k)));
                keyHandler(new KeyEvent(k, MapKeyModifiers(k)));
                keyUpHandler(new KeyEvent(k, MapKeyModifiers(k)));
            }
            // Cause OnKeyUp and OnKeyPressed. Note that the special handling for ESC above 
            // will not impact KeyUp.
            // This is causing ESC firing even if another keystroke was handled.
            //if (wch == Curses.KeyTab) {
            //	keyUpHandler (new KeyEvent (MapCursesKey (wch), keyModifiers));
            //} else {
            //	keyUpHandler (new KeyEvent ((Key)wch, keyModifiers));
            //}
        }

        void GetEscSeq(ref int code, ref Key k, ref int wch2, ref KeyEvent key, ref ConsoleKeyInfo[] cki)
        {
            ConsoleKey ck = 0;
            ConsoleModifiers mod = 0;
            while (code == 0)
            {
                code = Curses.get_wch(out wch2);
                var consoleKeyInfo = new ConsoleKeyInfo((char)wch2, 0, false, false, false);
                if (wch2 == 0 || wch2 == 27 || wch2 == Curses.KeyMouse)
                {
                    EscSeqUtils.DecodeEscSeq(null, ref consoleKeyInfo, ref ck, cki, ref mod, out _, out _, out _, out _, out bool isKeyMouse, out List<MouseFlags> mouseFlags, out Point pos, out _, ProcessContinuousButtonPressed);
                    if (isKeyMouse)
                    {
                        foreach (var mf in mouseFlags)
                        {
                            ProcessMouseEvent(mf, pos);
                        }
                        cki = null;
                        if (wch2 == 27)
                        {
                            cki = EscSeqUtils.ResizeArray(new ConsoleKeyInfo((char)Key.Esc, 0,
                                false, false, false), cki);
                        }
                    }
                    else
                    {
                        k = ConsoleKeyMapping.MapConsoleKeyToKey(consoleKeyInfo.Key, out _);
                        k = ConsoleKeyMapping.MapKeyModifiers(consoleKeyInfo, k);
                        key = new KeyEvent(k, MapKeyModifiers(k));
                        keyDownHandler(key);
                        keyHandler(key);
                    }
                }
                else
                {
                    cki = EscSeqUtils.ResizeArray(consoleKeyInfo, cki);
                }
            }
        }

        MouseFlags lastMouseFlags;

        void ProcessMouseEvent(MouseFlags mouseFlag, Point pos)
        {
            bool WasButtonReleased(MouseFlags flag)
            {
                return flag.HasFlag(MouseFlags.Button1Released) ||
                    flag.HasFlag(MouseFlags.Button2Released) ||
                    flag.HasFlag(MouseFlags.Button3Released) ||
                    flag.HasFlag(MouseFlags.Button4Released);
            }

            bool IsButtonNotPressed(MouseFlags flag)
            {
                return !flag.HasFlag(MouseFlags.Button1Pressed) &&
                    !flag.HasFlag(MouseFlags.Button2Pressed) &&
                    !flag.HasFlag(MouseFlags.Button3Pressed) &&
                    !flag.HasFlag(MouseFlags.Button4Pressed);
            }

            bool IsButtonClickedOrDoubleClicked(MouseFlags flag)
            {
                return flag.HasFlag(MouseFlags.Button1Clicked) ||
                    flag.HasFlag(MouseFlags.Button2Clicked) ||
                    flag.HasFlag(MouseFlags.Button3Clicked) ||
                    flag.HasFlag(MouseFlags.Button4Clicked) ||
                    flag.HasFlag(MouseFlags.Button1DoubleClicked) ||
                    flag.HasFlag(MouseFlags.Button2DoubleClicked) ||
                    flag.HasFlag(MouseFlags.Button3DoubleClicked) ||
                    flag.HasFlag(MouseFlags.Button4DoubleClicked);
            }

            if ((WasButtonReleased(mouseFlag) && IsButtonNotPressed(lastMouseFlags)) ||
                (IsButtonClickedOrDoubleClicked(mouseFlag) && lastMouseFlags == 0))
            {
                return;
            }

            lastMouseFlags = mouseFlag;
            var me = new MouseEvent()
            {
                Flags = mouseFlag,
                X = pos.X,
                Y = pos.Y
            };
            mouseHandler(me);
        }

        void ProcessContinuousButtonPressed(MouseFlags mouseFlag, Point pos)
        {
            ProcessMouseEvent(mouseFlag, pos);
        }

        Action<KeyEvent> keyHandler;
        Action<KeyEvent> keyDownHandler;
        Action<KeyEvent> keyUpHandler;
        Action<MouseEvent> mouseHandler;

        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
        {
            // Note: Curses doesn't support keydown/up events and thus any passed keyDown/UpHandlers will never be called
            this.keyHandler = keyHandler;
            this.keyDownHandler = keyDownHandler;
            this.keyUpHandler = keyUpHandler;
            this.mouseHandler = mouseHandler;

            var mLoop = mainLoop.Driver as UnixMainLoop;

            mLoop.AddWatch(0, UnixMainLoop.Condition.PollIn, x =>
            {
                ProcessInput();
                return true;
            });

            mLoop.WinChanged += () => ProcessWinChange();
        }

        public override void Init(Action terminalResized)
        {
            if (window != null)
                return;

            try
            {
                window = Curses.initscr();
                Curses.set_escdelay(10);
                Curses.nodelay(window.Handle, true);
            }
            catch (Exception e)
            {
                throw new Exception($"Curses failed to initialize, the exception is: {e.Message}");
            }

            // Ensures that all procedures are performed at some previous closing.
            Curses.doupdate();

            // 
            // We are setting Invisible as default so we could ignore XTerm DECSUSR setting
            //
            switch (Curses.curs_set(0))
            {
                case 0:
                    currentCursorVisibility = initialCursorVisibility = CursorVisibility.Invisible;
                    break;

                case 1:
                    currentCursorVisibility = initialCursorVisibility = CursorVisibility.Underline;
                    Curses.curs_set(1);
                    break;

                case 2:
                    currentCursorVisibility = initialCursorVisibility = CursorVisibility.Box;
                    Curses.curs_set(2);
                    break;

                default:
                    currentCursorVisibility = initialCursorVisibility = null;
                    break;
            }

            if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                clipboard = new MacOSXClipboard();
            }
            else
            {
                if (Is_WSL_Platform())
                {
                    clipboard = new WSLClipboard();
                }
                else
                {
                    clipboard = new CursesClipboard();
                }
            }

            Curses.raw();
            Curses.noecho();

            Curses.Window.Standard.keypad(true);
            TerminalResized = terminalResized;
            StartReportingMouseMoves();

            CurrentAttribute = MakeColor(Color.White, Color.Black);

            if (Curses.HasColors)
            {
                Curses.StartColor();
                Curses.UseDefaultColors();

                InitalizeColorSchemes();
            }
            else
            {
                InitalizeColorSchemes(false);

                // BUGBUG: This is a hack to make the colors work on the Mac?
                // The new Theme support overwrites these colors, so this is not needed?
                Colors.TopLevel.Normal = Curses.COLOR_GREEN;
                Colors.TopLevel.Focus = Curses.COLOR_WHITE;
                Colors.TopLevel.HotNormal = Curses.COLOR_YELLOW;
                Colors.TopLevel.HotFocus = Curses.COLOR_YELLOW;
                Colors.TopLevel.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
                Colors.Base.Normal = Curses.A_NORMAL;
                Colors.Base.Focus = Curses.A_REVERSE;
                Colors.Base.HotNormal = Curses.A_BOLD;
                Colors.Base.HotFocus = Curses.A_BOLD | Curses.A_REVERSE;
                Colors.Base.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
                Colors.Menu.Normal = Curses.A_REVERSE;
                Colors.Menu.Focus = Curses.A_NORMAL;
                Colors.Menu.HotNormal = Curses.A_BOLD;
                Colors.Menu.HotFocus = Curses.A_NORMAL;
                Colors.Menu.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
                Colors.Dialog.Normal = Curses.A_REVERSE;
                Colors.Dialog.Focus = Curses.A_NORMAL;
                Colors.Dialog.HotNormal = Curses.A_BOLD;
                Colors.Dialog.HotFocus = Curses.A_NORMAL;
                Colors.Dialog.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
                Colors.Error.Normal = Curses.A_BOLD;
                Colors.Error.Focus = Curses.A_BOLD | Curses.A_REVERSE;
                Colors.Error.HotNormal = Curses.A_BOLD | Curses.A_REVERSE;
                Colors.Error.HotFocus = Curses.A_REVERSE;
                Colors.Error.Disabled = Curses.A_BOLD | Curses.COLOR_GRAY;
            }

            ResizeScreen();
            UpdateOffScreen();
        }

        public override void ResizeScreen()
        {
            Clip = new Rect(0, 0, Cols, Rows);
        }

        public override void UpdateOffScreen()
        {
            contents = new int[Rows, Cols, 3];
            for (int row = 0; row < Rows; row++)
            {
                for (int col = 0; col < Cols; col++)
                {
                    Curses.move(row, col);
                    Curses.attrset(Colors.TopLevel.Normal);
                    Curses.addch((int)(uint)' ');
                    contents[row, col, 0] = ' ';
                    contents[row, col, 1] = Colors.TopLevel.Normal;
                    contents[row, col, 2] = 0;
                }
            }
        }

        public static bool Is_WSL_Platform()
        {
            // xclip does not work on WSL, so we need to use the Windows clipboard vis Powershell
            //if (new CursesClipboard ().IsSupported) {
            //	// If xclip is installed on Linux under WSL, this will return true.
            //	return false;
            //}
            var (exitCode, result) = ClipboardProcessRunner.Bash("uname -a", waitForOutput: true);
            if (exitCode == 0 && result.Contains("microsoft") && result.Contains("WSL"))
            {
                return true;
            }
            return false;
        }

        static int MapColor(Color color)
        {
            switch (color)
            {
                case Color.Black:
                    return Curses.COLOR_BLACK;
                case Color.Blue:
                    return Curses.COLOR_BLUE;
                case Color.Green:
                    return Curses.COLOR_GREEN;
                case Color.Cyan:
                    return Curses.COLOR_CYAN;
                case Color.Red:
                    return Curses.COLOR_RED;
                case Color.Magenta:
                    return Curses.COLOR_MAGENTA;
                case Color.Brown:
                    return Curses.COLOR_YELLOW;
                case Color.Gray:
                    return Curses.COLOR_WHITE;
                case Color.DarkGray:
                    //return Curses.COLOR_BLACK | Curses.A_BOLD;
                    return Curses.COLOR_GRAY;
                case Color.BrightBlue:
                    return Curses.COLOR_BLUE | Curses.A_BOLD | Curses.COLOR_GRAY;
                case Color.BrightGreen:
                    return Curses.COLOR_GREEN | Curses.A_BOLD | Curses.COLOR_GRAY;
                case Color.BrightCyan:
                    return Curses.COLOR_CYAN | Curses.A_BOLD | Curses.COLOR_GRAY;
                case Color.BrightRed:
                    return Curses.COLOR_RED | Curses.A_BOLD | Curses.COLOR_GRAY;
                case Color.BrightMagenta:
                    return Curses.COLOR_MAGENTA | Curses.A_BOLD | Curses.COLOR_GRAY;
                case Color.BrightYellow:
                    return Curses.COLOR_YELLOW | Curses.A_BOLD | Curses.COLOR_GRAY;
                case Color.White:
                    return Curses.COLOR_WHITE | Curses.A_BOLD | Curses.COLOR_GRAY;
            }
            throw new ArgumentException("Invalid color code");
        }

        static Color MapCursesColor(int color)
        {
            switch (color)
            {
                case Curses.COLOR_BLACK:
                    return Color.Black;
                case Curses.COLOR_BLUE:
                    return Color.Blue;
                case Curses.COLOR_GREEN:
                    return Color.Green;
                case Curses.COLOR_CYAN:
                    return Color.Cyan;
                case Curses.COLOR_RED:
                    return Color.Red;
                case Curses.COLOR_MAGENTA:
                    return Color.Magenta;
                case Curses.COLOR_YELLOW:
                    return Color.Brown;
                case Curses.COLOR_WHITE:
                    return Color.Gray;
                case Curses.COLOR_GRAY:
                    return Color.DarkGray;
                case Curses.COLOR_BLUE | Curses.COLOR_GRAY:
                    return Color.BrightBlue;
                case Curses.COLOR_GREEN | Curses.COLOR_GRAY:
                    return Color.BrightGreen;
                case Curses.COLOR_CYAN | Curses.COLOR_GRAY:
                    return Color.BrightCyan;
                case Curses.COLOR_RED | Curses.COLOR_GRAY:
                    return Color.BrightRed;
                case Curses.COLOR_MAGENTA | Curses.COLOR_GRAY:
                    return Color.BrightMagenta;
                case Curses.COLOR_YELLOW | Curses.COLOR_GRAY:
                    return Color.BrightYellow;
                case Curses.COLOR_WHITE | Curses.COLOR_GRAY:
                    return Color.White;
            }
            throw new ArgumentException("Invalid curses color code");
        }

        public override Attribute MakeAttribute(Color fore, Color back)
        {
            var f = MapColor(fore);
            //return MakeColor ((short)(f & 0xffff), (short)MapColor (back)) | ((f & Curses.A_BOLD) != 0 ? Curses.A_BOLD : 0);
            return MakeColor((short)(f & 0xffff), (short)MapColor(back));
        }

        public override void Suspend()
        {
            StopReportingMouseMoves();
            Platform.Suspend();
            Curses.Window.Standard.redrawwin();
            Curses.refresh();
            StartReportingMouseMoves();
        }

        public override void StartReportingMouseMoves()
        {
            Console.Out.Write(EscSeqUtils.EnableMouseEvents);
        }

        public override void StopReportingMouseMoves()
        {
            Console.Out.Write(EscSeqUtils.DisableMouseEvents);
        }

        //int lastMouseInterval;
        //bool mouseGrabbed;

        public override void UncookMouse()
        {
            //if (mouseGrabbed)
            //	return;
            //lastMouseInterval = Curses.mouseinterval (0);
            //mouseGrabbed = true;
        }

        public override void CookMouse()
        {
            //mouseGrabbed = false;
            //Curses.mouseinterval (lastMouseInterval);
        }

        /// <inheritdoc/>
        public override bool GetCursorVisibility(out CursorVisibility visibility)
        {
            visibility = CursorVisibility.Invisible;

            if (!currentCursorVisibility.HasValue)
                return false;

            visibility = currentCursorVisibility.Value;

            return true;
        }

        /// <inheritdoc/>
        public override bool SetCursorVisibility(CursorVisibility visibility)
        {
            if (initialCursorVisibility.HasValue == false)
                return false;

            Curses.curs_set(((int)visibility >> 16) & 0x000000FF);

            if (visibility != CursorVisibility.Invisible)
            {
                Console.Out.Write("\x1b[{0} q", ((int)visibility >> 24) & 0xFF);
            }

            currentCursorVisibility = visibility;

            return true;
        }

        /// <inheritdoc/>
        public override bool EnsureCursorVisibility()
        {
            return false;
        }

        public override void SendKeys(char keyChar, ConsoleKey consoleKey, bool shift, bool alt, bool control)
        {
            Key key;

            if (consoleKey == ConsoleKey.Packet)
            {
                ConsoleModifiers mod = new ConsoleModifiers();
                if (shift)
                {
                    mod |= ConsoleModifiers.Shift;
                }
                if (alt)
                {
                    mod |= ConsoleModifiers.Alt;
                }
                if (control)
                {
                    mod |= ConsoleModifiers.Control;
                }
                var kchar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(keyChar, mod, out uint ckey, out _);
                key = ConsoleKeyMapping.MapConsoleKeyToKey((ConsoleKey)ckey, out bool mappable);
                if (mappable)
                {
                    key = (Key)kchar;
                }
            }
            else
            {
                key = (Key)keyChar;
            }

            KeyModifiers km = new KeyModifiers();
            if (shift)
            {
                if (keyChar == 0)
                {
                    key |= Key.ShiftMask;
                }
                km.Shift = shift;
            }
            if (alt)
            {
                key |= Key.AltMask;
                km.Alt = alt;
            }
            if (control)
            {
                key |= Key.CtrlMask;
                km.Ctrl = control;
            }
            keyDownHandler(new KeyEvent(key, km));
            keyHandler(new KeyEvent(key, km));
            keyUpHandler(new KeyEvent(key, km));
        }

        public override bool GetColors(int value, out Color foreground, out Color background)
        {
            bool hasColor = false;
            foreground = default;
            background = default;
            int back = -1;
            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
                .OfType<ConsoleColor>()
                .Select(s => (int)s);
            if (values.Contains((value >> 12) & 0xffff))
            {
                hasColor = true;
                back = (value >> 12) & 0xffff;
                background = MapCursesColor(back);
            }
            if (values.Contains((value - (back << 12)) >> 8))
            {
                hasColor = true;
                foreground = MapCursesColor((value - (back << 12)) >> 8);
            }
            return hasColor;
        }
    }

    internal static class Platform
    {
        [DllImport("libc")]
        static extern int uname(IntPtr buf);

        [DllImport("libc")]
        static extern int killpg(int pgrp, int pid);

        static int suspendSignal;

        static int GetSuspendSignal()
        {
            if (suspendSignal != 0)
                return suspendSignal;

            IntPtr buf = Marshal.AllocHGlobal(8192);
            if (uname(buf) != 0)
            {
                Marshal.FreeHGlobal(buf);
                suspendSignal = -1;
                return suspendSignal;
            }
            try
            {
                switch (Marshal.PtrToStringAnsi(buf))
                {
                    case "Darwin":
                    case "DragonFly":
                    case "FreeBSD":
                    case "NetBSD":
                    case "OpenBSD":
                        suspendSignal = 18;
                        break;
                    case "Linux":
                        // TODO: should fetch the machine name and
                        // if it is MIPS return 24
                        suspendSignal = 20;
                        break;
                    case "Solaris":
                        suspendSignal = 24;
                        break;
                    default:
                        suspendSignal = -1;
                        break;
                }
                return suspendSignal;
            }
            finally
            {
                Marshal.FreeHGlobal(buf);
            }
        }

        /// <summary>
        /// Suspends the process by sending SIGTSTP to itself
        /// </summary>
        /// <returns>The suspend.</returns>
        static public bool Suspend()
        {
            int signal = GetSuspendSignal();
            if (signal == -1)
                return false;
            killpg(0, signal);
            return true;
        }
    }

    /// <summary>
    ///  A clipboard implementation for Linux.
    ///  This implementation uses the xclip command to access the clipboard.
    /// </summary>	
    /// <remarks>
    /// If xclip is not installed, this implementation will not work.
    /// </remarks>
    class CursesClipboard : ClipboardBase
    {
        public CursesClipboard()
        {
            IsSupported = CheckSupport();
        }

        string xclipPath = string.Empty;
        public override bool IsSupported { get; }

        bool CheckSupport()
        {
#pragma warning disable RCS1075 // Avoid empty catch clause that catches System.Exception.
            try
            {
                var (exitCode, result) = ClipboardProcessRunner.Bash("which xclip", waitForOutput: true);
                if (exitCode == 0 && result.FileExists())
                {
                    xclipPath = result;
                    return true;
                }
            }
            catch (Exception)
            {
                // Permissions issue.
            }
#pragma warning restore RCS1075 // Avoid empty catch clause that catches System.Exception.
            return false;
        }

        protected override string GetClipboardDataImpl()
        {
            var tempFileName = System.IO.Path.GetTempFileName();
            var xclipargs = "-selection clipboard -o";

            try
            {
                var (exitCode, result) = ClipboardProcessRunner.Bash($"{xclipPath} {xclipargs} > {tempFileName}", waitForOutput: false);
                if (exitCode == 0)
                {
                    if (Application.Driver is CursesDriver)
                    {
                        Curses.raw();
                        Curses.noecho();
                    }
                    return System.IO.File.ReadAllText(tempFileName);
                }
            }
            catch (Exception e)
            {
                throw new NotSupportedException($"\"{xclipPath} {xclipargs}\" failed.", e);
            }
            finally
            {
                System.IO.File.Delete(tempFileName);
            }
            return string.Empty;
        }

        protected override void SetClipboardDataImpl(string text)
        {
            var xclipargs = "-selection clipboard -i";
            try
            {
                var (exitCode, _) = ClipboardProcessRunner.Bash($"{xclipPath} {xclipargs}", text, waitForOutput: false);
                if (exitCode == 0 && Application.Driver is CursesDriver)
                {
                    Curses.raw();
                    Curses.noecho();
                }
            }
            catch (Exception e)
            {
                throw new NotSupportedException($"\"{xclipPath} {xclipargs} < {text}\" failed", e);
            }
        }
    }

    /// <summary>
    ///  A clipboard implementation for MacOSX. 
    ///  This implementation uses the Mac clipboard API (via P/Invoke) to copy/paste.
    ///  The existance of the Mac pbcopy and pbpaste commands 
    ///  is used to determine if copy/paste is supported.
    /// </summary>	
    class MacOSXClipboard : ClipboardBase
    {
        IntPtr nsString = objc_getClass("NSString");
        IntPtr nsPasteboard = objc_getClass("NSPasteboard");
        IntPtr utfTextType;
        IntPtr generalPasteboard;
        IntPtr initWithUtf8Register = sel_registerName("initWithUTF8String:");
        IntPtr allocRegister = sel_registerName("alloc");
        IntPtr setStringRegister = sel_registerName("setString:forType:");
        IntPtr stringForTypeRegister = sel_registerName("stringForType:");
        IntPtr utf8Register = sel_registerName("UTF8String");
        IntPtr nsStringPboardType;
        IntPtr generalPasteboardRegister = sel_registerName("generalPasteboard");
        IntPtr clearContentsRegister = sel_registerName("clearContents");

        public MacOSXClipboard()
        {
            utfTextType = objc_msgSend(objc_msgSend(nsString, allocRegister), initWithUtf8Register, "public.utf8-plain-text");
            nsStringPboardType = objc_msgSend(objc_msgSend(nsString, allocRegister), initWithUtf8Register, "NSStringPboardType");
            generalPasteboard = objc_msgSend(nsPasteboard, generalPasteboardRegister);
            IsSupported = CheckSupport();
        }

        public override bool IsSupported { get; }

        bool CheckSupport()
        {
            var (exitCode, result) = ClipboardProcessRunner.Bash("which pbcopy", waitForOutput: true);
            if (exitCode != 0 || !result.FileExists())
            {
                return false;
            }
            (exitCode, result) = ClipboardProcessRunner.Bash("which pbpaste", waitForOutput: true);
            return exitCode == 0 && result.FileExists();
        }

        protected override string GetClipboardDataImpl()
        {
            var ptr = objc_msgSend(generalPasteboard, stringForTypeRegister, nsStringPboardType);
            var charArray = objc_msgSend(ptr, utf8Register);
            return Marshal.PtrToStringAnsi(charArray);
        }

        protected override void SetClipboardDataImpl(string text)
        {
            IntPtr str = default;
            try
            {
                str = objc_msgSend(objc_msgSend(nsString, allocRegister), initWithUtf8Register, text);
                objc_msgSend(generalPasteboard, clearContentsRegister);
                objc_msgSend(generalPasteboard, setStringRegister, str, utfTextType);
            }
            finally
            {
                if (str != default)
                {
                    objc_msgSend(str, sel_registerName("release"));
                }
            }
        }

        [DllImport("/System/Library/Frameworks/AppKit.framework/AppKit")]
        static extern IntPtr objc_getClass(string className);

        [DllImport("/System/Library/Frameworks/AppKit.framework/AppKit")]
        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector);

        [DllImport("/System/Library/Frameworks/AppKit.framework/AppKit")]
        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector, string arg1);

        [DllImport("/System/Library/Frameworks/AppKit.framework/AppKit")]
        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector, IntPtr arg1);

        [DllImport("/System/Library/Frameworks/AppKit.framework/AppKit")]
        static extern IntPtr objc_msgSend(IntPtr receiver, IntPtr selector, IntPtr arg1, IntPtr arg2);

        [DllImport("/System/Library/Frameworks/AppKit.framework/AppKit")]
        static extern IntPtr sel_registerName(string selectorName);
    }

    /// <summary>
    ///  A clipboard implementation for Linux, when running under WSL. 
    ///  This implementation uses the Windows clipboard to store the data, and uses Windows'
    ///  powershell.exe (launched via WSL interop services) to set/get the Windows
    ///  clipboard. 
    /// </summary>
    class WSLClipboard : ClipboardBase
    {
        bool isSupported = false;
        public WSLClipboard()
        {
            isSupported = CheckSupport();
        }

        public override bool IsSupported
        {
            get
            {
                return isSupported = CheckSupport();
            }
        }

        private static string powershellPath = string.Empty;

        bool CheckSupport()
        {
            if (string.IsNullOrEmpty(powershellPath))
            {
                // Specify pwsh.exe (not pwsh) to ensure we get the Windows version (invoked via WSL)
                var (exitCode, result) = ClipboardProcessRunner.Bash("which pwsh.exe", waitForOutput: true);
                if (exitCode > 0)
                {
                    (exitCode, result) = ClipboardProcessRunner.Bash("which powershell.exe", waitForOutput: true);
                }

                if (exitCode == 0)
                {
                    powershellPath = result;
                }
            }
            return !string.IsNullOrEmpty(powershellPath);
        }

        protected override string GetClipboardDataImpl()
        {
            if (!IsSupported)
            {
                return string.Empty;
            }

            var (exitCode, output) = ClipboardProcessRunner.Process(powershellPath, "-noprofile -command \"Get-Clipboard\"");
            if (exitCode == 0)
            {
                if (Application.Driver is CursesDriver)
                {
                    Curses.raw();
                    Curses.noecho();
                }

                if (output.EndsWith("\r\n"))
                {
                    output = output.Substring(0, output.Length - 2);
                }
                return output;
            }
            return string.Empty;
        }

        protected override void SetClipboardDataImpl(string text)
        {
            if (!IsSupported)
            {
                return;
            }

            var (exitCode, output) = ClipboardProcessRunner.Process(powershellPath, $"-noprofile -command \"Set-Clipboard -Value \\\"{text}\\\"\"");
            if (exitCode == 0)
            {
                if (Application.Driver is CursesDriver)
                {
                    Curses.raw();
                    Curses.noecho();
                }
            }
        }
    }
    //=======================================================================
    //
    // DateField.cs: text entry for date
    //
    // Author: Barry Nolte
    //
    // Licensed under the MIT license
    //

    /// <summary>
    ///   Simple Date editing <see cref="View"/>
    /// </summary>
    /// <remarks>
    ///   The <see cref="DateField"/> <see cref="View"/> provides date editing functionality with mouse support.
    /// </remarks>
    public class DateField : TextField
    {
        DateTime date;
        bool isShort;
        int longFieldLen = 10;
        int shortFieldLen = 8;
        string sepChar;
        string longFormat;
        string shortFormat;

        int fieldLen => isShort ? shortFieldLen : longFieldLen;
        string format => isShort ? shortFormat : longFormat;

        /// <summary>
        ///   DateChanged event, raised when the <see cref="Date"/> property has changed.
        /// </summary>
        /// <remarks>
        ///   This event is raised when the <see cref="Date"/> property changes.
        /// </remarks>
        /// <remarks>
        ///   The passed event arguments containing the old value, new value, and format string.
        /// </remarks>
        public event Action<DateTimeEventArgs<DateTime>> DateChanged;

        /// <summary>
        ///    Initializes a new instance of <see cref="DateField"/> using <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        /// <param name="date">Initial date contents.</param>
        /// <param name="isShort">If true, shows only two digits for the year.</param>
        public DateField(int x, int y, DateTime date, bool isShort = false) : base(x, y, isShort ? 10 : 12, "")
        {
            Initialize(date, isShort);
        }

        /// <summary>
        ///  Initializes a new instance of <see cref="DateField"/> using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        public DateField() : this(DateTime.MinValue) { }

        /// <summary>
        ///  Initializes a new instance of <see cref="DateField"/> using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <param name="date"></param>
        public DateField(DateTime date) : base("")
        {
            Width = fieldLen + 2;
            Initialize(date);
        }

        void Initialize(DateTime date, bool isShort = false)
        {
            CultureInfo cultureInfo = CultureInfo.CurrentCulture;
            sepChar = cultureInfo.DateTimeFormat.DateSeparator;
            longFormat = GetLongFormat(cultureInfo.DateTimeFormat.ShortDatePattern);
            shortFormat = GetShortFormat(longFormat);
            this.isShort = isShort;
            Date = date;
            CursorPosition = 1;
            TextChanged += DateField_Changed;

            // Things this view knows how to do
            AddCommand(Command.DeleteCharRight, () => { DeleteCharRight(); return true; });
            AddCommand(Command.DeleteCharLeft, () => { DeleteCharLeft(); return true; });
            AddCommand(Command.LeftHome, () => MoveHome());
            AddCommand(Command.Left, () => MoveLeft());
            AddCommand(Command.RightEnd, () => MoveEnd());
            AddCommand(Command.Right, () => MoveRight());

            // Default keybindings for this view
            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);

            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);

            AddKeyBinding(Key.Home, Command.LeftHome);
            AddKeyBinding(Key.A | Key.CtrlMask, Command.LeftHome);

            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);

            AddKeyBinding(Key.End, Command.RightEnd);
            AddKeyBinding(Key.E | Key.CtrlMask, Command.RightEnd);

            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);
        }

        void DateField_Changed(ustring e)
        {
            try
            {
                if (!DateTime.TryParseExact(GetDate(Text).ToString(), GetInvarianteFormat(), CultureInfo.CurrentCulture, DateTimeStyles.None, out DateTime result))
                    Text = e;
            }
            catch (Exception)
            {
                Text = e;
            }
        }

        string GetInvarianteFormat()
        {
            return $"MM{sepChar}dd{sepChar}yyyy";
        }

        string GetLongFormat(string lf)
        {
            ustring[] frm = ustring.Make(lf).Split(ustring.Make(sepChar));
            for (int i = 0; i < frm.Length; i++)
            {
                if (frm[i].Contains("M") && frm[i].RuneCount < 2)
                    lf = lf.Replace("M", "MM");
                if (frm[i].Contains("d") && frm[i].RuneCount < 2)
                    lf = lf.Replace("d", "dd");
                if (frm[i].Contains("y") && frm[i].RuneCount < 4)
                    lf = lf.Replace("yy", "yyyy");
            }
            return $" {lf}";
        }

        string GetShortFormat(string lf)
        {
            return lf.Replace("yyyy", "yy");
        }

        /// <summary>
        ///   Gets or sets the date of the <see cref="DateField"/>.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public DateTime Date
        {
            get
            {
                return date;
            }
            set
            {
                if (ReadOnly)
                    return;

                var oldData = date;
                date = value;
                this.Text = value.ToString(format);
                var args = new DateTimeEventArgs<DateTime>(oldData, value, format);
                if (oldData != value)
                {
                    OnDateChanged(args);
                }
            }
        }

        /// <summary>
        /// Get or set the date format for the widget.
        /// </summary>
        public bool IsShortFormat
        {
            get => isShort;
            set
            {
                isShort = value;
                if (isShort)
                    Width = 10;
                else
                    Width = 12;
                var ro = ReadOnly;
                if (ro)
                    ReadOnly = false;
                SetText(Text);
                ReadOnly = ro;
                SetNeedsDisplay();
            }
        }

        /// <inheritdoc/>
        public override int CursorPosition
        {
            get => base.CursorPosition;
            set
            {
                base.CursorPosition = Math.Max(Math.Min(value, fieldLen), 1);
            }
        }

        bool SetText(Rune key)
        {
            var text = TextModel.ToRunes(Text);
            var newText = text.GetRange(0, CursorPosition);
            newText.Add(key);
            if (CursorPosition < fieldLen)
                newText = newText.Concat(text.GetRange(CursorPosition + 1, text.Count - (CursorPosition + 1))).ToList();
            return SetText(ustring.Make(newText));
        }

        bool SetText(ustring text)
        {
            if (text.IsEmpty)
            {
                return false;
            }

            ustring[] vals = text.Split(ustring.Make(sepChar));
            ustring[] frm = ustring.Make(format).Split(ustring.Make(sepChar));
            bool isValidDate = true;
            int idx = GetFormatIndex(frm, "y");
            int year = Int32.Parse(vals[idx].ToString());
            int month;
            int day;
            idx = GetFormatIndex(frm, "M");
            if (Int32.Parse(vals[idx].ToString()) < 1)
            {
                isValidDate = false;
                month = 1;
                vals[idx] = "1";
            }
            else if (Int32.Parse(vals[idx].ToString()) > 12)
            {
                isValidDate = false;
                month = 12;
                vals[idx] = "12";
            }
            else
                month = Int32.Parse(vals[idx].ToString());
            idx = GetFormatIndex(frm, "d");
            if (Int32.Parse(vals[idx].ToString()) < 1)
            {
                isValidDate = false;
                day = 1;
                vals[idx] = "1";
            }
            else if (Int32.Parse(vals[idx].ToString()) > 31)
            {
                isValidDate = false;
                day = DateTime.DaysInMonth(year, month);
                vals[idx] = day.ToString();
            }
            else
                day = Int32.Parse(vals[idx].ToString());
            string d = GetDate(month, day, year, frm);

            if (!DateTime.TryParseExact(d, format, CultureInfo.CurrentCulture, DateTimeStyles.None, out DateTime result) ||
                !isValidDate)
                return false;
            Date = result;
            return true;
        }

        string GetDate(int month, int day, int year, ustring[] fm)
        {
            string date = " ";
            for (int i = 0; i < fm.Length; i++)
            {
                if (fm[i].Contains("M"))
                {
                    date += $"{month,2:00}";
                }
                else if (fm[i].Contains("d"))
                {
                    date += $"{day,2:00}";
                }
                else
                {
                    if (!isShort && year.ToString().Length == 2)
                    {
                        var y = DateTime.Now.Year.ToString();
                        date += y.Substring(0, 2) + year.ToString();
                    }
                    else if (isShort && year.ToString().Length == 4)
                    {
                        date += $"{year.ToString().Substring(2, 2)}";
                    }
                    else
                    {
                        date += $"{year,2:00}";
                    }
                }
                if (i < 2)
                    date += $"{sepChar}";
            }
            return date;
        }

        ustring GetDate(ustring text)
        {
            ustring[] vals = text.Split(ustring.Make(sepChar));
            ustring[] frm = ustring.Make(format).Split(ustring.Make(sepChar));
            ustring[] date = { null, null, null };

            for (int i = 0; i < frm.Length; i++)
            {
                if (frm[i].Contains("M"))
                {
                    date[0] = vals[i].TrimSpace();
                }
                else if (frm[i].Contains("d"))
                {
                    date[1] = vals[i].TrimSpace();
                }
                else
                {
                    var year = vals[i].TrimSpace();
                    if (year.RuneCount == 2)
                    {
                        var y = DateTime.Now.Year.ToString();
                        date[2] = y.Substring(0, 2) + year.ToString();
                    }
                    else
                    {
                        date[2] = vals[i].TrimSpace();
                    }
                }
            }
            return date[0] + ustring.Make(sepChar) + date[1] + ustring.Make(sepChar) + date[2];

        }

        int GetFormatIndex(ustring[] fm, string t)
        {
            int idx = -1;
            for (int i = 0; i < fm.Length; i++)
            {
                if (fm[i].Contains(t))
                {
                    idx = i;
                    break;
                }
            }
            return idx;
        }

        void IncCursorPosition()
        {
            if (CursorPosition == fieldLen)
                return;
            if (Text[++CursorPosition] == sepChar.ToCharArray()[0])
                CursorPosition++;
        }

        void DecCursorPosition()
        {
            if (CursorPosition == 1)
                return;
            if (Text[--CursorPosition] == sepChar.ToCharArray()[0])
                CursorPosition--;
        }

        void AdjCursorPosition()
        {
            if (Text[CursorPosition] == sepChar.ToCharArray()[0])
                CursorPosition++;
        }

        /// <inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            // Ignore non-numeric characters.
            if (kb.Key < (Key)((int)'0') || kb.Key > (Key)((int)'9'))
                return false;

            if (ReadOnly)
                return true;

            if (SetText(TextModel.ToRunes(ustring.Make((uint)kb.Key)).First()))
                IncCursorPosition();

            return true;
        }

        bool MoveRight()
        {
            IncCursorPosition();
            return true;
        }

        bool MoveEnd()
        {
            CursorPosition = fieldLen;
            return true;
        }

        bool MoveLeft()
        {
            DecCursorPosition();
            return true;
        }

        bool MoveHome()
        {
            // Home, C-A
            CursorPosition = 1;
            return true;
        }

        /// <inheritdoc/>
        public override void DeleteCharLeft(bool useOldCursorPos = true)
        {
            if (ReadOnly)
                return;

            SetText('0');
            DecCursorPosition();
            return;
        }

        /// <inheritdoc/>
        public override void DeleteCharRight()
        {
            if (ReadOnly)
                return;

            SetText('0');
            return;
        }

        /// <inheritdoc/>
        public override bool MouseEvent(MouseEvent ev)
        {
            if (!ev.Flags.HasFlag(MouseFlags.Button1Clicked))
                return false;
            if (!HasFocus)
                SetFocus();

            var point = ev.X;
            if (point > fieldLen)
                point = fieldLen;
            if (point < 1)
                point = 1;
            CursorPosition = point;
            AdjCursorPosition();
            return true;
        }

        /// <summary>
        /// Event firing method for the <see cref="DateChanged"/> event.
        /// </summary>
        /// <param name="args">Event arguments</param>
        public virtual void OnDateChanged(DateTimeEventArgs<DateTime> args)
        {
            DateChanged?.Invoke(args);
        }
    }

    /// <summary>
    /// Defines the event arguments for <see cref="DateField.DateChanged"/> and <see cref="TimeField.TimeChanged"/> events.
    /// </summary>
    public class DateTimeEventArgs<T> : EventArgs
    {
        /// <summary>
        /// The old <see cref="DateField"/> or <see cref="TimeField"/> value.
        /// </summary>
        public T OldValue { get; }

        /// <summary>
        /// The new <see cref="DateField"/> or <see cref="TimeField"/> value.
        /// </summary>
        public T NewValue { get; }

        /// <summary>
        /// The <see cref="DateField"/> or <see cref="TimeField"/> format.
        /// </summary>
        public string Format { get; }

        /// <summary>
        /// Initializes a new instance of <see cref="DateTimeEventArgs{T}"/>
        /// </summary>
        /// <param name="oldValue">The old <see cref="DateField"/> or <see cref="TimeField"/> value.</param>
        /// <param name="newValue">The new <see cref="DateField"/> or <see cref="TimeField"/> value.</param>
        /// <param name="format">The <see cref="DateField"/> or <see cref="TimeField"/> format string.</param>
        public DateTimeEventArgs(T oldValue, T newValue, string format)
        {
            OldValue = oldValue;
            NewValue = newValue;
            Format = format;
        }
    }
    //=======================================================================
    //
    // Dialog.cs: Dialog box
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    /// The <see cref="Dialog"/> <see cref="View"/> is a <see cref="Window"/> that by default is centered and contains one 
    /// or more <see cref="Button"/>s. It defaults to the <see cref="Colors.Dialog"/> color scheme and has a 1 cell padding around the edges.
    /// </summary>
    /// <remarks>
    ///  To run the <see cref="Dialog"/> modally, create the <see cref="Dialog"/>, and pass it to <see cref="Application.Run(Func{Exception, bool})"/>. 
    ///  This will execute the dialog until it terminates via the [ESC] or [CTRL-Q] key, or when one of the views
    ///  or buttons added to the dialog calls <see cref="Application.RequestStop"/>.
    /// </remarks>
    public class Dialog : Window
    {
        internal List<Button> buttons = new List<Button>();
        const int padding = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="Dialog"/> class using <see cref="LayoutStyle.Computed"/> positioning 
        /// and an optional set of <see cref="Button"/>s to display
        /// </summary>
        /// <param name="title">Title for the dialog.</param>
        /// <param name="width">Width for the dialog.</param>
        /// <param name="height">Height for the dialog.</param>
        /// <param name="buttons">Optional buttons to lay out at the bottom of the dialog.</param>
        /// <remarks>
        /// if <c>width</c> and <c>height</c> are both 0, the Dialog will be vertically and horizontally centered in the
        /// container and the size will be 85% of the container. 
        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> to override this with a location or size.
        /// </remarks>
        /// <remarks>
        /// Use the constructor that does not take a <c>width</c> and <c>height</c> instead.
        /// </remarks>
        public Dialog(ustring title, int width, int height, params Button[] buttons) : base(title, padding: padding)
        {
            X = Pos.Center();
            Y = Pos.Center();

            if (width == 0 & height == 0)
            {
                Width = Dim.Percent(85);
                Height = Dim.Percent(85);
            }
            else
            {
                Width = width;
                Height = height;
            }

            ColorScheme = Colors.Dialog;
            Modal = true;
            Border.Effect3D = true;

            if (buttons != null)
            {
                foreach (var b in buttons)
                {
                    this.buttons.Add(b);
                    Add(b);
                }
            }

            LayoutStarted += (args) =>
            {
                LayoutStartedHandler();
            };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Dialog"/> class using <see cref="LayoutStyle.Computed"/>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Te Dialog will be vertically and horizontally centered in the container and the size will be 85% of the container. 
        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> to override this with a location or size.
        /// </para>
        /// <para>
        /// Use <see cref="AddButton(Button)"/> to add buttons to the dialog.
        /// </para>
        /// </remarks>
        public Dialog() : this(title: string.Empty, width: 0, height: 0, buttons: null) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Dialog"/> class using <see cref="LayoutStyle.Computed"/> positioning 
        /// and with an optional set of <see cref="Button"/>s to display
        /// </summary>
        /// <param name="title">Title for the dialog.</param>
        /// <param name="buttons">Optional buttons to lay out at the bottom of the dialog.</param>
        /// <remarks>
        /// Te Dialog will be vertically and horizontally centered in the container and the size will be 85% of the container. 
        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> to override this with a location or size.
        /// </remarks>
        public Dialog(ustring title, params Button[] buttons) : this(title: title, width: 0, height: 0, buttons: buttons) { }

        /// <summary>
        /// Adds a <see cref="Button"/> to the <see cref="Dialog"/>, its layout will be controlled by the <see cref="Dialog"/>
        /// </summary>
        /// <param name="button">Button to add.</param>
        public void AddButton(Button button)
        {
            if (button == null)
                return;

            buttons.Add(button);
            Add(button);
            SetNeedsDisplay();
            LayoutSubviews();
        }

        // Get the width of all buttons, not including any spacing
        internal int GetButtonsWidth()
        {
            if (buttons.Count == 0)
            {
                return 0;
            }
            return buttons.Select(b => b.Bounds.Width).Sum();
        }
        /// <summary>
        /// Determines the horizontal alignment of the Dialog buttons.
        /// </summary>
        public enum ButtonAlignments
        {
            /// <summary>
            /// Center-aligns the buttons (the default).
            /// </summary>
            Center = 0,

            /// <summary>
            /// Justifies the buttons
            /// </summary>
            Justify,

            /// <summary>
            /// Left-aligns the buttons
            /// </summary>
            Left,

            /// <summary>
            /// Right-aligns the buttons
            /// </summary>
            Right
        }

        private ButtonAlignments buttonAlignment = Dialog.ButtonAlignments.Center;

        /// <summary>
        /// Determines how the <see cref="Dialog"/> <see cref="Button"/>s are aligned along the 
        /// bottom of the dialog. 
        /// </summary>
        public ButtonAlignments ButtonAlignment { get => buttonAlignment; set => buttonAlignment = value; }

        void LayoutStartedHandler()
        {
            if (buttons.Count == 0 || !IsInitialized) return;

            int shiftLeft = 0;

            int buttonsWidth = GetButtonsWidth();
            switch (ButtonAlignment)
            {
                case ButtonAlignments.Center:
                    // Center Buttons
                    shiftLeft = (Bounds.Width - buttonsWidth - buttons.Count - 2) / 2 + 1;
                    for (int i = buttons.Count - 1; i >= 0; i--)
                    {
                        Button button = buttons[i];
                        shiftLeft += button.Frame.Width + (i == buttons.Count - 1 ? 0 : 1);
                        if (shiftLeft > -1)
                        {
                            button.X = Pos.AnchorEnd(shiftLeft);
                        }
                        else
                        {
                            button.X = Frame.Width - shiftLeft;
                        }
                        button.Y = Pos.AnchorEnd(1);
                    }
                    break;

                case ButtonAlignments.Justify:
                    // Justify Buttons
                    // leftmost and rightmost buttons are hard against edges. The rest are evenly spaced.

                    var spacing = (int)Math.Ceiling((double)(Bounds.Width - buttonsWidth - (Border.DrawMarginFrame ? 2 : 0)) / (buttons.Count - 1));
                    for (int i = buttons.Count - 1; i >= 0; i--)
                    {
                        Button button = buttons[i];
                        if (i == buttons.Count - 1)
                        {
                            shiftLeft += button.Frame.Width;
                            button.X = Pos.AnchorEnd(shiftLeft);
                        }
                        else
                        {
                            if (i == 0)
                            {
                                // first (leftmost) button - always hard flush left
                                var left = Bounds.Width - ((Border.DrawMarginFrame ? 2 : 0) + Border.BorderThickness.Left + Border.BorderThickness.Right);
                                button.X = Pos.AnchorEnd(Math.Max(left, 0));
                            }
                            else
                            {
                                shiftLeft += button.Frame.Width + (spacing);
                                button.X = Pos.AnchorEnd(shiftLeft);
                            }
                        }
                        button.Y = Pos.AnchorEnd(1);
                    }
                    break;

                case ButtonAlignments.Left:
                    // Left Align Buttons
                    var prevButton = buttons[0];
                    prevButton.X = 0;
                    prevButton.Y = Pos.AnchorEnd(1);
                    for (int i = 1; i < buttons.Count; i++)
                    {
                        Button button = buttons[i];
                        button.X = Pos.Right(prevButton) + 1;
                        button.Y = Pos.AnchorEnd(1);
                        prevButton = button;
                    }
                    break;

                case ButtonAlignments.Right:
                    // Right align buttons
                    shiftLeft = buttons[buttons.Count - 1].Frame.Width;
                    buttons[buttons.Count - 1].X = Pos.AnchorEnd(shiftLeft);
                    buttons[buttons.Count - 1].Y = Pos.AnchorEnd(1);
                    for (int i = buttons.Count - 2; i >= 0; i--)
                    {
                        Button button = buttons[i];
                        shiftLeft += button.Frame.Width + 1;
                        button.X = Pos.AnchorEnd(shiftLeft);
                        button.Y = Pos.AnchorEnd(1);
                    }
                    break;
            }
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            switch (kb.Key)
            {
                case Key.Esc:
                    Application.RequestStop(this);
                    return true;
            }
            return base.ProcessKey(kb);
        }
    }
    //=======================================================================
    /// <summary>
    /// Represents the state of an ANSI escape sequence request.
    /// </summary>
    /// <remarks>
    /// This is needed because there are some escape sequence requests responses that are equal
    /// with some normal escape sequences and thus, will be only considered the responses to the
    /// requests that were registered with this object.
    /// </remarks>
    public class EscSeqReqStatus
    {
        /// <summary>
        /// Gets the terminating.
        /// </summary>
        public string Terminating { get; }
        /// <summary>
        /// Gets the number of requests.
        /// </summary>
        public int NumRequests { get; }
        /// <summary>
        /// Gets information about unfinished requests.
        /// </summary>
        public int NumOutstanding { get; set; }

        /// <summary>
        /// Creates a new state of escape sequence request.
        /// </summary>
        /// <param name="terminating">The terminating.</param>
        /// <param name="numOfReq">The number of requests.</param>
        public EscSeqReqStatus(string terminating, int numOfReq)
        {
            Terminating = terminating;
            NumRequests = NumOutstanding = numOfReq;
        }
    }

    /// <summary>
    /// Manages a list of <see cref="EscSeqReqStatus"/>.
    /// </summary>
    public class EscSeqReqProc
    {
        /// <summary>
        /// Gets the <see cref="EscSeqReqStatus"/> list.
        /// </summary>
        public List<EscSeqReqStatus> EscSeqReqStats { get; } = new List<EscSeqReqStatus>();

        /// <summary>
        /// Adds a new <see cref="EscSeqReqStatus"/> instance to the <see cref="EscSeqReqStats"/> list.
        /// </summary>
        /// <param name="terminating">The terminating.</param>
        /// <param name="numOfReq">The number of requests.</param>
        public void Add(string terminating, int numOfReq = 1)
        {
            lock (EscSeqReqStats)
            {
                var found = EscSeqReqStats.Find(x => x.Terminating == terminating);
                if (found == null)
                {
                    EscSeqReqStats.Add(new EscSeqReqStatus(terminating, numOfReq));
                }
                else if (found != null && found.NumOutstanding < found.NumRequests)
                {
                    found.NumOutstanding = Math.Min(found.NumOutstanding + numOfReq, found.NumRequests);
                }
            }
        }

        /// <summary>
        /// Removes a <see cref="EscSeqReqStatus"/> instance from the <see cref="EscSeqReqStats"/> list.
        /// </summary>
        /// <param name="terminating">The terminating string.</param>
        public void Remove(string terminating)
        {
            lock (EscSeqReqStats)
            {
                var found = EscSeqReqStats.Find(x => x.Terminating == terminating);
                if (found == null)
                {
                    return;
                }
                if (found != null && found.NumOutstanding == 0)
                {
                    EscSeqReqStats.Remove(found);
                }
                else if (found != null && found.NumOutstanding > 0)
                {
                    found.NumOutstanding--;
                    if (found.NumOutstanding == 0)
                    {
                        EscSeqReqStats.Remove(found);
                    }
                }
            }
        }

        /// <summary>
        /// Indicates if a <see cref="EscSeqReqStatus"/> with the <paramref name="terminating"/> exist
        /// in the <see cref="EscSeqReqStats"/> list.
        /// </summary>
        /// <param name="terminating"></param>
        /// <returns><see langword="true"/> if exist, <see langword="false"/> otherwise.</returns>
        public bool Requested(string terminating)
        {
            lock (EscSeqReqStats)
            {
                var found = EscSeqReqStats.Find(x => x.Terminating == terminating);
                if (found == null)
                {
                    return false;
                }
                if (found != null && found.NumOutstanding > 0)
                {
                    return true;
                }
                else
                {
                    EscSeqReqStats.Remove(found);
                }
                return false;
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Provides a platform-independent API for managing ANSI escape sequence codes.
    /// </summary>
    public static class EscSeqUtils
    {
        /// <summary>
        /// Represents the escape key.
        /// </summary>
        public static readonly char KeyEsc = (char)Key.Esc;
        /// <summary>
        /// Represents the CSI (Control Sequence Introducer).
        /// </summary>
        public static readonly string KeyCSI = $"{KeyEsc}[";
        /// <summary>
        /// Represents the CSI for enable any mouse event tracking.
        /// </summary>
        public static readonly string CSI_EnableAnyEventMouse = KeyCSI + "?1003h";
        /// <summary>
        /// Represents the CSI for enable SGR (Select Graphic Rendition).
        /// </summary>
        public static readonly string CSI_EnableSgrExtModeMouse = KeyCSI + "?1006h";
        /// <summary>
        /// Represents the CSI for enable URXVT (Unicode Extended Virtual Terminal).
        /// </summary>
        public static readonly string CSI_EnableUrxvtExtModeMouse = KeyCSI + "?1015h";
        /// <summary>
        /// Represents the CSI for disable any mouse event tracking.
        /// </summary>
        public static readonly string CSI_DisableAnyEventMouse = KeyCSI + "?1003l";
        /// <summary>
        /// Represents the CSI for disable SGR (Select Graphic Rendition).
        /// </summary>
        public static readonly string CSI_DisableSgrExtModeMouse = KeyCSI + "?1006l";
        /// <summary>
        /// Represents the CSI for disable URXVT (Unicode Extended Virtual Terminal).
        /// </summary>
        public static readonly string CSI_DisableUrxvtExtModeMouse = KeyCSI + "?1015l";

        /// <summary>
        /// Control sequence for enable mouse events.
        /// </summary>
        public static string EnableMouseEvents { get; set; } =
            CSI_EnableAnyEventMouse + CSI_EnableUrxvtExtModeMouse + CSI_EnableSgrExtModeMouse;
        /// <summary>
        /// Control sequence for disable mouse events.
        /// </summary>
        public static string DisableMouseEvents { get; set; } =
            CSI_DisableAnyEventMouse + CSI_DisableUrxvtExtModeMouse + CSI_DisableSgrExtModeMouse;

        /// <summary>
        /// Ensures a console key is mapped to one that works correctly with ANSI escape sequences.
        /// </summary>
        /// <param name="consoleKeyInfo">The <see cref="ConsoleKeyInfo"/>.</param>
        /// <returns>The <see cref="ConsoleKeyInfo"/> modified.</returns>
        public static ConsoleKeyInfo GetConsoleInputKey(ConsoleKeyInfo consoleKeyInfo)
        {
            ConsoleKeyInfo newConsoleKeyInfo = consoleKeyInfo;
            ConsoleKey key;
            var keyChar = consoleKeyInfo.KeyChar;
            switch ((uint)keyChar)
            {
                case 0:
                    if (consoleKeyInfo.Key == (ConsoleKey)64)
                    {    // Ctrl+Space in Windows.
                        newConsoleKeyInfo = new ConsoleKeyInfo(' ', ConsoleKey.Spacebar,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Control) != 0);
                    }
                    break;
                case uint n when (n >= '\u0001' && n <= '\u001a'):
                    if (consoleKeyInfo.Key == 0 && consoleKeyInfo.KeyChar == '\r')
                    {
                        key = ConsoleKey.Enter;
                        newConsoleKeyInfo = new ConsoleKeyInfo(consoleKeyInfo.KeyChar,
                            key,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Control) != 0);
                    }
                    else if (consoleKeyInfo.Key == 0)
                    {
                        key = (ConsoleKey)(char)(consoleKeyInfo.KeyChar + (uint)ConsoleKey.A - 1);
                        newConsoleKeyInfo = new ConsoleKeyInfo((char)key,
                            key,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
                            (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
                            true);
                    }
                    break;
                case 127:
                    newConsoleKeyInfo = new ConsoleKeyInfo(consoleKeyInfo.KeyChar, ConsoleKey.Backspace,
                        (consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != 0,
                        (consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != 0,
                        (consoleKeyInfo.Modifiers & ConsoleModifiers.Control) != 0);
                    break;
                default:
                    newConsoleKeyInfo = consoleKeyInfo;
                    break;
            }

            return newConsoleKeyInfo;
        }

        /// <summary>
        /// A helper to resize the <see cref="ConsoleKeyInfo"/> as needed.
        /// </summary>
        /// <param name="consoleKeyInfo">The <see cref="ConsoleKeyInfo"/>.</param>
        /// <param name="cki">The <see cref="ConsoleKeyInfo"/> array to resize.</param>
        /// <returns>The <see cref="ConsoleKeyInfo"/> resized.</returns>
        public static ConsoleKeyInfo[] ResizeArray(ConsoleKeyInfo consoleKeyInfo, ConsoleKeyInfo[] cki)
        {
            Array.Resize(ref cki, cki == null ? 1 : cki.Length + 1);
            cki[cki.Length - 1] = consoleKeyInfo;
            return cki;
        }

        /// <summary>
        /// Decodes a escape sequence to been processed in the appropriate manner.
        /// </summary>
        /// <param name="escSeqReqProc">The <see cref="EscSeqReqProc"/> which may contain a request.</param>
        /// <param name="newConsoleKeyInfo">The <see cref="ConsoleKeyInfo"/> which may changes.</param>
        /// <param name="key">The <see cref="ConsoleKey"/> which may changes.</param>
        /// <param name="cki">The <see cref="ConsoleKeyInfo"/> array.</param>
        /// <param name="mod">The <see cref="ConsoleModifiers"/> which may changes.</param>
        /// <param name="c1Control">The control returned by the <see cref="GetC1ControlChar(char)"/> method.</param>
        /// <param name="code">The code returned by the <see cref="GetEscapeResult(char[])"/> method.</param>
        /// <param name="values">The values returned by the <see cref="GetEscapeResult(char[])"/> method.</param>
        /// <param name="terminating">The terminating returned by the <see cref="GetEscapeResult(char[])"/> method.</param>
        /// <param name="isKeyMouse">Indicates if the escape sequence is a mouse key.</param>
        /// <param name="buttonState">The <see cref="MouseFlags"/> button state.</param>
        /// <param name="pos">The <see cref="MouseFlags"/> position.</param>
        /// <param name="isReq">Indicates if the escape sequence is a response to a request.</param>
        /// <param name="continuousButtonPressedHandler">The handler that will process the event.</param>
        public static void DecodeEscSeq(EscSeqReqProc escSeqReqProc, ref ConsoleKeyInfo newConsoleKeyInfo, ref ConsoleKey key, ConsoleKeyInfo[] cki, ref ConsoleModifiers mod, out string c1Control, out string code, out string[] values, out string terminating, out bool isKeyMouse, out List<MouseFlags> buttonState, out Point pos, out bool isReq, Action<MouseFlags, Point> continuousButtonPressedHandler)
        {
            char[] kChars = GetKeyCharArray(cki);
            (c1Control, code, values, terminating) = GetEscapeResult(kChars);
            isKeyMouse = false;
            buttonState = new List<MouseFlags>() { 0 };
            pos = default;
            isReq = false;
            switch (c1Control)
            {
                case "ESC":
                    if (values == null && string.IsNullOrEmpty(terminating))
                    {
                        key = ConsoleKey.Escape;
                        newConsoleKeyInfo = new ConsoleKeyInfo(cki[0].KeyChar, key,
                            (mod & ConsoleModifiers.Shift) != 0,
                            (mod & ConsoleModifiers.Alt) != 0,
                            (mod & ConsoleModifiers.Control) != 0);
                    }
                    else if ((uint)cki[1].KeyChar >= 1 && (uint)cki[1].KeyChar <= 26)
                    {
                        key = (ConsoleKey)(char)(cki[1].KeyChar + (uint)ConsoleKey.A - 1);
                        newConsoleKeyInfo = new ConsoleKeyInfo(cki[1].KeyChar,
                            key,
                            false,
                            true,
                            true);
                    }
                    else
                    {
                        if (cki[1].KeyChar >= 97 && cki[1].KeyChar <= 122)
                        {
                            key = (ConsoleKey)cki[1].KeyChar.ToString().ToUpper()[0];
                        }
                        else
                        {
                            key = (ConsoleKey)cki[1].KeyChar;
                        }
                        newConsoleKeyInfo = new ConsoleKeyInfo((char)key,
                            (ConsoleKey)Math.Min((uint)key, 255),
                            false,
                            true,
                            false);
                    }
                    break;
                case "SS3":
                    key = GetConsoleKey(terminating[0], values[0], ref mod);
                    newConsoleKeyInfo = new ConsoleKeyInfo('\0',
                        key,
                        (mod & ConsoleModifiers.Shift) != 0,
                        (mod & ConsoleModifiers.Alt) != 0,
                        (mod & ConsoleModifiers.Control) != 0);
                    break;
                case "CSI":
                    if (!string.IsNullOrEmpty(code) && code == "<")
                    {
                        GetMouse(cki, out buttonState, out pos, continuousButtonPressedHandler);
                        isKeyMouse = true;
                        return;
                    }
                    else if (escSeqReqProc != null && escSeqReqProc.Requested(terminating))
                    {
                        isReq = true;
                        escSeqReqProc.Remove(terminating);
                        return;
                    }
                    key = GetConsoleKey(terminating[0], values[0], ref mod);
                    if (key != 0 && values.Length > 1)
                    {
                        mod |= GetConsoleModifiers(values[1]);
                    }
                    newConsoleKeyInfo = new ConsoleKeyInfo('\0',
                        key,
                        (mod & ConsoleModifiers.Shift) != 0,
                        (mod & ConsoleModifiers.Alt) != 0,
                        (mod & ConsoleModifiers.Control) != 0);
                    break;
            }
        }

        /// <summary>
        /// Gets all the needed information about a escape sequence.
        /// </summary>
        /// <param name="kChar">The array with all chars.</param>
        /// <returns>
        /// The c1Control returned by <see cref="GetC1ControlChar(char)"/>, code, values and terminating.
        /// </returns>
        public static (string c1Control, string code, string[] values, string terminating) GetEscapeResult(char[] kChar)
        {
            if (kChar == null || kChar.Length == 0)
            {
                return (null, null, null, null);
            }
            if (kChar[0] != '\x1b')
            {
                throw new InvalidOperationException("Invalid escape character!");
            }
            if (kChar.Length == 1)
            {
                return ("ESC", null, null, null);
            }
            if (kChar.Length == 2)
            {
                return ("ESC", null, null, kChar[1].ToString());
            }
            string c1Control = GetC1ControlChar(kChar[1]);
            string code = null;
            int nSep = kChar.Count(x => x == ';') + 1;
            string[] values = new string[nSep];
            int valueIdx = 0;
            string terminating = "";
            for (int i = 2; i < kChar.Length; i++)
            {
                var c = kChar[i];
                if (char.IsDigit(c))
                {
                    values[valueIdx] += c.ToString();
                }
                else if (c == ';')
                {
                    valueIdx++;
                }
                else if (valueIdx == nSep - 1 || i == kChar.Length - 1)
                {
                    terminating += c.ToString();
                }
                else
                {
                    code += c.ToString();
                }
            }

            return (c1Control, code, values, terminating);
        }

        /// <summary>
        /// Gets the c1Control used in the called escape sequence.
        /// </summary>
        /// <param name="c">The char used.</param>
        /// <returns>The c1Control.</returns>
        public static string GetC1ControlChar(char c)
        {
            // These control characters are used in the vtXXX emulation.
            switch (c)
            {
                case 'D':
                    return "IND"; // Index
                case 'E':
                    return "NEL"; // Next Line
                case 'H':
                    return "HTS"; // Tab Set
                case 'M':
                    return "RI"; // Reverse Index
                case 'N':
                    return "SS2"; // Single Shift Select of G2 Character Set: affects next character only
                case 'O':
                    return "SS3"; // Single Shift Select of G3 Character Set: affects next character only
                case 'P':
                    return "DCS"; // Device Control String
                case 'V':
                    return "SPA"; // Start of Guarded Area
                case 'W':
                    return "EPA"; // End of Guarded Area
                case 'X':
                    return "SOS"; // Start of String
                case 'Z':
                    return "DECID"; // Return Terminal ID Obsolete form of CSI c (DA)
                case '[':
                    return "CSI"; // Control Sequence Introducer
                case '\\':
                    return "ST"; // String Terminator
                case ']':
                    return "OSC"; // Operating System Command
                case '^':
                    return "PM"; // Privacy Message
                case '_':
                    return "APC"; // Application Program Command
                default:
                    return ""; // Not supported
            }
        }

        /// <summary>
        /// Gets the <see cref="ConsoleModifiers"/> from the value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>The <see cref="ConsoleModifiers"/> or zero.</returns>
        public static ConsoleModifiers GetConsoleModifiers(string value)
        {
            switch (value)
            {
                case "2":
                    return ConsoleModifiers.Shift;
                case "3":
                    return ConsoleModifiers.Alt;
                case "4":
                    return ConsoleModifiers.Shift | ConsoleModifiers.Alt;
                case "5":
                    return ConsoleModifiers.Control;
                case "6":
                    return ConsoleModifiers.Shift | ConsoleModifiers.Control;
                case "7":
                    return ConsoleModifiers.Alt | ConsoleModifiers.Control;
                case "8":
                    return ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// Gets the <see cref="ConsoleKey"/> depending on terminating and value.
        /// </summary>
        /// <param name="terminating">The terminating.</param>
        /// <param name="value">The value.</param>
        /// <param name="mod">The <see cref="ConsoleModifiers"/> which may changes.</param>
        /// <returns>The <see cref="ConsoleKey"/> and probably the <see cref="ConsoleModifiers"/>.</returns>
        public static ConsoleKey GetConsoleKey(char terminating, string value, ref ConsoleModifiers mod)
        {
            ConsoleKey key;
            switch (terminating)
            {
                case 'A':
                    key = ConsoleKey.UpArrow;
                    break;
                case 'B':
                    key = ConsoleKey.DownArrow;
                    break;
                case 'C':
                    key = ConsoleKey.RightArrow;
                    break;
                case 'D':
                    key = ConsoleKey.LeftArrow;
                    break;
                case 'F':
                    key = ConsoleKey.End;
                    break;
                case 'H':
                    key = ConsoleKey.Home;
                    break;
                case 'P':
                    key = ConsoleKey.F1;
                    break;
                case 'Q':
                    key = ConsoleKey.F2;
                    break;
                case 'R':
                    key = ConsoleKey.F3;
                    break;
                case 'S':
                    key = ConsoleKey.F4;
                    break;
                case 'Z':
                    key = ConsoleKey.Tab;
                    mod |= ConsoleModifiers.Shift;
                    break;
                case '~':
                    switch (value)
                    {
                        case "2":
                            key = ConsoleKey.Insert;
                            break;
                        case "3":
                            key = ConsoleKey.Delete;
                            break;
                        case "5":
                            key = ConsoleKey.PageUp;
                            break;
                        case "6":
                            key = ConsoleKey.PageDown;
                            break;
                        case "15":
                            key = ConsoleKey.F5;
                            break;
                        case "17":
                            key = ConsoleKey.F6;
                            break;
                        case "18":
                            key = ConsoleKey.F7;
                            break;
                        case "19":
                            key = ConsoleKey.F8;
                            break;
                        case "20":
                            key = ConsoleKey.F9;
                            break;
                        case "21":
                            key = ConsoleKey.F10;
                            break;
                        case "23":
                            key = ConsoleKey.F11;
                            break;
                        case "24":
                            key = ConsoleKey.F12;
                            break;
                        default:
                            key = 0;
                            break;
                    }
                    break;
                default:
                    key = 0;
                    break;
            }

            return key;
        }

        /// <summary>
        /// A helper to get only the <see cref="ConsoleKeyInfo.KeyChar"/> from the <see cref="ConsoleKeyInfo"/> array.
        /// </summary>
        /// <param name="cki"></param>
        /// <returns>The char array of the escape sequence.</returns>
        public static char[] GetKeyCharArray(ConsoleKeyInfo[] cki)
        {
            if (cki == null)
            {
                return null;
            }
            char[] kChar = new char[] { };
            var length = 0;
            foreach (var kc in cki)
            {
                length++;
                Array.Resize(ref kChar, length);
                kChar[length - 1] = kc.KeyChar;
            }

            return kChar;
        }

        private static MouseFlags? lastMouseButtonPressed;
        //private static MouseFlags? lastMouseButtonReleased;
        private static bool isButtonPressed;
        //private static bool isButtonReleased;
        private static bool isButtonClicked;
        private static bool isButtonDoubleClicked;
        private static bool isButtonTripleClicked;
        private static Point point;

        /// <summary>
        /// Gets the <see cref="MouseFlags"/> mouse button flags and the position.
        /// </summary>
        /// <param name="cki">The <see cref="ConsoleKeyInfo"/> array.</param>
        /// <param name="mouseFlags">The mouse button flags.</param>
        /// <param name="pos">The mouse position.</param>
        /// <param name="continuousButtonPressedHandler">The handler that will process the event.</param>
        public static void GetMouse(ConsoleKeyInfo[] cki, out List<MouseFlags> mouseFlags, out Point pos, Action<MouseFlags, Point> continuousButtonPressedHandler)
        {
            MouseFlags buttonState = 0;
            pos = new Point();
            int buttonCode = 0;
            bool foundButtonCode = false;
            int foundPoint = 0;
            string value = "";
            var kChar = GetKeyCharArray(cki);
            //System.Diagnostics.Debug.WriteLine ($"kChar: {new string (kChar)}");
            for (int i = 0; i < kChar.Length; i++)
            {
                var c = kChar[i];
                if (c == '<')
                {
                    foundButtonCode = true;
                }
                else if (foundButtonCode && c != ';')
                {
                    value += c.ToString();
                }
                else if (c == ';')
                {
                    if (foundButtonCode)
                    {
                        foundButtonCode = false;
                        buttonCode = int.Parse(value);
                    }
                    if (foundPoint == 1)
                    {
                        pos.X = int.Parse(value) - 1;
                    }
                    value = "";
                    foundPoint++;
                }
                else if (foundPoint > 0 && c != 'm' && c != 'M')
                {
                    value += c.ToString();
                }
                else if (c == 'm' || c == 'M')
                {
                    //pos.Y = int.Parse (value) + Console.WindowTop - 1;
                    pos.Y = int.Parse(value) - 1;

                    switch (buttonCode)
                    {
                        case 0:
                        case 8:
                        case 16:
                        case 24:
                        case 32:
                        case 36:
                        case 40:
                        case 48:
                        case 56:
                            buttonState = c == 'M' ? MouseFlags.Button1Pressed
                                : MouseFlags.Button1Released;
                            break;
                        case 1:
                        case 9:
                        case 17:
                        case 25:
                        case 33:
                        case 37:
                        case 41:
                        case 45:
                        case 49:
                        case 53:
                        case 57:
                        case 61:
                            buttonState = c == 'M' ? MouseFlags.Button2Pressed
                                : MouseFlags.Button2Released;
                            break;
                        case 2:
                        case 10:
                        case 14:
                        case 18:
                        case 22:
                        case 26:
                        case 30:
                        case 34:
                        case 42:
                        case 46:
                        case 50:
                        case 54:
                        case 58:
                        case 62:
                            buttonState = c == 'M' ? MouseFlags.Button3Pressed
                                : MouseFlags.Button3Released;
                            break;
                        case 35:
                        //// Needed for Windows OS
                        //if (isButtonPressed && c == 'm'
                        //	&& (lastMouseEvent.ButtonState == MouseFlags.Button1Pressed
                        //	|| lastMouseEvent.ButtonState == MouseFlags.Button2Pressed
                        //	|| lastMouseEvent.ButtonState == MouseFlags.Button3Pressed)) {

                        //	switch (lastMouseEvent.ButtonState) {
                        //	case MouseFlags.Button1Pressed:
                        //		buttonState = MouseFlags.Button1Released;
                        //		break;
                        //	case MouseFlags.Button2Pressed:
                        //		buttonState = MouseFlags.Button2Released;
                        //		break;
                        //	case MouseFlags.Button3Pressed:
                        //		buttonState = MouseFlags.Button3Released;
                        //		break;
                        //	}
                        //} else {
                        //	buttonState = MouseFlags.ReportMousePosition;
                        //}
                        //break;
                        case 39:
                        case 43:
                        case 47:
                        case 51:
                        case 55:
                        case 59:
                        case 63:
                            buttonState = MouseFlags.ReportMousePosition;
                            break;
                        case 64:
                            buttonState = MouseFlags.WheeledUp;
                            break;
                        case 65:
                            buttonState = MouseFlags.WheeledDown;
                            break;
                        case 68:
                        case 72:
                        case 80:
                            buttonState = MouseFlags.WheeledLeft;       // Shift/Ctrl+WheeledUp
                            break;
                        case 69:
                        case 73:
                        case 81:
                            buttonState = MouseFlags.WheeledRight;      // Shift/Ctrl+WheeledDown
                            break;
                    }
                    // Modifiers.
                    switch (buttonCode)
                    {
                        case 8:
                        case 9:
                        case 10:
                        case 43:
                            buttonState |= MouseFlags.ButtonAlt;
                            break;
                        case 14:
                        case 47:
                            buttonState |= MouseFlags.ButtonAlt | MouseFlags.ButtonShift;
                            break;
                        case 16:
                        case 17:
                        case 18:
                        case 51:
                            buttonState |= MouseFlags.ButtonCtrl;
                            break;
                        case 22:
                        case 55:
                            buttonState |= MouseFlags.ButtonCtrl | MouseFlags.ButtonShift;
                            break;
                        case 24:
                        case 25:
                        case 26:
                        case 59:
                            buttonState |= MouseFlags.ButtonCtrl | MouseFlags.ButtonAlt;
                            break;
                        case 30:
                        case 63:
                            buttonState |= MouseFlags.ButtonCtrl | MouseFlags.ButtonShift | MouseFlags.ButtonAlt;
                            break;
                        case 32:
                        case 33:
                        case 34:
                            buttonState |= MouseFlags.ReportMousePosition;
                            break;
                        case 36:
                        case 37:
                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonShift;
                            break;
                        case 39:
                        case 68:
                        case 69:
                            buttonState |= MouseFlags.ButtonShift;
                            break;
                        case 40:
                        case 41:
                        case 42:
                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonAlt;
                            break;
                        case 45:
                        case 46:
                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonAlt | MouseFlags.ButtonShift;
                            break;
                        case 48:
                        case 49:
                        case 50:
                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl;
                            break;
                        case 53:
                        case 54:
                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl | MouseFlags.ButtonShift;
                            break;
                        case 56:
                        case 57:
                        case 58:
                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl | MouseFlags.ButtonAlt;
                            break;
                        case 61:
                        case 62:
                            buttonState |= MouseFlags.ReportMousePosition | MouseFlags.ButtonCtrl | MouseFlags.ButtonShift | MouseFlags.ButtonAlt;
                            break;
                    }
                }
            }

            mouseFlags = new List<MouseFlags>() { MouseFlags.AllEvents };

            if (lastMouseButtonPressed != null && !isButtonPressed && !buttonState.HasFlag(MouseFlags.ReportMousePosition)
                && !buttonState.HasFlag(MouseFlags.Button1Released)
                && !buttonState.HasFlag(MouseFlags.Button2Released)
                && !buttonState.HasFlag(MouseFlags.Button3Released)
                && !buttonState.HasFlag(MouseFlags.Button4Released))
            {

                lastMouseButtonPressed = null;
                isButtonPressed = false;
            }

            if (!isButtonClicked && !isButtonDoubleClicked && ((buttonState == MouseFlags.Button1Pressed || buttonState == MouseFlags.Button2Pressed ||
                  buttonState == MouseFlags.Button3Pressed || buttonState == MouseFlags.Button4Pressed) && lastMouseButtonPressed == null) ||
                  isButtonPressed && lastMouseButtonPressed != null && buttonState.HasFlag(MouseFlags.ReportMousePosition))
            {

                mouseFlags[0] = buttonState;
                lastMouseButtonPressed = buttonState;
                isButtonPressed = true;

                if ((mouseFlags[0] & MouseFlags.ReportMousePosition) == 0)
                {
                    point = new Point()
                    {
                        X = pos.X,
                        Y = pos.Y
                    };

                    Application.MainLoop.AddIdle(() =>
                    {
                        Task.Run(async () => await ProcessContinuousButtonPressedAsync(buttonState, continuousButtonPressedHandler));
                        return false;
                    });
                }
                else if (mouseFlags[0] == MouseFlags.ReportMousePosition)
                {
                    isButtonPressed = false;
                }

            }
            else if (isButtonDoubleClicked && (buttonState == MouseFlags.Button1Pressed || buttonState == MouseFlags.Button2Pressed ||
              buttonState == MouseFlags.Button3Pressed || buttonState == MouseFlags.Button4Pressed))
            {

                mouseFlags[0] = GetButtonTripleClicked(buttonState);
                isButtonDoubleClicked = false;
                isButtonTripleClicked = true;

            }
            else if (isButtonClicked && (buttonState == MouseFlags.Button1Pressed || buttonState == MouseFlags.Button2Pressed ||
              buttonState == MouseFlags.Button3Pressed || buttonState == MouseFlags.Button4Pressed))
            {

                mouseFlags[0] = GetButtonDoubleClicked(buttonState);
                isButtonClicked = false;
                isButtonDoubleClicked = true;
                Application.MainLoop.AddIdle(() =>
                {
                    Task.Run(async () => await ProcessButtonDoubleClickedAsync());
                    return false;
                });

            }
            //else if (isButtonReleased && !isButtonClicked && buttonState == MouseFlags.ReportMousePosition) {
            //	mouseFlag [0] = GetButtonClicked ((MouseFlags)lastMouseButtonReleased);
            //	lastMouseButtonReleased = null;
            //	isButtonReleased = false;
            //	isButtonClicked = true;
            //	Application.MainLoop.AddIdle (() => {
            //		Task.Run (async () => await ProcessButtonClickedAsync ());
            //		return false;
            //	});

            //} 
            else if (!isButtonClicked && !isButtonDoubleClicked && (buttonState == MouseFlags.Button1Released || buttonState == MouseFlags.Button2Released ||
                  buttonState == MouseFlags.Button3Released || buttonState == MouseFlags.Button4Released))
            {

                mouseFlags[0] = buttonState;
                isButtonPressed = false;

                if (isButtonTripleClicked)
                {
                    isButtonTripleClicked = false;
                }
                else if (pos.X == point.X && pos.Y == point.Y)
                {
                    mouseFlags.Add(GetButtonClicked(buttonState));
                    isButtonClicked = true;
                    Application.MainLoop.AddIdle(() =>
                    {
                        Task.Run(async () => await ProcessButtonClickedAsync());
                        return false;
                    });
                }

                point = pos;

                //if ((lastMouseButtonPressed & MouseFlags.ReportMousePosition) == 0) {
                //	lastMouseButtonReleased = buttonState;
                //	isButtonPressed = false;
                //	isButtonReleased = true;
                //} else {
                //	lastMouseButtonPressed = null;
                //	isButtonPressed = false;
                //}

            }
            else if (buttonState == MouseFlags.WheeledUp)
            {

                mouseFlags[0] = MouseFlags.WheeledUp;

            }
            else if (buttonState == MouseFlags.WheeledDown)
            {

                mouseFlags[0] = MouseFlags.WheeledDown;

            }
            else if (buttonState == MouseFlags.WheeledLeft)
            {

                mouseFlags[0] = MouseFlags.WheeledLeft;

            }
            else if (buttonState == MouseFlags.WheeledRight)
            {

                mouseFlags[0] = MouseFlags.WheeledRight;

            }
            else if (buttonState == MouseFlags.ReportMousePosition)
            {
                mouseFlags[0] = MouseFlags.ReportMousePosition;

            }
            else
            {
                mouseFlags[0] = buttonState;
                //foreach (var flag in buttonState.GetUniqueFlags()) {
                //	mouseFlag [0] |= flag;
                //}
            }

            mouseFlags[0] = SetControlKeyStates(buttonState, mouseFlags[0]);
            //buttonState = mouseFlags;

            //System.Diagnostics.Debug.WriteLine ($"buttonState: {buttonState} X: {pos.X} Y: {pos.Y}");
            //foreach (var mf in mouseFlags) {
            //	System.Diagnostics.Debug.WriteLine ($"mouseFlags: {mf} X: {pos.X} Y: {pos.Y}");
            //}
        }

        private static async Task ProcessContinuousButtonPressedAsync(MouseFlags mouseFlag, Action<MouseFlags, Point> continuousButtonPressedHandler)
        {
            while (isButtonPressed)
            {
                await Task.Delay(100);
                //var me = new MouseEvent () {
                //	X = point.X,
                //	Y = point.Y,
                //	Flags = mouseFlag
                //};

                var view = Application.WantContinuousButtonPressedView;
                if (view == null)
                    break;
                if (isButtonPressed && lastMouseButtonPressed != null && (mouseFlag & MouseFlags.ReportMousePosition) == 0)
                {
                    Application.MainLoop.Invoke(() => continuousButtonPressedHandler(mouseFlag, point));
                }
            }
        }

        private static async Task ProcessButtonClickedAsync()
        {
            await Task.Delay(300);
            isButtonClicked = false;
        }

        private static async Task ProcessButtonDoubleClickedAsync()
        {
            await Task.Delay(300);
            isButtonDoubleClicked = false;
        }

        private static MouseFlags GetButtonClicked(MouseFlags mouseFlag)
        {
            MouseFlags mf = default;
            switch (mouseFlag)
            {
                case MouseFlags.Button1Released:
                    mf = MouseFlags.Button1Clicked;
                    break;

                case MouseFlags.Button2Released:
                    mf = MouseFlags.Button2Clicked;
                    break;

                case MouseFlags.Button3Released:
                    mf = MouseFlags.Button3Clicked;
                    break;
            }
            return mf;
        }

        private static MouseFlags GetButtonDoubleClicked(MouseFlags mouseFlag)
        {
            MouseFlags mf = default;
            switch (mouseFlag)
            {
                case MouseFlags.Button1Pressed:
                    mf = MouseFlags.Button1DoubleClicked;
                    break;

                case MouseFlags.Button2Pressed:
                    mf = MouseFlags.Button2DoubleClicked;
                    break;

                case MouseFlags.Button3Pressed:
                    mf = MouseFlags.Button3DoubleClicked;
                    break;
            }
            return mf;
        }

        private static MouseFlags GetButtonTripleClicked(MouseFlags mouseFlag)
        {
            MouseFlags mf = default;
            switch (mouseFlag)
            {
                case MouseFlags.Button1Pressed:
                    mf = MouseFlags.Button1TripleClicked;
                    break;

                case MouseFlags.Button2Pressed:
                    mf = MouseFlags.Button2TripleClicked;
                    break;

                case MouseFlags.Button3Pressed:
                    mf = MouseFlags.Button3TripleClicked;
                    break;
            }
            return mf;
        }

        private static MouseFlags SetControlKeyStates(MouseFlags buttonState, MouseFlags mouseFlag)
        {
            if ((buttonState & MouseFlags.ButtonCtrl) != 0 && (mouseFlag & MouseFlags.ButtonCtrl) == 0)
                mouseFlag |= MouseFlags.ButtonCtrl;

            if ((buttonState & MouseFlags.ButtonShift) != 0 && (mouseFlag & MouseFlags.ButtonShift) == 0)
                mouseFlag |= MouseFlags.ButtonShift;

            if ((buttonState & MouseFlags.ButtonAlt) != 0 && (mouseFlag & MouseFlags.ButtonAlt) == 0)
                mouseFlag |= MouseFlags.ButtonAlt;
            return mouseFlag;
        }

        /// <summary>
        /// Get the terminal that holds the console driver.
        /// </summary>
        /// <param name="process">The process.</param>
        /// <returns>If supported the executable console process, null otherwise.</returns>
        public static Process GetParentProcess(Process process)
        {
            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                return null;
            }

            string query = "SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = " + process.Id;
            using (ManagementObjectSearcher mos = new ManagementObjectSearcher(query))
            {
                foreach (ManagementObject mo in mos.Get())
                {
                    if (mo["ParentProcessId"] != null)
                    {
                        try
                        {
                            var id = Convert.ToInt32(mo["ParentProcessId"]);
                            return Process.GetProcessById(id);
                        }
                        catch
                        {
                        }
                    }
                }
            }
            return null;
        }
    }
    //=======================================================================
    //
    // Evemts.cs: Events, Key mappings
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    /// Identifies the state of the "shift"-keys within a event.
    /// </summary>
    public class KeyModifiers
    {
        /// <summary>
        /// Check if the Shift key was pressed or not.
        /// </summary>
        public bool Shift;
        /// <summary>
        /// Check if the Alt key was pressed or not.
        /// </summary>
        public bool Alt;
        /// <summary>
        /// Check if the Ctrl key was pressed or not.
        /// </summary>
        public bool Ctrl;
        /// <summary>
        /// Check if the Caps lock key was pressed or not.
        /// </summary>
        public bool Capslock;
        /// <summary>
        /// Check if the Num lock key was pressed or not.
        /// </summary>
        public bool Numlock;
        /// <summary>
        /// Check if the Scroll lock key was pressed or not.
        /// </summary>
        public bool Scrolllock;
    }

    /// <summary>
    /// The <see cref="Key"/> enumeration contains special encoding for some keys, but can also
    /// encode all the unicode values that can be passed.   
    /// </summary>
    /// <remarks>
    /// <para>
    ///   If the <see cref="SpecialMask"/> is set, then the value is that of the special mask,
    ///   otherwise, the value is the one of the lower bits (as extracted by <see cref="CharMask"/>)
    /// <para>
    ///   Numerics keys are the values between 48 and 57 corresponding to 0 to 9
    /// </para>
    /// </para>
    /// <para>
    ///   Upper alpha keys are the values between 65 and 90 corresponding to A to Z
    /// </para>
    /// <para>
    ///   Unicode runes are also stored here, the letter 'A" for example is encoded as a value 65 (not surfaced in the enum).
    /// </para>
    /// </remarks>
    [Flags]
    public enum Key : uint
    {
        /// <summary>
        /// Mask that indicates that this is a character value, values outside this range
        /// indicate special characters like Alt-key combinations or special keys on the
        /// keyboard like function keys, arrows keys and so on.
        /// </summary>
        CharMask = 0xfffff,

        /// <summary>
        /// If the <see cref="SpecialMask"/> is set, then the value is that of the special mask,
        /// otherwise, the value is the one of the lower bits (as extracted by <see cref="CharMask"/>).
        /// </summary>
        SpecialMask = 0xfff00000,

        /// <summary>
        /// The key code representing null or empty
        /// </summary>
        Null = '\0',

        /// <summary>
        /// Backspace key.
        /// </summary>
        Backspace = 8,

        /// <summary>
        /// The key code for the user pressing the tab key (forwards tab key).
        /// </summary>
        Tab = 9,

        /// <summary>
        /// The key code for the user pressing the return key.
        /// </summary>
        Enter = '\n',

        /// <summary>
        /// The key code for the user pressing the clear key.
        /// </summary>
        Clear = 12,

        /// <summary>
        /// The key code for the user pressing the escape key
        /// </summary>
        Esc = 27,

        /// <summary>
        /// The key code for the user pressing the space bar
        /// </summary>
        Space = 32,

        /// <summary>
        /// Digit 0.
        /// </summary>
        D0 = 48,
        /// <summary>
        /// Digit 1.
        /// </summary>
        D1,
        /// <summary>
        /// Digit 2.
        /// </summary>
        D2,
        /// <summary>
        /// Digit 3.
        /// </summary>
        D3,
        /// <summary>
        /// Digit 4.
        /// </summary>
        D4,
        /// <summary>
        /// Digit 5.
        /// </summary>
        D5,
        /// <summary>
        /// Digit 6.
        /// </summary>
        D6,
        /// <summary>
        /// Digit 7.
        /// </summary>
        D7,
        /// <summary>
        /// Digit 8.
        /// </summary>
        D8,
        /// <summary>
        /// Digit 9.
        /// </summary>
        D9,

        /// <summary>
        /// The key code for the user pressing Shift-A
        /// </summary>
        A = 65,
        /// <summary>
        /// The key code for the user pressing Shift-B
        /// </summary>
        B,
        /// <summary>
        /// The key code for the user pressing Shift-C
        /// </summary>
        C,
        /// <summary>
        /// The key code for the user pressing Shift-D
        /// </summary>
        D,
        /// <summary>
        /// The key code for the user pressing Shift-E
        /// </summary>
        E,
        /// <summary>
        /// The key code for the user pressing Shift-F
        /// </summary>
        F,
        /// <summary>
        /// The key code for the user pressing Shift-G
        /// </summary>
        G,
        /// <summary>
        /// The key code for the user pressing Shift-H
        /// </summary>
        H,
        /// <summary>
        /// The key code for the user pressing Shift-I
        /// </summary>
        I,
        /// <summary>
        /// The key code for the user pressing Shift-J
        /// </summary>
        J,
        /// <summary>
        /// The key code for the user pressing Shift-K
        /// </summary>
        K,
        /// <summary>
        /// The key code for the user pressing Shift-L
        /// </summary>
        L,
        /// <summary>
        /// The key code for the user pressing Shift-M
        /// </summary>
        M,
        /// <summary>
        /// The key code for the user pressing Shift-N
        /// </summary>
        N,
        /// <summary>
        /// The key code for the user pressing Shift-O
        /// </summary>
        O,
        /// <summary>
        /// The key code for the user pressing Shift-P
        /// </summary>
        P,
        /// <summary>
        /// The key code for the user pressing Shift-Q
        /// </summary>
        Q,
        /// <summary>
        /// The key code for the user pressing Shift-R
        /// </summary>
        R,
        /// <summary>
        /// The key code for the user pressing Shift-S
        /// </summary>
        S,
        /// <summary>
        /// The key code for the user pressing Shift-T
        /// </summary>
        T,
        /// <summary>
        /// The key code for the user pressing Shift-U
        /// </summary>
        U,
        /// <summary>
        /// The key code for the user pressing Shift-V
        /// </summary>
        V,
        /// <summary>
        /// The key code for the user pressing Shift-W
        /// </summary>
        W,
        /// <summary>
        /// The key code for the user pressing Shift-X
        /// </summary>
        X,
        /// <summary>
        /// The key code for the user pressing Shift-Y
        /// </summary>
        Y,
        /// <summary>
        /// The key code for the user pressing Shift-Z
        /// </summary>
        Z,
        /// <summary>
        /// The key code for the user pressing A
        /// </summary>
        a = 97,
        /// <summary>
        /// The key code for the user pressing B
        /// </summary>
        b,
        /// <summary>
        /// The key code for the user pressing C
        /// </summary>
        c,
        /// <summary>
        /// The key code for the user pressing D
        /// </summary>
        d,
        /// <summary>
        /// The key code for the user pressing E
        /// </summary>
        e,
        /// <summary>
        /// The key code for the user pressing F
        /// </summary>
        f,
        /// <summary>
        /// The key code for the user pressing G
        /// </summary>
        g,
        /// <summary>
        /// The key code for the user pressing H
        /// </summary>
        h,
        /// <summary>
        /// The key code for the user pressing I
        /// </summary>
        i,
        /// <summary>
        /// The key code for the user pressing J
        /// </summary>
        j,
        /// <summary>
        /// The key code for the user pressing K
        /// </summary>
        k,
        /// <summary>
        /// The key code for the user pressing L
        /// </summary>
        l,
        /// <summary>
        /// The key code for the user pressing M
        /// </summary>
        m,
        /// <summary>
        /// The key code for the user pressing N
        /// </summary>
        n,
        /// <summary>
        /// The key code for the user pressing O
        /// </summary>
        o,
        /// <summary>
        /// The key code for the user pressing P
        /// </summary>
        p,
        /// <summary>
        /// The key code for the user pressing Q
        /// </summary>
        q,
        /// <summary>
        /// The key code for the user pressing R
        /// </summary>
        r,
        /// <summary>
        /// The key code for the user pressing S
        /// </summary>
        s,
        /// <summary>
        /// The key code for the user pressing T
        /// </summary>
        t,
        /// <summary>
        /// The key code for the user pressing U
        /// </summary>
        u,
        /// <summary>
        /// The key code for the user pressing V
        /// </summary>
        v,
        /// <summary>
        /// The key code for the user pressing W
        /// </summary>
        w,
        /// <summary>
        /// The key code for the user pressing X
        /// </summary>
        x,
        /// <summary>
        /// The key code for the user pressing Y
        /// </summary>
        y,
        /// <summary>
        /// The key code for the user pressing Z
        /// </summary>
        z,
        /// <summary>
        /// The key code for the user pressing the delete key.
        /// </summary>
        Delete = 127,

        /// <summary>
        /// When this value is set, the Key encodes the sequence Shift-KeyValue.
        /// </summary>
        ShiftMask = 0x10000000,

        /// <summary>
        ///   When this value is set, the Key encodes the sequence Alt-KeyValue.
        ///   And the actual value must be extracted by removing the AltMask.
        /// </summary>
        AltMask = 0x80000000,

        /// <summary>
        ///   When this value is set, the Key encodes the sequence Ctrl-KeyValue.
        ///   And the actual value must be extracted by removing the CtrlMask.
        /// </summary>
        CtrlMask = 0x40000000,

        /// <summary>
        /// Cursor up key
        /// </summary>
        CursorUp = 0x100000,
        /// <summary>
        /// Cursor down key.
        /// </summary>
        CursorDown,
        /// <summary>
        /// Cursor left key.
        /// </summary>
        CursorLeft,
        /// <summary>
        /// Cursor right key.
        /// </summary>
        CursorRight,
        /// <summary>
        /// Page Up key.
        /// </summary>
        PageUp,
        /// <summary>
        /// Page Down key.
        /// </summary>
        PageDown,
        /// <summary>
        /// Home key.
        /// </summary>
        Home,
        /// <summary>
        /// End key.
        /// </summary>
        End,

        /// <summary>
        /// Insert character key.
        /// </summary>
        InsertChar,

        /// <summary>
        /// Delete character key.
        /// </summary>
        DeleteChar,

        /// <summary>
        /// Shift-tab key (backwards tab key).
        /// </summary>
        BackTab,

        /// <summary>
        /// Print screen character key.
        /// </summary>
        PrintScreen,

        /// <summary>
        /// F1 key.
        /// </summary>
        F1,
        /// <summary>
        /// F2 key.
        /// </summary>
        F2,
        /// <summary>
        /// F3 key.
        /// </summary>
        F3,
        /// <summary>
        /// F4 key.
        /// </summary>
        F4,
        /// <summary>
        /// F5 key.
        /// </summary>
        F5,
        /// <summary>
        /// F6 key.
        /// </summary>
        F6,
        /// <summary>
        /// F7 key.
        /// </summary>
        F7,
        /// <summary>
        /// F8 key.
        /// </summary>
        F8,
        /// <summary>
        /// F9 key.
        /// </summary>
        F9,
        /// <summary>
        /// F10 key.
        /// </summary>
        F10,
        /// <summary>
        /// F11 key.
        /// </summary>
        F11,
        /// <summary>
        /// F12 key.
        /// </summary>
        F12,
        /// <summary>
        /// F13 key.
        /// </summary>
        F13,
        /// <summary>
        /// F14 key.
        /// </summary>
        F14,
        /// <summary>
        /// F15 key.
        /// </summary>
        F15,
        /// <summary>
        /// F16 key.
        /// </summary>
        F16,
        /// <summary>
        /// F17 key.
        /// </summary>
        F17,
        /// <summary>
        /// F18 key.
        /// </summary>
        F18,
        /// <summary>
        /// F19 key.
        /// </summary>
        F19,
        /// <summary>
        /// F20 key.
        /// </summary>
        F20,
        /// <summary>
        /// F21 key.
        /// </summary>
        F21,
        /// <summary>
        /// F22 key.
        /// </summary>
        F22,
        /// <summary>
        /// F23 key.
        /// </summary>
        F23,
        /// <summary>
        /// F24 key.
        /// </summary>
        F24,

        /// <summary>
        /// A key with an unknown mapping was raised.
        /// </summary>
        Unknown
    }

    /// <summary>
    /// Describes a keyboard event.
    /// </summary>
    public class KeyEvent
    {
        KeyModifiers keyModifiers;

        /// <summary>
        /// Symbolic definition for the key.
        /// </summary>
        public Key Key;

        /// <summary>
        ///   The key value cast to an integer, you will typical use this for
        ///   extracting the Unicode rune value out of a key, when none of the
        ///   symbolic options are in use.
        /// </summary>
        public int KeyValue => (int)Key;

        /// <summary>
        /// Gets a value indicating whether the Shift key was pressed.
        /// </summary>
        /// <value><c>true</c> if is shift; otherwise, <c>false</c>.</value>
        public bool IsShift => keyModifiers.Shift || Key == Key.BackTab;

        /// <summary>
        /// Gets a value indicating whether the Alt key was pressed (real or synthesized)
        /// </summary>
        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
        public bool IsAlt => keyModifiers.Alt;

        /// <summary>
        /// Determines whether the value is a control key (and NOT just the ctrl key)
        /// </summary>
        /// <value><c>true</c> if is ctrl; otherwise, <c>false</c>.</value>
        //public bool IsCtrl => ((uint)Key >= 1) && ((uint)Key <= 26);
        public bool IsCtrl => keyModifiers.Ctrl;

        /// <summary>
        /// Gets a value indicating whether the Caps lock key was pressed (real or synthesized)
        /// </summary>
        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
        public bool IsCapslock => keyModifiers.Capslock;

        /// <summary>
        /// Gets a value indicating whether the Num lock key was pressed (real or synthesized)
        /// </summary>
        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
        public bool IsNumlock => keyModifiers.Numlock;

        /// <summary>
        /// Gets a value indicating whether the Scroll lock key was pressed (real or synthesized)
        /// </summary>
        /// <value><c>true</c> if is alternate; otherwise, <c>false</c>.</value>
        public bool IsScrolllock => keyModifiers.Scrolllock;

        /// <summary>
        /// Constructs a new <see cref="KeyEvent"/>
        /// </summary>
        public KeyEvent()
        {
            Key = Key.Unknown;
            keyModifiers = new KeyModifiers();
        }

        /// <summary>
        ///   Constructs a new <see cref="KeyEvent"/> from the provided Key value - can be a rune cast into a Key value
        /// </summary>
        public KeyEvent(Key k, KeyModifiers km)
        {
            Key = k;
            keyModifiers = km;
        }

        /// <summary>
        /// Pretty prints the KeyEvent
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            string msg = "";
            var key = this.Key;
            if (keyModifiers.Shift)
            {
                msg += "Shift-";
            }
            if (keyModifiers.Alt)
            {
                msg += "Alt-";
            }
            if (keyModifiers.Ctrl)
            {
                msg += "Ctrl-";
            }
            if (keyModifiers.Capslock)
            {
                msg += "Capslock-";
            }
            if (keyModifiers.Numlock)
            {
                msg += "Numlock-";
            }
            if (keyModifiers.Scrolllock)
            {
                msg += "Scrolllock-";
            }

            msg += $"{((Key)KeyValue != Key.Unknown && ((uint)this.KeyValue & (uint)Key.CharMask) > 27 ? $"{(char)this.KeyValue}" : $"{key}")}";

            return msg;
        }
    }

    /// <summary>
    /// Mouse flags reported in <see cref="MouseEvent"/>.
    /// </summary>
    /// <remarks>
    /// They just happen to map to the ncurses ones.
    /// </remarks>
    [Flags]
    public enum MouseFlags
    {
        /// <summary>
        /// The first mouse button was pressed.
        /// </summary>
        Button1Pressed = unchecked((int)0x2),
        /// <summary>
        /// The first mouse button was released.
        /// </summary>
        Button1Released = unchecked((int)0x1),
        /// <summary>
        /// The first mouse button was clicked (press+release).
        /// </summary>
        Button1Clicked = unchecked((int)0x4),
        /// <summary>
        /// The first mouse button was double-clicked.
        /// </summary>
        Button1DoubleClicked = unchecked((int)0x8),
        /// <summary>
        /// The first mouse button was triple-clicked.
        /// </summary>
        Button1TripleClicked = unchecked((int)0x10),
        /// <summary>
        /// The second mouse button was pressed.
        /// </summary>
        Button2Pressed = unchecked((int)0x80),
        /// <summary>
        /// The second mouse button was released.
        /// </summary>
        Button2Released = unchecked((int)0x40),
        /// <summary>
        /// The second mouse button was clicked (press+release).
        /// </summary>
        Button2Clicked = unchecked((int)0x100),
        /// <summary>
        /// The second mouse button was double-clicked.
        /// </summary>
        Button2DoubleClicked = unchecked((int)0x200),
        /// <summary>
        /// The second mouse button was triple-clicked.
        /// </summary>
        Button2TripleClicked = unchecked((int)0x400),
        /// <summary>
        /// The third mouse button was pressed.
        /// </summary>
        Button3Pressed = unchecked((int)0x2000),
        /// <summary>
        /// The third mouse button was released.
        /// </summary>
        Button3Released = unchecked((int)0x1000),
        /// <summary>
        /// The third mouse button was clicked (press+release).
        /// </summary>
        Button3Clicked = unchecked((int)0x4000),
        /// <summary>
        /// The third mouse button was double-clicked.
        /// </summary>
        Button3DoubleClicked = unchecked((int)0x8000),
        /// <summary>
        /// The third mouse button was triple-clicked.
        /// </summary>
        Button3TripleClicked = unchecked((int)0x10000),
        /// <summary>
        /// The fourth mouse button was pressed.
        /// </summary>
        Button4Pressed = unchecked((int)0x80000),
        /// <summary>
        /// The fourth mouse button was released.
        /// </summary>
        Button4Released = unchecked((int)0x40000),
        /// <summary>
        /// The fourth button was clicked (press+release).
        /// </summary>
        Button4Clicked = unchecked((int)0x100000),
        /// <summary>
        /// The fourth button was double-clicked.
        /// </summary>
        Button4DoubleClicked = unchecked((int)0x200000),
        /// <summary>
        /// The fourth button was triple-clicked.
        /// </summary>
        Button4TripleClicked = unchecked((int)0x400000),
        /// <summary>
        /// Flag: the shift key was pressed when the mouse button took place.
        /// </summary>
        ButtonShift = unchecked((int)0x2000000),
        /// <summary>
        /// Flag: the ctrl key was pressed when the mouse button took place.
        /// </summary>
        ButtonCtrl = unchecked((int)0x1000000),
        /// <summary>
        /// Flag: the alt key was pressed when the mouse button took place.
        /// </summary>
        ButtonAlt = unchecked((int)0x4000000),
        /// <summary>
        /// The mouse position is being reported in this event.
        /// </summary>
        ReportMousePosition = unchecked((int)0x8000000),
        /// <summary>
        /// Vertical button wheeled up.
        /// </summary>
        WheeledUp = unchecked((int)0x10000000),
        /// <summary>
        /// Vertical button wheeled down.
        /// </summary>
        WheeledDown = unchecked((int)0x20000000),
        /// <summary>
        /// Vertical button wheeled up while pressing ButtonCtrl.
        /// </summary>
        WheeledLeft = ButtonCtrl | WheeledUp,
        /// <summary>
        /// Vertical button wheeled down while pressing ButtonCtrl.
        /// </summary>
        WheeledRight = ButtonCtrl | WheeledDown,
        /// <summary>
        /// Mask that captures all the events.
        /// </summary>
        AllEvents = unchecked((int)0x7ffffff),
    }

    /// <summary>
    /// Low-level construct that conveys the details of mouse events, such
    /// as coordinates and button state, from ConsoleDrivers up to <see cref="Application"/> and
    /// Views.
    /// </summary>
    /// <remarks>The <see cref="Application"/> class includes the <see cref="Application.RootMouseEvent"/>
    /// Action which takes a MouseEvent argument.</remarks>
    public class MouseEvent
    {
        /// <summary>
        /// The X (column) location for the mouse event.
        /// </summary>
        public int X { get; set; }

        /// <summary>
        /// The Y (column) location for the mouse event.
        /// </summary>
        public int Y { get; set; }

        /// <summary>
        /// Flags indicating the kind of mouse event that is being posted.
        /// </summary>
        public MouseFlags Flags { get; set; }

        /// <summary>
        /// The offset X (column) location for the mouse event.
        /// </summary>
        public int OfX { get; set; }

        /// <summary>
        /// The offset Y (column) location for the mouse event.
        /// </summary>
        public int OfY { get; set; }

        /// <summary>
        /// The current view at the location for the mouse event.
        /// </summary>
        public View View { get; set; }

        /// <summary>
        /// Indicates if the current mouse event has already been processed and the driver should stop notifying any other event subscriber.
        /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
        /// </summary>
        public bool Handled { get; set; }

        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="MouseEvent"/>.
        /// </summary>
        /// <returns>A <see cref="T:System.String"/> that represents the current <see cref="MouseEvent"/>.</returns>
        public override string ToString()
        {
            return $"({X},{Y}:{Flags}";
        }
    }
    //=======================================================================
    //
    // FakeConsole.cs: A fake .NET Windows Console API implementation for unit tests.
    //

#pragma warning disable RCS1138 // Add summary to documentation comment.
    /// <summary>
    /// 
    /// </summary>
    public static class FakeConsole
    {
#pragma warning restore RCS1138 // Add summary to documentation comment.

        //
        // Summary:
        //	Gets or sets the width of the console window.
        //
        // Returns:
        //	The width of the console window measured in columns.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight
        //	property is less than or equal to 0.-or-The value of the System.Console.WindowHeight
        //	property plus the value of the System.Console.WindowTop property is greater than
        //	or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth
        //	property or the value of the System.Console.WindowHeight property is greater
        //	than the largest possible window width or height for the current screen resolution
        //	and console font.
        //
        //	T:System.IO.IOException:
        //	Error reading or writing information.
#pragma warning disable RCS1138 // Add summary to documentation comment.

        /// <summary>
        /// Specifies the initial console width.
        /// </summary>
        public const int WIDTH = 80;

        /// <summary>
        /// Specifies the initial console height.
        /// </summary>
        public const int HEIGHT = 25;

        /// <summary>
        /// 
        /// </summary>
        public static int WindowWidth { get; set; } = WIDTH;
        //
        // Summary:
        //	Gets a value that indicates whether output has been redirected from the standard
        //	output stream.
        //
        // Returns:
        //	true if output is redirected; otherwise, false.
        /// <summary>
        /// 
        /// </summary>
        public static bool IsOutputRedirected { get; }
        //
        // Summary:
        //	Gets a value that indicates whether the error output stream has been redirected
        //	from the standard error stream.
        //
        // Returns:
        //	true if error output is redirected; otherwise, false.
        /// <summary>
        /// 
        /// </summary>
        public static bool IsErrorRedirected { get; }
        //
        // Summary:
        //	Gets the standard input stream.
        //
        // Returns:
        //	A System.IO.TextReader that represents the standard input stream.
        /// <summary>
        /// 
        /// </summary>
        public static TextReader In { get; }
        //
        // Summary:
        //	Gets the standard output stream.
        //
        // Returns:
        //	A System.IO.TextWriter that represents the standard output stream.
        /// <summary>
        /// 
        /// </summary>
        public static TextWriter Out { get; }
        //
        // Summary:
        //	Gets the standard error output stream.
        //
        // Returns:
        //	A System.IO.TextWriter that represents the standard error output stream.
        /// <summary>
        /// 
        /// </summary>
        public static TextWriter Error { get; }
        //
        // Summary:
        //	Gets or sets the encoding the console uses to read input.
        //
        // Returns:
        //	The encoding used to read console input.
        //
        // Exceptions:
        //	T:System.ArgumentNullException:
        //	The property value in a set operation is null.
        //
        //	T:System.IO.IOException:
        //	An error occurred during the execution of this operation.
        //
        //	T:System.Security.SecurityException:
        //	Your application does not have permission to perform this operation.
        /// <summary>
        /// 
        /// </summary>
        public static Encoding InputEncoding { get; set; }
        //
        // Summary:
        //	Gets or sets the encoding the console uses to write output.
        //
        // Returns:
        //	The encoding used to write console output.
        //
        // Exceptions:
        //	T:System.ArgumentNullException:
        //	The property value in a set operation is null.
        //
        //	T:System.IO.IOException:
        //	An error occurred during the execution of this operation.
        //
        //	T:System.Security.SecurityException:
        //	Your application does not have permission to perform this operation.
        /// <summary>
        /// 
        /// </summary>
        public static Encoding OutputEncoding { get; set; }
        //
        // Summary:
        //	Gets or sets the background color of the console.
        //
        // Returns:
        //	A value that specifies the background color of the console; that is, the color
        //	that appears behind each character. The default is black.
        //
        // Exceptions:
        //	T:System.ArgumentException:
        //	The color specified in a set operation is not a valid member of System.ConsoleColor.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.

        static ConsoleColor _defaultBackgroundColor = ConsoleColor.Black;

        /// <summary>
        /// 
        /// </summary>
        public static ConsoleColor BackgroundColor { get; set; } = _defaultBackgroundColor;

        //
        // Summary:
        //	Gets or sets the foreground color of the console.
        //
        // Returns:
        //	A System.ConsoleColor that specifies the foreground color of the console; that
        //	is, the color of each character that is displayed. The default is gray.
        //
        // Exceptions:
        //	T:System.ArgumentException:
        //	The color specified in a set operation is not a valid member of System.ConsoleColor.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.

        static ConsoleColor _defaultForegroundColor = ConsoleColor.Gray;

        /// <summary>
        /// 
        /// </summary>
        public static ConsoleColor ForegroundColor { get; set; } = _defaultForegroundColor;
        //
        // Summary:
        //	Gets or sets the height of the buffer area.
        //
        // Returns:
        //	The current height, in rows, of the buffer area.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	The value in a set operation is less than or equal to zero.-or- The value in
        //	a set operation is greater than or equal to System.Int16.MaxValue.-or- The value
        //	in a set operation is less than System.Console.WindowTop + System.Console.WindowHeight.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static int BufferHeight { get; set; } = HEIGHT;
        //
        // Summary:
        //	Gets or sets the width of the buffer area.
        //
        // Returns:
        //	The current width, in columns, of the buffer area.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	The value in a set operation is less than or equal to zero.-or- The value in
        //	a set operation is greater than or equal to System.Int16.MaxValue.-or- The value
        //	in a set operation is less than System.Console.WindowLeft + System.Console.WindowWidth.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static int BufferWidth { get; set; } = WIDTH;
        //
        // Summary:
        //	Gets or sets the height of the console window area.
        //
        // Returns:
        //	The height of the console window measured in rows.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight
        //	property is less than or equal to 0.-or-The value of the System.Console.WindowHeight
        //	property plus the value of the System.Console.WindowTop property is greater than
        //	or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth
        //	property or the value of the System.Console.WindowHeight property is greater
        //	than the largest possible window width or height for the current screen resolution
        //	and console font.
        //
        //	T:System.IO.IOException:
        //	Error reading or writing information.
        /// <summary>
        /// 
        /// </summary>
        public static int WindowHeight { get; set; } = HEIGHT;
        //
        // Summary:
        //	Gets or sets a value indicating whether the combination of the System.ConsoleModifiers.Control
        //	modifier key and System.ConsoleKey.C console key (Ctrl+C) is treated as ordinary
        //	input or as an interruption that is handled by the operating system.
        //
        // Returns:
        //	true if Ctrl+C is treated as ordinary input; otherwise, false.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	Unable to get or set the input mode of the console input buffer.
        /// <summary>
        /// 
        /// </summary>
        public static bool TreatControlCAsInput { get; set; }
        //
        // Summary:
        //	Gets the largest possible number of console window columns, based on the current
        //	font and screen resolution.
        //
        // Returns:
        //	The width of the largest possible console window measured in columns.
        /// <summary>
        /// 
        /// </summary>
        public static int LargestWindowWidth { get; }
        //
        // Summary:
        //	Gets the largest possible number of console window rows, based on the current
        //	font and screen resolution.
        //
        // Returns:
        //	The height of the largest possible console window measured in rows.
        /// <summary>
        /// 
        /// </summary>
        public static int LargestWindowHeight { get; }
        //
        // Summary:
        //	Gets or sets the leftmost position of the console window area relative to the
        //	screen buffer.
        //
        // Returns:
        //	The leftmost console window position measured in columns.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	In a set operation, the value to be assigned is less than zero.-or-As a result
        //	of the assignment, System.Console.WindowLeft plus System.Console.WindowWidth
        //	would exceed System.Console.BufferWidth.
        //
        //	T:System.IO.IOException:
        //	Error reading or writing information.
        /// <summary>
        /// 
        /// </summary>
        public static int WindowLeft { get; set; }
        //
        // Summary:
        //	Gets or sets the top position of the console window area relative to the screen
        //	buffer.
        //
        // Returns:
        //	The uppermost console window position measured in rows.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	In a set operation, the value to be assigned is less than zero.-or-As a result
        //	of the assignment, System.Console.WindowTop plus System.Console.WindowHeight
        //	would exceed System.Console.BufferHeight.
        //
        //	T:System.IO.IOException:
        //	Error reading or writing information.
        /// <summary>
        /// 
        /// </summary>
        public static int WindowTop { get; set; }
        //
        // Summary:
        //	Gets or sets the column position of the cursor within the buffer area.
        //
        // Returns:
        //	The current position, in columns, of the cursor.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	The value in a set operation is less than zero.-or- The value in a set operation
        //	is greater than or equal to System.Console.BufferWidth.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static int CursorLeft { get; set; }
        //
        // Summary:
        //	Gets or sets the row position of the cursor within the buffer area.
        //
        // Returns:
        //	The current position, in rows, of the cursor.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	The value in a set operation is less than zero.-or- The value in a set operation
        //	is greater than or equal to System.Console.BufferHeight.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static int CursorTop { get; set; }
        //
        // Summary:
        //	Gets or sets the height of the cursor within a character cell.
        //
        // Returns:
        //	The size of the cursor expressed as a percentage of the height of a character
        //	cell. The property value ranges from 1 to 100.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	The value specified in a set operation is less than 1 or greater than 100.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static int CursorSize { get; set; }
        //
        // Summary:
        //	Gets or sets a value indicating whether the cursor is visible.
        //
        // Returns:
        //	true if the cursor is visible; otherwise, false.
        //
        // Exceptions:
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static bool CursorVisible { get; set; }
        //
        // Summary:
        //	Gets or sets the title to display in the console title bar.
        //
        // Returns:
        //	The string to be displayed in the title bar of the console. The maximum length
        //	of the title string is 24500 characters.
        //
        // Exceptions:
        //	T:System.InvalidOperationException:
        //	In a get operation, the retrieved title is longer than 24500 characters.
        //
        //	T:System.ArgumentOutOfRangeException:
        //	In a set operation, the specified title is longer than 24500 characters.
        //
        //	T:System.ArgumentNullException:
        //	In a set operation, the specified title is null.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static string Title { get; set; }
        //
        // Summary:
        //	Gets a value indicating whether a key press is available in the input stream.
        //
        // Returns:
        //	true if a key press is available; otherwise, false.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.InvalidOperationException:
        //	Standard input is redirected to a file instead of the keyboard.
        /// <summary>
        /// 
        /// </summary>
        public static bool KeyAvailable { get; }
        //
        // Summary:
        //	Gets a value indicating whether the NUM LOCK keyboard toggle is turned on or
        //	turned off.
        //
        // Returns:
        //	true if NUM LOCK is turned on; false if NUM LOCK is turned off.
        /// <summary>
        /// 
        /// </summary>
        public static bool NumberLock { get; }
        //
        // Summary:
        //	Gets a value indicating whether the CAPS LOCK keyboard toggle is turned on or
        //	turned off.
        //
        // Returns:
        //	true if CAPS LOCK is turned on; false if CAPS LOCK is turned off.
        /// <summary>
        /// 
        /// </summary>
        public static bool CapsLock { get; }
        //
        // Summary:
        //	Gets a value that indicates whether input has been redirected from the standard
        //	input stream.
        //
        // Returns:
        //	true if input is redirected; otherwise, false.
        /// <summary>
        /// 
        /// </summary>
        public static bool IsInputRedirected { get; }

        //
        // Summary:
        //	Plays the sound of a beep through the console speaker.
        //
        // Exceptions:
        //	T:System.Security.HostProtectionException:
        //	This method was executed on a server, such as SQL Server, that does not permit
        //	access to a user interface.
        /// <summary>
        /// 
        /// </summary>
        public static void Beep()
        {
            throw new NotImplementedException();
        }
        //
        // Summary:
        //	Plays the sound of a beep of a specified frequency and duration through the console
        //	speaker.
        //
        // Parameters:
        //	frequency:
        //	The frequency of the beep, ranging from 37 to 32767 hertz.
        //
        //	duration:
        //	The duration of the beep measured in milliseconds.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	frequency is less than 37 or more than 32767 hertz.-or- duration is less than
        //	or equal to zero.
        //
        //	T:System.Security.HostProtectionException:
        //	This method was executed on a server, such as SQL Server, that does not permit
        //	access to the console.
        /// <summary>
        /// 
        /// </summary>
        public static void Beep(int frequency, int duration)
        {
            throw new NotImplementedException();
        }
        //
        // Summary:
        //	Clears the console buffer and corresponding console window of display information.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.

        static char[,] _buffer = new char[WindowWidth, WindowHeight];

        /// <summary>
        /// 
        /// </summary>
        public static void Clear()
        {
            _buffer = new char[BufferWidth, BufferHeight];
            SetCursorPosition(0, 0);
        }

        //
        // Summary:
        //	Copies a specified source area of the screen buffer to a specified destination
        //	area.
        //
        // Parameters:
        //	sourceLeft:
        //	The leftmost column of the source area.
        //
        //	sourceTop:
        //	The topmost row of the source area.
        //
        //	sourceWidth:
        //	The number of columns in the source area.
        //
        //	sourceHeight:
        //	The number of rows in the source area.
        //
        //	targetLeft:
        //	The leftmost column of the destination area.
        //
        //	targetTop:
        //	The topmost row of the destination area.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	One or more of the parameters is less than zero.-or- sourceLeft or targetLeft
        //	is greater than or equal to System.Console.BufferWidth.-or- sourceTop or targetTop
        //	is greater than or equal to System.Console.BufferHeight.-or- sourceTop + sourceHeight
        //	is greater than or equal to System.Console.BufferHeight.-or- sourceLeft + sourceWidth
        //	is greater than or equal to System.Console.BufferWidth.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Copies a specified source area of the screen buffer to a specified destination
        //	area.
        //
        // Parameters:
        //	sourceLeft:
        //	The leftmost column of the source area.
        //
        //	sourceTop:
        //	The topmost row of the source area.
        //
        //	sourceWidth:
        //	The number of columns in the source area.
        //
        //	sourceHeight:
        //	The number of rows in the source area.
        //
        //	targetLeft:
        //	The leftmost column of the destination area.
        //
        //	targetTop:
        //	The topmost row of the destination area.
        //
        //	sourceChar:
        //	The character used to fill the source area.
        //
        //	sourceForeColor:
        //	The foreground color used to fill the source area.
        //
        //	sourceBackColor:
        //	The background color used to fill the source area.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	One or more of the parameters is less than zero.-or- sourceLeft or targetLeft
        //	is greater than or equal to System.Console.BufferWidth.-or- sourceTop or targetTop
        //	is greater than or equal to System.Console.BufferHeight.-or- sourceTop + sourceHeight
        //	is greater than or equal to System.Console.BufferHeight.-or- sourceLeft + sourceWidth
        //	is greater than or equal to System.Console.BufferWidth.
        //
        //	T:System.ArgumentException:
        //	One or both of the color parameters is not a member of the System.ConsoleColor
        //	enumeration.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Acquires the standard error stream.
        //
        // Returns:
        //	The standard error stream.
        /// <summary>
        /// 
        /// </summary>
        public static Stream OpenStandardError()
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Acquires the standard error stream, which is set to a specified buffer size.
        //
        // Parameters:
        //	bufferSize:
        //	The internal stream buffer size.
        //
        // Returns:
        //	The standard error stream.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	bufferSize is less than or equal to zero.
        /// <summary>
        /// 
        /// </summary>
        public static Stream OpenStandardError(int bufferSize)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Acquires the standard input stream, which is set to a specified buffer size.
        //
        // Parameters:
        //	bufferSize:
        //	The internal stream buffer size.
        //
        // Returns:
        //	The standard input stream.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	bufferSize is less than or equal to zero.
        /// <summary>
        /// 
        /// </summary>
        public static Stream OpenStandardInput(int bufferSize)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Acquires the standard input stream.
        //
        // Returns:
        //	The standard input stream.
        /// <summary>
        /// 
        /// </summary>
        public static Stream OpenStandardInput()
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Acquires the standard output stream, which is set to a specified buffer size.
        //
        // Parameters:
        //	bufferSize:
        //	The internal stream buffer size.
        //
        // Returns:
        //	The standard output stream.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	bufferSize is less than or equal to zero.
        /// <summary>
        /// 
        /// </summary>
        public static Stream OpenStandardOutput(int bufferSize)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Acquires the standard output stream.
        //
        // Returns:
        //	The standard output stream.
        /// <summary>
        /// 
        /// </summary>
        public static Stream OpenStandardOutput()
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Reads the next character from the standard input stream.
        //
        // Returns:
        //	The next character from the input stream, or negative one (-1) if there are currently
        //	no more characters to be read.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static int Read()
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Obtains the next character or function key pressed by the user. The pressed key
        //	is optionally displayed in the console window.
        //
        // Parameters:
        //	intercept:
        //	Determines whether to display the pressed key in the console window. true to
        //	not display the pressed key; otherwise, false.
        //
        // Returns:
        //	An object that describes the System.ConsoleKey constant and Unicode character,
        //	if any, that correspond to the pressed console key. The System.ConsoleKeyInfo
        //	object also describes, in a bitwise combination of System.ConsoleModifiers values,
        //	whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously
        //	with the console key.
        //
        // Exceptions:
        //	T:System.InvalidOperationException:
        //	The System.Console.In property is redirected from some stream other than the
        //	console.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        public static ConsoleKeyInfo ReadKey(bool intercept)
        {
            if (MockKeyPresses.Count > 0)
            {
                return MockKeyPresses.Pop();
            }
            else
            {
                return new ConsoleKeyInfo('\0', (ConsoleKey)'\0', false, false, false);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static Stack<ConsoleKeyInfo> MockKeyPresses = new Stack<ConsoleKeyInfo>();

        //
        // Summary:
        //	Obtains the next character or function key pressed by the user. The pressed key
        //	is displayed in the console window.
        //
        // Returns:
        //	An object that describes the System.ConsoleKey constant and Unicode character,
        //	if any, that correspond to the pressed console key. The System.ConsoleKeyInfo
        //	object also describes, in a bitwise combination of System.ConsoleModifiers values,
        //	whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously
        //	with the console key.
        //
        // Exceptions:
        //	T:System.InvalidOperationException:
        //	The System.Console.In property is redirected from some stream other than the
        //	console.
        /// <summary>
        /// 
        /// </summary>
        public static ConsoleKeyInfo ReadKey()
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Reads the next line of characters from the standard input stream.
        //
        // Returns:
        //	The next line of characters from the input stream, or null if no more lines are
        //	available.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.OutOfMemoryException:
        //	There is insufficient memory to allocate a buffer for the returned string.
        //
        //	T:System.ArgumentOutOfRangeException:
        //	The number of characters in the next line of characters is greater than System.Int32.MaxValue.
        /// <summary>
        /// 
        /// </summary>
        public static string ReadLine()
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Sets the foreground and background console colors to their defaults.
        //
        // Exceptions:
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        public static void ResetColor()
        {
            BackgroundColor = _defaultBackgroundColor;
            ForegroundColor = _defaultForegroundColor;
        }

        //
        // Summary:
        //	Sets the height and width of the screen buffer area to the specified values.
        //
        // Parameters:
        //	width:
        //	The width of the buffer area measured in columns.
        //
        //	height:
        //	The height of the buffer area measured in rows.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	height or width is less than or equal to zero.-or- height or width is greater
        //	than or equal to System.Int16.MaxValue.-or- width is less than System.Console.WindowLeft
        //	+ System.Console.WindowWidth.-or- height is less than System.Console.WindowTop
        //	+ System.Console.WindowHeight.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        public static void SetBufferSize(int width, int height)
        {
            BufferWidth = width;
            BufferHeight = height;
            _buffer = new char[BufferWidth, BufferHeight];
        }

        //
        // Summary:
        //	Sets the position of the cursor.
        //
        // Parameters:
        //	left:
        //	The column position of the cursor. Columns are numbered from left to right starting
        //	at 0.
        //
        //	top:
        //	The row position of the cursor. Rows are numbered from top to bottom starting
        //	at 0.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	left or top is less than zero.-or- left is greater than or equal to System.Console.BufferWidth.-or-
        //	top is greater than or equal to System.Console.BufferHeight.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        public static void SetCursorPosition(int left, int top)
        {
            CursorLeft = left;
            CursorTop = top;
            WindowLeft = Math.Max(Math.Min(left, BufferWidth - WindowWidth), 0);
            WindowTop = Math.Max(Math.Min(top, BufferHeight - WindowHeight), 0);
        }

        //
        // Summary:
        //	Sets the System.Console.Error property to the specified System.IO.TextWriter
        //	object.
        //
        // Parameters:
        //	newError:
        //	A stream that is the new standard error output.
        //
        // Exceptions:
        //	T:System.ArgumentNullException:
        //	newError is null.
        //
        //	T:System.Security.SecurityException:
        //	The caller does not have the required permission.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        public static void SetError(TextWriter newError)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Sets the System.Console.In property to the specified System.IO.TextReader object.
        //
        // Parameters:
        //	newIn:
        //	A stream that is the new standard input.
        //
        // Exceptions:
        //	T:System.ArgumentNullException:
        //	newIn is null.
        //
        //	T:System.Security.SecurityException:
        //	The caller does not have the required permission.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        public static void SetIn(TextReader newIn)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Sets the System.Console.Out property to the specified System.IO.TextWriter object.
        //
        // Parameters:
        //	newOut:
        //	A stream that is the new standard output.
        //
        // Exceptions:
        //	T:System.ArgumentNullException:
        //	newOut is null.
        //
        //	T:System.Security.SecurityException:
        //	The caller does not have the required permission.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newOut"></param>
        public static void SetOut(TextWriter newOut)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Sets the position of the console window relative to the screen buffer.
        //
        // Parameters:
        //	left:
        //	The column position of the upper left corner of the console window.
        //
        //	top:
        //	The row position of the upper left corner of the console window.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	left or top is less than zero.-or- left + System.Console.WindowWidth is greater
        //	than System.Console.BufferWidth.-or- top + System.Console.WindowHeight is greater
        //	than System.Console.BufferHeight.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="left"></param>
        /// <param name="top"></param>
        public static void SetWindowPosition(int left, int top)
        {
            WindowLeft = left;
            WindowTop = top;
        }

        //
        // Summary:
        //	Sets the height and width of the console window to the specified values.
        //
        // Parameters:
        //	width:
        //	The width of the console window measured in columns.
        //
        //	height:
        //	The height of the console window measured in rows.
        //
        // Exceptions:
        //	T:System.ArgumentOutOfRangeException:
        //	width or height is less than or equal to zero.-or- width plus System.Console.WindowLeft
        //	or height plus System.Console.WindowTop is greater than or equal to System.Int16.MaxValue.
        //	-or- width or height is greater than the largest possible window width or height
        //	for the current screen resolution and console font.
        //
        //	T:System.Security.SecurityException:
        //	The user does not have permission to perform this action.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[SecuritySafeCritical]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="width"></param>
        /// <param name="height"></param>
        public static void SetWindowSize(int width, int height)
        {
            WindowWidth = width;
            WindowHeight = height;
        }

        //
        // Summary:
        //	Writes the specified string value to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(string value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified object to the standard output
        //	stream.
        //
        // Parameters:
        //	value:
        //	The value to write, or null.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(object value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 64-bit unsigned integer value
        //	to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[CLSCompliant (false)]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(ulong value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 64-bit signed integer value to
        //	the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(long value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified objects to the standard output
        //	stream using the specified format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg0:
        //	The first object to write using format.
        //
        //	arg1:
        //	The second object to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        /// <param name="arg1"></param>
        public static void Write(string format, object arg0, object arg1)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 32-bit signed integer value to
        //	the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(int value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified object to the standard output
        //	stream using the specified format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg0:
        //	An object to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        public static void Write(string format, object arg0)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 32-bit unsigned integer value
        //	to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[CLSCompliant (false)]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(uint value)
        {
            throw new NotImplementedException();
        }

        //[CLSCompliant (false)]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        /// <param name="arg1"></param>
        /// <param name="arg2"></param>
        /// <param name="arg3"></param>
        public static void Write(string format, object arg0, object arg1, object arg2, object arg3)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified array of objects to the standard
        //	output stream using the specified format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg:
        //	An array of objects to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format or arg is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg"></param>
        public static void Write(string format, params object[] arg)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified Boolean value to the standard
        //	output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(bool value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the specified Unicode character value to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(char value)
        {
            _buffer[CursorLeft, CursorTop] = value;
        }

        //
        // Summary:
        //	Writes the specified array of Unicode characters to the standard output stream.
        //
        // Parameters:
        //	buffer:
        //	A Unicode character array.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="buffer"></param>
        public static void Write(char[] buffer)
        {
            _buffer[CursorLeft, CursorTop] = (char)0;
            foreach (var ch in buffer)
            {
                _buffer[CursorLeft, CursorTop] += ch;
            }
        }

        //
        // Summary:
        //	Writes the specified subarray of Unicode characters to the standard output stream.
        //
        // Parameters:
        //	buffer:
        //	An array of Unicode characters.
        //
        //	index:
        //	The starting position in buffer.
        //
        //	count:
        //	The number of characters to write.
        //
        // Exceptions:
        //	T:System.ArgumentNullException:
        //	buffer is null.
        //
        //	T:System.ArgumentOutOfRangeException:
        //	index or count is less than zero.
        //
        //	T:System.ArgumentException:
        //	index plus count specify a position that is not within buffer.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="index"></param>
        /// <param name="count"></param>
        public static void Write(char[] buffer, int index, int count)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified objects to the standard output
        //	stream using the specified format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg0:
        //	The first object to write using format.
        //
        //	arg1:
        //	The second object to write using format.
        //
        //	arg2:
        //	The third object to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        /// <param name="arg1"></param>
        /// <param name="arg2"></param>
        public static void Write(string format, object arg0, object arg1, object arg2)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified System.Decimal value to the standard
        //	output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(decimal value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified single-precision floating-point
        //	value to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(float value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified double-precision floating-point
        //	value to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void Write(double value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the current line terminator to the standard output stream.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        public static void WriteLine()
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified single-precision floating-point
        //	value, followed by the current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(float value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 32-bit signed integer value,
        //	followed by the current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(int value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 32-bit unsigned integer value,
        //	followed by the current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[CLSCompliant (false)]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(uint value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 64-bit signed integer value,
        //	followed by the current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(long value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified 64-bit unsigned integer value,
        //	followed by the current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //[CLSCompliant (false)]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(ulong value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified object, followed by the current
        //	line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(object value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the specified string value, followed by the current line terminator, to
        //	the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(string value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified object, followed by the current
        //	line terminator, to the standard output stream using the specified format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg0:
        //	An object to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        public static void WriteLine(string format, object arg0)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified objects, followed by the current
        //	line terminator, to the standard output stream using the specified format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg0:
        //	The first object to write using format.
        //
        //	arg1:
        //	The second object to write using format.
        //
        //	arg2:
        //	The third object to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        /// <param name="arg1"></param>
        /// <param name="arg2"></param>
        public static void WriteLine(string format, object arg0, object arg1, object arg2)
        {
            throw new NotImplementedException();
        }

        //[CLSCompliant (false)]
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        /// <param name="arg1"></param>
        /// <param name="arg2"></param>
        /// <param name="arg3"></param>
        public static void WriteLine(string format, object arg0, object arg1, object arg2, object arg3)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified array of objects, followed by
        //	the current line terminator, to the standard output stream using the specified
        //	format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg:
        //	An array of objects to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format or arg is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg"></param>
        public static void WriteLine(string format, params object[] arg)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the specified subarray of Unicode characters, followed by the current
        //	line terminator, to the standard output stream.
        //
        // Parameters:
        //	buffer:
        //	An array of Unicode characters.
        //
        //	index:
        //	The starting position in buffer.
        //
        //	count:
        //	The number of characters to write.
        //
        // Exceptions:
        //	T:System.ArgumentNullException:
        //	buffer is null.
        //
        //	T:System.ArgumentOutOfRangeException:
        //	index or count is less than zero.
        //
        //	T:System.ArgumentException:
        //	index plus count specify a position that is not within buffer.
        //
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="index"></param>
        /// <param name="count"></param>
        public static void WriteLine(char[] buffer, int index, int count)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified System.Decimal value, followed
        //	by the current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(decimal value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the specified array of Unicode characters, followed by the current line
        //	terminator, to the standard output stream.
        //
        // Parameters:
        //	buffer:
        //	A Unicode character array.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="buffer"></param>
        public static void WriteLine(char[] buffer)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the specified Unicode character, followed by the current line terminator,
        //	value to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(char value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified Boolean value, followed by the
        //	current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(bool value)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified objects, followed by the current
        //	line terminator, to the standard output stream using the specified format information.
        //
        // Parameters:
        //	format:
        //	A composite format string (see Remarks).
        //
        //	arg0:
        //	The first object to write using format.
        //
        //	arg1:
        //	The second object to write using format.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        //
        //	T:System.ArgumentNullException:
        //	format is null.
        //
        //	T:System.FormatException:
        //	The format specification in format is invalid.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="arg0"></param>
        /// <param name="arg1"></param>
        public static void WriteLine(string format, object arg0, object arg1)
        {
            throw new NotImplementedException();
        }

        //
        // Summary:
        //	Writes the text representation of the specified double-precision floating-point
        //	value, followed by the current line terminator, to the standard output stream.
        //
        // Parameters:
        //	value:
        //	The value to write.
        //
        // Exceptions:
        //	T:System.IO.IOException:
        //	An I/O error occurred.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static void WriteLine(double value)
        {
            throw new NotImplementedException();
        }

    }
    //=======================================================================
    //
    // FakeDriver.cs: A fake ConsoleDriver for unit tests. 
    //

    /// <summary>
    /// Implements a mock ConsoleDriver for unit testing
    /// </summary>
    public class FakeDriver : ConsoleDriver
    {
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public class Behaviors
        {

            public bool UseFakeClipboard { get; internal set; }
            public bool FakeClipboardAlwaysThrowsNotSupportedException { get; internal set; }
            public bool FakeClipboardIsSupportedAlwaysFalse { get; internal set; }

            public Behaviors(bool useFakeClipboard = false, bool fakeClipboardAlwaysThrowsNotSupportedException = false, bool fakeClipboardIsSupportedAlwaysTrue = false)
            {
                UseFakeClipboard = useFakeClipboard;
                FakeClipboardAlwaysThrowsNotSupportedException = fakeClipboardAlwaysThrowsNotSupportedException;
                FakeClipboardIsSupportedAlwaysFalse = fakeClipboardIsSupportedAlwaysTrue;

                // double check usage is correct
                Debug.Assert(useFakeClipboard == false && fakeClipboardAlwaysThrowsNotSupportedException == false);
                Debug.Assert(useFakeClipboard == false && fakeClipboardIsSupportedAlwaysTrue == false);
            }
        }

        public static FakeDriver.Behaviors FakeBehaviors = new Behaviors();

        int cols, rows, left, top;
        public override int Cols => cols;
        public override int Rows => rows;
        // Only handling left here because not all terminals has a horizontal scroll bar.
        public override int Left => 0;
        public override int Top => 0;
        [Obsolete("This API is deprecated", false)]
        public override bool EnableConsoleScrolling { get; set; }
        [Obsolete("This API is deprecated", false)]
        public override bool HeightAsBuffer { get; set; }
        private IClipboard clipboard = null;
        public override IClipboard Clipboard => clipboard;

        // The format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
        int[,,] contents;
        bool[] dirtyLine;

        /// <summary>
        /// Assists with testing, the format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
        /// </summary>
        public override int[,,] Contents => contents;

        //void UpdateOffscreen ()
        //{
        //	int cols = Cols;
        //	int rows = Rows;

        //	contents = new int [rows, cols, 3];
        //	for (int r = 0; r < rows; r++) {
        //		for (int c = 0; c < cols; c++) {
        //			contents [r, c, 0] = ' ';
        //			contents [r, c, 1] = MakeColor (ConsoleColor.Gray, ConsoleColor.Black);
        //			contents [r, c, 2] = 0;
        //		}
        //	}
        //	dirtyLine = new bool [rows];
        //	for (int row = 0; row < rows; row++)
        //		dirtyLine [row] = true;
        //}

        static bool sync = false;

        public FakeDriver()
        {
            if (FakeBehaviors.UseFakeClipboard)
            {
                clipboard = new FakeClipboard(FakeBehaviors.FakeClipboardAlwaysThrowsNotSupportedException, FakeBehaviors.FakeClipboardIsSupportedAlwaysFalse);
            }
            else
            {
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                {
                    clipboard = new WindowsClipboard();
                }
                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                {
                    clipboard = new MacOSXClipboard();
                }
                else
                {
                    if (CursesDriver.Is_WSL_Platform())
                    {
                        clipboard = new WSLClipboard();
                    }
                    else
                    {
                        clipboard = new CursesClipboard();
                    }
                }
            }
        }

        bool needMove;
        // Current row, and current col, tracked by Move/AddCh only
        int ccol, crow;
        public override void Move(int col, int row)
        {
            ccol = col;
            crow = row;

            if (Clip.Contains(col, row))
            {
                FakeConsole.CursorTop = row;
                FakeConsole.CursorLeft = col;
                needMove = false;
            }
            else
            {
                FakeConsole.CursorTop = Clip.Y;
                FakeConsole.CursorLeft = Clip.X;
                needMove = true;
            }
        }

        public override void AddRune(Rune rune)
        {
            rune = MakePrintable(rune);
            var runeWidth = Rune.ColumnWidth(rune);
            var validClip = IsValidContent(ccol, crow, Clip);

            if (validClip)
            {
                if (needMove)
                {
                    //MockConsole.CursorLeft = ccol;
                    //MockConsole.CursorTop = crow;
                    needMove = false;
                }
                if (runeWidth == 0 && ccol > 0)
                {
                    var r = contents[crow, ccol - 1, 0];
                    var s = new string(new char[] { (char)r, (char)rune });
                    string sn;
                    if (!s.IsNormalized())
                    {
                        sn = s.Normalize();
                    }
                    else
                    {
                        sn = s;
                    }
                    var c = sn[0];
                    contents[crow, ccol - 1, 0] = c;
                    contents[crow, ccol - 1, 1] = CurrentAttribute;
                    contents[crow, ccol - 1, 2] = 1;

                }
                else
                {
                    if (runeWidth < 2 && ccol > 0
                    && Rune.ColumnWidth((Rune)contents[crow, ccol - 1, 0]) > 1)
                    {

                        contents[crow, ccol - 1, 0] = (int)(uint)' ';

                    }
                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
                      && Rune.ColumnWidth((Rune)contents[crow, ccol, 0]) > 1)
                    {

                        contents[crow, ccol + 1, 0] = (int)(uint)' ';
                        contents[crow, ccol + 1, 2] = 1;

                    }
                    if (runeWidth > 1 && ccol == Clip.Right - 1)
                    {
                        contents[crow, ccol, 0] = (int)(uint)' ';
                    }
                    else
                    {
                        contents[crow, ccol, 0] = (int)(uint)rune;
                    }
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 1;

                    dirtyLine[crow] = true;
                }
            }
            else
            {
                needMove = true;
            }

            if (runeWidth < 0 || runeWidth > 0)
            {
                ccol++;
            }

            if (runeWidth > 1)
            {
                if (validClip && ccol < Clip.Right)
                {
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 0;
                }
                ccol++;
            }

            //if (ccol == Cols) {
            //	ccol = 0;
            //	if (crow + 1 < Rows)
            //		crow++;
            //}
            if (sync)
            {
                UpdateScreen();
            }
        }

        public override void AddStr(ustring str)
        {
            foreach (var rune in str)
                AddRune(rune);
        }

        public override void End()
        {
            FakeConsole.ResetColor();
            FakeConsole.Clear();
        }

        public override Attribute MakeColor(Color foreground, Color background)
        {
            return MakeColor((ConsoleColor)foreground, (ConsoleColor)background);
        }

        static Attribute MakeColor(ConsoleColor f, ConsoleColor b)
        {
            // Encode the colors into the int value.
            return new Attribute(
                value: ((((int)f) & 0xffff) << 16) | (((int)b) & 0xffff),
                foreground: (Color)f,
                background: (Color)b
                );
        }

        public override void Init(Action terminalResized)
        {
            TerminalResized = terminalResized;

            cols = FakeConsole.WindowWidth = FakeConsole.BufferWidth = FakeConsole.WIDTH;
            rows = FakeConsole.WindowHeight = FakeConsole.BufferHeight = FakeConsole.HEIGHT;
            FakeConsole.Clear();
            ResizeScreen();
            // Call InitalizeColorSchemes before UpdateOffScreen as it references Colors
            CurrentAttribute = MakeColor(Color.White, Color.Black);
            InitalizeColorSchemes();
            UpdateOffScreen();
        }

        public override Attribute MakeAttribute(Color fore, Color back)
        {
            return MakeColor((ConsoleColor)fore, (ConsoleColor)back);
        }

        int redrawColor = -1;
        void SetColor(int color)
        {
            redrawColor = color;
            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
                .OfType<ConsoleColor>()
                .Select(s => (int)s);
            if (values.Contains(color & 0xffff))
            {
                FakeConsole.BackgroundColor = (ConsoleColor)(color & 0xffff);
            }
            if (values.Contains((color >> 16) & 0xffff))
            {
                FakeConsole.ForegroundColor = (ConsoleColor)((color >> 16) & 0xffff);
            }
        }

        public override void UpdateScreen()
        {
            int top = Top;
            int left = Left;
            int rows = Math.Min(FakeConsole.WindowHeight + top, Rows);
            int cols = Cols;

            var savedRow = FakeConsole.CursorTop;
            var savedCol = FakeConsole.CursorLeft;
            var savedCursorVisible = FakeConsole.CursorVisible;
            for (int row = top; row < rows; row++)
            {
                if (!dirtyLine[row])
                    continue;
                dirtyLine[row] = false;
                for (int col = left; col < cols; col++)
                {
                    FakeConsole.CursorTop = row;
                    FakeConsole.CursorLeft = col;
                    for (; col < cols; col++)
                    {
                        if (contents[row, col, 2] == 0)
                        {
                            FakeConsole.CursorLeft++;
                            continue;
                        }

                        var color = contents[row, col, 1];
                        if (color != redrawColor)
                            SetColor(color);

                        Rune rune = contents[row, col, 0];
                        if (Rune.DecodeSurrogatePair(rune, out char[] spair))
                        {
                            FakeConsole.Write(spair);
                        }
                        else
                        {
                            FakeConsole.Write((char)rune);
                        }
                        contents[row, col, 2] = 0;
                    }
                }
            }
            FakeConsole.CursorTop = savedRow;
            FakeConsole.CursorLeft = savedCol;
            FakeConsole.CursorVisible = savedCursorVisible;
        }

        public override void Refresh()
        {
            UpdateScreen();
            UpdateCursor();
        }

        public override void SetAttribute(Attribute c)
        {
            base.SetAttribute(c);
        }

        public ConsoleKeyInfo FromVKPacketToKConsoleKeyInfo(ConsoleKeyInfo consoleKeyInfo)
        {
            if (consoleKeyInfo.Key != ConsoleKey.Packet)
            {
                return consoleKeyInfo;
            }

            var mod = consoleKeyInfo.Modifiers;
            var shift = (mod & ConsoleModifiers.Shift) != 0;
            var alt = (mod & ConsoleModifiers.Alt) != 0;
            var control = (mod & ConsoleModifiers.Control) != 0;

            var keyChar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(consoleKeyInfo.KeyChar, consoleKeyInfo.Modifiers, out uint virtualKey, out _);

            return new ConsoleKeyInfo((char)keyChar, (ConsoleKey)virtualKey, shift, alt, control);
        }

        Key MapKey(ConsoleKeyInfo keyInfo)
        {
            switch (keyInfo.Key)
            {
                case ConsoleKey.Escape:
                    return MapKeyModifiers(keyInfo, Key.Esc);
                case ConsoleKey.Tab:
                    return keyInfo.Modifiers == ConsoleModifiers.Shift ? Key.BackTab : Key.Tab;
                case ConsoleKey.Clear:
                    return MapKeyModifiers(keyInfo, Key.Clear);
                case ConsoleKey.Home:
                    return MapKeyModifiers(keyInfo, Key.Home);
                case ConsoleKey.End:
                    return MapKeyModifiers(keyInfo, Key.End);
                case ConsoleKey.LeftArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorLeft);
                case ConsoleKey.RightArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorRight);
                case ConsoleKey.UpArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorUp);
                case ConsoleKey.DownArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorDown);
                case ConsoleKey.PageUp:
                    return MapKeyModifiers(keyInfo, Key.PageUp);
                case ConsoleKey.PageDown:
                    return MapKeyModifiers(keyInfo, Key.PageDown);
                case ConsoleKey.Enter:
                    return MapKeyModifiers(keyInfo, Key.Enter);
                case ConsoleKey.Spacebar:
                    return MapKeyModifiers(keyInfo, keyInfo.KeyChar == 0 ? Key.Space : (Key)keyInfo.KeyChar);
                case ConsoleKey.Backspace:
                    return MapKeyModifiers(keyInfo, Key.Backspace);
                case ConsoleKey.Delete:
                    return MapKeyModifiers(keyInfo, Key.DeleteChar);
                case ConsoleKey.Insert:
                    return MapKeyModifiers(keyInfo, Key.InsertChar);
                case ConsoleKey.PrintScreen:
                    return MapKeyModifiers(keyInfo, Key.PrintScreen);

                case ConsoleKey.Oem1:
                case ConsoleKey.Oem2:
                case ConsoleKey.Oem3:
                case ConsoleKey.Oem4:
                case ConsoleKey.Oem5:
                case ConsoleKey.Oem6:
                case ConsoleKey.Oem7:
                case ConsoleKey.Oem8:
                case ConsoleKey.Oem102:
                case ConsoleKey.OemPeriod:
                case ConsoleKey.OemComma:
                case ConsoleKey.OemPlus:
                case ConsoleKey.OemMinus:
                    if (keyInfo.KeyChar == 0)
                        return Key.Unknown;

                    return (Key)((uint)keyInfo.KeyChar);
            }

            var key = keyInfo.Key;
            if (key >= ConsoleKey.A && key <= ConsoleKey.Z)
            {
                var delta = key - ConsoleKey.A;
                if (keyInfo.Modifiers == ConsoleModifiers.Control)
                {
                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.A + delta));
                }
                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
                {
                    return (Key)(((uint)Key.AltMask) | ((uint)Key.A + delta));
                }
                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
                {
                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
                }
                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    if (keyInfo.KeyChar == 0)
                    {
                        return (Key)(((uint)Key.AltMask | (uint)Key.CtrlMask) | ((uint)Key.A + delta));
                    }
                    else
                    {
                        return (Key)((uint)keyInfo.KeyChar);
                    }
                }
                return (Key)((uint)keyInfo.KeyChar);
            }
            if (key >= ConsoleKey.D0 && key <= ConsoleKey.D9)
            {
                var delta = key - ConsoleKey.D0;
                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
                {
                    return (Key)(((uint)Key.AltMask) | ((uint)Key.D0 + delta));
                }
                if (keyInfo.Modifiers == ConsoleModifiers.Control)
                {
                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.D0 + delta));
                }
                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
                {
                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
                }
                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    if (keyInfo.KeyChar == 0 || keyInfo.KeyChar == 30)
                    {
                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
                    }
                }
                return (Key)((uint)keyInfo.KeyChar);
            }
            if (key >= ConsoleKey.F1 && key <= ConsoleKey.F12)
            {
                var delta = key - ConsoleKey.F1;
                if ((keyInfo.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.F1 + delta));
                }

                return (Key)((uint)Key.F1 + delta);
            }
            if (keyInfo.KeyChar != 0)
            {
                return MapKeyModifiers(keyInfo, (Key)((uint)keyInfo.KeyChar));
            }

            return (Key)(0xffffffff);
        }

        KeyModifiers keyModifiers;

        private Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
        {
            Key keyMod = new Key();
            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
                keyMod = Key.ShiftMask;
            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
                keyMod |= Key.CtrlMask;
            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
                keyMod |= Key.AltMask;

            return keyMod != Key.Null ? keyMod | key : key;
        }

        Action<KeyEvent> keyDownHandler;
        Action<KeyEvent> keyHandler;
        Action<KeyEvent> keyUpHandler;
        private CursorVisibility savedCursorVisibility;

        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
        {
            this.keyDownHandler = keyDownHandler;
            this.keyHandler = keyHandler;
            this.keyUpHandler = keyUpHandler;

            // Note: Net doesn't support keydown/up events and thus any passed keyDown/UpHandlers will never be called
            (mainLoop.Driver as FakeMainLoop).KeyPressed += (consoleKey) => ProcessInput(consoleKey);
        }

        void ProcessInput(ConsoleKeyInfo consoleKey)
        {
            if (consoleKey.Key == ConsoleKey.Packet)
            {
                consoleKey = FromVKPacketToKConsoleKeyInfo(consoleKey);
            }
            keyModifiers = new KeyModifiers();
            if (consoleKey.Modifiers.HasFlag(ConsoleModifiers.Shift))
            {
                keyModifiers.Shift = true;
            }
            if (consoleKey.Modifiers.HasFlag(ConsoleModifiers.Alt))
            {
                keyModifiers.Alt = true;
            }
            if (consoleKey.Modifiers.HasFlag(ConsoleModifiers.Control))
            {
                keyModifiers.Ctrl = true;
            }
            var map = MapKey(consoleKey);
            if (map == (Key)0xffffffff)
            {
                if ((consoleKey.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    keyDownHandler(new KeyEvent(map, keyModifiers));
                    keyUpHandler(new KeyEvent(map, keyModifiers));
                }
                return;
            }

            keyDownHandler(new KeyEvent(map, keyModifiers));
            keyHandler(new KeyEvent(map, keyModifiers));
            keyUpHandler(new KeyEvent(map, keyModifiers));
        }

        /// <inheritdoc/>
        public override bool GetCursorVisibility(out CursorVisibility visibility)
        {
            visibility = FakeConsole.CursorVisible
                ? CursorVisibility.Default
                : CursorVisibility.Invisible;

            return FakeConsole.CursorVisible;
        }

        /// <inheritdoc/>
        public override bool SetCursorVisibility(CursorVisibility visibility)
        {
            savedCursorVisibility = visibility;
            return FakeConsole.CursorVisible = visibility == CursorVisibility.Default;
        }

        /// <inheritdoc/>
        public override bool EnsureCursorVisibility()
        {
            if (!(ccol >= 0 && crow >= 0 && ccol < Cols && crow < Rows))
            {
                GetCursorVisibility(out CursorVisibility cursorVisibility);
                savedCursorVisibility = cursorVisibility;
                SetCursorVisibility(CursorVisibility.Invisible);
                return false;
            }

            SetCursorVisibility(savedCursorVisibility);
            return FakeConsole.CursorVisible;
        }

        public override void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
        {
            ProcessInput(new ConsoleKeyInfo(keyChar, key, shift, alt, control));
        }

        public void SetBufferSize(int width, int height)
        {
            FakeConsole.SetBufferSize(width, height);
            cols = width;
            rows = height;
            SetWindowSize(width, height);
            ProcessResize();
        }

        public void SetWindowSize(int width, int height)
        {
            FakeConsole.SetWindowSize(width, height);
            if (width != cols || height != rows)
            {
                SetBufferSize(width, height);
                cols = width;
                rows = height;
            }
            ProcessResize();
        }

        public void SetWindowPosition(int left, int top)
        {
            if (this.left > 0 || this.top > 0)
            {
                this.left = 0;
                this.top = 0;
            }
            FakeConsole.SetWindowPosition(this.left, this.top);
        }

        void ProcessResize()
        {
            ResizeScreen();
            UpdateOffScreen();
            TerminalResized?.Invoke();
        }

        public override void ResizeScreen()
        {
            if (FakeConsole.WindowHeight > 0)
            {
                // Can raise an exception while is still resizing.
                try
                {
#pragma warning disable CA1416
                    FakeConsole.CursorTop = 0;
                    FakeConsole.CursorLeft = 0;
                    FakeConsole.WindowTop = 0;
                    FakeConsole.WindowLeft = 0;
#pragma warning restore CA1416
                }
                catch (System.IO.IOException)
                {
                    return;
                }
                catch (ArgumentOutOfRangeException)
                {
                    return;
                }
            }

            Clip = new Rect(0, 0, Cols, Rows);
        }

        public override void UpdateOffScreen()
        {
            contents = new int[Rows, Cols, 3];
            dirtyLine = new bool[Rows];

            // Can raise an exception while is still resizing.
            try
            {
                for (int row = 0; row < rows; row++)
                {
                    for (int c = 0; c < cols; c++)
                    {
                        contents[row, c, 0] = ' ';
                        contents[row, c, 1] = (ushort)Colors.TopLevel.Normal;
                        contents[row, c, 2] = 0;
                        dirtyLine[row] = true;
                    }
                }
            }
            catch (IndexOutOfRangeException) { }
        }

        public override bool GetColors(int value, out Color foreground, out Color background)
        {
            bool hasColor = false;
            foreground = default;
            background = default;
            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
                .OfType<ConsoleColor>()
                .Select(s => (int)s);
            if (values.Contains(value & 0xffff))
            {
                hasColor = true;
                background = (Color)(ConsoleColor)(value & 0xffff);
            }
            if (values.Contains((value >> 16) & 0xffff))
            {
                hasColor = true;
                foreground = (Color)(ConsoleColor)((value >> 16) & 0xffff);
            }
            return hasColor;
        }

        #region Unused
        public override void UpdateCursor()
        {
            if (!EnsureCursorVisibility())
                return;

            // Prevents the exception of size changing during resizing.
            try
            {
                if (ccol >= 0 && ccol < FakeConsole.BufferWidth && crow >= 0 && crow < FakeConsole.BufferHeight)
                {
                    FakeConsole.SetCursorPosition(ccol, crow);
                }
            }
            catch (System.IO.IOException)
            {
            }
            catch (ArgumentOutOfRangeException)
            {
            }
        }

        public override void StartReportingMouseMoves()
        {
        }

        public override void StopReportingMouseMoves()
        {
        }

        public override void Suspend()
        {
        }

        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
        {
        }

        public override void SetColors(short foregroundColorId, short backgroundColorId)
        {
            throw new NotImplementedException();
        }

        public override void CookMouse()
        {
        }

        public override void UncookMouse()
        {
        }

        #endregion

        public class FakeClipboard : ClipboardBase
        {
            public Exception FakeException = null;

            string contents = string.Empty;

            bool isSupportedAlwaysFalse = false;

            public override bool IsSupported => !isSupportedAlwaysFalse;

            public FakeClipboard(bool fakeClipboardThrowsNotSupportedException = false, bool isSupportedAlwaysFalse = false)
            {
                this.isSupportedAlwaysFalse = isSupportedAlwaysFalse;
                if (fakeClipboardThrowsNotSupportedException)
                {
                    FakeException = new NotSupportedException("Fake clipboard exception");
                }
            }

            protected override string GetClipboardDataImpl()
            {
                if (FakeException != null)
                {
                    throw FakeException;
                }
                return contents;
            }

            protected override void SetClipboardDataImpl(string text)
            {
                if (FakeException != null)
                {
                    throw FakeException;
                }
                contents = text;
            }
        }

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }
    //=======================================================================
    internal class FakeMainLoop : IMainLoopDriver
    {

        public Action<ConsoleKeyInfo> KeyPressed;

        public FakeMainLoop(ConsoleDriver consoleDriver = null)
        {
            // consoleDriver is not needed/used in FakeConsole
        }

        public void Setup(MainLoop mainLoop)
        {
        }

        public void Wakeup()
        {
            // No implementation needed for FakeMainLoop
        }

        public bool EventsPending(bool wait)
        {
            // Always return true for FakeMainLoop
            return true;
        }

        public void MainIteration()
        {
            if (FakeConsole.MockKeyPresses.Count > 0)
            {
                KeyPressed?.Invoke(FakeConsole.MockKeyPresses.Pop());
            }
        }
    }
    //=======================================================================
    // 
    // FileDialog.cs: File system dialogs for open and save
    //
    // TODO:
    //   * Add directory selector
    //   * Implement subclasses
    //   * Figure out why message text does not show
    //   * Remove the extra space when message does not show
    //   * Use a line separator to show the file listing, so we can use same colors as the rest
    //   * DirListView: Add mouse support

    internal class DirListView : View
    {
        int top, selected;
        DirectoryInfo dirInfo;
        FileSystemWatcher watcher;
        List<(string, bool, bool)> infos;
        internal bool canChooseFiles = true;
        internal bool canChooseDirectories = false;
        internal bool allowsMultipleSelection = false;
        FileDialog host;

        public DirListView(FileDialog host)
        {
            infos = new List<(string, bool, bool)>();
            CanFocus = true;
            this.host = host;
        }

        bool IsAllowed(FileSystemInfo fsi)
        {
            if (fsi.Attributes.HasFlag(FileAttributes.Directory))
                return true;
            if (allowedFileTypes == null)
                return true;
            foreach (var ft in allowedFileTypes)
                if (fsi.Name.EndsWith(ft, StringComparison.InvariantCultureIgnoreCase) || ft == ".*")
                    return true;
            return false;
        }

        internal bool Reload(ustring value = null)
        {
            bool valid = false;
            try
            {
                dirInfo = new DirectoryInfo(value == null ? directory.ToString() : value.ToString());

                // Dispose of the old watcher
                watcher?.Dispose();

                watcher = new FileSystemWatcher(dirInfo.FullName);
                watcher.NotifyFilter = NotifyFilters.Attributes
                 | NotifyFilters.CreationTime
                 | NotifyFilters.DirectoryName
                 | NotifyFilters.FileName
                 | NotifyFilters.LastAccess
                 | NotifyFilters.LastWrite
                 | NotifyFilters.Security
                 | NotifyFilters.Size;
                watcher.Changed += Watcher_Changed;
                watcher.Created += Watcher_Changed;
                watcher.Deleted += Watcher_Changed;
                watcher.Renamed += Watcher_Changed;
                watcher.Error += Watcher_Error;
                watcher.EnableRaisingEvents = true;
                infos = (from x in dirInfo.GetFileSystemInfos()
                         where IsAllowed(x) && (!canChooseFiles ? x.Attributes.HasFlag(FileAttributes.Directory) : true)
                         orderby (!x.Attributes.HasFlag(FileAttributes.Directory)) + x.Name
                         select (x.Name, x.Attributes.HasFlag(FileAttributes.Directory), false)).ToList();
                infos.Insert(0, ("..", true, false));
                top = 0;
                selected = 0;
                valid = true;
            }
            catch (Exception ex)
            {
                switch (ex)
                {
                    case DirectoryNotFoundException _:
                    case ArgumentException _:
                        dirInfo = null;
                        watcher?.Dispose();
                        watcher = null;
                        infos.Clear();
                        valid = true;
                        break;
                    default:
                        valid = false;
                        break;
                }
            }
            finally
            {
                if (valid)
                {
                    SetNeedsDisplay();
                }
            }
            return valid;
        }

        private bool _disposedValue;
        protected override void Dispose(bool disposing)
        {
            if (!_disposedValue)
            {
                if (disposing)
                {
                    if (watcher != null)
                    {
                        watcher.Changed -= Watcher_Changed;
                        watcher.Created -= Watcher_Changed;
                        watcher.Deleted -= Watcher_Changed;
                        watcher.Renamed -= Watcher_Changed;
                        watcher.Error -= Watcher_Error;
                    }
                    watcher?.Dispose();
                    watcher = null;
                }

                _disposedValue = true;
            }

            // Call base class implementation.
            base.Dispose(disposing);
        }

        void Watcher_Error(object sender, ErrorEventArgs e)
        {
            if (Application.MainLoop == null)
                return;

            Application.MainLoop.Invoke(() => Reload());
        }

        void Watcher_Changed(object sender, FileSystemEventArgs e)
        {
            if (Application.MainLoop == null)
                return;

            Application.MainLoop.Invoke(() => Reload());
        }

        ustring directory;
        public ustring Directory
        {
            get => directory;
            set
            {
                if (directory == value)
                {
                    return;
                }
                if (Reload(value))
                {
                    directory = value;
                }
            }
        }

        public override void PositionCursor()
        {
            Move(0, selected - top);
        }

        int lastSelected;
        bool shiftOnWheel;
        public override bool MouseEvent(MouseEvent me)
        {
            if ((me.Flags & (MouseFlags.Button1Clicked | MouseFlags.Button1DoubleClicked |
                MouseFlags.WheeledUp | MouseFlags.WheeledDown)) == 0)
                return false;

            if (!HasFocus)
                SetFocus();

            if (infos == null)
                return false;

            if (me.Y + top >= infos.Count)
                return true;

            int lastSelectedCopy = shiftOnWheel ? lastSelected : selected;

            switch (me.Flags)
            {
                case MouseFlags.Button1Clicked:
                    SetSelected(me);
                    OnSelectionChanged();
                    SetNeedsDisplay();
                    break;
                case MouseFlags.Button1DoubleClicked:
                    UnMarkAll();
                    SetSelected(me);
                    if (ExecuteSelection())
                    {
                        host.canceled = false;

                        //*master//
                        //////Application.RequestStop();
                        host.DialogResult = new ostgui.TfDialogResult().OK;
                        host.OnDialogClosed(host);
                        host.Visible = false;
                        //master*//
                    }
                    return true;
                case MouseFlags.Button1Clicked | MouseFlags.ButtonShift:
                    SetSelected(me);
                    if (shiftOnWheel)
                        lastSelected = lastSelectedCopy;
                    shiftOnWheel = false;
                    PerformMultipleSelection(lastSelected);
                    return true;
                case MouseFlags.Button1Clicked | MouseFlags.ButtonCtrl:
                    SetSelected(me);
                    PerformMultipleSelection();
                    return true;
                case MouseFlags.WheeledUp:
                    SetSelected(me);
                    selected = lastSelected;
                    MoveUp();
                    return true;
                case MouseFlags.WheeledDown:
                    SetSelected(me);
                    selected = lastSelected;
                    MoveDown();
                    return true;
                case MouseFlags.WheeledUp | MouseFlags.ButtonShift:
                    SetSelected(me);
                    selected = lastSelected;
                    lastSelected = lastSelectedCopy;
                    shiftOnWheel = true;
                    MoveUp();
                    return true;
                case MouseFlags.WheeledDown | MouseFlags.ButtonShift:
                    SetSelected(me);
                    selected = lastSelected;
                    lastSelected = lastSelectedCopy;
                    shiftOnWheel = true;
                    MoveDown();
                    return true;
            }

            return true;
        }

        void UnMarkAll()
        {
            for (int i = 0; i < infos.Count; i++)
            {
                if (infos[i].Item3)
                {
                    infos[i] = (infos[i].Item1, infos[i].Item2, false);
                }
            }
        }

        void SetSelected(MouseEvent me)
        {
            lastSelected = selected;
            selected = top + me.Y;
        }

        void DrawString(int line, string str)
        {
            var f = Frame;
            var width = f.Width;
            var ustr = ustring.Make(str);

            Move(allowsMultipleSelection ? 3 : 2, line);
            int byteLen = ustr.Length;
            int used = allowsMultipleSelection ? 2 : 1;
            for (int i = 0; i < byteLen;)
            {
                (var rune, var size) = Utf8.DecodeRune(ustr, i, i - byteLen);
                var count = Rune.ColumnWidth(rune);
                if (used + count >= width)
                    break;
                Driver.AddRune(rune);
                used += count;
                i += size;
            }
            for (; used < width - 1; used++)
            {
                Driver.AddRune(' ');
            }
        }

        public override void Redraw(Rect bounds)
        {
            var current = ColorScheme.Focus;
            Driver.SetAttribute(current);
            Move(0, 0);
            var f = Frame;
            var item = top;
            bool focused = HasFocus;
            var width = bounds.Width;

            for (int row = 0; row < f.Height; row++, item++)
            {
                bool isSelected = item == selected;
                Move(0, row);
                var newcolor = focused ? (isSelected ? ColorScheme.HotNormal : ColorScheme.Focus)
                    : Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
                if (newcolor != current)
                {
                    Driver.SetAttribute(newcolor);
                    current = newcolor;
                }
                if (item >= infos.Count)
                {
                    for (int c = 0; c < f.Width; c++)
                        Driver.AddRune(' ');
                    continue;
                }
                var fi = infos[item];

                Driver.AddRune(isSelected ? '>' : ' ');

                if (allowsMultipleSelection)
                    Driver.AddRune(fi.Item3 ? '*' : ' ');

                if (fi.Item2)
                    Driver.AddRune('/');
                else
                    Driver.AddRune(' ');
                DrawString(row, fi.Item1);
            }
        }

        public Action<(string, bool)> SelectedChanged { get; set; }
        public Action<ustring> DirectoryChanged { get; set; }
        public Action<ustring> FileChanged { get; set; }

        string splitString = ",";

        void OnSelectionChanged()
        {
            if (allowsMultipleSelection)
            {
                if (FilePaths.Count > 0)
                {
                    FileChanged?.Invoke(string.Join(splitString, GetFilesName(FilePaths)));
                }
                else
                {
                    FileChanged?.Invoke(infos[selected].Item2 && !canChooseDirectories ? "" : Path.GetFileName(infos[selected].Item1));
                }
            }
            else
            {
                var sel = infos[selected];
                SelectedChanged?.Invoke((sel.Item1, sel.Item2));
            }
        }

        List<string> GetFilesName(IReadOnlyList<string> files)
        {
            List<string> filesName = new List<string>();

            foreach (var file in files)
            {
                filesName.Add(Path.GetFileName(file));
            }

            return filesName;
        }

        public bool GetValidFilesName(string files, out string result)
        {
            result = string.Empty;
            if (infos?.Count == 0)
            {
                return false;
            }

            var valid = true;
            IReadOnlyList<string> filesList = new List<string>(files.Split(splitString.ToArray(), StringSplitOptions.None));
            var filesName = new List<string>();
            UnMarkAll();

            foreach (var file in filesList)
            {
                if (!allowsMultipleSelection && filesName.Count > 0)
                {
                    break;
                }
                var idx = infos.IndexOf(x => x.Item1.IndexOf(file, StringComparison.OrdinalIgnoreCase) >= 0);
                if (idx > -1 && string.Equals(infos[idx].Item1, file, StringComparison.OrdinalIgnoreCase))
                {
                    if (canChooseDirectories && !canChooseFiles && !infos[idx].Item2)
                    {
                        valid = false;
                    }
                    if (allowsMultipleSelection && !infos[idx].Item3)
                    {
                        infos[idx] = (infos[idx].Item1, infos[idx].Item2, true);
                    }
                    if (!allowsMultipleSelection)
                    {
                        selected = idx;
                    }
                    filesName.Add(Path.GetFileName(infos[idx].Item1));
                }
                else if (idx > -1)
                {
                    valid = false;
                    filesName.Add(Path.GetFileName(file));
                }
            }
            result = string.Join(splitString, filesName);
            if (string.IsNullOrEmpty(result))
            {
                valid = false;
            }
            return valid;
        }

        public override bool ProcessKey(KeyEvent keyEvent)
        {
            switch (keyEvent.Key)
            {
                case Key.CursorUp:
                case Key.P | Key.CtrlMask:
                    MoveUp();
                    return true;

                case Key.CursorDown:
                case Key.N | Key.CtrlMask:
                    MoveDown();
                    return true;

                case Key.V | Key.CtrlMask:
                case Key.PageDown:
                    var n = (selected + Frame.Height);
                    if (n > infos.Count)
                        n = infos.Count - 1;
                    if (n != selected)
                    {
                        selected = n;
                        if (infos.Count >= Frame.Height)
                            top = selected;
                        else
                            top = 0;
                        OnSelectionChanged();

                        SetNeedsDisplay();
                    }
                    return true;

                case Key.Enter:
                    UnMarkAll();
                    if (ExecuteSelection())
                        return false;
                    else
                        return true;

                case Key.PageUp:
                    n = (selected - Frame.Height);
                    if (n < 0)
                        n = 0;
                    if (n != selected)
                    {
                        selected = n;
                        top = selected;
                        OnSelectionChanged();
                        SetNeedsDisplay();
                    }
                    return true;

                case Key.Space:
                case Key.T | Key.CtrlMask:
                    PerformMultipleSelection();
                    return true;

                case Key.Home:
                    MoveFirst();
                    return true;

                case Key.End:
                    MoveLast();
                    return true;
            }
            return base.ProcessKey(keyEvent);
        }

        void MoveLast()
        {
            selected = infos.Count - 1;
            top = infos.Count() - 1;
            OnSelectionChanged();
            SetNeedsDisplay();
        }

        void MoveFirst()
        {
            selected = 0;
            top = 0;
            OnSelectionChanged();
            SetNeedsDisplay();
        }

        void MoveDown()
        {
            if (selected + 1 < infos.Count)
            {
                selected++;
                if (selected >= top + Frame.Height)
                    top++;
                OnSelectionChanged();
                SetNeedsDisplay();
            }
        }

        void MoveUp()
        {
            if (selected > 0)
            {
                selected--;
                if (selected < top)
                    top = selected;
                OnSelectionChanged();
                SetNeedsDisplay();
            }
        }

        internal bool ExecuteSelection(bool navigateFolder = true)
        {
            if (infos.Count == 0)
            {
                return false;
            }
            var isDir = infos[selected].Item2;

            if (isDir)
            {
                Directory = Path.GetFullPath(Path.Combine(Path.GetFullPath(Directory.ToString()), infos[selected].Item1));
                DirectoryChanged?.Invoke(Directory);
                if (canChooseDirectories && !navigateFolder)
                {
                    return true;
                }
            }
            else
            {
                OnSelectionChanged();
                if (canChooseFiles)
                {
                    // Ensures that at least one file is selected.
                    if (FilePaths.Count == 0)
                        PerformMultipleSelection();
                    // Let the OK handler take it over
                    return true;
                }
                // No files allowed, do not let the default handler take it.
            }
            return false;
        }

        void PerformMultipleSelection(int? firstSelected = null)
        {
            if (allowsMultipleSelection)
            {
                int first = Math.Min(firstSelected ?? selected, selected);
                int last = Math.Max(selected, firstSelected ?? selected);
                for (int i = first; i <= last; i++)
                {
                    if ((canChooseFiles && infos[i].Item2 == false) ||
                        (canChooseDirectories && infos[i].Item2 &&
                         infos[i].Item1 != ".."))
                    {
                        infos[i] = (infos[i].Item1, infos[i].Item2, !infos[i].Item3);
                    }
                }
                OnSelectionChanged();
                SetNeedsDisplay();
            }
        }

        string[] allowedFileTypes;
        public string[] AllowedFileTypes
        {
            get => allowedFileTypes;
            set
            {
                allowedFileTypes = value;
                Reload();
            }
        }

        public string MakePath(string relativePath)
        {
            var dir = Directory.ToString();
            return string.IsNullOrEmpty(dir) ? "" : Path.GetFullPath(Path.Combine(dir, relativePath));
        }

        public IReadOnlyList<string> FilePaths
        {
            get
            {
                if (allowsMultipleSelection)
                {
                    var res = new List<string>();
                    foreach (var item in infos)
                    {
                        if (item.Item3)
                            res.Add(MakePath(item.Item1));
                    }
                    if (res.Count == 0 && infos.Count > 0 && infos[selected].Item1 != "..")
                    {
                        res.Add(MakePath(infos[selected].Item1));
                    }
                    return res;
                }
                else
                {
                    if (infos.Count == 0)
                    {
                        return null;
                    }
                    if (infos[selected].Item2)
                    {
                        if (canChooseDirectories)
                        {
                            var sel = infos[selected].Item1;
                            return sel == ".." ? new List<string>() : new List<string>() { MakePath(infos[selected].Item1) };
                        }
                        return Array.Empty<string>();
                    }
                    else
                    {
                        if (canChooseFiles)
                        {
                            return new List<string>() { MakePath(infos[selected].Item1) };
                        }
                        return Array.Empty<string>();
                    }
                }
            }
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }
    }

    //*master//
    public class DialogEventArgs : System.EventArgs
    {
        private decimal dialogResult;
        private FileDialog dialog;
        private string filePath;
        private string directoryPath;
        private ScriptEngine.HostedScript.Library.ArrayImpl filePaths;

        public DialogEventArgs(FileDialog d)
        {
            dialogResult = d.DialogResult;
            dialog = d;
            filePath = d.FilePath.ToString();
            directoryPath = d.DirectoryPath.ToString();
            if (d.GetType() == typeof(OpenDialog))
            {
                ScriptEngine.HostedScript.Library.ArrayImpl ArrayImpl1 = new ScriptEngine.HostedScript.Library.ArrayImpl();
                foreach (var file in ((OpenDialog)d).FilePaths)
                {
                    ArrayImpl1.Add(ScriptEngine.Machine.ValueFactory.Create(file));
                }
                filePaths = ArrayImpl1;
            }
            else
            {
                filePaths = null;
            }
        }

        public decimal DialogResult
        {
            get { return dialogResult; }
            set { dialogResult = value; }
        }

        public FileDialog Dialog
        {
            get { return dialog; }
            set { dialog = value; }
        }

        public string FilePath
        {
            get { return filePath; }
            set { filePath = value; }
        }

        public string DirectoryPath
        {
            get { return directoryPath; }
            set { directoryPath = value; }
        }

        public ScriptEngine.HostedScript.Library.ArrayImpl FilePaths
        {
            get { return filePaths; }
            set { filePaths = value; }
        }
    }
    //master*//

    /// <summary>
    /// Base class for the <see cref="OpenDialog"/> and the <see cref="SaveDialog"/>
    /// </summary>
    public class FileDialog : Dialog
    {
        //*master//
        public decimal DialogResult;
        public event EventHandler<DialogEventArgs> DialogClosed;
        public void OnDialogClosed(FileDialog fd)
        {
            var handler = DialogClosed;
            if (handler != null)
            {
                handler(this, new DialogEventArgs(fd));
            }
        }
        //master*//

        //*master//
        //////Button prompt, cancel;
        public Button prompt, cancel;
        //master*//
        Label nameFieldLabel, message, nameDirLabel;
        TextField dirEntry, nameEntry;
        internal DirListView dirListView;
        ComboBox cmbAllowedTypes;

        /// <summary>
        /// Initializes a new <see cref="FileDialog"/>.
        /// </summary>
        public FileDialog() : this(title: string.Empty, prompt: string.Empty,
            nameFieldLabel: string.Empty, message: string.Empty)
        { }

        /// <summary>
        /// Initializes a new instance of <see cref="FileDialog"/>
        /// </summary>
        /// <param name="title">The title.</param>
        /// <param name="prompt">The prompt.</param>
        /// <param name="nameFieldLabel">The name of the file field label..</param>
        /// <param name="message">The message.</param>
        /// <param name="allowedTypes">The allowed types.</param>
        public FileDialog(ustring title, ustring prompt, ustring nameFieldLabel, ustring message, List<string> allowedTypes = null)
            : this(title, prompt, ustring.Empty, nameFieldLabel, message, allowedTypes) { }

        /// <summary>
        /// Initializes a new instance of <see cref="FileDialog"/>
        /// </summary>
        /// <param name="title">The title.</param>
        /// <param name="prompt">The prompt.</param>
        /// <param name="message">The message.</param>
        /// <param name="allowedTypes">The allowed types.</param>
        public FileDialog(ustring title, ustring prompt, ustring message, List<string> allowedTypes)
            : this(title, prompt, ustring.Empty, message, allowedTypes) { }

        /// <summary>
        /// Initializes a new instance of <see cref="FileDialog"/>
        /// </summary>
        /// <param name="title">The title.</param>
        /// <param name="prompt">The prompt.</param>
        /// <param name="nameDirLabel">The name of the directory field label.</param>
        /// <param name="nameFieldLabel">The name of the file field label..</param>
        /// <param name="message">The message.</param>
        /// <param name="allowedTypes">The allowed types.</param>
        public FileDialog(ustring title, ustring prompt, ustring nameDirLabel, ustring nameFieldLabel, ustring message,
            List<string> allowedTypes = null) : base(title)//, Driver.Cols - 20, Driver.Rows - 5, null)
        {
            this.message = new Label(message)
            {
                X = 1,
                Y = 0,
            };
            Add(this.message);
            var msgLines = TextFormatter.MaxLines(message, Driver.Cols - 20);

            this.nameDirLabel = new Label(nameDirLabel.IsEmpty ? $"{Strings.fdDirectory}: " : $"{nameDirLabel}: ")
            {
                X = 1,
                Y = 1 + msgLines,
                AutoSize = true
            };

            dirEntry = new TextField("")
            {
                X = Pos.Right(this.nameDirLabel),
                Y = 1 + msgLines,
                Width = Dim.Fill() - 1,
            };
            dirEntry.TextChanged += (e) =>
            {
                DirectoryPath = dirEntry.Text;
                nameEntry.Text = ustring.Empty;
            };
            Add(this.nameDirLabel, dirEntry);

            this.nameFieldLabel = new Label(nameFieldLabel.IsEmpty ? $"{Strings.fdFile}: " : $"{nameFieldLabel}: ")
            {
                X = 1,
                Y = 3 + msgLines,
                AutoSize = true
            };
            nameEntry = new TextField("")
            {
                X = Pos.Left(dirEntry),
                Y = 3 + msgLines,
                Width = Dim.Percent(70, true)
            };
            Add(this.nameFieldLabel, nameEntry);

            cmbAllowedTypes = new ComboBox()
            {
                X = Pos.Right(nameEntry) + 2,
                Y = Pos.Top(nameEntry),
                Width = Dim.Fill(1),
                Height = SetComboBoxHeight(allowedTypes),
                Text = allowedTypes?.Count > 0 ? allowedTypes[0] : string.Empty,
                SelectedItem = allowedTypes?.Count > 0 ? 0 : -1,
                ReadOnly = true,
                HideDropdownListOnClick = true
            };
            cmbAllowedTypes.SetSource(allowedTypes ?? new List<string>());
            cmbAllowedTypes.OpenSelectedItem += (e) =>
            {
                dirListView.AllowedFileTypes = cmbAllowedTypes.Text.ToString().Split(';');
                dirListView.Reload();
            };
            Add(cmbAllowedTypes);

            dirListView = new DirListView(this)
            {
                X = 1,
                Y = 3 + msgLines + 2,
                Width = Dim.Fill() - 1,
                Height = Dim.Fill() - 2,
            };
            DirectoryPath = Path.GetFullPath(Environment.CurrentDirectory);
            Add(dirListView);

            AllowedFileTypes = allowedTypes?.Count > 0 ? allowedTypes?.ToArray() : null;
            dirListView.DirectoryChanged = (dir) => { nameEntry.Text = ustring.Empty; dirEntry.Text = dir; };
            dirListView.FileChanged = (file) => nameEntry.Text = file == ".." ? "" : file;
            dirListView.SelectedChanged = (file) => nameEntry.Text = file.Item1 == ".." ? "" : file.Item1;
            this.cancel = new Button("Cancel");
            this.cancel.Clicked += () =>
            {
                //*master//
                //////Cancel();
                this.DialogResult = new ostgui.TfDialogResult().Cancel;
                OnDialogClosed(this);
                canceled = true;
                this.Visible = false;
                //master*//
            };
            AddButton(cancel);

            this.prompt = new Button(prompt.IsEmpty ? "Ok" : prompt)
            {
                IsDefault = true,
                Enabled = nameEntry.Text.IsEmpty ? false : true
            };
            this.prompt.Clicked += () =>
            {
                if (this is OpenDialog)
                {
                    if (!dirListView.GetValidFilesName(nameEntry.Text.ToString(), out string res))
                    {
                        nameEntry.Text = res;
                        dirListView.SetNeedsDisplay();
                        return;
                    }
                    if (!dirListView.canChooseDirectories && !dirListView.ExecuteSelection(false))
                    {
                        return;
                    }
                }
                else if (this is SaveDialog)
                {
                    var name = nameEntry.Text.ToString();
                    if (FilePath.IsEmpty || name.Split(',').Length > 1)
                    {
                        return;
                    }
                    var ext = name.EndsWith(cmbAllowedTypes.Text.ToString())
                        ? "" : cmbAllowedTypes.Text.ToString();
                    FilePath = Path.Combine(FilePath.ToString(), $"{name}{ext}");
                }
                canceled = false;

                //*master//
                //////Application.RequestStop();
                this.DialogResult = new ostgui.TfDialogResult().OK;
                OnDialogClosed(this);
                this.Visible = false;
                //master*//
            };
            AddButton(this.prompt);

            nameEntry.TextChanged += (e) =>
            {
                if (nameEntry.Text.IsEmpty)
                {
                    this.prompt.Enabled = false;
                }
                else
                {
                    this.prompt.Enabled = true;
                }
            };

            Width = Dim.Percent(80);
            Height = Dim.Percent(80);

            // On success, we will set this to false.
            canceled = true;

            KeyPress += (e) =>
            {
                if (e.KeyEvent.Key == Key.Esc)
                {
                    //*master//
                    //////Cancel();
                    this.DialogResult = new ostgui.TfDialogResult().Cancel;
                    OnDialogClosed(this);
                    canceled = true;
                    this.Visible = false;
                    //master*//

                    e.Handled = true;
                }
            };
            //*master//
            //////void Cancel()
            //////{
            //////    canceled = true;
            //////    Application.RequestStop();
            //////}
            //master*//
        }

        private static int SetComboBoxHeight(List<string> allowedTypes)
        {
            return allowedTypes != null ? Math.Min(allowedTypes.Count + 1, 8) : 8;
        }

        internal bool canceled;

        ///<inheritdoc/>
        public override void WillPresent()
        {
            base.WillPresent();
            dirListView.SetFocus();
        }

        //protected override void Dispose (bool disposing)
        //{
        //	message?.Dispose ();
        //	base.Dispose (disposing);
        //}

        /// <summary>
        /// Gets or sets the prompt label for the <see cref="Button"/> displayed to the user
        /// </summary>
        /// <value>The prompt.</value>
        public ustring Prompt
        {
            get => prompt.Text;
            set
            {
                prompt.Text = value;
            }
        }

        /// <summary>
        /// Gets or sets the name of the directory field label.
        /// </summary>
        /// <value>The name of the directory field label.</value>
        public ustring NameDirLabel
        {
            get => nameDirLabel.Text;
            set
            {
                nameDirLabel.Text = $"{value}: ";
            }
        }

        /// <summary>
        /// Gets or sets the name field label.
        /// </summary>
        /// <value>The name field label.</value>
        public ustring NameFieldLabel
        {
            get => nameFieldLabel.Text;
            set
            {
                nameFieldLabel.Text = $"{value}: ";
            }
        }

        /// <summary>
        /// Gets or sets the message displayed to the user, defaults to nothing
        /// </summary>
        /// <value>The message.</value>
        public ustring Message
        {
            get => message.Text;
            set
            {
                message.Text = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="FileDialog"/> can create directories.
        /// </summary>
        /// <value><c>true</c> if can create directories; otherwise, <c>false</c>.</value>
        public bool CanCreateDirectories { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="FileDialog"/> is extension hidden.
        /// </summary>
        /// <value><c>true</c> if is extension hidden; otherwise, <c>false</c>.</value>
        public bool IsExtensionHidden { get; set; }

        /// <summary>
        /// Gets or sets the directory path for this panel
        /// </summary>
        /// <value>The directory path.</value>
        public ustring DirectoryPath
        {
            get => dirEntry.Text;
            set
            {
                dirEntry.Text = value;
                dirListView.Directory = value;
            }
        }

        private string[] allowedFileTypes;

        /// <summary>
        /// The array of filename extensions allowed, or null if all file extensions are allowed.
        /// </summary>
        /// <value>The allowed file types.</value>
        public string[] AllowedFileTypes
        {
            get => allowedFileTypes;
            set
            {
                allowedFileTypes = value;
                var selected = cmbAllowedTypes.SelectedItem;
                cmbAllowedTypes.SetSource(value);
                cmbAllowedTypes.SelectedItem = selected > -1 ? selected : 0;
                SetComboBoxHeight(value?.ToList());
                dirListView.AllowedFileTypes = value != null
                    ? value[cmbAllowedTypes.SelectedItem].Split(';')
                    : null;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="FileDialog"/> allows the file to be saved with a different extension
        /// </summary>
        /// <value><c>true</c> if allows other file types; otherwise, <c>false</c>.</value>
        public bool AllowsOtherFileTypes { get; set; }

        /// <summary>
        /// The File path that is currently shown on the panel
        /// </summary>
        /// <value>The absolute file path for the file path entered.</value>
        public ustring FilePath
        {
            get => dirListView.MakePath(nameEntry.Text.ToString());
            set
            {
                nameEntry.Text = Path.GetFileName(value.ToString());
            }
        }

        /// <summary>
        /// Check if the dialog was or not canceled.
        /// </summary>
        public bool Canceled { get => canceled; }
    }

    /// <summary>
    ///  The <see cref="SaveDialog"/> provides an interactive dialog box for users to pick a file to 
    ///  save.
    /// </summary>
    /// <remarks>
    /// <para>
    ///   To use, create an instance of <see cref="SaveDialog"/>, and pass it to
    ///   <see cref="Application.Run(Func{Exception, bool})"/>. This will run the dialog modally,
    ///   and when this returns, the <see cref="FileName"/>property will contain the selected file name or 
    ///   null if the user canceled. 
    /// </para>
    /// </remarks>
    public class SaveDialog : FileDialog
    {
        //*master//
        // Добавил перевод надписи кнопки, так как односкрипт двуязычный.
        private int labelLanguage = 0;
        public int LabelLanguage
        {
            get { return labelLanguage; }
            set
            {
                if (value == 0)
                {
                    base.cancel.Text = "Отмена";
                }
                else
                {
                    base.cancel.Text = "Cancel";
                }
                labelLanguage = value;
            }
        }
        //master*//

        /// <summary>
        /// Initializes a new <see cref="SaveDialog"/>.
        /// </summary>
        public SaveDialog() : this(title: string.Empty, message: string.Empty) { }

        /// <summary>
        /// Initializes a new <see cref="SaveDialog"/>.
        /// </summary>
        /// <param name="title">The title.</param>
        /// <param name="message">The message.</param>
        /// <param name="allowedTypes">The allowed types.</param>
        public SaveDialog(ustring title, ustring message, List<string> allowedTypes = null)
            : base(title, prompt: Strings.fdSave, nameFieldLabel: $"{Strings.fdSaveAs}", message: message, allowedTypes) { }

        /// <summary>
        /// Gets the name of the file the user selected for saving, or null
        /// if the user canceled the <see cref="SaveDialog"/>.
        /// </summary>
        /// <value>The name of the file.</value>
        public ustring FileName
        {
            get
            {
                if (canceled)
                    return null;
                return Path.GetFileName(FilePath.ToString());
            }
        }
    }

    /// <summary>
    /// The <see cref="OpenDialog"/>provides an interactive dialog box for users to select files or directories.
    /// </summary>
    /// <remarks>
    /// <para>
    ///   The open dialog can be used to select files for opening, it can be configured to allow
    ///   multiple items to be selected (based on the AllowsMultipleSelection) variable and
    ///   you can control whether this should allow files or directories to be selected.
    /// </para>
    /// <para>
    ///   To use, create an instance of <see cref="OpenDialog"/>, and pass it to
    ///   <see cref="Application.Run(Func{Exception, bool})"/>. This will run the dialog modally,
    ///   and when this returns, the list of files will be available on the <see cref="FilePaths"/> property.
    /// </para>
    /// <para>
    /// To select more than one file, users can use the spacebar, or control-t.
    /// </para>
    /// </remarks>
    public class OpenDialog : FileDialog
    {
        OpenMode openMode;

        //*master//
        // Добавил перевод надписи кнопки, так как односкрипт двуязычный.
        private int labelLanguage = 0;
        public int LabelLanguage
        {
            get { return labelLanguage; }
            set
            {
                if (value == 0)
                {
                    base.cancel.Text = "Отмена";
                }
                else
                {
                    base.cancel.Text = "Cancel";
                }
                labelLanguage = value;
            }
        }
        //master*//

        /// <summary>
        /// Determine which <see cref="System.IO"/> type to open.
        /// </summary>
        public enum OpenMode
        {
            /// <summary>
            /// Opens only file or files.
            /// </summary>
            File,
            /// <summary>
            /// Opens only directory or directories.
            /// </summary>
            Directory,
            /// <summary>
            /// Opens files and directories.
            /// </summary>
            Mixed
        }

        /// <summary>
        /// Initializes a new <see cref="OpenDialog"/>.
        /// </summary>
        public OpenDialog() : this(title: string.Empty, message: string.Empty) { }

        /// <summary>
        /// Initializes a new <see cref="OpenDialog"/>.
        /// </summary>
        /// <param name="title">The title.</param>
        /// <param name="message">The message.</param>
        /// <param name="allowedTypes">The allowed types.</param>
        /// <param name="openMode">The open mode.</param>
        public OpenDialog(ustring title, ustring message, List<string> allowedTypes = null, OpenMode openMode = OpenMode.File) : base(title,
            prompt: openMode == OpenMode.File ? Strings.fdOpen : openMode == OpenMode.Directory ? Strings.fdSelectFolder : Strings.fdSelectMixed,
            nameFieldLabel: Strings.fdOpen, message: message, allowedTypes)
        {
            this.openMode = openMode;
            switch (openMode)
            {
                case OpenMode.File:
                    CanChooseFiles = true;
                    CanChooseDirectories = false;
                    break;
                case OpenMode.Directory:
                    CanChooseFiles = false;
                    CanChooseDirectories = true;
                    break;
                case OpenMode.Mixed:
                    CanChooseFiles = true;
                    CanChooseDirectories = true;
                    AllowsMultipleSelection = true;
                    break;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="Terminal.Gui.OpenDialog"/> can choose files.
        /// </summary>
        /// <value><c>true</c> if can choose files; otherwise, <c>false</c>.  Defaults to <c>true</c></value>
        public bool CanChooseFiles
        {
            get => dirListView.canChooseFiles;
            set
            {
                dirListView.canChooseFiles = value;
                dirListView.Reload();
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="OpenDialog"/> can choose directories.
        /// </summary>
        /// <value><c>true</c> if can choose directories; otherwise, <c>false</c> defaults to <c>false</c>.</value>
        public bool CanChooseDirectories
        {
            get => dirListView.canChooseDirectories;
            set
            {
                dirListView.canChooseDirectories = value;
                dirListView.Reload();
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="OpenDialog"/> allows multiple selection.
        /// </summary>
        /// <value><c>true</c> if allows multiple selection; otherwise, <c>false</c>, defaults to false.</value>
        public bool AllowsMultipleSelection
        {
            get => dirListView.allowsMultipleSelection;
            set
            {
                if (!value && openMode == OpenMode.Mixed)
                {
                    return;
                }
                dirListView.allowsMultipleSelection = value;
                dirListView.Reload();
            }
        }

        /// <summary>
        /// Returns the selected files, or an empty list if nothing has been selected
        /// </summary>
        /// <value>The file paths.</value>
        public IReadOnlyList<string> FilePaths
        {
            get => dirListView.FilePaths;
        }
    }
    //=======================================================================
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //
    // NOTE: FrameView is functionally identical to Window with the following exceptions. 
    //  - Is not a Toplevel
    //  - Does not support mouse dragging
    //  - Does not support padding (but should)
    //  - Does not support IEnumerable
    // Any udpates done here should probably be done in Window as well; TODO: Merge these classes

    /// <summary>
    /// The FrameView is a container frame that draws a frame around the contents. It is similar to
    /// a GroupBox in Windows.
    /// </summary>
    public class FrameView : View
    {
        View contentView;
        ustring title;

        /// <summary>
        /// The title to be displayed for this <see cref="FrameView"/>.
        /// </summary>
        /// <value>The title.</value>
        public ustring Title
        {
            get => title;
            set
            {
                title = value;
                if (Border != null)
                {
                    Border.Title = title;
                }
                SetNeedsDisplay();
            }
        }

        /// <inheritdoc/>
        public override Border Border
        {
            get => base.Border;
            set
            {
                if (base.Border != null && base.Border.Child != null && value.Child == null)
                {
                    value.Child = base.Border.Child;
                }
                base.Border = value;
                if (value == null)
                {
                    return;
                }
                Rect frame;
                if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
                {
                    frame = Rect.Empty;
                }
                else
                {
                    frame = Frame;
                }
                AdjustContentView(frame);

                Border.BorderChanged += Border_BorderChanged;
            }
        }

        void Border_BorderChanged(Border border)
        {
            Rect frame;
            if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
            {
                frame = Rect.Empty;
            }
            else
            {
                frame = Frame;
            }
            AdjustContentView(frame);
        }

        /// <summary>
        /// ContentView is an internal implementation detail of Window. It is used to host Views added with <see cref="Add(View)"/>. 
        /// Its ONLY reason for being is to provide a simple way for Window to expose to those SubViews that the Window's Bounds 
        /// are actually deflated due to the border. 
        /// </summary>
        class ContentView : View
        {
            public ContentView(Rect frame) : base(frame) { }
            public ContentView() : base() { }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.FrameView"/> class using <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <param name="frame">Frame.</param>
        /// <param name="title">Title.</param>
        /// <param name="views">Views.</param>
        /// <param name="border">The <see cref="Border"/>.</param>
        public FrameView(Rect frame, ustring title = null, View[] views = null, Border border = null) : base(frame)
        {
            //var cFrame = new Rect (1, 1, Math.Max (frame.Width - 2, 0), Math.Max (frame.Height - 2, 0));
            Initialize(frame, title, views, border);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.FrameView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <param name="title">Title.</param>
        /// <param name="border">The <see cref="Border"/>.</param>
        public FrameView(ustring title, Border border = null)
        {
            Initialize(Rect.Empty, title, null, border);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.FrameView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        public FrameView() : this(title: string.Empty) { }

        void Initialize(Rect frame, ustring title, View[] views = null, Border border = null)
        {
            if (title == null) title = ustring.Empty;
            this.Title = title;
            if (border == null)
            {
                Border = new Border()
                {
                    BorderStyle = BorderStyle.Single,
                    Title = title
                };
            }
            else
            {
                Border = border;
                if (ustring.IsNullOrEmpty(border.Title))
                {
                    border.Title = title;
                }
            }
            AdjustContentView(frame, views);
        }

        void AdjustContentView(Rect frame, View[] views = null)
        {
            var borderLength = Border.DrawMarginFrame ? 1 : 0;
            var sumPadding = Border.GetSumThickness();
            var wp = new Point();
            var wb = new Size();
            if (frame == Rect.Empty)
            {
                wp.X = borderLength + sumPadding.Left;
                wp.Y = borderLength + sumPadding.Top;
                wb.Width = borderLength + sumPadding.Right;
                wb.Height = borderLength + sumPadding.Bottom;
                if (contentView == null)
                {
                    contentView = new ContentView()
                    {
                        X = wp.X,
                        Y = wp.Y,
                        Width = Dim.Fill(wb.Width),
                        Height = Dim.Fill(wb.Height)
                    };
                }
                else
                {
                    contentView.X = wp.X;
                    contentView.Y = wp.Y;
                    contentView.Width = Dim.Fill(wb.Width);
                    contentView.Height = Dim.Fill(wb.Height);
                }
            }
            else
            {
                wb.Width = (2 * borderLength) + sumPadding.Right + sumPadding.Left;
                wb.Height = (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
                var cFrame = new Rect(borderLength + sumPadding.Left, borderLength + sumPadding.Top, frame.Width - wb.Width, frame.Height - wb.Height);
                if (contentView == null)
                {
                    contentView = new ContentView(cFrame);
                }
                else
                {
                    contentView.Frame = cFrame;
                }
            }
            if (views != null)
            {
                foreach (var view in views)
                {
                    contentView.Add(view);
                }
            }
            if (Subviews?.Count == 0)
            {
                base.Add(contentView);
                contentView.Text = base.Text;
            }
            Border.Child = contentView;
        }

        void DrawFrame()
        {
            DrawFrame(new Rect(0, 0, Frame.Width, Frame.Height), 0, fill: true);
        }

        /// <summary>
        /// Add the specified <see cref="View"/> to this container.
        /// </summary>
        /// <param name="view"><see cref="View"/> to add to this container</param>
        public override void Add(View view)
        {
            contentView.Add(view);
            if (view.CanFocus)
                CanFocus = true;
        }


        /// <summary>
        ///   Removes a <see cref="View"/> from this container.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public override void Remove(View view)
        {
            if (view == null)
                return;

            SetNeedsDisplay();
            var touched = view.Frame;
            if (view == contentView)
            {
                base.Remove(view);
            }
            else
            {
                contentView.Remove(view);
            }

            if (contentView.InternalSubviews.Count < 1)
                this.CanFocus = false;
        }

        /// <summary>
        ///   Removes all <see cref="View"/>s from this container.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public override void RemoveAll()
        {
            contentView.RemoveAll();
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            if (!NeedDisplay.IsEmpty)
            {
                Driver.SetAttribute(GetNormalColor());
                Clear();
            }

            var savedClip = contentView.ClipToBounds();
            contentView.Redraw(!NeedDisplay.IsEmpty ? contentView.Bounds : bounds);
            Driver.Clip = savedClip;

            ClearLayoutNeeded();
            ClearNeedsDisplay();

            Driver.SetAttribute(GetNormalColor());
            Border.DrawContent(this, false);
        }

        /// <summary>
        ///   The text displayed by the <see cref="Label"/>.
        /// </summary>
        public override ustring Text
        {
            get => contentView?.Text;
            set
            {
                base.Text = value;
                if (contentView != null)
                {
                    contentView.Text = value;
                }
            }
        }

        /// <summary>
        /// Controls the text-alignment property of the label, changing it will redisplay the <see cref="Label"/>.
        /// </summary>
        /// <value>The text alignment.</value>
        public override TextAlignment TextAlignment
        {
            get => contentView.TextAlignment;
            set
            {
                base.TextAlignment = contentView.TextAlignment = value;
            }
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            if (Subviews.Count == 0 || !Subviews.Any(subview => subview.CanFocus))
            {
                Application.Driver?.SetCursorVisibility(CursorVisibility.Invisible);
            }

            return base.OnEnter(view);
        }

        /// <inheritdoc/>
        public override void OnCanFocusChanged()
        {
            if (contentView != null)
            {
                contentView.CanFocus = CanFocus;
            }
            base.OnCanFocusChanged();
        }
    }
    //=======================================================================
    /// <summary>
    /// Control for rendering graphs (bar, scatter etc)
    /// </summary>
    public class GraphView : View
    {

        /// <summary>
        /// Horizontal axis
        /// </summary>
        /// <value></value>
        public HorizontalAxis AxisX { get; set; }

        /// <summary>
        /// Vertical axis
        /// </summary>
        /// <value></value>
        public VerticalAxis AxisY { get; set; }

        /// <summary>
        /// Collection of data series that are rendered in the graph
        /// </summary>
        public List<ISeries> Series { get; } = new List<ISeries>();


        /// <summary>
        /// Elements drawn into graph after series have been drawn e.g. Legends etc
        /// </summary>
        public List<IAnnotation> Annotations { get; } = new List<IAnnotation>();

        /// <summary>
        /// Amount of space to leave on left of control.  Graph content (<see cref="Series"/>)
        /// will not be rendered in margins but axis labels may be
        /// </summary>
        public uint MarginLeft { get; set; }

        /// <summary>
        /// Amount of space to leave on bottom of control.  Graph content (<see cref="Series"/>)
        /// will not be rendered in margins but axis labels may be
        /// </summary>
        public uint MarginBottom { get; set; }

        /// <summary>
        /// The graph space position of the bottom left of the control.
        /// Changing this scrolls the viewport around in the graph
        /// </summary>
        /// <value></value>
        public PointF ScrollOffset { get; set; } = new PointF(0, 0);

        /// <summary>
        /// Translates console width/height into graph space. Defaults
        /// to 1 row/col of console space being 1 unit of graph space. 
        /// </summary>
        /// <returns></returns>
        public PointF CellSize { get; set; } = new PointF(1, 1);

        /// <summary>
        /// The color of the background of the graph and axis/labels
        /// </summary>
        public Attribute? GraphColor { get; set; }

        /// <summary>
        /// Creates a new graph with a 1 to 1 graph space with absolute layout
        /// </summary>
        public GraphView()
        {
            CanFocus = true;

            AxisX = new HorizontalAxis();
            AxisY = new VerticalAxis();

            // Things this view knows how to do
            AddCommand(Command.ScrollUp, () => { Scroll(0, CellSize.Y); return true; });
            AddCommand(Command.ScrollDown, () => { Scroll(0, -CellSize.Y); return true; });
            AddCommand(Command.ScrollRight, () => { Scroll(CellSize.X, 0); return true; });
            AddCommand(Command.ScrollLeft, () => { Scroll(-CellSize.X, 0); return true; });
            AddCommand(Command.PageUp, () => { PageUp(); return true; });
            AddCommand(Command.PageDown, () => { PageDown(); return true; });

            AddKeyBinding(Key.CursorRight, Command.ScrollRight);
            AddKeyBinding(Key.CursorLeft, Command.ScrollLeft);
            AddKeyBinding(Key.CursorUp, Command.ScrollUp);
            AddKeyBinding(Key.CursorDown, Command.ScrollDown);

            // Not bound by default (preserves backwards compatibility)
            //AddKeyBinding (Key.PageUp, Command.PageUp);
            //AddKeyBinding (Key.PageDown, Command.PageDown);
        }

        /// <summary>
        /// Clears all settings configured on the graph and resets all properties
        /// to default values (<see cref="CellSize"/>, <see cref="ScrollOffset"/> etc) 
        /// </summary>
        public void Reset()
        {
            ScrollOffset = new PointF(0, 0);
            CellSize = new PointF(1, 1);
            AxisX.Reset();
            AxisY.Reset();
            Series.Clear();
            Annotations.Clear();
            GraphColor = null;
            SetNeedsDisplay();
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            if (CellSize.X == 0 || CellSize.Y == 0)
            {
                throw new Exception($"{nameof(CellSize)} cannot be 0");
            }

            SetDriverColorToGraphColor();

            Move(0, 0);

            // clear all old content
            for (int i = 0; i < Bounds.Height; i++)
            {
                Move(0, i);
                Driver.AddStr(new string(' ', Bounds.Width));
            }

            // If there is no data do not display a graph
            if (!Series.Any() && !Annotations.Any())
            {
                return;
            }

            // The drawable area of the graph (anything that isn't in the margins)
            var graphScreenWidth = Bounds.Width - ((int)MarginLeft);
            var graphScreenHeight = Bounds.Height - (int)MarginBottom;

            // if the margins take up the full draw bounds don't render
            if (graphScreenWidth < 0 || graphScreenHeight < 0)
            {
                return;
            }

            // Draw 'before' annotations
            foreach (var a in Annotations.ToArray().Where(a => a.BeforeSeries))
            {
                a.Render(this);
            }

            SetDriverColorToGraphColor();

            AxisY.DrawAxisLine(this);
            AxisX.DrawAxisLine(this);

            AxisY.DrawAxisLabels(this);
            AxisX.DrawAxisLabels(this);

            // Draw a cross where the two axis cross
            var axisIntersection = new Point(AxisY.GetAxisXPosition(this), AxisX.GetAxisYPosition(this));

            if (AxisX.Visible && AxisY.Visible)
            {
                Move(axisIntersection.X, axisIntersection.Y);
                AddRune(axisIntersection.X, axisIntersection.Y, '\u253C');
            }

            SetDriverColorToGraphColor();


            Rect drawBounds = new Rect((int)MarginLeft, 0, graphScreenWidth, graphScreenHeight);

            RectangleF graphSpace = ScreenToGraphSpace(drawBounds);

            foreach (var s in Series.ToArray())
            {

                s.DrawSeries(this, drawBounds, graphSpace);

                // If a series changes the graph color reset it
                SetDriverColorToGraphColor();
            }

            SetDriverColorToGraphColor();

            // Draw 'after' annotations
            foreach (var a in Annotations.ToArray().Where(a => !a.BeforeSeries))
            {
                a.Render(this);
            }

        }

        /// <summary>
        /// Sets the color attribute of <see cref="Application.Driver"/> to the <see cref="GraphColor"/>
        /// (if defined) or <see cref="ColorScheme"/> otherwise.
        /// </summary>
        public void SetDriverColorToGraphColor()
        {
            Driver.SetAttribute(GraphColor ?? (GetNormalColor()));
        }

        /// <summary>
        /// Returns the section of the graph that is represented by the given
        /// screen position
        /// </summary>
        /// <param name="col"></param>
        /// <param name="row"></param>
        /// <returns></returns>
        public RectangleF ScreenToGraphSpace(int col, int row)
        {
            return new RectangleF(
                ScrollOffset.X + ((col - MarginLeft) * CellSize.X),
                ScrollOffset.Y + ((Bounds.Height - (row + MarginBottom + 1)) * CellSize.Y),
                CellSize.X, CellSize.Y);
        }


        /// <summary>
        /// Returns the section of the graph that is represented by the screen area
        /// </summary>
        /// <param name="screenArea"></param>
        /// <returns></returns>
        public RectangleF ScreenToGraphSpace(Rect screenArea)
        {
            // get position of the bottom left
            var pos = ScreenToGraphSpace(screenArea.Left, screenArea.Bottom - 1);

            return new RectangleF(pos.X, pos.Y, screenArea.Width * CellSize.X, screenArea.Height * CellSize.Y);
        }
        /// <summary>
        /// Calculates the screen location for a given point in graph space.
        /// Bear in mind these be off screen
        /// </summary>
        /// <param name="location">Point in graph space that may or may not be represented in the
        /// visible area of graph currently presented.  E.g. 0,0 for origin</param>
        /// <returns>Screen position (Column/Row) which would be used to render the graph <paramref name="location"/>.
        /// Note that this can be outside the current client area of the control</returns>
        public Point GraphSpaceToScreen(PointF location)
        {
            return new Point(

                (int)((location.X - ScrollOffset.X) / CellSize.X) + (int)MarginLeft,
                 // screen coordinates are top down while graph coordinates are bottom up
                 (Bounds.Height - 1) - (int)MarginBottom - (int)((location.Y - ScrollOffset.Y) / CellSize.Y)
                );
        }

        /// <inheritdoc/>
        /// <remarks>Also ensures that cursor is invisible after entering the <see cref="GraphView"/>.</remarks>
        public override bool OnEnter(View view)
        {
            Driver.SetCursorVisibility(CursorVisibility.Invisible);
            return base.OnEnter(view);
        }

        /// <inheritdoc/>
        public override bool ProcessKey(KeyEvent keyEvent)
        {
            if (HasFocus && CanFocus)
            {
                var result = InvokeKeybindings(keyEvent);
                if (result != null)
                    return (bool)result;
            }

            return base.ProcessKey(keyEvent);
        }

        /// <summary>
        /// Scrolls the graph up 1 page
        /// </summary>
        public void PageUp()
        {
            Scroll(0, CellSize.Y * Bounds.Height);
        }

        /// <summary>
        /// Scrolls the graph down 1 page
        /// </summary>
        public void PageDown()
        {
            Scroll(0, -1 * CellSize.Y * Bounds.Height);
        }
        /// <summary>
        /// Scrolls the view by a given number of units in graph space.
        /// See <see cref="CellSize"/> to translate this into rows/cols
        /// </summary>
        /// <param name="offsetX"></param>
        /// <param name="offsetY"></param>
        public void Scroll(float offsetX, float offsetY)
        {
            ScrollOffset = new PointF(
                ScrollOffset.X + offsetX,
                ScrollOffset.Y + offsetY);

            SetNeedsDisplay();
        }


        #region Bresenham's line algorithm
        // https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C.23

        int ipart(decimal x) { return (int)x; }


        decimal fpart(decimal x)
        {
            if (x < 0) return (1 - (x - Math.Floor(x)));
            return (x - Math.Floor(x));
        }

        /// <summary>
        /// Draws a line between two points in screen space.  Can be diagonals.
        /// </summary>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="symbol">The symbol to use for the line</param>
        public void DrawLine(Point start, Point end, Rune symbol)
        {
            if (Equals(start, end))
            {
                return;
            }

            int x0 = start.X;
            int y0 = start.Y;
            int x1 = end.X;
            int y1 = end.Y;

            int dx = Math.Abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
            int dy = Math.Abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
            int err = (dx > dy ? dx : -dy) / 2, e2;

            while (true)
            {

                AddRune(x0, y0, symbol);

                if (x0 == x1 && y0 == y1) break;
                e2 = err;
                if (e2 > -dx) { err -= dy; x0 += sx; }
                if (e2 < dy) { err += dx; y0 += sy; }
            }
        }

        #endregion
    }
    //=======================================================================
    //
    // HexView.cs: A hexadecimal viewer
    //
    // TODO:
    // - Support searching and highlighting of the search result
    // - Bug showing the last line
    // 

    /// <summary>
    /// An hex viewer and editor <see cref="View"/> over a <see cref="System.IO.Stream"/>
    /// </summary>
    /// <remarks>
    /// <para>
    /// <see cref="HexView"/> provides a hex editor on top of a seekable <see cref="Stream"/> with the left side showing an hex
    /// dump of the values in the <see cref="Stream"/> and the right side showing the contents (filtered to 
    /// non-control sequence ASCII characters).    
    /// </para>
    /// <para>
    /// Users can switch from one side to the other by using the tab key.  
    /// </para>
    /// <para>
    /// To enable editing, set <see cref="AllowEdits"/> to true. When <see cref="AllowEdits"/> is true 
    /// the user can make changes to the hexadecimal values of the <see cref="Stream"/>. Any changes are tracked
    /// in the <see cref="Edits"/> property (a <see cref="SortedDictionary{TKey, TValue}"/>) indicating 
    /// the position where the changes were made and the new values. A convenience method, <see cref="ApplyEdits"/>
    /// will apply the edits to the <see cref="Stream"/>.
    /// </para>
    /// <para>
    /// Control the first byte shown by setting the <see cref="DisplayStart"/> property 
    /// to an offset in the stream.
    /// </para>
    /// </remarks>
    public class HexView : View
    {
        SortedDictionary<long, byte> edits = new SortedDictionary<long, byte>();
        Stream source;
        long displayStart, pos;
        bool firstNibble, leftSide;

        private long position
        {
            get => pos;
            set
            {
                pos = value;
                OnPositionChanged();
            }
        }

        /// <summary>
        /// Initializes a <see cref="HexView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <param name="source">The <see cref="Stream"/> to view and edit as hex, this <see cref="Stream"/> must support seeking, or an exception will be thrown.</param>
        public HexView(Stream source) : base()
        {
            Source = source;
            CanFocus = true;
            leftSide = true;
            firstNibble = true;

            // Things this view knows how to do
            AddCommand(Command.Left, () => MoveLeft());
            AddCommand(Command.Right, () => MoveRight());
            AddCommand(Command.LineDown, () => MoveDown(bytesPerLine));
            AddCommand(Command.LineUp, () => MoveUp(bytesPerLine));
            AddCommand(Command.ToggleChecked, () => ToggleSide());
            AddCommand(Command.PageUp, () => MoveUp(bytesPerLine * Frame.Height));
            AddCommand(Command.PageDown, () => MoveDown(bytesPerLine * Frame.Height));
            AddCommand(Command.TopHome, () => MoveHome());
            AddCommand(Command.BottomEnd, () => MoveEnd());
            AddCommand(Command.StartOfLine, () => MoveStartOfLine());
            AddCommand(Command.EndOfLine, () => MoveEndOfLine());
            AddCommand(Command.StartOfPage, () => MoveUp(bytesPerLine * ((int)(position - displayStart) / bytesPerLine)));
            AddCommand(Command.EndOfPage, () => MoveDown(bytesPerLine * (Frame.Height - 1 - ((int)(position - displayStart) / bytesPerLine))));

            // Default keybindings for this view
            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.CursorDown, Command.LineDown);
            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.Enter, Command.ToggleChecked);

            AddKeyBinding('v' + Key.AltMask, Command.PageUp);
            AddKeyBinding(Key.PageUp, Command.PageUp);

            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);
            AddKeyBinding(Key.PageDown, Command.PageDown);

            AddKeyBinding(Key.Home, Command.TopHome);
            AddKeyBinding(Key.End, Command.BottomEnd);
            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.StartOfLine);
            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.EndOfLine);
            AddKeyBinding(Key.CursorUp | Key.CtrlMask, Command.StartOfPage);
            AddKeyBinding(Key.CursorDown | Key.CtrlMask, Command.EndOfPage);
        }

        /// <summary>
        /// Initializes a <see cref="HexView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        public HexView() : this(source: new MemoryStream()) { }

        /// <summary>
        /// Event to be invoked when an edit is made on the <see cref="Stream"/>.
        /// </summary>
        public event Action<KeyValuePair<long, byte>> Edited;

        /// <summary>
        /// Event to be invoked when the position and cursor position changes.
        /// </summary>
        public event Action<HexViewEventArgs> PositionChanged;

        /// <summary>
        /// Sets or gets the <see cref="Stream"/> the <see cref="HexView"/> is operating on; the stream must support seeking (<see cref="Stream.CanSeek"/> == true).
        /// </summary>
        /// <value>The source.</value>
        public Stream Source
        {
            get => source;
            set
            {
                if (value == null)
                    throw new ArgumentNullException("source");
                if (!value.CanSeek)
                    throw new ArgumentException("The source stream must be seekable (CanSeek property)", "source");
                source = value;

                if (displayStart > source.Length)
                    DisplayStart = 0;
                if (position > source.Length)
                    position = 0;
                SetNeedsDisplay();
            }
        }

        internal void SetDisplayStart(long value)
        {
            if (value > 0 && value >= source.Length)
                displayStart = source.Length - 1;
            else if (value < 0)
                displayStart = 0;
            else
                displayStart = value;
            SetNeedsDisplay();
        }

        /// <summary>
        /// Sets or gets the offset into the <see cref="Stream"/> that will displayed at the top of the <see cref="HexView"/>
        /// </summary>
        /// <value>The display start.</value>
        public long DisplayStart
        {
            get => displayStart;
            set
            {
                position = value;

                SetDisplayStart(value);
            }
        }

        const int displayWidth = 9;
        const int bsize = 4;
        int bpl;
        private int bytesPerLine
        {
            get => bpl;
            set
            {
                bpl = value;
                OnPositionChanged();
            }
        }

        /// <inheritdoc/>
        public override Rect Frame
        {
            get => base.Frame;
            set
            {
                base.Frame = value;

                // Small buffers will just show the position, with the bsize field value (4 bytes)
                bytesPerLine = bsize;
                if (value.Width - displayWidth > 17)
                    bytesPerLine = bsize * ((value.Width - displayWidth) / 18);
            }
        }

        //
        // This is used to support editing of the buffer on a peer List<>, 
        // the offset corresponds to an offset relative to DisplayStart, and
        // the buffer contains the contents of a screenful of data, so the 
        // offset is relative to the buffer.
        //
        // 
        byte GetData(byte[] buffer, int offset, out bool edited)
        {
            var pos = DisplayStart + offset;
            if (edits.TryGetValue(pos, out byte v))
            {
                edited = true;
                return v;
            }
            edited = false;
            return buffer[offset];
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            Attribute currentAttribute;
            var current = ColorScheme.Focus;
            Driver.SetAttribute(current);
            Move(0, 0);

            var frame = Frame;

            var nblocks = bytesPerLine / bsize;
            var data = new byte[nblocks * bsize * frame.Height];
            Source.Position = displayStart;
            var n = source.Read(data, 0, data.Length);

            int activeColor = ColorScheme.HotNormal;
            int trackingColor = ColorScheme.HotFocus;

            for (int line = 0; line < frame.Height; line++)
            {
                var lineRect = new Rect(0, line, frame.Width, 1);
                if (!bounds.Contains(lineRect))
                    continue;

                Move(0, line);
                Driver.SetAttribute(ColorScheme.HotNormal);
                Driver.AddStr(string.Format("{0:x8} ", displayStart + line * nblocks * bsize));

                currentAttribute = ColorScheme.HotNormal;
                SetAttribute(GetNormalColor());

                for (int block = 0; block < nblocks; block++)
                {
                    for (int b = 0; b < bsize; b++)
                    {
                        var offset = (line * nblocks * bsize) + block * bsize + b;
                        var value = GetData(data, offset, out bool edited);
                        if (offset + displayStart == position || edited)
                            SetAttribute(leftSide ? activeColor : trackingColor);
                        else
                            SetAttribute(GetNormalColor());

                        Driver.AddStr(offset >= n && !edited ? "  " : string.Format("{0:x2}", value));
                        SetAttribute(GetNormalColor());
                        Driver.AddRune(' ');
                    }
                    Driver.AddStr(block + 1 == nblocks ? " " : "| ");
                }

                for (int bitem = 0; bitem < nblocks * bsize; bitem++)
                {
                    var offset = line * nblocks * bsize + bitem;
                    var b = GetData(data, offset, out bool edited);
                    Rune c;
                    if (offset >= n && !edited)
                        c = ' ';
                    else
                    {
                        if (b < 32)
                            c = '.';
                        else if (b > 127)
                            c = '.';
                        else
                            c = b;
                    }
                    if (offset + displayStart == position || edited)
                        SetAttribute(leftSide ? trackingColor : activeColor);
                    else
                        SetAttribute(GetNormalColor());

                    Driver.AddRune(c);
                }
            }

            void SetAttribute(Attribute attribute)
            {
                if (currentAttribute != attribute)
                {
                    currentAttribute = attribute;
                    Driver.SetAttribute(attribute);
                }
            }
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            var delta = (int)(position - displayStart);
            var line = delta / bytesPerLine;
            var item = delta % bytesPerLine;
            var block = item / bsize;
            var column = (item % bsize) * 3;

            if (leftSide)
                Move(displayWidth + block * 14 + column + (firstNibble ? 0 : 1), line);
            else
                Move(displayWidth + (bytesPerLine / bsize) * 14 + item - 1, line);
        }

        void RedisplayLine(long pos)
        {
            var delta = (int)(pos - DisplayStart);
            var line = delta / bytesPerLine;

            SetNeedsDisplay(new Rect(0, line, Frame.Width, 1));
        }

        bool MoveEndOfLine()
        {
            position = Math.Min((position / bytesPerLine * bytesPerLine) + bytesPerLine - 1, source.Length);
            SetNeedsDisplay();

            return true;
        }

        bool MoveStartOfLine()
        {
            position = position / bytesPerLine * bytesPerLine;
            SetNeedsDisplay();

            return true;
        }

        bool MoveEnd()
        {
            position = source.Length;
            if (position >= (DisplayStart + bytesPerLine * Frame.Height))
            {
                SetDisplayStart(position);
                SetNeedsDisplay();
            }
            else
                RedisplayLine(position);

            return true;
        }

        bool MoveHome()
        {
            DisplayStart = 0;
            SetNeedsDisplay();

            return true;
        }

        bool ToggleSide()
        {
            leftSide = !leftSide;
            RedisplayLine(position);
            firstNibble = true;

            return true;
        }

        bool MoveLeft()
        {
            RedisplayLine(position);
            if (leftSide)
            {
                if (!firstNibble)
                {
                    firstNibble = true;
                    return true;
                }
                firstNibble = false;
            }
            if (position == 0)
                return true;
            if (position - 1 < DisplayStart)
            {
                SetDisplayStart(displayStart - bytesPerLine);
                SetNeedsDisplay();
            }
            else
                RedisplayLine(position);
            position--;

            return true;
        }

        bool MoveRight()
        {
            RedisplayLine(position);
            if (leftSide)
            {
                if (firstNibble)
                {
                    firstNibble = false;
                    return true;
                }
                else
                    firstNibble = true;
            }
            if (position < source.Length)
                position++;
            if (position >= (DisplayStart + bytesPerLine * Frame.Height))
            {
                SetDisplayStart(DisplayStart + bytesPerLine);
                SetNeedsDisplay();
            }
            else
                RedisplayLine(position);

            return true;
        }

        bool MoveUp(int bytes)
        {
            RedisplayLine(position);
            if (position - bytes > -1)
                position -= bytes;
            if (position < DisplayStart)
            {
                SetDisplayStart(DisplayStart - bytes);
                SetNeedsDisplay();
            }
            else
                RedisplayLine(position);

            return true;
        }

        bool MoveDown(int bytes)
        {
            RedisplayLine(position);
            if (position + bytes < source.Length)
                position += bytes;
            else if ((bytes == bytesPerLine * Frame.Height && source.Length >= (DisplayStart + bytesPerLine * Frame.Height))
                || (bytes <= (bytesPerLine * Frame.Height - bytesPerLine) && source.Length <= (DisplayStart + bytesPerLine * Frame.Height)))
            {
                var p = position;
                while (p + bytesPerLine < source.Length)
                {
                    p += bytesPerLine;
                }
                position = p;
            }
            if (position >= (DisplayStart + bytesPerLine * Frame.Height))
            {
                SetDisplayStart(DisplayStart + bytes);
                SetNeedsDisplay();
            }
            else
                RedisplayLine(position);

            return true;
        }

        /// <inheritdoc/>
        public override bool ProcessKey(KeyEvent keyEvent)
        {
            var result = InvokeKeybindings(keyEvent);
            if (result != null)
                return (bool)result;

            if (!AllowEdits)
                return false;

            // Ignore control characters and other special keys
            if (keyEvent.Key < Key.Space || keyEvent.Key > Key.CharMask)
                return false;

            if (leftSide)
            {
                int value;
                var k = (char)keyEvent.Key;
                if (k >= 'A' && k <= 'F')
                    value = k - 'A' + 10;
                else if (k >= 'a' && k <= 'f')
                    value = k - 'a' + 10;
                else if (k >= '0' && k <= '9')
                    value = k - '0';
                else
                    return false;

                byte b;
                if (!edits.TryGetValue(position, out b))
                {
                    source.Position = position;
                    b = (byte)source.ReadByte();
                }
                RedisplayLine(position);
                if (firstNibble)
                {
                    firstNibble = false;
                    b = (byte)(b & 0xf | (value << bsize));
                    edits[position] = b;
                    OnEdited(new KeyValuePair<long, byte>(position, edits[position]));
                }
                else
                {
                    b = (byte)(b & 0xf0 | value);
                    edits[position] = b;
                    OnEdited(new KeyValuePair<long, byte>(position, edits[position]));
                    MoveRight();
                }
                return true;
            }
            else
                return false;
        }

        /// <summary>
        /// Method used to invoke the <see cref="Edited"/> event passing the <see cref="KeyValuePair{TKey, TValue}"/>.
        /// </summary>
        /// <param name="keyValuePair">The key value pair.</param>
        public virtual void OnEdited(KeyValuePair<long, byte> keyValuePair)
        {
            Edited?.Invoke(keyValuePair);
        }

        /// <summary>
        /// Method used to invoke the <see cref="PositionChanged"/> event passing the <see cref="HexViewEventArgs"/> arguments.
        /// </summary>
        public virtual void OnPositionChanged()
        {
            PositionChanged?.Invoke(new HexViewEventArgs(Position, CursorPosition, BytesPerLine));
        }

        /// <inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) && !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked)
                && !me.Flags.HasFlag(MouseFlags.WheeledDown) && !me.Flags.HasFlag(MouseFlags.WheeledUp))
                return false;

            if (!HasFocus)
                SetFocus();

            if (me.Flags == MouseFlags.WheeledDown)
            {
                DisplayStart = Math.Min(DisplayStart + bytesPerLine, source.Length);
                return true;
            }

            if (me.Flags == MouseFlags.WheeledUp)
            {
                DisplayStart = Math.Max(DisplayStart - bytesPerLine, 0);
                return true;
            }

            if (me.X < displayWidth)
                return true;
            var nblocks = bytesPerLine / bsize;
            var blocksSize = nblocks * 14;
            var blocksRightOffset = displayWidth + blocksSize - 1;
            if (me.X > blocksRightOffset + bytesPerLine - 1)
                return true;
            leftSide = me.X >= blocksRightOffset;
            var lineStart = (me.Y * bytesPerLine) + displayStart;
            var x = me.X - displayWidth + 1;
            var block = x / 14;
            x -= block * 2;
            var empty = x % 3;
            var item = x / 3;
            if (!leftSide && item > 0 && (empty == 0 || x == (block * 14) + 14 - 1 - (block * 2)))
                return true;
            firstNibble = true;
            if (leftSide)
                position = Math.Min(lineStart + me.X - blocksRightOffset, source.Length);
            else
                position = Math.Min(lineStart + item, source.Length);

            if (me.Flags == MouseFlags.Button1DoubleClicked)
            {
                leftSide = !leftSide;
                if (leftSide)
                    firstNibble = empty == 1;
                else
                    firstNibble = true;
            }
            SetNeedsDisplay();

            return true;
        }

        /// <summary>
        /// Gets or sets whether this <see cref="HexView"/> allow editing of the <see cref="Stream"/> 
        /// of the underlying <see cref="Stream"/>.
        /// </summary>
        /// <value><c>true</c> if allow edits; otherwise, <c>false</c>.</value>
        public bool AllowEdits { get; set; } = true;

        /// <summary>
        /// Gets a <see cref="SortedDictionary{TKey, TValue}"/> describing the edits done to the <see cref="HexView"/>. 
        /// Each Key indicates an offset where an edit was made and the Value is the changed byte.
        /// </summary>
        /// <value>The edits.</value>
        public IReadOnlyDictionary<long, byte> Edits => edits;

        /// <summary>
        /// Gets the current character position starting at one, related to the <see cref="Stream"/>.
        /// </summary>
        public long Position => position + 1;

        /// <summary>
        /// Gets the current cursor position starting at one for both, line and column.
        /// </summary>
        public Point CursorPosition
        {
            get
            {
                var delta = (int)position;
                var line = delta / bytesPerLine + 1;
                var item = delta % bytesPerLine + 1;

                return new Point(item, line);
            }
        }

        /// <summary>
        /// The bytes length per line.
        /// </summary>
        public int BytesPerLine => bytesPerLine;

        /// <summary>
        /// This method applies and edits made to the <see cref="Stream"/> and resets the 
        /// contents of the <see cref="Edits"/> property.
        /// </summary>
        /// <param name="stream">If provided also applies the changes to the passed <see cref="Stream"/></param>.
        public void ApplyEdits(Stream stream = null)
        {
            foreach (var kv in edits)
            {
                source.Position = kv.Key;
                source.WriteByte(kv.Value);
                source.Flush();
                if (stream != null)
                {
                    stream.Position = kv.Key;
                    stream.WriteByte(kv.Value);
                    stream.Flush();
                }
            }
            edits = new SortedDictionary<long, byte>();
            SetNeedsDisplay();
        }

        /// <summary>
        /// This method discards the edits made to the <see cref="Stream"/> by resetting the 
        /// contents of the <see cref="Edits"/> property.
        /// </summary>
        public void DiscardEdits()
        {
            edits = new SortedDictionary<long, byte>();
        }

        private CursorVisibility desiredCursorVisibility = CursorVisibility.Default;

        /// <summary>
        /// Get / Set the wished cursor when the field is focused
        /// </summary>
        public CursorVisibility DesiredCursorVisibility
        {
            get => desiredCursorVisibility;
            set
            {
                if (desiredCursorVisibility != value && HasFocus)
                {
                    Application.Driver.SetCursorVisibility(value);
                }

                desiredCursorVisibility = value;
            }
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);

            return base.OnEnter(view);
        }

        /// <summary>
        /// Defines the event arguments for <see cref="PositionChanged"/> event.
        /// </summary>
        public class HexViewEventArgs : EventArgs
        {
            /// <summary>
            /// Gets the current character position starting at one, related to the <see cref="Stream"/>.
            /// </summary>
            public long Position { get; private set; }
            /// <summary>
            /// Gets the current cursor position starting at one for both, line and column.
            /// </summary>
            public Point CursorPosition { get; private set; }

            /// <summary>
            /// The bytes length per line.
            /// </summary>
            public int BytesPerLine { get; private set; }

            /// <summary>
            /// Initializes a new instance of <see cref="HexViewEventArgs"/>
            /// </summary>
            /// <param name="pos">The character position.</param>
            /// <param name="cursor">The cursor position.</param>
            /// <param name="lineLength">Line bytes length.</param>
            public HexViewEventArgs(long pos, Point cursor, int lineLength)
            {
                Position = pos;
                CursorPosition = cursor;
                BytesPerLine = lineLength;
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Renders an overlay on another view at a given point that allows selecting
    /// from a range of 'autocomplete' options.
    /// </summary>
    public interface IAutocomplete
    {

        /// <summary>
        /// The host control that will use autocomplete.
        /// </summary>
        View HostControl { get; set; }

        /// <summary>
        /// Gets or sets where the popup will be displayed.
        /// </summary>
        bool PopupInsideContainer { get; set; }

        /// <summary>
        /// The maximum width of the autocomplete dropdown
        /// </summary>
        int MaxWidth { get; set; }

        /// <summary>
        /// The maximum number of visible rows in the autocomplete dropdown to render
        /// </summary>
        int MaxHeight { get; set; }

        /// <summary>
        /// True if the autocomplete should be considered open and visible
        /// </summary>
        bool Visible { get; set; }

        /// <summary>
        /// The strings that form the current list of suggestions to render
        /// based on what the user has typed so far.
        /// </summary>
        ReadOnlyCollection<string> Suggestions { get; set; }

        /// <summary>
        /// The full set of all strings that can be suggested.
        /// </summary>
        List<string> AllSuggestions { get; set; }

        /// <summary>
        /// The currently selected index into <see cref="Suggestions"/> that the user has highlighted
        /// </summary>
        int SelectedIdx { get; set; }

        /// <summary>
        /// The colors to use to render the overlay.  Accessing this property before
        /// the Application has been initialized will cause an error
        /// </summary>
        ColorScheme ColorScheme { get; set; }

        /// <summary>
        /// The key that the user must press to accept the currently selected autocomplete suggestion
        /// </summary>
        Key SelectionKey { get; set; }

        /// <summary>
        /// The key that the user can press to close the currently popped autocomplete menu
        /// </summary>
        Key CloseKey { get; set; }

        /// <summary>
        /// The key that the user can press to reopen the currently popped autocomplete menu
        /// </summary>
        Key Reopen { get; set; }

        /// <summary>
        /// Renders the autocomplete dialog inside the given <see cref="HostControl"/> at the
        /// given point.
        /// </summary>
        /// <param name="renderAt"></param>
        void RenderOverlay(Point renderAt);


        /// <summary>
        /// Handle key events before <see cref="HostControl"/> e.g. to make key events like
        /// up/down apply to the autocomplete control instead of changing the cursor position in
        /// the underlying text view.
        /// </summary>
        /// <param name="kb">The key event.</param>
        /// <returns><c>true</c>if the key can be handled <c>false</c>otherwise.</returns>
        bool ProcessKey(KeyEvent kb);

        /// <summary>
        /// Handle mouse events before <see cref="HostControl"/> e.g. to make mouse events like
        /// report/click apply to the autocomplete control instead of changing the cursor position in
        /// the underlying text view.
        /// </summary>
        /// <param name="me">The mouse event.</param>
        /// <param name="fromHost">If was called from the popup or from the host.</param>
        /// <returns><c>true</c>if the mouse can be handled <c>false</c>otherwise.</returns>
        bool MouseEvent(MouseEvent me, bool fromHost = false);

        /// <summary>
        /// Clears <see cref="Suggestions"/>
        /// </summary>
        void ClearSuggestions();

        /// <summary>
        /// Populates <see cref="Suggestions"/> with all strings in <see cref="AllSuggestions"/> that
        /// match with the current cursor position/text in the <see cref="HostControl"/>.
        /// </summary>
        /// <param name="columnOffset">The column offset. Current (zero - default), left (negative), right (positive).</param>
        void GenerateSuggestions(int columnOffset = 0);
    }
    //=======================================================================
    /// <summary>
    /// Definition to interact with the OS clipboard.
    /// </summary>
    public interface IClipboard
    {
        /// <summary>
        /// Returns true if the environmental dependencies are in place to interact with the OS clipboard.
        /// </summary>
        bool IsSupported { get; }

        /// <summary>
        /// Get the operation system clipboard.
        /// </summary>
        /// <exception cref="NotSupportedException">Thrown if it was not possible to read the clipboard contents.</exception>
        string GetClipboardData();

        /// <summary>
        /// Gets the operation system clipboard if possible.
        /// </summary>
        /// <param name="result">Clipboard contents read</param>
        /// <returns>true if it was possible to read the OS clipboard.</returns>
        bool TryGetClipboardData(out string result);

        /// <summary>
        /// Sets the operation system clipboard.
        /// </summary>
        /// <param name="text"></param>
        /// <exception cref="NotSupportedException">Thrown if it was not possible to set the clipboard contents.</exception>
        void SetClipboardData(string text);

        /// <summary>
        /// Sets the operation system clipboard if possible.
        /// </summary>
        /// <param name="text"></param>
        /// <returns>True if the clipboard content was set successfully.</returns>
        bool TrySetClipboardData(string text);
    }
    //=======================================================================
    /// <summary>
    /// Provides filtering for a <see cref="TreeView"/>.
    /// </summary>
    public interface ITreeViewFilter<T> where T : class
    {

        /// <summary>
        /// Return <see langword="true"/> if the <paramref name="model"/> should
        /// be included in the tree.
        /// </summary>
        bool IsMatch(T model);
    }
    //=======================================================================
    //
    // Label.cs: Label control
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    /// The Label <see cref="View"/> displays a string at a given position and supports multiple lines separated by newline characters.
    /// Multi-line Labels support word wrap.
    /// </summary>
    /// <remarks>
    /// The <see cref="Label"/> view is functionality identical to <see cref="View"/> and is included for API backwards compatibility.
    /// </remarks>
    public class Label : View
    {
        /// <inheritdoc/>
        public Label()
        {
            Initialize();
        }

        /// <inheritdoc/>
        public Label(Rect frame, bool autosize = false) : base(frame)
        {
            Initialize(autosize);
        }

        /// <inheritdoc/>
        public Label(ustring text, bool autosize = true) : base(text)
        {
            Initialize(autosize);
        }

        /// <inheritdoc/>
        public Label(Rect rect, ustring text, bool autosize = false) : base(rect, text)
        {
            Initialize(autosize);
        }

        /// <inheritdoc/>
        public Label(int x, int y, ustring text, bool autosize = true) : base(x, y, text)
        {
            Initialize(autosize);
        }

        /// <inheritdoc/>
        public Label(ustring text, TextDirection direction, bool autosize = true)
            : base(text, direction)
        {
            Initialize(autosize);
        }

        void Initialize(bool autosize = true)
        {
            AutoSize = autosize;
        }

        /// <summary>
        ///   Clicked <see cref="Action"/>, raised when the user clicks the primary mouse button within the Bounds of this <see cref="View"/>
        ///   or if the user presses the action key while this view is focused. (TODO: IsDefault)
        /// </summary>
        /// <remarks>
        ///   Client code can hook up to this event, it is
        ///   raised when the button is activated either with
        ///   the mouse or the keyboard.
        /// </remarks>
        public event Action Clicked;

        ///// <inheritdoc/>
        //public new ustring Text {
        //	get => base.Text;
        //	set {
        //		base.Text = value;
        //		// This supports Label auto-sizing when Text changes (preserving backwards compat behavior)
        //		if (Frame.Height == 1 && !ustring.IsNullOrEmpty (value)) {
        //			int w = Text.RuneCount;
        //			Width = w;
        //			Frame = new Rect (Frame.Location, new Size (w, Frame.Height));
        //		}
        //		SetNeedsDisplay ();
        //	}
        //}

        /// <summary>
        /// Method invoked when a mouse event is generated
        /// </summary>
        /// <param name="mouseEvent"></param>
        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
        public override bool OnMouseEvent(MouseEvent mouseEvent)
        {
            MouseEventArgs args = new MouseEventArgs(mouseEvent);
            if (OnMouseClick(args))
                return true;
            if (MouseEvent(mouseEvent))
                return true;

            if (mouseEvent.Flags == MouseFlags.Button1Clicked)
            {
                if (!HasFocus && SuperView != null)
                {
                    if (!SuperView.HasFocus)
                    {
                        SuperView.SetFocus();
                    }
                    SetFocus();
                    SetNeedsDisplay();
                }

                OnClicked();
                return true;
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }

        ///<inheritdoc/>
        public override bool ProcessHotKey(KeyEvent ke)
        {
            if (ke.Key == (Key.AltMask | HotKey))
            {
                if (!HasFocus)
                {
                    SetFocus();
                }
                OnClicked();
                return true;
            }
            return base.ProcessHotKey(ke);
        }

        /// <summary>
        /// Virtual method to invoke the <see cref="Clicked"/> event.
        /// </summary>
        public virtual void OnClicked()
        {
            Clicked?.Invoke();
        }
    }
    //=======================================================================
    /// <summary>
    /// A straight line control either horizontal or vertical
    /// </summary>
    public class LineView : View
    {

        /// <summary>
        /// The rune to display at the start of the line (left end of horizontal line or top end of vertical)
        /// If not specified then <see cref="LineRune"/> is used
        /// </summary>
        public Rune? StartingAnchor { get; set; }

        /// <summary>
        /// The rune to display at the end of the line (right end of horizontal line or bottom end of vertical).
        /// If not specified then <see cref="LineRune"/> is used
        /// </summary>
        public Rune? EndingAnchor { get; set; }

        /// <summary>
        /// The symbol to use for drawing the line
        /// </summary>
        public Rune LineRune { get; set; }

        /// <summary>
        /// The direction of the line.  If you change this you will need to manually update the Width/Height
        /// of the control to cover a relevant area based on the new direction.
        /// </summary>
        public Orientation Orientation { get; set; }

        /// <summary>
        /// Creates a horizontal line
        /// </summary>
        public LineView() : this(Orientation.Horizontal)
        {

        }

        /// <summary>
        /// Creates a horizontal or vertical line based on <paramref name="orientation"/>
        /// </summary>
        public LineView(Orientation orientation)
        {
            CanFocus = false;

            switch (orientation)
            {
                case Orientation.Horizontal:
                    Height = 1;
                    Width = Dim.Fill();
                    LineRune = Driver.HLine;

                    break;
                case Orientation.Vertical:
                    Height = Dim.Fill();
                    Width = 1;
                    LineRune = Driver.VLine;
                    break;
                default:
                    throw new ArgumentException($"Unknown Orientation {orientation}");
            }
            Orientation = orientation;
        }

        /// <summary>
        /// Draws the line including any starting/ending anchors
        /// </summary>
        /// <param name="bounds"></param>
        public override void Redraw(Rect bounds)
        {
            base.Redraw(bounds);

            Move(0, 0);
            Driver.SetAttribute(GetNormalColor());

            var hLineWidth = Math.Max(1, Rune.ColumnWidth(Driver.HLine));

            var dEnd = Orientation == Orientation.Horizontal ?
                bounds.Width :
                bounds.Height;

            for (int d = 0; d < dEnd; d += hLineWidth)
            {

                if (Orientation == Orientation.Horizontal)
                {
                    Move(d, 0);
                }
                else
                {
                    Move(0, d);
                }

                Rune rune = LineRune;

                if (d == 0)
                {
                    rune = StartingAnchor ?? LineRune;
                }
                else
                if (d == dEnd - 1)
                {
                    rune = EndingAnchor ?? LineRune;
                }

                Driver.AddRune(rune);
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Implement <see cref="IListDataSource"/> to provide custom rendering for a <see cref="ListView"/>.
    /// </summary>
    public interface IListDataSource
    {
        /// <summary>
        /// Returns the number of elements to display
        /// </summary>
        int Count { get; }

        /// <summary>
        /// Returns the maximum length of elements to display
        /// </summary>
        int Length { get; }

        /// <summary>
        /// This method is invoked to render a specified item, the method should cover the entire provided width.
        /// </summary>
        /// <returns>The render.</returns>
        /// <param name="container">The list view to render.</param>
        /// <param name="driver">The console driver to render.</param>
        /// <param name="selected">Describes whether the item being rendered is currently selected by the user.</param>
        /// <param name="item">The index of the item to render, zero for the first item and so on.</param>
        /// <param name="col">The column where the rendering will start</param>
        /// <param name="line">The line where the rendering will be done.</param>
        /// <param name="width">The width that must be filled out.</param>
        /// <param name="start">The index of the string to be displayed.</param>
        /// <remarks>
        ///   The default color will be set before this method is invoked, and will be based on whether the item is selected or not.
        /// </remarks>
        void Render(ListView container, ConsoleDriver driver, bool selected, int item, int col, int line, int width, int start = 0);

        /// <summary>
        /// Should return whether the specified item is currently marked.
        /// </summary>
        /// <returns><see langword="true"/>, if marked, <see langword="false"/> otherwise.</returns>
        /// <param name="item">Item index.</param>
        bool IsMarked(int item);

        /// <summary>
        /// Flags the item as marked.
        /// </summary>
        /// <param name="item">Item index.</param>
        /// <param name="value">If set to <see langword="true"/> value.</param>
        void SetMark(int item, bool value);

        /// <summary>
        /// Return the source as IList.
        /// </summary>
        /// <returns></returns>
        IList ToList();
    }

    /// <summary>
    /// ListView <see cref="View"/> renders a scrollable list of data where each item can be activated to perform an action.
    /// </summary>
    /// <remarks>
    /// <para>
    ///   The <see cref="ListView"/> displays lists of data and allows the user to scroll through the data.
    ///   Items in the can be activated firing an event (with the ENTER key or a mouse double-click). 
    ///   If the <see cref="AllowsMarking"/> property is true, elements of the list can be marked by the user.
    /// </para>
    /// <para>
    ///   By default <see cref="ListView"/> uses <see cref="object.ToString"/> to render the items of any
    ///   <see cref="IList"/> object (e.g. arrays, <see cref="List{T}"/>,
    ///   and other collections). Alternatively, an object that implements <see cref="IListDataSource"/>
    ///   can be provided giving full control of what is rendered.
    /// </para>
    /// <para>
    ///   <see cref="ListView"/> can display any object that implements the <see cref="IList"/> interface.
    ///   <see cref="string"/> values are converted into <see cref="ustring"/> values before rendering, and other values are
    ///   converted into <see cref="string"/> by calling <see cref="object.ToString"/> and then converting to <see cref="ustring"/> .
    /// </para>
    /// <para>
    ///   To change the contents of the ListView, set the <see cref="Source"/> property (when 
    ///   providing custom rendering via <see cref="IListDataSource"/>) or call <see cref="SetSource"/>
    ///   an <see cref="IList"/> is being used.
    /// </para>
    /// <para>
    ///   When <see cref="AllowsMarking"/> is set to true the rendering will prefix the rendered items with
    ///   [x] or [ ] and bind the SPACE key to toggle the selection. To implement a different
    ///   marking style set <see cref="AllowsMarking"/> to false and implement custom rendering.
    /// </para>
    /// <para>
    ///   Searching the ListView with the keyboard is supported. Users type the
    ///   first characters of an item, and the first item that starts with what the user types will be selected.
    /// </para>
    /// </remarks>
    public class ListView : View
    {
        int top, left;
        int selected;

        IListDataSource source;
        /// <summary>
        /// Gets or sets the <see cref="IListDataSource"/> backing this <see cref="ListView"/>, enabling custom rendering.
        /// </summary>
        /// <value>The source.</value>
        /// <remarks>
        ///  Use <see cref="SetSource"/> to set a new <see cref="IList"/> source.
        /// </remarks>
        public IListDataSource Source
        {
            get => source;
            set
            {
                source = value;
                KeystrokeNavigator.Collection = source?.ToList()?.Cast<object>();
                top = 0;
                selected = 0;
                lastSelectedItem = -1;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Sets the source of the <see cref="ListView"/> to an <see cref="IList"/>.
        /// </summary>
        /// <value>An object implementing the IList interface.</value>
        /// <remarks>
        ///  Use the <see cref="Source"/> property to set a new <see cref="IListDataSource"/> source and use custome rendering.
        /// </remarks>
        public void SetSource(IList source)
        {
            if (source == null && (Source == null || !(Source is ListWrapper)))
                Source = null;
            else
            {
                Source = MakeWrapper(source);
            }
        }

        /// <summary>
        /// Sets the source to an <see cref="IList"/> value asynchronously.
        /// </summary>
        /// <value>An item implementing the IList interface.</value>
        /// <remarks>
        ///  Use the <see cref="Source"/> property to set a new <see cref="IListDataSource"/> source and use custom rendering.
        /// </remarks>
        public Task SetSourceAsync(IList source)
        {
            return Task.Factory.StartNew(() =>
            {
                if (source == null && (Source == null || !(Source is ListWrapper)))
                    Source = null;
                else
                    Source = MakeWrapper(source);
                return source;
            }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);
        }

        bool allowsMarking;
        /// <summary>
        /// Gets or sets whether this <see cref="ListView"/> allows items to be marked.
        /// </summary>
        /// <value>Set to <see langword="true"/> to allow marking elements of the list.</value>
        /// <remarks>
        /// If set to <see langword="true"/>, <see cref="ListView"/> will render items marked items with "[x]", and unmarked items with "[ ]"
        /// spaces. SPACE key will toggle marking. The default is <see langword="false"/>.
        /// </remarks>
        public bool AllowsMarking
        {
            get => allowsMarking;
            set
            {
                allowsMarking = value;
                if (allowsMarking)
                {
                    AddKeyBinding(Key.Space, Command.ToggleChecked);
                }
                else
                {
                    ClearKeybinding(Key.Space);
                }

                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// If set to <see langword="true"/> more than one item can be selected. If <see langword="false"/> selecting
        /// an item will cause all others to be un-selected. The default is <see langword="false"/>.
        /// </summary>
        public bool AllowsMultipleSelection
        {
            get => allowsMultipleSelection;
            set
            {
                allowsMultipleSelection = value;
                if (Source != null && !allowsMultipleSelection)
                {
                    // Clear all selections except selected 
                    for (int i = 0; i < Source.Count; i++)
                    {
                        if (Source.IsMarked(i) && i != selected)
                        {
                            Source.SetMark(i, false);
                        }
                    }
                }
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Gets or sets the item that is displayed at the top of the <see cref="ListView"/>.
        /// </summary>
        /// <value>The top item.</value>
        public int TopItem
        {
            get => top;
            set
            {
                if (source == null)
                    return;

                if (value < 0 || (source.Count > 0 && value >= source.Count))
                    throw new ArgumentException("value");
                top = value;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Gets or sets the leftmost column that is currently visible (when scrolling horizontally).
        /// </summary>
        /// <value>The left position.</value>
        public int LeftItem
        {
            get => left;
            set
            {
                if (source == null)
                    return;

                if (value < 0 || (Maxlength > 0 && value >= Maxlength))
                    throw new ArgumentException("value");
                left = value;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Gets the widest item in the list.
        /// </summary>
        public int Maxlength => (source?.Length) ?? 0;

        /// <summary>
        /// Gets or sets the index of the currently selected item.
        /// </summary>
        /// <value>The selected item.</value>
        public int SelectedItem
        {
            get => selected;
            set
            {
                if (source == null || source.Count == 0)
                {
                    return;
                }
                if (value < 0 || value >= source.Count)
                {
                    throw new ArgumentException("value");
                }
                selected = value;
                OnSelectedChanged();
            }
        }

        static IListDataSource MakeWrapper(IList source)
        {
            return new ListWrapper(source);
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ListView"/> that will display the 
        /// contents of the object implementing the <see cref="IList"/> interface, 
        /// with relative positioning.
        /// </summary>
        /// <param name="source">An <see cref="IList"/> data source, if the elements are strings or ustrings, 
        /// the string is rendered, otherwise the ToString() method is invoked on the result.</param>
        public ListView(IList source) : this(MakeWrapper(source))
        {
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ListView"/> that will display the provided data source, using relative positioning.
        /// </summary>
        /// <param name="source"><see cref="IListDataSource"/> object that provides a mechanism to render the data. 
        /// The number of elements on the collection should not change, if you must change, set 
        /// the "Source" property to reset the internal settings of the ListView.</param>
        public ListView(IListDataSource source) : base()
        {
            this.source = source;
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ListView"/>. Set the <see cref="Source"/> property to display something.
        /// </summary>
        public ListView() : base()
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ListView"/> that will display the contents of the object implementing the <see cref="IList"/> interface with an absolute position.
        /// </summary>
        /// <param name="rect">Frame for the listview.</param>
        /// <param name="source">An IList data source, if the elements of the IList are strings or ustrings, 
        /// the string is rendered, otherwise the ToString() method is invoked on the result.</param>
        public ListView(Rect rect, IList source) : this(rect, MakeWrapper(source))
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of <see cref="ListView"/> with the provided data source and an absolute position
        /// </summary>
        /// <param name="rect">Frame for the listview.</param>
        /// <param name="source">IListDataSource object that provides a mechanism to render the data. 
        /// The number of elements on the collection should not change, if you must change, 
        /// set the "Source" property to reset the internal settings of the ListView.</param>
        public ListView(Rect rect, IListDataSource source) : base(rect)
        {
            this.source = source;
            Initialize();
        }

        void Initialize()
        {
            Source = source;
            CanFocus = true;

            // Things this view knows how to do
            AddCommand(Command.LineUp, () => MoveUp());
            AddCommand(Command.LineDown, () => MoveDown());
            AddCommand(Command.ScrollUp, () => ScrollUp(1));
            AddCommand(Command.ScrollDown, () => ScrollDown(1));
            AddCommand(Command.PageUp, () => MovePageUp());
            AddCommand(Command.PageDown, () => MovePageDown());
            AddCommand(Command.TopHome, () => MoveHome());
            AddCommand(Command.BottomEnd, () => MoveEnd());
            AddCommand(Command.OpenSelectedItem, () => OnOpenSelectedItem());
            AddCommand(Command.ToggleChecked, () => MarkUnmarkRow());

            // Default keybindings for all ListViews
            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.P | Key.CtrlMask, Command.LineUp);

            AddKeyBinding(Key.CursorDown, Command.LineDown);
            AddKeyBinding(Key.N | Key.CtrlMask, Command.LineDown);

            AddKeyBinding(Key.PageUp, Command.PageUp);

            AddKeyBinding(Key.PageDown, Command.PageDown);
            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);

            AddKeyBinding(Key.Home, Command.TopHome);

            AddKeyBinding(Key.End, Command.BottomEnd);

            AddKeyBinding(Key.Enter, Command.OpenSelectedItem);
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            var current = ColorScheme.Focus;
            Driver.SetAttribute(current);
            Move(0, 0);
            var f = Frame;
            var item = top;
            bool focused = HasFocus;
            int col = allowsMarking ? 2 : 0;
            int start = left;

            for (int row = 0; row < f.Height; row++, item++)
            {
                bool isSelected = item == selected;

                var newcolor = focused ? (isSelected ? ColorScheme.Focus : GetNormalColor())
                               : (isSelected ? ColorScheme.HotNormal : GetNormalColor());

                if (newcolor != current)
                {
                    Driver.SetAttribute(newcolor);
                    current = newcolor;
                }

                Move(0, row);
                if (source == null || item >= source.Count)
                {
                    for (int c = 0; c < f.Width; c++)
                        Driver.AddRune(' ');
                }
                else
                {
                    var rowEventArgs = new ListViewRowEventArgs(item);
                    OnRowRender(rowEventArgs);
                    if (rowEventArgs.RowAttribute != null && current != rowEventArgs.RowAttribute)
                    {
                        current = (Attribute)rowEventArgs.RowAttribute;
                        Driver.SetAttribute(current);
                    }
                    if (allowsMarking)
                    {
                        Driver.AddRune(source.IsMarked(item) ? (AllowsMultipleSelection ? Driver.Checked : Driver.Selected) :
                            (AllowsMultipleSelection ? Driver.UnChecked : Driver.UnSelected));
                        Driver.AddRune(' ');
                    }
                    Source.Render(this, Driver, isSelected, item, col, row, f.Width - col, start);
                }
            }
        }

        /// <summary>
        /// This event is raised when the selected item in the <see cref="ListView"/> has changed.
        /// </summary>
        public event Action<ListViewItemEventArgs> SelectedItemChanged;

        /// <summary>
        /// This event is raised when the user Double Clicks on an item or presses ENTER to open the selected item.
        /// </summary>
        public event Action<ListViewItemEventArgs> OpenSelectedItem;

        /// <summary>
        /// This event is invoked when this <see cref="ListView"/> is being drawn before rendering.
        /// </summary>
        public event Action<ListViewRowEventArgs> RowRender;

        /// <summary>
        /// Gets the <see cref="CollectionNavigator"/> that searches the <see cref="ListView.Source"/> collection as
        /// the user types.
        /// </summary>
        public CollectionNavigator KeystrokeNavigator { get; private set; } = new CollectionNavigator();

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            if (source == null)
            {
                return base.ProcessKey(kb);
            }

            var result = InvokeKeybindings(kb);
            if (result != null)
            {
                return (bool)result;
            }

            // Enable user to find & select an item by typing text
            if (CollectionNavigator.IsCompatibleKey(kb))
            {
                var newItem = KeystrokeNavigator?.GetNextMatchingItem(SelectedItem, (char)kb.KeyValue);
                if (newItem is int && newItem != -1)
                {
                    SelectedItem = (int)newItem;
                    EnsureSelectedItemVisible();
                    SetNeedsDisplay();
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// If <see cref="AllowsMarking"/> and <see cref="AllowsMultipleSelection"/> are both <see langword="true"/>,
        /// unmarks all marked items other than the currently selected. 
        /// </summary>
        /// <returns><see langword="true"/> if unmarking was successful.</returns>
        public virtual bool AllowsAll()
        {
            if (!allowsMarking)
                return false;
            if (!AllowsMultipleSelection)
            {
                for (int i = 0; i < Source.Count; i++)
                {
                    if (Source.IsMarked(i) && i != selected)
                    {
                        Source.SetMark(i, false);
                        return true;
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Marks the <see cref="SelectedItem"/> if it is not already marked.
        /// </summary>
        /// <returns><see langword="true"/> if the <see cref="SelectedItem"/> was marked.</returns>
        public virtual bool MarkUnmarkRow()
        {
            if (AllowsAll())
            {
                Source.SetMark(SelectedItem, !Source.IsMarked(SelectedItem));
                SetNeedsDisplay();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Changes the <see cref="SelectedItem"/> to the item at the top of the visible list.
        /// </summary>
        /// <returns></returns>
        public virtual bool MovePageUp()
        {
            int n = (selected - Frame.Height);
            if (n < 0)
                n = 0;
            if (n != selected)
            {
                selected = n;
                top = selected;
                OnSelectedChanged();
                SetNeedsDisplay();
            }

            return true;
        }

        /// <summary>
        /// Changes the <see cref="SelectedItem"/> to the item just below the bottom 
        /// of the visible list, scrolling if needed.
        /// </summary>
        /// <returns></returns>
        public virtual bool MovePageDown()
        {
            var n = (selected + Frame.Height);
            if (n >= source.Count)
                n = source.Count - 1;
            if (n != selected)
            {
                selected = n;
                if (source.Count >= Frame.Height)
                    top = selected;
                else
                    top = 0;
                OnSelectedChanged();
                SetNeedsDisplay();
            }

            return true;
        }

        /// <summary>
        /// Changes the <see cref="SelectedItem"/> to the next item in the list, 
        /// scrolling the list if needed.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveDown()
        {
            if (source.Count == 0)
            {
                // Do we set lastSelectedItem to -1 here?
                return false; //Nothing for us to move to
            }
            if (selected >= source.Count)
            {
                // If for some reason we are currently outside of the
                // valid values range, we should select the bottommost valid value.
                // This can occur if the backing data source changes.
                selected = source.Count - 1;
                OnSelectedChanged();
                SetNeedsDisplay();
            }
            else if (selected + 1 < source.Count)
            { //can move by down by one.
                selected++;

                if (selected >= top + Frame.Height)
                {
                    top++;
                }
                else if (selected < top)
                {
                    top = selected;
                }
                else if (selected < top)
                {
                    top = selected;
                }
                OnSelectedChanged();
                SetNeedsDisplay();
            }
            else if (selected == 0)
            {
                OnSelectedChanged();
                SetNeedsDisplay();
            }
            else if (selected >= top + Frame.Height)
            {
                top = source.Count - Frame.Height;
                SetNeedsDisplay();
            }

            return true;
        }

        /// <summary>
        /// Changes the <see cref="SelectedItem"/> to the previous item in the list, 
        /// scrolling the list if needed.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveUp()
        {
            if (source.Count == 0)
            {
                // Do we set lastSelectedItem to -1 here?
                return false; //Nothing for us to move to
            }
            if (selected >= source.Count)
            {
                // If for some reason we are currently outside of the
                // valid values range, we should select the bottommost valid value.
                // This can occur if the backing data source changes.
                selected = source.Count - 1;
                OnSelectedChanged();
                SetNeedsDisplay();
            }
            else if (selected > 0)
            {
                selected--;
                if (selected > Source.Count)
                {
                    selected = Source.Count - 1;
                }
                if (selected < top)
                {
                    top = selected;
                }
                else if (selected > top + Frame.Height)
                {
                    top = Math.Max(selected - Frame.Height + 1, 0);
                }
                OnSelectedChanged();
                SetNeedsDisplay();
            }
            else if (selected < top)
            {
                top = selected;
                SetNeedsDisplay();
            }
            return true;
        }

        /// <summary>
        /// Changes the <see cref="SelectedItem"/> to last item in the list, 
        /// scrolling the list if needed.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveEnd()
        {
            if (source?.Count > 0 && selected != source.Count - 1)
            {
                selected = source.Count - 1;
                if (top + selected > Frame.Height - 1)
                {
                    top = selected < Frame.Height - 1
                        ? Math.Max(Frame.Height - selected + 1, 0)
                        : Math.Max(selected - Frame.Height + 1, 0);
                }
                OnSelectedChanged();
                SetNeedsDisplay();
            }

            return true;
        }

        /// <summary>
        /// Changes the <see cref="SelectedItem"/> to the first item in the list, 
        /// scrolling the list if needed.
        /// </summary>
        /// <returns></returns>
        public virtual bool MoveHome()
        {
            if (selected != 0)
            {
                selected = 0;
                top = selected;
                OnSelectedChanged();
                SetNeedsDisplay();
            }

            return true;
        }

        /// <summary>
        /// Scrolls the view down by <paramref name="items"/> items.
        /// </summary>
        /// <param name="items">Number of items to scroll down.</param>
        public virtual bool ScrollDown(int items)
        {
            top = Math.Max(Math.Min(top + items, source.Count - 1), 0);
            SetNeedsDisplay();
            return true;
        }

        /// <summary>
        /// Scrolls the view up by <paramref name="items"/> items.
        /// </summary>
        /// <param name="items">Number of items to scroll up.</param>
        public virtual bool ScrollUp(int items)
        {
            top = Math.Max(top - items, 0);
            SetNeedsDisplay();
            return true;
        }

        /// <summary>
        /// Scrolls the view right.
        /// </summary>
        /// <param name="cols">Number of columns to scroll right.</param>
        public virtual bool ScrollRight(int cols)
        {
            left = Math.Max(Math.Min(left + cols, Maxlength - 1), 0);
            SetNeedsDisplay();
            return true;
        }

        /// <summary>
        /// Scrolls the view left.
        /// </summary>
        /// <param name="cols">Number of columns to scroll left.</param>
        public virtual bool ScrollLeft(int cols)
        {
            left = Math.Max(left - cols, 0);
            SetNeedsDisplay();
            return true;
        }

        int lastSelectedItem = -1;
        private bool allowsMultipleSelection = true;

        /// <summary>
        /// Invokes the <see cref="SelectedItemChanged"/> event if it is defined.
        /// </summary>
        /// <returns></returns>
        public virtual bool OnSelectedChanged()
        {
            if (selected != lastSelectedItem)
            {
                var value = source?.Count > 0 ? source.ToList()[selected] : null;
                SelectedItemChanged?.Invoke(new ListViewItemEventArgs(selected, value));
                if (HasFocus)
                {
                    lastSelectedItem = selected;
                }
                return true;
            }

            return false;
        }

        /// <summary>
        /// Invokes the <see cref="OpenSelectedItem"/> event if it is defined.
        /// </summary>
        /// <returns></returns>
        public virtual bool OnOpenSelectedItem()
        {
            if (source.Count <= selected || selected < 0 || OpenSelectedItem == null)
            {
                return false;
            }

            var value = source.ToList()[selected];

            OpenSelectedItem?.Invoke(new ListViewItemEventArgs(selected, value));

            return true;
        }

        /// <summary>
        /// Virtual method that will invoke the <see cref="RowRender"/>.
        /// </summary>
        /// <param name="rowEventArgs"></param>
        public virtual void OnRowRender(ListViewRowEventArgs rowEventArgs)
        {
            RowRender?.Invoke(rowEventArgs);
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            if (lastSelectedItem == -1)
            {
                EnsureSelectedItemVisible();
            }

            return base.OnEnter(view);
        }

        ///<inheritdoc/>
        public override bool OnLeave(View view)
        {
            if (lastSelectedItem > -1)
            {
                lastSelectedItem = -1;
            }

            return base.OnLeave(view);
        }

        /// <summary>
        /// Ensures the selected item is always visible on the screen.
        /// </summary>
        public void EnsureSelectedItemVisible()
        {
            SuperView?.LayoutSubviews();
            // If last item is selected and is removed, ensures a valid selected item
            if (Source != null && selected > Source.Count - 1)
            {
                SelectedItem = Source.Count - 1;
                SetNeedsDisplay();
            }
            if (selected < top)
            {
                top = selected;
            }
            else if (Frame.Height > 0 && selected >= top + Frame.Height)
            {
                top = Math.Max(selected - Frame.Height + 1, 0);
            }
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            if (allowsMarking)
                Move(0, selected - top);
            else
                Move(Bounds.Width - 1, selected - top);
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) && !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
                me.Flags != MouseFlags.WheeledDown && me.Flags != MouseFlags.WheeledUp &&
                me.Flags != MouseFlags.WheeledRight && me.Flags != MouseFlags.WheeledLeft)
                return false;

            if (!HasFocus && CanFocus)
            {
                SetFocus();
            }

            if (source == null)
            {
                return false;
            }

            if (me.Flags == MouseFlags.WheeledDown)
            {
                ScrollDown(1);
                return true;
            }
            else if (me.Flags == MouseFlags.WheeledUp)
            {
                ScrollUp(1);
                return true;
            }
            else if (me.Flags == MouseFlags.WheeledRight)
            {
                ScrollRight(1);
                return true;
            }
            else if (me.Flags == MouseFlags.WheeledLeft)
            {
                ScrollLeft(1);
                return true;
            }

            if (me.Y + top >= source.Count)
            {
                return true;
            }

            selected = top + me.Y;
            if (AllowsAll())
            {
                Source.SetMark(SelectedItem, !Source.IsMarked(SelectedItem));
            }
            OnSelectedChanged();
            SetNeedsDisplay();
            if (me.Flags == MouseFlags.Button1DoubleClicked)
            {
                OnOpenSelectedItem();
            }

            return true;
        }
    }

    /// <inheritdoc/>
    public class ListWrapper : IListDataSource
    {
        IList src;
        BitArray marks;
        int count, len;

        /// <inheritdoc/>
        public ListWrapper(IList source)
        {
            if (source != null)
            {
                count = source.Count;
                marks = new BitArray(count);
                src = source;
                len = GetMaxLengthItem();
            }
        }

        /// <inheritdoc/>
        public int Count
        {
            get
            {
                CheckAndResizeMarksIfRequired();
                return src?.Count ?? 0;
            }
        }

        /// <inheritdoc/>
        public int Length => len;

        void CheckAndResizeMarksIfRequired()
        {
            if (src != null && count != src.Count)
            {
                count = src.Count;
                BitArray newMarks = new BitArray(count);
                for (var i = 0; i < Math.Min(marks.Length, newMarks.Length); i++)
                {
                    newMarks[i] = marks[i];
                }
                marks = newMarks;

                len = GetMaxLengthItem();
            }
        }

        int GetMaxLengthItem()
        {
            if (src == null || src?.Count == 0)
            {
                return 0;
            }

            int maxLength = 0;
            for (int i = 0; i < src.Count; i++)
            {
                var t = src[i];
                int l;
                if (t is ustring u)
                {
                    l = TextFormatter.GetTextWidth(u);
                }
                else if (t is string s)
                {
                    l = s.Length;
                }
                else
                {
                    l = t.ToString().Length;
                }

                if (l > maxLength)
                {
                    maxLength = l;
                }
            }

            return maxLength;
        }

        void RenderUstr(ConsoleDriver driver, ustring ustr, int col, int line, int width, int start = 0)
        {
            ustring str = start > ustr.ConsoleWidth ? string.Empty : ustr.Substring(Math.Min(start, ustr.ToRunes().Length - 1));
            ustring u = TextFormatter.ClipAndJustify(str, width, TextAlignment.Left);
            driver.AddStr(u);
            width -= TextFormatter.GetTextWidth(u);
            while (width-- + start > 0)
            {
                driver.AddRune(' ');
            }
        }

        /// <inheritdoc/>
        public void Render(ListView container, ConsoleDriver driver, bool marked, int item, int col, int line, int width, int start = 0)
        {
            var savedClip = container.ClipToBounds();
            container.Move(Math.Max(col - start, 0), line);
            var t = src?[item];
            if (t == null)
            {
                RenderUstr(driver, ustring.Make(""), col, line, width);
            }
            else
            {
                if (t is ustring u)
                {
                    RenderUstr(driver, u, col, line, width, start);
                }
                else if (t is string s)
                {
                    RenderUstr(driver, s, col, line, width, start);
                }
                else
                {
                    RenderUstr(driver, t.ToString(), col, line, width, start);
                }
            }
            driver.Clip = savedClip;
        }

        /// <inheritdoc/>
        public bool IsMarked(int item)
        {
            if (item >= 0 && item < Count)
                return marks[item];
            return false;
        }

        /// <inheritdoc/>
        public void SetMark(int item, bool value)
        {
            if (item >= 0 && item < Count)
                marks[item] = value;
        }

        /// <inheritdoc/>
        public IList ToList()
        {
            return src;
        }

        /// <inheritdoc/>
        public int StartsWith(string search)
        {
            if (src == null || src?.Count == 0)
            {
                return -1;
            }

            for (int i = 0; i < src.Count; i++)
            {
                var t = src[i];
                if (t is ustring u)
                {
                    if (u.ToUpper().StartsWith(search.ToUpperInvariant()))
                    {
                        return i;
                    }
                }
                else if (t is string s)
                {
                    if (s.StartsWith(search, StringComparison.InvariantCultureIgnoreCase))
                    {
                        return i;
                    }
                }
            }
            return -1;
        }
    }

    /// <summary>
    /// <see cref="EventArgs"/> for <see cref="ListView"/> events.
    /// </summary>
    public class ListViewItemEventArgs : EventArgs
    {
        /// <summary>
        /// The index of the <see cref="ListView"/> item.
        /// </summary>
        public int Item { get; }
        /// <summary>
        /// The <see cref="ListView"/> item.
        /// </summary>
        public object Value { get; }

        /// <summary>
        /// Initializes a new instance of <see cref="ListViewItemEventArgs"/>
        /// </summary>
        /// <param name="item">The index of the <see cref="ListView"/> item.</param>
        /// <param name="value">The <see cref="ListView"/> item</param>
        public ListViewItemEventArgs(int item, object value)
        {
            Item = item;
            Value = value;
        }
    }

    /// <summary>
    /// <see cref="EventArgs"/> used by the <see cref="ListView.RowRender"/> event.
    /// </summary>
    public class ListViewRowEventArgs : EventArgs
    {
        /// <summary>
        /// The current row being rendered.
        /// </summary>
        public int Row { get; }
        /// <summary>
        /// The <see cref="Attribute"/> used by current row or
        /// null to maintain the current attribute.
        /// </summary>
        public Attribute? RowAttribute { get; set; }

        /// <summary>
        /// Initializes with the current row.
        /// </summary>
        /// <param name="row"></param>
        public ListViewRowEventArgs(int row)
        {
            Row = row;
        }
    }
    //=======================================================================
    //
    // MainLoop.cs: IMainLoopDriver and MainLoop for Terminal.Gui
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    /// Public interface to create your own platform specific main loop driver.
    /// </summary>
    public interface IMainLoopDriver
    {
        /// <summary>
        /// Initializes the main loop driver, gets the calling main loop for the initialization.
        /// </summary>
        /// <param name="mainLoop">Main loop.</param>
        void Setup(MainLoop mainLoop);

        /// <summary>
        /// Wakes up the mainloop that might be waiting on input, must be thread safe.
        /// </summary>
        void Wakeup();

        /// <summary>
        /// Must report whether there are any events pending, or even block waiting for events.
        /// </summary>
        /// <returns><c>true</c>, if there were pending events, <c>false</c> otherwise.</returns>
        /// <param name="wait">If set to <c>true</c> wait until an event is available, otherwise return immediately.</param>
        bool EventsPending(bool wait);

        /// <summary>
        /// The iteration function.
        /// </summary>
        void MainIteration();
    }

    /// <summary>
    ///   Simple main loop implementation that can be used to monitor
    ///   file descriptor, run timers and idle handlers.
    /// </summary>
    /// <remarks>
    ///   Monitoring of file descriptors is only available on Unix, there
    ///   does not seem to be a way of supporting this on Windows.
    /// </remarks>
    public class MainLoop
    {
        /// <summary>
        /// Provides data for timers running manipulation.
        /// </summary>
        public sealed class Timeout
        {
            /// <summary>
            /// Time to wait before invoke the callback.
            /// </summary>
            public TimeSpan Span;
            /// <summary>
            /// The function that will be invoked.
            /// </summary>
            public Func<MainLoop, bool> Callback;
        }

        internal SortedList<long, Timeout> timeouts = new SortedList<long, Timeout>();
        object timeoutsLockToken = new object();

        /// <summary>
        /// The idle handlers and lock that must be held while manipulating them
        /// </summary>
        object idleHandlersLock = new object();
        internal List<Func<bool>> idleHandlers = new List<Func<bool>>();

        /// <summary>
        /// Gets the list of all timeouts sorted by the <see cref="TimeSpan"/> time ticks./>.
        /// A shorter limit time can be added at the end, but it will be called before an
        ///  earlier addition that has a longer limit time.
        /// </summary>
        public SortedList<long, Timeout> Timeouts => timeouts;

        /// <summary>
        /// Gets a copy of the list of all idle handlers.
        /// </summary>
        public ReadOnlyCollection<Func<bool>> IdleHandlers
        {
            get
            {
                lock (idleHandlersLock)
                {
                    return new List<Func<bool>>(idleHandlers).AsReadOnly();
                }
            }
        }

        /// <summary>
        /// The current IMainLoopDriver in use.
        /// </summary>
        /// <value>The driver.</value>
        public IMainLoopDriver Driver { get; }

        /// <summary>
        /// Invoked when a new timeout is added. To be used in the case
        /// when <see cref="Application.ExitRunLoopAfterFirstIteration"/> is <see langword="true"/>.
        /// </summary>
        public event Action<long> TimeoutAdded;

        /// <summary>
        ///  Creates a new Mainloop. 
        /// </summary>
        /// <param name="driver">Should match the <see cref="ConsoleDriver"/> 
        /// (one of the implementations FakeMainLoop, UnixMainLoop, NetMainLoop or WindowsMainLoop).</param>
        public MainLoop(IMainLoopDriver driver)
        {
            Driver = driver;
            driver.Setup(this);
        }

        /// <summary>
        ///   Runs <c>action</c> on the thread that is processing events
        /// </summary>
        /// <param name="action">the action to be invoked on the main processing thread.</param>
        public void Invoke(Action action)
        {
            AddIdle(() =>
            {
                action();
                return false;
            });
        }

        /// <summary>
        ///   Adds specified idle handler function to mainloop processing. The handler function will be called once per iteration of the main loop after other events have been handled.
        /// </summary>
        /// <remarks>
        /// <para>
        ///   Remove an idle hander by calling <see cref="RemoveIdle(Func{bool})"/> with the token this method returns.
        /// </para>
        /// <para>
        ///   If the <c>idleHandler</c> returns <c>false</c> it will be removed and not called subsequently.
        /// </para>
        /// </remarks>
        /// <param name="idleHandler">Token that can be used to remove the idle handler with <see cref="RemoveIdle(Func{bool})"/> .</param>
        public Func<bool> AddIdle(Func<bool> idleHandler)
        {
            lock (idleHandlersLock)
            {
                idleHandlers.Add(idleHandler);
            }

            Driver.Wakeup();
            return idleHandler;
        }

        /// <summary>
        ///   Removes an idle handler added with <see cref="AddIdle(Func{bool})"/> from processing.
        /// </summary>
        /// <param name="token">A token returned by <see cref="AddIdle(Func{bool})"/></param>
        /// Returns <c>true</c>if the idle handler is successfully removed; otherwise, <c>false</c>.
        ///  This method also returns <c>false</c> if the idle handler is not found.
        public bool RemoveIdle(Func<bool> token)
        {
            lock (idleHandlersLock)
                return idleHandlers.Remove(token);
        }

        void AddTimeout(TimeSpan time, Timeout timeout)
        {
            lock (timeoutsLockToken)
            {
                var k = (DateTime.UtcNow + time).Ticks;
                timeouts.Add(NudgeToUniqueKey(k), timeout);
                TimeoutAdded?.Invoke(k);
            }
        }

        /// <summary>
        ///   Adds a timeout to the mainloop.
        /// </summary>
        /// <remarks>
        ///   When time specified passes, the callback will be invoked.
        ///   If the callback returns true, the timeout will be reset, repeating
        ///   the invocation. If it returns false, the timeout will stop and be removed.
        ///
        ///   The returned value is a token that can be used to stop the timeout
        ///   by calling <see cref="RemoveTimeout(object)"/>.
        /// </remarks>
        public object AddTimeout(TimeSpan time, Func<MainLoop, bool> callback)
        {
            if (callback == null)
                throw new ArgumentNullException(nameof(callback));
            var timeout = new Timeout()
            {
                Span = time,
                Callback = callback
            };
            AddTimeout(time, timeout);
            return timeout;
        }

        /// <summary>
        ///   Removes a previously scheduled timeout
        /// </summary>
        /// <remarks>
        ///   The token parameter is the value returned by AddTimeout.
        /// </remarks>
        /// Returns <c>true</c>if the timeout is successfully removed; otherwise, <c>false</c>.
        /// This method also returns <c>false</c> if the timeout is not found.
        public bool RemoveTimeout(object token)
        {
            lock (timeoutsLockToken)
            {
                var idx = timeouts.IndexOfValue(token as Timeout);
                if (idx == -1)
                    return false;
                timeouts.RemoveAt(idx);
            }
            return true;
        }

        void RunTimers()
        {
            long now = DateTime.UtcNow.Ticks;
            SortedList<long, Timeout> copy;

            // lock prevents new timeouts being added
            // after we have taken the copy but before
            // we have allocated a new list (which would
            // result in lost timeouts or errors during enumeration)
            lock (timeoutsLockToken)
            {
                copy = timeouts;
                timeouts = new SortedList<long, Timeout>();
            }

            foreach (var t in copy)
            {
                var k = t.Key;
                var timeout = t.Value;
                if (k < now)
                {
                    if (timeout.Callback(this))
                        AddTimeout(timeout.Span, timeout);
                }
                else
                {
                    lock (timeoutsLockToken)
                    {
                        timeouts.Add(NudgeToUniqueKey(k), timeout);
                    }
                }
            }
        }

        /// <summary>
        /// Finds the closest number to <paramref name="k"/> that is not
        /// present in <see cref="timeouts"/> (incrementally).
        /// </summary>
        /// <param name="k"></param>
        /// <returns></returns>
        private long NudgeToUniqueKey(long k)
        {
            lock (timeoutsLockToken)
            {
                while (timeouts.ContainsKey(k))
                {
                    k++;
                }
            }

            return k;
        }

        void RunIdle()
        {
            List<Func<bool>> iterate;
            lock (idleHandlersLock)
            {
                iterate = idleHandlers;
                idleHandlers = new List<Func<bool>>();
            }

            foreach (var idle in iterate)
            {
                if (idle())
                    lock (idleHandlersLock)
                        idleHandlers.Add(idle);
            }
        }

        bool running;

        /// <summary>
        ///   Stops the mainloop.
        /// </summary>
        public void Stop()
        {
            running = false;
            Driver.Wakeup();
        }

        /// <summary>
        ///   Determines whether there are pending events to be processed.
        /// </summary>
        /// <remarks>
        ///   You can use this method if you want to probe if events are pending.
        ///   Typically used if you need to flush the input queue while still
        ///   running some of your own code in your main thread.
        /// </remarks>
        public bool EventsPending(bool wait = false)
        {
            return Driver.EventsPending(wait);
        }

        /// <summary>
        ///   Runs one iteration of timers and file watches
        /// </summary>
        /// <remarks>
        ///   You use this to process all pending events (timers, idle handlers and file watches).
        ///
        ///   You can use it like this:
        ///     while (main.EvensPending ()) MainIteration ();
        /// </remarks>
        public void MainIteration()
        {
            if (timeouts.Count > 0)
                RunTimers();

            Driver.MainIteration();

            bool runIdle = false;
            lock (idleHandlersLock)
            {
                runIdle = idleHandlers.Count > 0;
            }
            if (runIdle)
            {
                RunIdle();
            }
        }

        /// <summary>
        ///   Runs the mainloop.
        /// </summary>
        public void Run()
        {
            bool prev = running;
            running = true;
            while (running)
            {
                EventsPending(true);
                MainIteration();
            }
            running = prev;
        }
    }
    //=======================================================================
    /// <summary>
    /// Specifies how a <see cref="MenuItem"/> shows selection state. 
    /// </summary>
    [Flags]
    public enum MenuItemCheckStyle
    {
        /// <summary>
        /// The menu item will be shown normally, with no check indicator. The default.
        /// </summary>
        NoCheck = 0b_0000_0000,

        /// <summary>
        /// The menu item will indicate checked/un-checked state (see <see cref="Checked"/>).
        /// </summary>
        Checked = 0b_0000_0001,

        /// <summary>
        /// The menu item is part of a menu radio group (see <see cref="Checked"/>) and will indicate selected state.
        /// </summary>
        Radio = 0b_0000_0010,
    };

    /// <summary>
    /// A <see cref="MenuItem"/> has title, an associated help text, and an action to execute on activation. 
    /// MenuItems can also have a checked indicator (see <see cref="Checked"/>).
    /// </summary>
    public class MenuItem
    {
        //*master//
        public ScriptEngine.Machine.IValue Tag { get; set; }
        //master*//

        ustring title;
        ShortcutHelper shortcutHelper;
        internal int TitleLength => GetMenuBarItemLength(Title);

        /// <summary>
        /// Gets or sets arbitrary data for the menu item.
        /// </summary>
        /// <remarks>This property is not used internally.</remarks>
        public object Data { get; set; }

        /// <summary>
        /// Initializes a new instance of <see cref="MenuItem"/>
        /// </summary>
        public MenuItem(Key shortcut = Key.Null) : this("", "", null, null, null, shortcut) { }

        /// <summary>
        /// Initializes a new instance of <see cref="MenuItem"/>.
        /// </summary>
        /// <param name="title">Title for the menu item.</param>
        /// <param name="help">Help text to display.</param>
        /// <param name="action">Action to invoke when the menu item is activated.</param>
        /// <param name="canExecute">Function to determine if the action can currently be executed.</param>
        /// <param name="parent">The <see cref="Parent"/> of this menu item.</param>
        /// <param name="shortcut">The <see cref="Shortcut"/> keystroke combination.</param>
        public MenuItem(ustring title, ustring help, Action action, Func<bool> canExecute = null, MenuItem parent = null, Key shortcut = Key.Null)
        {
            Title = title ?? "";
            Help = help ?? "";
            Action = action;
            CanExecute = canExecute;
            Parent = parent;
            shortcutHelper = new ShortcutHelper();
            if (shortcut != Key.Null)
            {
                shortcutHelper.Shortcut = shortcut;
            }
        }

        /// <summary>
        /// The HotKey is used to activate a <see cref="MenuItem"/> with the keyboard. HotKeys are defined by prefixing the <see cref="Title"/>
        /// of a MenuItem with an underscore ('_'). 
        /// <para>
        /// Pressing Alt-Hotkey for a <see cref="MenuBarItem"/> (menu items on the menu bar) works even if the menu is not active). 
        /// Once a menu has focus and is active, pressing just the HotKey will activate the MenuItem.
        /// </para>
        /// <para>
        /// For example for a MenuBar with a "_File" MenuBarItem that contains a "_New" MenuItem, Alt-F will open the File menu.
        /// Pressing the N key will then activate the New MenuItem.
        /// </para>
        /// <para>
        /// See also <see cref="Shortcut"/> which enable global key-bindings to menu items.
        /// </para>
        /// </summary>
        public Rune HotKey;

        /// <summary>
        /// Shortcut defines a key binding to the MenuItem that will invoke the MenuItem's action globally for the <see cref="View"/> that is
        /// the parent of the <see cref="MenuBar"/> or <see cref="ContextMenu"/> this <see cref="MenuItem"/>.
        /// <para>
        /// The <see cref="Key"/> will be drawn on the MenuItem to the right of the <see cref="Title"/> and <see cref="Help"/> text. See <see cref="ShortcutTag"/>.
        /// </para>
        /// </summary>
        public Key Shortcut
        {
            get => shortcutHelper.Shortcut;
            set
            {
                if (shortcutHelper.Shortcut != value && (ShortcutHelper.PostShortcutValidation(value) || value == Key.Null))
                {
                    shortcutHelper.Shortcut = value;
                }
            }
        }

        /// <summary>
        /// Gets the text describing the keystroke combination defined by <see cref="Shortcut"/>.
        /// </summary>
        public ustring ShortcutTag => ShortcutHelper.GetShortcutTag(shortcutHelper.Shortcut);

        /// <summary>
        /// Gets or sets the title of the menu item .
        /// </summary>
        /// <value>The title.</value>
        public ustring Title
        {
            get { return title; }
            set
            {
                if (title != value)
                {
                    title = value;
                    GetHotKey();
                }
            }
        }

        /// <summary>
        /// Gets or sets the help text for the menu item. The help text is drawn to the right of the <see cref="Title"/>.
        /// </summary>
        /// <value>The help text.</value>
        public ustring Help { get; set; }

        /// <summary>
        /// Gets or sets the action to be invoked when the menu item is triggered.
        /// </summary>
        /// <value>Method to invoke.</value>
        public Action Action { get; set; }

        /// <summary>
        /// Gets or sets the action to be invoked to determine if the menu can be triggered. If <see cref="CanExecute"/> returns <see langword="true"/>
        /// the menu item will be enabled. Otherwise, it will be disabled. 
        /// </summary>
        /// <value>Function to determine if the action is can be executed or not.</value>
        public Func<bool> CanExecute { get; set; }

        /// <summary>
        /// Returns <see langword="true"/> if the menu item is enabled. This method is a wrapper around <see cref="CanExecute"/>.
        /// </summary>
        public bool IsEnabled()
        {
            return CanExecute == null ? true : CanExecute();
        }

        // 
        // ┌─────────────────────────────┐
        // │ Quit  Quit UI Catalog  Ctrl+Q │
        // └─────────────────────────────┘
        // ┌─────────────────┐
        // │ ◌ TopLevel Alt+T │
        // └─────────────────┘
        // TODO: Replace the `2` literals with named constants 
        internal int Width => 1 + // space before Title
            TitleLength +
            2 + // space after Title - BUGBUG: This should be 1 
            (Checked || CheckType.HasFlag(MenuItemCheckStyle.Checked) || CheckType.HasFlag(MenuItemCheckStyle.Radio) ? 2 : 0) + // check glyph + space 
            (Help.ConsoleWidth > 0 ? 2 + Help.ConsoleWidth : 0) + // Two spaces before Help
            (ShortcutTag.ConsoleWidth > 0 ? 2 + ShortcutTag.ConsoleWidth : 0); // Pad two spaces before shortcut tag (which are also aligned right)

        /// <summary>
        /// Sets or gets whether the <see cref="MenuItem"/> shows a check indicator or not. See <see cref="MenuItemCheckStyle"/>.
        /// </summary>
        public bool Checked { set; get; }

        /// <summary>
        /// Sets or gets the <see cref="MenuItemCheckStyle"/> of a menu item where <see cref="Checked"/> is set to <see langword="true"/>.
        /// </summary>
        public MenuItemCheckStyle CheckType { get; set; }

        /// <summary>
        /// Gets the parent for this <see cref="MenuItem"/>.
        /// </summary>
        /// <value>The parent.</value>
        public MenuItem Parent { get; internal set; }

        /// <summary>
        /// Gets if this <see cref="MenuItem"/> is from a sub-menu.
        /// </summary>
        internal bool IsFromSubMenu { get { return Parent != null; } }

        /// <summary>
        /// Merely a debugging aid to see the interaction with main.
        /// </summary>
        public MenuItem GetMenuItem()
        {
            return this;
        }

        /// <summary>
        /// Merely a debugging aid to see the interaction with main.
        /// </summary>
        public bool GetMenuBarItem()
        {
            return IsFromSubMenu;
        }

        void GetHotKey()
        {
            bool nextIsHot = false;
            foreach (var x in title)
            {
                if (x == MenuBar.HotKeySpecifier)
                {
                    nextIsHot = true;
                }
                else
                {
                    if (nextIsHot)
                    {
                        HotKey = Char.ToUpper((char)x);
                        break;
                    }
                    nextIsHot = false;
                    HotKey = default;
                }
            }
        }

        int GetMenuBarItemLength(ustring title)
        {
            int len = 0;
            foreach (var ch in title)
            {
                if (ch == MenuBar.HotKeySpecifier)
                    continue;
                len += Math.Max(Rune.ColumnWidth(ch), 1);
            }

            return len;
        }
    }

    /// <summary>
    /// <see cref="MenuBarItem"/> is a menu item on an app's <see cref="MenuBar"/>. 
    /// MenuBarItems do not support <see cref="MenuItem.Shortcut"/>.
    /// </summary>
    public class MenuBarItem : MenuItem
    {
        /// <summary>
        /// Initializes a new <see cref="MenuBarItem"/> as a <see cref="MenuItem"/>.
        /// </summary>
        /// <param name="title">Title for the menu item.</param>
        /// <param name="help">Help text to display. Will be displayed next to the Title surrounded by parentheses.</param>
        /// <param name="action">Action to invoke when the menu item is activated.</param>
        /// <param name="canExecute">Function to determine if the action can currently be executed.</param>
        /// <param name="parent">The parent <see cref="MenuItem"/> of this if exist, otherwise is null.</param>
        public MenuBarItem(ustring title, ustring help, Action action, Func<bool> canExecute = null, MenuItem parent = null) : base(title, help, action, canExecute, parent)
        {
            Initialize(title, null, null, true);
        }

        /// <summary>
        /// Initializes a new <see cref="MenuBarItem"/>.
        /// </summary>
        /// <param name="title">Title for the menu item.</param>
        /// <param name="children">The items in the current menu.</param>
        /// <param name="parent">The parent <see cref="MenuItem"/> of this if exist, otherwise is null.</param>
        public MenuBarItem(ustring title, MenuItem[] children, MenuItem parent = null)
        {
            Initialize(title, children, parent);
        }

        /// <summary>
        /// Initializes a new <see cref="MenuBarItem"/> with separate list of items.
        /// </summary>
        /// <param name="title">Title for the menu item.</param>
        /// <param name="children">The list of items in the current menu.</param>
        /// <param name="parent">The parent <see cref="MenuItem"/> of this if exist, otherwise is null.</param>
        public MenuBarItem(ustring title, List<MenuItem[]> children, MenuItem parent = null)
        {
            Initialize(title, children, parent);
        }

        /// <summary>
        /// Initializes a new <see cref="MenuBarItem"/>.
        /// </summary>
        /// <param name="children">The items in the current menu.</param>
        public MenuBarItem(MenuItem[] children) : this("", children) { }

        /// <summary>
        /// Initializes a new <see cref="MenuBarItem"/>.
        /// </summary>
        public MenuBarItem() : this(children: new MenuItem[] { }) { }

        void Initialize(ustring title, object children, MenuItem parent = null, bool isTopLevel = false)
        {
            if (!isTopLevel && children == null)
            {
                throw new ArgumentNullException(nameof(children), "The parameter cannot be null. Use an empty array instead.");
            }
            SetTitle(title ?? "");
            if (parent != null)
            {
                Parent = parent;
            }
            if (children is List<MenuItem[]>)
            {
                MenuItem[] childrens = new MenuItem[] { };
                foreach (var item in (List<MenuItem[]>)children)
                {
                    for (int i = 0; i < item.Length; i++)
                    {
                        SetChildrensParent(item);
                        Array.Resize(ref childrens, childrens.Length + 1);
                        childrens[childrens.Length - 1] = item[i];
                    }
                }
                Children = childrens;
            }
            else if (children is MenuItem[])
            {
                SetChildrensParent((MenuItem[])children);
                Children = (MenuItem[])children;
            }
            else
            {
                Children = null;
            }
        }

        void SetChildrensParent(MenuItem[] childrens)
        {
            foreach (var child in childrens)
            {
                if (child != null && child.Parent == null)
                {
                    child.Parent = this;
                }
            }
        }

        /// <summary>
        /// Check if the children parameter is a <see cref="MenuBarItem"/>.
        /// </summary>
        /// <param name="children"></param>
        /// <returns>Returns a <see cref="MenuBarItem"/> or null otherwise.</returns>
        public MenuBarItem SubMenu(MenuItem children)
        {
            return children as MenuBarItem;
        }

        /// <summary>
        /// Check if the <see cref="MenuItem"/> parameter is a child of this.
        /// </summary>
        /// <param name="menuItem"></param>
        /// <returns>Returns <c>true</c> if it is a child of this. <c>false</c> otherwise.</returns>
        public bool IsSubMenuOf(MenuItem menuItem)
        {
            foreach (var child in Children)
            {
                if (child == menuItem && child.Parent == menuItem.Parent)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Get the index of the <see cref="MenuItem"/> parameter.
        /// </summary>
        /// <param name="children"></param>
        /// <returns>Returns a value bigger than -1 if the <see cref="MenuItem"/> is a child of this.</returns>
        public int GetChildrenIndex(MenuItem children)
        {
            if (Children?.Length == 0)
            {
                return -1;
            }
            int i = 0;
            foreach (var child in Children)
            {
                if (child == children)
                {
                    return i;
                }
                i++;
            }
            return -1;
        }

        void SetTitle(ustring title)
        {
            if (title == null)
                title = ustring.Empty;
            Title = title;
        }

        /// <summary>
        /// Gets or sets an array of <see cref="MenuItem"/> objects that are the children of this <see cref="MenuBarItem"/>
        /// </summary>
        /// <value>The children.</value>
        public MenuItem[] Children { get; set; }

        internal bool IsTopLevel { get => Parent == null && (Children == null || Children.Length == 0) && Action != null; }
    }

    class Menu : View
    {
        internal MenuBarItem barItems;
        internal MenuBar host;
        internal int current;
        internal View previousSubFocused;

        internal static Rect MakeFrame(int x, int y, MenuItem[] items, Menu parent = null)
        {
            if (items == null || items.Length == 0)
            {
                return new Rect();
            }
            int minX = x;
            int minY = y;
            int maxW = (items.Max(z => z?.Width) ?? 0) + 2; // This 2 is frame border?
            int maxH = items.Length + 2; // This 2 is frame border?
            if (parent != null && x + maxW > Driver.Cols)
            {
                minX = Math.Max(parent.Frame.Right - parent.Frame.Width - maxW, 0);
            }
            if (y + maxH > Driver.Rows)
            {
                minY = Math.Max(Driver.Rows - maxH, 0);
            }
            return new Rect(minX, minY, maxW, maxH);
        }

        public Menu(MenuBar host, int x, int y, MenuBarItem barItems, Menu parent = null)
            : base(MakeFrame(x, y, barItems.Children, parent))
        {
            this.barItems = barItems;
            this.host = host;
            if (barItems.IsTopLevel)
            {
                // This is a standalone MenuItem on a MenuBar
                ColorScheme = host.ColorScheme;
                CanFocus = true;
            }
            else
            {

                current = -1;
                for (int i = 0; i < barItems.Children?.Length; i++)
                {
                    if (barItems.Children[i]?.IsEnabled() == true)
                    {
                        current = i;
                        break;
                    }
                }
                ColorScheme = host.ColorScheme;
                CanFocus = true;
                WantMousePositionReports = host.WantMousePositionReports;
            }

            if (Application.Current != null)
            {
                Application.Current.Resized += Current_Resized;
            }

            // Things this view knows how to do
            AddCommand(Command.LineUp, () => MoveUp());
            AddCommand(Command.LineDown, () => MoveDown());
            AddCommand(Command.Left, () => { this.host.PreviousMenu(true); return true; });
            AddCommand(Command.Right, () =>
            {
                this.host.NextMenu(!this.barItems.IsTopLevel || (this.barItems.Children != null
                    && this.barItems.Children.Length > 0 && current > -1
                    && current < this.barItems.Children.Length && this.barItems.Children[current].IsFromSubMenu),
                    this.barItems.Children != null && this.barItems.Children.Length > 0 && current > -1
                    && host.UseSubMenusSingleFrame && this.barItems.SubMenu(this.barItems.Children[current]) != null);

                return true;
            });
            AddCommand(Command.Cancel, () => { CloseAllMenus(); return true; });
            AddCommand(Command.Accept, () => { RunSelected(); return true; });

            // Default keybindings for this view
            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.CursorDown, Command.LineDown);
            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.Esc, Command.Cancel);
            AddKeyBinding(Key.Enter, Command.Accept);
        }

        private void Current_Resized(Size obj)
        {
            if (host.IsMenuOpen)
            {
                host.CloseAllMenus();
            }
        }

        internal Attribute DetermineColorSchemeFor(MenuItem item, int index)
        {
            if (item != null)
            {
                if (index == current) return ColorScheme.Focus;
                if (!item.IsEnabled()) return ColorScheme.Disabled;
            }
            return GetNormalColor();
        }

        // Draws the Menu, within the Frame
        public override void Redraw(Rect bounds)
        {
            Driver.SetAttribute(GetNormalColor());
            DrawFrame(Bounds, padding: 0, fill: true);

            for (int i = Bounds.Y; i < barItems.Children.Length; i++)
            {
                if (i < 0)
                    continue;
                var item = barItems.Children[i];
                Driver.SetAttribute(item == null ? GetNormalColor()
                    : i == current ? ColorScheme.Focus : GetNormalColor());
                if (item == null)
                {
                    Move(0, i + 1);
                    Driver.AddRune(Driver.LeftTee);
                }
                else if (Frame.X + 1 < Driver.Cols)
                    Move(1, i + 1);

                Driver.SetAttribute(DetermineColorSchemeFor(item, i));
                for (int p = Bounds.X; p < Frame.Width - 2; p++)
                { // This - 2 is for the border
                    if (p < 0)
                        continue;
                    if (item == null)
                        Driver.AddRune(Driver.HLine);
                    else if (i == 0 && p == 0 && host.UseSubMenusSingleFrame && item.Parent.Parent != null)
                        Driver.AddRune(Driver.LeftArrow);
                    // This `- 3` is left border + right border + one row in from right
                    else if (p == Frame.Width - 3 && barItems.SubMenu(barItems.Children[i]) != null)
                        Driver.AddRune(Driver.RightArrow);
                    else
                        Driver.AddRune(' ');
                }

                if (item == null)
                {
                    if (SuperView?.Frame.Right - Frame.X > Frame.Width - 1)
                    {
                        Move(Frame.Width - 1, i + 1);
                        Driver.AddRune(Driver.RightTee);
                    }
                    continue;
                }

                ustring textToDraw;
                var checkChar = Driver.Selected;
                var uncheckedChar = Driver.UnSelected;

                if (item.CheckType.HasFlag(MenuItemCheckStyle.Checked))
                {
                    checkChar = Driver.Checked;
                    uncheckedChar = Driver.UnChecked;
                }

                // Support Checked even though CheckType wasn't set
                if (item.Checked)
                {
                    textToDraw = ustring.Make(new Rune[] { checkChar, ' ' }) + item.Title;
                }
                else if (item.CheckType.HasFlag(MenuItemCheckStyle.Checked) || item.CheckType.HasFlag(MenuItemCheckStyle.Radio))
                {
                    textToDraw = ustring.Make(new Rune[] { uncheckedChar, ' ' }) + item.Title;
                }
                else
                {
                    textToDraw = item.Title;
                }

                ViewToScreen(2, i + 1, out int vtsCol, out _, false);
                if (vtsCol < Driver.Cols)
                {
                    Move(2, i + 1);
                    if (!item.IsEnabled())
                    {
                        DrawHotString(textToDraw, ColorScheme.Disabled, ColorScheme.Disabled);
                    }
                    else if (i == 0 && host.UseSubMenusSingleFrame && item.Parent.Parent != null)
                    {
                        var tf = new TextFormatter()
                        {
                            Alignment = TextAlignment.Centered,
                            HotKeySpecifier = MenuBar.HotKeySpecifier,
                            Text = textToDraw
                        };
                        // The -3 is left/right border + one space (not sure what for)
                        tf.Draw(ViewToScreen(new Rect(2, i + 1, Frame.Width - 3, 1)),
                            i == current ? ColorScheme.Focus : GetNormalColor(),
                            i == current ? ColorScheme.HotFocus : ColorScheme.HotNormal,
                            SuperView == null ? default : SuperView.ViewToScreen(SuperView.Bounds));
                    }
                    else
                    {
                        DrawHotString(textToDraw,
                            i == current ? ColorScheme.HotFocus : ColorScheme.HotNormal,
                            i == current ? ColorScheme.Focus : GetNormalColor());
                    }

                    // The help string
                    var l = item.ShortcutTag.ConsoleWidth == 0 ? item.Help.ConsoleWidth : item.Help.ConsoleWidth + item.ShortcutTag.ConsoleWidth + 2;
                    var col = Frame.Width - l - 2;
                    ViewToScreen(col, i + 1, out vtsCol, out _, false);
                    if (vtsCol < Driver.Cols)
                    {
                        Move(col, 1 + i);
                        Driver.AddStr(item.Help);

                        // The shortcut tag string
                        if (!item.ShortcutTag.IsEmpty)
                        {
                            l = item.ShortcutTag.ConsoleWidth;
                            Move(Frame.Width - l - 2, 1 + i);
                            Driver.AddStr(item.ShortcutTag);
                        }
                    }
                }
            }
            PositionCursor();
        }

        public override void PositionCursor()
        {
            if (host == null || host.IsMenuOpen)
                if (barItems.IsTopLevel)
                {
                    host.PositionCursor();
                }
                else
                    Move(2, 1 + current);
            else
                host.PositionCursor();
        }

        public void Run(Action action)
        {
            if (action == null || host == null)
                return;

            Application.UngrabMouse();
            host.CloseAllMenus();
            Application.Refresh();

            host.Run(action);
        }

        public override bool OnLeave(View view)
        {
            return host.OnLeave(view);
        }

        public override bool OnKeyDown(KeyEvent keyEvent)
        {
            if (keyEvent.IsAlt)
            {
                host.CloseAllMenus();
                return true;
            }

            return false;
        }

        public override bool ProcessHotKey(KeyEvent keyEvent)
        {
            // To ncurses simulate a AltMask key pressing Alt+Space because
            // it can�t detect an alone special key down was pressed.
            if (keyEvent.IsAlt && keyEvent.Key == Key.AltMask)
            {
                OnKeyDown(keyEvent);
                return true;
            }

            return false;
        }

        public override bool ProcessKey(KeyEvent kb)
        {
            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            // TODO: rune-ify
            if (barItems.Children != null && Char.IsLetterOrDigit((char)kb.KeyValue))
            {
                var x = Char.ToUpper((char)kb.KeyValue);
                var idx = -1;
                foreach (var item in barItems.Children)
                {
                    idx++;
                    if (item == null) continue;
                    if (item.IsEnabled() && item.HotKey == x)
                    {
                        current = idx;
                        RunSelected();
                        return true;
                    }
                }
            }
            return host.ProcessHotKey(kb);
        }

        void RunSelected()
        {
            if (barItems.IsTopLevel)
            {
                Run(barItems.Action);
            }
            else if (current > -1 && barItems.Children[current].Action != null)
            {
                Run(barItems.Children[current].Action);
            }
            else if (current == 0 && host.UseSubMenusSingleFrame
              && barItems.Children[current].Parent.Parent != null)
            {

                host.PreviousMenu(barItems.Children[current].Parent.IsFromSubMenu, true);
            }
            else if (current > -1 && barItems.SubMenu(barItems.Children[current]) != null)
            {

                CheckSubMenu();
            }
        }

        void CloseAllMenus()
        {
            Application.UngrabMouse();
            host.CloseAllMenus();
        }

        bool MoveDown()
        {
            if (barItems.IsTopLevel)
            {
                return true;
            }
            bool disabled;
            do
            {
                current++;
                if (current >= barItems.Children.Length)
                {
                    current = 0;
                }
                if (this != host.openCurrentMenu && barItems.Children[current]?.IsFromSubMenu == true && host.selectedSub > -1)
                {
                    host.PreviousMenu(true);
                    host.SelectEnabledItem(barItems.Children, current, out current);
                    host.openCurrentMenu = this;
                }
                var item = barItems.Children[current];
                if (item?.IsEnabled() != true)
                {
                    disabled = true;
                }
                else
                {
                    disabled = false;
                }
                if (!host.UseSubMenusSingleFrame && host.UseKeysUpDownAsKeysLeftRight && barItems.SubMenu(barItems.Children[current]) != null &&
                    !disabled && host.IsMenuOpen)
                {
                    if (!CheckSubMenu())
                        return false;
                    break;
                }
                if (!host.IsMenuOpen)
                {
                    host.OpenMenu(host.selected);
                }
            } while (barItems.Children[current] == null || disabled);
            SetNeedsDisplay();
            SetParentSetNeedsDisplay();
            if (!host.UseSubMenusSingleFrame)
                host.OnMenuOpened();
            return true;
        }

        bool MoveUp()
        {
            if (barItems.IsTopLevel || current == -1)
            {
                return true;
            }
            bool disabled;
            do
            {
                current--;
                if (host.UseKeysUpDownAsKeysLeftRight && !host.UseSubMenusSingleFrame)
                {
                    if ((current == -1 || this != host.openCurrentMenu) && barItems.Children[current + 1].IsFromSubMenu && host.selectedSub > -1)
                    {
                        current++;
                        host.PreviousMenu(true);
                        if (current > 0)
                        {
                            current--;
                            host.openCurrentMenu = this;
                        }
                        break;
                    }
                }
                if (current < 0)
                    current = barItems.Children.Length - 1;
                if (!host.SelectEnabledItem(barItems.Children, current, out current, false))
                {
                    current = 0;
                    if (!host.SelectEnabledItem(barItems.Children, current, out current) && !host.CloseMenu(false))
                    {
                        return false;
                    }
                    break;
                }
                var item = barItems.Children[current];
                if (item?.IsEnabled() != true)
                {
                    disabled = true;
                }
                else
                {
                    disabled = false;
                }
                if (!host.UseSubMenusSingleFrame && host.UseKeysUpDownAsKeysLeftRight && barItems.SubMenu(barItems.Children[current]) != null &&
                    !disabled && host.IsMenuOpen)
                {
                    if (!CheckSubMenu())
                        return false;
                    break;
                }
            } while (barItems.Children[current] == null || disabled);
            SetNeedsDisplay();
            SetParentSetNeedsDisplay();
            if (!host.UseSubMenusSingleFrame)
                host.OnMenuOpened();
            return true;
        }

        private void SetParentSetNeedsDisplay()
        {
            if (host.openSubMenu != null)
            {
                foreach (var menu in host.openSubMenu)
                {
                    menu.SetNeedsDisplay();
                }
            }

            host?.openMenu.SetNeedsDisplay();
            host.SetNeedsDisplay();
        }

        public override bool MouseEvent(MouseEvent me)
        {
            if (!host.handled && !host.HandleGrabView(me, this))
            {
                return false;
            }
            host.handled = false;
            bool disabled;
            if (me.Flags == MouseFlags.Button1Clicked)
            {
                disabled = false;
                if (me.Y < 1)
                    return true;
                var meY = me.Y - 1;
                if (meY >= barItems.Children.Length)
                    return true;
                var item = barItems.Children[meY];
                if (item == null || !item.IsEnabled()) disabled = true;
                if (disabled) return true;
                current = meY;
                if (item != null && !disabled)
                    RunSelected();
                return true;
            }
            else if (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked ||
              me.Flags == MouseFlags.Button1TripleClicked || me.Flags == MouseFlags.ReportMousePosition ||
              me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition))
            {

                disabled = false;
                if (me.Y < 1 || me.Y - 1 >= barItems.Children.Length)
                {
                    return true;
                }
                var item = barItems.Children[me.Y - 1];
                if (item == null) return true;
                if (item == null || !item.IsEnabled()) disabled = true;
                if (item != null && !disabled)
                    current = me.Y - 1;
                if (host.UseSubMenusSingleFrame || !CheckSubMenu())
                {
                    SetNeedsDisplay();
                    SetParentSetNeedsDisplay();
                    return true;
                }
                host.OnMenuOpened();
                return true;
            }
            return false;
        }

        internal bool CheckSubMenu()
        {
            if (current == -1 || barItems.Children[current] == null)
            {
                return true;
            }
            var subMenu = barItems.SubMenu(barItems.Children[current]);
            if (subMenu != null)
            {
                int pos = -1;
                if (host.openSubMenu != null)
                {
                    pos = host.openSubMenu.FindIndex(o => o?.barItems == subMenu);
                }
                if (pos == -1 && this != host.openCurrentMenu && subMenu.Children != host.openCurrentMenu.barItems.Children
                    && !host.CloseMenu(false, true))
                {
                    return false;
                }
                host.Activate(host.selected, pos, subMenu);
            }
            else if (host.openSubMenu?.Count == 0 || host.openSubMenu?.Last().barItems.IsSubMenuOf(barItems.Children[current]) == false)
            {
                return host.CloseMenu(false, true);
            }
            else
            {
                SetNeedsDisplay();
                SetParentSetNeedsDisplay();
            }
            return true;
        }

        int GetSubMenuIndex(MenuBarItem subMenu)
        {
            int pos = -1;
            if (this != null && Subviews.Count > 0)
            {
                Menu v = null;
                foreach (var menu in Subviews)
                {
                    if (((Menu)menu).barItems == subMenu)
                        v = (Menu)menu;
                }
                if (v != null)
                    pos = Subviews.IndexOf(v);
            }

            return pos;
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }

        protected override void Dispose(bool disposing)
        {
            if (Application.Current != null)
            {
                Application.Current.Resized -= Current_Resized;
            }

            base.Dispose(disposing);
        }
    }

    /// <summary>
    ///	<para>
    /// Provides a menu bar that spans the top of a <see cref="Toplevel"/> View with drop-down and cascading menus. 
    ///	</para>
    /// <para>
    /// By default, any sub-sub-menus (sub-menus of the <see cref="MenuItem"/>s added to <see cref="MenuBarItem"/>s) 
    /// are displayed in a cascading manner, where each sub-sub-menu pops out of the sub-menu frame
    /// (either to the right or left, depending on where the sub-menu is relative to the edge of the screen). By setting
    /// <see cref="UseSubMenusSingleFrame"/> to <see langword="true"/>, this behavior can be changed such that all sub-sub-menus are
    /// drawn within a single frame below the MenuBar.
    /// </para>
    /// </summary>
    /// <remarks>
    ///	<para>
    ///	The <see cref="MenuBar"/> appears on the first row of the parent <see cref="Toplevel"/> View and uses the full width.
    ///	</para>
    ///	<para>
    ///	The <see cref="MenuBar"/> provides global hotkeys for the application. See <see cref="MenuItem.HotKey"/>.
    ///	</para>
    ///	<para>
    ///	See also: <see cref="ContextMenu"/>
    ///	</para>
    /// </remarks>
    public class MenuBar : View
    {
        internal int selected;
        internal int selectedSub;

        /// <summary>
        /// Gets or sets the array of <see cref="MenuBarItem"/>s for the menu. Only set this after the <see cref="MenuBar"/> is visible.
        /// </summary>
        /// <value>The menu array.</value>
        public MenuBarItem[] Menus { get; set; }

        private bool useKeysUpDownAsKeysLeftRight = false;

        /// <summary>
        /// Used for change the navigation key style.
        /// </summary>
        public bool UseKeysUpDownAsKeysLeftRight
        {
            get => useKeysUpDownAsKeysLeftRight;
            set
            {
                useKeysUpDownAsKeysLeftRight = value;
                if (value && UseSubMenusSingleFrame)
                {
                    UseSubMenusSingleFrame = false;
                    SetNeedsDisplay();
                }
            }
        }

        static ustring shortcutDelimiter = "+";
        /// <summary>
        /// Sets or gets the shortcut delimiter separator. The default is "+".
        /// </summary>
        public static ustring ShortcutDelimiter
        {
            get => shortcutDelimiter;
            set
            {
                if (shortcutDelimiter != value)
                {
                    shortcutDelimiter = value == ustring.Empty ? " " : value;
                }
            }
        }

        /// <summary>
        /// The specifier character for the hotkey to all menus.
        /// </summary>
        new public static Rune HotKeySpecifier => '_';

        private bool useSubMenusSingleFrame;

        /// <summary>
        /// Gets or sets if the sub-menus must be displayed in a single or multiple frames.
        /// <para>
        /// By default any sub-sub-menus (sub-menus of the main <see cref="MenuItem"/>s) are displayed in a cascading manner, 
        /// where each sub-sub-menu pops out of the sub-menu frame
        /// (either to the right or left, depending on where the sub-menu is relative to the edge of the screen). By setting
        /// <see cref="UseSubMenusSingleFrame"/> to <see langword="true"/>, this behavior can be changed such that all sub-sub-menus are
        /// drawn within a single frame below the MenuBar.
        /// </para>		
        /// </summary>
        public bool UseSubMenusSingleFrame
        {
            get => useSubMenusSingleFrame;
            set
            {
                useSubMenusSingleFrame = value;
                if (value && UseKeysUpDownAsKeysLeftRight)
                {
                    useKeysUpDownAsKeysLeftRight = false;
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// The <see cref="Gui.Key"/> used to activate the menu bar by keyboard.
        /// </summary>
        public Key Key { get; set; } = Key.F9;

        ///<inheritdoc/>
        public override bool Visible
        {
            get => base.Visible;
            set
            {
                base.Visible = value;
                if (!value)
                {
                    CloseAllMenus();
                }
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MenuBar"/>.
        /// </summary>
        public MenuBar() : this(new MenuBarItem[] { }) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="MenuBar"/> class with the specified set of toplevel menu items.
        /// </summary>
        /// <param name="menus">Individual menu items; a null item will result in a separator being drawn.</param>
        public MenuBar(MenuBarItem[] menus) : base()
        {
            X = 0;
            Y = 0;
            Width = Dim.Fill();
            Height = 1;
            Menus = menus;
            //CanFocus = true;
            selected = -1;
            selectedSub = -1;
            ColorScheme = Colors.Menu;
            WantMousePositionReports = true;
            IsMenuOpen = false;

            // Things this view knows how to do
            AddCommand(Command.Left, () => { MoveLeft(); return true; });
            AddCommand(Command.Right, () => { MoveRight(); return true; });
            AddCommand(Command.Cancel, () => { CloseMenuBar(); return true; });
            AddCommand(Command.Accept, () => { ProcessMenu(selected, Menus[selected]); return true; });

            // Default keybindings for this view
            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.Esc, Command.Cancel);
            AddKeyBinding(Key.C | Key.CtrlMask, Command.Cancel);
            AddKeyBinding(Key.CursorDown, Command.Accept);
            AddKeyBinding(Key.Enter, Command.Accept);
        }

        bool openedByAltKey;

        bool isCleaning;

        ///<inheritdoc/>
        public override bool OnLeave(View view)
        {
            if ((!(view is MenuBar) && !(view is Menu) || !(view is MenuBar) && !(view is Menu) && openMenu != null) && !isCleaning && !reopen)
            {
                CleanUp();
                return true;
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool OnKeyDown(KeyEvent keyEvent)
        {
            if (keyEvent.IsAlt || (keyEvent.IsCtrl && keyEvent.Key == (Key.CtrlMask | Key.Space)))
            {
                openedByAltKey = true;
                SetNeedsDisplay();
                openedByHotKey = false;
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool OnKeyUp(KeyEvent keyEvent)
        {
            if (keyEvent.IsAlt || keyEvent.Key == Key.AltMask || (keyEvent.IsCtrl && keyEvent.Key == (Key.CtrlMask | Key.Space)))
            {
                // User pressed Alt - this may be a precursor to a menu accelerator (e.g. Alt-F)
                if (openedByAltKey && !IsMenuOpen && openMenu == null && (((uint)keyEvent.Key & (uint)Key.CharMask) == 0
                    || ((uint)keyEvent.Key & (uint)Key.CharMask) == (uint)Key.Space))
                {
                    // There's no open menu, the first menu item should be highlight.
                    // The right way to do this is to SetFocus(MenuBar), but for some reason
                    // that faults.

                    var mbar = GetMouseGrabViewInstance(this);
                    if (mbar != null)
                    {
                        mbar.CleanUp();
                    }

                    //Activate (0);
                    //StartMenu ();
                    IsMenuOpen = true;
                    selected = 0;
                    CanFocus = true;
                    lastFocused = SuperView == null ? Application.Current.MostFocused : SuperView.MostFocused;
                    SetFocus();
                    SetNeedsDisplay();
                    Application.GrabMouse(this);
                }
                else if (!openedByHotKey)
                {
                    // There's an open menu. If this Alt key-up is a pre-cursor to an accelerator
                    // we don't want to close the menu because it'll flash.
                    // How to deal with that?

                    CleanUp();
                }

                return true;
            }
            return false;
        }

        internal void CleanUp()
        {
            isCleaning = true;
            if (openMenu != null)
            {
                CloseAllMenus();
            }
            openedByAltKey = false;
            IsMenuOpen = false;
            selected = -1;
            CanFocus = false;
            if (lastFocused != null)
            {
                lastFocused.SetFocus();
            }
            SetNeedsDisplay();
            Application.UngrabMouse();
            isCleaning = false;
        }

        // The column where the MenuBar starts
        static int xOrigin = 0;
        // Spaces before the Title
        static int leftPadding = 1;
        // Spaces after the Title
        static int rightPadding = 1;
        // Spaces after the submenu Title, before Help
        static int parensAroundHelp = 3;
        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            Move(0, 0);
            Driver.SetAttribute(GetNormalColor());
            for (int i = 0; i < Frame.Width; i++)
                Driver.AddRune(' ');

            Move(1, 0);
            int pos = 0;

            for (int i = 0; i < Menus.Length; i++)
            {
                var menu = Menus[i];
                Move(pos, 0);
                Attribute hotColor, normalColor;
                if (i == selected && IsMenuOpen)
                {
                    hotColor = i == selected ? ColorScheme.HotFocus : ColorScheme.HotNormal;
                    normalColor = i == selected ? ColorScheme.Focus : GetNormalColor();
                }
                else
                {
                    hotColor = ColorScheme.HotNormal;
                    normalColor = GetNormalColor();
                }
                // Note Help on MenuBar is drawn with parens around it
                DrawHotString(menu.Help.IsEmpty ? $" {menu.Title} " : $" {menu.Title} ({menu.Help}) ", hotColor, normalColor);
                pos += leftPadding + menu.TitleLength + (menu.Help.ConsoleWidth > 0 ? leftPadding + menu.Help.ConsoleWidth + parensAroundHelp : 0) + rightPadding;
            }
            PositionCursor();
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            if (selected == -1 && HasFocus && Menus.Length > 0)
            {
                selected = 0;
            }
            int pos = 0;
            for (int i = 0; i < Menus.Length; i++)
            {
                if (i == selected)
                {
                    pos++;
                    Move(pos + 1, 0);
                    return;
                }
                else
                {
                    pos += leftPadding + Menus[i].TitleLength + (Menus[i].Help.ConsoleWidth > 0 ? Menus[i].Help.ConsoleWidth + parensAroundHelp : 0) + rightPadding;
                }
            }
        }

        void Selected(MenuItem item)
        {
            var action = item.Action;

            if (action == null)
                return;

            Application.UngrabMouse();
            CloseAllMenus();
            Application.Refresh();
            Run(action);
        }

        internal void Run(Action action)
        {
            Application.MainLoop.AddIdle(() =>
            {
                action();
                return false;
            });

            CloseAllMenus();
        }

        /// <summary>
        /// Raised as a menu is opening.
        /// </summary>
        public event Action<MenuOpeningEventArgs> MenuOpening;

        /// <summary>
        /// Raised when a menu is opened.
        /// </summary>
        public event Action<MenuItem> MenuOpened;

        /// <summary>
        /// Raised when a menu is closing passing <see cref="MenuClosingEventArgs"/>.
        /// </summary>
        public event Action<MenuClosingEventArgs> MenuClosing;

        /// <summary>
        /// Raised when all the menu is closed.
        /// </summary>
        public event Action MenuAllClosed;

        internal Menu openMenu;
        Menu ocm;
        internal Menu openCurrentMenu
        {
            get => ocm;
            set
            {
                if (ocm != value)
                {
                    ocm = value;
                    if (ocm.current > -1)
                    {
                        OnMenuOpened();
                    }
                }
            }
        }
        internal List<Menu> openSubMenu;
        View previousFocused;
        internal bool isMenuOpening;
        internal bool isMenuClosing;

        /// <summary>
        /// <see langword="true"/> if the menu is open; otherwise <see langword="true"/>.
        /// </summary>
        public bool IsMenuOpen { get; protected set; }

        /// <summary>
        /// Virtual method that will invoke the <see cref="MenuOpening"/> event if it's defined.
        /// </summary>
        /// <param name="currentMenu">The current menu to be replaced.</param>
        /// <returns>Returns the <see cref="MenuOpeningEventArgs"/></returns>
        public virtual MenuOpeningEventArgs OnMenuOpening(MenuBarItem currentMenu)
        {
            var ev = new MenuOpeningEventArgs(currentMenu);
            MenuOpening?.Invoke(ev);
            return ev;
        }

        /// <summary>
        /// Virtual method that will invoke the <see cref="MenuOpened"/> event if it's defined.
        /// </summary>
        public virtual void OnMenuOpened()
        {
            MenuItem mi = null;
            if (openCurrentMenu.barItems.Children != null && openCurrentMenu.barItems.Children.Length > 0
                && openCurrentMenu?.current > -1)
            {

                mi = openCurrentMenu.barItems.Children[openCurrentMenu.current];
            }
            else if (openCurrentMenu.barItems.IsTopLevel)
            {
                mi = openCurrentMenu.barItems;
            }
            else if (openCurrentMenu?.current > -1)
            {
                mi = openMenu.barItems.Children[openMenu.current];
            }
            MenuOpened?.Invoke(mi);
        }

        /// <summary>
        /// Virtual method that will invoke the <see cref="MenuClosing"/>.
        /// </summary>
        /// <param name="currentMenu">The current menu to be closed.</param>
        /// <param name="reopen">Whether the current menu will be reopen.</param>
        /// <param name="isSubMenu">Whether is a sub-menu or not.</param>
        public virtual MenuClosingEventArgs OnMenuClosing(MenuBarItem currentMenu, bool reopen, bool isSubMenu)
        {
            var ev = new MenuClosingEventArgs(currentMenu, reopen, isSubMenu);
            MenuClosing?.Invoke(ev);
            return ev;
        }

        /// <summary>
        /// Virtual method that will invoke the <see cref="MenuAllClosed"/>.
        /// </summary>
        public virtual void OnMenuAllClosed()
        {
            MenuAllClosed?.Invoke();
        }

        View lastFocused;

        /// <summary>
        /// Gets the view that was last focused before opening the menu.
        /// </summary>
        public View LastFocused { get; private set; }

        internal void OpenMenu(int index, int sIndex = -1, MenuBarItem subMenu = null)
        {
            isMenuOpening = true;
            var newMenu = OnMenuOpening(Menus[index]);
            if (newMenu.Cancel)
            {
                isMenuOpening = false;
                return;
            }
            if (newMenu.NewMenuBarItem != null)
            {
                Menus[index] = newMenu.NewMenuBarItem;
            }
            int pos = 0;
            switch (subMenu)
            {
                case null:
                    // Open a submenu below a MenuBar
                    lastFocused = lastFocused ?? (SuperView == null ? Application.Current.MostFocused : SuperView.MostFocused);
                    if (openSubMenu != null && !CloseMenu(false, true))
                        return;
                    if (openMenu != null)
                    {
                        if (SuperView == null)
                        {
                            Application.Current.Remove(openMenu);
                        }
                        else
                        {
                            SuperView.Remove(openMenu);
                        }
                        openMenu.Dispose();
                    }

                    // This positions the submenu horizontally aligned with the first character of the
                    // menu it belongs to's text
                    for (int i = 0; i < index; i++)
                        pos += Menus[i].TitleLength + (Menus[i].Help.ConsoleWidth > 0 ? Menus[i].Help.ConsoleWidth + 2 : 0) + leftPadding + rightPadding;
                    openMenu = new Menu(this, Frame.X + pos, Frame.Y + 1, Menus[index]);
                    openCurrentMenu = openMenu;
                    openCurrentMenu.previousSubFocused = openMenu;

                    if (SuperView == null)
                    {
                        Application.Current.Add(openMenu);
                    }
                    else
                    {
                        SuperView.Add(openMenu);
                    }
                    openMenu.SetFocus();
                    break;
                default:
                    // Opens a submenu next to another submenu (openSubMenu)
                    if (openSubMenu == null)
                        openSubMenu = new List<Menu>();
                    if (sIndex > -1)
                    {
                        RemoveSubMenu(sIndex);
                    }
                    else
                    {
                        var last = openSubMenu.Count > 0 ? openSubMenu.Last() : openMenu;
                        if (!UseSubMenusSingleFrame)
                        {
                            openCurrentMenu = new Menu(this, last.Frame.Left + last.Frame.Width, last.Frame.Top + 1 + last.current, subMenu, last);
                        }
                        else
                        {
                            var first = openSubMenu.Count > 0 ? openSubMenu.First() : openMenu;
                            var mbi = new MenuItem[2 + subMenu.Children.Length];
                            mbi[0] = new MenuItem() { Title = subMenu.Title, Parent = subMenu };
                            mbi[1] = null;
                            for (int j = 0; j < subMenu.Children.Length; j++)
                            {
                                mbi[j + 2] = subMenu.Children[j];
                            }
                            var newSubMenu = new MenuBarItem(mbi);
                            openCurrentMenu = new Menu(this, first.Frame.Left, first.Frame.Top, newSubMenu);
                            last.Visible = false;
                            Application.GrabMouse(openCurrentMenu);
                        }
                        openCurrentMenu.previousSubFocused = last.previousSubFocused;
                        openSubMenu.Add(openCurrentMenu);
                        if (SuperView == null)
                        {
                            Application.Current.Add(openCurrentMenu);
                        }
                        else
                        {
                            SuperView.Add(openCurrentMenu);
                        }
                    }
                    selectedSub = openSubMenu.Count - 1;
                    if (selectedSub > -1 && SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current))
                    {
                        openCurrentMenu.SetFocus();
                    }
                    break;
            }
            isMenuOpening = false;
            IsMenuOpen = true;
        }

        private int openIndex = 0;
        public int OpenIndex
        {
            get { return openIndex; }
            set { openIndex = value; }
        }

        /// <summary>
        /// Opens the Menu programatically, as though the F9 key were pressed.
        /// </summary>
        public void OpenMenu()
        {
            var mbar = GetMouseGrabViewInstance(this);
            if (mbar != null)
            {
                mbar.CleanUp();
            }

            if (openMenu != null)
                return;
            selected = OpenIndex;
            SetNeedsDisplay();

            previousFocused = SuperView == null ? Application.Current.Focused : SuperView.Focused;
            OpenMenu(selected);
            if (!SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current) && !CloseMenu(false))
            {
                return;
            }
            if (!openCurrentMenu.CheckSubMenu())
                return;
            Application.GrabMouse(this);
        }

        // Activates the menu, handles either first focus, or activating an entry when it was already active
        // For mouse events.
        internal void Activate(int idx, int sIdx = -1, MenuBarItem subMenu = null)
        {
            selected = idx;
            selectedSub = sIdx;
            if (openMenu == null)
                previousFocused = SuperView == null ? Application.Current.Focused : SuperView.Focused;

            OpenMenu(idx, sIdx, subMenu);
            SetNeedsDisplay();
        }

        internal bool SelectEnabledItem(IEnumerable<MenuItem> chldren, int current, out int newCurrent, bool forward = true)
        {
            if (chldren == null)
            {
                newCurrent = -1;
                return true;
            }

            IEnumerable<MenuItem> childrens;
            if (forward)
            {
                childrens = chldren;
            }
            else
            {
                childrens = chldren.Reverse();
            }
            int count;
            if (forward)
            {
                count = -1;
            }
            else
            {
                count = childrens.Count();
            }
            foreach (var child in childrens)
            {
                if (forward)
                {
                    if (++count < current)
                    {
                        continue;
                    }
                }
                else
                {
                    if (--count > current)
                    {
                        continue;
                    }
                }
                if (child == null || !child.IsEnabled())
                {
                    if (forward)
                    {
                        current++;
                    }
                    else
                    {
                        current--;
                    }
                }
                else
                {
                    newCurrent = current;
                    return true;
                }
            }
            newCurrent = -1;
            return false;
        }

        /// <summary>
        /// Closes the Menu programmatically if open and not canceled (as though F9 were pressed).
        /// </summary>
        public bool CloseMenu(bool ignoreUseSubMenusSingleFrame = false)
        {
            return CloseMenu(false, false, ignoreUseSubMenusSingleFrame);
        }

        bool reopen;

        internal bool CloseMenu(bool reopen = false, bool isSubMenu = false, bool ignoreUseSubMenusSingleFrame = false)
        {
            var mbi = isSubMenu ? openCurrentMenu.barItems : openMenu?.barItems;
            if (UseSubMenusSingleFrame && mbi != null &&
                !ignoreUseSubMenusSingleFrame && mbi.Parent != null)
            {
                return false;
            }
            isMenuClosing = true;
            this.reopen = reopen;
            var args = OnMenuClosing(mbi, reopen, isSubMenu);
            if (args.Cancel)
            {
                isMenuClosing = false;
                if (args.CurrentMenu.Parent != null)
                    openMenu.current = ((MenuBarItem)args.CurrentMenu.Parent).Children.IndexOf(args.CurrentMenu);
                return false;
            }
            switch (isSubMenu)
            {
                case false:
                    if (openMenu != null)
                    {
                        if (SuperView == null)
                        {
                            Application.Current.Remove(openMenu);
                        }
                        else
                        {
                            SuperView?.Remove(openMenu);
                        }
                    }
                    SetNeedsDisplay();
                    if (previousFocused != null && previousFocused is Menu && openMenu != null && previousFocused.ToString() != openCurrentMenu.ToString())
                        previousFocused.SetFocus();
                    openMenu?.Dispose();
                    openMenu = null;
                    if (lastFocused is Menu || lastFocused is MenuBar)
                    {
                        lastFocused = null;
                    }
                    LastFocused = lastFocused;
                    lastFocused = null;
                    if (LastFocused != null && LastFocused.CanFocus)
                    {
                        if (!reopen)
                        {
                            selected = -1;
                        }
                        LastFocused.SetFocus();
                    }
                    else if (LastFocused == null && !IsMenuOpen)
                    {
                        Application.Current?.FocusFirst();
                    }
                    else
                    {
                        SetFocus();
                        PositionCursor();
                    }
                    IsMenuOpen = false;
                    break;

                case true:
                    selectedSub = -1;
                    SetNeedsDisplay();
                    RemoveAllOpensSubMenus();
                    openCurrentMenu.previousSubFocused.SetFocus();
                    openSubMenu = null;
                    IsMenuOpen = true;
                    break;
            }
            this.reopen = false;
            isMenuClosing = false;
            return true;
        }

        void RemoveSubMenu(int index, bool ignoreUseSubMenusSingleFrame = false)
        {
            if (openSubMenu == null || (UseSubMenusSingleFrame
                && !ignoreUseSubMenusSingleFrame && openSubMenu.Count == 0))

                return;
            for (int i = openSubMenu.Count - 1; i > index; i--)
            {
                isMenuClosing = true;
                Menu menu;
                if (openSubMenu.Count - 1 > 0)
                    menu = openSubMenu[i - 1];
                else
                    menu = openMenu;
                if (!menu.Visible)
                    menu.Visible = true;
                openCurrentMenu = menu;
                openCurrentMenu.SetFocus();
                if (openSubMenu != null)
                {
                    menu = openSubMenu[i];
                    if (SuperView == null)
                    {
                        Application.Current.Remove(menu);
                    }
                    else
                    {
                        SuperView.Remove(menu);
                    }
                    openSubMenu.Remove(menu);
                    menu.Dispose();
                }
                RemoveSubMenu(i, ignoreUseSubMenusSingleFrame);
            }
            if (openSubMenu.Count > 0)
                openCurrentMenu = openSubMenu.Last();

            isMenuClosing = false;
        }

        internal void RemoveAllOpensSubMenus()
        {
            if (openSubMenu != null)
            {
                foreach (var item in openSubMenu)
                {
                    if (SuperView == null)
                    {
                        Application.Current.Remove(item);
                    }
                    else
                    {
                        SuperView.Remove(item);
                    }
                    item.Dispose();
                }
            }
        }

        internal void CloseAllMenus()
        {
            if (!isMenuOpening && !isMenuClosing)
            {
                if (openSubMenu != null && !CloseMenu(false, true))
                    return;
                if (!CloseMenu(false))
                    return;
                if (LastFocused != null && LastFocused != this)
                    selected = -1;
                Application.UngrabMouse();
            }
            IsMenuOpen = false;
            openedByHotKey = false;
            openedByAltKey = false;
            OnMenuAllClosed();
        }

        View FindDeepestMenu(View view, ref int count)
        {
            count = count > 0 ? count : 0;
            foreach (var menu in view.Subviews)
            {
                if (menu is Menu)
                {
                    count++;
                    return FindDeepestMenu((Menu)menu, ref count);
                }
            }
            return view;
        }

        internal void PreviousMenu(bool isSubMenu = false, bool ignoreUseSubMenusSingleFrame = false)
        {
            switch (isSubMenu)
            {
                case false:
                    if (selected <= 0)
                        selected = Menus.Length - 1;
                    else
                        selected--;

                    if (selected > -1 && !CloseMenu(true, false, ignoreUseSubMenusSingleFrame))
                        return;
                    OpenMenu(selected);
                    if (!SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current, false))
                    {
                        openCurrentMenu.current = 0;
                    }
                    break;
                case true:
                    if (selectedSub > -1)
                    {
                        selectedSub--;
                        RemoveSubMenu(selectedSub, ignoreUseSubMenusSingleFrame);
                        SetNeedsDisplay();
                    }
                    else
                        PreviousMenu();

                    break;
            }
        }

        internal void NextMenu(bool isSubMenu = false, bool ignoreUseSubMenusSingleFrame = false)
        {
            switch (isSubMenu)
            {
                case false:
                    if (selected == -1)
                        selected = 0;
                    else if (selected + 1 == Menus.Length)
                        selected = 0;
                    else
                        selected++;

                    if (selected > -1 && !CloseMenu(true, ignoreUseSubMenusSingleFrame))
                        return;
                    OpenMenu(selected);
                    SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current);
                    break;
                case true:
                    if (UseKeysUpDownAsKeysLeftRight)
                    {
                        if (CloseMenu(false, true, ignoreUseSubMenusSingleFrame))
                        {
                            NextMenu(false, ignoreUseSubMenusSingleFrame);
                        }
                    }
                    else
                    {
                        var subMenu = openCurrentMenu.current > -1 && openCurrentMenu.barItems.Children.Length > 0
                            ? openCurrentMenu.barItems.SubMenu(openCurrentMenu.barItems.Children[openCurrentMenu.current])
                            : null;
                        if ((selectedSub == -1 || openSubMenu == null || openSubMenu?.Count - 1 == selectedSub) && subMenu == null)
                        {
                            if (openSubMenu != null && !CloseMenu(false, true))
                                return;
                            NextMenu(false, ignoreUseSubMenusSingleFrame);
                        }
                        else if (subMenu != null || (openCurrentMenu.current > -1
                          && !openCurrentMenu.barItems.Children[openCurrentMenu.current].IsFromSubMenu))
                        {
                            selectedSub++;
                            openCurrentMenu.CheckSubMenu();
                        }
                        else
                        {
                            if (CloseMenu(false, true, ignoreUseSubMenusSingleFrame))
                            {
                                NextMenu(false, ignoreUseSubMenusSingleFrame);
                            }
                            return;
                        }

                        SetNeedsDisplay();
                        if (UseKeysUpDownAsKeysLeftRight)
                            openCurrentMenu.CheckSubMenu();
                    }
                    break;
            }
        }

        bool openedByHotKey;
        internal bool FindAndOpenMenuByHotkey(KeyEvent kb)
        {
            //int pos = 0;
            var c = ((uint)kb.Key & (uint)Key.CharMask);
            for (int i = 0; i < Menus.Length; i++)
            {
                // TODO: this code is duplicated, hotkey should be part of the MenuBarItem
                var mi = Menus[i];
                int p = mi.Title.IndexOf(MenuBar.HotKeySpecifier);
                if (p != -1 && p + 1 < mi.Title.RuneCount)
                {
                    if (Char.ToUpperInvariant((char)mi.Title[p + 1]) == c)
                    {
                        ProcessMenu(i, mi);
                        return true;
                    }
                    else if (mi.Children?.Length > 0)
                    {
                        if (FindAndOpenChildrenMenuByHotkey(kb, mi.Children))
                        {
                            return true;
                        }
                    }
                }
                else if (mi.Children?.Length > 0)
                {
                    if (FindAndOpenChildrenMenuByHotkey(kb, mi.Children))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        bool FindAndOpenChildrenMenuByHotkey(KeyEvent kb, MenuItem[] children)
        {
            var c = ((uint)kb.Key & (uint)Key.CharMask);
            for (int i = 0; i < children.Length; i++)
            {
                var mi = children[i];

                if (mi == null)
                {
                    continue;
                }

                int p = mi.Title.IndexOf(MenuBar.HotKeySpecifier);
                if (p != -1 && p + 1 < mi.Title.RuneCount)
                {
                    if (Char.ToUpperInvariant((char)mi.Title[p + 1]) == c)
                    {
                        if (mi.IsEnabled())
                        {
                            var action = mi.Action;
                            if (action != null)
                            {
                                Run(action);
                            }
                        }
                        return true;
                    }
                    else if (mi is MenuBarItem menuBarItem && menuBarItem?.Children.Length > 0)
                    {
                        if (FindAndOpenChildrenMenuByHotkey(kb, menuBarItem.Children))
                        {
                            return true;
                        }
                    }
                }
                else if (mi is MenuBarItem menuBarItem && menuBarItem?.Children.Length > 0)
                {
                    if (FindAndOpenChildrenMenuByHotkey(kb, menuBarItem.Children))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        internal bool FindAndOpenMenuByShortcut(KeyEvent kb, MenuItem[] children = null)
        {
            if (children == null)
            {
                children = Menus;
            }

            var key = kb.KeyValue;
            var keys = ShortcutHelper.GetModifiersKey(kb);
            key |= (int)keys;
            for (int i = 0; i < children.Length; i++)
            {
                var mi = children[i];
                if (mi == null)
                {
                    continue;
                }
                if ((!(mi is MenuBarItem mbiTopLevel) || mbiTopLevel.IsTopLevel) && mi.Shortcut != Key.Null && mi.Shortcut == (Key)key)
                {
                    if (mi.IsEnabled())
                    {
                        var action = mi.Action;
                        if (action != null)
                        {
                            Run(action);
                        }
                    }
                    return true;
                }
                if (mi is MenuBarItem menuBarItem && menuBarItem.Children != null && !menuBarItem.IsTopLevel && FindAndOpenMenuByShortcut(kb, menuBarItem.Children))
                {
                    return true;
                }
            }

            return false;
        }

        private void ProcessMenu(int i, MenuBarItem mi)
        {
            if (selected < 0 && IsMenuOpen)
            {
                return;
            }

            if (mi.IsTopLevel)
            {
                var menu = new Menu(this, i, 0, mi);
                menu.Run(mi.Action);
                menu.Dispose();
            }
            else
            {
                openedByHotKey = true;
                Application.GrabMouse(this);
                selected = i;
                OpenMenu(i);
                if (!SelectEnabledItem(openCurrentMenu.barItems.Children, openCurrentMenu.current, out openCurrentMenu.current) && !CloseMenu(false))
                {
                    return;
                }
                if (!openCurrentMenu.CheckSubMenu())
                    return;
            }
            SetNeedsDisplay();
        }

        ///<inheritdoc/>
        public override bool ProcessHotKey(KeyEvent kb)
        {
            if (kb.Key == Key)
            {
                if (Visible && !IsMenuOpen)
                {
                    OpenMenu();
                }
                else
                {
                    CloseAllMenus();
                }
                return true;
            }

            // To ncurses simulate a AltMask key pressing Alt+Space because
            // it can't detect an alone special key down was pressed.
            if (kb.IsAlt && kb.Key == Key.AltMask && openMenu == null)
            {
                OnKeyDown(kb);
                OnKeyUp(kb);
                return true;
            }
            else if (kb.IsAlt && !kb.IsCtrl && !kb.IsShift)
            {
                if (FindAndOpenMenuByHotkey(kb)) return true;
            }
            //var kc = kb.KeyValue;

            return base.ProcessHotKey(kb);
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            if (InvokeKeybindings(kb) == true)
                return true;

            var key = kb.KeyValue;
            if ((key >= 'a' && key <= 'z') || (key >= 'A' && key <= 'Z') || (key >= '0' && key <= '9'))
            {
                char c = Char.ToUpper((char)key);

                if (selected == -1 || Menus[selected].IsTopLevel)
                    return false;

                foreach (var mi in Menus[selected].Children)
                {
                    if (mi == null)
                        continue;
                    int p = mi.Title.IndexOf(MenuBar.HotKeySpecifier);
                    if (p != -1 && p + 1 < mi.Title.RuneCount)
                    {
                        if (mi.Title[p + 1] == c)
                        {
                            Selected(mi);
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        void CloseMenuBar()
        {
            if (!CloseMenu(false))
                return;
            if (openedByAltKey)
            {
                openedByAltKey = false;
                LastFocused?.SetFocus();
            }
            SetNeedsDisplay();
        }

        void MoveRight()
        {
            selected = (selected + 1) % Menus.Length;
            OpenMenu(selected);
            SetNeedsDisplay();
        }

        void MoveLeft()
        {
            selected--;
            if (selected < 0)
                selected = Menus.Length - 1;
            OpenMenu(selected);
            SetNeedsDisplay();
        }

        ///<inheritdoc/>
        public override bool ProcessColdKey(KeyEvent kb)
        {
            return FindAndOpenMenuByShortcut(kb);
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (!handled && !HandleGrabView(me, this))
            {
                return false;
            }
            handled = false;

            if (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked || me.Flags == MouseFlags.Button1TripleClicked || me.Flags == MouseFlags.Button1Clicked ||
                (me.Flags == MouseFlags.ReportMousePosition && selected > -1) ||
                (me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) && selected > -1))
            {
                int pos = xOrigin;
                int cx = me.X;
                for (int i = 0; i < Menus.Length; i++)
                {
                    if (cx >= pos && cx < pos + leftPadding + Menus[i].TitleLength + Menus[i].Help.ConsoleWidth + rightPadding)
                    {
                        if (me.Flags == MouseFlags.Button1Clicked)
                        {
                            if (Menus[i].IsTopLevel)
                            {
                                var menu = new Menu(this, i, 0, Menus[i]);
                                menu.Run(Menus[i].Action);
                                menu.Dispose();
                            }
                            else if (!IsMenuOpen)
                            {
                                Activate(i);
                            }
                        }
                        else if (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked || me.Flags == MouseFlags.Button1TripleClicked)
                        {
                            if (IsMenuOpen && !Menus[i].IsTopLevel)
                            {
                                CloseAllMenus();
                            }
                            else if (!Menus[i].IsTopLevel)
                            {
                                Activate(i);
                            }
                        }
                        else if (selected != i && selected > -1 && (me.Flags == MouseFlags.ReportMousePosition ||
                          me.Flags == MouseFlags.Button1Pressed && me.Flags == MouseFlags.ReportMousePosition))
                        {
                            if (IsMenuOpen)
                            {
                                if (!CloseMenu(true, false))
                                {
                                    return true;
                                }
                                Activate(i);
                            }
                        }
                        else
                        {
                            if (IsMenuOpen)
                                Activate(i);
                        }
                        return true;
                    }
                    pos += leftPadding + Menus[i].TitleLength + rightPadding;
                }
            }
            return false;
        }

        internal bool handled;
        internal bool isContextMenuLoading;

        internal bool HandleGrabView(MouseEvent me, View current)
        {
            if (Application.MouseGrabView != null)
            {
                if (me.View is MenuBar || me.View is Menu)
                {
                    var mbar = GetMouseGrabViewInstance(me.View);
                    if (mbar != null)
                    {
                        if (me.Flags == MouseFlags.Button1Clicked)
                        {
                            mbar.CleanUp();
                            Application.GrabMouse(me.View);
                        }
                        else
                        {
                            handled = false;
                            return false;
                        }
                    }
                    if (me.View != current)
                    {
                        Application.UngrabMouse();
                        var v = me.View;
                        Application.GrabMouse(v);
                        MouseEvent nme;
                        if (me.Y > -1)
                        {
                            var newxy = v.ScreenToView(me.X, me.Y);
                            nme = new MouseEvent()
                            {
                                X = newxy.X,
                                Y = newxy.Y,
                                Flags = me.Flags,
                                OfX = me.X - newxy.X,
                                OfY = me.Y - newxy.Y,
                                View = v
                            };
                        }
                        else
                        {
                            nme = new MouseEvent()
                            {
                                X = me.X + current.Frame.X,
                                Y = 0,
                                Flags = me.Flags,
                                View = v
                            };
                        }

                        v.MouseEvent(nme);
                        return false;
                    }
                }
                else if (!isContextMenuLoading && !(me.View is MenuBar || me.View is Menu)
                  && me.Flags != MouseFlags.ReportMousePosition && me.Flags != 0)
                {

                    Application.UngrabMouse();
                    if (IsMenuOpen)
                        CloseAllMenus();
                    handled = false;
                    return false;
                }
                else
                {
                    handled = false;
                    isContextMenuLoading = false;
                    return false;
                }
            }
            else if (!IsMenuOpen && (me.Flags == MouseFlags.Button1Pressed || me.Flags == MouseFlags.Button1DoubleClicked
              || me.Flags == MouseFlags.Button1TripleClicked || me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition)))
            {

                Application.GrabMouse(current);
            }
            else if (IsMenuOpen && (me.View is MenuBar || me.View is Menu))
            {
                Application.GrabMouse(me.View);
            }
            else
            {
                handled = false;
                return false;
            }

            handled = true;

            return true;
        }

        MenuBar GetMouseGrabViewInstance(View view)
        {
            if (view == null || Application.MouseGrabView == null)
            {
                return null;
            }

            MenuBar hostView = null;
            if (view is MenuBar)
            {
                hostView = (MenuBar)view;
            }
            else if (view is Menu)
            {
                hostView = ((Menu)view).host;
            }

            var grabView = Application.MouseGrabView;
            MenuBar hostGrabView = null;
            if (grabView is MenuBar)
            {
                hostGrabView = (MenuBar)grabView;
            }
            else if (grabView is Menu)
            {
                hostGrabView = ((Menu)grabView).host;
            }

            return hostView != hostGrabView ? hostGrabView : null;
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }
    }

    /// <summary>
    /// An <see cref="EventArgs"/> which allows passing a cancelable menu opening event or replacing with a new <see cref="MenuBarItem"/>.
    /// </summary>
    public class MenuOpeningEventArgs : EventArgs
    {
        /// <summary>
        /// The current <see cref="MenuBarItem"/> parent.
        /// </summary>
        public MenuBarItem CurrentMenu { get; }

        /// <summary>
        /// The new <see cref="MenuBarItem"/> to be replaced.
        /// </summary>
        public MenuBarItem NewMenuBarItem { get; set; }
        /// <summary>
        /// Flag that allows the cancellation of the event. If set to <see langword="true"/> in the
        /// event handler, the event will be canceled. 
        /// </summary>
        public bool Cancel { get; set; }

        /// <summary>
        /// Initializes a new instance of <see cref="MenuOpeningEventArgs"/>.
        /// </summary>
        /// <param name="currentMenu">The current <see cref="MenuBarItem"/> parent.</param>
        public MenuOpeningEventArgs(MenuBarItem currentMenu)
        {
            CurrentMenu = currentMenu;
        }
    }

    /// <summary>
    /// An <see cref="EventArgs"/> which allows passing a cancelable menu closing event.
    /// </summary>
    public class MenuClosingEventArgs : EventArgs
    {
        /// <summary>
        /// The current <see cref="MenuBarItem"/> parent.
        /// </summary>
        public MenuBarItem CurrentMenu { get; }

        /// <summary>
        /// Indicates whether the current menu will reopen.
        /// </summary>
        public bool Reopen { get; }

        /// <summary>
        /// Indicates whether the current menu is a sub-menu.
        /// </summary>
        public bool IsSubMenu { get; }

        /// <summary>
        /// Flag that allows the cancellation of the event. If set to <see langword="true"/> in the
        /// event handler, the event will be canceled. 
        /// </summary>
        public bool Cancel { get; set; }

        /// <summary>
        /// Initializes a new instance of <see cref="MenuClosingEventArgs"/>.
        /// </summary>
        /// <param name="currentMenu">The current <see cref="MenuBarItem"/> parent.</param>
        /// <param name="reopen">Whether the current menu will reopen.</param>
        /// <param name="isSubMenu">Indicates whether it is a sub-menu.</param>
        public MenuClosingEventArgs(MenuBarItem currentMenu, bool reopen, bool isSubMenu)
        {
            CurrentMenu = currentMenu;
            Reopen = reopen;
            IsSubMenu = isSubMenu;
        }
    }
    //=======================================================================
    /// <summary>
    /// MessageBox displays a modal message to the user, with a title, a message and a series of options that the user can choose from.
    /// </summary>
    /// <para>
    ///   The difference between the <see cref="Query(ustring, ustring, ustring[])"/> and <see cref="ErrorQuery(ustring, ustring, ustring[])"/> 
    ///   method is the default set of colors used for the message box.
    /// </para>
    /// <para>
    /// The following example pops up a <see cref="MessageBox"/> with the specified title and text, plus two <see cref="Button"/>s.
    /// The value -1 is returned when the user cancels the <see cref="MessageBox"/> by pressing the ESC key.
    /// </para>
    /// <example>
    /// <code lang="c#">
    /// var n = MessageBox.Query ("Quit Demo", "Are you sure you want to quit this demo?", "Yes", "No");
    /// if (n == 0)
    ///    quit = true;
    /// else
    ///    quit = false;
    /// </code>
    /// </example>
    public static class MessageBox
    {
        /// <summary>
        /// Presents a normal <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="width">Width for the window.</param>
        /// <param name="height">Height for the window.</param>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// Use <see cref="Query(ustring, ustring, ustring[])"/> instead; it automatically sizes the MessageBox based on the contents.
        /// </remarks>
        public static int Query(int width, int height, ustring title, ustring message, params ustring[] buttons)
        {
            return QueryFull(false, width, height, title, message, 0, null, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
        /// from the size of the message and buttons.
        /// </remarks>
        public static int Query(ustring title, ustring message, params ustring[] buttons)
        {
            return QueryFull(false, 0, 0, title, message, 0, null, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="width">Width for the window.</param>
        /// <param name="height">Height for the window.</param>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// Use <see cref="ErrorQuery(ustring, ustring, ustring[])"/> instead; it automatically sizes the MessageBox based on the contents.
        /// </remarks>
        public static int ErrorQuery(int width, int height, ustring title, ustring message, params ustring[] buttons)
        {
            return QueryFull(true, width, height, title, message, 0, null, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
        /// from the size of the title, message. and buttons.
        /// </remarks>
        public static int ErrorQuery(ustring title, ustring message, params ustring[] buttons)
        {
            return QueryFull(true, 0, 0, title, message, 0, null, buttons);
        }

        /// <summary>
        /// Presents a normal <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="width">Width for the window.</param>
        /// <param name="height">Height for the window.</param>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// Use <see cref="Query(ustring, ustring, ustring[])"/> instead; it automatically sizes the MessageBox based on the contents.
        /// </remarks>
        public static int Query(int width, int height, ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
        {
            return QueryFull(false, width, height, title, message, defaultButton, null, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
        /// from the size of the message and buttons.
        /// </remarks>
        public static int Query(ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
        {
            return QueryFull(false, 0, 0, title, message, defaultButton, null, buttons);
        }

        /// <summary>
        /// Presents a normal <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="width">Width for the window.</param>
        /// <param name="height">Height for the window.</param>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="border">The border settings.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// Use <see cref="Query(ustring, ustring, ustring[])"/> instead; it automatically sizes the MessageBox based on the contents.
        /// </remarks>
        public static int Query(int width, int height, ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
        {
            return QueryFull(false, width, height, title, message, defaultButton, border, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="border">The border settings.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
        /// from the size of the message and buttons.
        /// </remarks>
        public static int Query(ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
        {
            return QueryFull(false, 0, 0, title, message, defaultButton, border, buttons);
        }


        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="width">Width for the window.</param>
        /// <param name="height">Height for the window.</param>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// Use <see cref="ErrorQuery(ustring, ustring, ustring[])"/> instead; it automatically sizes the MessageBox based on the contents.
        /// </remarks>
        public static int ErrorQuery(int width, int height, ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
        {
            return QueryFull(true, width, height, title, message, defaultButton, null, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
        /// from the size of the title, message. and buttons.
        /// </remarks>
        public static int ErrorQuery(ustring title, ustring message, int defaultButton = 0, params ustring[] buttons)
        {
            return QueryFull(true, 0, 0, title, message, defaultButton, null, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="width">Width for the window.</param>
        /// <param name="height">Height for the window.</param>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="border">The border settings.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// Use <see cref="ErrorQuery(ustring, ustring, ustring[])"/> instead; it automatically sizes the MessageBox based on the contents.
        /// </remarks>
        public static int ErrorQuery(int width, int height, ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
        {
            return QueryFull(true, width, height, title, message, defaultButton, border, buttons);
        }

        /// <summary>
        /// Presents an error <see cref="MessageBox"/> with the specified title and message and a list of buttons to show to the user.
        /// </summary>
        /// <returns>The index of the selected button, or -1 if the user pressed ESC to close the dialog.</returns>
        /// <param name="title">Title for the query.</param>
        /// <param name="message">Message to display, might contain multiple lines.</param>
        /// <param name="defaultButton">Index of the default button.</param>
        /// <param name="border">The border settings.</param>
        /// <param name="buttons">Array of buttons to add.</param>
        /// <remarks>
        /// The message box will be vertically and horizontally centered in the container and the size will be automatically determined
        /// from the size of the title, message. and buttons.
        /// </remarks>
        public static int ErrorQuery(ustring title, ustring message, int defaultButton = 0, Border border = null, params ustring[] buttons)
        {
            return QueryFull(true, 0, 0, title, message, defaultButton, border, buttons);
        }

        static int QueryFull(bool useErrorColors, int width, int height, ustring title, ustring message,
            int defaultButton = 0, Border border = null, params ustring[] buttons)
        {
            int defaultWidth = 50;
            if (defaultWidth > Application.Driver.Cols / 2)
            {
                defaultWidth = (int)(Application.Driver.Cols * 0.60f);
            }
            int maxWidthLine = TextFormatter.MaxWidthLine(message);
            if (maxWidthLine > Application.Driver.Cols)
            {
                maxWidthLine = Application.Driver.Cols;
            }
            if (width == 0)
            {
                maxWidthLine = Math.Max(maxWidthLine, defaultWidth);
            }
            else
            {
                maxWidthLine = width;
            }
            int textWidth = Math.Min(TextFormatter.MaxWidth(message, maxWidthLine), Application.Driver.Cols);
            int textHeight = TextFormatter.MaxLines(message, textWidth); // message.Count (ustring.Make ('\n')) + 1;
            int msgboxHeight = Math.Min(Math.Max(1, textHeight) + 4, Application.Driver.Rows); // textHeight + (top + top padding + buttons + bottom)

            // Create button array for Dialog
            int count = 0;
            List<Button> buttonList = new List<Button>();
            if (buttons != null && defaultButton > buttons.Length - 1)
            {
                defaultButton = buttons.Length - 1;
            }
            foreach (var s in buttons)
            {
                var b = new Button(s);
                if (count == defaultButton)
                {
                    b.IsDefault = true;
                }
                buttonList.Add(b);
                count++;
            }

            // Create Dialog (retain backwards compat by supporting specifying height/width)
            Dialog d;
            if (width == 0 & height == 0)
            {
                d = new Dialog(title, buttonList.ToArray())
                {
                    Height = msgboxHeight
                };
            }
            else
            {
                d = new Dialog(title, width, Math.Max(height, 4), buttonList.ToArray());
            }

            if (border != null)
            {
                d.Border = border;
            }

            if (useErrorColors)
            {
                d.ColorScheme = Colors.Error;
            }

            if (message != null)
            {
                var l = new Label(message)
                {
                    LayoutStyle = LayoutStyle.Computed,
                    TextAlignment = TextAlignment.Centered,
                    X = Pos.Center(),
                    Y = Pos.Center(),
                    Width = Dim.Fill(),
                    Height = Dim.Fill(1),
                    AutoSize = false
                };
                d.Add(l);
            }

            if (width == 0 & height == 0)
            {
                // Dynamically size Width
                d.Width = Math.Min(Math.Max(maxWidthLine, Math.Max(title.ConsoleWidth, Math.Max(textWidth + 2, d.GetButtonsWidth() + d.buttons.Count + 2))), Application.Driver.Cols); // textWidth + (left + padding + padding + right)
            }

            // Setup actions
            Clicked = -1;
            for (int n = 0; n < buttonList.Count; n++)
            {
                int buttonId = n;
                var b = buttonList[n];
                b.Clicked += () =>
                {
                    Clicked = buttonId;
                    Application.RequestStop();
                };
                if (b.IsDefault)
                {
                    b.SetFocus();
                }
            }

            // Run the modal; do not shutdown the mainloop driver when done
            Application.Run(d);
            return Clicked;
        }

        /// <summary>
        /// The index of the selected button, or -1 if the user pressed ESC to close the dialog.
        /// This is useful for web based console where by default there is no SynchronizationContext or TaskScheduler.
        /// </summary>
        public static int Clicked { get; private set; } = -1;
    }
    //=======================================================================
    //
    // NetDriver.cs: The System.Console-based .NET driver, works on Windows and Unix, but is not particularly efficient.
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    internal class NetWinVTConsole
    {
        IntPtr InputHandle, OutputHandle, ErrorHandle;
        uint originalInputConsoleMode, originalOutputConsoleMode, originalErrorConsoleMode;

        public NetWinVTConsole()
        {
            InputHandle = GetStdHandle(STD_INPUT_HANDLE);
            if (!GetConsoleMode(InputHandle, out uint mode))
            {
                throw new ApplicationException($"Failed to get input console mode, error code: {GetLastError()}.");
            }
            originalInputConsoleMode = mode;
            if ((mode & ENABLE_VIRTUAL_TERMINAL_INPUT) < ENABLE_VIRTUAL_TERMINAL_INPUT)
            {
                mode |= ENABLE_VIRTUAL_TERMINAL_INPUT;
                if (!SetConsoleMode(InputHandle, mode))
                {
                    throw new ApplicationException($"Failed to set input console mode, error code: {GetLastError()}.");
                }
            }

            OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
            if (!GetConsoleMode(OutputHandle, out mode))
            {
                throw new ApplicationException($"Failed to get output console mode, error code: {GetLastError()}.");
            }
            originalOutputConsoleMode = mode;
            if ((mode & (ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN)) < DISABLE_NEWLINE_AUTO_RETURN)
            {
                mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;
                if (!SetConsoleMode(OutputHandle, mode))
                {
                    throw new ApplicationException($"Failed to set output console mode, error code: {GetLastError()}.");
                }
            }

            ErrorHandle = GetStdHandle(STD_ERROR_HANDLE);
            if (!GetConsoleMode(ErrorHandle, out mode))
            {
                throw new ApplicationException($"Failed to get error console mode, error code: {GetLastError()}.");
            }
            originalErrorConsoleMode = mode;
            if ((mode & (DISABLE_NEWLINE_AUTO_RETURN)) < DISABLE_NEWLINE_AUTO_RETURN)
            {
                mode |= DISABLE_NEWLINE_AUTO_RETURN;
                if (!SetConsoleMode(ErrorHandle, mode))
                {
                    throw new ApplicationException($"Failed to set error console mode, error code: {GetLastError()}.");
                }
            }
        }

        public void Cleanup()
        {
            if (!SetConsoleMode(InputHandle, originalInputConsoleMode))
            {
                throw new ApplicationException($"Failed to restore input console mode, error code: {GetLastError()}.");
            }
            if (!SetConsoleMode(OutputHandle, originalOutputConsoleMode))
            {
                throw new ApplicationException($"Failed to restore output console mode, error code: {GetLastError()}.");
            }
            if (!SetConsoleMode(ErrorHandle, originalErrorConsoleMode))
            {
                throw new ApplicationException($"Failed to restore error console mode, error code: {GetLastError()}.");
            }
        }

        const int STD_INPUT_HANDLE = -10;
        const int STD_OUTPUT_HANDLE = -11;
        const int STD_ERROR_HANDLE = -12;

        // Input modes.
        const uint ENABLE_PROCESSED_INPUT = 1;
        const uint ENABLE_LINE_INPUT = 2;
        const uint ENABLE_ECHO_INPUT = 4;
        const uint ENABLE_WINDOW_INPUT = 8;
        const uint ENABLE_MOUSE_INPUT = 16;
        const uint ENABLE_INSERT_MODE = 32;
        const uint ENABLE_QUICK_EDIT_MODE = 64;
        const uint ENABLE_EXTENDED_FLAGS = 128;
        const uint ENABLE_VIRTUAL_TERMINAL_INPUT = 512;

        // Output modes.
        const uint ENABLE_PROCESSED_OUTPUT = 1;
        const uint ENABLE_WRAP_AT_EOL_OUTPUT = 2;
        const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4;
        const uint DISABLE_NEWLINE_AUTO_RETURN = 8;
        const uint ENABLE_LVB_GRID_WORLDWIDE = 10;

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll")]
        static extern bool GetConsoleMode(IntPtr hConsoleHandle, out uint lpMode);

        [DllImport("kernel32.dll")]
        static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint dwMode);

        [DllImport("kernel32.dll")]
        static extern uint GetLastError();
    }

    internal class NetEvents
    {
        ManualResetEventSlim inputReady = new ManualResetEventSlim(false);
        ManualResetEventSlim waitForStart = new ManualResetEventSlim(false);
        ManualResetEventSlim winChange = new ManualResetEventSlim(false);
        Queue<InputResult?> inputResultQueue = new Queue<InputResult?>();
        ConsoleDriver consoleDriver;
        volatile ConsoleKeyInfo[] cki = null;
        static volatile bool isEscSeq;

        internal CancellationTokenSource TokenSource = new CancellationTokenSource();

#if PROCESS_REQUEST
		bool neededProcessRequest;
#endif
        public EscSeqReqProc EscSeqReqProc { get; } = new EscSeqReqProc();

        public NetEvents(ConsoleDriver consoleDriver)
        {
            if (consoleDriver == null)
            {
                throw new ArgumentNullException("Console driver instance must be provided.");
            }
            this.consoleDriver = consoleDriver;
            Task.Run(ProcessInputResultQueue, TokenSource.Token);
            Task.Run(CheckWinChange, TokenSource.Token);
        }

        public InputResult? ReadConsoleInput()
        {
            while (!TokenSource.IsCancellationRequested)
            {
                waitForStart.Set();
                winChange.Set();

                if (inputResultQueue.Count == 0)
                {
                    inputReady.Wait();
                    inputReady.Reset();
                }
#if PROCESS_REQUEST
				neededProcessRequest = false;
#endif
                if (inputResultQueue.Count > 0)
                {
                    return inputResultQueue.Dequeue();
                }
            }

            return null;
        }

        void ProcessInputResultQueue()
        {
            while (!TokenSource.IsCancellationRequested)
            {
                waitForStart.Wait();
                waitForStart.Reset();

                if (inputResultQueue.Count == 0)
                {
                    GetConsoleKey();
                }

                inputReady.Set();
            }
        }

        void GetConsoleKey()
        {
            ConsoleKey key = 0;
            ConsoleModifiers mod = 0;
            ConsoleKeyInfo newConsoleKeyInfo = default;

            while (!TokenSource.IsCancellationRequested)
            {
                ConsoleKeyInfo consoleKeyInfo = default;

                try
                {
                    if (Console.KeyAvailable)
                    {
                        consoleKeyInfo = Console.ReadKey(true);
                    }
                    else
                    {
                        Task.Delay(100, TokenSource.Token).Wait(TokenSource.Token);
                        if (Console.KeyAvailable)
                        {
                            consoleKeyInfo = Console.ReadKey(true);
                        }
                    }
                }
                catch (OperationCanceledException)
                {

                    return;
                }

                if ((consoleKeyInfo.KeyChar == (char)Key.Esc && !isEscSeq)
                    || (consoleKeyInfo.KeyChar != (char)Key.Esc && isEscSeq))
                {
                    if (cki == null && consoleKeyInfo.KeyChar != (char)Key.Esc && isEscSeq)
                    {
                        cki = EscSeqUtils.ResizeArray(new ConsoleKeyInfo((char)Key.Esc, 0,
                            false, false, false), cki);
                    }
                    isEscSeq = true;
                    newConsoleKeyInfo = consoleKeyInfo;
                    cki = EscSeqUtils.ResizeArray(consoleKeyInfo, cki);
                    if (!Console.KeyAvailable)
                    {
                        DecodeEscSeq(ref newConsoleKeyInfo, ref key, cki, ref mod);
                        cki = null;
                        isEscSeq = false;
                        break;
                    }
                }
                else if (consoleKeyInfo.KeyChar == (char)Key.Esc && isEscSeq)
                {
                    DecodeEscSeq(ref newConsoleKeyInfo, ref key, cki, ref mod);
                    cki = null;
                    if (!Console.KeyAvailable)
                    {
                        isEscSeq = false;
                    }
                    break;
                }
                else
                {
                    if (consoleKeyInfo != default)
                    {
                        GetConsoleInputType(consoleKeyInfo);
                        break;
                    }
                }

                TokenSource.Token.ThrowIfCancellationRequested();
            }
        }

        void CheckWinChange()
        {
            while (!TokenSource.IsCancellationRequested)
            {
                winChange.Wait();
                winChange.Reset();
                WaitWinChange();
                inputReady.Set();
            }
        }

        void WaitWinChange()
        {
            while (!TokenSource.IsCancellationRequested)
            {
                try
                {
                    // Wait for a while then check if screen has changed sizes
                    Task.Delay(500, TokenSource.Token).Wait(TokenSource.Token);

                }
                catch (OperationCanceledException)
                {

                    return;
                }

                int buffHeight, buffWidth;
                if (((NetDriver)consoleDriver).IsWinPlatform)
                {
                    buffHeight = Math.Max(Console.BufferHeight, 0);
                    buffWidth = Math.Max(Console.BufferWidth, 0);
                }
                else
                {
                    buffHeight = consoleDriver.Rows;
                    buffWidth = consoleDriver.Cols;
                }
                if (IsWinChanged(
                    Math.Max(Console.WindowHeight, 0),
                    Math.Max(Console.WindowWidth, 0),
                    buffHeight,
                    buffWidth))
                {

                    return;
                }
            }
        }

        bool IsWinChanged(int winHeight, int winWidth, int buffHeight, int buffWidth)
        {
            if (winWidth != consoleDriver.Cols || winHeight != consoleDriver.Rows)
            {
                var w = Math.Max(winWidth, 0);
                var h = Math.Max(winHeight, 0);
                GetWindowSizeEvent(new Size(w, h));
                return true;
            }
            return false;
        }

        void GetWindowSizeEvent(Size size)
        {
            WindowSizeEvent windowSizeEvent = new WindowSizeEvent()
            {
                Size = size
            };

            inputResultQueue.Enqueue(new InputResult()
            {
                EventType = EventType.WindowSize,
                WindowSizeEvent = windowSizeEvent
            });
        }

        void GetConsoleInputType(ConsoleKeyInfo consoleKeyInfo)
        {
            InputResult inputResult = new InputResult
            {
                EventType = EventType.Key
            };
            MouseEvent mouseEvent = new MouseEvent();
            ConsoleKeyInfo newConsoleKeyInfo = EscSeqUtils.GetConsoleInputKey(consoleKeyInfo);
            if (inputResult.EventType == EventType.Key)
            {
                inputResult.ConsoleKeyInfo = newConsoleKeyInfo;
            }
            else
            {
                inputResult.MouseEvent = mouseEvent;
            }

            inputResultQueue.Enqueue(inputResult);
        }

        void DecodeEscSeq(ref ConsoleKeyInfo newConsoleKeyInfo, ref ConsoleKey key, ConsoleKeyInfo[] cki, ref ConsoleModifiers mod)
        {
            string c1Control, code, terminating;
            string[] values;
            // isKeyMouse is true if it's CSI<, false otherwise
            bool isKeyMouse;
            bool isReq;
            List<MouseFlags> mouseFlags;
            Point pos;
            EscSeqUtils.DecodeEscSeq(EscSeqReqProc, ref newConsoleKeyInfo, ref key, cki, ref mod, out c1Control, out code, out values, out terminating, out isKeyMouse, out mouseFlags, out pos, out isReq, ProcessContinuousButtonPressed);

            if (isKeyMouse)
            {
                foreach (var mf in mouseFlags)
                {
                    GetMouseEvent(MapMouseFlags(mf), pos);
                }
                return;
            }
            else if (isReq)
            {
                GetRequestEvent(c1Control, code, values, terminating);
                return;
            }
            InputResult inputResult = new InputResult
            {
                EventType = EventType.Key,
                ConsoleKeyInfo = newConsoleKeyInfo
            };

            inputResultQueue.Enqueue(inputResult);
        }

        void ProcessContinuousButtonPressed(MouseFlags mouseFlag, Point pos)
        {
            GetMouseEvent(MapMouseFlags(mouseFlag), pos);
        }

        MouseButtonState MapMouseFlags(MouseFlags mouseFlags)
        {
            MouseButtonState mbs = default;
            foreach (var flag in Enum.GetValues(mouseFlags.GetType()))
            {
                if (mouseFlags.HasFlag((MouseFlags)flag))
                {
                    switch (flag)
                    {
                        case MouseFlags.Button1Pressed:
                            mbs |= MouseButtonState.Button1Pressed;
                            break;
                        case MouseFlags.Button1Released:
                            mbs |= MouseButtonState.Button1Released;
                            break;
                        case MouseFlags.Button1Clicked:
                            mbs |= MouseButtonState.Button1Clicked;
                            break;
                        case MouseFlags.Button1DoubleClicked:
                            mbs |= MouseButtonState.Button1DoubleClicked;
                            break;
                        case MouseFlags.Button1TripleClicked:
                            mbs |= MouseButtonState.Button1TripleClicked;
                            break;
                        case MouseFlags.Button2Pressed:
                            mbs |= MouseButtonState.Button2Pressed;
                            break;
                        case MouseFlags.Button2Released:
                            mbs |= MouseButtonState.Button2Released;
                            break;
                        case MouseFlags.Button2Clicked:
                            mbs |= MouseButtonState.Button2Clicked;
                            break;
                        case MouseFlags.Button2DoubleClicked:
                            mbs |= MouseButtonState.Button2DoubleClicked;
                            break;
                        case MouseFlags.Button2TripleClicked:
                            mbs |= MouseButtonState.Button2TripleClicked;
                            break;
                        case MouseFlags.Button3Pressed:
                            mbs |= MouseButtonState.Button3Pressed;
                            break;
                        case MouseFlags.Button3Released:
                            mbs |= MouseButtonState.Button3Released;
                            break;
                        case MouseFlags.Button3Clicked:
                            mbs |= MouseButtonState.Button3Clicked;
                            break;
                        case MouseFlags.Button3DoubleClicked:
                            mbs |= MouseButtonState.Button3DoubleClicked;
                            break;
                        case MouseFlags.Button3TripleClicked:
                            mbs |= MouseButtonState.Button3TripleClicked;
                            break;
                        case MouseFlags.WheeledUp:
                            mbs |= MouseButtonState.ButtonWheeledUp;
                            break;
                        case MouseFlags.WheeledDown:
                            mbs |= MouseButtonState.ButtonWheeledDown;
                            break;
                        case MouseFlags.WheeledLeft:
                            mbs |= MouseButtonState.ButtonWheeledLeft;
                            break;
                        case MouseFlags.WheeledRight:
                            mbs |= MouseButtonState.ButtonWheeledRight;
                            break;
                        case MouseFlags.Button4Pressed:
                            mbs |= MouseButtonState.Button4Pressed;
                            break;
                        case MouseFlags.Button4Released:
                            mbs |= MouseButtonState.Button4Released;
                            break;
                        case MouseFlags.Button4Clicked:
                            mbs |= MouseButtonState.Button4Clicked;
                            break;
                        case MouseFlags.Button4DoubleClicked:
                            mbs |= MouseButtonState.Button4DoubleClicked;
                            break;
                        case MouseFlags.Button4TripleClicked:
                            mbs |= MouseButtonState.Button4TripleClicked;
                            break;
                        case MouseFlags.ButtonShift:
                            mbs |= MouseButtonState.ButtonShift;
                            break;
                        case MouseFlags.ButtonCtrl:
                            mbs |= MouseButtonState.ButtonCtrl;
                            break;
                        case MouseFlags.ButtonAlt:
                            mbs |= MouseButtonState.ButtonAlt;
                            break;
                        case MouseFlags.ReportMousePosition:
                            mbs |= MouseButtonState.ReportMousePosition;
                            break;
                        case MouseFlags.AllEvents:
                            mbs |= MouseButtonState.AllEvents;
                            break;
                    }
                }
            }
            return mbs;
        }

        Point lastCursorPosition;

        void GetRequestEvent(string c1Control, string code, string[] values, string terminating)
        {
            EventType eventType = new EventType();
            switch (terminating)
            {
                case "R": // Reports cursor position as CSI r ; c R
                    Point point = new Point
                    {
                        X = int.Parse(values[1]) - 1,
                        Y = int.Parse(values[0]) - 1
                    };
                    if (lastCursorPosition.Y != point.Y)
                    {
                        lastCursorPosition = point;
                        eventType = EventType.WindowPosition;
                        var winPositionEv = new WindowPositionEvent()
                        {
                            Top = 0,
                            Left = 0,
                            CursorPosition = point
                        };
                        inputResultQueue.Enqueue(new InputResult()
                        {
                            EventType = eventType,
                            WindowPositionEvent = winPositionEv
                        });
                    }
                    else
                    {
                        return;
                    }
                    break;
                default:
                    SetRequestedEvent(c1Control, code, values, terminating);
                    break;
            }

            inputReady.Set();
        }

        void SetRequestedEvent(string c1Control, string code, string[] values, string terminating)
        {
            EventType eventType = EventType.RequestResponse;
            var requestRespEv = new RequestResponseEvent()
            {
                ResultTuple = (c1Control, code, values, terminating)
            };
            inputResultQueue.Enqueue(new InputResult()
            {
                EventType = eventType,
                RequestResponseEvent = requestRespEv
            });
        }

        void GetMouseEvent(MouseButtonState buttonState, Point pos)
        {
            MouseEvent mouseEvent = new MouseEvent()
            {
                Position = pos,
                ButtonState = buttonState,
            };

            inputResultQueue.Enqueue(new InputResult()
            {
                EventType = EventType.Mouse,
                MouseEvent = mouseEvent
            });

            inputReady.Set();
        }

        public enum EventType
        {
            Key = 1,
            Mouse = 2,
            WindowSize = 3,
            WindowPosition = 4,
            RequestResponse = 5
        }

        [Flags]
        public enum MouseButtonState
        {
            Button1Pressed = 0x1,
            Button1Released = 0x2,
            Button1Clicked = 0x4,
            Button1DoubleClicked = 0x8,
            Button1TripleClicked = 0x10,
            Button2Pressed = 0x20,
            Button2Released = 0x40,
            Button2Clicked = 0x80,
            Button2DoubleClicked = 0x100,
            Button2TripleClicked = 0x200,
            Button3Pressed = 0x400,
            Button3Released = 0x800,
            Button3Clicked = 0x1000,
            Button3DoubleClicked = 0x2000,
            Button3TripleClicked = 0x4000,
            ButtonWheeledUp = 0x8000,
            ButtonWheeledDown = 0x10000,
            ButtonWheeledLeft = 0x20000,
            ButtonWheeledRight = 0x40000,
            Button4Pressed = 0x80000,
            Button4Released = 0x100000,
            Button4Clicked = 0x200000,
            Button4DoubleClicked = 0x400000,
            Button4TripleClicked = 0x800000,
            ButtonShift = 0x1000000,
            ButtonCtrl = 0x2000000,
            ButtonAlt = 0x4000000,
            ReportMousePosition = 0x8000000,
            AllEvents = -1
        }

        public struct MouseEvent
        {
            public Point Position;
            public MouseButtonState ButtonState;
        }

        public struct WindowSizeEvent
        {
            public Size Size;
        }

        public struct WindowPositionEvent
        {
            public int Top;
            public int Left;
            public Point CursorPosition;
        }

        public struct RequestResponseEvent
        {
            public (string c1Control, string code, string[] values, string terminating) ResultTuple;
        }

        public struct InputResult
        {
            public EventType EventType;
            public ConsoleKeyInfo ConsoleKeyInfo;
            public MouseEvent MouseEvent;
            public WindowSizeEvent WindowSizeEvent;
            public WindowPositionEvent WindowPositionEvent;
            public RequestResponseEvent RequestResponseEvent;
        }
    }

    internal class NetDriver : ConsoleDriver
    {
        const int COLOR_BLACK = 30;
        const int COLOR_RED = 31;
        const int COLOR_GREEN = 32;
        const int COLOR_YELLOW = 33;
        const int COLOR_BLUE = 34;
        const int COLOR_MAGENTA = 35;
        const int COLOR_CYAN = 36;
        const int COLOR_WHITE = 37;
        const int COLOR_BRIGHT_BLACK = 90;
        const int COLOR_BRIGHT_RED = 91;
        const int COLOR_BRIGHT_GREEN = 92;
        const int COLOR_BRIGHT_YELLOW = 93;
        const int COLOR_BRIGHT_BLUE = 94;
        const int COLOR_BRIGHT_MAGENTA = 95;
        const int COLOR_BRIGHT_CYAN = 96;
        const int COLOR_BRIGHT_WHITE = 97;

        int cols, rows, left, top;

        public override int Cols => cols;
        public override int Rows => rows;
        public override int Left => left;
        public override int Top => top;
        [Obsolete("This API is deprecated", false)]
        public override bool EnableConsoleScrolling { get; set; }
        [Obsolete("This API is deprecated", false)]
        public override bool HeightAsBuffer { get; set; }
        public NetWinVTConsole NetWinConsole { get; }
        public bool IsWinPlatform { get; }
        public override IClipboard Clipboard { get; }
        public override int[,,] Contents => contents;

        public NetDriver()
        {
            var p = Environment.OSVersion.Platform;
            if (p == PlatformID.Win32NT || p == PlatformID.Win32S || p == PlatformID.Win32Windows)
            {
                IsWinPlatform = true;
                NetWinConsole = new NetWinVTConsole();
            }
            if (IsWinPlatform)
            {
                Clipboard = new WindowsClipboard();
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                Clipboard = new MacOSXClipboard();
            }
            else
            {
                if (CursesDriver.Is_WSL_Platform())
                {
                    Clipboard = new WSLClipboard();
                }
                else
                {
                    Clipboard = new CursesClipboard();
                }
            }
        }

        // The format is rows, columns and 3 values on the last column: Rune, Attribute and Dirty Flag
        int[,,] contents;
        bool[] dirtyLine;

        static bool sync = false;

        // Current row, and current col, tracked by Move/AddCh only
        int ccol, crow;

        public override void Move(int col, int row)
        {
            ccol = col;
            crow = row;
        }

        public override void AddRune(Rune rune)
        {
            if (contents.Length != Rows * Cols * 3)
            {
                return;
            }
            rune = MakePrintable(rune);
            var runeWidth = Rune.ColumnWidth(rune);
            var validClip = IsValidContent(ccol, crow, Clip);

            if (validClip)
            {
                if (runeWidth == 0 && ccol > 0)
                {
                    var r = contents[crow, ccol - 1, 0];
                    var s = new string(new char[] { (char)r, (char)rune });
                    string sn;
                    if (!s.IsNormalized())
                    {
                        sn = s.Normalize();
                    }
                    else
                    {
                        sn = s;
                    }
                    var c = sn[0];
                    contents[crow, ccol - 1, 0] = c;
                    contents[crow, ccol - 1, 1] = CurrentAttribute;
                    contents[crow, ccol - 1, 2] = 1;

                }
                else
                {
                    if (runeWidth < 2 && ccol > 0
                        && Rune.ColumnWidth((char)contents[crow, ccol - 1, 0]) > 1)
                    {

                        contents[crow, ccol - 1, 0] = (int)(uint)' ';

                    }
                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
                      && Rune.ColumnWidth((char)contents[crow, ccol, 0]) > 1)
                    {

                        contents[crow, ccol + 1, 0] = (int)(uint)' ';
                        contents[crow, ccol + 1, 2] = 1;

                    }
                    if (runeWidth > 1 && ccol == Clip.Right - 1)
                    {
                        contents[crow, ccol, 0] = (int)(uint)' ';
                    }
                    else
                    {
                        contents[crow, ccol, 0] = (int)(uint)rune;
                    }
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 1;

                }
                dirtyLine[crow] = true;
            }

            if (runeWidth < 0 || runeWidth > 0)
            {
                ccol++;
            }

            if (runeWidth > 1)
            {
                if (validClip && ccol < Clip.Right)
                {
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 0;
                }
                ccol++;
            }

            if (sync)
            {
                UpdateScreen();
            }
        }

        public override void AddStr(ustring str)
        {
            foreach (var rune in str)
                AddRune(rune);
        }

        public override void End()
        {
            mainLoop.Dispose();

            if (IsWinPlatform)
            {
                NetWinConsole.Cleanup();
            }

            StopReportingMouseMoves();
            Console.ResetColor();

            //Disable alternative screen buffer.
            Console.Out.Write("\x1b[?1049l");

            //Set cursor key to cursor.
            Console.Out.Write("\x1b[?25h");

            Console.Out.Close();
        }

        public override Attribute MakeColor(Color foreground, Color background)
        {
            return MakeColor((ConsoleColor)foreground, (ConsoleColor)background);
        }

        static Attribute MakeColor(ConsoleColor f, ConsoleColor b)
        {
            // Encode the colors into the int value.
            return new Attribute(
                value: ((((int)f) & 0xffff) << 16) | (((int)b) & 0xffff),
                foreground: (Color)f,
                background: (Color)b
                );
        }

        public override void Init(Action terminalResized)
        {
            TerminalResized = terminalResized;

            //Enable alternative screen buffer.
            Console.Out.Write("\x1b[?1049h");

            //Set cursor key to application.
            Console.Out.Write("\x1b[?25l");

            Console.TreatControlCAsInput = true;

            cols = Console.WindowWidth;
            rows = Console.WindowHeight;

            CurrentAttribute = MakeColor(Color.White, Color.Black);
            InitalizeColorSchemes();

            CurrentAttribute = MakeColor(Color.White, Color.Black);
            InitalizeColorSchemes();

            ResizeScreen();
            UpdateOffScreen();

            StartReportingMouseMoves();
        }

        public override void ResizeScreen()
        {
            if (Console.WindowHeight > 0)
            {
                // Not supported on Unix.
                if (IsWinPlatform)
                {
                    // Can raise an exception while is still resizing.
                    try
                    {
#pragma warning disable CA1416
                        Console.CursorTop = 0;
                        Console.CursorLeft = 0;
                        Console.WindowTop = 0;
                        Console.WindowLeft = 0;
                        if (Console.WindowHeight > Rows)
                        {
                            Console.SetWindowSize(Cols, Rows);
                        }
                        Console.SetBufferSize(Cols, Rows);
#pragma warning restore CA1416
                    }
                    catch (System.IO.IOException)
                    {
                        setClip();
                    }
                    catch (ArgumentOutOfRangeException)
                    {
                        setClip();
                    }
                }
                else
                {
                    Console.Out.Write($"\x1b[8;{Rows};{Cols}t");
                }
            }

            setClip();

            void setClip()
            {
                Clip = new Rect(0, 0, Cols, Rows);
            }
        }

        public override void UpdateOffScreen()
        {
            contents = new int[Rows, Cols, 3];
            dirtyLine = new bool[Rows];

            lock (contents)
            {
                // Can raise an exception while is still resizing.
                try
                {
                    for (int row = 0; row < rows; row++)
                    {
                        for (int c = 0; c < cols; c++)
                        {
                            contents[row, c, 0] = ' ';
                            contents[row, c, 1] = (ushort)Colors.TopLevel.Normal;
                            contents[row, c, 2] = 0;
                            dirtyLine[row] = true;
                        }
                    }
                }
                catch (IndexOutOfRangeException) { }
            }
        }

        public override Attribute MakeAttribute(Color fore, Color back)
        {
            return MakeColor((ConsoleColor)fore, (ConsoleColor)back);
        }

        public override void Refresh()
        {
            UpdateScreen();
            UpdateCursor();
        }

        public override void UpdateScreen()
        {
            if (winChanging || Console.WindowHeight < 1 || contents.Length != Rows * Cols * 3 || Rows != Console.WindowHeight)
            {
                return;
            }

            int top = 0;
            int left = 0;
            int rows = Rows;
            int cols = Cols;
            System.Text.StringBuilder output = new System.Text.StringBuilder();
            int redrawAttr = -1;
            var lastCol = -1;

            Console.CursorVisible = false;

            for (int row = top; row < rows; row++)
            {
                if (Console.WindowHeight < 1)
                {
                    return;
                }
                if (!dirtyLine[row])
                {
                    continue;
                }
                if (!SetCursorPosition(0, row))
                {
                    return;
                }
                dirtyLine[row] = false;
                output.Clear();
                for (int col = left; col < cols; col++)
                {
                    lastCol = -1;
                    var outputWidth = 0;
                    for (; col < cols; col++)
                    {
                        if (contents[row, col, 2] == 0)
                        {
                            if (output.Length > 0)
                            {
                                SetCursorPosition(lastCol, row);
                                Console.Write(output);
                                output.Clear();
                                lastCol += outputWidth;
                                outputWidth = 0;
                            }
                            else if (lastCol == -1)
                            {
                                lastCol = col;
                            }
                            if (lastCol + 1 < cols)
                                lastCol++;
                            continue;
                        }

                        if (lastCol == -1)
                            lastCol = col;

                        var attr = contents[row, col, 1];
                        if (attr != redrawAttr)
                        {
                            redrawAttr = attr;
                            output.Append(WriteAttributes(attr));
                        }
                        outputWidth++;
                        var rune = contents[row, col, 0];
                        char[] spair;
                        if (Rune.DecodeSurrogatePair((uint)rune, out spair))
                        {
                            output.Append(spair);
                        }
                        else
                        {
                            output.Append((char)rune);
                        }
                        contents[row, col, 2] = 0;
                    }
                }
                if (output.Length > 0)
                {
                    SetCursorPosition(lastCol, row);
                    Console.Write(output);
                }
            }
            SetCursorPosition(0, 0);
        }

        void SetVirtualCursorPosition(int col, int row)
        {
            Console.Out.Write($"\x1b[{row + 1};{col + 1}H");
        }

        System.Text.StringBuilder WriteAttributes(int attr)
        {
            const string CSI = "\x1b[";
            int bg = 0;
            int fg = 0;
            System.Text.StringBuilder sb = new System.Text.StringBuilder();

            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
                  .OfType<ConsoleColor>()
                  .Select(s => (int)s);
            if (values.Contains(attr & 0xffff))
            {
                bg = MapColors((ConsoleColor)(attr & 0xffff), false);
            }
            if (values.Contains((attr >> 16) & 0xffff))
            {
                fg = MapColors((ConsoleColor)((attr >> 16) & 0xffff));
            }
            sb.Append($"{CSI}{bg};{fg}m");

            return sb;
        }

        int MapColors(ConsoleColor color, bool isForeground = true)
        {
            switch (color)
            {
                case ConsoleColor.Black:
                    return isForeground ? COLOR_BLACK : COLOR_BLACK + 10;
                case ConsoleColor.DarkBlue:
                    return isForeground ? COLOR_BLUE : COLOR_BLUE + 10;
                case ConsoleColor.DarkGreen:
                    return isForeground ? COLOR_GREEN : COLOR_GREEN + 10;
                case ConsoleColor.DarkCyan:
                    return isForeground ? COLOR_CYAN : COLOR_CYAN + 10;
                case ConsoleColor.DarkRed:
                    return isForeground ? COLOR_RED : COLOR_RED + 10;
                case ConsoleColor.DarkMagenta:
                    return isForeground ? COLOR_MAGENTA : COLOR_MAGENTA + 10;
                case ConsoleColor.DarkYellow:
                    return isForeground ? COLOR_YELLOW : COLOR_YELLOW + 10;
                case ConsoleColor.Gray:
                    return isForeground ? COLOR_WHITE : COLOR_WHITE + 10;
                case ConsoleColor.DarkGray:
                    return isForeground ? COLOR_BRIGHT_BLACK : COLOR_BRIGHT_BLACK + 10;
                case ConsoleColor.Blue:
                    return isForeground ? COLOR_BRIGHT_BLUE : COLOR_BRIGHT_BLUE + 10;
                case ConsoleColor.Green:
                    return isForeground ? COLOR_BRIGHT_GREEN : COLOR_BRIGHT_GREEN + 10;
                case ConsoleColor.Cyan:
                    return isForeground ? COLOR_BRIGHT_CYAN : COLOR_BRIGHT_CYAN + 10;
                case ConsoleColor.Red:
                    return isForeground ? COLOR_BRIGHT_RED : COLOR_BRIGHT_RED + 10;
                case ConsoleColor.Magenta:
                    return isForeground ? COLOR_BRIGHT_MAGENTA : COLOR_BRIGHT_MAGENTA + 10;
                case ConsoleColor.Yellow:
                    return isForeground ? COLOR_BRIGHT_YELLOW : COLOR_BRIGHT_YELLOW + 10;
                case ConsoleColor.White:
                    return isForeground ? COLOR_BRIGHT_WHITE : COLOR_BRIGHT_WHITE + 10;
            }
            return 0;
        }

        bool SetCursorPosition(int col, int row)
        {
            if (IsWinPlatform)
            {
                // Could happens that the windows is still resizing and the col is bigger than Console.WindowWidth.
                try
                {
                    Console.SetCursorPosition(col, row);
                    return true;
                }
                catch (Exception)
                {
                    return false;
                }
            }
            else
            {
                SetVirtualCursorPosition(col, row);
                return true;
            }
        }

        private void SetWindowPosition(int col, int row)
        {
            top = Console.WindowTop;
            left = Console.WindowLeft;
        }

        private bool EnsureBufferSize()
        {
#pragma warning disable CA1416
            if (IsWinPlatform && Console.BufferHeight < Rows)
            {
                try
                {
                    Console.SetBufferSize(Console.WindowWidth, Rows);
                }
                catch (Exception)
                {
                    return false;
                }
            }
#pragma warning restore CA1416
            return true;
        }

        private CursorVisibility? savedCursorVisibility;

        public override void UpdateCursor()
        {
            EnsureCursorVisibility();
            //Debug.WriteLine ($"Before - CursorTop: {Console.CursorTop};CursorLeft: {Console.CursorLeft}");

            if (ccol >= 0 && ccol < Cols && crow >= 0 && crow < Rows)
            {
                SetCursorPosition(ccol, crow);
                SetWindowPosition(0, crow);
            }
            //Debug.WriteLine ($"WindowTop: {Console.WindowTop};WindowLeft: {Console.WindowLeft}");
            //Debug.WriteLine ($"After - CursorTop: {Console.CursorTop};CursorLeft: {Console.CursorLeft}");
        }

        public override void StartReportingMouseMoves()
        {
            Console.Out.Write(EscSeqUtils.EnableMouseEvents);
        }

        public override void StopReportingMouseMoves()
        {
            Console.Out.Write(EscSeqUtils.DisableMouseEvents);
        }

        public override void Suspend()
        {
            if (Environment.OSVersion.Platform != PlatformID.Unix)
            {
                return;
            }

            StopReportingMouseMoves();
            Console.ResetColor();
            Console.Clear();

            //Disable alternative screen buffer.
            Console.Out.Write("\x1b[?1049l");

            //Set cursor key to cursor.
            Console.Out.Write("\x1b[?25h");

            Platform.Suspend();

            //Enable alternative screen buffer.
            Console.Out.Write("\x1b[?1049h");

            Application.Refresh();
            StartReportingMouseMoves();
        }

        public override void SetAttribute(Attribute c)
        {
            base.SetAttribute(c);
        }

        public ConsoleKeyInfo FromVKPacketToKConsoleKeyInfo(ConsoleKeyInfo consoleKeyInfo)
        {
            if (consoleKeyInfo.Key != ConsoleKey.Packet)
            {
                return consoleKeyInfo;
            }

            var mod = consoleKeyInfo.Modifiers;
            var shift = (mod & ConsoleModifiers.Shift) != 0;
            var alt = (mod & ConsoleModifiers.Alt) != 0;
            var control = (mod & ConsoleModifiers.Control) != 0;

            var keyChar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(consoleKeyInfo.KeyChar, consoleKeyInfo.Modifiers, out uint virtualKey, out _);

            return new ConsoleKeyInfo((char)keyChar, (ConsoleKey)virtualKey, shift, alt, control);
        }

        Key MapKey(ConsoleKeyInfo keyInfo)
        {
            MapKeyModifiers(keyInfo, (Key)keyInfo.Key);
            switch (keyInfo.Key)
            {
                case ConsoleKey.Escape:
                    return MapKeyModifiers(keyInfo, Key.Esc);
                case ConsoleKey.Tab:
                    return keyInfo.Modifiers == ConsoleModifiers.Shift ? Key.BackTab : Key.Tab;
                case ConsoleKey.Home:
                    return MapKeyModifiers(keyInfo, Key.Home);
                case ConsoleKey.End:
                    return MapKeyModifiers(keyInfo, Key.End);
                case ConsoleKey.LeftArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorLeft);
                case ConsoleKey.RightArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorRight);
                case ConsoleKey.UpArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorUp);
                case ConsoleKey.DownArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorDown);
                case ConsoleKey.PageUp:
                    return MapKeyModifiers(keyInfo, Key.PageUp);
                case ConsoleKey.PageDown:
                    return MapKeyModifiers(keyInfo, Key.PageDown);
                case ConsoleKey.Enter:
                    return MapKeyModifiers(keyInfo, Key.Enter);
                case ConsoleKey.Spacebar:
                    return MapKeyModifiers(keyInfo, keyInfo.KeyChar == 0 ? Key.Space : (Key)keyInfo.KeyChar);
                case ConsoleKey.Backspace:
                    return MapKeyModifiers(keyInfo, Key.Backspace);
                case ConsoleKey.Delete:
                    return MapKeyModifiers(keyInfo, Key.DeleteChar);
                case ConsoleKey.Insert:
                    return MapKeyModifiers(keyInfo, Key.InsertChar);


                case ConsoleKey.Oem1:
                case ConsoleKey.Oem2:
                case ConsoleKey.Oem3:
                case ConsoleKey.Oem4:
                case ConsoleKey.Oem5:
                case ConsoleKey.Oem6:
                case ConsoleKey.Oem7:
                case ConsoleKey.Oem8:
                case ConsoleKey.Oem102:
                case ConsoleKey.OemPeriod:
                case ConsoleKey.OemComma:
                case ConsoleKey.OemPlus:
                case ConsoleKey.OemMinus:
                    return (Key)((uint)keyInfo.KeyChar);
            }

            var key = keyInfo.Key;
            if (key >= ConsoleKey.A && key <= ConsoleKey.Z)
            {
                var delta = key - ConsoleKey.A;
                if (keyInfo.Modifiers == ConsoleModifiers.Control)
                {
                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.A + delta));
                }
                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
                {
                    return (Key)(((uint)Key.AltMask) | ((uint)Key.A + delta));
                }
                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    if (keyInfo.KeyChar == 0 || (keyInfo.KeyChar != 0 && keyInfo.KeyChar >= 1 && keyInfo.KeyChar <= 26))
                    {
                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
                    }
                }
                return (Key)((uint)keyInfo.KeyChar);
            }
            if (key >= ConsoleKey.D0 && key <= ConsoleKey.D9)
            {
                var delta = key - ConsoleKey.D0;
                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
                {
                    return (Key)(((uint)Key.AltMask) | ((uint)Key.D0 + delta));
                }
                if (keyInfo.Modifiers == ConsoleModifiers.Control)
                {
                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.D0 + delta));
                }
                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    if (keyInfo.KeyChar == 0 || keyInfo.KeyChar == 30 || keyInfo.KeyChar == ((uint)Key.D0 + delta))
                    {
                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
                    }
                }
                return (Key)((uint)keyInfo.KeyChar);
            }
            if (key >= ConsoleKey.F1 && key <= ConsoleKey.F12)
            {
                var delta = key - ConsoleKey.F1;
                if ((keyInfo.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.F1 + delta));
                }

                return (Key)((uint)Key.F1 + delta);
            }
            if (keyInfo.KeyChar != 0)
            {
                return MapKeyModifiers(keyInfo, (Key)((uint)keyInfo.KeyChar));
            }

            return (Key)(0xffffffff);
        }

        KeyModifiers keyModifiers;

        Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
        {
            if (keyModifiers == null)
            {
                keyModifiers = new KeyModifiers();
            }
            Key keyMod = new Key();
            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
            {
                keyMod = Key.ShiftMask;
                keyModifiers.Shift = true;
            }
            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
            {
                keyMod |= Key.CtrlMask;
                keyModifiers.Ctrl = true;
            }
            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
            {
                keyMod |= Key.AltMask;
                keyModifiers.Alt = true;
            }

            return keyMod != Key.Null ? keyMod | key : key;
        }

        Action<KeyEvent> keyHandler;
        Action<KeyEvent> keyDownHandler;
        Action<KeyEvent> keyUpHandler;
        Action<MouseEvent> mouseHandler;
        NetMainLoop mainLoop;

        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
        {
            this.keyHandler = keyHandler;
            this.keyDownHandler = keyDownHandler;
            this.keyUpHandler = keyUpHandler;
            this.mouseHandler = mouseHandler;

            var mLoop = this.mainLoop = mainLoop.Driver as NetMainLoop;

            // Note: Net doesn't support keydown/up events and thus any passed keyDown/UpHandlers will be simulated to be called.
            mLoop.ProcessInput = (e) => ProcessInput(e);
        }

        void ProcessInput(NetEvents.InputResult inputEvent)
        {
            switch (inputEvent.EventType)
            {
                case NetEvents.EventType.Key:
                    ConsoleKeyInfo consoleKeyInfo = inputEvent.ConsoleKeyInfo;
                    if (consoleKeyInfo.Key == ConsoleKey.Packet)
                    {
                        consoleKeyInfo = FromVKPacketToKConsoleKeyInfo(consoleKeyInfo);
                    }
                    keyModifiers = new KeyModifiers();
                    var map = MapKey(consoleKeyInfo);
                    if (map == (Key)0xffffffff)
                    {
                        return;
                    }
                    if (map == Key.Null)
                    {
                        keyDownHandler(new KeyEvent(map, keyModifiers));
                        keyUpHandler(new KeyEvent(map, keyModifiers));
                    }
                    else
                    {
                        keyDownHandler(new KeyEvent(map, keyModifiers));
                        keyHandler(new KeyEvent(map, keyModifiers));
                        keyUpHandler(new KeyEvent(map, keyModifiers));
                    }
                    break;
                case NetEvents.EventType.Mouse:
                    mouseHandler(ToDriverMouse(inputEvent.MouseEvent));
                    break;
                case NetEvents.EventType.WindowSize:
                    ChangeWin(inputEvent.WindowSizeEvent.Size);
                    break;
                case NetEvents.EventType.RequestResponse:
                    Application.Top.Data = inputEvent.RequestResponseEvent.ResultTuple;
                    break;
            }
        }

        volatile bool winChanging;

        void ChangeWin(Size size)
        {
            winChanging = true;
            top = 0;
            left = 0;
            cols = size.Width;
            rows = Math.Max(size.Height, 0);
            ResizeScreen();
            UpdateOffScreen();
            winChanging = false;
            TerminalResized?.Invoke();
        }

        MouseEvent ToDriverMouse(NetEvents.MouseEvent me)
        {
            //System.Diagnostics.Debug.WriteLine ($"X: {me.Position.X}; Y: {me.Position.Y}; ButtonState: {me.ButtonState}");

            MouseFlags mouseFlag = 0;

            if ((me.ButtonState & NetEvents.MouseButtonState.Button1Pressed) != 0)
            {
                mouseFlag |= MouseFlags.Button1Pressed;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button1Released) != 0)
            {
                mouseFlag |= MouseFlags.Button1Released;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button1Clicked) != 0)
            {
                mouseFlag |= MouseFlags.Button1Clicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button1DoubleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button1DoubleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button1TripleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button1TripleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button2Pressed) != 0)
            {
                mouseFlag |= MouseFlags.Button2Pressed;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button2Released) != 0)
            {
                mouseFlag |= MouseFlags.Button2Released;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button2Clicked) != 0)
            {
                mouseFlag |= MouseFlags.Button2Clicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button2DoubleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button2DoubleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button2TripleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button2TripleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button3Pressed) != 0)
            {
                mouseFlag |= MouseFlags.Button3Pressed;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button3Released) != 0)
            {
                mouseFlag |= MouseFlags.Button3Released;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button3Clicked) != 0)
            {
                mouseFlag |= MouseFlags.Button3Clicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button3DoubleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button3DoubleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button3TripleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button3TripleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledUp) != 0)
            {
                mouseFlag |= MouseFlags.WheeledUp;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledDown) != 0)
            {
                mouseFlag |= MouseFlags.WheeledDown;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledLeft) != 0)
            {
                mouseFlag |= MouseFlags.WheeledLeft;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonWheeledRight) != 0)
            {
                mouseFlag |= MouseFlags.WheeledRight;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button4Pressed) != 0)
            {
                mouseFlag |= MouseFlags.Button4Pressed;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button4Released) != 0)
            {
                mouseFlag |= MouseFlags.Button4Released;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button4Clicked) != 0)
            {
                mouseFlag |= MouseFlags.Button4Clicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button4DoubleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button4DoubleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.Button4TripleClicked) != 0)
            {
                mouseFlag |= MouseFlags.Button4TripleClicked;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ReportMousePosition) != 0)
            {
                mouseFlag |= MouseFlags.ReportMousePosition;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonShift) != 0)
            {
                mouseFlag |= MouseFlags.ButtonShift;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonCtrl) != 0)
            {
                mouseFlag |= MouseFlags.ButtonCtrl;
            }
            if ((me.ButtonState & NetEvents.MouseButtonState.ButtonAlt) != 0)
            {
                mouseFlag |= MouseFlags.ButtonAlt;
            }

            return new MouseEvent()
            {
                X = me.Position.X,
                Y = me.Position.Y,
                Flags = mouseFlag
            };
        }

        /// <inheritdoc/>
        public override bool GetCursorVisibility(out CursorVisibility visibility)
        {
            visibility = savedCursorVisibility ?? CursorVisibility.Default;
            return visibility == CursorVisibility.Default;
        }


        /// <inheritdoc/>
        public override bool SetCursorVisibility(CursorVisibility visibility)
        {
            savedCursorVisibility = visibility;
            Console.Out.Write(visibility == CursorVisibility.Default
                ? "\x1b[?25h"
                : "\x1b[?25l");

            return visibility == CursorVisibility.Default;
        }

        /// <inheritdoc/>
        public override bool EnsureCursorVisibility()
        {
            if (!(ccol >= 0 && crow >= 0 && ccol < Cols && crow < Rows))
            {
                GetCursorVisibility(out CursorVisibility cursorVisibility);
                savedCursorVisibility = cursorVisibility;
                SetCursorVisibility(CursorVisibility.Invisible);
                return false;
            }

            SetCursorVisibility(savedCursorVisibility ?? CursorVisibility.Default);
            return savedCursorVisibility == CursorVisibility.Default;
        }

        public override void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
        {
            NetEvents.InputResult input = new NetEvents.InputResult();
            input.EventType = NetEvents.EventType.Key;
            input.ConsoleKeyInfo = new ConsoleKeyInfo(keyChar, key, shift, alt, control);

            try
            {
                ProcessInput(input);
            }
            catch (OverflowException) { }
        }

        public override bool GetColors(int value, out Color foreground, out Color background)
        {
            bool hasColor = false;
            foreground = default;
            background = default;
            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
                  .OfType<ConsoleColor>()
                  .Select(s => (int)s);
            if (values.Contains(value & 0xffff))
            {
                hasColor = true;
                background = (Color)(ConsoleColor)(value & 0xffff);
            }
            if (values.Contains((value >> 16) & 0xffff))
            {
                hasColor = true;
                foreground = (Color)(ConsoleColor)((value >> 16) & 0xffff);
            }
            return hasColor;
        }

        #region Unused
        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
        {
        }

        public override void SetColors(short foregroundColorId, short backgroundColorId)
        {
        }

        public override void CookMouse()
        {
        }

        public override void UncookMouse()
        {
        }
        #endregion

        //
        // These are for the .NET driver, but running natively on Windows, wont run
        // on the Mono emulation
        //

    }

    /// <summary>
    /// Mainloop intended to be used with the .NET System.Console API, and can
    /// be used on Windows and Unix, it is cross platform but lacks things like
    /// file descriptor monitoring.
    /// </summary>
    /// <remarks>
    /// This implementation is used for NetDriver.
    /// </remarks>
    internal class NetMainLoop : IMainLoopDriver, IDisposable
    {
        ManualResetEventSlim keyReady = new ManualResetEventSlim(false);
        ManualResetEventSlim waitForProbe = new ManualResetEventSlim(false);
        Queue<NetEvents.InputResult?> inputResult = new Queue<NetEvents.InputResult?>();
        MainLoop mainLoop;
        CancellationTokenSource tokenSource = new CancellationTokenSource();
        internal NetEvents netEvents;

        /// <summary>
        /// Invoked when a Key is pressed.
        /// </summary>
        public Action<NetEvents.InputResult> ProcessInput;

        /// <summary>
        /// Initializes the class with the console driver.
        /// </summary>
        /// <remarks>
        ///   Passing a consoleDriver is provided to capture windows resizing.
        /// </remarks>
        /// <param name="consoleDriver">The console driver used by this Net main loop.</param>
        public NetMainLoop(ConsoleDriver consoleDriver = null)
        {
            if (consoleDriver == null)
            {
                throw new ArgumentNullException("Console driver instance must be provided.");
            }
            netEvents = new NetEvents(consoleDriver);
        }

        void NetInputHandler()
        {
            while (!tokenSource.IsCancellationRequested)
            {
                waitForProbe.Wait();
                waitForProbe.Reset();
                if (inputResult.Count == 0)
                {
                    inputResult.Enqueue(netEvents.ReadConsoleInput());
                }
                while (inputResult.Count > 0 && inputResult.Peek() == null)
                {
                    inputResult.Dequeue();
                }
                if (inputResult.Count > 0)
                {
                    keyReady.Set();
                }
            }
        }

        void IMainLoopDriver.Setup(MainLoop mainLoop)
        {
            this.mainLoop = mainLoop;
            Task.Run(NetInputHandler, tokenSource.Token);
        }

        void IMainLoopDriver.Wakeup()
        {
            keyReady.Set();
        }

        bool IMainLoopDriver.EventsPending(bool wait)
        {
            waitForProbe.Set();

            if (CheckTimers(wait, out var waitTimeout))
            {
                return true;
            }

            try
            {
                if (!tokenSource.IsCancellationRequested)
                {
                    keyReady.Wait(waitTimeout, tokenSource.Token);
                }
            }
            catch (OperationCanceledException)
            {
                return true;
            }
            finally
            {
                keyReady.Reset();
            }

            if (!tokenSource.IsCancellationRequested)
            {
                return inputResult.Count > 0 || CheckTimers(wait, out _);
            }

            tokenSource.Token.ThrowIfCancellationRequested();
            return true;
        }

        bool CheckTimers(bool wait, out int waitTimeout)
        {
            long now = DateTime.UtcNow.Ticks;

            if (mainLoop.timeouts.Count > 0)
            {
                waitTimeout = (int)((mainLoop.timeouts.Keys[0] - now) / TimeSpan.TicksPerMillisecond);
                if (waitTimeout < 0)
                    return true;
            }
            else
            {
                waitTimeout = -1;
            }

            if (!wait)
                waitTimeout = 0;

            int ic;
            lock (mainLoop.idleHandlers)
            {
                ic = mainLoop.idleHandlers.Count;
            }

            return ic > 0;
        }

        void IMainLoopDriver.MainIteration()
        {
            while (inputResult.Count > 0)
            {
                ProcessInput?.Invoke(inputResult.Dequeue().Value);
            }
        }

        public void Dispose()
        {
            tokenSource.Cancel();
            netEvents.TokenSource.Cancel();
        }
    }
    //=======================================================================
    /// <summary>
    /// A container for single <see cref="Child"/> that will allow to drawn <see cref="Border"/> in
    ///  two ways. If <see cref="UsePanelFrame"/> the borders and the child will be accommodated in the available
    ///  panel size, otherwise the panel will be resized based on the child and borders thickness sizes.
    /// </summary>
    public class PanelView : View
    {
        ChildContentView childContentView;

        private class ChildContentView : View { }

        private class SavedPosDim
        {
            public Pos X;
            public Pos Y;
            public Dim Width;
            public Dim Height;
        }

        private SavedPosDim savedPanel;
        private SavedPosDim savedChild;

        private View child;
        private bool usePanelFrame;

        /// <summary>
        /// Initializes a panel with a null child.
        /// </summary>
        public PanelView() : this(null) { }

        /// <summary>
        /// Initializes a panel with a valid child.
        /// </summary>
        /// <param name="child"></param>
        public PanelView(View child)
        {
            childContentView = new ChildContentView();
            base.Add(childContentView);
            CanFocus = false;
            Child = child;
            if (child != null)
            {
                Visible = child.Visible;
            }
        }

        /// <summary>
        /// Gets or sets if the panel size will used, otherwise the child size.
        /// </summary>
        public bool UsePanelFrame
        {
            get => usePanelFrame;
            set
            {
                usePanelFrame = value;
                AdjustContainer();
            }
        }

        /// <summary>
        /// The child that will use this panel.
        /// </summary>
        public View Child
        {
            get => child;
            set
            {
                if (child != null && value == null)
                {
                    childContentView.Remove(child);
                    child = value;
                    return;
                }
                child = value;
                savedChild = new SavedPosDim()
                {
                    X = child?.X ?? child?.Frame.X,
                    Y = child?.Y ?? child?.Frame.Y,
                    Width = child?.Width ?? child?.Frame.Width,
                    Height = child?.Height ?? child?.Frame.Height
                };
                if (child == null)
                {
                    Visible = false;
                    return;
                }
                if (child?.Border != null)
                {
                    Border = child.Border;
                }
                else
                {
                    if (Border == null)
                    {
                        Border = new Border();
                    }
                    Child.Border = Border;
                }
                Border.Child = childContentView;
                if (!child.IsInitialized)
                {
                    child.Initialized += Child_Initialized;
                }
                childContentView.Add(Child);
            }
        }

        /// <inheritdoc />
        public override Border Border
        {
            get => base.Border;
            set
            {
                if (base.Border?.Child != null && value.Child == null)
                {
                    value.Child = base.Border.Child;
                }
                base.Border = value;
                if (value == null)
                {
                    return;
                }
                Border.BorderChanged += Border_BorderChanged;
                if (Child != null && (Child?.Border == null || Child?.Border != value))
                {
                    if (Child?.Border == null)
                    {
                        Child.Border = new Border();
                    }
                    Child.Border = Border;
                    Child.Border.BorderChanged += Border_BorderChanged;
                }
                AdjustContainer();
            }
        }

        private void Child_Initialized(object sender, EventArgs e)
        {
            savedPanel = new SavedPosDim()
            {
                X = X,
                Y = Y,
                Width = Width,
                Height = Height
            };
            AdjustContainer();
            Child.Initialized -= Child_Initialized;
        }

        private void Border_BorderChanged(Border obj)
        {
            AdjustContainer();
        }

        private void AdjustContainer()
        {
            if (Child?.IsInitialized == true)
            {
                if (Child?.Border != null && Child.Border != Border)
                {
                    Border = Child.Border;
                }
                var borderLength = Child.Border.DrawMarginFrame ? 1 : 0;
                var sumPadding = Child.Border.GetSumThickness();
                var effect3DOffset = Child.Border.Effect3D ? Child.Border.Effect3DOffset : new Point();
                if (!UsePanelFrame)
                {
                    X = savedPanel.X;
                    childContentView.X = borderLength + sumPadding.Left;
                    Y = savedPanel.Y;
                    childContentView.Y = borderLength + sumPadding.Top;
                    if (savedChild.Width is Dim.DimFill)
                    {
                        var margin = -savedChild.Width.Anchor(0);
                        Width = Dim.Fill(margin);
                        childContentView.Width = Dim.Fill(margin + borderLength + sumPadding.Right);
                    }
                    else
                    {
                        var savedLayout = LayoutStyle;
                        LayoutStyle = LayoutStyle.Absolute;
                        Width = savedChild.X.Anchor(0) + savedChild.Width + (2 * borderLength) + sumPadding.Right + sumPadding.Left;
                        LayoutStyle = savedLayout;
                        childContentView.Width = Dim.Fill(borderLength + sumPadding.Right);
                    }
                    if (savedChild.Height is Dim.DimFill)
                    {
                        var margin = -savedChild.Height.Anchor(0);
                        Height = Dim.Fill(margin);
                        childContentView.Height = Dim.Fill(margin + borderLength + sumPadding.Bottom);
                    }
                    else
                    {
                        var savedLayout = LayoutStyle;
                        LayoutStyle = LayoutStyle.Absolute;
                        Height = savedChild.Y.Anchor(0) + savedChild.Height + (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
                        LayoutStyle = savedLayout;
                        childContentView.Height = Dim.Fill(borderLength + sumPadding.Bottom);
                    }
                }
                else
                {
                    X = savedPanel.X - (effect3DOffset.X < 0 ? effect3DOffset.X : 0);
                    childContentView.X = borderLength + sumPadding.Left;
                    Y = savedPanel.Y - (effect3DOffset.Y < 0 ? effect3DOffset.Y : 0);
                    childContentView.Y = borderLength + sumPadding.Top;
                    Width = savedPanel.Width;
                    Height = savedPanel.Height;
                    if (Width is Dim.DimFill)
                    {
                        var margin = -savedPanel.Width.Anchor(0) +
                            (effect3DOffset.X > 0 ? effect3DOffset.X : 0);
                        Width = Dim.Fill(margin);
                        childContentView.Width = Dim.Fill(margin + borderLength + sumPadding.Right +
                            (effect3DOffset.X > 0 ? effect3DOffset.X : 0));
                    }
                    else
                    {
                        childContentView.Width = Dim.Fill(borderLength + sumPadding.Right);
                    }
                    if (Height is Dim.DimFill)
                    {
                        var margin = -savedPanel.Height.Anchor(0) +
                            (effect3DOffset.Y > 0 ? effect3DOffset.Y : 0);
                        Height = Dim.Fill(margin);
                        childContentView.Height = Dim.Fill(margin + borderLength + sumPadding.Bottom +
                            (effect3DOffset.Y > 0 ? effect3DOffset.Y : 0));
                    }
                    else
                    {
                        childContentView.Height = Dim.Fill(borderLength + sumPadding.Bottom);
                    }
                }
                Visible = Child.Visible;
            }
            else
            {
                Visible = false;
            }
        }

        /// <inheritdoc/>
        public override void Add(View view)
        {
            if (Child != null)
            {
                Child = null;
            }
            Child = view;
        }

        /// <inheritdoc/>
        public override void Remove(View view)
        {
            if (view == childContentView)
            {
                base.Remove(view);
                return;
            }
            childContentView.Remove(view);
            if (Child != null)
            {
                Child = null;
            }
        }

        /// <inheritdoc/>
        public override void RemoveAll()
        {
            if (Child != null)
            {
                Child = null;
            }
        }

        /// <inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            if (!NeedDisplay.IsEmpty)
            {
                Driver.SetAttribute(Child.GetNormalColor());
                Clear();
                Child.Border.DrawContent(Border.Child);
            }
            var savedClip = childContentView.ClipToBounds();
            childContentView.Redraw(childContentView.Bounds);
            Driver.Clip = savedClip;

            ClearLayoutNeeded();
            ClearNeedsDisplay();
        }
    }
    //=======================================================================
    //
    // System.Drawing.Point.cs
    //
    // Author:
    //   Mike Kestner (mkestner@speakeasy.net)
    //
    // Copyright (C) 2001 Mike Kestner
    // Copyright (C) 2004 Novell, Inc.  http://www.novell.com 
    //

    /// <summary>
    /// Represents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane.
    /// </summary>
    public struct Point
    {
        /// <summary>
        /// Gets or sets the x-coordinate of this Point.
        /// </summary>
        public int X;

        /// <summary>
        /// Gets or sets the y-coordinate of this Point.
        /// </summary>
        public int Y;

        // -----------------------
        // Public Shared Members
        // -----------------------

        /// <summary>
        ///	Empty Shared Field
        /// </summary>
        ///
        /// <remarks>
        ///	An uninitialized Point Structure.
        /// </remarks>

        public static readonly Point Empty;

        /// <summary>
        ///	Addition Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Translates a Point using the Width and Height
        ///	properties of the given <typeref>Size</typeref>.
        /// </remarks>

        public static Point operator +(Point pt, Size sz)
        {
            return new Point(pt.X + sz.Width, pt.Y + sz.Height);
        }

        /// <summary>
        ///	Equality Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Compares two Point objects. The return value is
        ///	based on the equivalence of the X and Y properties 
        ///	of the two points.
        /// </remarks>

        public static bool operator ==(Point left, Point right)
        {
            return ((left.X == right.X) && (left.Y == right.Y));
        }

        /// <summary>
        ///	Inequality Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Compares two Point objects. The return value is
        ///	based on the equivalence of the X and Y properties 
        ///	of the two points.
        /// </remarks>

        public static bool operator !=(Point left, Point right)
        {
            return ((left.X != right.X) || (left.Y != right.Y));
        }

        /// <summary>
        ///	Subtraction Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Translates a Point using the negation of the Width 
        ///	and Height properties of the given Size.
        /// </remarks>

        public static Point operator -(Point pt, Size sz)
        {
            return new Point(pt.X - sz.Width, pt.Y - sz.Height);
        }

        /// <summary>
        ///	Point to Size Conversion
        /// </summary>
        ///
        /// <remarks>
        ///	Returns a Size based on the Coordinates of a given 
        ///	Point. Requires explicit cast.
        /// </remarks>

        public static explicit operator Size(Point p)
        {
            if (p.X < 0 || p.Y < 0)
                throw new ArgumentException("Either Width and Height must be greater or equal to 0.");

            return new Size(p.X, p.Y);
        }

        // -----------------------
        // Public Constructors
        // -----------------------
        /// <summary>
        ///	Point Constructor
        /// </summary>
        ///
        /// <remarks>
        ///	Creates a Point from a Size value.
        /// </remarks>

        public Point(Size sz)
        {
            X = sz.Width;
            Y = sz.Height;
        }

        /// <summary>
        ///	Point Constructor
        /// </summary>
        ///
        /// <remarks>
        ///	Creates a Point from a specified x,y coordinate pair.
        /// </remarks>

        public Point(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }

        // -----------------------
        // Public Instance Members
        // -----------------------

        /// <summary>
        ///	IsEmpty Property
        /// </summary>
        ///
        /// <remarks>
        ///	Indicates if both X and Y are zero.
        /// </remarks>		
        public bool IsEmpty
        {
            get
            {
                return ((X == 0) && (Y == 0));
            }
        }

        /// <summary>
        ///	Equals Method
        /// </summary>
        ///
        /// <remarks>
        ///	Checks equivalence of this Point and another object.
        /// </remarks>

        public override bool Equals(object obj)
        {
            if (!(obj is Point))
                return false;

            return (this == (Point)obj);
        }

        /// <summary>
        ///	GetHashCode Method
        /// </summary>
        ///
        /// <remarks>
        ///	Calculates a hashing value.
        /// </remarks>

        public override int GetHashCode()
        {
            return X ^ Y;
        }

        /// <summary>
        ///	Offset Method
        /// </summary>
        ///
        /// <remarks>
        ///	Moves the Point a specified distance.
        /// </remarks>

        public void Offset(int dx, int dy)
        {
            X += dx;
            Y += dy;
        }

        /// <summary>
        ///	ToString Method
        /// </summary>
        ///
        /// <remarks>
        ///	Formats the Point as a string in coordinate notation.
        /// </remarks>

        public override string ToString()
        {
            return string.Format("{{X={0},Y={1}}}", X.ToString(CultureInfo.InvariantCulture),
                Y.ToString(CultureInfo.InvariantCulture));
        }

        /// <summary>
        /// Adds the specified Size to the specified Point.
        /// </summary>
        /// <returns>The Point that is the result of the addition operation.</returns>
        /// <param name="pt">The Point to add.</param>
        /// <param name="sz">The Size to add.</param>
        public static Point Add(Point pt, Size sz)
        {
            return new Point(pt.X + sz.Width, pt.Y + sz.Height);
        }

        /// <summary>
        /// Translates this Point by the specified Point.
        /// </summary>
        /// <returns>The offset.</returns>
        /// <param name="p">The Point used offset this Point.</param>
        public void Offset(Point p)
        {
            Offset(p.X, p.Y);
        }

        /// <summary>
        /// Returns the result of subtracting specified Size from the specified Point.
        /// </summary>
        /// <returns>The Point that is the result of the subtraction operation.</returns>
        /// <param name="pt">The Point to be subtracted from.</param>
        /// <param name="sz">The Size to subtract from the Point.</param>
        public static Point Subtract(Point pt, Size sz)
        {
            return new Point(pt.X - sz.Width, pt.Y - sz.Height);
        }

    }
    //=======================================================================
    // Licensed to the .NET Foundation under one or more agreements.
    // The .NET Foundation licenses this file to you under the MIT license.
    // See the LICENSE file in the project root for more information.

    // Copied from: https://github.com/dotnet/corefx/tree/master/src/System.Drawing.Primitives/src/System/Drawing

    /// <summary>
    /// Represents an ordered pair of x and y coordinates that define a point in a two-dimensional plane.
    /// </summary>
    public struct PointF : IEquatable<PointF>
    {
        /// <summary>
        /// Creates a new instance of the <see cref='Terminal.Gui.PointF'/> class with member data left uninitialized.
        /// </summary>
        public static readonly PointF Empty;
        private float x; // Do not rename (binary serialization)
        private float y; // Do not rename (binary serialization)

        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.PointF'/> class with the specified coordinates.
        /// </summary>
        public PointF(float x, float y)
        {
            this.x = x;
            this.y = y;
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref='Terminal.Gui.PointF'/> is empty.
        /// </summary>
        [Browsable(false)]
        public bool IsEmpty => x == 0f && y == 0f;

        /// <summary>
        /// Gets the x-coordinate of this <see cref='Terminal.Gui.PointF'/>.
        /// </summary>
        public float X
        {
            get => x;
            set => x = value;
        }

        /// <summary>
        /// Gets the y-coordinate of this <see cref='Terminal.Gui.PointF'/>.
        /// </summary>
        public float Y
        {
            get => y;
            set => y = value;
        }

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.Size'/> .
        /// </summary>
        public static PointF operator +(PointF pt, Size sz) => Add(pt, sz);

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.Size'/> .
        /// </summary>
        public static PointF operator -(PointF pt, Size sz) => Subtract(pt, sz);

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.SizeF'/> .
        /// </summary>
        public static PointF operator +(PointF pt, SizeF sz) => Add(pt, sz);

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.SizeF'/> .
        /// </summary>
        public static PointF operator -(PointF pt, SizeF sz) => Subtract(pt, sz);

        /// <summary>
        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
        /// <see cref='Terminal.Gui.PointF.X'/> and <see cref='Terminal.Gui.PointF.Y'/> properties of the two
        /// <see cref='Terminal.Gui.PointF'/> objects are equal.
        /// </summary>
        public static bool operator ==(PointF left, PointF right) => left.X == right.X && left.Y == right.Y;

        /// <summary>
        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
        /// <see cref='Terminal.Gui.PointF.X'/> or <see cref='Terminal.Gui.PointF.Y'/> properties of the two
        /// <see cref='Terminal.Gui.PointF'/> objects are unequal.
        /// </summary>
        public static bool operator !=(PointF left, PointF right) => !(left == right);

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.Size'/> .
        /// </summary>
        public static PointF Add(PointF pt, Size sz) => new PointF(pt.X + sz.Width, pt.Y + sz.Height);

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.Size'/> .
        /// </summary>
        public static PointF Subtract(PointF pt, Size sz) => new PointF(pt.X - sz.Width, pt.Y - sz.Height);

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by a given <see cref='Terminal.Gui.SizeF'/> .
        /// </summary>
        public static PointF Add(PointF pt, SizeF sz) => new PointF(pt.X + sz.Width, pt.Y + sz.Height);

        /// <summary>
        /// Translates a <see cref='Terminal.Gui.PointF'/> by the negative of a given <see cref='Terminal.Gui.SizeF'/> .
        /// </summary>
        public static PointF Subtract(PointF pt, SizeF sz) => new PointF(pt.X - sz.Width, pt.Y - sz.Height);


        /// <summary>
        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
        /// <see cref='Terminal.Gui.PointF.X'/> and <see cref='Terminal.Gui.PointF.Y'/> properties of the two
        /// <see cref='Terminal.Gui.PointF'/> objects are equal.
        /// </summary>
        public override bool Equals(object obj) => obj is PointF && Equals((PointF)obj);


        /// <summary>
        /// Compares two <see cref='Terminal.Gui.PointF'/> objects. The result specifies whether the values of the
        /// <see cref='Terminal.Gui.PointF.X'/> and <see cref='Terminal.Gui.PointF.Y'/> properties of the two
        /// <see cref='Terminal.Gui.PointF'/> objects are equal.
        /// </summary>
        public bool Equals(PointF other) => this == other;

        /// <summary>
        /// Generates a hashcode from the X and Y components
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return X.GetHashCode() ^ Y.GetHashCode();
        }

        /// <summary>
        /// Returns a string including the X and Y values
        /// </summary>
        /// <returns></returns>
        public override string ToString() => "{X=" + x.ToString() + ", Y=" + y.ToString() + "}";
    }
    //=======================================================================
    //
    // PosDim.cs: Pos and Dim objects for view dimensions.
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    /// Describes the position of a <see cref="View"/> which can be an absolute value, a percentage, centered, or 
    /// relative to the ending dimension. Integer values are implicitly convertible to
    /// an absolute <see cref="Pos"/>. These objects are created using the static methods Percent,
    /// AnchorEnd, and Center. The <see cref="Pos"/> objects can be combined with the addition and 
    /// subtraction operators.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     Use the <see cref="Pos"/> objects on the X or Y properties of a view to control the position.
    ///   </para>
    ///   <para>
    ///     These can be used to set the absolute position, when merely assigning an
    ///     integer value (via the implicit integer to <see cref="Pos"/> conversion), and they can be combined
    ///     to produce more useful layouts, like: Pos.Center - 3, which would shift the position
    ///     of the <see cref="View"/> 3 characters to the left after centering for example.
    ///   </para>
    ///   <para>
    ///     It is possible to reference coordinates of another view by using the methods
    ///     Left(View), Right(View), Bottom(View), Top(View). The X(View) and Y(View) are
    ///     aliases to Left(View) and Top(View) respectively.
    ///   </para>
    /// </remarks>
    public class Pos
    {
        internal virtual int Anchor(int width)
        {
            return 0;
        }

        // Helper class to provide dynamic value by the execution of a function that returns an integer.
        internal class PosFunc : Pos
        {
            Func<int> function;

            public PosFunc(Func<int> n)
            {
                this.function = n;
            }

            internal override int Anchor(int width)
            {
                return function();
            }

            public override string ToString()
            {
                return $"Pos.PosFunc({function()})";
            }

            public override int GetHashCode() => function.GetHashCode();

            public override bool Equals(object other) => other is PosFunc f && f.function() == function();
        }

        /// <summary>
        /// Creates a "PosFunc" from the specified function.
        /// </summary>
        /// <param name="function">The function to be executed.</param>
        /// <returns>The <see cref="Pos"/> returned from the function.</returns>
        public static Pos Function(Func<int> function)
        {
            return new PosFunc(function);
        }

        internal class PosFactor : Pos
        {
            float factor;

            public PosFactor(float n)
            {
                this.factor = n;
            }

            internal override int Anchor(int width)
            {
                return (int)(width * factor);
            }

            public override string ToString()
            {
                return $"Pos.Factor({factor})";
            }

            public override int GetHashCode() => factor.GetHashCode();

            public override bool Equals(object other) => other is PosFactor f && f.factor == factor;
        }

        /// <summary>
        /// Creates a percentage <see cref="Pos"/> object
        /// </summary>
        /// <returns>The percent <see cref="Pos"/> object.</returns>
        /// <param name="n">A value between 0 and 100 representing the percentage.</param>
        /// <example>
        /// This creates a <see cref="TextField"/>that is centered horizontally, is 50% of the way down, 
        /// is 30% the height, and is 80% the width of the <see cref="View"/> it added to.
        /// <code>
        /// var textView = new TextView () {
        ///	X = Pos.Center (),
        ///	Y = Pos.Percent (50),
        ///	Width = Dim.Percent (80),
        /// 	Height = Dim.Percent (30),
        /// };
        /// </code>
        /// </example>
        public static Pos Percent(float n)
        {
            if (n < 0 || n > 100)
                throw new ArgumentException("Percent value must be between 0 and 100");

            return new PosFactor(n / 100);
        }

        internal class PosAnchorEnd : Pos
        {
            int n;

            public PosAnchorEnd(int n)
            {
                this.n = n;
            }

            internal override int Anchor(int width)
            {
                return width - n;
            }

            public override string ToString()
            {
                return $"Pos.AnchorEnd(margin={n})";
            }

            public override int GetHashCode() => n.GetHashCode();

            public override bool Equals(object other) => other is PosAnchorEnd anchorEnd && anchorEnd.n == n;
        }

        /// <summary>
        /// Creates a <see cref="Pos"/> object that is anchored to the end (right side or bottom) of the dimension, 
        /// useful to flush the layout from the right or bottom.
        /// </summary>
        /// <returns>The <see cref="Pos"/> object anchored to the end (the bottom or the right side).</returns>
        /// <param name="margin">Optional margin to place to the right or below.</param>
        /// <example>
        /// This sample shows how align a <see cref="Button"/> to the bottom-right of a <see cref="View"/>.
        /// <code>
        /// // See Issue #502 
        /// anchorButton.X = Pos.AnchorEnd () - (Pos.Right (anchorButton) - Pos.Left (anchorButton));
        /// anchorButton.Y = Pos.AnchorEnd (1);
        /// </code>
        /// </example>
        public static Pos AnchorEnd(int margin = 0)
        {
            if (margin < 0)
                throw new ArgumentException("Margin must be positive");

            return new PosAnchorEnd(margin);
        }

        internal class PosCenter : Pos
        {
            internal override int Anchor(int width)
            {
                return width / 2;
            }

            public override string ToString()
            {
                return "Pos.Center";
            }
        }

        /// <summary>
        /// Returns a <see cref="Pos"/> object that can be used to center the <see cref="View"/>
        /// </summary>
        /// <returns>The center Pos.</returns>
        /// <example>
        /// This creates a <see cref="TextField"/>that is centered horizontally, is 50% of the way down, 
        /// is 30% the height, and is 80% the width of the <see cref="View"/> it added to.
        /// <code>
        /// var textView = new TextView () {
        ///	X = Pos.Center (),
        ///	Y = Pos.Percent (50),
        ///	Width = Dim.Percent (80),
        /// 	Height = Dim.Percent (30),
        /// };
        /// </code>
        /// </example>
        public static Pos Center()
        {
            return new PosCenter();
        }

        internal class PosAbsolute : Pos
        {
            int n;
            public PosAbsolute(int n) { this.n = n; }

            public override string ToString()
            {
                return $"Pos.Absolute({n})";
            }

            internal override int Anchor(int width)
            {
                return n;
            }

            public override int GetHashCode() => n.GetHashCode();

            public override bool Equals(object other) => other is PosAbsolute abs && abs.n == n;
        }

        /// <summary>
        /// Creates an Absolute <see cref="Pos"/> from the specified integer value.
        /// </summary>
        /// <returns>The Absolute <see cref="Pos"/>.</returns>
        /// <param name="n">The value to convert to the <see cref="Pos"/> .</param>
        public static implicit operator Pos(int n)
        {
            return new PosAbsolute(n);
        }

        /// <summary>
        /// Creates an Absolute <see cref="Pos"/> from the specified integer value.
        /// </summary>
        /// <returns>The Absolute <see cref="Pos"/>.</returns>
        /// <param name="n">The value to convert to the <see cref="Pos"/>.</param>
        public static Pos At(int n)
        {
            return new PosAbsolute(n);
        }

        internal class PosCombine : Pos
        {
            internal Pos left, right;
            bool add;
            public PosCombine(bool add, Pos left, Pos right)
            {
                this.left = left;
                this.right = right;
                this.add = add;
            }

            internal override int Anchor(int width)
            {
                var la = left.Anchor(width);
                var ra = right.Anchor(width);
                if (add)
                    return la + ra;
                else
                    return la - ra;
            }

            public override string ToString()
            {
                return $"Pos.Combine({left.ToString()}{(add ? '+' : '-')}{right.ToString()})";
            }

        }

        /// <summary>
        /// Adds a <see cref="Terminal.Gui.Pos"/> to a <see cref="Terminal.Gui.Pos"/>, yielding a new <see cref="Pos"/>.
        /// </summary>
        /// <param name="left">The first <see cref="Terminal.Gui.Pos"/> to add.</param>
        /// <param name="right">The second <see cref="Terminal.Gui.Pos"/> to add.</param>
        /// <returns>The <see cref="Pos"/> that is the sum of the values of <c>left</c> and <c>right</c>.</returns>
        public static Pos operator +(Pos left, Pos right)
        {
            if (left is PosAbsolute && right is PosAbsolute)
            {
                return new PosAbsolute(left.Anchor(0) + right.Anchor(0));
            }
            PosCombine newPos = new PosCombine(true, left, right);
            SetPosCombine(left, newPos);
            return newPos;
        }

        /// <summary>
        /// Subtracts a <see cref="Terminal.Gui.Pos"/> from a <see cref="Terminal.Gui.Pos"/>, yielding a new <see cref="Pos"/>.
        /// </summary>
        /// <param name="left">The <see cref="Terminal.Gui.Pos"/> to subtract from (the minuend).</param>
        /// <param name="right">The <see cref="Terminal.Gui.Pos"/> to subtract (the subtrahend).</param>
        /// <returns>The <see cref="Pos"/> that is the <c>left</c> minus <c>right</c>.</returns>
        public static Pos operator -(Pos left, Pos right)
        {
            if (left is PosAbsolute && right is PosAbsolute)
            {
                return new PosAbsolute(left.Anchor(0) - right.Anchor(0));
            }
            PosCombine newPos = new PosCombine(false, left, right);
            SetPosCombine(left, newPos);
            return newPos;
        }

        static void SetPosCombine(Pos left, PosCombine newPos)
        {
            var view = left as PosView;
            if (view != null)
            {
                view.Target.SetNeedsLayout();
            }
        }

        internal class PosView : Pos
        {
            public View Target;
            int side;
            public PosView(View view, int side)
            {
                Target = view;
                this.side = side;
            }
            internal override int Anchor(int width)
            {
                switch (side)
                {
                    case 0: return Target.Frame.X;
                    case 1: return Target.Frame.Y;
                    case 2: return Target.Frame.Right;
                    case 3: return Target.Frame.Bottom;
                    default:
                        return 0;
                }
            }

            public override string ToString()
            {
                string tside;
                switch (side)
                {
                    case 0: tside = "x"; break;
                    case 1: tside = "y"; break;
                    case 2: tside = "right"; break;
                    case 3: tside = "bottom"; break;
                    default: tside = "unknown"; break;
                }
                return $"Pos.View(side={tside}, target={Target.ToString()})";
            }

            public override int GetHashCode() => Target.GetHashCode();

            public override bool Equals(object other) => other is PosView abs && abs.Target == Target;
        }

        /// <summary>
        /// Returns a <see cref="Pos"/> object tracks the Left (X) position of the specified <see cref="View"/>.
        /// </summary>
        /// <returns>The <see cref="Pos"/> that depends on the other view.</returns>
        /// <param name="view">The <see cref="View"/>  that will be tracked.</param>
        public static Pos Left(View view) => new PosCombine(true, new PosView(view, 0), new Pos.PosAbsolute(0));

        /// <summary>
        /// Returns a <see cref="Pos"/> object tracks the Left (X) position of the specified <see cref="View"/>.
        /// </summary>
        /// <returns>The <see cref="Pos"/> that depends on the other view.</returns>
        /// <param name="view">The <see cref="View"/>  that will be tracked.</param>
        public static Pos X(View view) => new PosCombine(true, new PosView(view, 0), new Pos.PosAbsolute(0));

        /// <summary>
        /// Returns a <see cref="Pos"/> object tracks the Top (Y) position of the specified <see cref="View"/>.
        /// </summary>
        /// <returns>The <see cref="Pos"/> that depends on the other view.</returns>
        /// <param name="view">The <see cref="View"/>  that will be tracked.</param>
        public static Pos Top(View view) => new PosCombine(true, new PosView(view, 1), new Pos.PosAbsolute(0));

        /// <summary>
        /// Returns a <see cref="Pos"/> object tracks the Top (Y) position of the specified <see cref="View"/>.
        /// </summary>
        /// <returns>The <see cref="Pos"/> that depends on the other view.</returns>
        /// <param name="view">The <see cref="View"/>  that will be tracked.</param>
        public static Pos Y(View view) => new PosCombine(true, new PosView(view, 1), new Pos.PosAbsolute(0));

        /// <summary>
        /// Returns a <see cref="Pos"/> object tracks the Right (X+Width) coordinate of the specified <see cref="View"/>.
        /// </summary>
        /// <returns>The <see cref="Pos"/> that depends on the other view.</returns>
        /// <param name="view">The <see cref="View"/>  that will be tracked.</param>
        public static Pos Right(View view) => new PosCombine(true, new PosView(view, 2), new Pos.PosAbsolute(0));

        /// <summary>
        /// Returns a <see cref="Pos"/> object tracks the Bottom (Y+Height) coordinate of the specified <see cref="View"/> 
        /// </summary>
        /// <returns>The <see cref="Pos"/> that depends on the other view.</returns>
        /// <param name="view">The <see cref="View"/>  that will be tracked.</param>
        public static Pos Bottom(View view) => new PosCombine(true, new PosView(view, 3), new Pos.PosAbsolute(0));

        /// <summary>Serves as the default hash function. </summary>
        /// <returns>A hash code for the current object.</returns>
        public override int GetHashCode() => Anchor(0).GetHashCode();

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        /// <param name="other">The object to compare with the current object. </param>
        /// <returns>
        ///     <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        public override bool Equals(object other) => other is Pos abs && abs == this;
    }

    /// <summary>
    /// Dim properties of a <see cref="View"/> to control the position.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     Use the Dim objects on the Width or Height properties of a <see cref="View"/> to control the position.
    ///   </para>
    ///   <para>
    ///     These can be used to set the absolute position, when merely assigning an
    ///     integer value (via the implicit integer to Pos conversion), and they can be combined
    ///     to produce more useful layouts, like: Pos.Center - 3, which would shift the position
    ///     of the <see cref="View"/> 3 characters to the left after centering for example.
    ///   </para>
    /// </remarks>
    public class Dim
    {
        internal virtual int Anchor(int width)
        {
            return 0;
        }

        // Helper class to provide dynamic value by the execution of a function that returns an integer.
        internal class DimFunc : Dim
        {
            Func<int> function;

            public DimFunc(Func<int> n)
            {
                this.function = n;
            }

            internal override int Anchor(int width)
            {
                return function();
            }

            public override string ToString()
            {
                return $"Dim.DimFunc({function()})";
            }

            public override int GetHashCode() => function.GetHashCode();

            public override bool Equals(object other) => other is DimFunc f && f.function() == function();
        }

        /// <summary>
        /// Creates a "DimFunc" from the specified function.
        /// </summary>
        /// <param name="function">The function to be executed.</param>
        /// <returns>The <see cref="Dim"/> returned from the function.</returns>
        public static Dim Function(Func<int> function)
        {
            return new DimFunc(function);
        }

        internal class DimFactor : Dim
        {
            float factor;
            bool remaining;

            public DimFactor(float n, bool r = false)
            {
                factor = n;
                remaining = r;
            }

            internal override int Anchor(int width)
            {
                return (int)(width * factor);
            }

            public bool IsFromRemaining()
            {
                return remaining;
            }

            public override string ToString()
            {
                return $"Dim.Factor(factor={factor}, remaining={remaining})";
            }

            public override int GetHashCode() => factor.GetHashCode();

            public override bool Equals(object other) => other is DimFactor f && f.factor == factor && f.remaining == remaining;
        }

        /// <summary>
        /// Creates a percentage <see cref="Dim"/> object
        /// </summary>
        /// <returns>The percent <see cref="Dim"/> object.</returns>
        /// <param name="n">A value between 0 and 100 representing the percentage.</param>
        /// <param name="r">If <c>true</c> the Percent is computed based on the remaining space after the X/Y anchor positions. If <c>false</c> is computed based on the whole original space.</param>
        /// <example>
        /// This initializes a <see cref="TextField"/>that is centered horizontally, is 50% of the way down, 
        /// is 30% the height, and is 80% the width of the <see cref="View"/> it added to.
        /// <code>
        /// var textView = new TextView () {
        ///	X = Pos.Center (),
        ///	Y = Pos.Percent (50),
        ///	Width = Dim.Percent (80),
        /// 	Height = Dim.Percent (30),
        /// };
        /// </code>
        /// </example>
        public static Dim Percent(float n, bool r = false)
        {
            if (n < 0 || n > 100)
                throw new ArgumentException("Percent value must be between 0 and 100");

            return new DimFactor(n / 100, r);
        }

        internal class DimAbsolute : Dim
        {
            int n;
            public DimAbsolute(int n) { this.n = n; }

            public override string ToString()
            {
                return $"Dim.Absolute({n})";
            }

            internal override int Anchor(int width)
            {
                return n;
            }

            public override int GetHashCode() => n.GetHashCode();

            public override bool Equals(object other) => other is DimAbsolute abs && abs.n == n;
        }

        internal class DimFill : Dim
        {
            int margin;
            public DimFill(int margin) { this.margin = margin; }

            public override string ToString()
            {
                return $"Dim.Fill(margin={margin})";
            }

            internal override int Anchor(int width)
            {
                return width - margin;
            }

            public override int GetHashCode() => margin.GetHashCode();

            public override bool Equals(object other) => other is DimFill fill && fill.margin == margin;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Dim"/> class that fills the dimension, but leaves the specified number of colums for a margin.
        /// </summary>
        /// <returns>The Fill dimension.</returns>
        /// <param name="margin">Margin to use.</param>
        public static Dim Fill(int margin = 0)
        {
            return new DimFill(margin);
        }

        /// <summary>
        /// Creates an Absolute <see cref="Dim"/> from the specified integer value.
        /// </summary>
        /// <returns>The Absolute <see cref="Dim"/>.</returns>
        /// <param name="n">The value to convert to the pos.</param>
        public static implicit operator Dim(int n)
        {
            return new DimAbsolute(n);
        }

        /// <summary>
        /// Creates an Absolute <see cref="Dim"/> from the specified integer value.
        /// </summary>
        /// <returns>The Absolute <see cref="Dim"/>.</returns>
        /// <param name="n">The value to convert to the <see cref="Dim"/>.</param>
        public static Dim Sized(int n)
        {
            return new DimAbsolute(n);
        }

        internal class DimCombine : Dim
        {
            internal Dim left, right;
            internal bool add;
            public DimCombine(bool add, Dim left, Dim right)
            {
                this.left = left;
                this.right = right;
                this.add = add;
            }

            internal override int Anchor(int width)
            {
                var la = left.Anchor(width);
                var ra = right.Anchor(width);
                if (add)
                    return la + ra;
                else
                    return la - ra;
            }

            public override string ToString()
            {
                return $"Dim.Combine({left.ToString()}{(add ? '+' : '-')}{right.ToString()})";
            }

        }

        /// <summary>
        /// Adds a <see cref="Terminal.Gui.Dim"/> to a <see cref="Terminal.Gui.Dim"/>, yielding a new <see cref="Dim"/>.
        /// </summary>
        /// <param name="left">The first <see cref="Terminal.Gui.Dim"/> to add.</param>
        /// <param name="right">The second <see cref="Terminal.Gui.Dim"/> to add.</param>
        /// <returns>The <see cref="Dim"/> that is the sum of the values of <c>left</c> and <c>right</c>.</returns>
        public static Dim operator +(Dim left, Dim right)
        {
            if (left is DimAbsolute && right is DimAbsolute)
            {
                return new DimAbsolute(left.Anchor(0) + right.Anchor(0));
            }
            DimCombine newDim = new DimCombine(true, left, right);
            SetDimCombine(left, newDim);
            return newDim;
        }

        /// <summary>
        /// Subtracts a <see cref="Terminal.Gui.Dim"/> from a <see cref="Terminal.Gui.Dim"/>, yielding a new <see cref="Dim"/>.
        /// </summary>
        /// <param name="left">The <see cref="Terminal.Gui.Dim"/> to subtract from (the minuend).</param>
        /// <param name="right">The <see cref="Terminal.Gui.Dim"/> to subtract (the subtrahend).</param>
        /// <returns>The <see cref="Dim"/> that is the <c>left</c> minus <c>right</c>.</returns>
        public static Dim operator -(Dim left, Dim right)
        {
            if (left is DimAbsolute && right is DimAbsolute)
            {
                return new DimAbsolute(left.Anchor(0) - right.Anchor(0));
            }
            DimCombine newDim = new DimCombine(false, left, right);
            SetDimCombine(left, newDim);
            return newDim;
        }

        static void SetDimCombine(Dim left, DimCombine newPos)
        {
            var view = left as DimView;
            if (view != null)
            {
                view.Target.SetNeedsLayout();
            }
        }

        internal class DimView : Dim
        {
            public View Target;
            int side;
            public DimView(View view, int side)
            {
                Target = view;
                this.side = side;
            }

            internal override int Anchor(int width)
            {
                switch (side)
                {
                    case 0: return Target.Frame.Height;
                    case 1: return Target.Frame.Width;
                    default:
                        return 0;
                }
            }

            public override string ToString()
            {
                string tside;
                switch (side)
                {
                    case 0: tside = "Height"; break;
                    case 1: tside = "Width"; break;
                    default: tside = "unknown"; break;
                }
                return $"DimView(side={tside}, target={Target.ToString()})";
            }

            public override int GetHashCode() => Target.GetHashCode();

            public override bool Equals(object other) => other is DimView abs && abs.Target == Target;
        }
        /// <summary>
        /// Returns a <see cref="Dim"/> object tracks the Width of the specified <see cref="View"/>.
        /// </summary>
        /// <returns>The <see cref="Dim"/> of the other <see cref="View"/>.</returns>
        /// <param name="view">The view that will be tracked.</param>
        public static Dim Width(View view) => new DimView(view, 1);

        /// <summary>
        /// Returns a <see cref="Dim"/> object tracks the Height of the specified <see cref="View"/>.
        /// </summary>
        /// <returns>The <see cref="Dim"/> of the other <see cref="View"/>.</returns>
        /// <param name="view">The view that will be tracked.</param>
        public static Dim Height(View view) => new DimView(view, 0);

        /// <summary>Serves as the default hash function. </summary>
        /// <returns>A hash code for the current object.</returns>
        public override int GetHashCode() => Anchor(0).GetHashCode();

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        /// <param name="other">The object to compare with the current object. </param>
        /// <returns>
        ///     <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        public override bool Equals(object other) => other is Dim abs && abs == this;
    }
    //=======================================================================
    /// <summary>
    /// Specifies the style that a <see cref="ProgressBar"/> uses to indicate the progress of an operation.
    /// </summary>
    public enum ProgressBarStyle
    {
        /// <summary>
        /// Indicates progress by increasing the number of segmented blocks in a <see cref="ProgressBar"/>.
        /// </summary>
        Blocks,
        /// <summary>
        /// Indicates progress by increasing the size of a smooth, continuous bar in a <see cref="ProgressBar"/>.
        /// </summary>
        Continuous,
        /// <summary>
        /// Indicates progress by continuously scrolling a block across a <see cref="ProgressBar"/> in a marquee fashion.
        /// </summary>
        MarqueeBlocks,
        /// <summary>
        /// Indicates progress by continuously scrolling a block across a <see cref="ProgressBar"/> in a marquee fashion.
        /// </summary>
        MarqueeContinuous

    }

    /// <summary>
    ///Specifies the format that a <see cref="ProgressBar"/> uses to indicate the visual presentation.
    /// </summary>
    public enum ProgressBarFormat
    {
        /// <summary>
        /// A simple visual presentation showing only the progress bar.
        /// </summary>
        Simple,
        /// <summary>
        /// A simple visual presentation showing the progress bar and the percentage.
        /// </summary>
        SimplePlusPercentage,
        /// <summary>
        /// A framed visual presentation showing only the progress bar.
        /// </summary>
        Framed,
        /// <summary>
        /// A framed visual presentation showing the progress bar and the percentage.
        /// </summary>
        FramedPlusPercentage,
        /// <summary>
        /// A framed visual presentation showing all with the progress bar padded.
        /// </summary>
        FramedProgressPadded
    }

    /// <summary>
    /// A Progress Bar view that can indicate progress of an activity visually.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     <see cref="ProgressBar"/> can operate in two modes, percentage mode, or
    ///     activity mode.  The progress bar starts in percentage mode and
    ///     setting the Fraction property will reflect on the UI the progress 
    ///     made so far.   Activity mode is used when the application has no 
    ///     way of knowing how much time is left, and is started when the <see cref="Pulse"/> method is called.  
    ///     Call <see cref="Pulse"/> repeatedly as progress is made.
    ///   </para>
    /// </remarks>
    public class ProgressBar : View
    {
        bool isActivity;
        int[] activityPos;
        int delta, padding;

        /// <summary>
        /// Initializes a new instance of the <see cref="ProgressBar"/> class, starts in percentage mode with an absolute position and size.
        /// </summary>
        /// <param name="rect">Rect.</param>
        public ProgressBar(Rect rect) : base(rect)
        {
            Initialize(rect);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProgressBar"/> class, starts in percentage mode and uses relative layout.
        /// </summary>
        public ProgressBar() : base()
        {
            Initialize(Rect.Empty);
        }

        void Initialize(Rect rect)
        {
            CanFocus = false;
            fraction = 0;
            ColorScheme = new ColorScheme()
            {
                Normal = Application.Driver.MakeAttribute(Color.BrightGreen, Color.Gray),
                HotNormal = Colors.Base.Normal
            };
            if (rect.IsEmpty)
            {
                Height = 1;
            }
        }

        float fraction;

        /// <summary>
        /// Gets or sets the <see cref="ProgressBar"/> fraction to display, must be a value between 0 and 1.
        /// </summary>
        /// <value>The fraction representing the progress.</value>
        public float Fraction
        {
            get => fraction;
            set
            {
                fraction = Math.Min(value, 1);
                isActivity = false;
                SetNeedsDisplay();
            }
        }

        ProgressBarStyle progressBarStyle;

        /// <summary>
        /// Gets/Sets the progress bar style based on the <see cref="Terminal.Gui.ProgressBarStyle"/>
        /// </summary>
        public ProgressBarStyle ProgressBarStyle
        {
            get => progressBarStyle;
            set
            {
                progressBarStyle = value;
                switch (value)
                {
                    case ProgressBarStyle.Blocks:
                        SegmentCharacter = Driver.BlocksMeterSegment;
                        break;
                    case ProgressBarStyle.Continuous:
                        SegmentCharacter = Driver.ContinuousMeterSegment;
                        break;
                    case ProgressBarStyle.MarqueeBlocks:
                        SegmentCharacter = Driver.BlocksMeterSegment;
                        break;
                    case ProgressBarStyle.MarqueeContinuous:
                        SegmentCharacter = Driver.ContinuousMeterSegment;
                        break;
                }
                SetNeedsDisplay();
            }
        }

        private ProgressBarFormat progressBarFormat;

        /// <summary>
        /// Specifies the format that a <see cref="ProgressBar"/> uses to indicate the visual presentation.
        /// </summary>
        public ProgressBarFormat ProgressBarFormat
        {
            get => progressBarFormat;
            set
            {
                progressBarFormat = value;
                switch (progressBarFormat)
                {
                    case ProgressBarFormat.Simple:
                        Height = 1;
                        break;
                    case ProgressBarFormat.SimplePlusPercentage:
                        Height = 2;
                        break;
                    case ProgressBarFormat.Framed:
                        Height = 3;
                        break;
                    case ProgressBarFormat.FramedPlusPercentage:
                        Height = 4;
                        break;
                    case ProgressBarFormat.FramedProgressPadded:
                        Height = 6;
                        break;
                }
                SetNeedsDisplay();
            }
        }

        private Rune segmentCharacter = Driver.BlocksMeterSegment;

        /// <summary>
        /// Segment indicator for meter views.
        /// </summary>
        public Rune SegmentCharacter
        {
            get => segmentCharacter;
            set
            {
                segmentCharacter = value;
                SetNeedsDisplay();
            }
        }

        ///<inheritdoc/>
        public override ustring Text
        {
            get => GetPercentageText();
            set
            {
                base.Text = SetPercentageText(value);
            }
        }

        private bool bidirectionalMarquee = true;

        /// <summary>
        /// Specifies if the <see cref="ProgressBarStyle.MarqueeBlocks"/> or the
        ///  <see cref="ProgressBarStyle.MarqueeContinuous"/> styles is unidirectional
        ///  or bidirectional.
        /// </summary>
        public bool BidirectionalMarquee
        {
            get => bidirectionalMarquee;
            set
            {
                bidirectionalMarquee = value;
                SetNeedsDisplay();
            }
        }

        ustring GetPercentageText()
        {
            switch (progressBarStyle)
            {
                case ProgressBarStyle.Blocks:
                case ProgressBarStyle.Continuous:
                    return $"{fraction * 100:F0}%";
                case ProgressBarStyle.MarqueeBlocks:
                case ProgressBarStyle.MarqueeContinuous:
                    break;
            }

            return base.Text;
        }

        ustring SetPercentageText(ustring value)
        {
            switch (progressBarStyle)
            {
                case ProgressBarStyle.Blocks:
                case ProgressBarStyle.Continuous:
                    return $"{fraction * 100:F0}%";
                case ProgressBarStyle.MarqueeBlocks:
                case ProgressBarStyle.MarqueeContinuous:
                    break;
            }

            return value;
        }

        /// <summary>
        /// Notifies the <see cref="ProgressBar"/> that some progress has taken place.
        /// </summary>
        /// <remarks>
        /// If the <see cref="ProgressBar"/> is percentage mode, it switches to activity
        /// mode. If is in activity mode, the marker is moved.
        /// </remarks>
        public void Pulse()
        {
            if (activityPos == null)
            {
                PopulateActivityPos();
            }
            if (!isActivity)
            {
                isActivity = true;
                delta = 1;
            }
            else
            {
                for (int i = 0; i < activityPos.Length; i++)
                {
                    activityPos[i] += delta;
                }
                int fWidth = GetFrameWidth();
                if (activityPos[activityPos.Length - 1] < 0)
                {
                    for (int i = 0; i < activityPos.Length; i++)
                    {
                        activityPos[i] = i - activityPos.Length + 2;
                    }
                    delta = 1;
                }
                else if (activityPos[0] >= fWidth)
                {
                    if (bidirectionalMarquee)
                    {
                        for (int i = 0; i < activityPos.Length; i++)
                        {
                            activityPos[i] = fWidth + i - 2;
                        }
                        delta = -1;
                    }
                    else
                    {
                        PopulateActivityPos();
                    }
                }
            }

            SetNeedsDisplay();
        }

        ///<inheritdoc/>
        public override void Redraw(Rect region)
        {
            DrawFrame();

            Driver.SetAttribute(GetNormalColor());

            int fWidth = GetFrameWidth();
            if (isActivity)
            {
                Move(padding, padding);
                for (int i = 0; i < fWidth; i++)
                    if (Array.IndexOf(activityPos, i) != -1)
                        Driver.AddRune(SegmentCharacter);
                    else
                        Driver.AddRune(' ');
            }
            else
            {
                Move(padding, padding);
                int mid = (int)(fraction * fWidth);
                int i;
                for (i = 0; i < mid & i < fWidth; i++)
                    Driver.AddRune(SegmentCharacter);
                for (; i < fWidth; i++)
                    Driver.AddRune(' ');
            }

            DrawText(fWidth);
        }

        int GetFrameWidth()
        {
            switch (progressBarFormat)
            {
                case ProgressBarFormat.Simple:
                case ProgressBarFormat.SimplePlusPercentage:
                    break;
                case ProgressBarFormat.Framed:
                case ProgressBarFormat.FramedPlusPercentage:
                    return Frame.Width - 2;
                case ProgressBarFormat.FramedProgressPadded:
                    return Frame.Width - 2 - padding;
            }

            return Frame.Width;
        }

        void DrawText(int fWidth)
        {
            switch (progressBarFormat)
            {
                case ProgressBarFormat.Simple:
                case ProgressBarFormat.Framed:
                    break;
                case ProgressBarFormat.SimplePlusPercentage:
                case ProgressBarFormat.FramedPlusPercentage:
                case ProgressBarFormat.FramedProgressPadded:
                    var tf = new TextFormatter()
                    {
                        Alignment = TextAlignment.Centered,
                        Text = Text
                    };
                    var row = padding + (progressBarFormat == ProgressBarFormat.FramedProgressPadded
                        ? 2 : 1);
                    Move(padding, row);
                    var rect = new Rect(padding, row, fWidth, Frame.Height);
                    tf?.Draw(ViewToScreen(rect), ColorScheme.HotNormal, ColorScheme.HotNormal,
                        SuperView == null ? default : SuperView.ViewToScreen(SuperView.Bounds));
                    break;
            }
        }

        void DrawFrame()
        {
            switch (progressBarFormat)
            {
                case ProgressBarFormat.Simple:
                case ProgressBarFormat.SimplePlusPercentage:
                    padding = 0;
                    break;
                case ProgressBarFormat.Framed:
                case ProgressBarFormat.FramedPlusPercentage:
                    padding = 1;
                    Application.Driver.DrawWindowFrame(ViewToScreen(Bounds), padding, padding, padding, padding, true);
                    break;
                case ProgressBarFormat.FramedProgressPadded:
                    padding = 2;
                    Application.Driver.DrawWindowFrame(ViewToScreen(Bounds), padding, padding, padding, padding + 1, true);
                    Application.Driver.DrawWindowFrame(ViewToScreen(Bounds), padding - 1, padding - 1, padding - 1, padding - 1, true);
                    break;
            }
        }

        void PopulateActivityPos()
        {
            activityPos = new int[Math.Min(Frame.Width / 3, 5)];
            for (int i = 0; i < activityPos.Length; i++)
            {
                activityPos[i] = i - activityPos.Length + 1;
            }
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }
    }
    //=======================================================================
    /// <summary>
    /// Displays a group of labels each with a selected indicator. Only one of those can be selected at a given time.
    /// </summary>
    public class RadioGroup : View
    {
        int selected = -1;
        int cursor;
        DisplayModeLayout displayMode;
        int horizontalSpace = 2;
        List<(int pos, int length)> horizontal;

        /// <summary>
        /// Initializes a new instance of the <see cref="RadioGroup"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        public RadioGroup() : this(radioLabels: new ustring[] { }) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="RadioGroup"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <param name="radioLabels">The radio labels; an array of strings that can contain hotkeys using an underscore before the letter.</param>
        /// <param name="selected">The index of the item to be selected, the value is clamped to the number of items.</param>
        public RadioGroup(ustring[] radioLabels, int selected = 0) : base()
        {
            Initialize(Rect.Empty, radioLabels, selected);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RadioGroup"/> class using <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <param name="rect">Boundaries for the radio group.</param>
        /// <param name="radioLabels">The radio labels; an array of strings that can contain hotkeys using an underscore before the letter.</param>
        /// <param name="selected">The index of item to be selected, the value is clamped to the number of items.</param>
        public RadioGroup(Rect rect, ustring[] radioLabels, int selected = 0) : base(rect)
        {
            Initialize(rect, radioLabels, selected);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RadioGroup"/> class using <see cref="LayoutStyle.Absolute"/> layout.
        /// The <see cref="View"/> frame is computed from the provided radio labels.
        /// </summary>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        /// <param name="radioLabels">The radio labels; an array of strings that can contain hotkeys using an underscore before the letter.</param>
        /// <param name="selected">The item to be selected, the value is clamped to the number of items.</param>
        public RadioGroup(int x, int y, ustring[] radioLabels, int selected = 0) :
            this(MakeRect(x, y, radioLabels != null ? radioLabels.ToList() : null), radioLabels, selected)
        { }

        void Initialize(Rect rect, ustring[] radioLabels, int selected)
        {
            if (radioLabels == null)
            {
                this.radioLabels = new List<ustring>();
            }
            else
            {
                this.radioLabels = radioLabels.ToList();
            }

            this.selected = selected;
            if (rect == Rect.Empty)
            {
                SetWidthHeight(this.radioLabels);
            }
            else
            {
                Frame = rect;
            }
            CanFocus = true;
            HotKeySpecifier = new Rune('_');

            // Things this view knows how to do
            AddCommand(Command.LineUp, () => { MoveUp(); return true; });
            AddCommand(Command.LineDown, () => { MoveDown(); return true; });
            AddCommand(Command.TopHome, () => { MoveHome(); return true; });
            AddCommand(Command.BottomEnd, () => { MoveEnd(); return true; });
            AddCommand(Command.Accept, () => { SelectItem(); return true; });

            // Default keybindings for this view
            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.CursorDown, Command.LineDown);
            AddKeyBinding(Key.Home, Command.TopHome);
            AddKeyBinding(Key.End, Command.BottomEnd);
            AddKeyBinding(Key.Space, Command.Accept);
        }

        /// <summary>
        /// Gets or sets the <see cref="DisplayModeLayout"/> for this <see cref="RadioGroup"/>.
        /// </summary>
        public DisplayModeLayout DisplayMode
        {
            get { return displayMode; }
            set
            {
                if (displayMode != value)
                {
                    displayMode = value;
                    SetWidthHeight(radioLabels);
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Gets or sets the horizontal space for this <see cref="RadioGroup"/> if the <see cref="DisplayMode"/> is <see cref="DisplayModeLayout.Horizontal"/>
        /// </summary>
        public int HorizontalSpace
        {
            get { return horizontalSpace; }
            set
            {
                if (horizontalSpace != value && displayMode == DisplayModeLayout.Horizontal)
                {
                    horizontalSpace = value;
                    SetWidthHeight(radioLabels);
                    UpdateTextFormatterText();
                    SetNeedsDisplay();
                }
            }
        }

        void SetWidthHeight(List<ustring> radioLabels)
        {
            switch (displayMode)
            {
                case DisplayModeLayout.Vertical:
                    var r = MakeRect(0, 0, radioLabels);
                    if (IsAdded && LayoutStyle == LayoutStyle.Computed)
                    {
                        Width = r.Width;
                        Height = radioLabels.Count;
                    }
                    else
                    {
                        Frame = new Rect(Frame.Location, new Size(r.Width, radioLabels.Count));
                    }
                    break;
                case DisplayModeLayout.Horizontal:
                    CalculateHorizontalPositions();
                    var length = 0;
                    foreach (var item in horizontal)
                    {
                        length += item.length;
                    }
                    var hr = new Rect(0, 0, length, 1);
                    if (IsAdded && LayoutStyle == LayoutStyle.Computed)
                    {
                        Width = hr.Width;
                        Height = 1;
                    }
                    else
                    {
                        Frame = new Rect(Frame.Location, new Size(hr.Width, radioLabels.Count));
                    }
                    break;
            }
        }

        static Rect MakeRect(int x, int y, List<ustring> radioLabels)
        {
            if (radioLabels == null)
            {
                return new Rect(x, y, 0, 0);
            }

            int width = 0;

            foreach (var s in radioLabels)
                width = Math.Max(s.ConsoleWidth + 3, width);
            return new Rect(x, y, width, radioLabels.Count);
        }

        List<ustring> radioLabels = new List<ustring>();

        /// <summary>
        /// The radio labels to display
        /// </summary>
        /// <value>The radio labels.</value>
        public ustring[] RadioLabels
        {
            get => radioLabels.ToArray();
            set
            {
                var prevCount = radioLabels.Count;
                radioLabels = value.ToList();
                if (prevCount != radioLabels.Count)
                {
                    SetWidthHeight(radioLabels);
                }
                SelectedItem = 0;
                cursor = 0;
                SetNeedsDisplay();
            }
        }

        private void CalculateHorizontalPositions()
        {
            if (displayMode == DisplayModeLayout.Horizontal)
            {
                horizontal = new List<(int pos, int length)>();
                int start = 0;
                int length = 0;
                for (int i = 0; i < radioLabels.Count; i++)
                {
                    start += length;
                    length = radioLabels[i].ConsoleWidth + 2 + (i < radioLabels.Count - 1 ? horizontalSpace : 0);
                    horizontal.Add((start, length));
                }
            }
        }

        //// Redraws the RadioGroup 
        //void Update(List<ustring> newRadioLabels)
        //{
        //	for (int i = 0; i < radioLabels.Count; i++) {
        //		Move(0, i);
        //		Driver.SetAttribute(ColorScheme.Normal);
        //		Driver.AddStr(ustring.Make(new string (' ', radioLabels[i].ConsoleWidth + 4)));
        //	}
        //	if (newRadioLabels.Count != radioLabels.Count) {
        //		SetWidthHeight(newRadioLabels);
        //	}
        //}

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            Driver.SetAttribute(GetNormalColor());
            Clear();
            for (int i = 0; i < radioLabels.Count; i++)
            {
                switch (DisplayMode)
                {
                    case DisplayModeLayout.Vertical:
                        Move(0, i);
                        break;
                    case DisplayModeLayout.Horizontal:
                        Move(horizontal[i].pos, 0);
                        break;
                }
                var rl = radioLabels[i];
                Driver.SetAttribute(GetNormalColor());
                Driver.AddStr(ustring.Make(new Rune[] { i == selected ? Driver.Selected : Driver.UnSelected, ' ' }));
                TextFormatter.FindHotKey(rl, HotKeySpecifier, true, out int hotPos, out Key hotKey);
                if (hotPos != -1 && (hotKey != Key.Null || hotKey != Key.Unknown))
                {
                    var rlRunes = rl.ToRunes();
                    for (int j = 0; j < rlRunes.Length; j++)
                    {
                        Rune rune = rlRunes[j];
                        if (j == hotPos && i == cursor)
                        {
                            Application.Driver.SetAttribute(HasFocus ? ColorScheme.HotFocus : GetHotNormalColor());
                        }
                        else if (j == hotPos && i != cursor)
                        {
                            Application.Driver.SetAttribute(GetHotNormalColor());
                        }
                        else if (HasFocus && i == cursor)
                        {
                            Application.Driver.SetAttribute(ColorScheme.Focus);
                        }
                        if (rune == HotKeySpecifier && j + 1 < rlRunes.Length)
                        {
                            j++;
                            rune = rlRunes[j];
                            if (i == cursor)
                            {
                                Application.Driver.SetAttribute(HasFocus ? ColorScheme.HotFocus : GetHotNormalColor());
                            }
                            else if (i != cursor)
                            {
                                Application.Driver.SetAttribute(GetHotNormalColor());
                            }
                        }
                        Application.Driver.AddRune(rune);
                        Driver.SetAttribute(GetNormalColor());
                    }
                }
                else
                {
                    DrawHotString(rl, HasFocus && i == cursor, ColorScheme);
                }
            }
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            switch (DisplayMode)
            {
                case DisplayModeLayout.Vertical:
                    Move(0, cursor);
                    break;
                case DisplayModeLayout.Horizontal:
                    Move(horizontal[cursor].pos, 0);
                    break;
            }
        }

        /// <summary>
        /// Invoked when the selected radio label has changed.
        /// </summary>
        public event Action<SelectedItemChangedArgs> SelectedItemChanged;

        /// <summary>
        /// The currently selected item from the list of radio labels
        /// </summary>
        /// <value>The selected.</value>
        public int SelectedItem
        {
            get => selected;
            set
            {
                OnSelectedItemChanged(value, SelectedItem);
                cursor = selected;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Allow to invoke the <see cref="SelectedItemChanged"/> after their creation.
        /// </summary>
        public void Refresh()
        {
            OnSelectedItemChanged(selected, -1);
        }

        /// <summary>
        /// Called whenever the current selected item changes. Invokes the <see cref="SelectedItemChanged"/> event.
        /// </summary>
        /// <param name="selectedItem"></param>
        /// <param name="previousSelectedItem"></param>
        public virtual void OnSelectedItemChanged(int selectedItem, int previousSelectedItem)
        {
            selected = selectedItem;
            SelectedItemChanged?.Invoke(new SelectedItemChangedArgs(selectedItem, previousSelectedItem));
        }

        ///<inheritdoc/>
        public override bool ProcessColdKey(KeyEvent kb)
        {
            var key = kb.KeyValue;
            if (key < Char.MaxValue && Char.IsLetterOrDigit((char)key))
            {
                int i = 0;
                key = Char.ToUpper((char)key);
                foreach (var l in radioLabels)
                {
                    bool nextIsHot = false;
                    TextFormatter.FindHotKey(l, HotKeySpecifier, true, out _, out Key hotKey);
                    foreach (Rune c in l)
                    {
                        if (c == HotKeySpecifier)
                        {
                            nextIsHot = true;
                        }
                        else
                        {
                            if ((nextIsHot && Rune.ToUpper(c) == key) || (key == (uint)hotKey))
                            {
                                SelectedItem = i;
                                cursor = i;
                                if (!HasFocus)
                                    SetFocus();
                                return true;
                            }
                            nextIsHot = false;
                        }
                    }
                    i++;
                }
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            return base.ProcessKey(kb);
        }

        void SelectItem()
        {
            SelectedItem = cursor;
        }

        void MoveEnd()
        {
            cursor = Math.Max(radioLabels.Count - 1, 0);
        }

        void MoveHome()
        {
            cursor = 0;
        }

        void MoveDown()
        {
            if (cursor + 1 < radioLabels.Count)
            {
                cursor++;
                SetNeedsDisplay();
            }
            else if (cursor > 0)
            {
                cursor = 0;
                SetNeedsDisplay();
            }
        }

        void MoveUp()
        {
            if (cursor > 0)
            {
                cursor--;
                SetNeedsDisplay();
            }
            else if (radioLabels.Count - 1 > 0)
            {
                cursor = radioLabels.Count - 1;
                SetNeedsDisplay();
            }
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked))
            {
                return false;
            }
            if (!CanFocus)
            {
                return false;
            }
            SetFocus();

            var pos = displayMode == DisplayModeLayout.Horizontal ? me.X : me.Y;
            var rCount = displayMode == DisplayModeLayout.Horizontal ? horizontal.Last().pos + horizontal.Last().length : radioLabels.Count;

            if (pos < rCount)
            {
                var c = displayMode == DisplayModeLayout.Horizontal ? horizontal.FindIndex((x) => x.pos <= me.X && x.pos + x.length - 2 >= me.X) : me.Y;
                if (c > -1)
                {
                    cursor = SelectedItem = c;
                    SetNeedsDisplay();
                }
            }
            return true;
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }
    }

    /// <summary>
    /// Used for choose the display mode of this <see cref="RadioGroup"/>
    /// </summary>
    public enum DisplayModeLayout
    {
        /// <summary>
        /// Vertical mode display. It's the default.
        /// </summary>
        Vertical,
        /// <summary>
        /// Horizontal mode display.
        /// </summary>
        Horizontal
    }

    /// <summary>
    /// Event arguments for the SelectedItemChagned event.
    /// </summary>
    public class SelectedItemChangedArgs : EventArgs
    {
        /// <summary>
        /// Gets the index of the item that was previously selected. -1 if there was no previous selection.
        /// </summary>
        public int PreviousSelectedItem { get; }

        /// <summary>
        /// Gets the index of the item that is now selected. -1 if there is no selection.
        /// </summary>
        public int SelectedItem { get; }

        /// <summary>
        /// Initializes a new <see cref="SelectedItemChangedArgs"/> class.
        /// </summary>
        /// <param name="selectedItem"></param>
        /// <param name="previousSelectedItem"></param>
        public SelectedItemChangedArgs(int selectedItem, int previousSelectedItem)
        {
            PreviousSelectedItem = previousSelectedItem;
            SelectedItem = selectedItem;
        }
    }
    //=======================================================================
    static class ReadOnlyCollectionExtensions
    {

        public static int IndexOf<T>(this IReadOnlyCollection<T> self, Func<T, bool> predicate)
        {
            int i = 0;
            foreach (T element in self)
            {
                if (predicate(element))
                    return i;
                i++;
            }
            return -1;
        }
        public static int IndexOf<T>(this IReadOnlyCollection<T> self, T toFind)
        {
            int i = 0;
            foreach (T element in self)
            {
                if (Equals(element, toFind))
                    return i;
                i++;
            }
            return -1;
        }
    }
    //=======================================================================
    //
    // System.Drawing.Rectangle.cs
    //
    // Author:
    //   Mike Kestner (mkestner@speakeasy.net)
    //
    // Copyright (C) 2001 Mike Kestner
    // Copyright (C) 2004 Novell, Inc.  http://www.novell.com 
    //

    /// <summary>
    /// Stores a set of four integers that represent the location and size of a rectangle
    /// </summary>
    public struct Rect
    {
        int width;
        int height;

        /// <summary>
        /// Gets or sets the x-coordinate of the upper-left corner of this Rectangle structure.
        /// </summary>
        public int X;
        /// <summary>
        /// Gets or sets the y-coordinate of the upper-left corner of this Rectangle structure.
        /// </summary>
        public int Y;

        /// <summary>
        /// Gets or sets the width of this Rect structure.
        /// </summary>
        public int Width
        {
            get { return width; }
            set
            {
                if (value < 0)
                    throw new ArgumentException("Width must be greater or equal to 0.");
                width = value;
            }
        }

        /// <summary>
        /// Gets or sets the height of this Rectangle structure.
        /// </summary>
        public int Height
        {
            get { return height; }
            set
            {
                if (value < 0)
                    throw new ArgumentException("Height must be greater or equal to 0.");
                height = value;
            }
        }

        /// <summary>
        ///	Empty Shared Field
        /// </summary>
        ///
        /// <remarks>
        ///	An uninitialized Rectangle Structure.
        /// </remarks>

        public static readonly Rect Empty;

        /// <summary>
        ///	FromLTRB Shared Method
        /// </summary>
        ///
        /// <remarks>
        ///	Produces a Rectangle structure from left, top, right
        ///	and bottom coordinates.
        /// </remarks>

        public static Rect FromLTRB(int left, int top,
                          int right, int bottom)
        {
            return new Rect(left, top, right - left,
                          bottom - top);
        }

        /// <summary>
        ///	Inflate Shared Method
        /// </summary>
        ///
        /// <remarks>
        ///	Produces a new Rectangle by inflating an existing 
        ///	Rectangle by the specified coordinate values.
        /// </remarks>

        public static Rect Inflate(Rect rect, int x, int y)
        {
            Rect r = new Rect(rect.Location, rect.Size);
            r.Inflate(x, y);
            return r;
        }

        /// <summary>
        ///	Inflate Method
        /// </summary>
        ///
        /// <remarks>
        ///	Inflates the Rectangle by a specified width and height.
        /// </remarks>

        public void Inflate(int width, int height)
        {
            Inflate(new Size(width, height));
        }

        /// <summary>
        ///	Inflate Method
        /// </summary>
        ///
        /// <remarks>
        ///	Inflates the Rectangle by a specified Size.
        /// </remarks>

        public void Inflate(Size size)
        {
            X -= size.Width;
            Y -= size.Height;
            Width += size.Width * 2;
            Height += size.Height * 2;
        }

        /// <summary>
        ///	Intersect Shared Method
        /// </summary>
        ///
        /// <remarks>
        ///	Produces a new Rectangle by intersecting 2 existing 
        ///	Rectangles. Returns null if there is no	intersection.
        /// </remarks>

        public static Rect Intersect(Rect a, Rect b)
        {
            // MS.NET returns a non-empty rectangle if the two rectangles
            // touch each other
            if (!a.IntersectsWithInclusive(b))
                return Empty;

            return Rect.FromLTRB(
                Math.Max(a.Left, b.Left),
                Math.Max(a.Top, b.Top),
                Math.Min(a.Right, b.Right),
                Math.Min(a.Bottom, b.Bottom));
        }

        /// <summary>
        ///	Intersect Method
        /// </summary>
        ///
        /// <remarks>
        ///	Replaces the Rectangle with the intersection of itself
        ///	and another Rectangle.
        /// </remarks>

        public void Intersect(Rect rect)
        {
            this = Rect.Intersect(this, rect);
        }

        /// <summary>
        ///	Union Shared Method
        /// </summary>
        ///
        /// <remarks>
        ///	Produces a new Rectangle from the union of 2 existing 
        ///	Rectangles.
        /// </remarks>

        public static Rect Union(Rect a, Rect b)
        {
            return FromLTRB(Math.Min(a.Left, b.Left),
                     Math.Min(a.Top, b.Top),
                     Math.Max(a.Right, b.Right),
                     Math.Max(a.Bottom, b.Bottom));
        }

        /// <summary>
        ///	Equality Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Compares two Rectangle objects. The return value is
        ///	based on the equivalence of the Location and Size 
        ///	properties of the two Rectangles.
        /// </remarks>

        public static bool operator ==(Rect left, Rect right)
        {
            return ((left.Location == right.Location) &&
                (left.Size == right.Size));
        }

        /// <summary>
        ///	Inequality Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Compares two Rectangle objects. The return value is
        ///	based on the equivalence of the Location and Size 
        ///	properties of the two Rectangles.
        /// </remarks>

        public static bool operator !=(Rect left, Rect right)
        {
            return ((left.Location != right.Location) ||
                (left.Size != right.Size));
        }

        // -----------------------
        // Public Constructors
        // -----------------------

        /// <summary>
        ///	Rectangle Constructor
        /// </summary>
        ///
        /// <remarks>
        ///	Creates a Rectangle from Point and Size values.
        /// </remarks>

        public Rect(Point location, Size size)
        {
            X = location.X;
            Y = location.Y;
            width = size.Width;
            height = size.Height;
            Width = width;
            Height = height;
        }

        /// <summary>
        ///	Rectangle Constructor
        /// </summary>
        ///
        /// <remarks>
        ///	Creates a Rectangle from a specified x,y location and
        ///	width and height values.
        /// </remarks>

        public Rect(int x, int y, int width, int height)
        {
            X = x;
            Y = y;
            this.width = width;
            this.height = height;
            Width = this.width;
            Height = this.height;
        }



        /// <summary>
        ///	Bottom Property
        /// </summary>
        ///
        /// <remarks>
        ///	The Y coordinate of the bottom edge of the Rectangle.
        ///	Read only.
        /// </remarks>		
        public int Bottom
        {
            get
            {
                return Y + Height;
            }
        }

        /// <summary>
        ///	IsEmpty Property
        /// </summary>
        ///
        /// <remarks>
        ///	Indicates if the width or height are zero. Read only.
        /// </remarks>		
        public bool IsEmpty
        {
            get
            {
                return ((X == 0) && (Y == 0) && (Width == 0) && (Height == 0));
            }
        }

        /// <summary>
        ///	Left Property
        /// </summary>
        ///
        /// <remarks>
        ///	The X coordinate of the left edge of the Rectangle.
        ///	Read only.
        /// </remarks>

        public int Left
        {
            get
            {
                return X;
            }
        }

        /// <summary>
        ///	Location Property
        /// </summary>
        ///
        /// <remarks>
        ///	The Location of the top-left corner of the Rectangle.
        /// </remarks>

        public Point Location
        {
            get
            {
                return new Point(X, Y);
            }
            set
            {
                X = value.X;
                Y = value.Y;
            }
        }

        /// <summary>
        ///	Right Property
        /// </summary>
        ///
        /// <remarks>
        ///	The X coordinate of the right edge of the Rectangle.
        ///	Read only.
        /// </remarks>

        public int Right
        {
            get
            {
                return X + Width;
            }
        }

        /// <summary>
        ///	Size Property
        /// </summary>
        ///
        /// <remarks>
        ///	The Size of the Rectangle.
        /// </remarks>

        public Size Size
        {
            get
            {
                return new Size(Width, Height);
            }
            set
            {
                Width = value.Width;
                Height = value.Height;
            }
        }

        /// <summary>
        ///	Top Property
        /// </summary>
        ///
        /// <remarks>
        ///	The Y coordinate of the top edge of the Rectangle.
        ///	Read only.
        /// </remarks>

        public int Top
        {
            get
            {
                return Y;
            }
        }

        /// <summary>
        ///	Contains Method
        /// </summary>
        ///
        /// <remarks>
        ///	Checks if an x,y coordinate lies within this Rectangle.
        /// </remarks>

        public bool Contains(int x, int y)
        {
            return ((x >= Left) && (x < Right) &&
                (y >= Top) && (y < Bottom));
        }

        /// <summary>
        ///	Contains Method
        /// </summary>
        ///
        /// <remarks>
        ///	Checks if a Point lies within this Rectangle.
        /// </remarks>

        public bool Contains(Point pt)
        {
            return Contains(pt.X, pt.Y);
        }

        /// <summary>
        ///	Contains Method
        /// </summary>
        ///
        /// <remarks>
        ///	Checks if a Rectangle lies entirely within this 
        ///	Rectangle.
        /// </remarks>

        public bool Contains(Rect rect)
        {
            return (rect == Intersect(this, rect));
        }

        /// <summary>
        ///	Equals Method
        /// </summary>
        ///
        /// <remarks>
        ///	Checks equivalence of this Rectangle and another object.
        /// </remarks>

        public override bool Equals(object obj)
        {
            if (!(obj is Rect))
                return false;

            return (this == (Rect)obj);
        }

        /// <summary>
        ///	GetHashCode Method
        /// </summary>
        ///
        /// <remarks>
        ///	Calculates a hashing value.
        /// </remarks>

        public override int GetHashCode()
        {
            return (Height + Width) ^ X + Y;
        }

        /// <summary>
        ///	IntersectsWith Method
        /// </summary>
        ///
        /// <remarks>
        ///	Checks if a Rectangle intersects with this one.
        /// </remarks>

        public bool IntersectsWith(Rect rect)
        {
            return !((Left >= rect.Right) || (Right <= rect.Left) ||
                (Top >= rect.Bottom) || (Bottom <= rect.Top));
        }

        bool IntersectsWithInclusive(Rect r)
        {
            return !((Left > r.Right) || (Right < r.Left) ||
                (Top > r.Bottom) || (Bottom < r.Top));
        }

        /// <summary>
        ///	Offset Method
        /// </summary>
        ///
        /// <remarks>
        ///	Moves the Rectangle a specified distance.
        /// </remarks>

        public void Offset(int x, int y)
        {
            this.X += x;
            this.Y += y;
        }

        /// <summary>
        ///	Offset Method
        /// </summary>
        ///
        /// <remarks>
        ///	Moves the Rectangle a specified distance.
        /// </remarks>

        public void Offset(Point pos)
        {
            X += pos.X;
            Y += pos.Y;
        }

        /// <summary>
        ///	ToString Method
        /// </summary>
        ///
        /// <remarks>
        ///	Formats the Rectangle as a string in (x,y,w,h) notation.
        /// </remarks>

        public override string ToString()
        {
            return String.Format("{{X={0},Y={1},Width={2},Height={3}}}",
                         X, Y, Width, Height);
        }

    }
    //=======================================================================
    // Licensed to the .NET Foundation under one or more agreements.
    // The .NET Foundation licenses this file to you under the MIT license.
    // See the LICENSE file in the project root for more information.

    // Copied from https://github.com/dotnet/corefx/tree/master/src/System.Drawing.Primitives/src/System/Drawing

    /// <summary>
    /// Stores the location and size of a rectangular region.
    /// </summary>
    public struct RectangleF : IEquatable<RectangleF>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.RectangleF'/> class.
        /// </summary>
        public static readonly RectangleF Empty;

        private float x; // Do not rename (binary serialization)
        private float y; // Do not rename (binary serialization)
        private float width; // Do not rename (binary serialization)
        private float height; // Do not rename (binary serialization)

        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.RectangleF'/> class with the specified location
        /// and size.
        /// </summary>
        public RectangleF(float x, float y, float width, float height)
        {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.RectangleF'/> class with the specified location
        /// and size.
        /// </summary>
        public RectangleF(PointF location, SizeF size)
        {
            x = location.X;
            y = location.Y;
            width = size.Width;
            height = size.Height;
        }

        /// <summary>
        /// Creates a new <see cref='Terminal.Gui.RectangleF'/> with the specified location and size.
        /// </summary>
        public static RectangleF FromLTRB(float left, float top, float right, float bottom) =>
            new RectangleF(left, top, right - left, bottom - top);

        /// <summary>
        /// Gets or sets the coordinates of the upper-left corner of the rectangular region represented by this
        /// <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        [Browsable(false)]
        public PointF Location
        {
            get => new PointF(X, Y);
            set
            {
                X = value.X;
                Y = value.Y;
            }
        }

        /// <summary>
        /// Gets or sets the size of this <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        [Browsable(false)]
        public SizeF Size
        {
            get => new SizeF(Width, Height);
            set
            {
                Width = value.Width;
                Height = value.Height;
            }
        }

        /// <summary>
        /// Gets or sets the x-coordinate of the upper-left corner of the rectangular region defined by this
        /// <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        public float X
        {
            get => x;
            set => x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of the upper-left corner of the rectangular region defined by this
        /// <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        public float Y
        {
            get => y;
            set => y = value;
        }

        /// <summary>
        /// Gets or sets the width of the rectangular region defined by this <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        public float Width
        {
            get => width;
            set => width = value;
        }

        /// <summary>
        /// Gets or sets the height of the rectangular region defined by this <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        public float Height
        {
            get => height;
            set => height = value;
        }

        /// <summary>
        /// Gets the x-coordinate of the upper-left corner of the rectangular region defined by this
        /// <see cref='Terminal.Gui.RectangleF'/> .
        /// </summary>
        [Browsable(false)]
        public float Left => X;

        /// <summary>
        /// Gets the y-coordinate of the upper-left corner of the rectangular region defined by this
        /// <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        [Browsable(false)]
        public float Top => Y;

        /// <summary>
        /// Gets the x-coordinate of the lower-right corner of the rectangular region defined by this
        /// <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        [Browsable(false)]
        public float Right => X + Width;

        /// <summary>
        /// Gets the y-coordinate of the lower-right corner of the rectangular region defined by this
        /// <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        [Browsable(false)]
        public float Bottom => Y + Height;

        /// <summary>
        /// Tests whether this <see cref='Terminal.Gui.RectangleF'/> has a <see cref='Terminal.Gui.RectangleF.Width'/> or a <see cref='Terminal.Gui.RectangleF.Height'/> of 0.
        /// </summary>
        [Browsable(false)]
        public bool IsEmpty => (Width <= 0) || (Height <= 0);

        /// <summary>
        /// Tests whether <paramref name="obj"/> is a <see cref='Terminal.Gui.RectangleF'/> with the same location and
        /// size of this <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        public override bool Equals(object obj) => obj is RectangleF && Equals((RectangleF)obj);

        /// <summary>
        /// Returns true if two <see cref='Terminal.Gui.RectangleF'/> objects have equal location and size.
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(RectangleF other) => this == other;

        /// <summary>
        /// Tests whether two <see cref='Terminal.Gui.RectangleF'/> objects have equal location and size.
        /// </summary>
        public static bool operator ==(RectangleF left, RectangleF right) =>
            left.X == right.X && left.Y == right.Y && left.Width == right.Width && left.Height == right.Height;

        /// <summary>
        /// Tests whether two <see cref='Terminal.Gui.RectangleF'/> objects differ in location or size.
        /// </summary>
        public static bool operator !=(RectangleF left, RectangleF right) => !(left == right);

        /// <summary>
        /// Determines if the specified point is contained within the rectangular region defined by this
        /// <see cref='Terminal.Gui.Rect'/> .
        /// </summary>
        public bool Contains(float x, float y) => X <= x && x < X + Width && Y <= y && y < Y + Height;

        /// <summary>
        /// Determines if the specified point is contained within the rectangular region defined by this
        /// <see cref='Terminal.Gui.Rect'/> .
        /// </summary>
        public bool Contains(PointF pt) => Contains(pt.X, pt.Y);

        /// <summary>
        /// Determines if the rectangular region represented by <paramref name="rect"/> is entirely contained within
        /// the rectangular region represented by this <see cref='Terminal.Gui.Rect'/> .
        /// </summary>
        public bool Contains(RectangleF rect) =>
            (X <= rect.X) && (rect.X + rect.Width <= X + Width) && (Y <= rect.Y) && (rect.Y + rect.Height <= Y + Height);

        /// <summary>
        /// Gets the hash code for this <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        public override int GetHashCode()
        {
            return (Height.GetHashCode() + Width.GetHashCode()) ^ X.GetHashCode() + Y.GetHashCode();
        }

        /// <summary>
        /// Inflates this <see cref='Terminal.Gui.Rect'/> by the specified amount.
        /// </summary>
        public void Inflate(float x, float y)
        {
            X -= x;
            Y -= y;
            Width += 2 * x;
            Height += 2 * y;
        }

        /// <summary>
        /// Inflates this <see cref='Terminal.Gui.Rect'/> by the specified amount.
        /// </summary>
        public void Inflate(SizeF size) => Inflate(size.Width, size.Height);

        /// <summary>
        /// Creates a <see cref='Terminal.Gui.Rect'/> that is inflated by the specified amount.
        /// </summary>
        public static RectangleF Inflate(RectangleF rect, float x, float y)
        {
            RectangleF r = rect;
            r.Inflate(x, y);
            return r;
        }

        /// <summary>
        /// Creates a Rectangle that represents the intersection between this Rectangle and rect.
        /// </summary>
        public void Intersect(RectangleF rect)
        {
            RectangleF result = Intersect(rect, this);

            X = result.X;
            Y = result.Y;
            Width = result.Width;
            Height = result.Height;
        }

        /// <summary>
        /// Creates a rectangle that represents the intersection between a and b. If there is no intersection, an
        /// empty rectangle is returned.
        /// </summary>
        public static RectangleF Intersect(RectangleF a, RectangleF b)
        {
            float x1 = Math.Max(a.X, b.X);
            float x2 = Math.Min(a.X + a.Width, b.X + b.Width);
            float y1 = Math.Max(a.Y, b.Y);
            float y2 = Math.Min(a.Y + a.Height, b.Y + b.Height);

            if (x2 >= x1 && y2 >= y1)
            {
                return new RectangleF(x1, y1, x2 - x1, y2 - y1);
            }

            return Empty;
        }

        /// <summary>
        /// Determines if this rectangle intersects with rect.
        /// </summary>
        public bool IntersectsWith(RectangleF rect) =>
            (rect.X < X + Width) && (X < rect.X + rect.Width) && (rect.Y < Y + Height) && (Y < rect.Y + rect.Height);

        /// <summary>
        /// Creates a rectangle that represents the union between a and b.
        /// </summary>
        public static RectangleF Union(RectangleF a, RectangleF b)
        {
            float x1 = Math.Min(a.X, b.X);
            float x2 = Math.Max(a.X + a.Width, b.X + b.Width);
            float y1 = Math.Min(a.Y, b.Y);
            float y2 = Math.Max(a.Y + a.Height, b.Y + b.Height);

            return new RectangleF(x1, y1, x2 - x1, y2 - y1);
        }

        /// <summary>
        /// Adjusts the location of this rectangle by the specified amount.
        /// </summary>
        public void Offset(PointF pos) => Offset(pos.X, pos.Y);

        /// <summary>
        /// Adjusts the location of this rectangle by the specified amount.
        /// </summary>
        public void Offset(float x, float y)
        {
            X += x;
            Y += y;
        }

        /// <summary>
        /// Converts the specified <see cref='Terminal.Gui.Rect'/> to a
        /// <see cref='Terminal.Gui.RectangleF'/>.
        /// </summary>
        public static implicit operator RectangleF(Rect r) => new RectangleF(r.X, r.Y, r.Width, r.Height);

        /// <summary>
        /// Converts the <see cref='Terminal.Gui.RectangleF.Location'/> and <see cref='Terminal.Gui.RectangleF.Size'/>
        /// of this <see cref='Terminal.Gui.RectangleF'/> to a human-readable string.
        /// </summary>
        public override string ToString() =>
            "{X=" + X.ToString() + ",Y=" + Y.ToString() +
            ",Width=" + Width.ToString() + ",Height=" + Height.ToString() + "}";
    }
    //=======================================================================
    //
    // Core.cs: The core engine for gui.cs
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //
    // Pending:
    //   - Check for NeedDisplay on the hierarchy and repaint
    //   - Layout support
    //   - "Colors" type or "Attributes" type?
    //   - What to surface as "BackgroundCOlor" when clearing a window, an attribute or colors?
    //
    // Optimziations
    //   - Add rendering limitation to the exposed area

    /// <summary>
    /// Responder base class implemented by objects that want to participate on keyboard and mouse input.
    /// </summary>
    public class Responder : IDisposable
    {
        bool disposedValue;

#if DEBUG_IDISPOSABLE
		/// <summary>
		/// For debug purposes to verify objects are being disposed properly
		/// </summary>
		public bool WasDisposed = false;
		/// <summary>
		/// For debug purposes to verify objects are being disposed properly
		/// </summary>
		public int DisposedCount = 0;
		/// <summary>
		/// For debug purposes
		/// </summary>
		public static List<Responder> Instances = new List<Responder> ();
		/// <summary>
		/// For debug purposes
		/// </summary>
		public Responder ()
		{
			Instances.Add (this);
		}
#endif

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="Responder"/> can focus.
        /// </summary>
        /// <value><c>true</c> if can focus; otherwise, <c>false</c>.</value>
        public virtual bool CanFocus { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="Responder"/> has focus.
        /// </summary>
        /// <value><c>true</c> if has focus; otherwise, <c>false</c>.</value>
        public virtual bool HasFocus { get; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="Responder"/> can respond to user interaction.
        /// </summary>
        public virtual bool Enabled { get; set; } = true;

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="Responder"/> and all its child controls are displayed.
        /// </summary>
        public virtual bool Visible { get; set; } = true;

        // Key handling
        /// <summary>
        ///   This method can be overwritten by view that
        ///     want to provide accelerator functionality
        ///     (Alt-key for example).
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Before keys are sent to the subview on the
        ///     current view, all the views are
        ///     processed and the key is passed to the widgets
        ///     to allow some of them to process the keystroke
        ///     as a hot-key. </para>
        ///  <para>
        ///     For example, if you implement a button that
        ///     has a hotkey ok "o", you would catch the
        ///     combination Alt-o here.  If the event is
        ///     caught, you must return true to stop the
        ///     keystroke from being dispatched to other
        ///     views.
        ///  </para>
        /// </remarks>

        public virtual bool ProcessHotKey(KeyEvent kb)
        {
            return false;
        }

        /// <summary>
        ///   If the view is focused, gives the view a
        ///   chance to process the keystroke.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Views can override this method if they are
        ///     interested in processing the given keystroke.
        ///     If they consume the keystroke, they must
        ///     return true to stop the keystroke from being
        ///     processed by other widgets or consumed by the
        ///     widget engine.    If they return false, the
        ///     keystroke will be passed using the ProcessColdKey
        ///     method to other views to process.
        ///   </para>
        ///   <para>
        ///     The View implementation does nothing but return false,
        ///     so it is not necessary to call base.ProcessKey if you
        ///     derive directly from View, but you should if you derive
        ///     other View subclasses.
        ///   </para>
        /// </remarks>
        /// <param name="keyEvent">Contains the details about the key that produced the event.</param>
        public virtual bool ProcessKey(KeyEvent keyEvent)
        {
            return false;
        }

        /// <summary>
        ///   This method can be overwritten by views that
        ///     want to provide accelerator functionality
        ///     (Alt-key for example), but without
        ///     interefering with normal ProcessKey behavior.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     After keys are sent to the subviews on the
        ///     current view, all the view are
        ///     processed and the key is passed to the views
        ///     to allow some of them to process the keystroke
        ///     as a cold-key. </para>
        ///  <para>
        ///    This functionality is used, for example, by
        ///    default buttons to act on the enter key.
        ///    Processing this as a hot-key would prevent
        ///    non-default buttons from consuming the enter
        ///    keypress when they have the focus.
        ///  </para>
        /// </remarks>
        /// <param name="keyEvent">Contains the details about the key that produced the event.</param>
        public virtual bool ProcessColdKey(KeyEvent keyEvent)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when a key is pressed.
        /// </summary>
        /// <param name="keyEvent">Contains the details about the key that produced the event.</param>
        /// <returns>true if the event was handled</returns>
        public virtual bool OnKeyDown(KeyEvent keyEvent)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when a key is released.
        /// </summary>
        /// <param name="keyEvent">Contains the details about the key that produced the event.</param>
        /// <returns>true if the event was handled</returns>
        public virtual bool OnKeyUp(KeyEvent keyEvent)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when a mouse event is generated
        /// </summary>
        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
        /// <param name="mouseEvent">Contains the details about the mouse event.</param>
        public virtual bool MouseEvent(MouseEvent mouseEvent)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when a mouse event is generated for the first time.
        /// </summary>
        /// <param name="mouseEvent"></param>
        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
        public virtual bool OnMouseEnter(MouseEvent mouseEvent)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when a mouse event is generated for the last time.
        /// </summary>
        /// <param name="mouseEvent"></param>
        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
        public virtual bool OnMouseLeave(MouseEvent mouseEvent)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when a view gets focus.
        /// </summary>
        /// <param name="view">The view that is losing focus.</param>
        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
        public virtual bool OnEnter(View view)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when a view loses focus.
        /// </summary>
        /// <param name="view">The view that is getting focus.</param>
        /// <returns><c>true</c>, if the event was handled, <c>false</c> otherwise.</returns>
        public virtual bool OnLeave(View view)
        {
            return false;
        }

        /// <summary>
        /// Method invoked when the <see cref="CanFocus"/> property from a view is changed.
        /// </summary>
        public virtual void OnCanFocusChanged() { }

        /// <summary>
        /// Method invoked when the <see cref="Enabled"/> property from a view is changed.
        /// </summary>
        public virtual void OnEnabledChanged() { }

        /// <summary>
        /// Method invoked when the <see cref="Visible"/> property from a view is changed.
        /// </summary>
        public virtual void OnVisibleChanged() { }

        /// <summary>
        /// Utilty function to determine <paramref name="method"/> is overridden in the <paramref name="subclass"/>.
        /// </summary>
        /// <param name="subclass">The view.</param>
        /// <param name="method">The method name.</param>
        /// <returns><see langword="true"/> if it's overridden, <see langword="false"/> otherwise.</returns>
        internal static bool IsOverridden(Responder subclass, string method)
        {
            MethodInfo m = subclass.GetType().GetMethod(method,
                BindingFlags.Instance
                | BindingFlags.Public
                | BindingFlags.NonPublic
                | BindingFlags.DeclaredOnly);
            if (m == null)
            {
                return false;
            }
            return m.GetBaseDefinition().DeclaringType != m.DeclaringType;
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        /// <remarks>
        /// If disposing equals true, the method has been called directly
        /// or indirectly by a user's code. Managed and unmanaged resources
        /// can be disposed.
        /// If disposing equals false, the method has been called by the
        /// runtime from inside the finalizer and you should not reference
        /// other objects. Only unmanaged resources can be disposed.		
        /// </remarks>
        /// <param name="disposing"></param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects)
                }

                // TODO: free unmanaged resources (unmanaged objects) and override finalizer
                // TODO: set large fields to null
                disposedValue = true;
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resource.
        /// </summary>
        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
#if DEBUG_IDISPOSABLE
			WasDisposed = true;

			foreach (var instance in Instances.Where (x => x.WasDisposed).ToList ()) {
				Instances.Remove (instance);
			}
#endif
        }
    }
    //=======================================================================
    //
    // ScrollBarView.cs: ScrollBarView view.
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    /// ScrollBarViews are views that display a 1-character scrollbar, either horizontal or vertical
    /// </summary>
    /// <remarks>
    /// <para>
    ///   The scrollbar is drawn to be a representation of the Size, assuming that the 
    ///   scroll position is set at Position.
    /// </para>
    /// <para>
    ///   If the region to display the scrollbar is larger than three characters, 
    ///   arrow indicators are drawn.
    /// </para>
    /// </remarks>
    public class ScrollBarView : View
    {
        bool vertical;
        int size, position;
        bool showScrollIndicator;
        bool keepContentAlwaysInViewport = true;
        bool autoHideScrollBars = true;
        bool hosted;
        ScrollBarView otherScrollBarView;
        View contentBottomRightCorner;

        bool showBothScrollIndicator => OtherScrollBarView != null && OtherScrollBarView.showScrollIndicator && showScrollIndicator;

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.ScrollBarView"/> class using <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <param name="rect">Frame for the scrollbar.</param>
        public ScrollBarView(Rect rect) : this(rect, 0, 0, false) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.ScrollBarView"/> class using <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <param name="rect">Frame for the scrollbar.</param>
        /// <param name="size">The size that this scrollbar represents. Sets the <see cref="Size"/> property.</param>
        /// <param name="position">The position within this scrollbar. Sets the <see cref="Position"/> property.</param>
        /// <param name="isVertical">If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal. Sets the <see cref="IsVertical"/> property.</param>
        public ScrollBarView(Rect rect, int size, int position, bool isVertical) : base(rect)
        {
            Init(size, position, isVertical);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.ScrollBarView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        public ScrollBarView() : this(0, 0, false) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.ScrollBarView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <param name="size">The size that this scrollbar represents.</param>
        /// <param name="position">The position within this scrollbar.</param>
        /// <param name="isVertical">If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal.</param>
        public ScrollBarView(int size, int position, bool isVertical) : base()
        {
            Init(size, position, isVertical);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.ScrollBarView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <param name="host">The view that will host this scrollbar.</param>
        /// <param name="isVertical">If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal.</param>
        /// <param name="showBothScrollIndicator">If set to <c>true (default)</c> will have the other scrollbar, otherwise will have only one.</param>
        public ScrollBarView(View host, bool isVertical, bool showBothScrollIndicator = true) : this(0, 0, isVertical)
        {
            if (host == null)
            {
                throw new ArgumentNullException("The host parameter can't be null.");
            }
            else if (host.SuperView == null)
            {
                throw new ArgumentNullException("The host SuperView parameter can't be null.");
            }
            hosted = true;
            ColorScheme = host.ColorScheme;
            X = isVertical ? Pos.Right(host) - 1 : Pos.Left(host);
            Y = isVertical ? Pos.Top(host) : Pos.Bottom(host) - 1;
            Host = host;
            CanFocus = false;
            Enabled = host.Enabled;
            Visible = host.Visible;
            //Host.CanFocusChanged += Host_CanFocusChanged;
            Host.EnabledChanged += Host_EnabledChanged;
            Host.VisibleChanged += Host_VisibleChanged;
            Host.SuperView.Add(this);
            AutoHideScrollBars = true;
            if (showBothScrollIndicator)
            {
                OtherScrollBarView = new ScrollBarView(0, 0, !isVertical)
                {
                    ColorScheme = host.ColorScheme,
                    Host = host,
                    CanFocus = false,
                    Enabled = host.Enabled,
                    Visible = host.Visible,
                    OtherScrollBarView = this
                };
                OtherScrollBarView.hosted = true;
                OtherScrollBarView.X = OtherScrollBarView.IsVertical ? Pos.Right(host) - 1 : Pos.Left(host);
                OtherScrollBarView.Y = OtherScrollBarView.IsVertical ? Pos.Top(host) : Pos.Bottom(host) - 1;
                OtherScrollBarView.Host.SuperView.Add(OtherScrollBarView);
                OtherScrollBarView.ShowScrollIndicator = true;
            }
            ShowScrollIndicator = true;
            contentBottomRightCorner = new View(" ") { Visible = host.Visible, ColorScheme = host.ColorScheme };
            Host.SuperView.Add(contentBottomRightCorner);
            contentBottomRightCorner.X = Pos.Right(host) - 1;
            contentBottomRightCorner.Y = Pos.Bottom(host) - 1;
            contentBottomRightCorner.Width = 1;
            contentBottomRightCorner.Height = 1;
            contentBottomRightCorner.MouseClick += ContentBottomRightCorner_MouseClick;
            contentBottomRightCorner.DrawContent += ContentBottomRightCorner_DrawContent;
            ClearOnVisibleFalse = false;
        }

        private void Host_VisibleChanged()
        {
            if (!Host.Visible)
            {
                Visible = Host.Visible;
                if (otherScrollBarView != null)
                {
                    otherScrollBarView.Visible = Visible;
                }
                contentBottomRightCorner.Visible = Visible;
            }
            else
            {
                ShowHideScrollBars();
            }
        }

        private void Host_EnabledChanged()
        {
            Enabled = Host.Enabled;
            if (otherScrollBarView != null)
            {
                otherScrollBarView.Enabled = Enabled;
            }
            contentBottomRightCorner.Enabled = Enabled;
        }

        //private void Host_CanFocusChanged ()
        //{
        //	CanFocus = Host.CanFocus;
        //	if (otherScrollBarView != null) {
        //		otherScrollBarView.CanFocus = CanFocus;
        //	}
        //}

        void ContentBottomRightCorner_MouseClick(MouseEventArgs me)
        {
            if (me.MouseEvent.Flags == MouseFlags.WheeledDown || me.MouseEvent.Flags == MouseFlags.WheeledUp
                || me.MouseEvent.Flags == MouseFlags.WheeledRight || me.MouseEvent.Flags == MouseFlags.WheeledLeft)
            {
                me.Handled = true;
                MouseEvent(me.MouseEvent);
            }
            else if (me.MouseEvent.Flags == MouseFlags.Button1Clicked)
            {
                me.Handled = true;
                Host.SetFocus();
            }
        }

        private void ContentBottomRightCorner_DrawContent(Rect obj)
        {
            Driver.SetAttribute(Host.HasFocus ? GetFocusColor() : GetNormalColor());
            Host.SuperView.AddRune(contentBottomRightCorner.Frame.X, contentBottomRightCorner.Frame.Y, ' ');
        }

        void Init(int size, int position, bool isVertical)
        {
            vertical = isVertical;
            this.position = position;
            this.size = size;
            WantContinuousButtonPressed = true;
        }

        /// <summary>
        /// If set to <c>true</c> this is a vertical scrollbar, otherwise, the scrollbar is horizontal.
        /// </summary>
        public bool IsVertical
        {
            get => vertical;
            set
            {
                vertical = value;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// The size of content the scrollbar represents.
        /// </summary>
        /// <value>The size.</value>
        /// <remarks>The <see cref="Size"/> is typically the size of the virtual content. E.g. when a Scrollbar is
        /// part of a <see cref="View"/> the Size is set to the appropriate dimension of <see cref="Host"/>.</remarks>
        public int Size
        {
            get => size;
            set
            {
                size = value;
                SetRelativeLayout(Bounds);
                ShowHideScrollBars(false);
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// This event is raised when the position on the scrollbar has changed.
        /// </summary>
        public event Action ChangedPosition;

        /// <summary>
        /// The position, relative to <see cref="Size"/>, to set the scrollbar at.
        /// </summary>
        /// <value>The position.</value>
        public int Position
        {
            get => position;
            set
            {
                if (position != value)
                {
                    if (CanScroll(value - position, out int max, vertical))
                    {
                        if (max == value - position)
                        {
                            position = value;
                        }
                        else
                        {
                            position = Math.Max(position + max, 0);
                        }
                    }
                    else if (max < 0)
                    {
                        position = Math.Max(position + max, 0);
                    }
                    var s = GetBarsize(vertical);
                    OnChangedPosition();
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Get or sets the view that host this <see cref="View"/>
        /// </summary>
        public View Host { get; internal set; }

        /// <summary>
        /// Represent a vertical or horizontal ScrollBarView other than this.
        /// </summary>
        public ScrollBarView OtherScrollBarView
        {
            get => otherScrollBarView;
            set
            {
                if (value != null && (value.IsVertical && vertical || !value.IsVertical && !vertical))
                {
                    throw new ArgumentException($"There is already a {(vertical ? "vertical" : "horizontal")} ScrollBarView.");
                }
                otherScrollBarView = value;
            }
        }

        /// <summary>
        /// Gets or sets the visibility for the vertical or horizontal scroll indicator.
        /// </summary>
        /// <value><c>true</c> if show vertical or horizontal scroll indicator; otherwise, <c>false</c>.</value>
        public bool ShowScrollIndicator
        {
            get => showScrollIndicator;
            set
            {
                if (value == showScrollIndicator)
                {
                    return;
                }

                showScrollIndicator = value;
                SetNeedsLayout();
                if (value)
                {
                    Visible = true;
                }
                else
                {
                    Visible = false;
                    Position = 0;
                }
                SetWidthHeight();
            }
        }

        /// <summary>
        /// Get or sets if the view-port is kept always visible in the area of this <see cref="ScrollBarView"/>
        /// </summary>
        public bool KeepContentAlwaysInViewport
        {
            get { return keepContentAlwaysInViewport; }
            set
            {
                if (keepContentAlwaysInViewport != value)
                {
                    keepContentAlwaysInViewport = value;
                    int pos = 0;
                    if (value && !vertical && position + Host.Bounds.Width > size)
                    {
                        pos = size - Host.Bounds.Width + (showBothScrollIndicator ? 1 : 0);
                    }
                    if (value && vertical && position + Host.Bounds.Height > size)
                    {
                        pos = size - Host.Bounds.Height + (showBothScrollIndicator ? 1 : 0);
                    }
                    if (pos != 0)
                    {
                        Position = pos;
                    }
                    if (OtherScrollBarView != null && OtherScrollBarView.keepContentAlwaysInViewport != value)
                    {
                        OtherScrollBarView.KeepContentAlwaysInViewport = value;
                    }
                    if (pos == 0)
                    {
                        Refresh();
                    }
                }
            }
        }

        /// <summary>
        /// If true the vertical/horizontal scroll bars won't be showed if it's not needed.
        /// </summary>
        public bool AutoHideScrollBars
        {
            get => autoHideScrollBars;
            set
            {
                if (autoHideScrollBars != value)
                {
                    autoHideScrollBars = value;
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Virtual method to invoke the <see cref="ChangedPosition"/> action event.
        /// </summary>
        public virtual void OnChangedPosition()
        {
            ChangedPosition?.Invoke();
        }

        /// <summary>
        /// Only used for a hosted view that will update and redraw the scrollbars.
        /// </summary>
        public virtual void Refresh()
        {
            ShowHideScrollBars();
        }

        void ShowHideScrollBars(bool redraw = true)
        {
            if (!hosted || (hosted && !autoHideScrollBars))
            {
                if (contentBottomRightCorner != null && contentBottomRightCorner.Visible)
                {
                    contentBottomRightCorner.Visible = false;
                }
                else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && otherScrollBarView.contentBottomRightCorner.Visible)
                {
                    otherScrollBarView.contentBottomRightCorner.Visible = false;
                }
                return;
            }

            var pending = CheckBothScrollBars(this);
            if (otherScrollBarView != null)
            {
                CheckBothScrollBars(otherScrollBarView, pending);
            }

            SetWidthHeight();
            SetRelativeLayout(Bounds);
            if (otherScrollBarView != null)
            {
                OtherScrollBarView.SetRelativeLayout(OtherScrollBarView.Bounds);
            }

            if (showBothScrollIndicator)
            {
                if (contentBottomRightCorner != null && !contentBottomRightCorner.Visible)
                {
                    contentBottomRightCorner.Visible = true;
                }
                else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && !otherScrollBarView.contentBottomRightCorner.Visible)
                {
                    otherScrollBarView.contentBottomRightCorner.Visible = true;
                }
            }
            else if (!showScrollIndicator)
            {
                if (contentBottomRightCorner != null && contentBottomRightCorner.Visible)
                {
                    contentBottomRightCorner.Visible = false;
                }
                else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && otherScrollBarView.contentBottomRightCorner.Visible)
                {
                    otherScrollBarView.contentBottomRightCorner.Visible = false;
                }
                if (Application.MouseGrabView != null && Application.MouseGrabView == this)
                {
                    Application.UngrabMouse();
                }
            }
            else if (contentBottomRightCorner != null && contentBottomRightCorner.Visible)
            {
                contentBottomRightCorner.Visible = false;
            }
            else if (otherScrollBarView != null && otherScrollBarView.contentBottomRightCorner != null && otherScrollBarView.contentBottomRightCorner.Visible)
            {
                otherScrollBarView.contentBottomRightCorner.Visible = false;
            }
            if (Host?.Visible == true && showScrollIndicator && !Visible)
            {
                Visible = true;
            }
            if (Host?.Visible == true && otherScrollBarView?.showScrollIndicator == true && !otherScrollBarView.Visible)
            {
                otherScrollBarView.Visible = true;
            }

            if (!redraw)
            {
                return;
            }

            if (showScrollIndicator)
            {
                Redraw(Bounds);
            }
            if (otherScrollBarView != null && otherScrollBarView.showScrollIndicator)
            {
                otherScrollBarView.Redraw(otherScrollBarView.Bounds);
            }
        }

        bool CheckBothScrollBars(ScrollBarView scrollBarView, bool pending = false)
        {
            int barsize = scrollBarView.vertical ? scrollBarView.Bounds.Height : scrollBarView.Bounds.Width;

            if (barsize == 0 || barsize >= scrollBarView.size)
            {
                if (scrollBarView.showScrollIndicator)
                {
                    scrollBarView.ShowScrollIndicator = false;
                }
                if (scrollBarView.Visible)
                {
                    scrollBarView.Visible = false;
                }
            }
            else if (barsize > 0 && barsize == scrollBarView.size && scrollBarView.OtherScrollBarView != null && pending)
            {
                if (scrollBarView.showScrollIndicator)
                {
                    scrollBarView.ShowScrollIndicator = false;
                }
                if (scrollBarView.Visible)
                {
                    scrollBarView.Visible = false;
                }
                if (scrollBarView.OtherScrollBarView != null && scrollBarView.showBothScrollIndicator)
                {
                    scrollBarView.OtherScrollBarView.ShowScrollIndicator = false;
                }
                if (scrollBarView.OtherScrollBarView.Visible)
                {
                    scrollBarView.OtherScrollBarView.Visible = false;
                }
            }
            else if (barsize > 0 && barsize == size && scrollBarView.OtherScrollBarView != null && !pending)
            {
                pending = true;
            }
            else
            {
                if (scrollBarView.OtherScrollBarView != null && pending)
                {
                    if (!scrollBarView.showBothScrollIndicator)
                    {
                        scrollBarView.OtherScrollBarView.ShowScrollIndicator = true;
                    }
                    if (!scrollBarView.OtherScrollBarView.Visible)
                    {
                        scrollBarView.OtherScrollBarView.Visible = true;
                    }
                }
                if (!scrollBarView.showScrollIndicator)
                {
                    scrollBarView.ShowScrollIndicator = true;
                }
                if (!scrollBarView.Visible)
                {
                    scrollBarView.Visible = true;
                }
            }

            return pending;
        }

        void SetWidthHeight()
        {
            if (showBothScrollIndicator)
            {
                Width = vertical ? 1 : Dim.Width(Host) - 1;
                Height = vertical ? Dim.Height(Host) - 1 : 1;

                otherScrollBarView.Width = otherScrollBarView.vertical ? 1 : Dim.Width(Host) - 1;
                otherScrollBarView.Height = otherScrollBarView.vertical ? Dim.Height(Host) - 1 : 1;
            }
            else if (showScrollIndicator)
            {
                Width = vertical ? 1 : Dim.Width(Host) - 0;
                Height = vertical ? Dim.Height(Host) - 0 : 1;
            }
            else if (otherScrollBarView?.showScrollIndicator == true)
            {
                otherScrollBarView.Width = otherScrollBarView.vertical ? 1 : Dim.Width(Host) - 0;
                otherScrollBarView.Height = otherScrollBarView.vertical ? Dim.Height(Host) - 0 : 1;
            }
        }

        int posTopTee;
        int posLeftTee;
        int posBottomTee;
        int posRightTee;

        ///<inheritdoc/>
        public override void Redraw(Rect region)
        {
            if (ColorScheme == null || ((!showScrollIndicator || Size == 0) && AutoHideScrollBars && Visible))
            {
                if ((!showScrollIndicator || Size == 0) && AutoHideScrollBars && Visible)
                {
                    ShowHideScrollBars(false);
                }
                return;
            }

            Driver.SetAttribute(Host.HasFocus ? ColorScheme.Focus : GetNormalColor());

            if ((vertical && Bounds.Height == 0) || (!vertical && Bounds.Width == 0))
            {
                return;
            }

            if (vertical)
            {
                if (region.Right < Bounds.Width - 1)
                {
                    return;
                }

                var col = Bounds.Width - 1;
                var bh = Bounds.Height;
                Rune special;

                if (bh < 4)
                {
                    var by1 = position * bh / Size;
                    var by2 = (position + bh) * bh / Size;

                    Move(col, 0);
                    if (Bounds.Height == 1)
                    {
                        Driver.AddRune(Driver.Diamond);
                    }
                    else
                    {
                        Driver.AddRune(Driver.UpArrow);
                    }
                    if (Bounds.Height == 3)
                    {
                        Move(col, 1);
                        Driver.AddRune(Driver.Diamond);
                    }
                    if (Bounds.Height > 1)
                    {
                        Move(col, Bounds.Height - 1);
                        Driver.AddRune(Driver.DownArrow);
                    }
                }
                else
                {
                    bh -= 2;
                    var by1 = KeepContentAlwaysInViewport ? position * bh / Size : position * bh / (Size + bh);
                    var by2 = KeepContentAlwaysInViewport ? Math.Min(((position + bh) * bh / Size) + 1, bh - 1) : (position + bh) * bh / (Size + bh);
                    if (KeepContentAlwaysInViewport && by1 == by2)
                    {
                        by1 = Math.Max(by1 - 1, 0);
                    }

                    Move(col, 0);
                    Driver.AddRune(Driver.UpArrow);
                    Move(col, Bounds.Height - 1);
                    Driver.AddRune(Driver.DownArrow);

                    bool hasTopTee = false;
                    bool hasDiamond = false;
                    bool hasBottomTee = false;
                    for (int y = 0; y < bh; y++)
                    {
                        Move(col, y + 1);
                        if ((y < by1 || y > by2) && ((position > 0 && !hasTopTee) || (hasTopTee && hasBottomTee)))
                        {
                            special = Driver.Stipple;
                        }
                        else
                        {
                            if (y != by2 && y > 1 && by2 - by1 == 0 && by1 < bh - 1 && hasTopTee && !hasDiamond)
                            {
                                hasDiamond = true;
                                special = Driver.Diamond;
                            }
                            else
                            {
                                if (y == by1 && !hasTopTee)
                                {
                                    hasTopTee = true;
                                    posTopTee = y;
                                    special = Driver.TopTee;
                                }
                                else if ((position == 0 && y == bh - 1 || y >= by2 || by2 == 0) && !hasBottomTee)
                                {
                                    hasBottomTee = true;
                                    posBottomTee = y;
                                    special = Driver.BottomTee;
                                }
                                else
                                {
                                    special = Driver.VLine;
                                }
                            }
                        }
                        Driver.AddRune(special);
                    }
                    if (!hasTopTee)
                    {
                        Move(col, Bounds.Height - 2);
                        Driver.AddRune(Driver.TopTee);
                    }
                }
            }
            else
            {
                if (region.Bottom < Bounds.Height - 1)
                {
                    return;
                }

                var row = Bounds.Height - 1;
                var bw = Bounds.Width;
                Rune special;

                if (bw < 4)
                {
                    var bx1 = position * bw / Size;
                    var bx2 = (position + bw) * bw / Size;

                    Move(0, row);
                    Driver.AddRune(Driver.LeftArrow);
                    Driver.AddRune(Driver.RightArrow);
                }
                else
                {
                    bw -= 2;
                    var bx1 = KeepContentAlwaysInViewport ? position * bw / Size : position * bw / (Size + bw);
                    var bx2 = KeepContentAlwaysInViewport ? Math.Min(((position + bw) * bw / Size) + 1, bw - 1) : (position + bw) * bw / (Size + bw);
                    if (KeepContentAlwaysInViewport && bx1 == bx2)
                    {
                        bx1 = Math.Max(bx1 - 1, 0);
                    }

                    Move(0, row);
                    Driver.AddRune(Driver.LeftArrow);

                    bool hasLeftTee = false;
                    bool hasDiamond = false;
                    bool hasRightTee = false;
                    for (int x = 0; x < bw; x++)
                    {
                        if ((x < bx1 || x >= bx2 + 1) && ((position > 0 && !hasLeftTee) || (hasLeftTee && hasRightTee)))
                        {
                            special = Driver.Stipple;
                        }
                        else
                        {
                            if (x != bx2 && x > 1 && bx2 - bx1 == 0 && bx1 < bw - 1 && hasLeftTee && !hasDiamond)
                            {
                                hasDiamond = true;
                                special = Driver.Diamond;
                            }
                            else
                            {
                                if (x == bx1 && !hasLeftTee)
                                {
                                    hasLeftTee = true;
                                    posLeftTee = x;
                                    special = Driver.LeftTee;
                                }
                                else if ((position == 0 && x == bw - 1 || x >= bx2 || bx2 == 0) && !hasRightTee)
                                {
                                    hasRightTee = true;
                                    posRightTee = x;
                                    special = Driver.RightTee;
                                }
                                else
                                {
                                    special = Driver.HLine;
                                }
                            }
                        }
                        Driver.AddRune(special);
                    }
                    if (!hasLeftTee)
                    {
                        Move(Bounds.Width - 2, row);
                        Driver.AddRune(Driver.LeftTee);
                    }

                    Driver.AddRune(Driver.RightArrow);
                }
            }
        }

        int lastLocation = -1;
        int posBarOffset;

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent mouseEvent)
        {
            if (mouseEvent.Flags != MouseFlags.Button1Pressed && mouseEvent.Flags != MouseFlags.Button1DoubleClicked &&
                !mouseEvent.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) &&
                mouseEvent.Flags != MouseFlags.Button1Released && mouseEvent.Flags != MouseFlags.WheeledDown &&
                mouseEvent.Flags != MouseFlags.WheeledUp && mouseEvent.Flags != MouseFlags.WheeledRight &&
                mouseEvent.Flags != MouseFlags.WheeledLeft && mouseEvent.Flags != MouseFlags.Button1TripleClicked)
            {
                return false;
            }

            if (!Host.CanFocus)
            {
                return true;
            }
            if (Host?.HasFocus == false)
            {
                Host.SetFocus();
            }

            int location = vertical ? mouseEvent.Y : mouseEvent.X;
            int barsize = vertical ? Bounds.Height : Bounds.Width;
            int posTopLeftTee = vertical ? posTopTee + 1 : posLeftTee + 1;
            int posBottomRightTee = vertical ? posBottomTee + 1 : posRightTee + 1;
            barsize -= 2;
            var pos = Position;

            if (mouseEvent.Flags != MouseFlags.Button1Released
                && (Application.MouseGrabView == null || Application.MouseGrabView != this))
            {
                Application.GrabMouse(this);
            }
            else if (mouseEvent.Flags == MouseFlags.Button1Released && Application.MouseGrabView != null && Application.MouseGrabView == this)
            {
                lastLocation = -1;
                Application.UngrabMouse();
                return true;
            }
            if (showScrollIndicator && (mouseEvent.Flags == MouseFlags.WheeledDown || mouseEvent.Flags == MouseFlags.WheeledUp ||
                mouseEvent.Flags == MouseFlags.WheeledRight || mouseEvent.Flags == MouseFlags.WheeledLeft))
            {
                return Host.MouseEvent(mouseEvent);
            }

            if (location == 0)
            {
                if (pos > 0)
                {
                    Position = pos - 1;
                }
            }
            else if (location == barsize + 1)
            {
                if (CanScroll(1, out _, vertical))
                {
                    Position = pos + 1;
                }
            }
            else if (location > 0 && location < barsize + 1)
            {
                //var b1 = pos * (Size > 0 ? barsize / Size : 0);
                //var b2 = Size > 0
                //	? (KeepContentAlwaysInViewport ? Math.Min (((pos + barsize) * barsize / Size) + 1, barsize - 1) : (pos + barsize) * barsize / Size)
                //	: 0;
                //if (KeepContentAlwaysInViewport && b1 == b2) {
                //	b1 = Math.Max (b1 - 1, 0);
                //}

                if (lastLocation > -1 || (location >= posTopLeftTee && location <= posBottomRightTee
                && mouseEvent.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition)))
                {
                    if (lastLocation == -1)
                    {
                        lastLocation = location;
                        posBarOffset = keepContentAlwaysInViewport ? Math.Max(location - posTopLeftTee, 1) : 0;
                        return true;
                    }

                    if (location > lastLocation)
                    {
                        if (location - posBarOffset < barsize)
                        {
                            var np = ((location - posBarOffset) * Size / barsize) + (Size / barsize);
                            if (CanScroll(np - pos, out int nv, vertical))
                            {
                                Position = pos + nv;
                            }
                        }
                        else if (CanScroll(Size - pos, out int nv, vertical))
                        {
                            Position = Math.Min(pos + nv, Size);
                        }
                    }
                    else if (location < lastLocation)
                    {
                        if (location - posBarOffset > 0)
                        {
                            var np = ((location - posBarOffset) * Size / barsize) - (Size / barsize);
                            if (CanScroll(np - pos, out int nv, vertical))
                            {
                                Position = pos + nv;
                            }
                        }
                        else
                        {
                            Position = 0;
                        }
                    }
                    else if (location - posBarOffset >= barsize && posBottomRightTee - posTopLeftTee >= 3 && CanScroll(Size - pos, out int nv, vertical))
                    {
                        Position = Math.Min(pos + nv, Size);
                    }
                    else if (location - posBarOffset >= barsize - 1 && posBottomRightTee - posTopLeftTee <= 3 && CanScroll(Size - pos, out nv, vertical))
                    {
                        Position = Math.Min(pos + nv, Size);
                    }
                    else if (location - posBarOffset <= 0 && posBottomRightTee - posTopLeftTee <= 3)
                    {
                        Position = 0;
                    }
                }
                else if (location > posBottomRightTee)
                {
                    if (CanScroll(barsize, out int nv, vertical))
                    {
                        Position = pos + nv;
                    }
                }
                else if (location < posTopLeftTee)
                {
                    if (CanScroll(-barsize, out int nv, vertical))
                    {
                        Position = pos + nv;
                    }
                }
                else if (location == 1 && posTopLeftTee <= 3)
                {
                    Position = 0;
                }
                else if (location == barsize)
                {
                    if (CanScroll(Size - pos, out int nv, vertical))
                    {
                        Position = Math.Min(pos + nv, Size);
                    }
                }
            }

            return true;
        }

        internal bool CanScroll(int n, out int max, bool isVertical = false)
        {
            if (Host?.Bounds.IsEmpty != false)
            {
                max = 0;
                return false;
            }
            int s = GetBarsize(isVertical);
            var newSize = Math.Max(Math.Min(size - s, position + n), 0);
            max = size > s + newSize ? (newSize == 0 ? -position : n) : size - (s + position) - 1;
            if (size >= s + newSize && max != 0)
            {
                return true;
            }
            return false;
        }

        int GetBarsize(bool isVertical)
        {
            if (Host?.Bounds.IsEmpty != false)
            {
                return 0;
            }
            return isVertical ?
                (KeepContentAlwaysInViewport ? Host.Bounds.Height + (showBothScrollIndicator ? -2 : -1) : 0) :
                (KeepContentAlwaysInViewport ? Host.Bounds.Width + (showBothScrollIndicator ? -2 : -1) : 0);
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }
    }
    //=======================================================================
    //
    // ScrollView.cs: ScrollView view.
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //
    //
    // TODO:
    // - focus in scrollview
    // - focus handling in scrollview to auto scroll to focused view
    // - Raise events
    // - Perhaps allow an option to not display the scrollbar arrow indicators?

    /// <summary>
    /// Scrollviews are views that present a window into a virtual space where subviews are added.  Similar to the iOS UIScrollView.
    /// </summary>
    /// <remarks>
    /// <para>
    ///   The subviews that are added to this <see cref="Gui.ScrollView"/> are offset by the
    ///   <see cref="ContentOffset"/> property.  The view itself is a window into the 
    ///   space represented by the <see cref="ContentSize"/>.
    /// </para>
    /// <para>
    ///   Use the 
    /// </para>
    /// </remarks>
    public class ScrollView : View
    {
        private class ContentView : View
        {
            public ContentView(Rect frame) : base(frame)
            {
                CanFocus = true;
            }
        }

        ContentView contentView;
        ScrollBarView vertical, horizontal;

        /// <summary>
        ///  Initializes a new instance of the <see cref="Gui.ScrollView"/> class using <see cref="LayoutStyle.Absolute"/> positioning.
        /// </summary>
        /// <param name="frame"></param>
        public ScrollView(Rect frame) : base(frame)
        {
            Initialize(frame);
        }


        /// <summary>
        ///  Initializes a new instance of the <see cref="Gui.ScrollView"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        public ScrollView() : base()
        {
            Initialize(Rect.Empty);
        }

        void Initialize(Rect frame)
        {
            contentView = new ContentView(frame);
            vertical = new ScrollBarView(1, 0, isVertical: true)
            {
                X = Pos.AnchorEnd(1),
                Y = 0,
                Width = 1,
                Height = Dim.Fill(showHorizontalScrollIndicator ? 1 : 0)
            };
            vertical.ChangedPosition += delegate
            {
                ContentOffset = new Point(ContentOffset.X, vertical.Position);
            };
            vertical.Host = this;
            horizontal = new ScrollBarView(1, 0, isVertical: false)
            {
                X = 0,
                Y = Pos.AnchorEnd(1),
                Width = Dim.Fill(showVerticalScrollIndicator ? 1 : 0),
                Height = 1
            };
            horizontal.ChangedPosition += delegate
            {
                ContentOffset = new Point(horizontal.Position, ContentOffset.Y);
            };
            horizontal.Host = this;
            vertical.OtherScrollBarView = horizontal;
            horizontal.OtherScrollBarView = vertical;
            base.Add(contentView);
            CanFocus = true;

            MouseEnter += View_MouseEnter;
            MouseLeave += View_MouseLeave;
            contentView.MouseEnter += View_MouseEnter;
            contentView.MouseLeave += View_MouseLeave;

            // Things this view knows how to do
            AddCommand(Command.ScrollUp, () => ScrollUp(1));
            AddCommand(Command.ScrollDown, () => ScrollDown(1));
            AddCommand(Command.ScrollLeft, () => ScrollLeft(1));
            AddCommand(Command.ScrollRight, () => ScrollRight(1));
            AddCommand(Command.PageUp, () => ScrollUp(Bounds.Height));
            AddCommand(Command.PageDown, () => ScrollDown(Bounds.Height));
            AddCommand(Command.PageLeft, () => ScrollLeft(Bounds.Width));
            AddCommand(Command.PageRight, () => ScrollRight(Bounds.Width));
            AddCommand(Command.TopHome, () => ScrollUp(contentSize.Height));
            AddCommand(Command.BottomEnd, () => ScrollDown(contentSize.Height));
            AddCommand(Command.LeftHome, () => ScrollLeft(contentSize.Width));
            AddCommand(Command.RightEnd, () => ScrollRight(contentSize.Width));

            // Default keybindings for this view
            AddKeyBinding(Key.CursorUp, Command.ScrollUp);
            AddKeyBinding(Key.CursorDown, Command.ScrollDown);
            AddKeyBinding(Key.CursorLeft, Command.ScrollLeft);
            AddKeyBinding(Key.CursorRight, Command.ScrollRight);

            AddKeyBinding(Key.PageUp, Command.PageUp);
            AddKeyBinding((Key)'v' | Key.AltMask, Command.PageUp);

            AddKeyBinding(Key.PageDown, Command.PageDown);
            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);

            AddKeyBinding(Key.PageUp | Key.CtrlMask, Command.PageLeft);
            AddKeyBinding(Key.PageDown | Key.CtrlMask, Command.PageRight);
            AddKeyBinding(Key.Home, Command.TopHome);
            AddKeyBinding(Key.End, Command.BottomEnd);
            AddKeyBinding(Key.Home | Key.CtrlMask, Command.LeftHome);
            AddKeyBinding(Key.End | Key.CtrlMask, Command.RightEnd);
        }

        Size contentSize;
        Point contentOffset;
        bool showHorizontalScrollIndicator;
        bool showVerticalScrollIndicator;
        bool keepContentAlwaysInViewport = true;
        bool autoHideScrollBars = true;

        /// <summary>
        /// Represents the contents of the data shown inside the scrollview
        /// </summary>
        /// <value>The size of the content.</value>
        public Size ContentSize
        {
            get
            {
                return contentSize;
            }
            set
            {
                if (contentSize != value)
                {
                    contentSize = value;
                    contentView.Frame = new Rect(contentOffset, value);
                    vertical.Size = contentSize.Height;
                    horizontal.Size = contentSize.Width;
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Represents the top left corner coordinate that is displayed by the scrollview
        /// </summary>
        /// <value>The content offset.</value>
        public Point ContentOffset
        {
            get
            {
                return contentOffset;
            }
            set
            {
                var co = new Point(-Math.Abs(value.X), -Math.Abs(value.Y));
                if (contentOffset != co)
                {
                    contentOffset = co;
                    contentView.Frame = new Rect(contentOffset, contentSize);
                    var p = Math.Max(0, -contentOffset.Y);
                    if (vertical.Position != p)
                    {
                        vertical.Position = Math.Max(0, -contentOffset.Y);
                    }
                    p = Math.Max(0, -contentOffset.X);
                    if (horizontal.Position != p)
                    {
                        horizontal.Position = Math.Max(0, -contentOffset.X);
                    }
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// If true the vertical/horizontal scroll bars won't be showed if it's not needed.
        /// </summary>
        public bool AutoHideScrollBars
        {
            get => autoHideScrollBars;
            set
            {
                if (autoHideScrollBars != value)
                {
                    autoHideScrollBars = value;
                    if (Subviews.Contains(vertical))
                    {
                        vertical.AutoHideScrollBars = value;
                    }
                    if (Subviews.Contains(horizontal))
                    {
                        horizontal.AutoHideScrollBars = value;
                    }
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Get or sets if the view-port is kept always visible in the area of this <see cref="ScrollView"/>
        /// </summary>
        public bool KeepContentAlwaysInViewport
        {
            get { return keepContentAlwaysInViewport; }
            set
            {
                if (keepContentAlwaysInViewport != value)
                {
                    keepContentAlwaysInViewport = value;
                    vertical.OtherScrollBarView.KeepContentAlwaysInViewport = value;
                    horizontal.OtherScrollBarView.KeepContentAlwaysInViewport = value;
                    Point p = default;
                    if (value && -contentOffset.X + Bounds.Width > contentSize.Width)
                    {
                        p = new Point(contentSize.Width - Bounds.Width + (showVerticalScrollIndicator ? 1 : 0), -contentOffset.Y);
                    }
                    if (value && -contentOffset.Y + Bounds.Height > contentSize.Height)
                    {
                        if (p == default)
                        {
                            p = new Point(-contentOffset.X, contentSize.Height - Bounds.Height + (showHorizontalScrollIndicator ? 1 : 0));
                        }
                        else
                        {
                            p.Y = contentSize.Height - Bounds.Height + (showHorizontalScrollIndicator ? 1 : 0);
                        }
                    }
                    if (p != default)
                    {
                        ContentOffset = p;
                    }
                }
            }
        }

        /// <summary>
        /// Adds the view to the scrollview.
        /// </summary>
        /// <param name="view">The view to add to the scrollview.</param>
        public override void Add(View view)
        {
            if (!IsOverridden(view, "MouseEvent"))
            {
                view.MouseEnter += View_MouseEnter;
                view.MouseLeave += View_MouseLeave;
            }
            contentView.Add(view);
            SetNeedsLayout();
        }

        /// <summary>
        /// Removes the view from the scrollview.
        /// </summary>
        /// <param name="view">The view to remove from the scrollview.</param>
        public override void Remove(View view)
        {
            if (view == null)
            {
                return;
            }

            SetNeedsDisplay();
            var container = view?.SuperView;
            if (container == this)
            {
                base.Remove(view);
            }
            else
            {
                container?.Remove(view);
            }

            if (contentView.InternalSubviews.Count < 1)
            {
                this.CanFocus = false;
            }
        }

        /// <summary>
        ///   Removes all widgets from this container.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public override void RemoveAll()
        {
            contentView.RemoveAll();
        }

        void View_MouseLeave(MouseEventArgs e)
        {
            if (Application.MouseGrabView != null && Application.MouseGrabView != vertical && Application.MouseGrabView != horizontal)
            {
                Application.UngrabMouse();
            }
        }

        void View_MouseEnter(MouseEventArgs e)
        {
            Application.GrabMouse(this);
        }

        /// <summary>
        /// Gets or sets the visibility for the horizontal scroll indicator.
        /// </summary>
        /// <value><c>true</c> if show horizontal scroll indicator; otherwise, <c>false</c>.</value>
        public bool ShowHorizontalScrollIndicator
        {
            get => showHorizontalScrollIndicator;
            set
            {
                if (value == showHorizontalScrollIndicator)
                {
                    return;
                }

                showHorizontalScrollIndicator = value;
                SetNeedsLayout();
                if (value)
                {
                    base.Add(horizontal);
                    horizontal.ShowScrollIndicator = value;
                    horizontal.AutoHideScrollBars = autoHideScrollBars;
                    horizontal.OtherScrollBarView = vertical;
                    horizontal.OtherScrollBarView.ShowScrollIndicator = value;
                    horizontal.MouseEnter += View_MouseEnter;
                    horizontal.MouseLeave += View_MouseLeave;
                }
                else
                {
                    base.Remove(horizontal);
                    horizontal.OtherScrollBarView = null;
                    horizontal.MouseEnter -= View_MouseEnter;
                    horizontal.MouseLeave -= View_MouseLeave;
                }
                vertical.Height = Dim.Fill(showHorizontalScrollIndicator ? 1 : 0);
            }
        }

        /// <summary>
        /// Gets or sets the visibility for the vertical scroll indicator.
        /// </summary>
        /// <value><c>true</c> if show vertical scroll indicator; otherwise, <c>false</c>.</value>
        public bool ShowVerticalScrollIndicator
        {
            get => showVerticalScrollIndicator;
            set
            {
                if (value == showVerticalScrollIndicator)
                {
                    return;
                }

                showVerticalScrollIndicator = value;
                SetNeedsLayout();
                if (value)
                {
                    base.Add(vertical);
                    vertical.ShowScrollIndicator = value;
                    vertical.AutoHideScrollBars = autoHideScrollBars;
                    vertical.OtherScrollBarView = horizontal;
                    vertical.OtherScrollBarView.ShowScrollIndicator = value;
                    vertical.MouseEnter += View_MouseEnter;
                    vertical.MouseLeave += View_MouseLeave;
                }
                else
                {
                    Remove(vertical);
                    vertical.OtherScrollBarView = null;
                    vertical.MouseEnter -= View_MouseEnter;
                    vertical.MouseLeave -= View_MouseLeave;
                }
                horizontal.Width = Dim.Fill(showVerticalScrollIndicator ? 1 : 0);
            }
        }

        /// <inheritdoc/>
        public override void Redraw(Rect region)
        {
            Driver.SetAttribute(GetNormalColor());
            SetViewsNeedsDisplay();
            Clear();

            var savedClip = ClipToBounds();
            OnDrawContent(new Rect(ContentOffset,
                new Size(Math.Max(Bounds.Width - (ShowVerticalScrollIndicator ? 1 : 0), 0),
                    Math.Max(Bounds.Height - (ShowHorizontalScrollIndicator ? 1 : 0), 0))));
            contentView.Redraw(contentView.Frame);
            Driver.Clip = savedClip;

            if (autoHideScrollBars)
            {
                ShowHideScrollBars();
            }
            else
            {
                if (ShowVerticalScrollIndicator)
                {
                    vertical.SetRelativeLayout(Bounds);
                    vertical.Redraw(vertical.Bounds);
                }

                if (ShowHorizontalScrollIndicator)
                {
                    horizontal.SetRelativeLayout(Bounds);
                    horizontal.Redraw(horizontal.Bounds);
                }
            }

            // Fill in the bottom right corner
            if (ShowVerticalScrollIndicator && ShowHorizontalScrollIndicator)
            {
                AddRune(Bounds.Width - 1, Bounds.Height - 1, ' ');
            }
            Driver.SetAttribute(GetNormalColor());
        }

        void ShowHideScrollBars()
        {
            bool v = false, h = false; bool p = false;

            if (Bounds.Height == 0 || Bounds.Height > contentSize.Height)
            {
                if (ShowVerticalScrollIndicator)
                {
                    ShowVerticalScrollIndicator = false;
                }
                v = false;
            }
            else if (Bounds.Height > 0 && Bounds.Height == contentSize.Height)
            {
                p = true;
            }
            else
            {
                if (!ShowVerticalScrollIndicator)
                {
                    ShowVerticalScrollIndicator = true;
                }
                v = true;
            }
            if (Bounds.Width == 0 || Bounds.Width > contentSize.Width)
            {
                if (ShowHorizontalScrollIndicator)
                {
                    ShowHorizontalScrollIndicator = false;
                }
                h = false;
            }
            else if (Bounds.Width > 0 && Bounds.Width == contentSize.Width && p)
            {
                if (ShowHorizontalScrollIndicator)
                {
                    ShowHorizontalScrollIndicator = false;
                }
                h = false;
                if (ShowVerticalScrollIndicator)
                {
                    ShowVerticalScrollIndicator = false;
                }
                v = false;
            }
            else
            {
                if (p)
                {
                    if (!ShowVerticalScrollIndicator)
                    {
                        ShowVerticalScrollIndicator = true;
                    }
                    v = true;
                }
                if (!ShowHorizontalScrollIndicator)
                {
                    ShowHorizontalScrollIndicator = true;
                }
                h = true;
            }
            var dim = Dim.Fill(h ? 1 : 0);
            if (!vertical.Height.Equals(dim))
            {
                vertical.Height = dim;
            }
            dim = Dim.Fill(v ? 1 : 0);
            if (!horizontal.Width.Equals(dim))
            {
                horizontal.Width = dim;
            }

            if (v)
            {
                vertical.SetRelativeLayout(Bounds);
                vertical.Redraw(vertical.Bounds);
            }
            if (h)
            {
                horizontal.SetRelativeLayout(Bounds);
                horizontal.Redraw(horizontal.Bounds);
            }
        }

        void SetViewsNeedsDisplay()
        {
            foreach (View view in contentView.Subviews)
            {
                view.SetNeedsDisplay();
            }
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            if (InternalSubviews.Count == 0)
                Move(0, 0);
            else
                base.PositionCursor();
        }

        /// <summary>
        /// Scrolls the view up.
        /// </summary>
        /// <returns><c>true</c>, if left was scrolled, <c>false</c> otherwise.</returns>
        /// <param name="lines">Number of lines to scroll.</param>
        public bool ScrollUp(int lines)
        {
            if (contentOffset.Y < 0)
            {
                ContentOffset = new Point(contentOffset.X, Math.Min(contentOffset.Y + lines, 0));
                return true;
            }
            return false;
        }

        /// <summary>
        /// Scrolls the view to the left
        /// </summary>
        /// <returns><c>true</c>, if left was scrolled, <c>false</c> otherwise.</returns>
        /// <param name="cols">Number of columns to scroll by.</param>
        public bool ScrollLeft(int cols)
        {
            if (contentOffset.X < 0)
            {
                ContentOffset = new Point(Math.Min(contentOffset.X + cols, 0), contentOffset.Y);
                return true;
            }
            return false;
        }

        /// <summary>
        /// Scrolls the view down.
        /// </summary>
        /// <returns><c>true</c>, if left was scrolled, <c>false</c> otherwise.</returns>
        /// <param name="lines">Number of lines to scroll.</param>
        public bool ScrollDown(int lines)
        {
            if (vertical.CanScroll(lines, out _, true))
            {
                ContentOffset = new Point(contentOffset.X, contentOffset.Y - lines);
                return true;
            }
            return false;
        }

        /// <summary>
        /// Scrolls the view to the right.
        /// </summary>
        /// <returns><c>true</c>, if right was scrolled, <c>false</c> otherwise.</returns>
        /// <param name="cols">Number of columns to scroll by.</param>
        public bool ScrollRight(int cols)
        {
            if (horizontal.CanScroll(cols, out _))
            {
                ContentOffset = new Point(contentOffset.X - cols, contentOffset.Y);
                return true;
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            if (base.ProcessKey(kb))
                return true;

            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            return false;
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (me.Flags != MouseFlags.WheeledDown && me.Flags != MouseFlags.WheeledUp &&
                me.Flags != MouseFlags.WheeledRight && me.Flags != MouseFlags.WheeledLeft &&
                //				me.Flags != MouseFlags.Button1Pressed && me.Flags != MouseFlags.Button1Clicked &&
                !me.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition))
            {
                return false;
            }

            if (me.Flags == MouseFlags.WheeledDown && ShowVerticalScrollIndicator)
            {
                ScrollDown(1);
            }
            else if (me.Flags == MouseFlags.WheeledUp && ShowVerticalScrollIndicator)
            {
                ScrollUp(1);
            }
            else if (me.Flags == MouseFlags.WheeledRight && showHorizontalScrollIndicator)
            {
                ScrollRight(1);
            }
            else if (me.Flags == MouseFlags.WheeledLeft && ShowVerticalScrollIndicator)
            {
                ScrollLeft(1);
            }
            else if (me.X == vertical.Frame.X && ShowVerticalScrollIndicator)
            {
                vertical.MouseEvent(me);
            }
            else if (me.Y == horizontal.Frame.Y && ShowHorizontalScrollIndicator)
            {
                horizontal.MouseEvent(me);
            }
            else if (IsOverridden(me.View, "MouseEvent"))
            {
                Application.UngrabMouse();
            }
            return true;
        }

        ///<inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (!showVerticalScrollIndicator)
            {
                // It was not added to SuperView, so it won't get disposed automatically
                vertical?.Dispose();
            }
            if (!showHorizontalScrollIndicator)
            {
                // It was not added to SuperView, so it won't get disposed automatically
                horizontal?.Dispose();
            }
            base.Dispose(disposing);
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            if (Subviews.Count == 0 || !Subviews.Any(subview => subview.CanFocus))
            {
                Application.Driver?.SetCursorVisibility(CursorVisibility.Invisible);
            }

            return base.OnEnter(view);
        }
    }
    //=======================================================================
    /// <summary>
    /// Represents a helper to manipulate shortcut keys used on views.
    /// </summary>
    public class ShortcutHelper
    {
        private Key shortcut;

        /// <summary>
        /// This is the global setting that can be used as a global shortcut to invoke the action on the view.
        /// </summary>
        public virtual Key Shortcut
        {
            get => shortcut;
            set
            {
                if (shortcut != value && (PostShortcutValidation(value) || value == Key.Null))
                {
                    shortcut = value;
                }
            }
        }

        /// <summary>
        /// The keystroke combination used in the <see cref="Shortcut"/> as string.
        /// </summary>
        public virtual ustring ShortcutTag => GetShortcutTag(shortcut);

        /// <summary>
        /// The action to run if the <see cref="Shortcut"/> is defined.
        /// </summary>
        public virtual Action ShortcutAction { get; set; }

        /// <summary>
        /// Gets the key with all the keys modifiers, especially the shift key that sometimes have to be injected later.
        /// </summary>
        /// <param name="kb">The <see cref="KeyEvent"/> to check.</param>
        /// <returns>The <see cref="KeyEvent.Key"/> with all the keys modifiers.</returns>
        public static Key GetModifiersKey(KeyEvent kb)
        {
            var key = kb.Key;
            if (kb.IsAlt && (key & Key.AltMask) == 0)
            {
                key |= Key.AltMask;
            }
            if (kb.IsCtrl && (key & Key.CtrlMask) == 0)
            {
                key |= Key.CtrlMask;
            }
            if (kb.IsShift && (key & Key.ShiftMask) == 0)
            {
                key |= Key.ShiftMask;
            }

            return key;
        }

        /// <summary>
        /// Get the <see cref="Shortcut"/> key as string.
        /// </summary>
        /// <param name="shortcut">The shortcut key.</param>
        /// <param name="delimiter">The delimiter string.</param>
        /// <returns></returns>
        public static ustring GetShortcutTag(Key shortcut, ustring delimiter = null)
        {
            if (shortcut == Key.Null)
            {
                return "";
            }

            var k = shortcut;
            if (delimiter == null)
            {
                delimiter = MenuBar.ShortcutDelimiter;
            }
            ustring tag = ustring.Empty;
            var sCut = GetKeyToString(k, out Key knm).ToString();
            if (knm == Key.Unknown)
            {
                k &= ~Key.Unknown;
                sCut = GetKeyToString(k, out _).ToString();
            }
            if ((k & Key.CtrlMask) != 0)
            {
                tag = "Ctrl";
            }
            if ((k & Key.ShiftMask) != 0)
            {
                if (!tag.IsEmpty)
                {
                    tag += delimiter;
                }
                tag += "Shift";
            }
            if ((k & Key.AltMask) != 0)
            {
                if (!tag.IsEmpty)
                {
                    tag += delimiter;
                }
                tag += "Alt";
            }

            ustring[] keys = ustring.Make(sCut).Split(",");
            for (int i = 0; i < keys.Length; i++)
            {
                var key = keys[i].TrimSpace();
                if (key == Key.AltMask.ToString() || key == Key.ShiftMask.ToString() || key == Key.CtrlMask.ToString())
                {
                    continue;
                }
                if (!tag.IsEmpty)
                {
                    tag += delimiter;
                }
                if (!key.Contains("F") && key.Length > 2 && keys.Length == 1)
                {
                    k = (uint)Key.AltMask + k;
                    tag += ((char)k).ToString();
                }
                else if (key.Length == 2 && key.StartsWith("D"))
                {
                    tag += ((char)key.ElementAt(1)).ToString();
                }
                else
                {
                    tag += key;
                }
            }

            return tag;
        }

        /// <summary>
        /// Return key as string.
        /// </summary>
        /// <param name="key">The key to extract.</param>
        /// <param name="knm">Correspond to the non modifier key.</param>
        public static ustring GetKeyToString(Key key, out Key knm)
        {
            if (key == Key.Null)
            {
                knm = Key.Null;
                return "";
            }

            knm = key;
            var mK = key & (Key.AltMask | Key.CtrlMask | Key.ShiftMask);
            knm &= ~mK;
            for (uint i = (uint)Key.F1; i < (uint)Key.F12; i++)
            {
                if (knm == (Key)i)
                {
                    mK |= (Key)i;
                }
            }
            knm &= ~mK;
            uint.TryParse(knm.ToString(), out uint c);
            var s = mK == Key.Null ? "" : mK.ToString();
            if (s != "" && (knm != Key.Null || c > 0))
            {
                s += ",";
            }
            s += c == 0 ? knm == Key.Null ? "" : knm.ToString() : ((char)c).ToString();
            return s;
        }

        /// <summary>
        /// Allows to retrieve a <see cref="Key"/> from a <see cref="ShortcutTag"/>
        /// </summary>
        /// <param name="tag">The key as string.</param>
        /// <param name="delimiter">The delimiter string.</param>
        public static Key GetShortcutFromTag(ustring tag, ustring delimiter = null)
        {
            var sCut = tag;
            if (sCut.IsEmpty)
            {
                return default;
            }

            Key key = Key.Null;
            //var hasCtrl = false;
            if (delimiter == null)
            {
                delimiter = MenuBar.ShortcutDelimiter;
            }

            ustring[] keys = sCut.Split(delimiter);
            for (int i = 0; i < keys.Length; i++)
            {
                var k = keys[i];
                if (k == "Ctrl")
                {
                    //hasCtrl = true;
                    key |= Key.CtrlMask;
                }
                else if (k == "Shift")
                {
                    key |= Key.ShiftMask;
                }
                else if (k == "Alt")
                {
                    key |= Key.AltMask;
                }
                else if (k.StartsWith("F") && k.Length > 1)
                {
                    int.TryParse(k.Substring(1).ToString(), out int n);
                    for (uint j = (uint)Key.F1; j <= (uint)Key.F12; j++)
                    {
                        int.TryParse(((Key)j).ToString().Substring(1), out int f);
                        if (f == n)
                        {
                            key |= (Key)j;
                        }
                    }
                }
                else
                {
                    key |= (Key)Enum.Parse(typeof(Key), k.ToString());
                }
            }

            return key;
        }

        /// <summary>
        /// Lookup for a <see cref="Key"/> on range of keys.
        /// </summary>
        /// <param name="key">The source key.</param>
        /// <param name="first">First key in range.</param>
        /// <param name="last">Last key in range.</param>
        public static bool CheckKeysFlagRange(Key key, Key first, Key last)
        {
            for (uint i = (uint)first; i < (uint)last; i++)
            {
                if ((key | (Key)i) == key)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Used at key down or key press validation.
        /// </summary>
        /// <param name="key">The key to validate.</param>
        /// <returns><c>true</c> if is valid.<c>false</c>otherwise.</returns>
        public static bool PreShortcutValidation(Key key)
        {
            if ((key & (Key.CtrlMask | Key.ShiftMask | Key.AltMask)) == 0 && !CheckKeysFlagRange(key, Key.F1, Key.F12))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Used at key up validation.
        /// </summary>
        /// <param name="key">The key to validate.</param>
        /// <returns><c>true</c> if is valid.<c>false</c>otherwise.</returns>
        public static bool PostShortcutValidation(Key key)
        {
            GetKeyToString(key, out Key knm);

            if (CheckKeysFlagRange(key, Key.F1, Key.F12) ||
                ((key & (Key.CtrlMask | Key.ShiftMask | Key.AltMask)) != 0 && knm != Key.Null && knm != Key.Unknown))
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// Allows a view to run a <see cref="View.ShortcutAction"/> if defined.
        /// </summary>
        /// <param name="kb">The <see cref="KeyEvent"/></param>
        /// <param name="view">The <see cref="View"/></param>
        /// <returns><c>true</c> if defined <c>false</c>otherwise.</returns>
        public static bool FindAndOpenByShortcut(KeyEvent kb, View view = null)
        {
            if (view == null)
            {
                return false;
            }

            var key = kb.KeyValue;
            var keys = GetModifiersKey(kb);
            key |= (int)keys;
            foreach (var v in view.Subviews)
            {
                if (v.Shortcut != Key.Null && v.Shortcut == (Key)key)
                {
                    var action = v.ShortcutAction;
                    if (action != null)
                    {
                        Application.MainLoop.AddIdle(() =>
                        {
                            action();
                            return false;
                        });
                    }
                    return true;
                }
                if (FindAndOpenByShortcut(kb, v))
                {
                    return true;
                }
            }

            return false;
        }
    }
    //=======================================================================
    //
    // System.Drawing.Size.cs
    //
    // Author:
    //   Mike Kestner (mkestner@speakeasy.net)
    //
    // Copyright (C) 2001 Mike Kestner
    // Copyright (C) 2004 Novell, Inc. http://www.novell.com
    //

    /// <summary>
    /// Stores an ordered pair of integers, which specify a Height and Width.
    /// </summary>
    public struct Size
    {
        int width, height;

        /// <summary>
        /// Gets a Size structure that has a Height and Width value of 0.
        /// </summary>
        public static readonly Size Empty;

        /// <summary>
        ///	Addition Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Addition of two Size structures.
        /// </remarks>

        public static Size operator +(Size sz1, Size sz2)
        {
            return new Size(sz1.Width + sz2.Width,
                     sz1.Height + sz2.Height);
        }

        /// <summary>
        ///	Equality Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Compares two Size objects. The return value is
        ///	based on the equivalence of the Width and Height 
        ///	properties of the two Sizes.
        /// </remarks>

        public static bool operator ==(Size sz1, Size sz2)
        {
            return ((sz1.Width == sz2.Width) &&
                (sz1.Height == sz2.Height));
        }

        /// <summary>
        ///	Inequality Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Compares two Size objects. The return value is
        ///	based on the equivalence of the Width and Height 
        ///	properties of the two Sizes.
        /// </remarks>

        public static bool operator !=(Size sz1, Size sz2)
        {
            return ((sz1.Width != sz2.Width) ||
                (sz1.Height != sz2.Height));
        }

        /// <summary>
        ///	Subtraction Operator
        /// </summary>
        ///
        /// <remarks>
        ///	Subtracts two Size structures.
        /// </remarks>

        public static Size operator -(Size sz1, Size sz2)
        {
            return new Size(sz1.Width - sz2.Width,
                     sz1.Height - sz2.Height);
        }

        /// <summary>
        ///	Size to Point Conversion
        /// </summary>
        ///
        /// <remarks>
        ///	Returns a Point based on the dimensions of a given 
        ///	Size. Requires explicit cast.
        /// </remarks>

        public static explicit operator Point(Size size)
        {
            return new Point(size.Width, size.Height);
        }

        /// <summary>
        ///	Size Constructor
        /// </summary>
        ///
        /// <remarks>
        ///	Creates a Size from a Point value.
        /// </remarks>

        public Size(Point pt)
        {
            width = pt.X;
            height = pt.Y;
        }

        /// <summary>
        ///	Size Constructor
        /// </summary>
        ///
        /// <remarks>
        ///	Creates a Size from specified dimensions.
        /// </remarks>

        public Size(int width, int height)
        {
            if (width < 0 || height < 0)
                throw new ArgumentException("Either Width and Height must be greater or equal to 0.");

            this.width = width;
            this.height = height;
        }

        /// <summary>
        ///	IsEmpty Property
        /// </summary>
        ///
        /// <remarks>
        ///	Indicates if both Width and Height are zero.
        /// </remarks>

        public bool IsEmpty
        {
            get
            {
                return ((width == 0) && (height == 0));
            }
        }

        /// <summary>
        ///	Width Property
        /// </summary>
        ///
        /// <remarks>
        ///	The Width coordinate of the Size.
        /// </remarks>

        public int Width
        {
            get
            {
                return width;
            }
            set
            {
                if (value < 0)
                    throw new ArgumentException("Width must be greater or equal to 0.");
                width = value;
            }
        }

        /// <summary>
        ///	Height Property
        /// </summary>
        ///
        /// <remarks>
        ///	The Height coordinate of the Size.
        /// </remarks>

        public int Height
        {
            get
            {
                return height;
            }
            set
            {
                if (value < 0)
                    throw new ArgumentException("Height must be greater or equal to 0.");
                height = value;
            }
        }

        /// <summary>
        ///	Equals Method
        /// </summary>
        ///
        /// <remarks>
        ///	Checks equivalence of this Size and another object.
        /// </remarks>

        public override bool Equals(object obj)
        {
            if (!(obj is Size))
                return false;

            return (this == (Size)obj);
        }

        /// <summary>
        ///	GetHashCode Method
        /// </summary>
        ///
        /// <remarks>
        ///	Calculates a hashing value.
        /// </remarks>

        public override int GetHashCode()
        {
            return width ^ height;
        }

        /// <summary>
        ///	ToString Method
        /// </summary>
        ///
        /// <remarks>
        ///	Formats the Size as a string in coordinate notation.
        /// </remarks>

        public override string ToString()
        {
            return String.Format("{{Width={0}, Height={1}}}", width, height);
        }

        /// <summary>
        /// Adds the width and height of one Size structure to the width and height of another Size structure.
        /// </summary>
        /// <returns>The add.</returns>
        /// <param name="sz1">The first Size structure to add.</param>
        /// <param name="sz2">The second Size structure to add.</param>
        public static Size Add(Size sz1, Size sz2)
        {
            return new Size(sz1.Width + sz2.Width,
                     sz1.Height + sz2.Height);

        }

        /// <summary>
        /// Subtracts the width and height of one Size structure to the width and height of another Size structure.
        /// </summary>
        /// <returns>The subtract.</returns>
        /// <param name="sz1">The first Size structure to subtract.</param>
        /// <param name="sz2">The second Size structure to subtract.</param>
        public static Size Subtract(Size sz1, Size sz2)
        {
            return new Size(sz1.Width - sz2.Width,
                     sz1.Height - sz2.Height);
        }

    }
    //=======================================================================
    // Licensed to the .NET Foundation under one or more agreements.
    // The .NET Foundation licenses this file to you under the MIT license.
    // See the LICENSE file in the project root for more information.

    // Copied from: https://github.com/dotnet/corefx/tree/master/src/System.Drawing.Primitives/src/System/Drawing

    /// <summary>
    /// Represents the size of a rectangular region with an ordered pair of width and height.
    /// </summary>
    public struct SizeF : IEquatable<SizeF>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class.
        /// </summary>
        public static readonly SizeF Empty;
        private float width; // Do not rename (binary serialization)
        private float height; // Do not rename (binary serialization)

        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class from the specified
        /// existing <see cref='Terminal.Gui.SizeF'/>.
        /// </summary>
        public SizeF(SizeF size)
        {
            width = size.width;
            height = size.height;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class from the specified
        /// <see cref='Terminal.Gui.PointF'/>.
        /// </summary>
        public SizeF(PointF pt)
        {
            width = pt.X;
            height = pt.Y;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref='Terminal.Gui.SizeF'/> class from the specified dimensions.
        /// </summary>
        public SizeF(float width, float height)
        {
            this.width = width;
            this.height = height;
        }

        /// <summary>
        /// Performs vector addition of two <see cref='Terminal.Gui.SizeF'/> objects.
        /// </summary>
        public static SizeF operator +(SizeF sz1, SizeF sz2) => Add(sz1, sz2);

        /// <summary>
        /// Contracts a <see cref='Terminal.Gui.SizeF'/> by another <see cref='Terminal.Gui.SizeF'/>
        /// </summary>
        public static SizeF operator -(SizeF sz1, SizeF sz2) => Subtract(sz1, sz2);

        /// <summary>
        /// Multiplies <see cref="SizeF"/> by a <see cref="float"/> producing <see cref="SizeF"/>.
        /// </summary>
        /// <param name="left">Multiplier of type <see cref="float"/>.</param>
        /// <param name="right">Multiplicand of type <see cref="SizeF"/>.</param>
        /// <returns>Product of type <see cref="SizeF"/>.</returns>
        public static SizeF operator *(float left, SizeF right) => Multiply(right, left);

        /// <summary>
        /// Multiplies <see cref="SizeF"/> by a <see cref="float"/> producing <see cref="SizeF"/>.
        /// </summary>
        /// <param name="left">Multiplicand of type <see cref="SizeF"/>.</param>
        /// <param name="right">Multiplier of type <see cref="float"/>.</param>
        /// <returns>Product of type <see cref="SizeF"/>.</returns>
        public static SizeF operator *(SizeF left, float right) => Multiply(left, right);

        /// <summary>
        /// Divides <see cref="SizeF"/> by a <see cref="float"/> producing <see cref="SizeF"/>.
        /// </summary>
        /// <param name="left">Dividend of type <see cref="SizeF"/>.</param>
        /// <param name="right">Divisor of type <see cref="int"/>.</param>
        /// <returns>Result of type <see cref="SizeF"/>.</returns>
        public static SizeF operator /(SizeF left, float right)
            => new SizeF(left.width / right, left.height / right);

        /// <summary>
        /// Tests whether two <see cref='Terminal.Gui.SizeF'/> objects are identical.
        /// </summary>
        public static bool operator ==(SizeF sz1, SizeF sz2) => sz1.Width == sz2.Width && sz1.Height == sz2.Height;

        /// <summary>
        /// Tests whether two <see cref='Terminal.Gui.SizeF'/> objects are different.
        /// </summary>
        public static bool operator !=(SizeF sz1, SizeF sz2) => !(sz1 == sz2);

        /// <summary>
        /// Converts the specified <see cref='Terminal.Gui.SizeF'/> to a <see cref='Terminal.Gui.PointF'/>.
        /// </summary>
        public static explicit operator PointF(SizeF size) => new PointF(size.Width, size.Height);

        /// <summary>
        /// Tests whether this <see cref='Terminal.Gui.SizeF'/> has zero width and height.
        /// </summary>
        [Browsable(false)]
        public bool IsEmpty => width == 0 && height == 0;

        /// <summary>
        /// Represents the horizontal component of this <see cref='Terminal.Gui.SizeF'/>.
        /// </summary>
        public float Width
        {
            get => width;
            set => width = value;
        }

        /// <summary>
        /// Represents the vertical component of this <see cref='Terminal.Gui.SizeF'/>.
        /// </summary>
        public float Height
        {
            get => height;
            set => height = value;
        }

        /// <summary>
        /// Performs vector addition of two <see cref='Terminal.Gui.SizeF'/> objects.
        /// </summary>
        public static SizeF Add(SizeF sz1, SizeF sz2) => new SizeF(sz1.Width + sz2.Width, sz1.Height + sz2.Height);

        /// <summary>
        /// Contracts a <see cref='Terminal.Gui.SizeF'/> by another <see cref='Terminal.Gui.SizeF'/>.
        /// </summary>
        public static SizeF Subtract(SizeF sz1, SizeF sz2) => new SizeF(sz1.Width - sz2.Width, sz1.Height - sz2.Height);

        /// <summary>
        /// Tests to see whether the specified object is a <see cref='Terminal.Gui.SizeF'/>  with the same dimensions
        /// as this <see cref='Terminal.Gui.SizeF'/>.
        /// </summary>
        public override bool Equals(object obj) => obj is SizeF && Equals((SizeF)obj);


        /// <summary>
        /// Tests whether two <see cref='Terminal.Gui.SizeF'/> objects are identical.
        /// </summary>
        public bool Equals(SizeF other) => this == other;

        /// <summary>
        /// Generates a hashcode from the width and height
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return width.GetHashCode() ^ height.GetHashCode();
        }

        /// <summary>
        /// Creates a human-readable string that represents this <see cref='Terminal.Gui.SizeF'/>.
        /// </summary>
        public override string ToString() => "{Width=" + width.ToString() + ", Height=" + height.ToString() + "}";

        /// <summary>
        /// Multiplies <see cref="SizeF"/> by a <see cref="float"/> producing <see cref="SizeF"/>.
        /// </summary>
        /// <param name="size">Multiplicand of type <see cref="SizeF"/>.</param>
        /// <param name="multiplier">Multiplier of type <see cref="float"/>.</param>
        /// <returns>Product of type SizeF.</returns>
        private static SizeF Multiply(SizeF size, float multiplier) =>
            new SizeF(size.width * multiplier, size.height * multiplier);
    }
    //=======================================================================
    /// <summary>
    /// Extension of <see cref="Stack{T}"/> helper to work with specific <see cref="IEqualityComparer{T}"/>
    /// </summary>
    public static class StackExtensions
    {
        /// <summary>
        /// Replaces an stack object values that match with the value to replace.
        /// </summary>
        /// <typeparam name="T">The stack object type.</typeparam>
        /// <param name="stack">The stack object.</param>
        /// <param name="valueToReplace">Value to replace.</param>
        /// <param name="valueToReplaceWith">Value to replace with to what matches the value to replace.</param>
        /// <param name="comparer">The comparison object.</param>
        public static void Replace<T>(this Stack<T> stack, T valueToReplace,
            T valueToReplaceWith, IEqualityComparer<T> comparer = null)
        {
            comparer = comparer ?? EqualityComparer<T>.Default;

            var temp = new Stack<T>();
            while (stack.Count > 0)
            {
                var value = stack.Pop();
                if (comparer.Equals(value, valueToReplace))
                {
                    stack.Push(valueToReplaceWith);
                    break;
                }
                temp.Push(value);
            }

            while (temp.Count > 0)
                stack.Push(temp.Pop());
        }

        /// <summary>
        /// Swap two stack objects values that matches with the both values.
        /// </summary>
        /// <typeparam name="T">The stack object type.</typeparam>
        /// <param name="stack">The stack object.</param>
        /// <param name="valueToSwapFrom">Value to swap from.</param>
        /// <param name="valueToSwapTo">Value to swap to.</param>
        /// <param name="comparer">The comparison object.</param>
        public static void Swap<T>(this Stack<T> stack, T valueToSwapFrom,
            T valueToSwapTo, IEqualityComparer<T> comparer = null)
        {
            comparer = comparer ?? EqualityComparer<T>.Default;

            int index = stack.Count - 1;
            T[] stackArr = new T[stack.Count];
            while (stack.Count > 0)
            {
                var value = stack.Pop();
                if (comparer.Equals(value, valueToSwapFrom))
                {
                    stackArr[index] = valueToSwapTo;
                }
                else if (comparer.Equals(value, valueToSwapTo))
                {
                    stackArr[index] = valueToSwapFrom;
                }
                else
                {
                    stackArr[index] = value;
                }
                index--;
            }

            for (int i = 0; i < stackArr.Length; i++)
                stack.Push(stackArr[i]);
        }

        /// <summary>
        /// Move the first stack object value to the end.
        /// </summary>
        /// <typeparam name="T">The stack object type.</typeparam>
        /// <param name="stack">The stack object.</param>
        public static void MoveNext<T>(this Stack<T> stack)
        {
            var temp = new Stack<T>();
            var last = stack.Pop();
            while (stack.Count > 0)
            {
                var value = stack.Pop();
                temp.Push(value);
            }
            temp.Push(last);

            while (temp.Count > 0)
                stack.Push(temp.Pop());
        }

        /// <summary>
        /// Move the last stack object value to the top.
        /// </summary>
        /// <typeparam name="T">The stack object type.</typeparam>
        /// <param name="stack">The stack object.</param>
        public static void MovePrevious<T>(this Stack<T> stack)
        {
            var temp = new Stack<T>();
            T first = default;
            while (stack.Count > 0)
            {
                var value = stack.Pop();
                temp.Push(value);
                if (stack.Count == 1)
                {
                    first = stack.Pop();
                }
            }

            while (temp.Count > 0)
                stack.Push(temp.Pop());
            stack.Push(first);
        }

        /// <summary>
        /// Find all duplicates stack objects values.
        /// </summary>
        /// <typeparam name="T">The stack object type.</typeparam>
        /// <param name="stack">The stack object.</param>
        /// <param name="comparer">The comparison object.</param>
        /// <returns>The duplicates stack object.</returns>
        public static Stack<T> FindDuplicates<T>(this Stack<T> stack, IEqualityComparer<T> comparer = null)
        {
            comparer = comparer ?? EqualityComparer<T>.Default;

            var dup = new Stack<T>();
            T[] stackArr = stack.ToArray();
            for (int i = 0; i < stackArr.Length; i++)
            {
                var value = stackArr[i];
                for (int j = i + 1; j < stackArr.Length; j++)
                {
                    var valueToFind = stackArr[j];
                    if (comparer.Equals(value, valueToFind) && !Contains(dup, valueToFind))
                    {
                        dup.Push(value);
                    }
                }
            }

            return dup;
        }

        /// <summary>
        /// Check if the stack object contains the value to find.
        /// </summary>
        /// <typeparam name="T">The stack object type.</typeparam>
        /// <param name="stack">The stack object.</param>
        /// <param name="valueToFind">Value to find.</param>
        /// <param name="comparer">The comparison object.</param>
        /// <returns><c>true</c> If the value was found.<c>false</c> otherwise.</returns>
        public static bool Contains<T>(this Stack<T> stack, T valueToFind, IEqualityComparer<T> comparer = null)
        {
            comparer = comparer ?? EqualityComparer<T>.Default;

            foreach (T obj in stack)
            {
                if (comparer.Equals(obj, valueToFind))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Move the stack object value to the index.
        /// </summary>
        /// <typeparam name="T">The stack object type.</typeparam>
        /// <param name="stack">The stack object.</param>
        /// <param name="valueToMove">Value to move.</param>
        /// <param name="index">The index where to move.</param>
        /// <param name="comparer">The comparison object.</param>
        public static void MoveTo<T>(this Stack<T> stack, T valueToMove, int index = 0,
            IEqualityComparer<T> comparer = null)
        {
            if (index < 0)
            {
                return;
            }

            comparer = comparer ?? EqualityComparer<T>.Default;

            var temp = new Stack<T>();
            var toMove = default(T);
            var stackCount = stack.Count;
            var count = 0;
            while (stack.Count > 0)
            {
                var value = stack.Pop();
                if (comparer.Equals(value, valueToMove))
                {
                    toMove = value;
                    break;
                }
                temp.Push(value);
                count++;
            }

            int idx = 0;
            while (stack.Count < stackCount)
            {
                if (count - idx == index)
                {
                    stack.Push(toMove);
                }
                else
                {
                    stack.Push(temp.Pop());
                }
                idx++;
            }
        }
    }
    //=======================================================================
    //
    // StatusBar.cs: a statusbar for an application
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //
    // TODO:
    //   Add mouse support

    /// <summary>
    /// <see cref="StatusItem"/> objects are contained by <see cref="StatusBar"/> <see cref="View"/>s. 
    /// Each <see cref="StatusItem"/> has a title, a shortcut (hotkey), and an <see cref="Action"/> that will be invoked when the 
    /// <see cref="StatusItem.Shortcut"/> is pressed.
    /// The <see cref="StatusItem.Shortcut"/> will be a global hotkey for the application in the current context of the screen.
    /// The colour of the <see cref="StatusItem.Title"/> will be changed after each ~ (can be customized using <see cref="HotTextSpecifier"/>).
    /// A <see cref="StatusItem.Title"/> set to `~F1~ Help` will render as *F1* using <see cref="ColorScheme.HotNormal"/> and
    /// *Help* as <see cref="ColorScheme.Normal"/>.
    /// </summary>
    public class StatusItem
    {
        //*master//
        public ScriptEngine.Machine.IValue Tag { get; set; }
        //master*//

        /// <summary>
        /// Initializes a new <see cref="StatusItem"/>.
        /// </summary>
        /// <param name="shortcut">Shortcut to activate the <see cref="StatusItem"/>.</param>
        /// <param name="title">Title for the <see cref="StatusItem"/>.</param>
        /// <param name="action">Action to invoke when the <see cref="StatusItem"/> is activated.</param>
        /// <param name="canExecute">Function to determine if the action can currently be executed.</param>
        public StatusItem(Key shortcut, ustring title, Action action, Func<bool> canExecute = null)
        {
            Title = title ?? "";
            Shortcut = shortcut;
            Action = action;
            CanExecute = canExecute;
        }

        /// <summary>
        /// Gets the global shortcut to invoke the action on the menu.
        /// </summary>
        public Key Shortcut { get; }

        /// <summary>
        /// Gets or sets the title.
        /// </summary>
        /// <value>The title.</value>
        /// <remarks>
        /// The colour of the <see cref="StatusItem.Title"/> will be changed after each ~. 
        /// A <see cref="StatusItem.Title"/> set to `~F1~ Help` will render as *F1* using <see cref="ColorScheme.HotNormal"/> and
        /// *Help* as <see cref="ColorScheme.HotNormal"/>.
        /// </remarks>
        public ustring Title { get; set; }

        /// <summary>
        /// Gets or sets the action to be invoked when the statusbar item is triggered
        /// </summary>
        /// <value>Action to invoke.</value>
        public Action Action { get; set; }

        /// <summary>
        /// Gets or sets the action to be invoked to determine if the <see cref="StatusItem"/> can be triggered. 
        /// If <see cref="CanExecute"/> returns <see langword="true"/> the status item will be enabled. Otherwise, it will be disabled.
        /// </summary>
        /// <value>Function to determine if the action is can be executed or not.</value>
        public Func<bool> CanExecute { get; set; }

        /// <summary>
        /// Gets or sets the rune that toggles the text color between <see cref="ColorScheme.Normal"/> and <see cref="ColorScheme.HotNormal"/>.
        /// The default value is '~'.
        /// Therefore, '~F1~ Help' will be rendered as 'F1' using <see cref="ColorScheme.HotNormal"/> and 'Help' using <see cref="ColorScheme.Normal"/>.
        /// In order to use '~' as part of the title (e.g., to denote the home directory as a part of the current directory),
        /// <see cref="HotTextSpecifier"/> should be changed to a different rune.
        /// </summary>
        public Rune HotTextSpecifier { get; set; } = '~';

        /// <summary>
        /// Returns <see langword="true"/> if the status item is enabled. This method is a wrapper around <see cref="CanExecute"/>.
        /// </summary>
        public bool IsEnabled()
        {
            return CanExecute == null ? true : CanExecute();
        }

        /// <summary>
        /// Gets or sets arbitrary data for the status item.
        /// </summary>
        /// <remarks>This property is not used internally.</remarks>
        public object Data { get; set; }
    };

    /// <summary>
    /// A status bar is a <see cref="View"/> that snaps to the bottom of a <see cref="Toplevel"/> displaying set of <see cref="StatusItem"/>s.
    /// The <see cref="StatusBar"/> should be context sensitive. This means, if the main menu and an open text editor are visible, the items probably shown will
    /// be ~F1~ Help ~F2~ Save ~F3~ Load. While a dialog to ask a file to load is executed, the remaining commands will probably be ~F1~ Help.
    /// So for each context must be a new instance of a statusbar.
    /// </summary>
    public class StatusBar : View
    {
        /// <summary>
        /// The items that compose the <see cref="StatusBar"/>
        /// </summary>
        public StatusItem[] Items { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="StatusBar"/> class.
        /// </summary>
        public StatusBar() : this(items: new StatusItem[] { }) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="StatusBar"/> class with the specified set of <see cref="StatusItem"/>s.
        /// The <see cref="StatusBar"/> will be drawn on the lowest line of the terminal or <see cref="View.SuperView"/> (if not null).
        /// </summary>
        /// <param name="items">A list of statusbar items.</param>
        public StatusBar(StatusItem[] items) : base()
        {
            Items = items;
            CanFocus = false;
            ColorScheme = Colors.Menu;
            X = 0;
            Y = Pos.AnchorEnd(1);
            Width = Dim.Fill();
            Height = 1;
        }

        static ustring shortcutDelimiter = "-";
        /// <summary>
        /// Used for change the shortcut delimiter separator.
        /// </summary>
        public static ustring ShortcutDelimiter
        {
            get => shortcutDelimiter;
            set
            {
                if (shortcutDelimiter != value)
                {
                    shortcutDelimiter = value == ustring.Empty ? " " : value;
                }
            }
        }

        Attribute ToggleScheme(Attribute scheme)
        {
            var result = scheme == ColorScheme.Normal ? ColorScheme.HotNormal : ColorScheme.Normal;
            Driver.SetAttribute(result);
            return result;
        }

        Attribute DetermineColorSchemeFor(StatusItem item)
        {
            if (item != null)
            {
                if (item.IsEnabled())
                {
                    return GetNormalColor();
                }
                return ColorScheme.Disabled;
            }
            return GetNormalColor();
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            Move(0, 0);
            Driver.SetAttribute(GetNormalColor());
            for (int i = 0; i < Frame.Width; i++)
                Driver.AddRune(' ');

            Move(1, 0);
            var scheme = GetNormalColor();
            Driver.SetAttribute(scheme);
            for (int i = 0; i < Items.Length; i++)
            {
                var title = Items[i].Title.ToString();
                var hotTextSpecifier = Items[i].HotTextSpecifier;
                Driver.SetAttribute(DetermineColorSchemeFor(Items[i]));
                for (int n = 0; n < Items[i].Title.RuneCount; n++)
                {
                    if (title[n] == hotTextSpecifier)
                    {
                        if (Items[i].IsEnabled())
                        {
                            scheme = ToggleScheme(scheme);
                        }
                        continue;
                    }
                    Driver.AddRune(title[n]);
                }
                if (i + 1 < Items.Length)
                {
                    Driver.AddRune(' ');
                    Driver.AddRune(Driver.VLine);
                    Driver.AddRune(' ');
                }
            }
        }

        ///<inheritdoc/>
        public override bool ProcessHotKey(KeyEvent kb)
        {
            foreach (var item in Items)
            {
                if (kb.Key == item.Shortcut)
                {
                    if (item.IsEnabled())
                    {
                        Run(item.Action);
                    }
                    return true;
                }
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (me.Flags != MouseFlags.Button1Clicked)
                return false;

            int pos = 1;
            for (int i = 0; i < Items.Length; i++)
            {
                if (me.X >= pos && me.X < pos + GetItemTitleLength(Items[i]))
                {
                    var item = Items[i];
                    if (item.IsEnabled())
                    {
                        Run(item.Action);
                    }
                    break;
                }
                pos += GetItemTitleLength(Items[i]) + 3;
            }
            return true;
        }

        int GetItemTitleLength(StatusItem item)
        {
            int len = 0;
            foreach (var ch in item.Title)
            {
                if (ch == item.HotTextSpecifier)
                    continue;
                len++;
            }

            return len;
        }

        void Run(Action action)
        {
            if (action == null)
                return;

            Application.MainLoop.AddIdle(() =>
            {
                action();
                return false;
            });
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(CursorVisibility.Invisible);

            return base.OnEnter(view);
        }

        /// <summary>
        /// Inserts a <see cref="StatusItem"/> in the specified index of <see cref="Items"/>.
        /// </summary>
        /// <param name="index">The zero-based index at which item should be inserted.</param>
        /// <param name="item">The item to insert.</param>
        public void AddItemAt(int index, StatusItem item)
        {
            var itemsList = new List<StatusItem>(Items);
            itemsList.Insert(index, item);
            Items = itemsList.ToArray();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Removes a <see cref="StatusItem"/> at specified index of <see cref="Items"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the item to remove.</param>
        /// <returns>The <see cref="StatusItem"/> removed.</returns>
        public StatusItem RemoveItem(int index)
        {
            var itemsList = new List<StatusItem>(Items);
            var item = itemsList[index];
            itemsList.RemoveAt(index);
            Items = itemsList.ToArray();
            SetNeedsDisplay();

            return item;
        }
    }
    //=======================================================================
    /// <summary>
    /// View for tabular data based on a <see cref="DataTable"/>.
    /// 
    /// <a href="https://gui-cs.github.io/Terminal.Gui/articles/tableview.html">See TableView Deep Dive for more information</a>.
    /// </summary>
    public class TableView : View
    {

        /// <summary>
        ///  Defines the event arguments for <see cref="TableView.CellActivated"/> event
        /// </summary>
        public class CellActivatedEventArgs : EventArgs
        {
            /// <summary>
            /// The current table to which the new indexes refer.  May be null e.g. if selection change is the result of clearing the table from the view
            /// </summary>
            /// <value></value>
            public DataTable Table { get; }


            /// <summary>
            /// The column index of the <see cref="Table"/> cell that is being activated
            /// </summary>
            /// <value></value>
            public int Col { get; }

            /// <summary>
            /// The row index of the <see cref="Table"/> cell that is being activated
            /// </summary>
            /// <value></value>
            public int Row { get; }

            /// <summary>
            /// Creates a new instance of arguments describing a cell being activated in <see cref="TableView"/>
            /// </summary>
            /// <param name="t"></param>
            /// <param name="col"></param>
            /// <param name="row"></param>
            public CellActivatedEventArgs(DataTable t, int col, int row)
            {
                Table = t;
                Col = col;
                Row = row;
            }
        }

        private int columnOffset;
        private int rowOffset;
        private int selectedRow;
        private int selectedColumn;
        private DataTable table;
        private TableStyle style = new TableStyle();
        private Key cellActivationKey = Key.Enter;

        Point? scrollLeftPoint;
        Point? scrollRightPoint;

        /// <summary>
        /// The default maximum cell width for <see cref="TableView.MaxCellWidth"/> and <see cref="ColumnStyle.MaxWidth"/>
        /// </summary>
        public const int DefaultMaxCellWidth = 100;


        /// <summary>
        /// The default minimum cell width for <see cref="ColumnStyle.MinAcceptableWidth"/>
        /// </summary>
        public const int DefaultMinAcceptableWidth = 100;

        /// <summary>
        /// The data table to render in the view.  Setting this property automatically updates and redraws the control.
        /// </summary>
        public DataTable Table { get => table; set { table = value; Update(); } }

        /// <summary>
        /// Contains options for changing how the table is rendered
        /// </summary>
        public TableStyle Style { get => style; set { style = value; Update(); } }

        /// <summary>
        /// True to select the entire row at once.  False to select individual cells.  Defaults to false
        /// </summary>
        public bool FullRowSelect { get; set; }

        /// <summary>
        /// True to allow regions to be selected 
        /// </summary>
        /// <value></value>
        public bool MultiSelect { get; set; } = true;

        /// <summary>
        /// When <see cref="MultiSelect"/> is enabled this property contain all rectangles of selected cells.  Rectangles describe column/rows selected in <see cref="Table"/> (not screen coordinates)
        /// </summary>
        /// <returns></returns>
        public Stack<TableSelection> MultiSelectedRegions { get; } = new Stack<TableSelection>();

        /// <summary>
        /// Horizontal scroll offset.  The index of the first column in <see cref="Table"/> to display when when rendering the view.
        /// </summary>
        /// <remarks>This property allows very wide tables to be rendered with horizontal scrolling</remarks>
        public int ColumnOffset
        {
            get => columnOffset;

            //try to prevent this being set to an out of bounds column
            set => columnOffset = TableIsNullOrInvisible() ? 0 : Math.Max(0, Math.Min(Table.Columns.Count - 1, value));
        }

        /// <summary>
        /// Vertical scroll offset.  The index of the first row in <see cref="Table"/> to display in the first non header line of the control when rendering the view.
        /// </summary>
        public int RowOffset
        {
            get => rowOffset;
            set => rowOffset = TableIsNullOrInvisible() ? 0 : Math.Max(0, Math.Min(Table.Rows.Count - 1, value));
        }

        /// <summary>
        /// The index of <see cref="DataTable.Columns"/> in <see cref="Table"/> that the user has currently selected
        /// </summary>
        public int SelectedColumn
        {
            get => selectedColumn;

            set
            {
                var oldValue = selectedColumn;

                //try to prevent this being set to an out of bounds column
                selectedColumn = TableIsNullOrInvisible() ? 0 : Math.Min(Table.Columns.Count - 1, Math.Max(0, value));

                if (oldValue != selectedColumn)
                    OnSelectedCellChanged(new SelectedCellChangedEventArgs(Table, oldValue, SelectedColumn, SelectedRow, SelectedRow));
            }
        }

        /// <summary>
        /// The index of <see cref="DataTable.Rows"/> in <see cref="Table"/> that the user has currently selected
        /// </summary>
        public int SelectedRow
        {
            get => selectedRow;
            set
            {

                var oldValue = selectedRow;

                selectedRow = TableIsNullOrInvisible() ? 0 : Math.Min(Table.Rows.Count - 1, Math.Max(0, value));

                if (oldValue != selectedRow)
                    OnSelectedCellChanged(new SelectedCellChangedEventArgs(Table, SelectedColumn, SelectedColumn, oldValue, selectedRow));
            }
        }

        /// <summary>
        /// The maximum number of characters to render in any given column.  This prevents one long column from pushing out all the others
        /// </summary>
        public int MaxCellWidth { get; set; } = DefaultMaxCellWidth;

        /// <summary>
        /// The text representation that should be rendered for cells with the value <see cref="DBNull.Value"/>
        /// </summary>
        public string NullSymbol { get; set; } = "-";

        /// <summary>
        /// The symbol to add after each cell value and header value to visually seperate values (if not using vertical gridlines)
        /// </summary>
        public char SeparatorSymbol { get; set; } = ' ';

        /// <summary>
        /// This event is raised when the selected cell in the table changes.
        /// </summary>
        public event Action<SelectedCellChangedEventArgs> SelectedCellChanged;

        /// <summary>
        /// This event is raised when a cell is activated e.g. by double clicking or pressing <see cref="CellActivationKey"/>
        /// </summary>
        public event Action<CellActivatedEventArgs> CellActivated;

        /// <summary>
        /// The key which when pressed should trigger <see cref="CellActivated"/> event.  Defaults to Enter.
        /// </summary>
        public Key CellActivationKey
        {
            get => cellActivationKey;
            set
            {
                if (cellActivationKey != value)
                {
                    ReplaceKeyBinding(cellActivationKey, value);

                    // of API user is mixing and matching old and new methods of keybinding then they may have lost
                    // the old binding (e.g. with ClearKeybindings) so ReplaceKeyBinding alone will fail
                    AddKeyBinding(value, Command.Accept);
                    cellActivationKey = value;
                }
            }
        }

        /// <summary>
        /// Initialzies a <see cref="TableView"/> class using <see cref="LayoutStyle.Computed"/> layout. 
        /// </summary>
        /// <param name="table">The table to display in the control</param>
        public TableView(DataTable table) : this()
        {
            this.Table = table;
        }

        /// <summary>
        /// Initialzies a <see cref="TableView"/> class using <see cref="LayoutStyle.Computed"/> layout. Set the <see cref="Table"/> property to begin editing
        /// </summary>
        public TableView() : base()
        {
            CanFocus = true;

            // Things this view knows how to do
            AddCommand(Command.Right, () => { ChangeSelectionByOffset(1, 0, false); return true; });
            AddCommand(Command.Left, () => { ChangeSelectionByOffset(-1, 0, false); return true; });
            AddCommand(Command.LineUp, () => { ChangeSelectionByOffset(0, -1, false); return true; });
            AddCommand(Command.LineDown, () => { ChangeSelectionByOffset(0, 1, false); return true; });
            AddCommand(Command.PageUp, () => { PageUp(false); return true; });
            AddCommand(Command.PageDown, () => { PageDown(false); return true; });
            AddCommand(Command.LeftHome, () => { ChangeSelectionToStartOfRow(false); return true; });
            AddCommand(Command.RightEnd, () => { ChangeSelectionToEndOfRow(false); return true; });
            AddCommand(Command.TopHome, () => { ChangeSelectionToStartOfTable(false); return true; });
            AddCommand(Command.BottomEnd, () => { ChangeSelectionToEndOfTable(false); return true; });

            AddCommand(Command.RightExtend, () => { ChangeSelectionByOffset(1, 0, true); return true; });
            AddCommand(Command.LeftExtend, () => { ChangeSelectionByOffset(-1, 0, true); return true; });
            AddCommand(Command.LineUpExtend, () => { ChangeSelectionByOffset(0, -1, true); return true; });
            AddCommand(Command.LineDownExtend, () => { ChangeSelectionByOffset(0, 1, true); return true; });
            AddCommand(Command.PageUpExtend, () => { PageUp(true); return true; });
            AddCommand(Command.PageDownExtend, () => { PageDown(true); return true; });
            AddCommand(Command.LeftHomeExtend, () => { ChangeSelectionToStartOfRow(true); return true; });
            AddCommand(Command.RightEndExtend, () => { ChangeSelectionToEndOfRow(true); return true; });
            AddCommand(Command.TopHomeExtend, () => { ChangeSelectionToStartOfTable(true); return true; });
            AddCommand(Command.BottomEndExtend, () => { ChangeSelectionToEndOfTable(true); return true; });

            AddCommand(Command.SelectAll, () => { SelectAll(); return true; });
            AddCommand(Command.Accept, () => { OnCellActivated(new CellActivatedEventArgs(Table, SelectedColumn, SelectedRow)); return true; });

            // Default keybindings for this view
            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.CursorDown, Command.LineDown);
            AddKeyBinding(Key.PageUp, Command.PageUp);
            AddKeyBinding(Key.PageDown, Command.PageDown);
            AddKeyBinding(Key.Home, Command.LeftHome);
            AddKeyBinding(Key.End, Command.RightEnd);
            AddKeyBinding(Key.Home | Key.CtrlMask, Command.TopHome);
            AddKeyBinding(Key.End | Key.CtrlMask, Command.BottomEnd);

            AddKeyBinding(Key.CursorLeft | Key.ShiftMask, Command.LeftExtend);
            AddKeyBinding(Key.CursorRight | Key.ShiftMask, Command.RightExtend);
            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LineUpExtend);
            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.LineDownExtend);
            AddKeyBinding(Key.PageUp | Key.ShiftMask, Command.PageUpExtend);
            AddKeyBinding(Key.PageDown | Key.ShiftMask, Command.PageDownExtend);
            AddKeyBinding(Key.Home | Key.ShiftMask, Command.LeftHomeExtend);
            AddKeyBinding(Key.End | Key.ShiftMask, Command.RightEndExtend);
            AddKeyBinding(Key.Home | Key.CtrlMask | Key.ShiftMask, Command.TopHomeExtend);
            AddKeyBinding(Key.End | Key.CtrlMask | Key.ShiftMask, Command.BottomEndExtend);

            AddKeyBinding(Key.A | Key.CtrlMask, Command.SelectAll);
            AddKeyBinding(CellActivationKey, Command.Accept);
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            Move(0, 0);
            var frame = Frame;

            scrollRightPoint = null;
            scrollLeftPoint = null;

            // What columns to render at what X offset in viewport
            var columnsToRender = CalculateViewport(bounds).ToArray();

            Driver.SetAttribute(GetNormalColor());

            //invalidate current row (prevents scrolling around leaving old characters in the frame
            Driver.AddStr(new string(' ', bounds.Width));

            int line = 0;

            if (ShouldRenderHeaders())
            {
                // Render something like:
                /*
                    ┌────────────────────┬──────────┬───────────┬──────────────┬─────────┐
                    │ArithmeticComparator│chi       │Healthboard│Interpretation│Labnumber│
                    └────────────────────┴──────────┴───────────┴──────────────┴─────────┘
                */
                if (Style.ShowHorizontalHeaderOverline)
                {
                    RenderHeaderOverline(line, bounds.Width, columnsToRender);
                    line++;
                }

                RenderHeaderMidline(line, columnsToRender);
                line++;

                if (Style.ShowHorizontalHeaderUnderline)
                {
                    RenderHeaderUnderline(line, bounds.Width, columnsToRender);
                    line++;
                }
            }

            int headerLinesConsumed = line;

            //render the cells
            for (; line < frame.Height; line++)
            {

                ClearLine(line, bounds.Width);

                //work out what Row to render
                var rowToRender = RowOffset + (line - headerLinesConsumed);

                //if we have run off the end of the table
                if (TableIsNullOrInvisible() || rowToRender >= Table.Rows.Count || rowToRender < 0)
                    continue;

                RenderRow(line, rowToRender, columnsToRender);
            }
        }

        /// <summary>
        /// Clears a line of the console by filling it with spaces
        /// </summary>
        /// <param name="row"></param>
        /// <param name="width"></param>
        private void ClearLine(int row, int width)
        {
            Move(0, row);
            Driver.SetAttribute(GetNormalColor());
            Driver.AddStr(new string(' ', width));
        }

        /// <summary>
        /// Returns the amount of vertical space currently occupied by the header or 0 if it is not visible.
        /// </summary>
        /// <returns></returns>
        private int GetHeaderHeightIfAny()
        {
            return ShouldRenderHeaders() ? GetHeaderHeight() : 0;
        }

        /// <summary>
        /// Returns the amount of vertical space required to display the header
        /// </summary>
        /// <returns></returns>
        private int GetHeaderHeight()
        {
            int heightRequired = 1;

            if (Style.ShowHorizontalHeaderOverline)
                heightRequired++;

            if (Style.ShowHorizontalHeaderUnderline)
                heightRequired++;

            return heightRequired;
        }

        private void RenderHeaderOverline(int row, int availableWidth, ColumnToRender[] columnsToRender)
        {
            // Renders a line above table headers (when visible) like:
            // ┌────────────────────┬──────────┬───────────┬──────────────┬─────────┐

            for (int c = 0; c < availableWidth; c++)
            {

                var rune = Driver.HLine;

                if (Style.ShowVerticalHeaderLines)
                {

                    if (c == 0)
                    {
                        rune = Driver.ULCorner;
                    }
                    // if the next column is the start of a header
                    else if (columnsToRender.Any(r => r.X == c + 1))
                    {
                        rune = Driver.TopTee;
                    }
                    else if (c == availableWidth - 1)
                    {
                        rune = Driver.URCorner;
                    }
                    // if the next console column is the lastcolumns end
                    else if (Style.ExpandLastColumn == false &&
                         columnsToRender.Any(r => r.IsVeryLast && r.X + r.Width - 1 == c))
                    {
                        rune = Driver.TopTee;
                    }
                }

                AddRuneAt(Driver, c, row, rune);
            }
        }

        private void RenderHeaderMidline(int row, ColumnToRender[] columnsToRender)
        {
            // Renders something like:
            // │ArithmeticComparator│chi       │Healthboard│Interpretation│Labnumber│

            ClearLine(row, Bounds.Width);

            //render start of line
            if (style.ShowVerticalHeaderLines)
                AddRune(0, row, Driver.VLine);

            for (int i = 0; i < columnsToRender.Length; i++)
            {

                var current = columnsToRender[i];

                var colStyle = Style.GetColumnStyleIfAny(current.Column);
                var colName = current.Column.ColumnName;

                RenderSeparator(current.X - 1, row, true);

                Move(current.X, row);

                Driver.AddStr(TruncateOrPad(colName, colName, current.Width, colStyle));

                if (Style.ExpandLastColumn == false && current.IsVeryLast)
                {
                    RenderSeparator(current.X + current.Width - 1, row, true);
                }
            }

            //render end of line
            if (style.ShowVerticalHeaderLines)
                AddRune(Bounds.Width - 1, row, Driver.VLine);
        }

        private void RenderHeaderUnderline(int row, int availableWidth, ColumnToRender[] columnsToRender)
        {
            /*
			 *  First lets work out if we should be rendering scroll indicators
			 */

            // are there are visible columns to the left that have been pushed
            // off the screen due to horizontal scrolling?
            bool moreColumnsToLeft = ColumnOffset > 0;

            // if we moved left would we find a new column (or are they all invisible?)
            if (!TryGetNearestVisibleColumn(ColumnOffset - 1, false, false, out _))
            {
                moreColumnsToLeft = false;
            }

            // are there visible columns to the right that have not yet been reached?
            // lets find out, what is the column index of the last column we are rendering
            int lastColumnIdxRendered = ColumnOffset + columnsToRender.Length - 1;

            // are there more valid indexes?
            bool moreColumnsToRight = lastColumnIdxRendered < Table.Columns.Count;

            // if we went right from the last column would we find a new visible column?
            if (!TryGetNearestVisibleColumn(lastColumnIdxRendered + 1, true, false, out _))
            {
                // no we would not
                moreColumnsToRight = false;
            }

            /*
			 *  Now lets draw the line itself
			 */

            // Renders a line below the table headers (when visible) like:
            // ├──────────┼───────────┼───────────────────┼──────────┼────────┼─────────────┤

            for (int c = 0; c < availableWidth; c++)
            {

                // Start by assuming we just draw a straight line the
                // whole way but update to instead draw a header indicator
                // or scroll arrow etc
                var rune = Driver.HLine;

                if (Style.ShowVerticalHeaderLines)
                {
                    if (c == 0)
                    {
                        // for first character render line
                        rune = Style.ShowVerticalCellLines ? Driver.LeftTee : Driver.LLCorner;

                        // unless we have horizontally scrolled along
                        // in which case render an arrow, to indicate user
                        // can scroll left
                        if (Style.ShowHorizontalScrollIndicators && moreColumnsToLeft)
                        {
                            rune = Driver.LeftArrow;
                            scrollLeftPoint = new Point(c, row);
                        }

                    }
                    // if the next column is the start of a header
                    else if (columnsToRender.Any(r => r.X == c + 1))
                    {

                        /*TODO: is ┼ symbol in Driver?*/
                        rune = Style.ShowVerticalCellLines ? '┼' : Driver.BottomTee;
                    }
                    else if (c == availableWidth - 1)
                    {

                        // for the last character in the table
                        rune = Style.ShowVerticalCellLines ? Driver.RightTee : Driver.LRCorner;

                        // unless there is more of the table we could horizontally
                        // scroll along to see. In which case render an arrow,
                        // to indicate user can scroll right
                        if (Style.ShowHorizontalScrollIndicators && moreColumnsToRight)
                        {
                            rune = Driver.RightArrow;
                            scrollRightPoint = new Point(c, row);
                        }

                    }
                    // if the next console column is the lastcolumns end
                    else if (Style.ExpandLastColumn == false &&
                            columnsToRender.Any(r => r.IsVeryLast && r.X + r.Width - 1 == c))
                    {
                        rune = Style.ShowVerticalCellLines ? '┼' : Driver.BottomTee;
                    }
                }

                AddRuneAt(Driver, c, row, rune);
            }

        }
        private void RenderRow(int row, int rowToRender, ColumnToRender[] columnsToRender)
        {
            var focused = HasFocus;

            var rowScheme = (Style.RowColorGetter?.Invoke(
                new RowColorGetterArgs(Table, rowToRender))) ?? ColorScheme;

            //render start of line
            if (style.ShowVerticalCellLines)
                AddRune(0, row, Driver.VLine);

            //start by clearing the entire line
            Move(0, row);

            Attribute color;

            if (FullRowSelect && IsSelected(0, rowToRender))
            {
                color = focused ? rowScheme.HotFocus : rowScheme.HotNormal;
            }
            else
            {
                color = Enabled ? rowScheme.Normal : rowScheme.Disabled;
            }

            Driver.SetAttribute(color);
            Driver.AddStr(new string(' ', Bounds.Width));

            // Render cells for each visible header for the current row
            for (int i = 0; i < columnsToRender.Length; i++)
            {

                var current = columnsToRender[i];

                var colStyle = Style.GetColumnStyleIfAny(current.Column);

                // move to start of cell (in line with header positions)
                Move(current.X, row);

                // Set color scheme based on whether the current cell is the selected one
                bool isSelectedCell = IsSelected(current.Column.Ordinal, rowToRender);

                var val = Table.Rows[rowToRender][current.Column];

                // Render the (possibly truncated) cell value
                var representation = GetRepresentation(val, colStyle);

                // to get the colour scheme
                var colorSchemeGetter = colStyle?.ColorGetter;

                ColorScheme scheme;
                if (colorSchemeGetter != null)
                {
                    // user has a delegate for defining row color per cell, call it
                    scheme = colorSchemeGetter(
                        new CellColorGetterArgs(Table, rowToRender, current.Column.Ordinal, val, representation, rowScheme));

                    // if users custom color getter returned null, use the row scheme
                    if (scheme == null)
                    {
                        scheme = rowScheme;
                    }
                }
                else
                {
                    // There is no custom cell coloring delegate so use the scheme for the row
                    scheme = rowScheme;
                }

                Attribute cellColor;
                if (isSelectedCell)
                {
                    cellColor = focused ? scheme.HotFocus : scheme.HotNormal;
                }
                else
                {
                    cellColor = Enabled ? scheme.Normal : scheme.Disabled;
                }

                var render = TruncateOrPad(val, representation, current.Width, colStyle);

                // While many cells can be selected (see MultiSelectedRegions) only one cell is the primary (drives navigation etc)
                bool isPrimaryCell = current.Column.Ordinal == selectedColumn && rowToRender == selectedRow;

                RenderCell(cellColor, render, isPrimaryCell);

                // Reset color scheme to normal for drawing separators if we drew text with custom scheme
                if (scheme != rowScheme)
                {

                    if (isSelectedCell)
                    {
                        color = focused ? rowScheme.HotFocus : rowScheme.HotNormal;
                    }
                    else
                    {
                        color = Enabled ? rowScheme.Normal : rowScheme.Disabled;
                    }
                    Driver.SetAttribute(color);
                }

                // If not in full row select mode always, reset color scheme to normal and render the vertical line (or space) at the end of the cell
                if (!FullRowSelect)
                    Driver.SetAttribute(Enabled ? rowScheme.Normal : rowScheme.Disabled);

                RenderSeparator(current.X - 1, row, false);

                if (Style.ExpandLastColumn == false && current.IsVeryLast)
                {
                    RenderSeparator(current.X + current.Width - 1, row, false);
                }
            }

            //render end of line
            if (style.ShowVerticalCellLines)
                AddRune(Bounds.Width - 1, row, Driver.VLine);
        }

        /// <summary>
        /// Override to provide custom multi colouring to cells.  Use <see cref="View.Driver"/> to
        /// with <see cref="ConsoleDriver.AddStr(ustring)"/>.  The driver will already be
        /// in the correct place when rendering and you must render the full <paramref name="render"/>
        /// or the view will not look right.  For simpler provision of color use <see cref="ColumnStyle.ColorGetter"/>
        /// For changing the content that is rendered use <see cref="ColumnStyle.RepresentationGetter"/>
        /// </summary>
        /// <param name="cellColor"></param>
        /// <param name="render"></param>
        /// <param name="isPrimaryCell"></param>
        protected virtual void RenderCell(Attribute cellColor, string render, bool isPrimaryCell)
        {
            // If the cell is the selected col/row then draw the first rune in inverted colors
            // this allows the user to track which cell is the active one during a multi cell
            // selection or in full row select mode
            if (Style.InvertSelectedCellFirstCharacter && isPrimaryCell)
            {

                if (render.Length > 0)
                {
                    // invert the color of the current cell for the first character
                    Driver.SetAttribute(Driver.MakeAttribute(cellColor.Background, cellColor.Foreground));
                    Driver.AddRune(render[0]);

                    if (render.Length > 1)
                    {
                        Driver.SetAttribute(cellColor);
                        Driver.AddStr(render.Substring(1));
                    }
                }
            }
            else
            {
                Driver.SetAttribute(cellColor);
                Driver.AddStr(render);
            }
        }

        private void RenderSeparator(int col, int row, bool isHeader)
        {
            if (col < 0)
                return;

            var renderLines = isHeader ? style.ShowVerticalHeaderLines : style.ShowVerticalCellLines;

            Rune symbol = renderLines ? Driver.VLine : SeparatorSymbol;
            AddRune(col, row, symbol);
        }

        void AddRuneAt(ConsoleDriver d, int col, int row, Rune ch)
        {
            Move(col, row);
            d.AddRune(ch);
        }

        /// <summary>
        /// Truncates or pads <paramref name="representation"/> so that it occupies a exactly <paramref name="availableHorizontalSpace"/> using the alignment specified in <paramref name="colStyle"/> (or left if no style is defined)
        /// </summary>
        /// <param name="originalCellValue">The object in this cell of the <see cref="Table"/></param>
        /// <param name="representation">The string representation of <paramref name="originalCellValue"/></param>
        /// <param name="availableHorizontalSpace"></param>
        /// <param name="colStyle">Optional style indicating custom alignment for the cell</param>
        /// <returns></returns>
        private string TruncateOrPad(object originalCellValue, string representation, int availableHorizontalSpace, ColumnStyle colStyle)
        {
            if (string.IsNullOrEmpty(representation))
                return representation;

            // if value is not wide enough
            if (representation.Sum(c => Rune.ColumnWidth(c)) < availableHorizontalSpace)
            {

                // pad it out with spaces to the given alignment
                int toPad = availableHorizontalSpace - (representation.Sum(c => Rune.ColumnWidth(c)) + 1 /*leave 1 space for cell boundary*/);

                switch (colStyle?.GetAlignment(originalCellValue) ?? TextAlignment.Left)
                {

                    case TextAlignment.Left:
                        return representation + new string(' ', toPad);
                    case TextAlignment.Right:
                        return new string(' ', toPad) + representation;

                    // TODO: With single line cells, centered and justified are the same right?
                    case TextAlignment.Centered:
                    case TextAlignment.Justified:
                        return
                            new string(' ', (int)Math.Floor(toPad / 2.0)) + // round down
                            representation +
                             new string(' ', (int)Math.Ceiling(toPad / 2.0)); // round up
                }
            }

            // value is too wide
            return new string(representation.TakeWhile(c => (availableHorizontalSpace -= Rune.ColumnWidth(c)) > 0).ToArray());
        }

        /// <inheritdoc/>
        public override bool ProcessKey(KeyEvent keyEvent)
        {
            if (TableIsNullOrInvisible())
            {
                PositionCursor();
                return false;
            }

            var result = InvokeKeybindings(keyEvent);
            if (result != null)
            {
                PositionCursor();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Moves the <see cref="SelectedRow"/> and <see cref="SelectedColumn"/> to the given col/row in <see cref="Table"/>. Optionally starting a box selection (see <see cref="MultiSelect"/>)
        /// </summary>
        /// <param name="col"></param>
        /// <param name="row"></param>
        /// <param name="extendExistingSelection">True to create a multi cell selection or adjust an existing one</param>
        public void SetSelection(int col, int row, bool extendExistingSelection)
        {
            // if we are trying to increase the column index then
            // we are moving right otherwise we are moving left
            bool lookRight = col > selectedColumn;

            col = GetNearestVisibleColumn(col, lookRight, true);

            if (!MultiSelect || !extendExistingSelection)
                MultiSelectedRegions.Clear();

            if (extendExistingSelection)
            {
                // If we are extending current selection but there isn't one
                if (MultiSelectedRegions.Count == 0)
                {
                    // Create a new region between the old active cell and the new cell
                    var rect = CreateTableSelection(SelectedColumn, SelectedRow, col, row);
                    MultiSelectedRegions.Push(rect);
                }
                else
                {
                    // Extend the current head selection to include the new cell
                    var head = MultiSelectedRegions.Pop();
                    var newRect = CreateTableSelection(head.Origin.X, head.Origin.Y, col, row);
                    MultiSelectedRegions.Push(newRect);
                }
            }

            SelectedColumn = col;
            SelectedRow = row;
        }

        /// <summary>
        /// Unions the current selected cell (and/or regions) with the provided cell and makes
        /// it the active one.
        /// </summary>
        /// <param name="col"></param>
        /// <param name="row"></param>
        private void UnionSelection(int col, int row)
        {
            if (!MultiSelect || TableIsNullOrInvisible())
            {
                return;
            }

            EnsureValidSelection();

            var oldColumn = SelectedColumn;
            var oldRow = SelectedRow;

            // move us to the new cell
            SelectedColumn = col;
            SelectedRow = row;
            MultiSelectedRegions.Push(
                CreateTableSelection(col, row)
                );

            // if the old cell was not part of a rectangular select
            // or otherwise selected we need to retain it in the selection

            if (!IsSelected(oldColumn, oldRow))
            {
                MultiSelectedRegions.Push(
                    CreateTableSelection(oldColumn, oldRow)
                    );
            }
        }


        /// <summary>
        /// Moves the <see cref="SelectedRow"/> and <see cref="SelectedColumn"/> by the provided offsets. Optionally starting a box selection (see <see cref="MultiSelect"/>)
        /// </summary>
        /// <param name="offsetX">Offset in number of columns</param>
        /// <param name="offsetY">Offset in number of rows</param>
        /// <param name="extendExistingSelection">True to create a multi cell selection or adjust an existing one</param>
        public void ChangeSelectionByOffset(int offsetX, int offsetY, bool extendExistingSelection)
        {
            SetSelection(SelectedColumn + offsetX, SelectedRow + offsetY, extendExistingSelection);
            Update();
        }

        /// <summary>
        /// Moves the selection up by one page
        /// </summary>
        /// <param name="extend">true to extend the current selection (if any) instead of replacing</param>
        public void PageUp(bool extend)
        {
            ChangeSelectionByOffset(0, -(Bounds.Height - GetHeaderHeightIfAny()), extend);
            Update();
        }

        /// <summary>
        /// Moves the selection down by one page
        /// </summary>
        /// <param name="extend">true to extend the current selection (if any) instead of replacing</param>
        public void PageDown(bool extend)
        {
            ChangeSelectionByOffset(0, Bounds.Height - GetHeaderHeightIfAny(), extend);
            Update();
        }

        /// <summary>
        /// Moves or extends the selection to the first cell in the table (0,0).
        /// If <see cref="FullRowSelect"/> is enabled then selection instead moves
        /// to (<see cref="SelectedColumn"/>,0) i.e. no horizontal scrolling.
        /// </summary>
        /// <param name="extend">true to extend the current selection (if any) instead of replacing</param>
        public void ChangeSelectionToStartOfTable(bool extend)
        {
            SetSelection(FullRowSelect ? SelectedColumn : 0, 0, extend);
            Update();
        }

        /// <summary>
        /// Moves or extends the selection to the final cell in the table (nX,nY).
        /// If <see cref="FullRowSelect"/> is enabled then selection instead moves
        /// to (<see cref="SelectedColumn"/>,nY) i.e. no horizontal scrolling.
        /// </summary>
        /// <param name="extend">true to extend the current selection (if any) instead of replacing</param>
        public void ChangeSelectionToEndOfTable(bool extend)
        {
            var finalColumn = Table.Columns.Count - 1;

            SetSelection(FullRowSelect ? SelectedColumn : finalColumn, Table.Rows.Count - 1, extend);
            Update();
        }


        /// <summary>
        /// Moves or extends the selection to the last cell in the current row
        /// </summary>
        /// <param name="extend">true to extend the current selection (if any) instead of replacing</param>
        public void ChangeSelectionToEndOfRow(bool extend)
        {
            SetSelection(Table.Columns.Count - 1, SelectedRow, extend);
            Update();
        }

        /// <summary>
        /// Moves or extends the selection to the first cell in the current row
        /// </summary>
        /// <param name="extend">true to extend the current selection (if any) instead of replacing</param>
        public void ChangeSelectionToStartOfRow(bool extend)
        {
            SetSelection(0, SelectedRow, extend);
            Update();
        }

        /// <summary>
        /// When <see cref="MultiSelect"/> is on, creates selection over all cells in the table (replacing any old selection regions)
        /// </summary>
        public void SelectAll()
        {
            if (TableIsNullOrInvisible() || !MultiSelect || Table.Rows.Count == 0)
                return;

            MultiSelectedRegions.Clear();

            // Create a single region over entire table, set the origin of the selection to the active cell so that a followup spread selection e.g. shift-right behaves properly
            MultiSelectedRegions.Push(new TableSelection(new Point(SelectedColumn, SelectedRow), new Rect(0, 0, Table.Columns.Count, table.Rows.Count)));
            Update();
        }

        /// <summary>
        /// Returns all cells in any <see cref="MultiSelectedRegions"/> (if <see cref="MultiSelect"/> is enabled) and the selected cell
        /// </summary>
        /// <remarks>Return value is not affected by <see cref="FullRowSelect"/> (i.e. returned <see cref="Point"/>s are not expanded to 
        /// include all points on row).</remarks>
        /// <returns></returns>
        public IEnumerable<Point> GetAllSelectedCells()
        {
            if (TableIsNullOrInvisible() || Table.Rows.Count == 0)
                yield break;

            EnsureValidSelection();

            // If there are one or more rectangular selections
            if (MultiSelect && MultiSelectedRegions.Any())
            {

                // Quiz any cells for whether they are selected.  For performance we only need to check those between the top left and lower right vertex of selection regions
                var yMin = MultiSelectedRegions.Min(r => r.Rect.Top);
                var yMax = MultiSelectedRegions.Max(r => r.Rect.Bottom);

                var xMin = FullRowSelect ? 0 : MultiSelectedRegions.Min(r => r.Rect.Left);
                var xMax = FullRowSelect ? Table.Columns.Count : MultiSelectedRegions.Max(r => r.Rect.Right);

                for (int y = yMin; y < yMax; y++)
                {
                    for (int x = xMin; x < xMax; x++)
                    {
                        if (IsSelected(x, y))
                        {
                            yield return new Point(x, y);
                        }
                    }
                }
            }
            else
            {

                // if there are no region selections then it is just the active cell

                // if we are selecting the full row
                if (FullRowSelect)
                {
                    // all cells in active row are selected
                    for (int x = 0; x < Table.Columns.Count; x++)
                    {
                        yield return new Point(x, SelectedRow);
                    }
                }
                else
                {
                    // Not full row select and no multi selections
                    yield return new Point(SelectedColumn, SelectedRow);
                }
            }
        }

        /// <summary>
        /// Returns a new rectangle between the two points with positive width/height regardless of relative positioning of the points.  pt1 is always considered the <see cref="TableSelection.Origin"/> point
        /// </summary>
        /// <param name="pt1X">Origin point for the selection in X</param>
        /// <param name="pt1Y">Origin point for the selection in Y</param>
        /// <param name="pt2X">End point for the selection in X</param>
        /// <param name="pt2Y">End point for the selection in Y</param>
        /// <returns></returns>
        private TableSelection CreateTableSelection(int pt1X, int pt1Y, int pt2X, int pt2Y)
        {
            var top = Math.Max(Math.Min(pt1Y, pt2Y), 0);
            var bot = Math.Max(Math.Max(pt1Y, pt2Y), 0);

            var left = Math.Max(Math.Min(pt1X, pt2X), 0);
            var right = Math.Max(Math.Max(pt1X, pt2X), 0);

            // Rect class is inclusive of Top Left but exclusive of Bottom Right so extend by 1
            return new TableSelection(new Point(pt1X, pt1Y), new Rect(left, top, right - left + 1, bot - top + 1));
        }

        /// <summary>
        /// Returns a single point as a <see cref="TableSelection"/>
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        private TableSelection CreateTableSelection(int x, int y)
        {
            return CreateTableSelection(x, y, x, y);
        }
        /// <summary>
        /// <para>
        /// Returns true if the given cell is selected either because it is the active cell or part of a multi cell selection (e.g. <see cref="FullRowSelect"/>).
        /// </para>
        /// <remarks>Returns <see langword="false"/> if <see cref="ColumnStyle.Visible"/> is <see langword="false"/>.</remarks>
        /// </summary>
        /// <param name="col"></param>
        /// <param name="row"></param>
        /// <returns></returns>
        public bool IsSelected(int col, int row)
        {
            if (!IsColumnVisible(col))
            {
                return false;
            }

            // Cell is also selected if in any multi selection region
            if (MultiSelect && MultiSelectedRegions.Any(r => r.Rect.Contains(col, row)))
                return true;

            // Cell is also selected if Y axis appears in any region (when FullRowSelect is enabled)
            if (FullRowSelect && MultiSelect && MultiSelectedRegions.Any(r => r.Rect.Bottom > row && r.Rect.Top <= row))
                return true;

            return row == SelectedRow &&
                    (col == SelectedColumn || FullRowSelect);
        }

        /// <summary>
        /// Returns true if the given <paramref name="columnIndex"/> indexes a visible
        /// column otherwise false.  Returns false for indexes that are out of bounds.
        /// </summary>
        /// <param name="columnIndex"></param>
        /// <returns></returns>
        private bool IsColumnVisible(int columnIndex)
        {
            // if the column index provided is out of bounds
            if (columnIndex < 0 || columnIndex >= table.Columns.Count)
            {
                return false;
            }

            return this.Style.GetColumnStyleIfAny(Table.Columns[columnIndex])?.Visible ?? true;
        }

        /// <summary>
        /// Positions the cursor in the area of the screen in which the start of the active cell is rendered.  Calls base implementation if active cell is not visible due to scrolling or table is loaded etc
        /// </summary>
        public override void PositionCursor()
        {
            if (TableIsNullOrInvisible())
            {
                base.PositionCursor();
                return;
            }

            var screenPoint = CellToScreen(SelectedColumn, SelectedRow);

            if (screenPoint != null)
                Move(screenPoint.Value.X, screenPoint.Value.Y);
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) && !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
                me.Flags != MouseFlags.WheeledDown && me.Flags != MouseFlags.WheeledUp &&
                me.Flags != MouseFlags.WheeledLeft && me.Flags != MouseFlags.WheeledRight)
                return false;

            if (!HasFocus && CanFocus)
            {
                SetFocus();
            }

            if (TableIsNullOrInvisible())
            {
                return false;
            }

            // Scroll wheel flags
            switch (me.Flags)
            {
                case MouseFlags.WheeledDown:
                    RowOffset++;
                    EnsureValidScrollOffsets();
                    SetNeedsDisplay();
                    return true;

                case MouseFlags.WheeledUp:
                    RowOffset--;
                    EnsureValidScrollOffsets();
                    SetNeedsDisplay();
                    return true;

                case MouseFlags.WheeledRight:
                    ColumnOffset++;
                    EnsureValidScrollOffsets();
                    SetNeedsDisplay();
                    return true;

                case MouseFlags.WheeledLeft:
                    ColumnOffset--;
                    EnsureValidScrollOffsets();
                    SetNeedsDisplay();
                    return true;
            }

            if (me.Flags.HasFlag(MouseFlags.Button1Clicked))
            {

                if (scrollLeftPoint != null
                    && scrollLeftPoint.Value.X == me.X
                    && scrollLeftPoint.Value.Y == me.Y)
                {
                    ColumnOffset--;
                    EnsureValidScrollOffsets();
                    SetNeedsDisplay();
                }

                if (scrollRightPoint != null
                    && scrollRightPoint.Value.X == me.X
                    && scrollRightPoint.Value.Y == me.Y)
                {
                    ColumnOffset++;
                    EnsureValidScrollOffsets();
                    SetNeedsDisplay();
                }

                var hit = ScreenToCell(me.X, me.Y);
                if (hit != null)
                {

                    if (MultiSelect && HasControlOrAlt(me))
                    {
                        UnionSelection(hit.Value.X, hit.Value.Y);
                    }
                    else
                    {
                        SetSelection(hit.Value.X, hit.Value.Y, me.Flags.HasFlag(MouseFlags.ButtonShift));
                    }

                    Update();
                }
            }

            // Double clicking a cell activates
            if (me.Flags == MouseFlags.Button1DoubleClicked)
            {
                var hit = ScreenToCell(me.X, me.Y);
                if (hit != null)
                {
                    OnCellActivated(new CellActivatedEventArgs(Table, hit.Value.X, hit.Value.Y));
                }
            }

            return false;
        }

        private bool HasControlOrAlt(MouseEvent me)
        {
            return me.Flags.HasFlag(MouseFlags.ButtonAlt) || me.Flags.HasFlag(MouseFlags.ButtonCtrl);
        }

        /// <summary>.
        /// Returns the column and row of <see cref="Table"/> that corresponds to a given point 
        /// on the screen (relative to the control client area).  Returns null if the point is
        /// in the header, no table is loaded or outside the control bounds.
        /// </summary>
        /// <param name="clientX">X offset from the top left of the control.</param>
        /// <param name="clientY">Y offset from the top left of the control.</param>
        /// <returns>Cell clicked or null.</returns>
        public Point? ScreenToCell(int clientX, int clientY)
        {
            return ScreenToCell(clientX, clientY, out _);
        }

        /// <inheritdoc cref="ScreenToCell(int, int)"/>
        /// <param name="clientX">X offset from the top left of the control.</param>
        /// <param name="clientY">Y offset from the top left of the control.</param>
        /// <param name="headerIfAny">If the click is in a header this is the column clicked.</param>
        public Point? ScreenToCell(int clientX, int clientY, out DataColumn headerIfAny)
        {
            headerIfAny = null;

            if (TableIsNullOrInvisible())
                return null;

            var viewPort = CalculateViewport(Bounds);

            var headerHeight = GetHeaderHeightIfAny();

            var col = viewPort.LastOrDefault(c => c.X <= clientX);

            // Click is on the header section of rendered UI
            if (clientY < headerHeight)
            {
                headerIfAny = col?.Column;
                return null;
            }


            var rowIdx = RowOffset - headerHeight + clientY;

            // if click is off bottom of the rows don't give an
            // invalid index back to user!
            if (rowIdx >= Table.Rows.Count)
            {
                return null;
            }

            if (col != null && rowIdx >= 0)
            {

                return new Point(col.Column.Ordinal, rowIdx);
            }

            return null;
        }

        /// <summary>
        /// Returns the screen position (relative to the control client area) that the given cell is rendered or null if it is outside the current scroll area or no table is loaded
        /// </summary>
        /// <param name="tableColumn">The index of the <see cref="Table"/> column you are looking for, use <see cref="DataColumn.Ordinal"/></param>
        /// <param name="tableRow">The index of the row in <see cref="Table"/> that you are looking for</param>
        /// <returns></returns>
        public Point? CellToScreen(int tableColumn, int tableRow)
        {
            if (TableIsNullOrInvisible())
                return null;

            var viewPort = CalculateViewport(Bounds);

            var headerHeight = GetHeaderHeightIfAny();

            var colHit = viewPort.FirstOrDefault(c => c.Column.Ordinal == tableColumn);

            // current column is outside the scroll area
            if (colHit == null)
                return null;

            // the cell is too far up above the current scroll area
            if (RowOffset > tableRow)
                return null;

            // the cell is way down below the scroll area and off the screen
            if (tableRow > RowOffset + (Bounds.Height - headerHeight))
                return null;

            return new Point(colHit.X, tableRow + headerHeight - RowOffset);
        }
        /// <summary>
        /// Updates the view to reflect changes to <see cref="Table"/> and to (<see cref="ColumnOffset"/> / <see cref="RowOffset"/>) etc
        /// </summary>
        /// <remarks>This always calls <see cref="View.SetNeedsDisplay()"/></remarks>
        public void Update()
        {
            if (TableIsNullOrInvisible())
            {
                SetNeedsDisplay();
                return;
            }

            EnsureValidScrollOffsets();
            EnsureValidSelection();

            EnsureSelectedCellIsVisible();

            SetNeedsDisplay();
        }

        /// <summary>
        /// Updates <see cref="ColumnOffset"/> and <see cref="RowOffset"/> where they are outside the bounds of the table (by adjusting them to the nearest existing cell).  Has no effect if <see cref="Table"/> has not been set.
        /// </summary>
        /// <remarks>Changes will not be immediately visible in the display until you call <see cref="View.SetNeedsDisplay()"/></remarks>
        public void EnsureValidScrollOffsets()
        {
            if (TableIsNullOrInvisible())
            {
                return;
            }

            ColumnOffset = Math.Max(Math.Min(ColumnOffset, Table.Columns.Count - 1), 0);
            RowOffset = Math.Max(Math.Min(RowOffset, Table.Rows.Count - 1), 0);
        }


        /// <summary>
        /// Updates <see cref="SelectedColumn"/>, <see cref="SelectedRow"/> and <see cref="MultiSelectedRegions"/> where they are outside the bounds of the table (by adjusting them to the nearest existing cell).  Has no effect if <see cref="Table"/> has not been set.
        /// </summary>
        /// <remarks>Changes will not be immediately visible in the display until you call <see cref="View.SetNeedsDisplay()"/></remarks>
        public void EnsureValidSelection()
        {
            if (TableIsNullOrInvisible())
            {

                // Table doesn't exist, we should probably clear those selections
                MultiSelectedRegions.Clear();
                return;
            }

            SelectedColumn = Math.Max(Math.Min(SelectedColumn, Table.Columns.Count - 1), 0);
            SelectedRow = Math.Max(Math.Min(SelectedRow, Table.Rows.Count - 1), 0);

            // If SelectedColumn is invisible move it to a visible one
            SelectedColumn = GetNearestVisibleColumn(SelectedColumn, lookRight: true, true);

            var oldRegions = MultiSelectedRegions.ToArray().Reverse();

            MultiSelectedRegions.Clear();

            // evaluate 
            foreach (var region in oldRegions)
            {
                // ignore regions entirely below current table state
                if (region.Rect.Top >= Table.Rows.Count)
                    continue;

                // ignore regions entirely too far right of table columns
                if (region.Rect.Left >= Table.Columns.Count)
                    continue;

                // ensure region's origin exists
                region.Origin = new Point(
                    Math.Max(Math.Min(region.Origin.X, Table.Columns.Count - 1), 0),
                    Math.Max(Math.Min(region.Origin.Y, Table.Rows.Count - 1), 0));

                // ensure regions do not go over edge of table bounds
                region.Rect = Rect.FromLTRB(region.Rect.Left,
                    region.Rect.Top,
                    Math.Max(Math.Min(region.Rect.Right, Table.Columns.Count), 0),
                    Math.Max(Math.Min(region.Rect.Bottom, Table.Rows.Count), 0)
                    );

                MultiSelectedRegions.Push(region);
            }
        }

        /// <summary>
        /// Returns true if the <see cref="Table"/> is not set or all the
        /// <see cref="DataColumn"/> in the <see cref="Table"/> have an explicit
        /// <see cref="ColumnStyle"/> that marks them <see cref="ColumnStyle.visible"/>
        /// <see langword="false"/>.
        /// </summary>
        /// <returns></returns>
        private bool TableIsNullOrInvisible()
        {
            return Table == null ||
                Table.Columns.Count <= 0 ||
                Table.Columns.Cast<DataColumn>().All(
                c => (Style.GetColumnStyleIfAny(c)?.Visible ?? true) == false);
        }

        /// <summary>
        /// Returns <paramref name="columnIndex"/> unless the <see cref="ColumnStyle.Visible"/> is false for
        /// the indexed <see cref="DataColumn"/>.  If so then the index returned is nudged to the nearest visible
        /// column.
        /// </summary>
        /// <remarks>Returns <paramref name="columnIndex"/> unchanged if it is invalid (e.g. out of bounds).</remarks>
        /// <param name="columnIndex">The input column index.</param>
        /// <param name="lookRight">When nudging invisible selections look right first.
        /// <see langword="true"/> to look right, <see langword="false"/> to look left.</param>
        /// <param name="allowBumpingInOppositeDirection">If we cannot find anything visible when
        /// looking in direction of <paramref name="lookRight"/> then should we look in the opposite
        /// direction instead? Use true if you want to push a selection to a valid index no matter what.
        /// Use false if you are primarily interested in learning about directional column visibility.</param>
        private int GetNearestVisibleColumn(int columnIndex, bool lookRight, bool allowBumpingInOppositeDirection)
        {
            if (TryGetNearestVisibleColumn(columnIndex, lookRight, allowBumpingInOppositeDirection, out var answer))
            {
                return answer;
            }

            return columnIndex;
        }

        private bool TryGetNearestVisibleColumn(int columnIndex, bool lookRight, bool allowBumpingInOppositeDirection, out int idx)
        {
            // if the column index provided is out of bounds
            if (columnIndex < 0 || columnIndex >= table.Columns.Count)
            {

                idx = columnIndex;
                return false;
            }

            // get the column visibility by index (if no style visible is true)
            bool[] columnVisibility = Table.Columns.Cast<DataColumn>()
                .Select(c => this.Style.GetColumnStyleIfAny(c)?.Visible ?? true)
                .ToArray();

            // column is visible
            if (columnVisibility[columnIndex])
            {
                idx = columnIndex;
                return true;
            }

            int increment = lookRight ? 1 : -1;

            // move in that direction
            for (int i = columnIndex; i >= 0 && i < columnVisibility.Length; i += increment)
            {
                // if we find a visible column
                if (columnVisibility[i])
                {
                    idx = i;
                    return true;
                }
            }

            // Caller only wants to look in one direction and we did not find any
            // visible columns in that direction
            if (!allowBumpingInOppositeDirection)
            {
                idx = columnIndex;
                return false;
            }

            // Caller will let us look in the other direction so
            // now look other way
            increment = -increment;

            for (int i = columnIndex; i >= 0 && i < columnVisibility.Length; i += increment)
            {
                // if we find a visible column
                if (columnVisibility[i])
                {
                    idx = i;
                    return true;
                }
            }

            // nothing seems to be visible so just return input index
            idx = columnIndex;
            return false;
        }

        /// <summary>
        /// Updates scroll offsets to ensure that the selected cell is visible.  Has no effect if <see cref="Table"/> has not been set.
        /// </summary>
        /// <remarks>Changes will not be immediately visible in the display until you call <see cref="View.SetNeedsDisplay()"/></remarks>
        public void EnsureSelectedCellIsVisible()
        {
            if (Table == null || Table.Columns.Count <= 0)
            {
                return;
            }

            var columnsToRender = CalculateViewport(Bounds).ToArray();
            var headerHeight = GetHeaderHeightIfAny();

            //if we have scrolled too far to the left 
            if (SelectedColumn < columnsToRender.Min(r => r.Column.Ordinal))
            {
                ColumnOffset = SelectedColumn;
            }

            //if we have scrolled too far to the right
            if (SelectedColumn > columnsToRender.Max(r => r.Column.Ordinal))
            {

                if (Style.SmoothHorizontalScrolling)
                {

                    // Scroll right 1 column at a time until the users selected column is visible
                    while (SelectedColumn > columnsToRender.Max(r => r.Column.Ordinal))
                    {

                        ColumnOffset++;
                        columnsToRender = CalculateViewport(Bounds).ToArray();

                        // if we are already scrolled to the last column then break
                        // this will prevent any theoretical infinite loop
                        if (ColumnOffset >= Table.Columns.Count - 1)
                            break;

                    }
                }
                else
                {
                    ColumnOffset = SelectedColumn;
                }

            }

            //if we have scrolled too far down
            if (SelectedRow >= RowOffset + (Bounds.Height - headerHeight))
            {
                RowOffset = SelectedRow - (Bounds.Height - headerHeight) + 1;
            }
            //if we have scrolled too far up
            if (SelectedRow < RowOffset)
            {
                RowOffset = SelectedRow;
            }
        }

        /// <summary>
        /// Invokes the <see cref="SelectedCellChanged"/> event
        /// </summary>
        protected virtual void OnSelectedCellChanged(SelectedCellChangedEventArgs args)
        {
            SelectedCellChanged?.Invoke(args);
        }

        /// <summary>
        /// Invokes the <see cref="CellActivated"/> event
        /// </summary>
        /// <param name="args"></param>
        protected virtual void OnCellActivated(CellActivatedEventArgs args)
        {
            CellActivated?.Invoke(args);
        }

        /// <summary>
        /// Calculates which columns should be rendered given the <paramref name="bounds"/> in which to display and the <see cref="ColumnOffset"/>
        /// </summary>
        /// <param name="bounds"></param>
        /// <param name="padding"></param>
        /// <returns></returns>
        private IEnumerable<ColumnToRender> CalculateViewport(Rect bounds, int padding = 1)
        {
            if (TableIsNullOrInvisible())
                yield break;

            int usedSpace = 0;

            //if horizontal space is required at the start of the line (before the first header)
            if (Style.ShowVerticalHeaderLines || Style.ShowVerticalCellLines)
                usedSpace += 1;

            int availableHorizontalSpace = bounds.Width;
            int rowsToRender = bounds.Height;

            // reserved for the headers row
            if (ShouldRenderHeaders())
                rowsToRender -= GetHeaderHeight();

            bool first = true;
            var lastColumn = Table.Columns.Cast<DataColumn>().Last();

            foreach (var col in Table.Columns.Cast<DataColumn>().Skip(ColumnOffset))
            {

                int startingIdxForCurrentHeader = usedSpace;
                var colStyle = Style.GetColumnStyleIfAny(col);
                int colWidth;

                // if column is not being rendered
                if (colStyle?.Visible == false)
                {
                    // do not add it to the returned columns
                    continue;
                }

                // is there enough space for this column (and it's data)?
                colWidth = CalculateMaxCellWidth(col, rowsToRender, colStyle) + padding;

                // there is not enough space for this columns 
                // visible content
                if (usedSpace + colWidth > availableHorizontalSpace)
                {
                    bool showColumn = false;

                    // if this column accepts flexible width rendering and
                    // is therefore happy rendering into less space
                    if (colStyle != null && colStyle.MinAcceptableWidth > 0 &&
                        // is there enough space to meet the MinAcceptableWidth
                        (availableHorizontalSpace - usedSpace) >= colStyle.MinAcceptableWidth)
                    {
                        // show column and use use whatever space is 
                        // left for rendering it
                        showColumn = true;
                        colWidth = availableHorizontalSpace - usedSpace;
                    }

                    // If its the only column we are able to render then
                    // accept it anyway (that must be one massively wide column!)
                    if (first)
                    {
                        showColumn = true;
                    }

                    // no special exceptions and we are out of space
                    // so stop accepting new columns for the render area
                    if (!showColumn)
                        break;
                }

                usedSpace += colWidth;

                // there is space
                yield return new ColumnToRender(col, startingIdxForCurrentHeader,
                    // required for if we end up here because first == true i.e. we have a single massive width (overspilling bounds) column to present
                    Math.Min(availableHorizontalSpace, colWidth),
                    lastColumn == col);
                first = false;
            }
        }

        private bool ShouldRenderHeaders()
        {
            if (TableIsNullOrInvisible())
                return false;

            return Style.AlwaysShowHeaders || rowOffset == 0;
        }

        /// <summary>
        /// Returns the maximum of the <paramref name="col"/> name and the maximum length of data that will be rendered starting at <see cref="RowOffset"/> and rendering <paramref name="rowsToRender"/>
        /// </summary>
        /// <param name="col"></param>
        /// <param name="rowsToRender"></param>
        /// <param name="colStyle"></param>
        /// <returns></returns>
        private int CalculateMaxCellWidth(DataColumn col, int rowsToRender, ColumnStyle colStyle)
        {
            int spaceRequired = col.ColumnName.Sum(c => Rune.ColumnWidth(c));

            // if table has no rows
            if (RowOffset < 0)
                return spaceRequired;


            for (int i = RowOffset; i < RowOffset + rowsToRender && i < Table.Rows.Count; i++)
            {

                //expand required space if cell is bigger than the last biggest cell or header
                spaceRequired = Math.Max(spaceRequired, GetRepresentation(Table.Rows[i][col], colStyle).Sum(c => Rune.ColumnWidth(c)));
            }

            // Don't require more space than the style allows
            if (colStyle != null)
            {

                // enforce maximum cell width based on style
                if (spaceRequired > colStyle.MaxWidth)
                {
                    spaceRequired = colStyle.MaxWidth;
                }

                // enforce minimum cell width based on style
                if (spaceRequired < colStyle.MinWidth)
                {
                    spaceRequired = colStyle.MinWidth;
                }
            }

            // enforce maximum cell width based on global table style
            if (spaceRequired > MaxCellWidth)
                spaceRequired = MaxCellWidth;


            return spaceRequired;
        }

        /// <summary>
        /// Returns the value that should be rendered to best represent a strongly typed <paramref name="value"/> read from <see cref="Table"/>
        /// </summary>
        /// <param name="value"></param>
        /// <param name="colStyle">Optional style defining how to represent cell values</param>
        /// <returns></returns>
        private string GetRepresentation(object value, ColumnStyle colStyle)
        {
            if (value == null || value == DBNull.Value)
            {
                return NullSymbol;
            }

            return colStyle != null ? colStyle.GetRepresentation(value) : value.ToString();
        }

        /// <summary>
        /// Delegate for providing color to <see cref="TableView"/> cells based on the value being rendered
        /// </summary>
        /// <param name="args">Contains information about the cell for which color is needed</param>
        /// <returns></returns>
        public delegate ColorScheme CellColorGetterDelegate(CellColorGetterArgs args);

        /// <summary>
        /// Delegate for providing color for a whole row of a <see cref="TableView"/>
        /// </summary>
        /// <param name="args"></param>
        /// <returns></returns>
        public delegate ColorScheme RowColorGetterDelegate(RowColorGetterArgs args);

        #region Nested Types
        /// <summary>
        /// Describes how to render a given column in  a <see cref="TableView"/> including <see cref="Alignment"/> 
        /// and textual representation of cells (e.g. date formats)
        /// 
        /// <a href="https://gui-cs.github.io/Terminal.Gui/articles/tableview.html">See TableView Deep Dive for more information</a>.
        /// </summary>
        public class ColumnStyle
        {

            /// <summary>
            /// Defines the default alignment for all values rendered in this column.  For custom alignment based on cell contents use <see cref="AlignmentGetter"/>.
            /// </summary>
            public TextAlignment Alignment { get; set; }

            /// <summary>
            /// Defines a delegate for returning custom alignment per cell based on cell values.  When specified this will override <see cref="Alignment"/>
            /// </summary>
            public Func<object, TextAlignment> AlignmentGetter;

            /// <summary>
            /// Defines a delegate for returning custom representations of cell values.  If not set then <see cref="object.ToString()"/> is used.  Return values from your delegate may be truncated e.g. based on <see cref="MaxWidth"/>
            /// </summary>
            public Func<object, string> RepresentationGetter;

            /// <summary>
            /// Defines a delegate for returning a custom color scheme per cell based on cell values.
            /// Return null for the default
            /// </summary>
            public CellColorGetterDelegate ColorGetter;
            private bool visible = true;

            /// <summary>
            /// Defines the format for values e.g. "yyyy-MM-dd" for dates
            /// </summary>
            public string Format { get; set; }

            /// <summary>
            /// Set the maximum width of the column in characters.  This value will be ignored if more than the tables <see cref="TableView.MaxCellWidth"/>.  Defaults to <see cref="TableView.DefaultMaxCellWidth"/>
            /// </summary>
            public int MaxWidth { get; set; } = TableView.DefaultMaxCellWidth;

            /// <summary>
            /// Set the minimum width of the column in characters.  Setting this will ensure that
            /// even when a column has short content/header it still fills a given width of the control.
            /// 
            /// <para>This value will be ignored if more than the tables <see cref="TableView.MaxCellWidth"/> 
            /// or the <see cref="MaxWidth"/>
            /// </para>
            /// <remarks>
            /// For setting a flexible column width (down to a lower limit) use <see cref="MinAcceptableWidth"/>
            /// instead
            /// </remarks>
            /// </summary>
            public int MinWidth { get; set; }

            /// <summary>
            /// Enables flexible sizing of this column based on available screen space to render into.
            /// </summary>
            public int MinAcceptableWidth { get; set; } = DefaultMinAcceptableWidth;

            /// <summary>
            /// Gets or Sets a value indicating whether the column should be visible to the user.
            /// This affects both whether it is rendered and whether it can be selected. Defaults to
            /// true.
            /// </summary>
            /// <remarks>If <see cref="MaxWidth"/> is 0 then <see cref="Visible"/> will always return false.</remarks>
            public bool Visible { get => MaxWidth >= 0 && visible; set => visible = value; }


            /// <summary>
            /// Returns the alignment for the cell based on <paramref name="cellValue"/> and <see cref="AlignmentGetter"/>/<see cref="Alignment"/>
            /// </summary>
            /// <param name="cellValue"></param>
            /// <returns></returns>
            public TextAlignment GetAlignment(object cellValue)
            {
                if (AlignmentGetter != null)
                    return AlignmentGetter(cellValue);

                return Alignment;
            }

            /// <summary>
            /// Returns the full string to render (which may be truncated if too long) that the current style says best represents the given <paramref name="value"/>
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            public string GetRepresentation(object value)
            {
                if (!string.IsNullOrWhiteSpace(Format))
                {

                    if (value is IFormattable f)
                        return f.ToString(Format, null);
                }


                if (RepresentationGetter != null)
                    return RepresentationGetter(value);

                return value?.ToString();
            }
        }
        /// <summary>
        /// Defines rendering options that affect how the table is displayed.
        /// 
        /// <a href="https://gui-cs.github.io/Terminal.Gui/articles/tableview.html">See TableView Deep Dive for more information</a>.
        /// </summary>
        public class TableStyle
        {

            /// <summary>
            /// When scrolling down always lock the column headers in place as the first row of the table
            /// </summary>
            public bool AlwaysShowHeaders { get; set; } = false;

            /// <summary>
            /// True to render a solid line above the headers
            /// </summary>
            public bool ShowHorizontalHeaderOverline { get; set; } = true;

            /// <summary>
            /// True to render a solid line under the headers
            /// </summary>
            public bool ShowHorizontalHeaderUnderline { get; set; } = true;

            /// <summary>
            /// True to render a solid line vertical line between cells
            /// </summary>
            public bool ShowVerticalCellLines { get; set; } = true;

            /// <summary>
            /// True to render a solid line vertical line between headers
            /// </summary>
            public bool ShowVerticalHeaderLines { get; set; } = true;

            /// <summary>
            /// True to render a arrows on the right/left of the table when 
            /// there are more column(s) that can be scrolled to.  Requires
            /// <see cref="ShowHorizontalHeaderUnderline"/> to be true.
            /// Defaults to true
            /// </summary>
            public bool ShowHorizontalScrollIndicators { get; set; } = true;

            /// <summary>
            /// True to invert the colors of the first symbol of the selected cell in the <see cref="TableView"/>.
            /// This gives the appearance of a cursor for when the <see cref="ConsoleDriver"/> doesn't otherwise show
            /// this
            /// </summary>
            public bool InvertSelectedCellFirstCharacter { get; set; } = false;

            /// <summary>
            /// Collection of columns for which you want special rendering (e.g. custom column lengths, text alignment etc)
            /// </summary>
            public Dictionary<DataColumn, ColumnStyle> ColumnStyles { get; set; } = new Dictionary<DataColumn, ColumnStyle>();

            /// <summary>
            /// Delegate for coloring specific rows in a different color.  For cell color <see cref="ColumnStyle.ColorGetter"/>
            /// </summary>
            /// <value></value>
            public RowColorGetterDelegate RowColorGetter { get; set; }

            /// <summary>
            /// Determines rendering when the last column in the table is visible but it's
            /// content or <see cref="ColumnStyle.MaxWidth"/> is less than the remaining 
            /// space in the control.  True (the default) will expand the column to fill
            /// the remaining bounds of the control.  False will draw a column ending line
            /// and leave a blank column that cannot be selected in the remaining space.  
            /// </summary>
            /// <value></value>
            public bool ExpandLastColumn { get; set; } = true;

            /// <summary>
            /// <para>
            /// Determines how <see cref="TableView.ColumnOffset"/> is updated when scrolling
            /// right off the end of the currently visible area.
            /// </para>
            /// <para>
            /// If true then when scrolling right the scroll offset is increased the minimum required to show
            /// the new column.  This may be slow if you have an incredibly large number of columns in
            /// your table and/or slow <see cref="ColumnStyle.RepresentationGetter"/> implementations
            /// </para>
            /// <para>
            /// If false then scroll offset is set to the currently selected column (i.e. PageRight).
            /// </para>
            /// </summary>
            public bool SmoothHorizontalScrolling { get; set; } = true;

            /// <summary>
            /// Returns the entry from <see cref="ColumnStyles"/> for the given <paramref name="col"/> or null if no custom styling is defined for it
            /// </summary>
            /// <param name="col"></param>
            /// <returns></returns>
            public ColumnStyle GetColumnStyleIfAny(DataColumn col)
            {
                return ColumnStyles.TryGetValue(col, out ColumnStyle result) ? result : null;
            }

            /// <summary>
            /// Returns an existing <see cref="ColumnStyle"/> for the given <paramref name="col"/> or creates a new one with default options
            /// </summary>
            /// <param name="col"></param>
            /// <returns></returns>
            public ColumnStyle GetOrCreateColumnStyle(DataColumn col)
            {
                if (!ColumnStyles.ContainsKey(col))
                    ColumnStyles.Add(col, new ColumnStyle());

                return ColumnStyles[col];
            }
        }

        /// <summary>
        /// Describes a desire to render a column at a given horizontal position in the UI
        /// </summary>
        internal class ColumnToRender
        {

            /// <summary>
            /// The column to render
            /// </summary>
            public DataColumn Column { get; set; }

            /// <summary>
            /// The horizontal position to begin rendering the column at
            /// </summary>
            public int X { get; set; }

            /// <summary>
            /// The width that the column should occupy as calculated by <see cref="CalculateViewport(Rect, int)"/>.  Note that this includes
            /// space for padding i.e. the separator between columns.
            /// </summary>
            public int Width { get; }

            /// <summary>
            /// True if this column is the very last column in the <see cref="Table"/> (not just the last visible column)
            /// </summary>
            public bool IsVeryLast { get; }

            public ColumnToRender(DataColumn col, int x, int width, bool isVeryLast)
            {
                Column = col;
                X = x;
                Width = width;
                IsVeryLast = isVeryLast;
            }

        }

        /// <summary>
        /// Arguments for a <see cref="CellColorGetterDelegate"/>.  Describes a cell for which a rendering
        /// <see cref="ColorScheme"/> is being sought
        /// </summary>
        public class CellColorGetterArgs
        {

            /// <summary>
            /// The data table hosted by the <see cref="TableView"/> control.
            /// </summary>
            public DataTable Table { get; }

            /// <summary>
            /// The index of the row in <see cref="Table"/> for which color is needed
            /// </summary>
            public int RowIndex { get; }

            /// <summary>
            /// The index of column in <see cref="Table"/> for which color is needed
            /// </summary>
            public int ColIdex { get; }

            /// <summary>
            /// The hard typed value being rendered in the cell for which color is needed
            /// </summary>
            public object CellValue { get; }

            /// <summary>
            /// The textual representation of <see cref="CellValue"/> (what will actually be drawn to the screen)
            /// </summary>
            public string Representation { get; }

            /// <summary>
            /// the color scheme that is going to be used to render the cell if no cell specific color scheme is returned
            /// </summary>
            public ColorScheme RowScheme { get; }

            internal CellColorGetterArgs(DataTable table, int rowIdx, int colIdx, object cellValue, string representation, ColorScheme rowScheme)
            {
                Table = table;
                RowIndex = rowIdx;
                ColIdex = colIdx;
                CellValue = cellValue;
                Representation = representation;
                RowScheme = rowScheme;
            }

        }

        /// <summary>
        /// Arguments for <see cref="RowColorGetterDelegate"/>. Describes a row of data in a <see cref="DataTable"/>
        /// for which <see cref="ColorScheme"/> is sought.
        /// </summary>
        public class RowColorGetterArgs
        {

            /// <summary>
            /// The data table hosted by the <see cref="TableView"/> control.
            /// </summary>
            public DataTable Table { get; }

            /// <summary>
            /// The index of the row in <see cref="Table"/> for which color is needed
            /// </summary>
            public int RowIndex { get; }

            internal RowColorGetterArgs(DataTable table, int rowIdx)
            {
                Table = table;
                RowIndex = rowIdx;
            }
        }

        /// <summary>
        /// Defines the event arguments for <see cref="TableView.SelectedCellChanged"/> 
        /// </summary>
        public class SelectedCellChangedEventArgs : EventArgs
        {
            /// <summary>
            /// The current table to which the new indexes refer.  May be null e.g. if selection change is the result of clearing the table from the view
            /// </summary>
            /// <value></value>
            public DataTable Table { get; }


            /// <summary>
            /// The previous selected column index.  May be invalid e.g. when the selection has been changed as a result of replacing the existing Table with a smaller one
            /// </summary>
            /// <value></value>
            public int OldCol { get; }


            /// <summary>
            /// The newly selected column index.
            /// </summary>
            /// <value></value>
            public int NewCol { get; }


            /// <summary>
            /// The previous selected row index.  May be invalid e.g. when the selection has been changed as a result of deleting rows from the table
            /// </summary>
            /// <value></value>
            public int OldRow { get; }


            /// <summary>
            /// The newly selected row index.
            /// </summary>
            /// <value></value>
            public int NewRow { get; }

            /// <summary>
            /// Creates a new instance of arguments describing a change in selected cell in a <see cref="TableView"/>
            /// </summary>
            /// <param name="t"></param>
            /// <param name="oldCol"></param>
            /// <param name="newCol"></param>
            /// <param name="oldRow"></param>
            /// <param name="newRow"></param>
            public SelectedCellChangedEventArgs(DataTable t, int oldCol, int newCol, int oldRow, int newRow)
            {
                Table = t;
                OldCol = oldCol;
                NewCol = newCol;
                OldRow = oldRow;
                NewRow = newRow;
            }
        }

        /// <summary>
        /// Describes a selected region of the table
        /// </summary>
        public class TableSelection
        {

            /// <summary>
            /// Corner of the <see cref="Rect"/> where selection began
            /// </summary>
            /// <value></value>
            public Point Origin { get; set; }

            /// <summary>
            /// Area selected
            /// </summary>
            /// <value></value>
            public Rect Rect { get; set; }

            /// <summary>
            /// Creates a new selected area starting at the origin corner and covering the provided rectangular area
            /// </summary>
            /// <param name="origin"></param>
            /// <param name="rect"></param>
            public TableSelection(Point origin, Rect rect)
            {
                Origin = origin;
                Rect = rect;
            }
        }
        #endregion
    }
    //=======================================================================
    /// <summary>
    /// Control that hosts multiple sub views, presenting a single one at once
    /// </summary>
    public class TabView : View
    {
        private Tab selectedTab;

        /// <summary>
        /// The default <see cref="MaxTabTextWidth"/> to set on new <see cref="TabView"/> controls
        /// </summary>
        public const uint DefaultMaxTabTextWidth = 30;

        /// <summary>
        /// This sub view is the 2 or 3 line control that represents the actual tabs themselves
        /// </summary>
        TabRowView tabsBar;

        private class TabContentView : View { }

        /// <summary>
        /// This sub view is the main client area of the current tab.  It hosts the <see cref="Tab.View"/> 
        /// of the tab, the <see cref="SelectedTab"/>
        /// </summary>
        TabContentView contentView;
        private List<Tab> tabs = new List<Tab>();

        /// <summary>
        /// All tabs currently hosted by the control
        /// </summary>
        /// <value></value>
        public IReadOnlyCollection<Tab> Tabs { get => tabs.AsReadOnly(); }

        /// <summary>
        /// When there are too many tabs to render, this indicates the first
        /// tab to render on the screen.
        /// </summary>
        /// <value></value>
        public int TabScrollOffset { get; set; }

        /// <summary>
        /// The maximum number of characters to render in a Tab header.  This prevents one long tab 
        /// from pushing out all the others.
        /// </summary>
        public uint MaxTabTextWidth { get; set; } = DefaultMaxTabTextWidth;

        /// <summary>
        /// Event for when <see cref="SelectedTab"/> changes
        /// </summary>
        public event EventHandler<TabChangedEventArgs> SelectedTabChanged;


        /// <summary>
        /// Event fired when a <see cref="TabView.Tab"/> is clicked.  Can be used to cancel navigation,
        /// show context menu (e.g. on right click) etc.
        /// </summary>
        public event EventHandler<TabMouseEventArgs> TabClicked;


        /// <summary>
        /// The currently selected member of <see cref="Tabs"/> chosen by the user
        /// </summary>
        /// <value></value>
        public Tab SelectedTab
        {
            get => selectedTab;
            set
            {

                var old = selectedTab;

                if (selectedTab != null)
                {

                    if (selectedTab.View != null)
                    {
                        // remove old content
                        if (selectedTab.View.Subviews.Count == 0)
                        {
                            contentView.Remove(selectedTab.View);
                        }
                        else
                        {
                            foreach (var view in selectedTab.View.Subviews)
                            {
                                contentView.Remove(view);
                            }
                        }
                    }
                }

                selectedTab = value;

                if (value != null)
                {

                    // add new content
                    if (selectedTab.View != null)
                    {
                        if (selectedTab.View.Subviews.Count == 0)
                        {
                            contentView.Add(selectedTab.View);
                        }
                        else
                        {
                            foreach (var view in selectedTab.View.Subviews)
                            {
                                contentView.Add(view);
                            }
                        }
                    }
                }

                EnsureSelectedTabIsVisible();

                if (old != value)
                {
                    OnSelectedTabChanged(old, value);
                }
            }
        }

        /// <summary>
        /// Render choices for how to display tabs.  After making changes, call <see cref="ApplyStyleChanges()"/>
        /// </summary>
        /// <value></value>
        public TabStyle Style { get; set; } = new TabStyle();


        /// <summary>
        /// Initializes a <see cref="TabView"/> class using <see cref="LayoutStyle.Computed"/> layout.
        /// </summary>
        public TabView() : base()
        {
            CanFocus = true;
            contentView = new TabContentView();
            tabsBar = new TabRowView(this);

            ApplyStyleChanges();

            base.Add(tabsBar);
            base.Add(contentView);

            // Things this view knows how to do
            AddCommand(Command.Left, () => { SwitchTabBy(-1); return true; });
            AddCommand(Command.Right, () => { SwitchTabBy(1); return true; });
            AddCommand(Command.LeftHome, () => { SelectedTab = Tabs.FirstOrDefault(); return true; });
            AddCommand(Command.RightEnd, () => { SelectedTab = Tabs.LastOrDefault(); return true; });


            // Default keybindings for this view
            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.Home, Command.LeftHome);
            AddKeyBinding(Key.End, Command.RightEnd);
        }

        /// <summary>
        /// Updates the control to use the latest state settings in <see cref="Style"/>.
        /// This can change the size of the client area of the tab (for rendering the 
        /// selected tab's content).  This method includes a call 
        /// to <see cref="View.SetNeedsDisplay()"/>
        /// </summary>
        public void ApplyStyleChanges()
        {
            contentView.X = Style.ShowBorder ? 1 : 0;
            contentView.Width = Dim.Fill(Style.ShowBorder ? 1 : 0);

            if (Style.TabsOnBottom)
            {
                // Tabs are along the bottom so just dodge the border
                contentView.Y = Style.ShowBorder ? 1 : 0;

                // Fill client area leaving space at bottom for tabs
                contentView.Height = Dim.Fill(GetTabHeight(false));

                var tabHeight = GetTabHeight(false);
                tabsBar.Height = tabHeight;

                tabsBar.Y = Pos.Percent(100) - tabHeight;

            }
            else
            {

                // Tabs are along the top

                var tabHeight = GetTabHeight(true);

                //move content down to make space for tabs
                contentView.Y = tabHeight;

                // Fill client area leaving space at bottom for border
                contentView.Height = Dim.Fill(Style.ShowBorder ? 1 : 0);

                // The top tab should be 2 or 3 rows high and on the top

                tabsBar.Height = tabHeight;

                // Should be able to just use 0 but switching between top/bottom tabs repeatedly breaks in ValidatePosDim if just using the absolute value 0
                tabsBar.Y = Pos.Percent(0);
            }


            SetNeedsDisplay();
        }



        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            Move(0, 0);
            Driver.SetAttribute(GetNormalColor());

            if (Style.ShowBorder)
            {

                // How much space do we need to leave at the bottom to show the tabs
                int spaceAtBottom = Math.Max(0, GetTabHeight(false) - 1);
                int startAtY = Math.Max(0, GetTabHeight(true) - 1);

                DrawFrame(new Rect(0, startAtY, bounds.Width,
                    Math.Max(bounds.Height - spaceAtBottom - startAtY, 0)), 0, true);
            }

            if (Tabs.Any())
            {
                tabsBar.Redraw(tabsBar.Bounds);
                contentView.SetNeedsDisplay();
                var savedClip = contentView.ClipToBounds();
                contentView.Redraw(contentView.Bounds);
                Driver.Clip = savedClip;
            }
        }

        /// <summary>
        /// Disposes the control and all <see cref="Tabs"/>
        /// </summary>
        /// <param name="disposing"></param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            // Manually dispose all tabs
            foreach (var tab in Tabs)
            {
                tab.View?.Dispose();
            }
        }

        /// <summary>
        /// Raises the <see cref="SelectedTabChanged"/> event
        /// </summary>
        protected virtual void OnSelectedTabChanged(Tab oldTab, Tab newTab)
        {

            SelectedTabChanged?.Invoke(this, new TabChangedEventArgs(oldTab, newTab));
        }

        /// <inheritdoc/>
        public override bool ProcessKey(KeyEvent keyEvent)
        {
            if (HasFocus && CanFocus && Focused == tabsBar)
            {
                var result = InvokeKeybindings(keyEvent);
                if (result != null)
                    return (bool)result;
            }

            return base.ProcessKey(keyEvent);
        }


        /// <summary>
        /// Changes the <see cref="SelectedTab"/> by the given <paramref name="amount"/>.  
        /// Positive for right, negative for left.  If no tab is currently selected then
        /// the first tab will become selected
        /// </summary>
        /// <param name="amount"></param>
        public void SwitchTabBy(int amount)
        {
            if (Tabs.Count == 0)
            {
                return;
            }

            // if there is only one tab anyway or nothing is selected
            if (Tabs.Count == 1 || SelectedTab == null)
            {
                SelectedTab = Tabs.ElementAt(0);
                SetNeedsDisplay();
                return;
            }

            var currentIdx = Tabs.IndexOf(SelectedTab);

            // Currently selected tab has vanished!
            if (currentIdx == -1)
            {
                SelectedTab = Tabs.ElementAt(0);
                SetNeedsDisplay();
                return;
            }

            var newIdx = Math.Max(0, Math.Min(currentIdx + amount, Tabs.Count - 1));

            SelectedTab = tabs[newIdx];
            SetNeedsDisplay();

            EnsureSelectedTabIsVisible();
        }


        /// <summary>
        /// Updates <see cref="TabScrollOffset"/> to be a valid index of <see cref="Tabs"/>
        /// </summary>
        /// <remarks>Changes will not be immediately visible in the display until you call <see cref="View.SetNeedsDisplay()"/></remarks>
        public void EnsureValidScrollOffsets()
        {
            TabScrollOffset = Math.Max(Math.Min(TabScrollOffset, Tabs.Count - 1), 0);
        }

        /// <summary>
        /// Updates <see cref="TabScrollOffset"/> to ensure that <see cref="SelectedTab"/> is visible
        /// </summary>
        public void EnsureSelectedTabIsVisible()
        {
            if (SelectedTab == null)
            {
                return;
            }

            // if current viewport does not include the selected tab
            if (!CalculateViewport(Bounds).Any(r => Equals(SelectedTab, r.Tab)))
            {

                // Set scroll offset so the first tab rendered is the
                TabScrollOffset = Math.Max(0, Tabs.IndexOf(SelectedTab));
            }
        }

        /// <summary>
        /// Returns the number of rows occupied by rendering the tabs, this depends 
        /// on <see cref="TabStyle.ShowTopLine"/> and can be 0 (e.g. if 
        /// <see cref="TabStyle.TabsOnBottom"/> and you ask for <paramref name="top"/>).
        /// </summary>
        /// <param name="top">True to measure the space required at the top of the control,
        /// false to measure space at the bottom</param>
        /// <returns></returns>
        private int GetTabHeight(bool top)
        {
            if (top && Style.TabsOnBottom)
            {
                return 0;
            }

            if (!top && !Style.TabsOnBottom)
            {
                return 0;
            }

            return Style.ShowTopLine ? 3 : 2;
        }


        /// <summary>
        /// Returns which tabs to render at each x location
        /// </summary>
        /// <returns></returns>
        private IEnumerable<TabToRender> CalculateViewport(Rect bounds)
        {
            int i = 1;

            // Starting at the first or scrolled to tab
            foreach (var tab in Tabs.Skip(TabScrollOffset))
            {

                // while there is space for the tab
                var tabTextWidth = tab.Text.Sum(c => Rune.ColumnWidth(c));

                string text = tab.Text.ToString();

                // The maximum number of characters to use for the tab name as specified
                // by the user (MaxTabTextWidth).  But not more than the width of the view
                // or we won't even be able to render a single tab!
                var maxWidth = Math.Max(0, Math.Min(bounds.Width - 3, MaxTabTextWidth));

                // if tab view is width <= 3 don't render any tabs
                if (maxWidth == 0)
                {
                    yield return new TabToRender(i, tab, string.Empty, Equals(SelectedTab, tab), 0);
                    break;
                }

                if (tabTextWidth > maxWidth)
                {
                    text = tab.Text.ToString().Substring(0, (int)maxWidth);
                    tabTextWidth = (int)maxWidth;
                }

                // if there is not enough space for this tab
                if (i + tabTextWidth >= bounds.Width)
                {
                    break;
                }

                // there is enough space!
                yield return new TabToRender(i, tab, text, Equals(SelectedTab, tab), tabTextWidth);
                i += tabTextWidth + 1;
            }
        }


        /// <summary>
        /// Adds the given <paramref name="tab"/> to <see cref="Tabs"/>
        /// </summary>
        /// <param name="tab"></param>
        /// <param name="andSelect">True to make the newly added Tab the <see cref="SelectedTab"/></param>
        public void AddTab(Tab tab, bool andSelect)
        {
            if (tabs.Contains(tab))
            {
                return;
            }


            tabs.Add(tab);

            if (SelectedTab == null || andSelect)
            {
                SelectedTab = tab;

                EnsureSelectedTabIsVisible();

                tab.View?.SetFocus();
            }

            SetNeedsDisplay();
        }


        /// <summary>
        /// Removes the given <paramref name="tab"/> from <see cref="Tabs"/>.
        /// Caller is responsible for disposing the tab's hosted <see cref="Tab.View"/>
        /// if appropriate.
        /// </summary>
        /// <param name="tab"></param>
        public void RemoveTab(Tab tab)
        {
            if (tab == null || !tabs.Contains(tab))
            {
                return;
            }

            // what tab was selected before closing
            var idx = tabs.IndexOf(tab);

            tabs.Remove(tab);

            // if the currently selected tab is no longer a member of Tabs
            if (SelectedTab == null || !Tabs.Contains(SelectedTab))
            {
                // select the tab closest to the one that disappeared
                var toSelect = Math.Max(idx - 1, 0);

                if (toSelect < Tabs.Count)
                {
                    SelectedTab = Tabs.ElementAt(toSelect);
                }
                else
                {
                    SelectedTab = Tabs.LastOrDefault();
                }

            }

            EnsureSelectedTabIsVisible();
            SetNeedsDisplay();
        }

        #region Nested Types

        private class TabToRender
        {
            public int X { get; set; }
            public Tab Tab { get; set; }

            /// <summary>
            /// True if the tab that is being rendered is the selected one
            /// </summary>
            /// <value></value>
            public bool IsSelected { get; set; }
            public int Width { get; }
            public string TextToRender { get; }

            public TabToRender(int x, Tab tab, string textToRender, bool isSelected, int width)
            {
                X = x;
                Tab = tab;
                IsSelected = isSelected;
                Width = width;
                TextToRender = textToRender;
            }
        }

        private class TabRowView : View
        {

            readonly TabView host;

            public TabRowView(TabView host)
            {
                this.host = host;

                CanFocus = true;
                Height = 1;
                Width = Dim.Fill();
            }

            public override bool OnEnter(View view)
            {
                Driver.SetCursorVisibility(CursorVisibility.Invisible);
                return base.OnEnter(view);
            }

            public override void Redraw(Rect bounds)
            {
                base.Redraw(bounds);

                var tabLocations = host.CalculateViewport(bounds).ToArray();
                var width = bounds.Width;
                Driver.SetAttribute(GetNormalColor());

                if (host.Style.ShowTopLine)
                {
                    RenderOverline(tabLocations, width);
                }

                RenderTabLine(tabLocations, width);

                RenderUnderline(tabLocations, width);
                Driver.SetAttribute(GetNormalColor());


            }

            /// <summary>
            /// Renders the line of the tabs that does not adjoin the content
            /// </summary>
            /// <param name="tabLocations"></param>
            /// <param name="width"></param>
            private void RenderOverline(TabToRender[] tabLocations, int width)
            {
                // if tabs are on the bottom draw the side of the tab that doesn't border the content area at the bottom otherwise the top
                int y = host.Style.TabsOnBottom ? 2 : 0;

                Move(0, y);

                var selected = tabLocations.FirstOrDefault(t => t.IsSelected);

                // Clear out everything
                Driver.AddStr(new string(' ', width));

                // Nothing is selected... odd but we are done
                if (selected == null)
                {
                    return;
                }


                Move(selected.X - 1, y);
                Driver.AddRune(host.Style.TabsOnBottom ? Driver.LLCorner : Driver.ULCorner);

                for (int i = 0; i < selected.Width; i++)
                {

                    if (selected.X + i > width)
                    {
                        // we ran out of space horizontally
                        return;
                    }

                    Driver.AddRune(Driver.HLine);
                }

                // Add the end of the selected tab
                Driver.AddRune(host.Style.TabsOnBottom ? Driver.LRCorner : Driver.URCorner);

            }

            /// <summary>
            /// Renders the line with the tab names in it
            /// </summary>
            /// <param name="tabLocations"></param>
            /// <param name="width"></param>
            private void RenderTabLine(TabToRender[] tabLocations, int width)
            {
                int y;

                if (host.Style.TabsOnBottom)
                {

                    y = 1;
                }
                else
                {
                    y = host.Style.ShowTopLine ? 1 : 0;
                }



                // clear any old text
                Move(0, y);
                Driver.AddStr(new string(' ', width));

                foreach (var toRender in tabLocations)
                {

                    if (toRender.IsSelected)
                    {
                        Move(toRender.X - 1, y);
                        Driver.AddRune(Driver.VLine);
                    }

                    Move(toRender.X, y);

                    // if tab is the selected one and focus is inside this control
                    if (toRender.IsSelected && host.HasFocus)
                    {

                        if (host.Focused == this)
                        {

                            // if focus is the tab bar ourself then show that they can switch tabs
                            Driver.SetAttribute(ColorScheme.HotFocus);

                        }
                        else
                        {

                            // Focus is inside the tab
                            Driver.SetAttribute(ColorScheme.HotNormal);
                        }
                    }


                    Driver.AddStr(toRender.TextToRender);
                    Driver.SetAttribute(GetNormalColor());

                    if (toRender.IsSelected)
                    {
                        Driver.AddRune(Driver.VLine);
                    }
                }
            }

            /// <summary>
            /// Renders the line of the tab that adjoins the content of the tab
            /// </summary>
            /// <param name="tabLocations"></param>
            /// <param name="width"></param>
            private void RenderUnderline(TabToRender[] tabLocations, int width)
            {
                int y = GetUnderlineYPosition();

                Move(0, y);

                // If host has no border then we need to draw the solid line first (then we draw gaps over the top)
                if (!host.Style.ShowBorder)
                {

                    for (int x = 0; x < width; x++)
                    {
                        Driver.AddRune(Driver.HLine);
                    }


                }
                var selected = tabLocations.FirstOrDefault(t => t.IsSelected);

                if (selected == null)
                {
                    return;
                }

                Move(selected.X - 1, y);

                Driver.AddRune(selected.X == 1 ? Driver.VLine :
            (host.Style.TabsOnBottom ? Driver.URCorner : Driver.LRCorner));

                Driver.AddStr(new string(' ', selected.Width));


                Driver.AddRune(selected.X + selected.Width == width - 1 ?
             Driver.VLine :
                (host.Style.TabsOnBottom ? Driver.ULCorner : Driver.LLCorner));


                // draw scroll indicators

                // if there are more tabs to the left not visible
                if (host.TabScrollOffset > 0)
                {
                    Move(0, y);

                    // indicate that
                    Driver.AddRune(Driver.LeftArrow);
                }

                // if there are more tabs to the right not visible
                if (ShouldDrawRightScrollIndicator(tabLocations))
                {
                    Move(width - 1, y);

                    // indicate that
                    Driver.AddRune(Driver.RightArrow);
                }
            }

            private bool ShouldDrawRightScrollIndicator(TabToRender[] tabLocations)
            {
                return tabLocations.LastOrDefault()?.Tab != host.Tabs.LastOrDefault();
            }

            private int GetUnderlineYPosition()
            {
                if (host.Style.TabsOnBottom)
                {

                    return 0;
                }
                else
                {

                    return host.Style.ShowTopLine ? 2 : 1;
                }
            }

            public override bool MouseEvent(MouseEvent me)
            {
                var hit = ScreenToTab(me.X, me.Y);

                bool isClick = me.Flags.HasFlag(MouseFlags.Button1Clicked) ||
                    me.Flags.HasFlag(MouseFlags.Button2Clicked) ||
                    me.Flags.HasFlag(MouseFlags.Button3Clicked);

                if (isClick)
                {
                    host.OnTabClicked(new TabMouseEventArgs(hit, me));

                    // user canceled click
                    if (me.Handled)
                    {
                        return true;
                    }
                }


                if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) &&
                !me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
                !me.Flags.HasFlag(MouseFlags.Button1TripleClicked))
                    return false;

                if (!HasFocus && CanFocus)
                {
                    SetFocus();
                }


                if (me.Flags.HasFlag(MouseFlags.Button1Clicked) ||
                me.Flags.HasFlag(MouseFlags.Button1DoubleClicked) ||
                me.Flags.HasFlag(MouseFlags.Button1TripleClicked))
                {

                    var scrollIndicatorHit = ScreenToScrollIndicator(me.X, me.Y);

                    if (scrollIndicatorHit != 0)
                    {

                        host.SwitchTabBy(scrollIndicatorHit);

                        SetNeedsDisplay();
                        return true;
                    }


                    if (hit != null)
                    {
                        host.SelectedTab = hit;
                        SetNeedsDisplay();
                        return true;
                    }
                }

                return false;
            }

            /// <summary>
            /// Calculates whether scroll indicators are visible and if so whether the click
            /// was on one of them.
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <returns>-1 for click in scroll left, 1 for scroll right or 0 for no hit</returns>
            private int ScreenToScrollIndicator(int x, int y)
            {
                // scroll indicator is showing
                if (host.TabScrollOffset > 0 && x == 0)
                {

                    return y == GetUnderlineYPosition() ? -1 : 0;
                }

                // scroll indicator is showing
                if (x == Bounds.Width - 1 && ShouldDrawRightScrollIndicator(host.CalculateViewport(Bounds).ToArray()))
                {

                    return y == GetUnderlineYPosition() ? 1 : 0;
                }

                return 0;
            }

            /// <summary>
            /// Translates the client coordinates of a click into a tab when the click is on top of a tab
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <returns></returns>
            public Tab ScreenToTab(int x, int y)
            {
                var tabs = host.CalculateViewport(Bounds);

                return tabs.LastOrDefault(t => x >= t.X && x < t.X + t.Width)?.Tab;
            }
        }

        /// <summary>
        /// Raises the <see cref="TabClicked"/> event.
        /// </summary>
        /// <param name="tabMouseEventArgs"></param>
        protected virtual private void OnTabClicked(TabMouseEventArgs tabMouseEventArgs)
        {
            TabClicked?.Invoke(this, tabMouseEventArgs);
        }

        /// <summary>
        /// Describes a mouse event over a specific <see cref="TabView.Tab"/> in a <see cref="TabView"/>.
        /// </summary>
        public class TabMouseEventArgs : EventArgs
        {

            /// <summary>
            /// Gets the <see cref="TabView.Tab"/> (if any) that the mouse
            /// was over when the <see cref="MouseEvent"/> occurred.
            /// </summary>
            /// <remarks>This will be null if the click is after last tab
            /// or before first.</remarks>
            public Tab Tab { get; }

            /// <summary>
            /// Gets the actual mouse event.  Use <see cref="MouseEvent.Handled"/> to cancel this event
            /// and perform custom behavior (e.g. show a context menu).
            /// </summary>
            public MouseEvent MouseEvent { get; }

            /// <summary>
            /// Creates a new instance of the <see cref="TabMouseEventArgs"/> class.
            /// </summary>
            /// <param name="tab"><see cref="TabView.Tab"/> that the mouse was over when the event occurred.</param>
            /// <param name="mouseEvent">The mouse activity being reported</param>
            public TabMouseEventArgs(Tab tab, MouseEvent mouseEvent)
            {
                Tab = tab;
                MouseEvent = mouseEvent;
            }
        }

        /// <summary>
        /// A single tab in a <see cref="TabView"/>
        /// </summary>
        public class Tab
        {
            private ustring text;

            /// <summary>
            /// The text to display in a <see cref="TabView"/>
            /// </summary>
            /// <value></value>
            public ustring Text { get => text ?? "Unamed"; set => text = value; }

            /// <summary>
            /// The control to display when the tab is selected
            /// </summary>
            /// <value></value>
            public View View { get; set; }

            /// <summary>
            /// Creates a new unamed tab with no controls inside
            /// </summary>
            public Tab()
            {

            }

            /// <summary>
            /// Creates a new tab with the given text hosting a view
            /// </summary>
            /// <param name="text"></param>
            /// <param name="view"></param>
            public Tab(string text, View view)
            {
                this.Text = text;
                this.View = view;
            }
        }

        /// <summary>
        /// Describes render stylistic selections of a <see cref="TabView"/>
        /// </summary>
        public class TabStyle
        {

            /// <summary>
            /// True to show the top lip of tabs.  False to directly begin with tab text during 
            /// rendering.  When true header line occupies 3 rows, when false only 2.
            /// Defaults to true.
            /// 
            /// <para>When <see cref="TabsOnBottom"/> is enabled this instead applies to the
            ///  bottommost line of the control</para>
            /// </summary> 
            public bool ShowTopLine { get; set; } = true;


            /// <summary>
            /// True to show a solid box around the edge of the control.  Defaults to true.
            /// </summary>
            public bool ShowBorder { get; set; } = true;

            /// <summary>
            /// True to render tabs at the bottom of the view instead of the top
            /// </summary>
            public bool TabsOnBottom { get; set; } = false;

        }

        /// <summary>
        /// Describes a change in <see cref="TabView.SelectedTab"/>
        /// </summary>
        public class TabChangedEventArgs : EventArgs
        {

            /// <summary>
            /// The previously selected tab. May be null
            /// </summary>
            public Tab OldTab { get; }

            /// <summary>
            /// The currently selected tab. May be null
            /// </summary>
            public Tab NewTab { get; }

            /// <summary>
            /// Documents a tab change
            /// </summary>
            /// <param name="oldTab"></param>
            /// <param name="newTab"></param>
            public TabChangedEventArgs(Tab oldTab, Tab newTab)
            {
                OldTab = oldTab;
                NewTab = newTab;
            }
        }
        #endregion
    }
    //=======================================================================
    //
    // TextField.cs: single-line text editor with Emacs keybindings
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //

    /// <summary>
    ///   Single-line text entry <see cref="View"/>
    /// </summary>
    /// <remarks>
    ///   The <see cref="TextField"/> <see cref="View"/> provides editing functionality and mouse support.
    /// </remarks>
    public class TextField : View
    {
        List<Rune> text;
        int first, point;
        int selectedStart = -1; // -1 represents there is no text selection.
        ustring selectedText;
        HistoryText historyText = new HistoryText();
        CultureInfo currentCulture;

        /// <summary>
        /// Tracks whether the text field should be considered "used", that is, that the user has moved in the entry, so new input should be appended at the cursor position, rather than clearing the entry
        /// </summary>
        public bool Used { get; set; }

        /// <summary>
        /// If set to true its not allow any changes in the text.
        /// </summary>
        public bool ReadOnly { get; set; } = false;

        /// <summary>
        /// Changing event, raised before the <see cref="Text"/> changes and can be canceled or changing the new text.
        /// </summary>
        public event Action<TextChangingEventArgs> TextChanging;

        /// <summary>
        ///   Changed event, raised when the text has changed.
        /// </summary>
        /// <remarks>
        ///   This event is raised when the <see cref="Text"/> changes. 
        /// </remarks>
        /// <remarks>
        ///   The passed <see cref="EventArgs"/> is a <see cref="ustring"/> containing the old value. 
        /// </remarks>
        public event Action<ustring> TextChanged;

        /// <summary>
        /// Initializes a new instance of the <see cref="TextField"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        /// <param name="text">Initial text contents.</param>
        public TextField(string text) : this(ustring.Make(text)) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="TextField"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        public TextField() : this(string.Empty) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="TextField"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        /// <param name="text">Initial text contents.</param>
        public TextField(ustring text) : base(text)
        {
            Initialize(text, text.RuneCount + 1);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TextField"/> class using <see cref="LayoutStyle.Absolute"/> positioning.
        /// </summary>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        /// <param name="w">The width.</param>
        /// <param name="text">Initial text contents.</param>
        public TextField(int x, int y, int w, ustring text) : base(new Rect(x, y, w, 1))
        {
            Initialize(text, w);
        }

        void Initialize(ustring text, int w)
        {
            Height = 1;

            if (text == null)
                text = "";

            this.text = TextModel.ToRunes(text.Split("\n")[0]);
            point = text.RuneCount;
            first = point > w + 1 ? point - w + 1 : 0;
            CanFocus = true;
            Used = true;
            WantMousePositionReports = true;
            savedCursorVisibility = desiredCursorVisibility;

            historyText.ChangeText += HistoryText_ChangeText;

            Initialized += TextField_Initialized;

            // Things this view knows how to do
            AddCommand(Command.DeleteCharRight, () => { DeleteCharRight(); return true; });
            AddCommand(Command.DeleteCharLeft, () => { DeleteCharLeft(); return true; });
            AddCommand(Command.LeftHomeExtend, () => { MoveHomeExtend(); return true; });
            AddCommand(Command.RightEndExtend, () => { MoveEndExtend(); return true; });
            AddCommand(Command.LeftHome, () => { MoveHome(); return true; });
            AddCommand(Command.LeftExtend, () => { MoveLeftExtend(); return true; });
            AddCommand(Command.RightExtend, () => { MoveRightExtend(); return true; });
            AddCommand(Command.WordLeftExtend, () => { MoveWordLeftExtend(); return true; });
            AddCommand(Command.WordRightExtend, () => { MoveWordRightExtend(); return true; });
            AddCommand(Command.Left, () => { MoveLeft(); return true; });
            AddCommand(Command.RightEnd, () => { MoveEnd(); return true; });
            AddCommand(Command.Right, () => { MoveRight(); return true; });
            AddCommand(Command.CutToEndLine, () => { KillToEnd(); return true; });
            AddCommand(Command.CutToStartLine, () => { KillToStart(); return true; });
            AddCommand(Command.Undo, () => { UndoChanges(); return true; });
            AddCommand(Command.Redo, () => { RedoChanges(); return true; });
            AddCommand(Command.WordLeft, () => { MoveWordLeft(); return true; });
            AddCommand(Command.WordRight, () => { MoveWordRight(); return true; });
            AddCommand(Command.KillWordForwards, () => { KillWordForwards(); return true; });
            AddCommand(Command.KillWordBackwards, () => { KillWordBackwards(); return true; });
            AddCommand(Command.ToggleOverwrite, () => { SetOverwrite(!Used); return true; });
            AddCommand(Command.EnableOverwrite, () => { SetOverwrite(true); return true; });
            AddCommand(Command.DisableOverwrite, () => { SetOverwrite(false); return true; });
            AddCommand(Command.Copy, () => { Copy(); return true; });
            AddCommand(Command.Cut, () => { Cut(); return true; });
            AddCommand(Command.Paste, () => { Paste(); return true; });
            AddCommand(Command.SelectAll, () => { SelectAll(); return true; });
            AddCommand(Command.DeleteAll, () => { DeleteAll(); return true; });
            AddCommand(Command.Accept, () => { ShowContextMenu(); return true; });

            // Default keybindings for this view
            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);

            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);

            AddKeyBinding(Key.Home | Key.ShiftMask, Command.LeftHomeExtend);
            AddKeyBinding(Key.Home | Key.ShiftMask | Key.CtrlMask, Command.LeftHomeExtend);
            AddKeyBinding(Key.A | Key.ShiftMask | Key.CtrlMask, Command.LeftHomeExtend);

            AddKeyBinding(Key.End | Key.ShiftMask, Command.RightEndExtend);
            AddKeyBinding(Key.End | Key.ShiftMask | Key.CtrlMask, Command.RightEndExtend);
            AddKeyBinding(Key.E | Key.ShiftMask | Key.CtrlMask, Command.RightEndExtend);

            AddKeyBinding(Key.Home, Command.LeftHome);
            AddKeyBinding(Key.Home | Key.CtrlMask, Command.LeftHome);
            AddKeyBinding(Key.A | Key.CtrlMask, Command.LeftHome);

            AddKeyBinding(Key.CursorLeft | Key.ShiftMask, Command.LeftExtend);
            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LeftExtend);

            AddKeyBinding(Key.CursorRight | Key.ShiftMask, Command.RightExtend);
            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.RightExtend);

            AddKeyBinding(Key.CursorLeft | Key.ShiftMask | Key.CtrlMask, Command.WordLeftExtend);
            AddKeyBinding(Key.CursorUp | Key.ShiftMask | Key.CtrlMask, Command.WordLeftExtend);
            AddKeyBinding((Key)((int)'B' + Key.ShiftMask | Key.AltMask), Command.WordLeftExtend);

            AddKeyBinding(Key.CursorRight | Key.ShiftMask | Key.CtrlMask, Command.WordRightExtend);
            AddKeyBinding(Key.CursorDown | Key.ShiftMask | Key.CtrlMask, Command.WordRightExtend);
            AddKeyBinding((Key)((int)'F' + Key.ShiftMask | Key.AltMask), Command.WordRightExtend);

            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);

            AddKeyBinding(Key.End, Command.RightEnd);
            AddKeyBinding(Key.End | Key.CtrlMask, Command.RightEnd);
            AddKeyBinding(Key.E | Key.CtrlMask, Command.RightEnd);

            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);

            AddKeyBinding(Key.K | Key.CtrlMask, Command.CutToEndLine);
            AddKeyBinding(Key.K | Key.AltMask, Command.CutToStartLine);

            AddKeyBinding(Key.Z | Key.CtrlMask, Command.Undo);
            AddKeyBinding(Key.Backspace | Key.AltMask, Command.Undo);

            AddKeyBinding(Key.Y | Key.CtrlMask, Command.Redo);

            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.WordLeft);
            AddKeyBinding(Key.CursorUp | Key.CtrlMask, Command.WordLeft);
            AddKeyBinding((Key)((int)'B' + Key.AltMask), Command.WordLeft);

            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.WordRight);
            AddKeyBinding(Key.CursorDown | Key.CtrlMask, Command.WordRight);
            AddKeyBinding((Key)((int)'F' + Key.AltMask), Command.WordRight);

            AddKeyBinding(Key.DeleteChar | Key.CtrlMask, Command.KillWordForwards);
            AddKeyBinding(Key.Backspace | Key.CtrlMask, Command.KillWordBackwards);
            AddKeyBinding(Key.InsertChar, Command.ToggleOverwrite);
            AddKeyBinding(Key.C | Key.CtrlMask, Command.Copy);
            AddKeyBinding(Key.X | Key.CtrlMask, Command.Cut);
            AddKeyBinding(Key.V | Key.CtrlMask, Command.Paste);
            AddKeyBinding(Key.T | Key.CtrlMask, Command.SelectAll);

            AddKeyBinding(Key.R | Key.CtrlMask, Command.DeleteAll);
            AddKeyBinding(Key.D | Key.CtrlMask | Key.ShiftMask, Command.DeleteAll);

            currentCulture = Thread.CurrentThread.CurrentUICulture;

            ContextMenu = new ContextMenu(this, BuildContextMenuBarItem());
            ContextMenu.KeyChanged += ContextMenu_KeyChanged;

            AddKeyBinding(ContextMenu.Key, Command.Accept);
        }

        private MenuBarItem BuildContextMenuBarItem()
        {
            return new MenuBarItem(new MenuItem[] {
                    new MenuItem (Strings.ctxSelectAll, "", () => SelectAll (), null, null, GetKeyFromCommand (Command.SelectAll)),
                    new MenuItem (Strings.ctxDeleteAll, "", () => DeleteAll (), null, null, GetKeyFromCommand (Command.DeleteAll)),
                    new MenuItem (Strings.ctxCopy, "", () => Copy (), null, null, GetKeyFromCommand (Command.Copy)),
                    new MenuItem (Strings.ctxCut, "", () => Cut (), null, null, GetKeyFromCommand (Command.Cut)),
                    new MenuItem (Strings.ctxPaste, "", () => Paste (), null, null, GetKeyFromCommand (Command.Paste)),
                    new MenuItem (Strings.ctxUndo, "", () => UndoChanges (), null, null, GetKeyFromCommand (Command.Undo)),
                    new MenuItem (Strings.ctxRedo, "", () => RedoChanges (), null, null, GetKeyFromCommand (Command.Redo)),
                });
        }

        private void ContextMenu_KeyChanged(Key obj)
        {
            ReplaceKeyBinding(obj, ContextMenu.Key);
        }

        private void HistoryText_ChangeText(HistoryText.HistoryTextItem obj)
        {
            if (obj == null)
                return;

            Text = ustring.Make(obj?.Lines[obj.CursorPosition.Y]);
            CursorPosition = obj.CursorPosition.X;
            Adjust();
        }

        void TextField_Initialized(object sender, EventArgs e)
        {
            Autocomplete.HostControl = this;
            Autocomplete.PopupInsideContainer = false;
        }

        ///<inheritdoc/>
        public override bool OnLeave(View view)
        {
            if (Application.MouseGrabView != null && Application.MouseGrabView == this)
                Application.UngrabMouse();
            //if (SelectedLength != 0 && !(Application.MouseGrabView is MenuBar))
            //	ClearAllSelection ();

            return base.OnLeave(view);
        }

        /// <summary>
        /// Provides autocomplete context menu based on suggestions at the current cursor
        /// position. Populate <see cref="Autocomplete.AllSuggestions"/> to enable this feature.
        /// </summary>
        public IAutocomplete Autocomplete { get; protected set; } = new TextFieldAutocomplete();

        ///<inheritdoc/>
        public override Rect Frame
        {
            get => base.Frame;
            set
            {
                base.Frame = value;
                Adjust();
            }
        }

        /// <summary>
        ///   Sets or gets the text held by the view.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public new ustring Text
        {
            get
            {
                return ustring.Make(text);
            }

            set
            {
                var oldText = ustring.Make(text);

                if (oldText == value)
                    return;

                var newText = OnTextChanging(value.Replace("\t", "").Split("\n")[0]);
                if (newText.Cancel)
                {
                    if (point > text.Count)
                    {
                        point = text.Count;
                    }
                    return;
                }
                ClearAllSelection();
                text = TextModel.ToRunes(newText.NewText);

                if (!Secret && !historyText.IsFromHistory)
                {
                    historyText.Add(new List<List<Rune>>() { oldText.ToRuneList() },
                        new Point(point, 0));
                    historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0)
                        , HistoryText.LineStatus.Replaced);
                }

                TextChanged?.Invoke(oldText);

                if (point > text.Count)
                {
                    point = Math.Max(TextModel.DisplaySize(text, 0).size - 1, 0);
                }

                Adjust();
                SetNeedsDisplay();
            }
        }

        /// <summary>
        ///   Sets the secret property.
        /// </summary>
        /// <remarks>
        ///   This makes the text entry suitable for entering passwords.
        /// </remarks>
        public bool Secret { get; set; }

        /// <summary>
        ///    Sets or gets the current cursor position.
        /// </summary>
        public virtual int CursorPosition
        {
            get { return point; }
            set
            {
                if (value < 0)
                {
                    point = 0;
                }
                else if (value > text.Count)
                {
                    point = text.Count;
                }
                else
                {
                    point = value;
                }
                PrepareSelection(selectedStart, point - selectedStart);
            }
        }

        /// <summary>
        /// Gets the left offset position.
        /// </summary>
        public int ScrollOffset => first;

        /// <summary>
        /// Indicates whatever the text was changed or not.
        /// <see langword="true"/> if the text was changed <see langword="false"/> otherwise.
        /// </summary>
        public bool IsDirty => historyText.IsDirty(Text);

        /// <summary>
        /// Indicates whatever the text has history changes or not.
        /// <see langword="true"/> if the text has history changes <see langword="false"/> otherwise.
        /// </summary>
        public bool HasHistoryChanges => historyText.HasHistoryChanges;

        /// <summary>
        /// Get the <see cref="ContextMenu"/> for this view.
        /// </summary>
        public ContextMenu ContextMenu { get; private set; }

        /// <summary>
        ///   Sets the cursor position.
        /// </summary>
        public override void PositionCursor()
        {
            var col = 0;
            for (int idx = first < 0 ? 0 : first; idx < text.Count; idx++)
            {
                if (idx == point)
                    break;
                var cols = Rune.ColumnWidth(text[idx]);
                TextModel.SetCol(ref col, Frame.Width - 1, cols);
            }
            var pos = point - first + Math.Min(Frame.X, 0);
            var offB = OffSetBackground();
            var containerFrame = SuperView?.ViewToScreen(SuperView.Bounds) ?? default;
            var thisFrame = ViewToScreen(Bounds);
            if (pos > -1 && col >= pos && pos < Frame.Width + offB
                && containerFrame.IntersectsWith(thisFrame))
            {
                RestoreCursorVisibility();
                Move(col, 0);
            }
            else
            {
                HideCursorVisibility();
                if (pos < 0)
                {
                    Move(pos, 0, false);
                }
                else
                {
                    Move(pos - offB, 0, false);
                }
            }
        }

        CursorVisibility savedCursorVisibility;

        void HideCursorVisibility()
        {
            if (desiredCursorVisibility != CursorVisibility.Invisible)
            {
                DesiredCursorVisibility = CursorVisibility.Invisible;
            }
        }

        void RestoreCursorVisibility()
        {
            if (desiredCursorVisibility != savedCursorVisibility)
            {
                DesiredCursorVisibility = savedCursorVisibility;
            }
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            var selColor = new Attribute(ColorScheme.Focus.Background, ColorScheme.Focus.Foreground);
            SetSelectedStartSelectedLength();

            Driver.SetAttribute(GetNormalColor());
            Move(0, 0);

            int p = first;
            int col = 0;
            int width = Frame.Width + OffSetBackground();
            var tcount = text.Count;
            var roc = GetReadOnlyColor();
            for (int idx = p; idx < tcount; idx++)
            {
                var rune = text[idx];
                var cols = Rune.ColumnWidth(rune);
                if (idx == point && HasFocus && !Used && length == 0 && !ReadOnly)
                {
                    Driver.SetAttribute(selColor);
                }
                else if (ReadOnly)
                {
                    Driver.SetAttribute(idx >= start && length > 0 && idx < start + length ? selColor : roc);
                }
                else if (!HasFocus && Enabled)
                {
                    Driver.SetAttribute(ColorScheme.Focus);
                }
                else if (!Enabled)
                {
                    Driver.SetAttribute(roc);
                }
                else
                {
                    Driver.SetAttribute(idx >= start && length > 0 && idx < start + length ? selColor : ColorScheme.Focus);
                }
                if (col + cols <= width)
                {
                    Driver.AddRune((Rune)(Secret ? '*' : rune));
                }
                if (!TextModel.SetCol(ref col, width, cols))
                {
                    break;
                }
                if (idx + 1 < tcount && col + Rune.ColumnWidth(text[idx + 1]) > width)
                {
                    break;
                }
            }

            Driver.SetAttribute(ColorScheme.Focus);
            for (int i = col; i < width; i++)
            {
                Driver.AddRune(' ');
            }

            PositionCursor();

            if (SelectedLength > 0)
                return;

            // draw autocomplete
            Autocomplete.GenerateSuggestions();

            var renderAt = new Point(
                CursorPosition - ScrollOffset, 0);

            Autocomplete.RenderOverlay(renderAt);
        }

        /// <inheritdoc/>
        public override Attribute GetNormalColor()
        {
            return Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
        }

        Attribute GetReadOnlyColor()
        {
            if (ColorScheme.Disabled.Foreground == ColorScheme.Focus.Background)
            {
                return new Attribute(ColorScheme.Focus.Foreground, ColorScheme.Focus.Background);
            }
            return new Attribute(ColorScheme.Disabled.Foreground, ColorScheme.Focus.Background);
        }

        void Adjust()
        {
            if (!IsAdded)
                return;

            int offB = OffSetBackground();
            if (point < first)
            {
                first = point;
            }
            else if (Frame.Width > 0 && (first + point - (Frame.Width + offB) == 0 ||
                TextModel.DisplaySize(text, first, point).size >= Frame.Width + offB))
            {

                first = Math.Max(TextModel.CalculateLeftColumn(text, first,
                    point, Frame.Width + offB), 0);
            }
            SetNeedsDisplay();
        }

        int OffSetBackground()
        {
            int offB = 0;
            if (SuperView?.Frame.Right - Frame.Right < 0)
            {
                offB = SuperView.Frame.Right - Frame.Right - 1;
            }

            return offB;
        }

        void SetText(List<Rune> newText)
        {
            Text = ustring.Make(newText);
        }

        void SetText(IEnumerable<Rune> newText)
        {
            SetText(newText.ToList());
        }

        ///<inheritdoc/>
        public override bool CanFocus
        {
            get => base.CanFocus;
            set { base.CanFocus = value; }
        }

        void SetClipboard(IEnumerable<Rune> text)
        {
            if (!Secret)
                Clipboard.Contents = ustring.Make(text.ToList());
        }

        int oldCursorPos;

        /// <summary>
        /// Processes key presses for the <see cref="TextField"/>.
        /// </summary>
        /// <param name="kb"></param>
        /// <returns></returns>
        /// <remarks>
        /// The <see cref="TextField"/> control responds to the following keys:
        /// <list type="table">
        ///    <listheader>
        ///        <term>Keys</term>
        ///        <description>Function</description>
        ///    </listheader>
        ///    <item>
        ///        <term><see cref="Key.Delete"/>, <see cref="Key.Backspace"/></term>
        ///        <description>Deletes the character before cursor.</description>
        ///    </item>
        /// </list>
        /// </remarks>
        public override bool ProcessKey(KeyEvent kb)
        {
            // remember current cursor position
            // because the new calculated cursor position is needed to be set BEFORE the change event is triggest
            // Needed for the Elmish Wrapper issue https://github.com/DieselMeister/Terminal.Gui.Elmish/issues/2
            oldCursorPos = point;

            // Give autocomplete first opportunity to respond to key presses
            if (SelectedLength == 0 && Autocomplete.ProcessKey(kb))
            {
                return true;
            }

            var result = InvokeKeybindings(new KeyEvent(ShortcutHelper.GetModifiersKey(kb),
                new KeyModifiers() { Alt = kb.IsAlt, Ctrl = kb.IsCtrl, Shift = kb.IsShift }));
            if (result != null)
                return (bool)result;

            // Ignore other control characters.
            if (kb.Key < Key.Space || kb.Key > Key.CharMask)
                return false;

            if (ReadOnly)
                return true;

            InsertText(kb);

            return true;
        }

        void InsertText(KeyEvent kb, bool useOldCursorPos = true)
        {
            historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0));

            List<Rune> newText = text;
            if (length > 0)
            {
                newText = DeleteSelectedText();
                oldCursorPos = point;
            }
            if (!useOldCursorPos)
            {
                oldCursorPos = point;
            }
            var kbstr = TextModel.ToRunes(ustring.Make((uint)kb.Key));
            if (Used)
            {
                point++;
                if (point == newText.Count + 1)
                {
                    SetText(newText.Concat(kbstr).ToList());
                }
                else
                {
                    if (oldCursorPos > newText.Count)
                    {
                        oldCursorPos = newText.Count;
                    }
                    SetText(newText.GetRange(0, oldCursorPos).Concat(kbstr).Concat(newText.GetRange(oldCursorPos, Math.Min(newText.Count - oldCursorPos, newText.Count))));
                }
            }
            else
            {
                SetText(newText.GetRange(0, oldCursorPos).Concat(kbstr).Concat(newText.GetRange(Math.Min(oldCursorPos + 1, newText.Count), Math.Max(newText.Count - oldCursorPos - 1, 0))));
                point++;
            }
            Adjust();
        }

        void SetOverwrite(bool overwrite)
        {
            Used = overwrite;
            SetNeedsDisplay();
        }

        /// <summary>
        /// Deletes word backwards.
        /// </summary>
        public virtual void KillWordBackwards()
        {
            ClearAllSelection();
            int bw = WordBackward(point);
            if (bw != -1)
            {
                SetText(text.GetRange(0, bw).Concat(text.GetRange(point, text.Count - point)));
                point = bw;
            }
            Adjust();
        }

        /// <summary>
        /// Deletes word forwards.
        /// </summary>
        public virtual void KillWordForwards()
        {
            ClearAllSelection();
            int fw = WordForward(point);
            if (fw != -1)
            {
                SetText(text.GetRange(0, point).Concat(text.GetRange(fw, text.Count - fw)));
            }
            Adjust();
        }

        void MoveWordRight()
        {
            ClearAllSelection();
            int fw = WordForward(point);
            if (fw != -1)
                point = fw;
            Adjust();
        }

        void MoveWordLeft()
        {
            ClearAllSelection();
            int bw = WordBackward(point);
            if (bw != -1)
                point = bw;
            Adjust();
        }

        void RedoChanges()
        {
            if (ReadOnly)
                return;

            historyText.Redo();

            //if (ustring.IsNullOrEmpty (Clipboard.Contents))
            //	return true;
            //var clip = TextModel.ToRunes (Clipboard.Contents);
            //if (clip == null)
            //	return true;

            //if (point == text.Count) {
            //	point = text.Count;
            //	SetText(text.Concat(clip).ToList());
            //} else {
            //	point += clip.Count;
            //	SetText(text.GetRange(0, oldCursorPos).Concat(clip).Concat(text.GetRange(oldCursorPos, text.Count - oldCursorPos)));
            //}
            //Adjust ();
        }

        void UndoChanges()
        {
            if (ReadOnly)
                return;

            historyText.Undo();
        }

        void KillToStart()
        {
            if (ReadOnly)
                return;

            ClearAllSelection();
            if (point == 0)
                return;
            SetClipboard(text.GetRange(0, point));
            SetText(text.GetRange(point, text.Count - point));
            point = 0;
            Adjust();
        }

        void KillToEnd()
        {
            if (ReadOnly)
                return;

            ClearAllSelection();
            if (point >= text.Count)
                return;
            SetClipboard(text.GetRange(point, text.Count - point));
            SetText(text.GetRange(0, point));
            Adjust();
        }

        void MoveRight()
        {
            ClearAllSelection();
            if (point == text.Count)
                return;
            point++;
            Adjust();
        }

        void MoveEnd()
        {
            ClearAllSelection();
            point = text.Count;
            Adjust();
        }

        void MoveLeft()
        {
            ClearAllSelection();
            if (point > 0)
            {
                point--;
                Adjust();
            }
        }

        void MoveWordRightExtend()
        {
            if (point < text.Count)
            {
                int x = start > -1 && start > point ? start : point;
                int sfw = WordForward(x);
                if (sfw != -1)
                    point = sfw;
                PrepareSelection(x, sfw - x);
            }
        }

        void MoveWordLeftExtend()
        {
            if (point > 0)
            {
                int x = Math.Min(start > -1 && start > point ? start : point, text.Count);
                if (x > 0)
                {
                    int sbw = WordBackward(x);
                    if (sbw != -1)
                        point = sbw;
                    PrepareSelection(x, sbw - x);
                }
            }
        }

        void MoveRightExtend()
        {
            if (point < text.Count)
            {
                PrepareSelection(point++, 1);
            }
        }

        void MoveLeftExtend()
        {
            if (point > 0)
            {
                PrepareSelection(point--, -1);
            }
        }

        void MoveHome()
        {
            ClearAllSelection();
            point = 0;
            Adjust();
        }

        void MoveEndExtend()
        {
            if (point <= text.Count)
            {
                int x = point;
                point = text.Count;
                PrepareSelection(x, point - x);
            }
        }

        void MoveHomeExtend()
        {
            if (point > 0)
            {
                int x = point;
                point = 0;
                PrepareSelection(x, point - x);
            }
        }

        /// <summary>
        /// Deletes the left character.
        /// </summary>
        public virtual void DeleteCharLeft(bool useOldCursorPos = true)
        {
            if (ReadOnly)
                return;

            historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0));

            if (length == 0)
            {
                if (point == 0)
                    return;

                if (!useOldCursorPos)
                {
                    oldCursorPos = point;
                }
                point--;
                if (oldCursorPos < text.Count)
                {
                    SetText(text.GetRange(0, oldCursorPos - 1).Concat(text.GetRange(oldCursorPos, text.Count - oldCursorPos)));
                }
                else
                {
                    SetText(text.GetRange(0, oldCursorPos - 1));
                }
                Adjust();
            }
            else
            {
                var newText = DeleteSelectedText();
                Text = ustring.Make(newText);
                Adjust();
            }
        }

        /// <summary>
        /// Deletes the right character.
        /// </summary>
        public virtual void DeleteCharRight()
        {
            if (ReadOnly)
                return;

            historyText.Add(new List<List<Rune>>() { text }, new Point(point, 0));

            if (length == 0)
            {
                if (text.Count == 0 || text.Count == point)
                    return;

                SetText(text.GetRange(0, point).Concat(text.GetRange(point + 1, text.Count - (point + 1))));
                Adjust();
            }
            else
            {
                var newText = DeleteSelectedText();
                Text = ustring.Make(newText);
                Adjust();
            }
        }

        int WordForward(int p)
        {
            if (p >= text.Count)
                return -1;

            int i = p + 1;
            if (i == text.Count)
                return text.Count;

            var ti = text[i];
            if (Rune.IsLetterOrDigit(ti) && Rune.IsWhiteSpace(text[p]))
                return i;

            if (Rune.IsPunctuation(ti) || Rune.IsSymbol(ti) || Rune.IsWhiteSpace(ti))
            {
                for (; i < text.Count; i++)
                {
                    if (Rune.IsLetterOrDigit(text[i]))
                        return i;
                }
            }
            else
            {
                for (; i < text.Count; i++)
                {
                    if (!Rune.IsLetterOrDigit(text[i]))
                        break;
                }
                for (; i < text.Count; i++)
                {
                    if (Rune.IsLetterOrDigit(text[i]) ||
                        (Rune.IsPunctuation(text[i]) && Rune.IsWhiteSpace(text[i - 1])))
                        break;
                }
            }

            if (i != p)
                return Math.Min(i, text.Count);

            return -1;
        }

        int WordBackward(int p)
        {
            if (p == 0)
                return -1;

            int i = p - 1;
            if (i == 0)
                return 0;

            var ti = text[i];
            var lastValidCol = -1;
            if (Rune.IsPunctuation(ti) || Rune.IsSymbol(ti) || Rune.IsWhiteSpace(ti))
            {
                for (; i >= 0; i--)
                {
                    if (Rune.IsLetterOrDigit(text[i]))
                    {
                        lastValidCol = i;
                        break;
                    }
                    if (i - 1 > 0 && !Rune.IsWhiteSpace(text[i]) && Rune.IsWhiteSpace(text[i - 1]))
                    {
                        return i;
                    }
                }
                for (; i >= 0; i--)
                {
                    if (!Rune.IsLetterOrDigit(text[i]))
                        break;
                    lastValidCol = i;
                }
                if (lastValidCol > -1)
                {
                    return lastValidCol;
                }
            }
            else
            {
                for (; i >= 0; i--)
                {
                    if (!Rune.IsLetterOrDigit(text[i]))
                        break;
                    lastValidCol = i;
                }
                if (lastValidCol > -1)
                {
                    return lastValidCol;
                }
            }

            if (i != p)
                return Math.Max(i, 0);

            return -1;
        }

        void ShowContextMenu()
        {
            if (currentCulture != Thread.CurrentThread.CurrentUICulture)
            {

                currentCulture = Thread.CurrentThread.CurrentUICulture;

                ContextMenu.MenuItems = BuildContextMenuBarItem();
            }
            ContextMenu.Show();
        }

        /// <summary>
        /// Selects all text.
        /// </summary>
        public void SelectAll()
        {
            if (text.Count == 0)
            {
                return;
            }

            selectedStart = 0;
            MoveEndExtend();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Deletes all text.
        /// </summary>
        public void DeleteAll()
        {
            if (text.Count == 0)
            {
                return;
            }

            selectedStart = 0;
            MoveEndExtend();
            DeleteCharLeft();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Start position of the selected text.
        /// </summary>
        public int SelectedStart
        {
            get => selectedStart;
            set
            {
                if (value < -1)
                {
                    selectedStart = -1;
                }
                else if (value > text.Count)
                {
                    selectedStart = text.Count;
                }
                else
                {
                    selectedStart = value;
                }
                PrepareSelection(selectedStart, point - selectedStart);
            }
        }

        /// <summary>
        /// Length of the selected text.
        /// </summary>
        public int SelectedLength { get => length; }

        /// <summary>
        /// The selected text.
        /// </summary>
        public ustring SelectedText
        {
            get => Secret ? null : selectedText;
            private set => selectedText = value;
        }

        int start, length;
        bool isButtonPressed;
        bool isButtonReleased = true;

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent ev)
        {
            if (!ev.Flags.HasFlag(MouseFlags.Button1Pressed) && !ev.Flags.HasFlag(MouseFlags.ReportMousePosition) &&
                !ev.Flags.HasFlag(MouseFlags.Button1Released) && !ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked) &&
                !ev.Flags.HasFlag(MouseFlags.Button1TripleClicked) && !ev.Flags.HasFlag(ContextMenu.MouseFlags))
            {
                return false;
            }

            if (!CanFocus)
            {
                return true;
            }

            if (!HasFocus && ev.Flags != MouseFlags.ReportMousePosition)
            {
                SetFocus();
            }

            // Give autocomplete first opportunity to respond to mouse clicks
            if (SelectedLength == 0 && Autocomplete.MouseEvent(ev, true))
            {
                return true;
            }

            if (ev.Flags == MouseFlags.Button1Pressed)
            {
                EnsureHasFocus();
                PositionCursor(ev);
                if (isButtonReleased)
                {
                    ClearAllSelection();
                }
                isButtonReleased = true;
                isButtonPressed = true;
            }
            else if (ev.Flags == (MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) && isButtonPressed)
            {
                int x = PositionCursor(ev);
                isButtonReleased = false;
                PrepareSelection(x);
                if (Application.MouseGrabView == null)
                {
                    Application.GrabMouse(this);
                }
            }
            else if (ev.Flags == MouseFlags.Button1Released)
            {
                isButtonReleased = true;
                isButtonPressed = false;
                Application.UngrabMouse();
            }
            else if (ev.Flags == MouseFlags.Button1DoubleClicked)
            {
                EnsureHasFocus();
                int x = PositionCursor(ev);
                int sbw = x;
                if (x == text.Count || (x > 0 && (char)text[x - 1] != ' ')
                    || (x > 0 && (char)text[x] == ' '))
                {

                    sbw = WordBackward(x);
                }
                if (sbw != -1)
                {
                    x = sbw;
                    PositionCursor(x);
                }
                int sfw = WordForward(x);
                ClearAllSelection();
                if (sfw != -1 && sbw != -1)
                {
                    point = sfw;
                }
                PrepareSelection(sbw, sfw - sbw);
            }
            else if (ev.Flags == MouseFlags.Button1TripleClicked)
            {
                EnsureHasFocus();
                PositionCursor(0);
                ClearAllSelection();
                PrepareSelection(0, text.Count);
            }
            else if (ev.Flags == ContextMenu.MouseFlags)
            {
                ShowContextMenu();
            }

            SetNeedsDisplay();
            return true;

            void EnsureHasFocus()
            {
                if (!HasFocus)
                {
                    SetFocus();
                }
            }
        }

        int PositionCursor(MouseEvent ev)
        {
            // We could also set the cursor position.
            int x;
            var pX = TextModel.GetColFromX(text, first, ev.X);
            if (text.Count == 0)
            {
                x = pX - ev.OfX;
            }
            else
            {
                x = pX;
            }
            return PositionCursor(x, false);
        }

        int PositionCursor(int x, bool getX = true)
        {
            int pX = x;
            if (getX)
            {
                pX = TextModel.GetColFromX(text, first, x);
            }
            if (first + pX > text.Count)
            {
                point = text.Count;
            }
            else if (first + pX < first)
            {
                point = 0;
            }
            else
            {
                point = first + pX;
            }

            return point;
        }

        void PrepareSelection(int x, int direction = 0)
        {
            x = x + first < -1 ? 0 : x;
            selectedStart = selectedStart == -1 && text.Count > 0 && x >= 0 && x <= text.Count ? x : selectedStart;
            if (selectedStart > -1)
            {
                length = Math.Abs(x + direction <= text.Count ? x + direction - selectedStart : text.Count - selectedStart);
                SetSelectedStartSelectedLength();
                if (start > -1 && length > 0)
                {
                    selectedText = length > 0 ? ustring.Make(text).ToString().Substring(
                        start < 0 ? 0 : start, length > text.Count ? text.Count : length) : "";
                    if (first > start)
                    {
                        first = start;
                    }
                }
                else if (start > -1 && length == 0)
                {
                    selectedText = null;
                }
            }
            else if (length > 0 || selectedText != null)
            {
                ClearAllSelection();
            }
            Adjust();
        }

        /// <summary>
        /// Clear the selected text.
        /// </summary>
        public void ClearAllSelection()
        {
            if (selectedStart == -1 && length == 0 && selectedText == "")
                return;

            selectedStart = -1;
            length = 0;
            selectedText = null;
            start = 0;
            length = 0;
            SetNeedsDisplay();
        }

        void SetSelectedStartSelectedLength()
        {
            if (SelectedStart > -1 && point < SelectedStart)
            {
                start = point;
            }
            else
            {
                start = SelectedStart;
            }
        }

        /// <summary>
        /// Copy the selected text to the clipboard.
        /// </summary>
        public virtual void Copy()
        {
            if (Secret || length == 0)
                return;

            Clipboard.Contents = SelectedText;
        }

        /// <summary>
        /// Cut the selected text to the clipboard.
        /// </summary>
        public virtual void Cut()
        {
            if (ReadOnly || Secret || length == 0)
                return;

            Clipboard.Contents = SelectedText;
            var newText = DeleteSelectedText();
            Text = ustring.Make(newText);
            Adjust();
        }

        List<Rune> DeleteSelectedText()
        {
            ustring actualText = Text;
            SetSelectedStartSelectedLength();
            int selStart = SelectedStart > -1 ? start : point;
            (var _, var len) = TextModel.DisplaySize(text, 0, selStart, false);
            (var _, var len2) = TextModel.DisplaySize(text, selStart, selStart + length, false);
            (var _, var len3) = TextModel.DisplaySize(text, selStart + length, actualText.RuneCount, false);
            var newText = actualText[0, len] +
                actualText[len + len2, len + len2 + len3];
            ClearAllSelection();
            point = selStart >= newText.RuneCount ? newText.RuneCount : selStart;
            return newText.ToRuneList();
        }

        /// <summary>
        /// Paste the selected text from the clipboard.
        /// </summary>
        public virtual void Paste()
        {
            if (ReadOnly || ustring.IsNullOrEmpty(Clipboard.Contents))
            {
                return;
            }

            SetSelectedStartSelectedLength();
            int selStart = start == -1 ? CursorPosition : start;
            ustring actualText = Text;
            (int _, int len) = TextModel.DisplaySize(text, 0, selStart, false);
            (var _, var len2) = TextModel.DisplaySize(text, selStart, selStart + length, false);
            (var _, var len3) = TextModel.DisplaySize(text, selStart + length, actualText.RuneCount, false);
            ustring cbTxt = Clipboard.Contents.Split("\n")[0] ?? "";
            Text = actualText[0, len] +
                cbTxt +
                actualText[len + len2, len + len2 + len3];
            point = selStart + cbTxt.RuneCount;
            ClearAllSelection();
            SetNeedsDisplay();
            Adjust();
        }

        /// <summary>
        /// Virtual method that invoke the <see cref="TextChanging"/> event if it's defined.
        /// </summary>
        /// <param name="newText">The new text to be replaced.</param>
        /// <returns>Returns the <see cref="TextChangingEventArgs"/></returns>
        public virtual TextChangingEventArgs OnTextChanging(ustring newText)
        {
            var ev = new TextChangingEventArgs(newText);
            TextChanging?.Invoke(ev);
            return ev;
        }

        CursorVisibility desiredCursorVisibility = CursorVisibility.Default;

        /// <summary>
        /// Get / Set the wished cursor when the field is focused
        /// </summary>
        public CursorVisibility DesiredCursorVisibility
        {
            get => desiredCursorVisibility;
            set
            {
                if (desiredCursorVisibility != value && HasFocus)
                {
                    Application.Driver.SetCursorVisibility(value);
                }

                desiredCursorVisibility = value;
            }
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);

            return base.OnEnter(view);
        }

        /// <summary>
        /// Inserts the given <paramref name="toAdd"/> text at the current cursor position
        /// exactly as if the user had just typed it
        /// </summary>
        /// <param name="toAdd">Text to add</param>
        /// <param name="useOldCursorPos">If uses the <see cref="oldCursorPos"/>.</param>
        public void InsertText(string toAdd, bool useOldCursorPos = true)
        {
            foreach (var ch in toAdd)
            {

                Key key;

                try
                {
                    key = (Key)ch;
                }
                catch (Exception)
                {

                    throw new ArgumentException($"Cannot insert character '{ch}' because it does not map to a Key");
                }

                InsertText(new KeyEvent() { Key = key }, useOldCursorPos);
            }
        }

        /// <summary>
        /// Allows clearing the <see cref="HistoryText.HistoryTextItem"/> items updating the original text.
        /// </summary>
        public void ClearHistoryChanges()
        {
            historyText.Clear(Text);
        }
    }

    /// <summary>
    /// An <see cref="EventArgs"/> which allows passing a cancelable new text value event.
    /// </summary>
    public class TextChangingEventArgs : EventArgs
    {
        /// <summary>
        /// The new text to be replaced.
        /// </summary>
        public ustring NewText { get; set; }
        /// <summary>
        /// Flag which allows to cancel the new text value.
        /// </summary>
        public bool Cancel { get; set; }

        /// <summary>
        /// Initializes a new instance of <see cref="TextChangingEventArgs"/>
        /// </summary>
        /// <param name="newText">The new <see cref="TextField.Text"/> to be replaced.</param>
        public TextChangingEventArgs(ustring newText)
        {
            NewText = newText;
        }
    }

    /// <summary>
    /// Renders an overlay on another view at a given point that allows selecting
    /// from a range of 'autocomplete' options.
    /// An implementation on a TextField.
    /// </summary>
    public class TextFieldAutocomplete : Autocomplete
    {

        /// <inheritdoc/>
        protected override void DeleteTextBackwards()
        {
            ((TextField)HostControl).DeleteCharLeft(false);
        }

        /// <inheritdoc/>
        protected override string GetCurrentWord(int columnOffset = 0)
        {
            var host = (TextField)HostControl;
            var currentLine = host.Text.ToRuneList();
            var cursorPosition = Math.Min(host.CursorPosition + columnOffset, currentLine.Count);
            return IdxToWord(currentLine, cursorPosition, columnOffset);
        }

        /// <inheritdoc/>
        protected override void InsertText(string accepted)
        {
            ((TextField)HostControl).InsertText(accepted, false);
        }
    }
    //=======================================================================
    /// <summary>
    /// Text alignment enumeration, controls how text is displayed.
    /// </summary>
    public enum TextAlignment
    {
        /// <summary>
        /// Aligns the text to the left of the frame.
        /// </summary>
        Left,
        /// <summary>
        /// Aligns the text to the right side of the frame.
        /// </summary>
        Right,
        /// <summary>
        /// Centers the text in the frame.
        /// </summary>
        Centered,
        /// <summary>
        /// Shows the text as justified text in the frame.
        /// </summary>
        Justified
    }

    /// <summary>
    /// Vertical text alignment enumeration, controls how text is displayed.
    /// </summary>
    public enum VerticalTextAlignment
    {
        /// <summary>
        /// Aligns the text to the top of the frame.
        /// </summary>
        Top,
        /// <summary>
        /// Aligns the text to the bottom of the frame.
        /// </summary>
        Bottom,
        /// <summary>
        /// Centers the text verticaly in the frame.
        /// </summary>
        Middle,
        /// <summary>
        /// Shows the text as justified text in the frame.
        /// </summary>
        Justified
    }

    /// TextDirection  [H] = Horizontal  [V] = Vertical
    /// =============
    /// LeftRight_TopBottom [H] Normal
    /// TopBottom_LeftRight [V] Normal
    /// 
    /// RightLeft_TopBottom [H] Invert Text
    /// TopBottom_RightLeft [V] Invert Lines
    /// 
    /// LeftRight_BottomTop [H] Invert Lines
    /// BottomTop_LeftRight [V] Invert Text
    /// 
    /// RightLeft_BottomTop [H] Invert Text + Invert Lines
    /// BottomTop_RightLeft [V] Invert Text + Invert Lines
    ///
    /// <summary>
    /// Text direction enumeration, controls how text is displayed.
    /// </summary>
    public enum TextDirection
    {
        /// <summary>
        /// Normal horizontal direction.
        /// <code>HELLO<br/>WORLD</code>
        /// </summary>
        LeftRight_TopBottom,
        /// <summary>
        /// Normal vertical direction.
        /// <code>H W<br/>E O<br/>L R<br/>L L<br/>O D</code>
        /// </summary>
        TopBottom_LeftRight,
        /// <summary>
        /// This is a horizontal direction. <br/> RTL
        /// <code>OLLEH<br/>DLROW</code>
        /// </summary>
        RightLeft_TopBottom,
        /// <summary>
        /// This is a vertical direction.
        /// <code>W H<br/>O E<br/>R L<br/>L L<br/>D O</code>
        /// </summary>
        TopBottom_RightLeft,
        /// <summary>
        /// This is a horizontal direction.
        /// <code>WORLD<br/>HELLO</code>
        /// </summary>
        LeftRight_BottomTop,
        /// <summary>
        /// This is a vertical direction.
        /// <code>O D<br/>L L<br/>L R<br/>E O<br/>H W</code>
        /// </summary>
        BottomTop_LeftRight,
        /// <summary>
        /// This is a horizontal direction.
        /// <code>DLROW<br/>OLLEH</code>
        /// </summary>
        RightLeft_BottomTop,
        /// <summary>
        /// This is a vertical direction.
        /// <code>D O<br/>L L<br/>R L<br/>O E<br/>W H</code>
        /// </summary>
        BottomTop_RightLeft
    }

    /// <summary>
    /// Provides text formatting capabilities for console apps. Supports, hotkeys, horizontal alignment, multiple lines, and word-based line wrap.
    /// </summary>
    public class TextFormatter
    {
        List<ustring> lines = new List<ustring>();
        ustring text;
        TextAlignment textAlignment;
        VerticalTextAlignment textVerticalAlignment;
        TextDirection textDirection;
        Attribute textColor = -1;
        bool needsFormat;
        Key hotKey;
        Size size;

        /// <summary>
        /// Event invoked when the <see cref="HotKey"/> is changed.
        /// </summary>
        public event Action<Key> HotKeyChanged;

        /// <summary>
        ///   The text to be displayed. This text is never modified.
        /// </summary>
        public virtual ustring Text
        {
            get => text;
            set
            {
                text = value;

                if (text != null && text.RuneCount > 0 && (Size.Width == 0 || Size.Height == 0 || Size.Width != text.ConsoleWidth))
                {
                    // Provide a default size (width = length of longest line, height = 1)
                    // TODO: It might makes more sense for the default to be width = length of first line?
                    Size = new Size(TextFormatter.MaxWidth(Text, int.MaxValue), 1);
                }

                NeedsFormat = true;
            }
        }

        /// <summary>
        /// Used by <see cref="Text"/> to resize the view's <see cref="View.Bounds"/> with the <see cref="Size"/>.
        /// Setting <see cref="AutoSize"/> to true only work if the <see cref="View.Width"/> and <see cref="View.Height"/> are null or
        ///   <see cref="LayoutStyle.Absolute"/> values and doesn't work with <see cref="LayoutStyle.Computed"/> layout,
        ///   to avoid breaking the <see cref="Pos"/> and <see cref="Dim"/> settings.
        /// </summary>
        public bool AutoSize { get; set; }

        /// <summary>
        /// Gets or sets a flag that determines whether <see cref="Text"/> will have trailing spaces preserved
        /// or not when <see cref="WordWrap"/> is enabled. If `true` any trailing spaces will be trimmed when
        /// either the <see cref="Text"/> property is changed or when <see cref="WordWrap"/> is set to `true`.
        /// The default is `false`.
        /// </summary>
        public bool PreserveTrailingSpaces { get; set; }

        /// <summary>
        /// Controls the horizontal text-alignment property.
        /// </summary>
        /// <value>The text alignment.</value>
        public TextAlignment Alignment
        {
            get => textAlignment;
            set
            {
                textAlignment = value;
                NeedsFormat = true;
            }
        }

        /// <summary>
        /// Controls the vertical text-alignment property. 
        /// </summary>
        /// <value>The text vertical alignment.</value>
        public VerticalTextAlignment VerticalAlignment
        {
            get => textVerticalAlignment;
            set
            {
                textVerticalAlignment = value;
                NeedsFormat = true;
            }
        }

        /// <summary>
        /// Controls the text-direction property. 
        /// </summary>
        /// <value>The text vertical alignment.</value>
        public TextDirection Direction
        {
            get => textDirection;
            set
            {
                textDirection = value;
                NeedsFormat = true;
            }
        }

        /// <summary>
        /// Check if it is a horizontal direction
        /// </summary>
        public static bool IsHorizontalDirection(TextDirection textDirection)
        {
            switch (textDirection)
            {
                case TextDirection.LeftRight_TopBottom:
                case TextDirection.LeftRight_BottomTop:
                case TextDirection.RightLeft_TopBottom:
                case TextDirection.RightLeft_BottomTop:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Check if it is a vertical direction
        /// </summary>
        public static bool IsVerticalDirection(TextDirection textDirection)
        {
            switch (textDirection)
            {
                case TextDirection.TopBottom_LeftRight:
                case TextDirection.TopBottom_RightLeft:
                case TextDirection.BottomTop_LeftRight:
                case TextDirection.BottomTop_RightLeft:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Check if it is Left to Right direction
        /// </summary>
        public static bool IsLeftToRight(TextDirection textDirection)
        {
            switch (textDirection)
            {
                case TextDirection.LeftRight_TopBottom:
                case TextDirection.LeftRight_BottomTop:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Check if it is Top to Bottom direction
        /// </summary>
        public static bool IsTopToBottom(TextDirection textDirection)
        {
            switch (textDirection)
            {
                case TextDirection.TopBottom_LeftRight:
                case TextDirection.TopBottom_RightLeft:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        ///  Gets or sets the size of the area the text will be constrained to when formatted.
        /// </summary>
        public Size Size
        {
            get => size;
            set
            {
                size = value;
                NeedsFormat = true;
            }
        }

        /// <summary>
        /// The specifier character for the hotkey (e.g. '_'). Set to '\xffff' to disable hotkey support for this View instance. The default is '\xffff'.
        /// </summary>
        public Rune HotKeySpecifier { get; set; } = (Rune)0xFFFF;

        /// <summary>
        /// The position in the text of the hotkey. The hotkey will be rendered using the hot color.
        /// </summary>
        public int HotKeyPos { get => hotKeyPos; set => hotKeyPos = value; }

        /// <summary>
        /// Gets the hotkey. Will be an upper case letter or digit.
        /// </summary>
        public Key HotKey
        {
            get => hotKey;
            internal set
            {
                if (hotKey != value)
                {
                    var oldKey = hotKey;
                    hotKey = value;
                    HotKeyChanged?.Invoke(oldKey);
                }
            }
        }

        /// <summary>
        /// Gets the cursor position from <see cref="HotKey"/>. If the <see cref="HotKey"/> is defined, the cursor will be positioned over it.
        /// </summary>
        public int CursorPosition { get; set; }

        /// <summary>
        /// Gets the formatted lines.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Upon a 'get' of this property, if the text needs to be formatted (if <see cref="NeedsFormat"/> is <c>true</c>)
        /// <see cref="Format(ustring, int, bool, bool, bool, int, TextDirection)"/> will be called internally. 
        /// </para>
        /// </remarks>
        public List<ustring> Lines
        {
            get
            {
                // With this check, we protect against subclasses with overrides of Text
                if (ustring.IsNullOrEmpty(Text) || Size.IsEmpty)
                {
                    lines = new List<ustring> {
                        ustring.Empty
                    };
                    NeedsFormat = false;
                    return lines;
                }

                if (NeedsFormat)
                {
                    var shown_text = text;
                    if (FindHotKey(text, HotKeySpecifier, true, out hotKeyPos, out Key newHotKey))
                    {
                        HotKey = newHotKey;
                        shown_text = RemoveHotKeySpecifier(Text, hotKeyPos, HotKeySpecifier);
                        shown_text = ReplaceHotKeyWithTag(shown_text, hotKeyPos);
                    }

                    if (IsVerticalDirection(textDirection))
                    {
                        var colsWidth = GetSumMaxCharWidth(shown_text, 0, 1);
                        lines = Format(shown_text, Size.Height, textVerticalAlignment == VerticalTextAlignment.Justified, Size.Width > colsWidth,
                            PreserveTrailingSpaces, 0, textDirection);
                        if (!AutoSize)
                        {
                            colsWidth = GetMaxColsForWidth(lines, Size.Width);
                            if (lines.Count > colsWidth)
                            {
                                lines.RemoveRange(colsWidth, lines.Count - colsWidth);
                            }
                        }
                    }
                    else
                    {
                        lines = Format(shown_text, Size.Width, textAlignment == TextAlignment.Justified, Size.Height > 1,
                            PreserveTrailingSpaces, 0, textDirection);
                        if (!AutoSize && lines.Count > Size.Height)
                        {
                            lines.RemoveRange(Size.Height, lines.Count - Size.Height);
                        }
                    }

                    NeedsFormat = false;
                }
                return lines;
            }
        }

        /// <summary>
        /// Gets or sets whether the <see cref="TextFormatter"/> needs to format the text when <see cref="Draw(Rect, Attribute, Attribute, Rect, bool)"/> is called.
        /// If it is <c>false</c> when Draw is called, the Draw call will be faster.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is set to true when the properties of <see cref="TextFormatter"/> are set.
        /// </para>
        /// </remarks>
        public bool NeedsFormat { get => needsFormat; set => needsFormat = value; }

        static ustring StripCRLF(ustring str, bool keepNewLine = false)
        {
            var runes = str.ToRuneList();
            for (int i = 0; i < runes.Count; i++)
            {
                switch (runes[i])
                {
                    case '\n':
                        if (!keepNewLine)
                        {
                            runes.RemoveAt(i);
                        }
                        break;

                    case '\r':
                        if ((i + 1) < runes.Count && runes[i + 1] == '\n')
                        {
                            runes.RemoveAt(i);
                            if (!keepNewLine)
                            {
                                runes.RemoveAt(i);
                            }
                            i++;
                        }
                        else
                        {
                            if (!keepNewLine)
                            {
                                runes.RemoveAt(i);
                            }
                        }
                        break;
                }
            }
            return ustring.Make(runes);
        }
        static ustring ReplaceCRLFWithSpace(ustring str)
        {
            var runes = str.ToRuneList();
            for (int i = 0; i < runes.Count; i++)
            {
                switch (runes[i])
                {
                    case '\n':
                        runes[i] = (Rune)' ';
                        break;

                    case '\r':
                        if ((i + 1) < runes.Count && runes[i + 1] == '\n')
                        {
                            runes[i] = (Rune)' ';
                            runes.RemoveAt(i + 1);
                            i++;
                        }
                        else
                        {
                            runes[i] = (Rune)' ';
                        }
                        break;
                }
            }
            return ustring.Make(runes);
        }

        /// <summary>
        /// Splits all newlines in the <paramref name="text"/> into a list
        /// and supports both CRLF and LF, preserving the ending newline.
        /// </summary>
        /// <param name="text">The text.</param>
        /// <returns>A list of text without the newline characters.</returns>
        public static List<ustring> SplitNewLine(ustring text)
        {
            var runes = text.ToRuneList();
            var lines = new List<ustring>();
            var start = 0;
            var end = 0;

            for (int i = 0; i < runes.Count; i++)
            {
                end = i;
                switch (runes[i])
                {
                    case '\n':
                        lines.Add(ustring.Make(runes.GetRange(start, end - start)));
                        i++;
                        start = i;
                        break;

                    case '\r':
                        if ((i + 1) < runes.Count && runes[i + 1] == '\n')
                        {
                            lines.Add(ustring.Make(runes.GetRange(start, end - start)));
                            i += 2;
                            start = i;
                        }
                        else
                        {
                            lines.Add(ustring.Make(runes.GetRange(start, end - start)));
                            i++;
                            start = i;
                        }
                        break;
                }
            }
            if (runes.Count > 0 && lines.Count == 0)
            {
                lines.Add(ustring.Make(runes));
            }
            else if (runes.Count > 0 && start < runes.Count)
            {
                lines.Add(ustring.Make(runes.GetRange(start, runes.Count - start)));
            }
            else
            {
                lines.Add(ustring.Make(""));
            }
            return lines;
        }

        /// <summary>
        /// Adds trailing whitespace or truncates <paramref name="text"/>
        /// so that it fits exactly <paramref name="width"/> console units.
        /// Note that some unicode characters take 2+ columns
        /// </summary>
        /// <param name="text"></param>
        /// <param name="width"></param>
        /// <returns></returns>
        public static string ClipOrPad(string text, int width)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            // if value is not wide enough
            if (text.Sum(c => Rune.ColumnWidth(c)) < width)
            {

                // pad it out with spaces to the given alignment
                int toPad = width - (text.Sum(c => Rune.ColumnWidth(c)));

                return text + new string(' ', toPad);
            }

            // value is too wide
            return new string(text.TakeWhile(c => (width -= Rune.ColumnWidth(c)) >= 0).ToArray());
        }

        /// <summary>
        /// Formats the provided text to fit within the width provided using word wrapping.
        /// </summary>
        /// <param name="text">The text to word wrap</param>
        /// <param name="width">The width to contain the text to</param>
        /// <param name="preserveTrailingSpaces">If <c>true</c>, the wrapped text will keep the trailing spaces.
        ///  If <c>false</c>, the trailing spaces will be trimmed.</param>
        /// <param name="tabWidth">The tab width.</param>
        /// <param name="textDirection">The text direction.</param>
        /// <returns>Returns a list of word wrapped lines.</returns>
        /// <remarks>
        /// <para>
        /// This method does not do any justification.
        /// </para>
        /// <para>
        /// This method strips Newline ('\n' and '\r\n') sequences before processing.
        /// </para>
        /// </remarks>
        public static List<ustring> WordWrap(ustring text, int width, bool preserveTrailingSpaces = false, int tabWidth = 0,
            TextDirection textDirection = TextDirection.LeftRight_TopBottom)
        {
            if (width < 0)
            {
                throw new ArgumentOutOfRangeException("Width cannot be negative.");
            }

            int start = 0, end;
            var lines = new List<ustring>();

            if (ustring.IsNullOrEmpty(text))
            {
                return lines;
            }

            var runes = StripCRLF(text).ToRuneList();
            if (!preserveTrailingSpaces)
            {
                if (IsHorizontalDirection(textDirection))
                {
                    while ((end = start + Math.Max(GetMaxLengthForWidth(runes.GetRange(start, runes.Count - start), width), 1)) < runes.Count)
                    {
                        while (runes[end] != ' ' && end > start)
                            end--;
                        if (end == start)
                            end = start + GetMaxLengthForWidth(runes.GetRange(end, runes.Count - end), width);
                        lines.Add(ustring.Make(runes.GetRange(start, end - start)));
                        start = end;
                        if (runes[end] == ' ')
                        {
                            start++;
                        }
                    }
                }
                else
                {
                    while ((end = start + width) < runes.Count)
                    {
                        while (runes[end] != ' ' && end > start)
                            end--;
                        if (end == start)
                            end = start + width;
                        lines.Add(ustring.Make(runes.GetRange(start, end - start)));
                        start = end;
                        if (runes[end] == ' ')
                        {
                            start++;
                        }
                    }
                }
            }
            else
            {
                while ((end = start) < runes.Count)
                {
                    end = GetNextWhiteSpace(start, width, out bool incomplete);
                    if (end == 0 && incomplete)
                    {
                        start = text.RuneCount;
                        break;
                    }
                    lines.Add(ustring.Make(runes.GetRange(start, end - start)));
                    start = end;
                    if (incomplete)
                    {
                        start = text.RuneCount;
                        break;
                    }
                }
            }

            int GetNextWhiteSpace(int from, int cWidth, out bool incomplete, int cLength = 0)
            {
                var lastFrom = from;
                var to = from;
                var length = cLength;
                incomplete = false;

                while (length < cWidth && to < runes.Count)
                {
                    var rune = runes[to];
                    if (IsHorizontalDirection(textDirection))
                    {
                        length += Rune.ColumnWidth(rune);
                    }
                    else
                    {
                        length++;
                    }
                    if (length > cWidth)
                    {
                        if (to >= runes.Count || (length > 1 && cWidth <= 1))
                        {
                            incomplete = true;
                        }
                        return to;
                    }
                    if (rune == ' ')
                    {
                        if (length == cWidth)
                        {
                            return to + 1;
                        }
                        else if (length > cWidth)
                        {
                            return to;
                        }
                        else
                        {
                            return GetNextWhiteSpace(to + 1, cWidth, out incomplete, length);
                        }
                    }
                    else if (rune == '\t')
                    {
                        length += tabWidth + 1;
                        if (length == tabWidth && tabWidth > cWidth)
                        {
                            return to + 1;
                        }
                        else if (length > cWidth && tabWidth > cWidth)
                        {
                            return to;
                        }
                        else
                        {
                            return GetNextWhiteSpace(to + 1, cWidth, out incomplete, length);
                        }
                    }
                    to++;
                }
                if (cLength > 0 && to < runes.Count && runes[to] != ' ' && runes[to] != '\t')
                {
                    return from;
                }
                else if (cLength > 0 && to < runes.Count && (runes[to] == ' ' || runes[to] == '\t'))
                {
                    return lastFrom;
                }
                else
                {
                    return to;
                }
            }

            if (start < text.RuneCount)
            {
                lines.Add(ustring.Make(runes.GetRange(start, runes.Count - start)));
            }

            return lines;
        }

        /// <summary>
        /// Justifies text within a specified width. 
        /// </summary>
        /// <param name="text">The text to justify.</param>
        /// <param name="width">If the text length is greater that <c>width</c> it will be clipped.</param>
        /// <param name="talign">Alignment.</param>
        /// <param name="textDirection">The text direction.</param>
        /// <returns>Justified and clipped text.</returns>
        public static ustring ClipAndJustify(ustring text, int width, TextAlignment talign, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
        {
            return ClipAndJustify(text, width, talign == TextAlignment.Justified, textDirection);
        }

        /// <summary>
        /// Justifies text within a specified width. 
        /// </summary>
        /// <param name="text">The text to justify.</param>
        /// <param name="width">If the text length is greater that <c>width</c> it will be clipped.</param>
        /// <param name="justify">Justify.</param>
        /// <param name="textDirection">The text direction.</param>
        /// <returns>Justified and clipped text.</returns>
        public static ustring ClipAndJustify(ustring text, int width, bool justify, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
        {
            if (width < 0)
            {
                throw new ArgumentOutOfRangeException("Width cannot be negative.");
            }
            if (ustring.IsNullOrEmpty(text))
            {
                return text;
            }

            var runes = text.ToRuneList();
            int slen = runes.Count;
            if (slen > width)
            {
                if (IsHorizontalDirection(textDirection))
                {
                    return ustring.Make(runes.GetRange(0, GetMaxLengthForWidth(text, width)));
                }
                else
                {
                    return ustring.Make(runes.GetRange(0, width));
                }
            }
            else
            {
                if (justify)
                {
                    return Justify(text, width, ' ', textDirection);
                }
                else if (IsHorizontalDirection(textDirection) && GetTextWidth(text) > width)
                {
                    return ustring.Make(runes.GetRange(0, GetMaxLengthForWidth(text, width)));
                }
                return text;
            }
        }

        /// <summary>
        /// Justifies the text to fill the width provided. Space will be added between words (demarked by spaces and tabs) to
        /// make the text just fit <c>width</c>. Spaces will not be added to the ends.
        /// </summary>
        /// <param name="text"></param>
        /// <param name="width"></param>
        /// <param name="spaceChar">Character to replace whitespace and pad with. For debugging purposes.</param>
        /// <param name="textDirection">The text direction.</param>
        /// <returns>The justified text.</returns>
        public static ustring Justify(ustring text, int width, char spaceChar = ' ', TextDirection textDirection = TextDirection.LeftRight_TopBottom)
        {
            if (width < 0)
            {
                throw new ArgumentOutOfRangeException("Width cannot be negative.");
            }
            if (ustring.IsNullOrEmpty(text))
            {
                return text;
            }

            var words = text.Split(ustring.Make(' '));
            int textCount;
            if (IsHorizontalDirection(textDirection))
            {
                textCount = words.Sum(arg => GetTextWidth(arg));
            }
            else
            {
                textCount = words.Sum(arg => arg.RuneCount);
            }
            var spaces = words.Length > 1 ? (width - textCount) / (words.Length - 1) : 0;
            var extras = words.Length > 1 ? (width - textCount) % (words.Length - 1) : 0;

            var s = new System.Text.StringBuilder();
            for (int w = 0; w < words.Length; w++)
            {
                var x = words[w];
                s.Append(x);
                if (w + 1 < words.Length)
                    for (int i = 0; i < spaces; i++)
                        s.Append(spaceChar);
                if (extras > 0)
                {
                    for (int i = 0; i < 1; i++)
                        s.Append(spaceChar);
                    extras--;
                }
                if (w + 1 == words.Length - 1)
                {
                    for (int i = 0; i < extras; i++)
                        s.Append(spaceChar);
                }
            }
            return ustring.Make(s.ToString());
        }

        static char[] whitespace = new char[] { ' ', '\t' };
        private int hotKeyPos = -1;

        /// <summary>
        /// Reformats text into lines, applying text alignment and optionally wrapping text to new lines on word boundaries.
        /// </summary>
        /// <param name="text"></param>
        /// <param name="width">The width to bound the text to for word wrapping and clipping.</param>
        /// <param name="talign">Specifies how the text will be aligned horizontally.</param>
        /// <param name="wordWrap">If <c>true</c>, the text will be wrapped to new lines as need. If <c>false</c>, forces text to fit a single line. Line breaks are converted to spaces. The text will be clipped to <c>width</c></param>
        /// <param name="preserveTrailingSpaces">If <c>true</c> and 'wordWrap' also true, the wrapped text will keep the trailing spaces. If <c>false</c>, the trailing spaces will be trimmed.</param>
        /// <param name="tabWidth">The tab width.</param>
        /// <param name="textDirection">The text direction.</param>
        /// <returns>A list of word wrapped lines.</returns>
        /// <remarks>
        /// <para>
        /// An empty <c>text</c> string will result in one empty line.
        /// </para>
        /// <para>
        /// If <c>width</c> is 0, a single, empty line will be returned.
        /// </para>
        /// <para>
        /// If <c>width</c> is int.MaxValue, the text will be formatted to the maximum width possible. 
        /// </para>
        /// </remarks>
        public static List<ustring> Format(ustring text, int width, TextAlignment talign, bool wordWrap, bool preserveTrailingSpaces = false, int tabWidth = 0, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
        {
            return Format(text, width, talign == TextAlignment.Justified, wordWrap, preserveTrailingSpaces, tabWidth, textDirection);
        }

        /// <summary>
        /// Reformats text into lines, applying text alignment and optionally wrapping text to new lines on word boundaries.
        /// </summary>
        /// <param name="text"></param>
        /// <param name="width">The width to bound the text to for word wrapping and clipping.</param>
        /// <param name="justify">Specifies whether the text should be justified.</param>
        /// <param name="wordWrap">If <c>true</c>, the text will be wrapped to new lines as need. If <c>false</c>, forces text to fit a single line. Line breaks are converted to spaces. The text will be clipped to <c>width</c></param>
        /// <param name="preserveTrailingSpaces">If <c>true</c> and 'wordWrap' also true, the wrapped text will keep the trailing spaces. If <c>false</c>, the trailing spaces will be trimmed.</param>
        /// <param name="tabWidth">The tab width.</param>
        /// <param name="textDirection">The text direction.</param>
        /// <returns>A list of word wrapped lines.</returns>
        /// <remarks>
        /// <para>
        /// An empty <c>text</c> string will result in one empty line.
        /// </para>
        /// <para>
        /// If <c>width</c> is 0, a single, empty line will be returned.
        /// </para>
        /// <para>
        /// If <c>width</c> is int.MaxValue, the text will be formatted to the maximum width possible. 
        /// </para>
        /// </remarks>
        public static List<ustring> Format(ustring text, int width, bool justify, bool wordWrap,
            bool preserveTrailingSpaces = false, int tabWidth = 0, TextDirection textDirection = TextDirection.LeftRight_TopBottom)
        {
            if (width < 0)
            {
                throw new ArgumentOutOfRangeException("width cannot be negative");
            }
            List<ustring> lineResult = new List<ustring>();

            if (ustring.IsNullOrEmpty(text) || width == 0)
            {
                lineResult.Add(ustring.Empty);
                return lineResult;
            }

            if (wordWrap == false)
            {
                text = ReplaceCRLFWithSpace(text);
                lineResult.Add(ClipAndJustify(text, width, justify, textDirection));
                return lineResult;
            }

            var runes = StripCRLF(text, true).ToRuneList();
            int runeCount = runes.Count;
            int lp = 0;
            for (int i = 0; i < runeCount; i++)
            {
                Rune c = runes[i];
                if (c == '\n')
                {
                    var wrappedLines = WordWrap(ustring.Make(runes.GetRange(lp, i - lp)), width, preserveTrailingSpaces, tabWidth, textDirection);
                    foreach (var line in wrappedLines)
                    {
                        lineResult.Add(ClipAndJustify(line, width, justify, textDirection));
                    }
                    if (wrappedLines.Count == 0)
                    {
                        lineResult.Add(ustring.Empty);
                    }
                    lp = i + 1;
                }
            }
            foreach (var line in WordWrap(ustring.Make(runes.GetRange(lp, runeCount - lp)), width, preserveTrailingSpaces, tabWidth, textDirection))
            {
                lineResult.Add(ClipAndJustify(line, width, justify, textDirection));
            }

            return lineResult;
        }

        /// <summary>
        /// Computes the number of lines needed to render the specified text given the width.
        /// </summary>
        /// <returns>Number of lines.</returns>
        /// <param name="text">Text, may contain newlines.</param>
        /// <param name="width">The minimum width for the text.</param>
        public static int MaxLines(ustring text, int width)
        {
            var result = TextFormatter.Format(text, width, false, true);
            return result.Count;
        }

        /// <summary>
        /// Computes the maximum width needed to render the text (single line or multiple lines) given a minimum width.
        /// </summary>
        /// <returns>Max width of lines.</returns>
        /// <param name="text">Text, may contain newlines.</param>
        /// <param name="width">The minimum width for the text.</param>
        public static int MaxWidth(ustring text, int width)
        {
            var result = TextFormatter.Format(text, width, false, true);
            var max = 0;
            result.ForEach(s =>
            {
                var m = 0;
                s.ToRuneList().ForEach(r => m += Math.Max(Rune.ColumnWidth(r), 1));
                if (m > max)
                {
                    max = m;
                }
            });
            return max;
        }

        /// <summary>
        /// Determines the line with the highest width in the 
        /// <paramref name="text"/> if it contains newlines.
        /// </summary>
        /// <param name="text">Text, may contain newlines.</param>
        /// <returns>The highest line width.</returns>
        public static int MaxWidthLine(ustring text)
        {
            var result = TextFormatter.SplitNewLine(text);
            return result.Max(x => x.ConsoleWidth);
        }

        /// <summary>
        /// Gets the total width of the passed text.
        /// </summary>
        /// <param name="text"></param>
        /// <returns>The text width.</returns>
        public static int GetTextWidth(ustring text)
        {
            return text.ToRuneList().Sum(r => Math.Max(Rune.ColumnWidth(r), 1));
        }

        /// <summary>
        /// Gets the maximum characters width from the list based on the <paramref name="startIndex"/>
        /// and the <paramref name="length"/>.
        /// </summary>
        /// <param name="lines">The lines.</param>
        /// <param name="startIndex">The start index.</param>
        /// <param name="length">The length.</param>
        /// <returns>The maximum characters width.</returns>
        public static int GetSumMaxCharWidth(List<ustring> lines, int startIndex = -1, int length = -1)
        {
            var max = 0;
            for (int i = (startIndex == -1 ? 0 : startIndex); i < (length == -1 ? lines.Count : startIndex + length); i++)
            {
                var runes = lines[i];
                if (runes.Length > 0)
                    max += runes.Max(r => Math.Max(Rune.ColumnWidth(r), 1));
            }
            return max;
        }

        /// <summary>
        /// Gets the maximum characters width from the text based on the <paramref name="startIndex"/>
        /// and the <paramref name="length"/>.
        /// </summary>
        /// <param name="text">The text.</param>
        /// <param name="startIndex">The start index.</param>
        /// <param name="length">The length.</param>
        /// <returns>The maximum characters width.</returns>
        public static int GetSumMaxCharWidth(ustring text, int startIndex = -1, int length = -1)
        {
            var max = 0;
            var runes = text.ToRunes();
            for (int i = (startIndex == -1 ? 0 : startIndex); i < (length == -1 ? runes.Length : startIndex + length); i++)
            {
                max += Math.Max(Rune.ColumnWidth(runes[i]), 1);
            }
            return max;
        }

        /// <summary>
        /// Gets the index position from the text based on the <paramref name="width"/>.
        /// </summary>
        /// <param name="text">The text.</param>
        /// <param name="width">The width.</param>
        /// <returns>The index of the text that fit the width.</returns>
        public static int GetMaxLengthForWidth(ustring text, int width)
        {
            var runes = text.ToRuneList();
            var runesLength = 0;
            var runeIdx = 0;
            for (; runeIdx < runes.Count; runeIdx++)
            {
                var runeWidth = Math.Max(Rune.ColumnWidth(runes[runeIdx]), 1);
                if (runesLength + runeWidth > width)
                {
                    break;
                }
                runesLength += runeWidth;
            }
            return runeIdx;
        }

        /// <summary>
        /// Gets the index position from the list based on the <paramref name="width"/>.
        /// </summary>
        /// <param name="runes">The runes.</param>
        /// <param name="width">The width.</param>
        /// <returns>The index of the list that fit the width.</returns>
        public static int GetMaxLengthForWidth(List<Rune> runes, int width)
        {
            var runesLength = 0;
            var runeIdx = 0;
            for (; runeIdx < runes.Count; runeIdx++)
            {
                var runeWidth = Math.Max(Rune.ColumnWidth(runes[runeIdx]), 1);
                if (runesLength + runeWidth > width)
                {
                    break;
                }
                runesLength += runeWidth;
            }
            return runeIdx;
        }

        /// <summary>
        /// Gets the index position from the list based on the <paramref name="width"/>.
        /// </summary>
        /// <param name="lines">The lines.</param>
        /// <param name="width">The width.</param>
        /// <returns>The index of the list that fit the width.</returns>
        public static int GetMaxColsForWidth(List<ustring> lines, int width)
        {
            var runesLength = 0;
            var lineIdx = 0;
            for (; lineIdx < lines.Count; lineIdx++)
            {
                var runes = lines[lineIdx].ToRuneList();
                var maxRruneWidth = runes.Count > 0
                    ? runes.Max(r => Math.Max(Rune.ColumnWidth(r), 1)) : 1;
                if (runesLength + maxRruneWidth > width)
                {
                    break;
                }
                runesLength += maxRruneWidth;
            }
            return lineIdx;
        }

        /// <summary>
        ///  Calculates the rectangle required to hold text, assuming no word wrapping.
        /// </summary>
        /// <param name="x">The x location of the rectangle</param>
        /// <param name="y">The y location of the rectangle</param>
        /// <param name="text">The text to measure</param>
        /// <param name="direction">The text direction.</param>
        /// <returns></returns>
        public static Rect CalcRect(int x, int y, ustring text, TextDirection direction = TextDirection.LeftRight_TopBottom)
        {
            if (ustring.IsNullOrEmpty(text))
            {
                return new Rect(new Point(x, y), Size.Empty);
            }

            int w, h;

            if (IsHorizontalDirection(direction))
            {
                int mw = 0;
                int ml = 1;

                int cols = 0;
                foreach (var rune in text)
                {
                    if (rune == '\n')
                    {
                        ml++;
                        if (cols > mw)
                        {
                            mw = cols;
                        }
                        cols = 0;
                    }
                    else if (rune != '\r')
                    {
                        cols++;
                        var rw = Rune.ColumnWidth(rune);
                        if (rw > 0)
                        {
                            rw--;
                        }
                        cols += rw;
                    }
                }
                if (cols > mw)
                {
                    mw = cols;
                }
                w = mw;
                h = ml;
            }
            else
            {
                int vw = 1, cw = 1;
                int vh = 0;

                int rows = 0;
                foreach (var rune in text)
                {
                    if (rune == '\n')
                    {
                        vw++;
                        if (rows > vh)
                        {
                            vh = rows;
                        }
                        rows = 0;
                        cw = 1;
                    }
                    else if (rune != '\r')
                    {
                        rows++;
                        var rw = Rune.ColumnWidth(rune);
                        if (cw < rw)
                        {
                            cw = rw;
                            vw++;
                        }
                    }
                }
                if (rows > vh)
                {
                    vh = rows;
                }
                w = vw;
                h = vh;
            }

            return new Rect(x, y, w, h);
        }

        /// <summary>
        /// Finds the hotkey and its location in text. 
        /// </summary>
        /// <param name="text">The text to look in.</param>
        /// <param name="hotKeySpecifier">The hotkey specifier (e.g. '_') to look for.</param>
        /// <param name="firstUpperCase">If <c>true</c> the legacy behavior of identifying the first upper case character as the hotkey will be enabled.
        /// Regardless of the value of this parameter, <c>hotKeySpecifier</c> takes precedence.</param>
        /// <param name="hotPos">Outputs the Rune index into <c>text</c>.</param>
        /// <param name="hotKey">Outputs the hotKey.</param>
        /// <returns><c>true</c> if a hotkey was found; <c>false</c> otherwise.</returns>
        public static bool FindHotKey(ustring text, Rune hotKeySpecifier, bool firstUpperCase, out int hotPos, out Key hotKey)
        {
            if (ustring.IsNullOrEmpty(text) || hotKeySpecifier == (Rune)0xFFFF)
            {
                hotPos = -1;
                hotKey = Key.Unknown;
                return false;
            }

            Rune hot_key = (Rune)0;
            int hot_pos = -1;

            // Use first hot_key char passed into 'hotKey'.
            // TODO: Ignore hot_key of two are provided
            // TODO: Do not support non-alphanumeric chars that can't be typed
            int i = 0;
            foreach (Rune c in text)
            {
                if ((char)c != 0xFFFD)
                {
                    if (c == hotKeySpecifier)
                    {
                        hot_pos = i;
                    }
                    else if (hot_pos > -1)
                    {
                        hot_key = c;
                        break;
                    }
                }
                i++;
            }


            // Legacy support - use first upper case char if the specifier was not found
            if (hot_pos == -1 && firstUpperCase)
            {
                i = 0;
                foreach (Rune c in text)
                {
                    if ((char)c != 0xFFFD)
                    {
                        if (Rune.IsUpper(c))
                        {
                            hot_key = c;
                            hot_pos = i;
                            break;
                        }
                    }
                    i++;
                }
            }

            if (hot_key != (Rune)0 && hot_pos != -1)
            {
                hotPos = hot_pos;

                if (hot_key.IsValid && char.IsLetterOrDigit((char)hot_key))
                {
                    hotKey = (Key)char.ToUpperInvariant((char)hot_key);
                    return true;
                }
            }

            hotPos = -1;
            hotKey = Key.Unknown;
            return false;
        }

        /// <summary>
        /// Replaces the Rune at the index specified by the <c>hotPos</c> parameter with a tag identifying 
        /// it as the hotkey.
        /// </summary>
        /// <param name="text">The text to tag the hotkey in.</param>
        /// <param name="hotPos">The Rune index of the hotkey in <c>text</c>.</param>
        /// <returns>The text with the hotkey tagged.</returns>
        /// <remarks>
        /// The returned string will not render correctly without first un-doing the tag. To undo the tag, search for 
        /// </remarks>
        public ustring ReplaceHotKeyWithTag(ustring text, int hotPos)
        {
            // Set the high bit
            var runes = text.ToRuneList();
            if (Rune.IsLetterOrNumber(runes[hotPos]))
            {
                runes[hotPos] = new Rune((uint)runes[hotPos]);
            }
            return ustring.Make(runes);
        }

        /// <summary>
        /// Removes the hotkey specifier from text.
        /// </summary>
        /// <param name="text">The text to manipulate.</param>
        /// <param name="hotKeySpecifier">The hot-key specifier (e.g. '_') to look for.</param>
        /// <param name="hotPos">Returns the position of the hot-key in the text. -1 if not found.</param>
        /// <returns>The input text with the hotkey specifier ('_') removed.</returns>
        public static ustring RemoveHotKeySpecifier(ustring text, int hotPos, Rune hotKeySpecifier)
        {
            if (ustring.IsNullOrEmpty(text))
            {
                return text;
            }

            // Scan 
            ustring start = ustring.Empty;
            int i = 0;
            foreach (Rune c in text)
            {
                if (c == hotKeySpecifier && i == hotPos)
                {
                    i++;
                    continue;
                }
                start += ustring.Make(c);
                i++;
            }
            return start;
        }

        /// <summary>
        /// Draws the text held by <see cref="TextFormatter"/> to <see cref="Application.Driver"/> using the colors specified.
        /// </summary>
        /// <param name="bounds">Specifies the screen-relative location and maximum size for drawing the text.</param>
        /// <param name="normalColor">The color to use for all text except the hotkey</param>
        /// <param name="hotColor">The color to use to draw the hotkey</param>
        /// <param name="containerBounds">Specifies the screen-relative location and maximum container size.</param>
        /// <param name="fillRemaining">Determines if the bounds width will be used (default) or only the text width will be used.</param>
        public void Draw(Rect bounds, Attribute normalColor, Attribute hotColor, Rect containerBounds = default, bool fillRemaining = true)
        {
            // With this check, we protect against subclasses with overrides of Text (like Button)
            if (ustring.IsNullOrEmpty(text))
            {
                return;
            }

            Application.Driver?.SetAttribute(normalColor);

            // Use "Lines" to ensure a Format (don't use "lines"))

            var linesFormated = Lines;
            switch (textDirection)
            {
                case TextDirection.TopBottom_RightLeft:
                case TextDirection.LeftRight_BottomTop:
                case TextDirection.RightLeft_BottomTop:
                case TextDirection.BottomTop_RightLeft:
                    linesFormated.Reverse();
                    break;
            }

            var isVertical = IsVerticalDirection(textDirection);
            var maxBounds = containerBounds == default
                ? bounds
                : new Rect(Math.Max(containerBounds.X, bounds.X),
                    Math.Max(containerBounds.Y, bounds.Y),
                    Math.Max(Math.Max(containerBounds.Width, containerBounds.Right - bounds.Left), 0),
                    Math.Max(Math.Max(containerBounds.Height, containerBounds.Bottom - bounds.Top), 0));

            int boundsStart = 0;
            if (isVertical)
            {
                if (bounds.X < 0)
                {
                    boundsStart = bounds.X;
                }
            }
            else
            {
                if (bounds.Y < 0)
                {
                    boundsStart = bounds.Y;
                }
            }
            for (int line = 0; line < linesFormated.Count; line++)
            {
                if (boundsStart < 0)
                {
                    boundsStart++;
                    continue;
                }
                if ((isVertical && line > bounds.Width) || (!isVertical && line > bounds.Height))
                {
                    continue;
                }
                if ((isVertical && line >= maxBounds.Left + maxBounds.Width)
                    || (!isVertical && line >= maxBounds.Top + maxBounds.Height))
                {
                    break;
                }

                var runes = lines[line].ToRunes();

                switch (textDirection)
                {
                    case TextDirection.RightLeft_BottomTop:
                    case TextDirection.RightLeft_TopBottom:
                    case TextDirection.BottomTop_LeftRight:
                    case TextDirection.BottomTop_RightLeft:
                        runes = runes.Reverse().ToArray();
                        break;
                }

                // When text is justified, we lost left or right, so we use the direction to align. 

                int x, y;
                // Horizontal Alignment
                if (textAlignment == TextAlignment.Right || (textAlignment == TextAlignment.Justified && !IsLeftToRight(textDirection)))
                {
                    if (isVertical)
                    {
                        var runesWidth = GetSumMaxCharWidth(Lines, line);
                        x = bounds.Right - runesWidth;
                        CursorPosition = bounds.Width - runesWidth + (hotKeyPos > -1 ? hotKeyPos : 0);
                    }
                    else
                    {
                        var runesWidth = GetTextWidth(ustring.Make(runes));
                        x = bounds.Right - runesWidth;
                        CursorPosition = bounds.Width - runesWidth + (hotKeyPos > -1 ? hotKeyPos : 0);
                    }
                }
                else if (textAlignment == TextAlignment.Left || textAlignment == TextAlignment.Justified)
                {
                    if (isVertical)
                    {
                        var runesWidth = line > 0 ? GetSumMaxCharWidth(Lines, 0, line) : 0;
                        x = bounds.Left + runesWidth;
                    }
                    else
                    {
                        x = bounds.Left;
                    }
                    CursorPosition = hotKeyPos > -1 ? hotKeyPos : 0;
                }
                else if (textAlignment == TextAlignment.Centered)
                {
                    if (isVertical)
                    {
                        var runesWidth = GetSumMaxCharWidth(Lines, line);
                        x = bounds.Left + line + ((bounds.Width - runesWidth) / 2);
                        CursorPosition = (bounds.Width - runesWidth) / 2 + (hotKeyPos > -1 ? hotKeyPos : 0);
                    }
                    else
                    {
                        var runesWidth = GetTextWidth(ustring.Make(runes));
                        x = bounds.Left + (bounds.Width - runesWidth) / 2;
                        CursorPosition = (bounds.Width - runesWidth) / 2 + (hotKeyPos > -1 ? hotKeyPos : 0);
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException();
                }

                // Vertical Alignment
                if (textVerticalAlignment == VerticalTextAlignment.Bottom || (textVerticalAlignment == VerticalTextAlignment.Justified && !IsTopToBottom(textDirection)))
                {
                    if (isVertical)
                    {
                        y = bounds.Bottom - runes.Length;
                    }
                    else
                    {
                        y = bounds.Bottom - Lines.Count + line;
                    }
                }
                else if (textVerticalAlignment == VerticalTextAlignment.Top || textVerticalAlignment == VerticalTextAlignment.Justified)
                {
                    if (isVertical)
                    {
                        y = bounds.Top;
                    }
                    else
                    {
                        y = bounds.Top + line;
                    }
                }
                else if (textVerticalAlignment == VerticalTextAlignment.Middle)
                {
                    if (isVertical)
                    {
                        var s = (bounds.Height - runes.Length) / 2;
                        y = bounds.Top + s;
                    }
                    else
                    {
                        var s = (bounds.Height - Lines.Count) / 2;
                        y = bounds.Top + line + s;
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException();
                }

                var start = isVertical ? bounds.Top : bounds.Left;
                var size = isVertical ? bounds.Height : bounds.Width;
                var current = start;

                for (var idx = (isVertical ? start - y : start - x); current < start + size; idx++)
                {
                    if (!fillRemaining && idx < 0)
                    {
                        current++;
                        continue;
                    }
                    else if (!fillRemaining && idx > runes.Length - 1)
                    {
                        break;
                    }
                    if ((!isVertical && idx >= maxBounds.Left + maxBounds.Width - bounds.X) || (isVertical && idx >= maxBounds.Top + maxBounds.Height - bounds.Y))
                    {
                        break;
                    }

                    var rune = (Rune)' ';
                    if (isVertical)
                    {
                        Application.Driver?.Move(x, current);
                        if (idx >= 0 && idx < runes.Length)
                        {
                            rune = runes[idx];
                        }
                    }
                    else
                    {
                        Application.Driver?.Move(current, y);
                        if (idx >= 0 && idx < runes.Length)
                        {
                            rune = runes[idx];
                        }
                    }
                    if (HotKeyPos > -1 && idx == HotKeyPos)
                    {
                        if ((isVertical && textVerticalAlignment == VerticalTextAlignment.Justified) ||
                        (!isVertical && textAlignment == TextAlignment.Justified))
                        {
                            CursorPosition = idx - start;
                        }
                        Application.Driver?.SetAttribute(hotColor);
                        Application.Driver?.AddRune(rune);
                        Application.Driver?.SetAttribute(normalColor);
                    }
                    else
                    {
                        Application.Driver?.AddRune(rune);
                    }
                    var runeWidth = Math.Max(Rune.ColumnWidth(rune), 1);
                    if (isVertical)
                    {
                        current++;
                    }
                    else
                    {
                        current += runeWidth;
                    }
                    var nextRuneWidth = idx + 1 > -1 && idx + 1 < runes.Length ? Rune.ColumnWidth(runes[idx + 1]) : 0;
                    if (!isVertical && idx + 1 < runes.Length && current + nextRuneWidth > start + size)
                    {
                        break;
                    }
                }
            }
        }
    }
    //=======================================================================
    //
    // TextValidateField.cs: single-line text editor with validation through providers.
    //
    // Authors:
    //	José Miguel Perricone (jmperricone@hotmail.com)
    //

    namespace TextValidateProviders
    {
        /// <summary>
        /// TextValidateField Providers Interface.
        /// All TextValidateField are created with a ITextValidateProvider.
        /// </summary>
        public interface ITextValidateProvider
        {
            /// <summary>
            /// Set that this provider uses a fixed width.
            /// e.g. Masked ones are fixed.
            /// </summary>
            bool Fixed { get; }

            /// <summary>
            /// Set Cursor position to <paramref name="pos"/>.
            /// </summary>
            /// <param name="pos"></param>
            /// <returns>Return first valid position.</returns>
            int Cursor(int pos);

            /// <summary>
            /// First valid position before <paramref name="pos"/>.
            /// </summary>
            /// <param name="pos"></param>
            /// <returns>New cursor position if any, otherwise returns <paramref name="pos"/></returns>
            int CursorLeft(int pos);

            /// <summary>
            /// First valid position after <paramref name="pos"/>.
            /// </summary>
            /// <param name="pos">Current position.</param>
            /// <returns>New cursor position if any, otherwise returns <paramref name="pos"/></returns>
            int CursorRight(int pos);

            /// <summary>
            /// Find the first valid character position.
            /// </summary>
            /// <returns>New cursor position.</returns>
            int CursorStart();

            /// <summary>
            /// Find the last valid character position.
            /// </summary>
            /// <returns>New cursor position.</returns>
            int CursorEnd();

            /// <summary>
            /// Deletes the current character in <paramref name="pos"/>.
            /// </summary>
            /// <param name="pos"></param>
            /// <returns>true if the character was successfully removed, otherwise false.</returns>
            bool Delete(int pos);

            /// <summary>
            /// Insert character <paramref name="ch"/> in position <paramref name="pos"/>.
            /// </summary>
            /// <param name="ch"></param>
            /// <param name="pos"></param>
            /// <returns>true if the character was successfully inserted, otherwise false.</returns>
            bool InsertAt(char ch, int pos);

            /// <summary>
            /// True if the input is valid, otherwise false.
            /// </summary>
            bool IsValid { get; }

            /// <summary>
            /// Set the input text and get the current value.
            /// </summary>
            ustring Text { get; set; }

            /// <summary>
            /// Gets the formatted string for display.
            /// </summary>
            ustring DisplayText { get; }
        }

        //////////////////////////////////////////////////////////////////////////////
        // PROVIDERS
        //////////////////////////////////////////////////////////////////////////////

        #region NetMaskedTextProvider

        /// <summary>
        /// .Net MaskedTextProvider Provider for TextValidateField.
        /// <para></para>
        /// <para><a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.maskedtextprovider?view=net-5.0">Wrapper around MaskedTextProvider</a></para>
        /// <para><a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.maskedtextbox.mask?view=net-5.0">Masking elements</a></para>
        /// </summary>
        public class NetMaskedTextProvider : ITextValidateProvider
        {
            MaskedTextProvider provider;

            /// <summary>
            /// Empty Constructor
            /// </summary>
            public NetMaskedTextProvider(string mask)
            {
                Mask = mask;
            }

            /// <summary>
            /// Mask property
            /// </summary>
            public ustring Mask
            {
                get
                {
                    return provider?.Mask;
                }
                set
                {
                    var current = provider != null ? provider.ToString(false, false) : string.Empty;
                    provider = new MaskedTextProvider(value == ustring.Empty ? "&&&&&&" : value.ToString());
                    if (string.IsNullOrEmpty(current) == false)
                    {
                        provider.Set(current);
                    }
                }
            }

            ///<inheritdoc/>
            public ustring Text
            {
                get
                {
                    return provider.ToString();
                }
                set
                {
                    provider.Set(value.ToString());
                }
            }

            ///<inheritdoc/>
            public bool IsValid => provider.MaskCompleted;

            ///<inheritdoc/>
            public bool Fixed => true;

            ///<inheritdoc/>
            public ustring DisplayText => provider.ToDisplayString();

            ///<inheritdoc/>
            public int Cursor(int pos)
            {
                if (pos < 0)
                {
                    return CursorStart();
                }
                else if (pos > provider.Length)
                {
                    return CursorEnd();
                }
                else
                {
                    var p = provider.FindEditPositionFrom(pos, false);
                    if (p == -1) p = provider.FindEditPositionFrom(pos, true);
                    return p;
                }
            }

            ///<inheritdoc/>
            public int CursorStart()
            {
                return
                    provider.IsEditPosition(0)
                    ? 0
                    : provider.FindEditPositionFrom(0, true);
            }

            ///<inheritdoc/>
            public int CursorEnd()
            {
                return
                    provider.IsEditPosition(provider.Length - 1)
                    ? provider.Length - 1
                    : provider.FindEditPositionFrom(provider.Length, false);
            }

            ///<inheritdoc/>
            public int CursorLeft(int pos)
            {
                var c = provider.FindEditPositionFrom(pos - 1, false);
                return c == -1 ? pos : c;
            }

            ///<inheritdoc/>
            public int CursorRight(int pos)
            {
                var c = provider.FindEditPositionFrom(pos + 1, true);
                return c == -1 ? pos : c;
            }

            ///<inheritdoc/>
            public bool Delete(int pos)
            {
                return provider.Replace(' ', pos);// .RemoveAt (pos);
            }

            ///<inheritdoc/>
            public bool InsertAt(char ch, int pos)
            {
                return provider.Replace(ch, pos);
            }
        }
        #endregion

        #region TextRegexProvider

        /// <summary>
        /// Regex Provider for TextValidateField.
        /// </summary>
        public class TextRegexProvider : ITextValidateProvider
        {
            Regex regex;
            List<Rune> text;
            List<Rune> pattern;

            /// <summary>
            /// Empty Constructor.
            /// </summary>
            public TextRegexProvider(string pattern)
            {
                Pattern = pattern;
            }

            /// <summary>
            /// Regex pattern property.
            /// </summary>
            public ustring Pattern
            {
                get
                {
                    return ustring.Make(pattern);
                }
                set
                {
                    pattern = value.ToRuneList();
                    CompileMask();
                    SetupText();
                }
            }

            ///<inheritdoc/>
            public ustring Text
            {
                get
                {
                    return ustring.Make(text);
                }
                set
                {
                    text = value != ustring.Empty ? value.ToRuneList() : null;
                    SetupText();
                }
            }

            ///<inheritdoc/>
            public ustring DisplayText => Text;

            ///<inheritdoc/>
            public bool IsValid
            {
                get
                {
                    return Validate(text);
                }
            }

            ///<inheritdoc/>
            public bool Fixed => false;

            /// <summary>
            /// When true, validates with the regex pattern on each input, preventing the input if it's not valid.
            /// </summary>
            public bool ValidateOnInput { get; set; } = true;


            bool Validate(List<Rune> text)
            {
                var match = regex.Match(ustring.Make(text).ToString());
                return match.Success;
            }

            ///<inheritdoc/>
            public int Cursor(int pos)
            {
                if (pos < 0)
                {
                    return CursorStart();
                }
                else if (pos >= text.Count)
                {
                    return CursorEnd();
                }
                else
                {
                    return pos;
                }
            }

            ///<inheritdoc/>
            public int CursorStart()
            {
                return 0;
            }

            ///<inheritdoc/>
            public int CursorEnd()
            {
                return text.Count;
            }

            ///<inheritdoc/>
            public int CursorLeft(int pos)
            {
                if (pos > 0)
                {
                    return pos - 1;
                }
                return pos;
            }

            ///<inheritdoc/>
            public int CursorRight(int pos)
            {
                if (pos < text.Count)
                {
                    return pos + 1;
                }
                return pos;
            }

            ///<inheritdoc/>
            public bool Delete(int pos)
            {
                if (text.Count > 0 && pos < text.Count)
                {
                    text.RemoveAt(pos);
                }
                return true;
            }

            ///<inheritdoc/>
            public bool InsertAt(char ch, int pos)
            {
                var aux = text.ToList();
                aux.Insert(pos, ch);
                if (Validate(aux) || ValidateOnInput == false)
                {
                    text.Insert(pos, ch);
                    return true;
                }
                return false;
            }

            void SetupText()
            {
                if (text != null && IsValid)
                {
                    return;
                }

                text = new List<Rune>();
            }

            /// <summary>
            /// Compiles the regex pattern for validation./>
            /// </summary>
            private void CompileMask()
            {
                regex = new Regex(ustring.Make(pattern).ToString(), RegexOptions.Compiled);
            }
        }
        #endregion
    }

    /// <summary>
    /// Text field that validates input through a  <see cref="ITextValidateProvider"/>
    /// </summary>
    public class TextValidateField : View
    {

        ITextValidateProvider provider;
        int cursorPosition = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="TextValidateField"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        public TextValidateField() : this(null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TextValidateField"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        public TextValidateField(ITextValidateProvider provider)
        {
            if (provider != null)
            {
                Provider = provider;
            }

            Initialize();
        }

        void Initialize()
        {
            Height = 1;
            CanFocus = true;

            // Things this view knows how to do
            AddCommand(Command.LeftHome, () => { HomeKeyHandler(); return true; });
            AddCommand(Command.RightEnd, () => { EndKeyHandler(); return true; });
            AddCommand(Command.DeleteCharRight, () => { DeleteKeyHandler(); return true; });
            AddCommand(Command.DeleteCharLeft, () => { BackspaceKeyHandler(); return true; });
            AddCommand(Command.Left, () => { CursorLeft(); return true; });
            AddCommand(Command.Right, () => { CursorRight(); return true; });

            // Default keybindings for this view
            AddKeyBinding(Key.Home, Command.LeftHome);
            AddKeyBinding(Key.End, Command.RightEnd);

            AddKeyBinding(Key.Delete, Command.DeleteCharRight);
            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);

            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);
            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.CursorRight, Command.Right);
        }

        /// <summary>
        /// Provider
        /// </summary>
        public ITextValidateProvider Provider
        {
            get => provider;
            set
            {
                provider = value;
                if (provider.Fixed == true)
                {
                    this.Width = provider.DisplayText == ustring.Empty ? 10 : Text.Length;
                }
                HomeKeyHandler();
                SetNeedsDisplay();
            }
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent mouseEvent)
        {
            if (mouseEvent.Flags.HasFlag(MouseFlags.Button1Pressed))
            {

                var c = provider.Cursor(mouseEvent.X - GetMargins(Frame.Width).left);
                if (provider.Fixed == false && TextAlignment == TextAlignment.Right && Text.Length > 0)
                {
                    c += 1;
                }
                cursorPosition = c;
                SetFocus();
                SetNeedsDisplay();
                return true;
            }
            return false;
        }

        /// <summary>
        /// Text
        /// </summary>
        public new ustring Text
        {
            get
            {
                if (provider == null)
                {
                    return ustring.Empty;
                }

                return provider.Text;
            }
            set
            {
                if (provider == null)
                {
                    return;
                }
                provider.Text = value;

                SetNeedsDisplay();
            }
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            var (left, _) = GetMargins(Frame.Width);

            // Fixed = true, is for inputs thar have fixed width, like masked ones.
            // Fixed = false, is for normal input.
            // When it's right-aligned and it's a normal input, the cursor behaves differently.
            if (provider?.Fixed == false && TextAlignment == TextAlignment.Right)
            {
                Move(cursorPosition + left - 1, 0);
            }
            else
            {
                Move(cursorPosition + left, 0);
            }
        }

        /// <summary>
        /// Margins for text alignment.
        /// </summary>
        /// <param name="width">Total width</param>
        /// <returns>Left and right margins</returns>
        (int left, int right) GetMargins(int width)
        {
            var count = Text.Length;
            var total = width - count;
            switch (TextAlignment)
            {
                case TextAlignment.Left:
                    return (0, total);
                case TextAlignment.Centered:
                    return (total / 2, (total / 2) + (total % 2));
                case TextAlignment.Right:
                    return (total, 0);
                default:
                    return (0, total);
            }
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            if (provider == null)
            {
                Move(0, 0);
                Driver.AddStr("Error: ITextValidateProvider not set!");
                return;
            }

            var bgcolor = !IsValid ? Color.BrightRed : ColorScheme.Focus.Background;
            var textColor = new Attribute(ColorScheme.Focus.Foreground, bgcolor);

            var (margin_left, margin_right) = GetMargins(bounds.Width);

            Move(0, 0);

            // Left Margin
            Driver.SetAttribute(textColor);
            for (int i = 0; i < margin_left; i++)
            {
                Driver.AddRune(' ');
            }

            // Content
            Driver.SetAttribute(textColor);
            // Content
            for (int i = 0; i < provider.DisplayText.Length; i++)
            {
                Driver.AddRune(provider.DisplayText[i]);
            }

            // Right Margin
            Driver.SetAttribute(textColor);
            for (int i = 0; i < margin_right; i++)
            {
                Driver.AddRune(' ');
            }
        }

        /// <summary>
        /// Try to move the cursor to the left.
        /// </summary>
        /// <returns>True if moved.</returns>
        bool CursorLeft()
        {
            var current = cursorPosition;
            cursorPosition = provider.CursorLeft(cursorPosition);
            SetNeedsDisplay();
            return current != cursorPosition;
        }

        /// <summary>
        /// Try to move the cursor to the right.
        /// </summary>
        /// <returns>True if moved.</returns>
        bool CursorRight()
        {
            var current = cursorPosition;
            cursorPosition = provider.CursorRight(cursorPosition);
            SetNeedsDisplay();
            return current != cursorPosition;
        }

        /// <summary>
        /// Delete char at cursor position - 1, moving the cursor.
        /// </summary>
        /// <returns></returns>
        bool BackspaceKeyHandler()
        {
            if (provider.Fixed == false && TextAlignment == TextAlignment.Right && cursorPosition <= 1)
            {
                return false;
            }
            cursorPosition = provider.CursorLeft(cursorPosition);
            provider.Delete(cursorPosition);
            SetNeedsDisplay();
            return true;
        }

        /// <summary>
        /// Deletes char at current position.
        /// </summary>
        /// <returns></returns>
        bool DeleteKeyHandler()
        {
            if (provider.Fixed == false && TextAlignment == TextAlignment.Right)
            {
                cursorPosition = provider.CursorLeft(cursorPosition);
            }
            provider.Delete(cursorPosition);
            SetNeedsDisplay();
            return true;
        }

        /// <summary>
        /// Moves the cursor to first char.
        /// </summary>
        /// <returns></returns>
        bool HomeKeyHandler()
        {
            cursorPosition = provider.CursorStart();
            SetNeedsDisplay();
            return true;
        }

        /// <summary>
        /// Moves the cursor to the last char.
        /// </summary>
        /// <returns></returns>
        bool EndKeyHandler()
        {
            cursorPosition = provider.CursorEnd();
            SetNeedsDisplay();
            return true;
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            if (provider == null)
            {
                return false;
            }

            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            if (kb.Key < Key.Space || kb.Key > Key.CharMask)
                return false;

            var key = new Rune((uint)kb.KeyValue);

            var inserted = provider.InsertAt((char)key, cursorPosition);

            if (inserted)
            {
                CursorRight();
            }

            return true;
        }

        /// <summary>
        /// This property returns true if the input is valid.
        /// </summary>
        public virtual bool IsValid
        {
            get
            {
                if (provider == null)
                {
                    return false;
                }

                return provider.IsValid;
            }
        }
    }
    //=======================================================================
    // TextView.cs: multi-line text editing

    class TextModel
    {
        List<List<Rune>> lines = new List<List<Rune>>();

        public event Action LinesLoaded;

        public bool LoadFile(string file)
        {
            FilePath = file ?? throw new ArgumentNullException(nameof(file));

            var stream = File.OpenRead(file);
            LoadStream(stream);
            return true;
        }

        public bool CloseFile()
        {
            if (FilePath == null)
                throw new ArgumentNullException(nameof(FilePath));

            FilePath = null;
            lines = new List<List<Rune>>();
            return true;
        }

        // Turns the ustring into runes, this does not split the 
        // contents on a newline if it is present.
        internal static List<Rune> ToRunes(ustring str)
        {
            List<Rune> runes = new List<Rune>();
            foreach (var x in str.ToRunes())
            {
                runes.Add(x);
            }
            return runes;
        }

        // Splits a string into a List that contains a List<Rune> for each line
        public static List<List<Rune>> StringToRunes(ustring content)
        {
            var lines = new List<List<Rune>>();
            int start = 0, i = 0;
            var hasCR = false;
            // ASCII code 13 = Carriage Return.
            // ASCII code 10 = Line Feed.
            for (; i < content.Length; i++)
            {
                if (content[i] == 13)
                {
                    hasCR = true;
                    continue;
                }
                if (content[i] == 10)
                {
                    if (i - start > 0)
                        lines.Add(ToRunes(content[start, hasCR ? i - 1 : i]));
                    else
                        lines.Add(ToRunes(ustring.Empty));
                    start = i + 1;
                    hasCR = false;
                }
            }
            if (i - start >= 0)
                lines.Add(ToRunes(content[start, null]));
            return lines;
        }

        void Append(List<byte> line)
        {
            var str = ustring.Make(line.ToArray());
            lines.Add(ToRunes(str));
        }

        public void LoadStream(Stream input)
        {
            if (input == null)
                throw new ArgumentNullException(nameof(input));

            lines = new List<List<Rune>>();
            var buff = new BufferedStream(input);
            int v;
            var line = new List<byte>();
            var wasNewLine = false;
            while ((v = buff.ReadByte()) != -1)
            {
                if (v == 13)
                {
                    continue;
                }
                if (v == 10)
                {
                    Append(line);
                    line.Clear();
                    wasNewLine = true;
                    continue;
                }
                line.Add((byte)v);
                wasNewLine = false;
            }
            if (line.Count > 0 || wasNewLine)
                Append(line);
            buff.Dispose();

            OnLinesLoaded();
        }

        public void LoadString(ustring content)
        {
            lines = StringToRunes(content);

            OnLinesLoaded();
        }

        void OnLinesLoaded()
        {
            LinesLoaded?.Invoke();
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            for (int i = 0; i < lines.Count; i++)
            {
                sb.Append(ustring.Make(lines[i]));
                if ((i + 1) < lines.Count)
                {
                    sb.AppendLine();
                }
            }
            return sb.ToString();
        }

        public string FilePath { get; set; }

        /// <summary>
        /// The number of text lines in the model
        /// </summary>
        public int Count => lines.Count;

        /// <summary>
        /// Returns the specified line as a List of Rune
        /// </summary>
        /// <returns>The line.</returns>
        /// <param name="line">Line number to retrieve.</param>
        public List<Rune> GetLine(int line)
        {
            if (lines.Count > 0)
            {
                if (line < Count)
                {
                    return lines[line];
                }
                else
                {
                    return lines[Count - 1];
                }
            }
            else
            {
                lines.Add(new List<Rune>());
                return lines[0];
            }
        }

        /// <summary>
        /// Adds a line to the model at the specified position.
        /// </summary>
        /// <param name="pos">Line number where the line will be inserted.</param>
        /// <param name="runes">The line of text, as a List of Rune.</param>
        public void AddLine(int pos, List<Rune> runes)
        {
            lines.Insert(pos, runes);
        }

        /// <summary>
        /// Removes the line at the specified position
        /// </summary>
        /// <param name="pos">Position.</param>
        public void RemoveLine(int pos)
        {
            if (lines.Count > 0)
            {
                if (lines.Count == 1 && lines[0].Count == 0)
                {
                    return;
                }
                lines.RemoveAt(pos);
            }
        }

        public void ReplaceLine(int pos, List<Rune> runes)
        {
            if (lines.Count > 0 && pos < lines.Count)
            {
                lines[pos] = new List<Rune>(runes);
            }
            else if (lines.Count == 0 || (lines.Count > 0 && pos >= lines.Count))
            {
                lines.Add(runes);
            }
        }

        /// <summary>
        /// Returns the maximum line length of the visible lines.
        /// </summary>
        /// <param name="first">The first line.</param>
        /// <param name="last">The last line.</param>
        /// <param name="tabWidth">The tab width.</param>
        public int GetMaxVisibleLine(int first, int last, int tabWidth)
        {
            int maxLength = 0;
            last = last < lines.Count ? last : lines.Count;
            for (int i = first; i < last; i++)
            {
                var line = GetLine(i);
                var tabSum = line.Sum(r => r == '\t' ? Math.Max(tabWidth - 1, 0) : 0);
                var l = line.Count + tabSum;
                if (l > maxLength)
                {
                    maxLength = l;
                }
            }

            return maxLength;
        }

        internal static bool SetCol(ref int col, int width, int cols)
        {
            if (col + cols <= width)
            {
                col += cols;
                return true;
            }

            return false;
        }

        internal static int GetColFromX(List<Rune> t, int start, int x, int tabWidth = 0)
        {
            if (x < 0)
            {
                return x;
            }
            int size = start;
            var pX = x + start;
            for (int i = start; i < t.Count; i++)
            {
                var r = t[i];
                size += Rune.ColumnWidth(r);
                if (r == '\t')
                {
                    size += tabWidth + 1;
                }
                if (i == pX || (size > pX))
                {
                    return i - start;
                }
            }
            return t.Count - start;
        }

        // Returns the size and length in a range of the string.
        internal static (int size, int length) DisplaySize(List<Rune> t, int start = -1, int end = -1,
            bool checkNextRune = true, int tabWidth = 0)
        {
            if (t == null || t.Count == 0)
            {
                return (0, 0);
            }
            int size = 0;
            int len = 0;
            int tcount = end == -1 ? t.Count : end > t.Count ? t.Count : end;
            int i = start == -1 ? 0 : start;
            for (; i < tcount; i++)
            {
                var rune = t[i];
                size += Rune.ColumnWidth(rune);
                len += Rune.RuneLen(rune);
                if (rune == '\t')
                {
                    size += tabWidth + 1;
                    len += tabWidth - 1;
                }
                if (checkNextRune && i == tcount - 1 && t.Count > tcount
                    && IsWideRune(t[i + 1], tabWidth, out int s, out int l))
                {
                    size += s;
                    len += l;
                }
            }

            bool IsWideRune(Rune r, int tWidth, out int s, out int l)
            {
                s = Rune.ColumnWidth(r);
                l = Rune.RuneLen(r);
                if (r == '\t')
                {
                    s += tWidth + 1;
                    l += tWidth - 1;
                }

                return s > 1;
            }

            return (size, len);
        }

        // Returns the left column in a range of the string.
        internal static int CalculateLeftColumn(List<Rune> t, int start, int end, int width, int tabWidth = 0)
        {
            if (t == null || t.Count == 0)
            {
                return 0;
            }
            int size = 0;
            int tcount = end > t.Count - 1 ? t.Count - 1 : end;
            int col = 0;

            for (int i = tcount; i >= 0; i--)
            {
                var rune = t[i];
                size += Rune.ColumnWidth(rune);
                if (rune == '\t')
                {
                    size += tabWidth + 1;
                }
                if (size > width)
                {
                    if (col + width == end)
                    {
                        col++;
                    }
                    break;
                }
                else if ((end < t.Count && col > 0 && start < end && col == start) || (end - col == width - 1))
                {
                    break;
                }
                col = i;
            }

            return col;
        }

        (Point startPointToFind, Point currentPointToFind, bool found) toFind;

        internal (Point current, bool found) FindNextText(ustring text, out bool gaveFullTurn, bool matchCase = false, bool matchWholeWord = false)
        {
            if (text == null || lines.Count == 0)
            {
                gaveFullTurn = false;
                return (Point.Empty, false);
            }

            if (toFind.found)
            {
                toFind.currentPointToFind.X++;
            }
            var foundPos = GetFoundNextTextPoint(text, lines.Count, matchCase, matchWholeWord, toFind.currentPointToFind);
            if (!foundPos.found && toFind.currentPointToFind != toFind.startPointToFind)
            {
                foundPos = GetFoundNextTextPoint(text, toFind.startPointToFind.Y + 1, matchCase, matchWholeWord, Point.Empty);
            }
            gaveFullTurn = ApplyToFind(foundPos);

            return foundPos;
        }

        internal (Point current, bool found) FindPreviousText(ustring text, out bool gaveFullTurn, bool matchCase = false, bool matchWholeWord = false)
        {
            if (text == null || lines.Count == 0)
            {
                gaveFullTurn = false;
                return (Point.Empty, false);
            }

            if (toFind.found)
            {
                toFind.currentPointToFind.X++;
            }
            var linesCount = toFind.currentPointToFind.IsEmpty ? lines.Count - 1 : toFind.currentPointToFind.Y;
            var foundPos = GetFoundPreviousTextPoint(text, linesCount, matchCase, matchWholeWord, toFind.currentPointToFind);
            if (!foundPos.found && toFind.currentPointToFind != toFind.startPointToFind)
            {
                foundPos = GetFoundPreviousTextPoint(text, lines.Count - 1, matchCase, matchWholeWord,
                    new Point(lines[lines.Count - 1].Count, lines.Count));
            }
            gaveFullTurn = ApplyToFind(foundPos);

            return foundPos;
        }

        internal (Point current, bool found) ReplaceAllText(ustring text, bool matchCase = false, bool matchWholeWord = false, ustring textToReplace = null)
        {
            bool found = false;
            Point pos = Point.Empty;

            for (int i = 0; i < lines.Count; i++)
            {
                var x = lines[i];
                var txt = GetText(x);
                var matchText = !matchCase ? text.ToUpper().ToString() : text.ToString();
                var col = txt.IndexOf(matchText);
                while (col > -1)
                {
                    if (matchWholeWord && !MatchWholeWord(txt, matchText, col))
                    {
                        if (col + 1 > txt.Length)
                        {
                            break;
                        }
                        col = txt.IndexOf(matchText, col + 1);
                        continue;
                    }
                    if (col > -1)
                    {
                        if (!found)
                        {
                            found = true;
                        }
                        lines[i] = ReplaceText(x, textToReplace, matchText, col).ToRuneList();
                        x = lines[i];
                        txt = GetText(x);
                        pos = new Point(col, i);
                        col += (textToReplace.Length - matchText.Length);
                    }
                    if (col < 0 || col + 1 > txt.Length)
                    {
                        break;
                    }
                    col = txt.IndexOf(matchText, col + 1);
                }
            }

            string GetText(List<Rune> x)
            {
                var txt = ustring.Make(x).ToString();
                if (!matchCase)
                {
                    txt = txt.ToUpper();
                }
                return txt;
            }

            return (pos, found);
        }

        ustring ReplaceText(List<Rune> source, ustring textToReplace, string matchText, int col)
        {
            var origTxt = ustring.Make(source);
            (int _, int len) = TextModel.DisplaySize(source, 0, col, false);
            (var _, var len2) = TextModel.DisplaySize(source, col, col + matchText.Length, false);
            (var _, var len3) = TextModel.DisplaySize(source, col + matchText.Length, origTxt.RuneCount, false);

            return origTxt[0, len] +
                textToReplace.ToString() +
                origTxt[len + len2, len + len2 + len3];
        }

        bool ApplyToFind((Point current, bool found) foundPos)
        {
            bool gaveFullTurn = false;
            if (foundPos.found)
            {
                toFind.currentPointToFind = foundPos.current;
                if (toFind.found && toFind.currentPointToFind == toFind.startPointToFind)
                {
                    gaveFullTurn = true;
                }
                if (!toFind.found)
                {
                    toFind.startPointToFind = toFind.currentPointToFind = foundPos.current;
                    toFind.found = foundPos.found;
                }
            }

            return gaveFullTurn;
        }

        (Point current, bool found) GetFoundNextTextPoint(ustring text, int linesCount, bool matchCase, bool matchWholeWord, Point start)
        {
            for (int i = start.Y; i < linesCount; i++)
            {
                var x = lines[i];
                var txt = ustring.Make(x).ToString();
                if (!matchCase)
                {
                    txt = txt.ToUpper();
                }
                var matchText = !matchCase ? text.ToUpper().ToString() : text.ToString();
                var col = txt.IndexOf(matchText, Math.Min(start.X, txt.Length));
                if (col > -1 && matchWholeWord && !MatchWholeWord(txt, matchText, col))
                {
                    continue;
                }
                if (col > -1 && ((i == start.Y && col >= start.X)
                    || i > start.Y)
                    && txt.Contains(matchText))
                {
                    return (new Point(col, i), true);
                }
                else if (col == -1 && start.X > 0)
                {
                    start.X = 0;
                }
            }

            return (Point.Empty, false);
        }

        (Point current, bool found) GetFoundPreviousTextPoint(ustring text, int linesCount, bool matchCase, bool matchWholeWord, Point start)
        {
            for (int i = linesCount; i >= 0; i--)
            {
                var x = lines[i];
                var txt = ustring.Make(x).ToString();
                if (!matchCase)
                {
                    txt = txt.ToUpper();
                }
                if (start.Y != i)
                {
                    start.X = Math.Max(x.Count - 1, 0);
                }
                var matchText = !matchCase ? text.ToUpper().ToString() : text.ToString();
                var col = txt.LastIndexOf(matchText, toFind.found ? start.X - 1 : start.X);
                if (col > -1 && matchWholeWord && !MatchWholeWord(txt, matchText, col))
                {
                    continue;
                }
                if (col > -1 && ((i <= linesCount && col <= start.X)
                    || i < start.Y)
                    && txt.Contains(matchText))
                {
                    return (new Point(col, i), true);
                }
            }

            return (Point.Empty, false);
        }

        bool MatchWholeWord(string source, string matchText, int index = 0)
        {
            if (string.IsNullOrEmpty(source) || string.IsNullOrEmpty(matchText))
            {
                return false;
            }

            var txt = matchText.Trim();
            var start = index > 0 ? index - 1 : 0;
            var end = index + txt.Length;

            if ((start == 0 || Rune.IsWhiteSpace(source[start]))
                && (end == source.Length || Rune.IsWhiteSpace(source[end])))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Redefine column and line tracking.
        /// </summary>
        /// <param name="point">Contains the column and line.</param>
        internal void ResetContinuousFind(Point point)
        {
            toFind.startPointToFind = toFind.currentPointToFind = point;
            toFind.found = false;
        }
    }

    class HistoryText
    {
        public enum LineStatus
        {
            Original,
            Replaced,
            Removed,
            Added
        }

        public class HistoryTextItem
        {
            public List<List<Rune>> Lines;
            public Point CursorPosition;
            public LineStatus LineStatus;
            public bool IsUndoing;
            public Point FinalCursorPosition;
            public HistoryTextItem RemovedOnAdded;

            public HistoryTextItem(List<List<Rune>> lines, Point curPos, LineStatus linesStatus)
            {
                Lines = lines;
                CursorPosition = curPos;
                LineStatus = linesStatus;
            }

            public HistoryTextItem(HistoryTextItem historyTextItem)
            {
                Lines = new List<List<Rune>>(historyTextItem.Lines);
                CursorPosition = new Point(historyTextItem.CursorPosition.X, historyTextItem.CursorPosition.Y);
                LineStatus = historyTextItem.LineStatus;
            }

            public override string ToString()
            {
                return $"(Count: {Lines.Count}, Cursor: {CursorPosition}, Status: {LineStatus})";
            }
        }

        List<HistoryTextItem> historyTextItems = new List<HistoryTextItem>();
        int idxHistoryText = -1;
        ustring originalText;

        public bool IsFromHistory { get; private set; }

        public bool HasHistoryChanges => idxHistoryText > -1;

        public event Action<HistoryTextItem> ChangeText;

        public void Add(List<List<Rune>> lines, Point curPos, LineStatus lineStatus = LineStatus.Original)
        {
            if (lineStatus == LineStatus.Original && historyTextItems.Count > 0
                && historyTextItems.Last().LineStatus == LineStatus.Original)
            {
                return;
            }
            if (lineStatus == LineStatus.Replaced && historyTextItems.Count > 0
                && historyTextItems.Last().LineStatus == LineStatus.Replaced)
            {
                return;
            }

            if (historyTextItems.Count == 0 && lineStatus != LineStatus.Original)
                throw new ArgumentException("The first item must be the original.");

            if (idxHistoryText >= 0 && idxHistoryText + 1 < historyTextItems.Count)
                historyTextItems.RemoveRange(idxHistoryText + 1, historyTextItems.Count - idxHistoryText - 1);

            historyTextItems.Add(new HistoryTextItem(lines, curPos, lineStatus));
            idxHistoryText++;
        }

        public void ReplaceLast(List<List<Rune>> lines, Point curPos, LineStatus lineStatus)
        {
            var found = historyTextItems.FindLast(x => x.LineStatus == lineStatus);
            if (found != null)
            {
                found.Lines = lines;
                found.CursorPosition = curPos;
            }
        }

        public void Undo()
        {
            if (historyTextItems?.Count > 0 && idxHistoryText > 0)
            {
                IsFromHistory = true;

                idxHistoryText--;

                var historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText])
                {
                    IsUndoing = true
                };

                ProcessChanges(ref historyTextItem);

                IsFromHistory = false;
            }
        }

        public void Redo()
        {
            if (historyTextItems?.Count > 0 && idxHistoryText < historyTextItems.Count - 1)
            {
                IsFromHistory = true;

                idxHistoryText++;

                var historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText])
                {
                    IsUndoing = false
                };

                ProcessChanges(ref historyTextItem);

                IsFromHistory = false;
            }
        }

        void ProcessChanges(ref HistoryTextItem historyTextItem)
        {
            if (historyTextItem.IsUndoing)
            {
                if (idxHistoryText - 1 > -1 && ((historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Added)
                    || historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed
                    || (historyTextItem.LineStatus == LineStatus.Replaced &&
                    historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Original)))
                {

                    idxHistoryText--;

                    while (historyTextItems[idxHistoryText].LineStatus == LineStatus.Added
                        && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed)
                    {

                        idxHistoryText--;
                    }
                    historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText]);
                    historyTextItem.IsUndoing = true;
                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
                }

                if (historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Added)
                {
                    historyTextItem.RemovedOnAdded = new HistoryTextItem(historyTextItems[idxHistoryText + 1]);
                }

                if ((historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Original)
                    || (historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Original)
                    || (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed))
                {

                    if (!historyTextItem.Lines[0].SequenceEqual(historyTextItems[idxHistoryText - 1].Lines[0])
                        && historyTextItem.CursorPosition == historyTextItems[idxHistoryText - 1].CursorPosition)
                    {
                        historyTextItem.Lines[0] = new List<Rune>(historyTextItems[idxHistoryText - 1].Lines[0]);
                    }
                    if (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed)
                    {
                        historyTextItem.FinalCursorPosition = historyTextItems[idxHistoryText - 2].CursorPosition;
                    }
                    else
                    {
                        historyTextItem.FinalCursorPosition = historyTextItems[idxHistoryText - 1].CursorPosition;
                    }
                }
                else
                {
                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
                }

                OnChangeText(historyTextItem);
                while (historyTextItems[idxHistoryText].LineStatus == LineStatus.Removed
                    || historyTextItems[idxHistoryText].LineStatus == LineStatus.Added)
                {

                    idxHistoryText--;
                }
            }
            else if (!historyTextItem.IsUndoing)
            {
                if (idxHistoryText + 1 < historyTextItems.Count && (historyTextItem.LineStatus == LineStatus.Original
                    || historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Added
                    || historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Removed))
                {

                    idxHistoryText++;
                    historyTextItem = new HistoryTextItem(historyTextItems[idxHistoryText]);
                    historyTextItem.IsUndoing = false;
                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
                }

                if (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText - 1].LineStatus == LineStatus.Removed)
                {
                    historyTextItem.RemovedOnAdded = new HistoryTextItem(historyTextItems[idxHistoryText - 1]);
                }

                if ((historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Replaced)
                    || (historyTextItem.LineStatus == LineStatus.Removed && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Original)
                    || (historyTextItem.LineStatus == LineStatus.Added && historyTextItems[idxHistoryText + 1].LineStatus == LineStatus.Replaced))
                {

                    if (historyTextItem.LineStatus == LineStatus.Removed
                        && !historyTextItem.Lines[0].SequenceEqual(historyTextItems[idxHistoryText + 1].Lines[0]))
                    {
                        historyTextItem.Lines[0] = new List<Rune>(historyTextItems[idxHistoryText + 1].Lines[0]);
                    }
                    historyTextItem.FinalCursorPosition = historyTextItems[idxHistoryText + 1].CursorPosition;
                }
                else
                {
                    historyTextItem.FinalCursorPosition = historyTextItem.CursorPosition;
                }

                OnChangeText(historyTextItem);
                while (historyTextItems[idxHistoryText].LineStatus == LineStatus.Removed
                    || historyTextItems[idxHistoryText].LineStatus == LineStatus.Added)
                {

                    idxHistoryText++;
                }
            }
        }

        void OnChangeText(HistoryTextItem lines)
        {
            ChangeText?.Invoke(lines);
        }

        public void Clear(ustring text)
        {
            historyTextItems.Clear();
            idxHistoryText = -1;
            originalText = text;
            OnChangeText(null);
        }

        public bool IsDirty(ustring text)
        {
            return originalText != text;
        }
    }

    class WordWrapManager
    {
        class WrappedLine
        {
            public int ModelLine;
            public int Row;
            public int RowIndex;
            public int ColWidth;
        }

        List<WrappedLine> wrappedModelLines = new List<WrappedLine>();
        int frameWidth;
        bool isWrapModelRefreshing;

        public TextModel Model { get; private set; }

        public WordWrapManager(TextModel model)
        {
            Model = model;
        }

        public TextModel WrapModel(int width, out int nRow, out int nCol, out int nStartRow, out int nStartCol,
            int row = 0, int col = 0, int startRow = 0, int startCol = 0, int tabWidth = 0, bool preserveTrailingSpaces = true)
        {
            frameWidth = width;

            var modelRow = isWrapModelRefreshing ? row : GetModelLineFromWrappedLines(row);
            var modelCol = isWrapModelRefreshing ? col : GetModelColFromWrappedLines(row, col);
            var modelStartRow = isWrapModelRefreshing ? startRow : GetModelLineFromWrappedLines(startRow);
            var modelStartCol = isWrapModelRefreshing ? startCol : GetModelColFromWrappedLines(startRow, startCol);
            var wrappedModel = new TextModel();
            int lines = 0;
            nRow = 0;
            nCol = 0;
            nStartRow = 0;
            nStartCol = 0;
            bool isRowAndColSetted = row == 0 && col == 0;
            bool isStartRowAndColSetted = startRow == 0 && startCol == 0;
            List<WrappedLine> wModelLines = new List<WrappedLine>();

            for (int i = 0; i < Model.Count; i++)
            {
                var line = Model.GetLine(i);
                var wrappedLines = ToListRune(
                    TextFormatter.Format(ustring.Make(line), width, TextAlignment.Left, true, preserveTrailingSpaces, tabWidth));
                int sumColWidth = 0;
                for (int j = 0; j < wrappedLines.Count; j++)
                {
                    var wrapLine = wrappedLines[j];
                    if (!isRowAndColSetted && modelRow == i)
                    {
                        if (nCol + wrapLine.Count <= modelCol)
                        {
                            nCol += wrapLine.Count;
                            nRow = lines;
                            if (nCol == modelCol)
                            {
                                nCol = wrapLine.Count;
                                isRowAndColSetted = true;
                            }
                            else if (j == wrappedLines.Count - 1)
                            {
                                nCol = wrapLine.Count - j + modelCol - nCol;
                                isRowAndColSetted = true;
                            }
                        }
                        else
                        {
                            var offset = nCol + wrapLine.Count - modelCol;
                            nCol = wrapLine.Count - offset;
                            nRow = lines;
                            isRowAndColSetted = true;
                        }
                    }
                    if (!isStartRowAndColSetted && modelStartRow == i)
                    {
                        if (nStartCol + wrapLine.Count <= modelStartCol)
                        {
                            nStartCol += wrapLine.Count;
                            nStartRow = lines;
                            if (nStartCol == modelStartCol)
                            {
                                nStartCol = wrapLine.Count;
                                isStartRowAndColSetted = true;
                            }
                            else if (j == wrappedLines.Count - 1)
                            {
                                nStartCol = wrapLine.Count - j + modelStartCol - nStartCol;
                                isStartRowAndColSetted = true;
                            }
                        }
                        else
                        {
                            var offset = nStartCol + wrapLine.Count - modelStartCol;
                            nStartCol = wrapLine.Count - offset;
                            nStartRow = lines;
                            isStartRowAndColSetted = true;
                        }
                    }
                    wrappedModel.AddLine(lines, wrapLine);
                    sumColWidth += wrapLine.Count;
                    var wrappedLine = new WrappedLine()
                    {
                        ModelLine = i,
                        Row = lines,
                        RowIndex = j,
                        ColWidth = wrapLine.Count,
                    };
                    wModelLines.Add(wrappedLine);
                    lines++;
                }
            }
            wrappedModelLines = wModelLines;

            return wrappedModel;
        }

        public List<List<Rune>> ToListRune(List<ustring> textList)
        {
            var runesList = new List<List<Rune>>();

            foreach (var text in textList)
            {
                runesList.Add(text.ToRuneList());
            }

            return runesList;
        }

        public int GetModelLineFromWrappedLines(int line) => wrappedModelLines.Count > 0
            ? wrappedModelLines[Math.Min(line, wrappedModelLines.Count - 1)].ModelLine
            : 0;

        public int GetModelColFromWrappedLines(int line, int col)
        {
            if (wrappedModelLines?.Count == 0)
            {
                return 0;
            }

            var modelLine = GetModelLineFromWrappedLines(line);
            var firstLine = wrappedModelLines.IndexOf(r => r.ModelLine == modelLine);
            int modelCol = 0;

            for (int i = firstLine; i <= Math.Min(line, wrappedModelLines.Count - 1); i++)
            {
                var wLine = wrappedModelLines[i];

                if (i < line)
                {
                    modelCol += wLine.ColWidth;
                }
                else
                {
                    modelCol += col;
                }
            }

            return modelCol;
        }

        List<Rune> GetCurrentLine(int row) => Model.GetLine(row);

        public void AddLine(int row, int col)
        {
            var modelRow = GetModelLineFromWrappedLines(row);
            var modelCol = GetModelColFromWrappedLines(row, col);
            var line = GetCurrentLine(modelRow);
            var restCount = line.Count - modelCol;
            var rest = line.GetRange(modelCol, restCount);
            line.RemoveRange(modelCol, restCount);
            Model.AddLine(modelRow + 1, rest);
            isWrapModelRefreshing = true;
            WrapModel(frameWidth, out _, out _, out _, out _, modelRow + 1, 0);
            isWrapModelRefreshing = false;
        }

        public bool Insert(int row, int col, Rune rune)
        {
            var line = GetCurrentLine(GetModelLineFromWrappedLines(row));
            line.Insert(GetModelColFromWrappedLines(row, col), rune);
            if (line.Count > frameWidth)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public bool RemoveAt(int row, int col)
        {
            var modelRow = GetModelLineFromWrappedLines(row);
            var line = GetCurrentLine(modelRow);
            var modelCol = GetModelColFromWrappedLines(row, col);

            if (modelCol > line.Count)
            {
                Model.RemoveLine(modelRow);
                RemoveAt(row, 0);
                return false;
            }
            if (modelCol < line.Count)
                line.RemoveAt(modelCol);
            if (line.Count > frameWidth || (row + 1 < wrappedModelLines.Count
                && wrappedModelLines[row + 1].ModelLine == modelRow))
            {
                return true;
            }

            return false;
        }

        public bool RemoveLine(int row, int col, out bool lineRemoved, bool forward = true)
        {
            lineRemoved = false;
            var modelRow = GetModelLineFromWrappedLines(row);
            var line = GetCurrentLine(modelRow);
            var modelCol = GetModelColFromWrappedLines(row, col);

            if (modelCol == 0 && line.Count == 0)
            {
                Model.RemoveLine(modelRow);
                return false;
            }
            else if (modelCol < line.Count)
            {
                if (forward)
                {
                    line.RemoveAt(modelCol);
                    return true;
                }
                else if (modelCol - 1 > -1)
                {
                    line.RemoveAt(modelCol - 1);
                    return true;
                }
            }
            lineRemoved = true;
            if (forward)
            {
                if (modelRow + 1 == Model.Count)
                {
                    return false;
                }

                var nextLine = Model.GetLine(modelRow + 1);
                line.AddRange(nextLine);
                Model.RemoveLine(modelRow + 1);
                if (line.Count > frameWidth)
                {
                    return true;
                }
            }
            else
            {
                if (modelRow == 0)
                {
                    return false;
                }

                var prevLine = Model.GetLine(modelRow - 1);
                prevLine.AddRange(line);
                Model.RemoveLine(modelRow);
                if (prevLine.Count > frameWidth)
                {
                    return true;
                }
            }

            return false;
        }

        public bool RemoveRange(int row, int index, int count)
        {
            var modelRow = GetModelLineFromWrappedLines(row);
            var line = GetCurrentLine(modelRow);
            var modelCol = GetModelColFromWrappedLines(row, index);

            try
            {
                line.RemoveRange(modelCol, count);
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        public void UpdateModel(TextModel model, out int nRow, out int nCol, out int nStartRow, out int nStartCol,
            int row, int col, int startRow, int startCol, bool preserveTrailingSpaces)
        {
            isWrapModelRefreshing = true;
            Model = model;
            WrapModel(frameWidth, out nRow, out nCol, out nStartRow, out nStartCol, row, col, startRow, startCol, tabWidth: 0, preserveTrailingSpaces);
            isWrapModelRefreshing = false;
        }

        public int GetWrappedLineColWidth(int line, int col, WordWrapManager wrapManager)
        {
            if (wrappedModelLines?.Count == 0)
                return 0;

            var wModelLines = wrapManager.wrappedModelLines;
            var modelLine = GetModelLineFromWrappedLines(line);
            var firstLine = wrappedModelLines.IndexOf(r => r.ModelLine == modelLine);
            int modelCol = 0;
            int colWidthOffset = 0;
            int i = firstLine;

            while (modelCol < col)
            {
                var wLine = wrappedModelLines[i];
                var wLineToCompare = wModelLines[i];

                if (wLine.ModelLine != modelLine || wLineToCompare.ModelLine != modelLine)
                    break;

                modelCol += Math.Max(wLine.ColWidth, wLineToCompare.ColWidth);
                colWidthOffset += wLine.ColWidth - wLineToCompare.ColWidth;
                if (modelCol > col)
                {
                    modelCol += col - modelCol;
                }
                i++;
            }

            return modelCol - colWidthOffset;
        }
    }

    /// <summary>
    ///  Multi-line text editing <see cref="View"/>.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///   <see cref="TextView"/> provides a multi-line text editor. Users interact
    ///   with it with the standard Windows, Mac, and Linux (Emacs) commands. 
    ///  </para> 
    ///  <list type="table"> 
    ///   <listheader>
    ///    <term>Shortcut</term>
    ///    <description>Action performed</description>
    ///   </listheader>
    ///   <item>
    ///    <term>Left cursor, Control-b</term>
    ///    <description>
    ///     Moves the editing point left.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Right cursor, Control-f</term>
    ///    <description>
    ///     Moves the editing point right.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Alt-b</term>
    ///    <description>
    ///     Moves one word back.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Alt-f</term>
    ///    <description>
    ///     Moves one word forward.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Up cursor, Control-p</term>
    ///    <description>
    ///     Moves the editing point one line up.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Down cursor, Control-n</term>
    ///    <description>
    ///     Moves the editing point one line down
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Home key, Control-a</term>
    ///    <description>
    ///     Moves the cursor to the beginning of the line.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>End key, Control-e</term>
    ///    <description>
    ///     Moves the cursor to the end of the line.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Control-Home</term>
    ///    <description>
    ///     Scrolls to the first line and moves the cursor there.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Control-End</term>
    ///    <description>
    ///     Scrolls to the last line and moves the cursor there.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Delete, Control-d</term>
    ///    <description>
    ///     Deletes the character in front of the cursor.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Backspace</term>
    ///    <description>
    ///     Deletes the character behind the cursor.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Control-k</term>
    ///    <description>
    ///     Deletes the text until the end of the line and replaces the kill buffer
    ///     with the deleted text. You can paste this text in a different place by
    ///     using Control-y.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Control-y</term>
    ///    <description>
    ///      Pastes the content of the kill ring into the current position.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Alt-d</term>
    ///    <description>
    ///      Deletes the word above the cursor and adds it to the kill ring. You 
    ///      can paste the contents of the kill ring with Control-y.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <term>Control-q</term>
    ///    <description>
    ///     Quotes the next input character, to prevent the normal processing of
    ///     key handling to take place.
    ///    </description>
    ///   </item>
    ///  </list>
    /// </remarks>
    public class TextView : View
    {
        TextModel model = new TextModel();
        int topRow;
        int leftColumn;
        int currentRow;
        int currentColumn;
        int selectionStartColumn, selectionStartRow;
        bool selecting;
        bool wordWrap;
        WordWrapManager wrapManager;
        bool continuousFind;
        int bottomOffset, rightOffset;
        int tabWidth = 4;
        bool allowsTab = true;
        bool allowsReturn = true;
        bool multiline = true;
        HistoryText historyText = new HistoryText();
        CultureInfo currentCulture;

        /// <summary>
        /// Raised when the <see cref="Text"/> property of the <see cref="TextView"/> changes.
        /// </summary>
        /// <remarks>
        /// The <see cref="Text"/> property of <see cref="TextView"/> only changes when it is explicitly
        /// set, not as the user types. To be notified as the user changes the contents of the TextView
        /// see <see cref="IsDirty"/>.
        /// </remarks>
        public event Action TextChanged;

        /// <summary>
        ///  Raised when the contents of the <see cref="TextView"/> are changed. 
        /// </summary>
        /// <remarks>
        /// Unlike the <see cref="TextChanged"/> event, this event is raised whenever the user types or
        /// otherwise changes the contents of the <see cref="TextView"/>.
        /// </remarks>
        public event Action<ContentsChangedEventArgs> ContentsChanged;

        /// <summary>
        /// Invoked with the unwrapped <see cref="CursorPosition"/>.
        /// </summary>
        public event Action<Point> UnwrappedCursorPosition;

        /// <summary>
        /// Provides autocomplete context menu based on suggestions at the current cursor
        /// position. Populate <see cref="Autocomplete.AllSuggestions"/> to enable this feature
        /// </summary>
        public IAutocomplete Autocomplete { get; protected set; } = new TextViewAutocomplete();

        /// <summary>
        ///  Initializes a <see cref="TextView"/> on the specified area, with absolute position and size.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public TextView(Rect frame) : base(frame)
        {
            Initialize();
        }

        /// <summary>
        ///  Initializes a <see cref="TextView"/> on the specified area, 
        ///  with dimensions controlled with the X, Y, Width and Height properties.
        /// </summary>
        public TextView() : base()
        {
            Initialize();
        }

        void Initialize()
        {
            CanFocus = true;
            Used = true;

            model.LinesLoaded += Model_LinesLoaded;
            historyText.ChangeText += HistoryText_ChangeText;

            Initialized += TextView_Initialized;

            // Things this view knows how to do
            AddCommand(Command.PageDown, () => { ProcessPageDown(); return true; });
            AddCommand(Command.PageDownExtend, () => { ProcessPageDownExtend(); return true; });
            AddCommand(Command.PageUp, () => { ProcessPageUp(); return true; });
            AddCommand(Command.PageUpExtend, () => { ProcessPageUpExtend(); return true; });
            AddCommand(Command.LineDown, () => { ProcessMoveDown(); return true; });
            AddCommand(Command.LineDownExtend, () => { ProcessMoveDownExtend(); return true; });
            AddCommand(Command.LineUp, () => { ProcessMoveUp(); return true; });
            AddCommand(Command.LineUpExtend, () => { ProcessMoveUpExtend(); return true; });
            AddCommand(Command.Right, () => ProcessMoveRight());
            AddCommand(Command.RightExtend, () => { ProcessMoveRightExtend(); return true; });
            AddCommand(Command.Left, () => ProcessMoveLeft());
            AddCommand(Command.LeftExtend, () => { ProcessMoveLeftExtend(); return true; });
            AddCommand(Command.DeleteCharLeft, () => { ProcessDeleteCharLeft(); return true; });
            AddCommand(Command.StartOfLine, () => { ProcessMoveStartOfLine(); return true; });
            AddCommand(Command.StartOfLineExtend, () => { ProcessMoveStartOfLineExtend(); return true; });
            AddCommand(Command.DeleteCharRight, () => { ProcessDeleteCharRight(); return true; });
            AddCommand(Command.EndOfLine, () => { ProcessMoveEndOfLine(); return true; });
            AddCommand(Command.EndOfLineExtend, () => { ProcessMoveEndOfLineExtend(); return true; });
            AddCommand(Command.CutToEndLine, () => { KillToEndOfLine(); return true; });
            AddCommand(Command.CutToStartLine, () => { KillToStartOfLine(); return true; });
            AddCommand(Command.Paste, () => { ProcessPaste(); return true; });
            AddCommand(Command.ToggleExtend, () => { ToggleSelecting(); return true; });
            AddCommand(Command.Copy, () => { ProcessCopy(); return true; });
            AddCommand(Command.Cut, () => { ProcessCut(); return true; });
            AddCommand(Command.WordLeft, () => { ProcessMoveWordBackward(); return true; });
            AddCommand(Command.WordLeftExtend, () => { ProcessMoveWordBackwardExtend(); return true; });
            AddCommand(Command.WordRight, () => { ProcessMoveWordForward(); return true; });
            AddCommand(Command.WordRightExtend, () => { ProcessMoveWordForwardExtend(); return true; });
            AddCommand(Command.KillWordForwards, () => { ProcessKillWordForward(); return true; });
            AddCommand(Command.KillWordBackwards, () => { ProcessKillWordBackward(); return true; });
            AddCommand(Command.NewLine, () => ProcessReturn());
            AddCommand(Command.BottomEnd, () => { MoveBottomEnd(); return true; });
            AddCommand(Command.BottomEndExtend, () => { MoveBottomEndExtend(); return true; });
            AddCommand(Command.TopHome, () => { MoveTopHome(); return true; });
            AddCommand(Command.TopHomeExtend, () => { MoveTopHomeExtend(); return true; });
            AddCommand(Command.SelectAll, () => { ProcessSelectAll(); return true; });
            AddCommand(Command.ToggleOverwrite, () => { ProcessSetOverwrite(); return true; });
            AddCommand(Command.EnableOverwrite, () => { SetOverwrite(true); return true; });
            AddCommand(Command.DisableOverwrite, () => { SetOverwrite(false); return true; });
            AddCommand(Command.Tab, () => ProcessTab());
            AddCommand(Command.BackTab, () => ProcessBackTab());
            AddCommand(Command.NextView, () => ProcessMoveNextView());
            AddCommand(Command.PreviousView, () => ProcessMovePreviousView());
            AddCommand(Command.Undo, () => { UndoChanges(); return true; });
            AddCommand(Command.Redo, () => { RedoChanges(); return true; });
            AddCommand(Command.DeleteAll, () => { DeleteAll(); return true; });
            AddCommand(Command.Accept, () =>
            {
                ContextMenu.Position = new Point(CursorPosition.X - leftColumn + 2, CursorPosition.Y - topRow + 2);
                ShowContextMenu();
                return true;
            });

            // Default keybindings for this view
            AddKeyBinding(Key.PageDown, Command.PageDown);
            AddKeyBinding(Key.V | Key.CtrlMask, Command.PageDown);

            AddKeyBinding(Key.PageDown | Key.ShiftMask, Command.PageDownExtend);

            AddKeyBinding(Key.PageUp, Command.PageUp);
            AddKeyBinding(((int)'V' + Key.AltMask), Command.PageUp);

            AddKeyBinding(Key.PageUp | Key.ShiftMask, Command.PageUpExtend);

            AddKeyBinding(Key.N | Key.CtrlMask, Command.LineDown);
            AddKeyBinding(Key.CursorDown, Command.LineDown);

            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.LineDownExtend);

            AddKeyBinding(Key.P | Key.CtrlMask, Command.LineUp);
            AddKeyBinding(Key.CursorUp, Command.LineUp);

            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LineUpExtend);

            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);
            AddKeyBinding(Key.CursorRight, Command.Right);

            AddKeyBinding(Key.CursorRight | Key.ShiftMask, Command.RightExtend);

            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);
            AddKeyBinding(Key.CursorLeft, Command.Left);

            AddKeyBinding(Key.CursorLeft | Key.ShiftMask, Command.LeftExtend);

            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);

            AddKeyBinding(Key.Home, Command.StartOfLine);
            AddKeyBinding(Key.A | Key.CtrlMask, Command.StartOfLine);

            AddKeyBinding(Key.Home | Key.ShiftMask, Command.StartOfLineExtend);

            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);

            AddKeyBinding(Key.End, Command.EndOfLine);
            AddKeyBinding(Key.E | Key.CtrlMask, Command.EndOfLine);

            AddKeyBinding(Key.End | Key.ShiftMask, Command.EndOfLineExtend);

            AddKeyBinding(Key.K | Key.CtrlMask, Command.CutToEndLine); // kill-to-end
            AddKeyBinding(Key.DeleteChar | Key.CtrlMask | Key.ShiftMask, Command.CutToEndLine); // kill-to-end

            AddKeyBinding(Key.K | Key.AltMask, Command.CutToStartLine); // kill-to-start
            AddKeyBinding(Key.Backspace | Key.CtrlMask | Key.ShiftMask, Command.CutToStartLine); // kill-to-start

            AddKeyBinding(Key.Y | Key.CtrlMask, Command.Paste); // Control-y, yank
            AddKeyBinding(Key.Space | Key.CtrlMask, Command.ToggleExtend);

            AddKeyBinding(((int)'C' + Key.AltMask), Command.Copy);
            AddKeyBinding(Key.C | Key.CtrlMask, Command.Copy);

            AddKeyBinding(((int)'W' + Key.AltMask), Command.Cut);
            AddKeyBinding(Key.W | Key.CtrlMask, Command.Cut);
            AddKeyBinding(Key.X | Key.CtrlMask, Command.Cut);

            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.WordLeft);
            AddKeyBinding((Key)((int)'B' + Key.AltMask), Command.WordLeft);

            AddKeyBinding(Key.CursorLeft | Key.CtrlMask | Key.ShiftMask, Command.WordLeftExtend);

            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.WordRight);
            AddKeyBinding((Key)((int)'F' + Key.AltMask), Command.WordRight);

            AddKeyBinding(Key.CursorRight | Key.CtrlMask | Key.ShiftMask, Command.WordRightExtend);
            AddKeyBinding(Key.DeleteChar | Key.CtrlMask, Command.KillWordForwards); // kill-word-forwards
            AddKeyBinding(Key.Backspace | Key.CtrlMask, Command.KillWordBackwards); // kill-word-backwards

            AddKeyBinding(Key.Enter, Command.NewLine);
            AddKeyBinding(Key.End | Key.CtrlMask, Command.BottomEnd);
            AddKeyBinding(Key.End | Key.CtrlMask | Key.ShiftMask, Command.BottomEndExtend);
            AddKeyBinding(Key.Home | Key.CtrlMask, Command.TopHome);
            AddKeyBinding(Key.Home | Key.CtrlMask | Key.ShiftMask, Command.TopHomeExtend);
            AddKeyBinding(Key.T | Key.CtrlMask, Command.SelectAll);
            AddKeyBinding(Key.InsertChar, Command.ToggleOverwrite);
            AddKeyBinding(Key.Tab, Command.Tab);
            AddKeyBinding(Key.BackTab | Key.ShiftMask, Command.BackTab);

            AddKeyBinding(Key.Tab | Key.CtrlMask, Command.NextView);
            AddKeyBinding(Application.AlternateForwardKey, Command.NextView);

            AddKeyBinding(Key.Tab | Key.CtrlMask | Key.ShiftMask, Command.PreviousView);
            AddKeyBinding(Application.AlternateBackwardKey, Command.PreviousView);

            AddKeyBinding(Key.Z | Key.CtrlMask, Command.Undo);
            AddKeyBinding(Key.R | Key.CtrlMask, Command.Redo);

            AddKeyBinding(Key.G | Key.CtrlMask, Command.DeleteAll);
            AddKeyBinding(Key.D | Key.CtrlMask | Key.ShiftMask, Command.DeleteAll);

            currentCulture = Thread.CurrentThread.CurrentUICulture;

            ContextMenu = new ContextMenu() { MenuItems = BuildContextMenuBarItem() };
            ContextMenu.KeyChanged += ContextMenu_KeyChanged;

            AddKeyBinding(ContextMenu.Key, Command.Accept);
        }

        private MenuBarItem BuildContextMenuBarItem()
        {
            return new MenuBarItem(new MenuItem[] {
                    new MenuItem (Strings.ctxSelectAll, "", () => SelectAll (), null, null, GetKeyFromCommand (Command.SelectAll)),
                    new MenuItem (Strings.ctxDeleteAll, "", () => DeleteAll (), null, null, GetKeyFromCommand (Command.DeleteAll)),
                    new MenuItem (Strings.ctxCopy, "", () => Copy (), null, null, GetKeyFromCommand (Command.Copy)),
                    new MenuItem (Strings.ctxCut, "", () => Cut (), null, null, GetKeyFromCommand (Command.Cut)),
                    new MenuItem (Strings.ctxPaste, "", () => Paste (), null, null, GetKeyFromCommand (Command.Paste)),
                    new MenuItem (Strings.ctxUndo, "", () => UndoChanges (), null, null, GetKeyFromCommand (Command.Undo)),
                    new MenuItem (Strings.ctxRedo, "", () => RedoChanges (), null, null, GetKeyFromCommand (Command.Redo)),
                });
        }

        private void ContextMenu_KeyChanged(Key obj)
        {
            ReplaceKeyBinding(obj, ContextMenu.Key);
        }

        private void Model_LinesLoaded()
        {
            // This call is not needed. Model_LinesLoaded gets invoked when
            // model.LoadString (value) is called. LoadString is called from one place
            // (Text.set) and historyText.Clear() is called immediately after.
            // If this call happens, HistoryText_ChangeText will get called multiple times
            // when Text is set, which is wrong.
            //historyText.Clear (Text);
        }

        private void HistoryText_ChangeText(HistoryText.HistoryTextItem obj)
        {
            SetWrapModel();

            if (obj != null)
            {
                var startLine = obj.CursorPosition.Y;

                if (obj.RemovedOnAdded != null)
                {
                    int offset;
                    if (obj.IsUndoing)
                    {
                        offset = Math.Max(obj.RemovedOnAdded.Lines.Count - obj.Lines.Count, 1);
                    }
                    else
                    {
                        offset = obj.RemovedOnAdded.Lines.Count - 1;
                    }
                    for (int i = 0; i < offset; i++)
                    {
                        if (Lines > obj.RemovedOnAdded.CursorPosition.Y)
                        {
                            model.RemoveLine(obj.RemovedOnAdded.CursorPosition.Y);
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                for (int i = 0; i < obj.Lines.Count; i++)
                {
                    if (i == 0)
                    {
                        model.ReplaceLine(startLine, obj.Lines[i]);
                    }
                    else if ((obj.IsUndoing && obj.LineStatus == HistoryText.LineStatus.Removed)
                          || !obj.IsUndoing && obj.LineStatus == HistoryText.LineStatus.Added)
                    {
                        model.AddLine(startLine, obj.Lines[i]);
                    }
                    else if (Lines > obj.CursorPosition.Y + 1)
                    {
                        model.RemoveLine(obj.CursorPosition.Y + 1);
                    }
                    startLine++;
                }

                CursorPosition = obj.FinalCursorPosition;
            }

            UpdateWrapModel();

            Adjust();
            OnContentsChanged();
        }

        void TextView_Initialized(object sender, EventArgs e)
        {
            Autocomplete.HostControl = this;

            if (Application.Top != null)
            {
                Application.Top.AlternateForwardKeyChanged += Top_AlternateForwardKeyChanged;
                Application.Top.AlternateBackwardKeyChanged += Top_AlternateBackwardKeyChanged;
            }
            OnContentsChanged();
        }

        void Top_AlternateBackwardKeyChanged(Key obj)
        {
            ReplaceKeyBinding(obj, Application.AlternateBackwardKey);
        }

        void Top_AlternateForwardKeyChanged(Key obj)
        {
            ReplaceKeyBinding(obj, Application.AlternateForwardKey);
        }

        /// <summary>
        /// Tracks whether the text view should be considered "used", that is, that the user has moved in the entry,
        /// so new input should be appended at the cursor position, rather than clearing the entry
        /// </summary>
        public bool Used { get; set; }

        void ResetPosition()
        {
            topRow = leftColumn = currentRow = currentColumn = 0;
            StopSelecting();
            ResetCursorVisibility();
        }

        /// <summary>
        ///  Sets or gets the text in the <see cref="TextView"/>.
        /// </summary>
        /// <remarks>
        /// The <see cref="TextChanged"/> event is fired whenever this property is set. Note, however,
        /// that Text is not set by <see cref="TextView"/> as the user types.
        /// </remarks>
        public override ustring Text
        {
            get
            {
                if (wordWrap)
                {
                    return wrapManager.Model.ToString();
                }
                else
                {
                    return model.ToString();
                }
            }

            set
            {
                ResetPosition();
                model.LoadString(value);
                if (wordWrap)
                {
                    wrapManager = new WordWrapManager(model);
                    model = wrapManager.WrapModel(frameWidth, out _, out _, out _, out _);
                }
                TextChanged?.Invoke();
                SetNeedsDisplay();

                historyText.Clear(Text);
            }
        }

        ///<inheritdoc/>
        public override Rect Frame
        {
            get => base.Frame;
            set
            {
                base.Frame = value;
                WrapTextModel();
                Adjust();
            }
        }

        void WrapTextModel()
        {
            if (wordWrap && wrapManager != null)
            {
                model = wrapManager.WrapModel(frameWidth,
                    out int nRow, out int nCol,
                    out int nStartRow, out int nStartCol,
                    currentRow, currentColumn,
                    selectionStartRow, selectionStartColumn,
                    tabWidth, preserveTrailingSpaces: true);
                currentRow = nRow;
                currentColumn = nCol;
                selectionStartRow = nStartRow;
                selectionStartColumn = nStartCol;
                SetNeedsDisplay();
            }
        }

        int frameWidth => Math.Max(Frame.Width - (RightOffset != 0 ? 2 : 1), 0);

        /// <summary>
        /// Gets or sets the top row.
        /// </summary>
        public int TopRow { get => topRow; set => topRow = Math.Max(Math.Min(value, Lines - 1), 0); }

        /// <summary>
        /// Gets or sets the left column.
        /// </summary>
        public int LeftColumn
        {
            get => leftColumn;
            set
            {
                if (value > 0 && wordWrap)
                    return;
                leftColumn = Math.Max(Math.Min(value, Maxlength - 1), 0);
            }
        }

        /// <summary>
        /// Gets the maximum visible length line.
        /// </summary>
        public int Maxlength => model.GetMaxVisibleLine(topRow, topRow + Frame.Height, TabWidth);

        /// <summary>
        /// Gets the number of lines.
        /// </summary>
        public int Lines => model.Count;

        /// <summary>
        ///  Sets or gets the current cursor position.
        /// </summary>
        public Point CursorPosition
        {
            get => new Point(currentColumn, currentRow);
            set
            {
                var line = model.GetLine(Math.Max(Math.Min(value.Y, model.Count - 1), 0));
                currentColumn = value.X < 0 ? 0 : value.X > line.Count ? line.Count : value.X;
                currentRow = value.Y < 0 ? 0 : value.Y > model.Count - 1
                    ? Math.Max(model.Count - 1, 0) : value.Y;
                SetNeedsDisplay();
                Adjust();
            }
        }

        /// <summary>
        /// Start column position of the selected text.
        /// </summary>
        public int SelectionStartColumn
        {
            get => selectionStartColumn;
            set
            {
                var line = model.GetLine(currentRow);
                selectionStartColumn = value < 0 ? 0 : value > line.Count ? line.Count : value;
                selecting = true;
                SetNeedsDisplay();
                Adjust();
            }
        }

        /// <summary>
        /// Start row position of the selected text.
        /// </summary>
        public int SelectionStartRow
        {
            get => selectionStartRow;
            set
            {
                selectionStartRow = value < 0 ? 0 : value > model.Count - 1
                    ? Math.Max(model.Count - 1, 0) : value;
                selecting = true;
                SetNeedsDisplay();
                Adjust();
            }
        }

        /// <summary>
        /// The selected text.
        /// </summary>
        public ustring SelectedText
        {
            get
            {
                if (!selecting || (model.Count == 1 && model.GetLine(0).Count == 0))
                {
                    return ustring.Empty;
                }

                return GetSelectedRegion();
            }
        }

        /// <summary>
        /// Length of the selected text.
        /// </summary>
        public int SelectedLength => GetSelectedLength();

        /// <summary>
        /// Get or sets the selecting.
        /// </summary>
        public bool Selecting
        {
            get => selecting;
            set => selecting = value;
        }
        /// <summary>
        /// Allows word wrap the to fit the available container width.
        /// </summary>
        public bool WordWrap
        {
            get => wordWrap;
            set
            {
                if (value == wordWrap)
                {
                    return;
                }
                if (value && !multiline)
                {
                    return;
                }
                wordWrap = value;
                ResetPosition();
                if (wordWrap)
                {
                    wrapManager = new WordWrapManager(model);
                    model = wrapManager.WrapModel(frameWidth, out _, out _, out _, out _);
                }
                else if (!wordWrap && wrapManager != null)
                {
                    model = wrapManager.Model;
                }
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// The bottom offset needed to use a horizontal scrollbar or for another reason.
        /// This is only needed with the keyboard navigation.
        /// </summary>
        public int BottomOffset
        {
            get => bottomOffset;
            set
            {
                topRow = AdjustOffset(value);
                bottomOffset = value;
            }
        }

        /// <summary>
        /// The right offset needed to use a vertical scrollbar or for another reason.
        /// This is only needed with the keyboard navigation.
        /// </summary>
        public int RightOffset
        {
            get => rightOffset;
            set
            {
                leftColumn = AdjustOffset(value, false);
                rightOffset = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether pressing ENTER in a <see cref="TextView"/>
        /// creates a new line of text in the view or activates the default button for the toplevel.
        /// </summary>
        public bool AllowsReturn
        {
            get => allowsReturn;
            set
            {
                allowsReturn = value;
                if (allowsReturn && !multiline)
                {
                    Multiline = true;
                }
                if (!allowsReturn && multiline)
                {
                    Multiline = false;
                    AllowsTab = false;
                }
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Gets or sets whether the <see cref="TextView"/> inserts a tab character into the text or ignores 
        /// tab input. If set to `false` and the user presses the tab key (or shift-tab) the focus will move to the
        /// next view (or previous with shift-tab). The default is `true`; if the user presses the tab key, a tab 
        /// character will be inserted into the text.
        /// </summary>
        public bool AllowsTab
        {
            get => allowsTab;
            set
            {
                allowsTab = value;
                if (allowsTab && tabWidth == 0)
                {
                    tabWidth = 4;
                }
                if (allowsTab && !multiline)
                {
                    Multiline = true;
                }
                if (!allowsTab && tabWidth > 0)
                {
                    tabWidth = 0;
                }
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Gets or sets a value indicating the number of whitespace when pressing the TAB key.
        /// </summary>
        public int TabWidth
        {
            get => tabWidth;
            set
            {
                tabWidth = Math.Max(value, 0);
                if (tabWidth > 0 && !AllowsTab)
                {
                    AllowsTab = true;
                }
                SetNeedsDisplay();
            }
        }

        Dim savedHeight = null;

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="TextView"/> is a multiline text view.
        /// </summary>
        public bool Multiline
        {
            get => multiline;
            set
            {
                multiline = value;
                if (multiline && !allowsTab)
                {
                    AllowsTab = true;
                }
                if (multiline && !allowsReturn)
                {
                    AllowsReturn = true;
                }

                if (!multiline)
                {
                    AllowsReturn = false;
                    AllowsTab = false;
                    WordWrap = false;
                    currentColumn = 0;
                    currentRow = 0;
                    savedHeight = Height;
                    var lyout = LayoutStyle;
                    if (LayoutStyle == LayoutStyle.Computed)
                    {
                        LayoutStyle = LayoutStyle.Absolute;
                    }
                    Height = 1;
                    LayoutStyle = lyout;
                    Autocomplete.PopupInsideContainer = false;
                    SetNeedsDisplay();
                }
                else if (multiline && savedHeight != null)
                {
                    var lyout = LayoutStyle;
                    if (LayoutStyle == LayoutStyle.Computed)
                    {
                        LayoutStyle = LayoutStyle.Absolute;
                    }
                    Height = savedHeight;
                    LayoutStyle = lyout;
                    Autocomplete.PopupInsideContainer = true;
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Indicates whatever the text was changed or not.
        /// <see langword="true"/> if the text was changed <see langword="false"/> otherwise.
        /// </summary>
        public bool IsDirty => historyText.IsDirty(Text);

        /// <summary>
        /// Indicates whatever the text has history changes or not.
        /// <see langword="true"/> if the text has history changes <see langword="false"/> otherwise.
        /// </summary>
        public bool HasHistoryChanges => historyText.HasHistoryChanges;

        /// <summary>
        /// Get the <see cref="ContextMenu"/> for this view.
        /// </summary>
        public ContextMenu ContextMenu { get; private set; }

        int GetSelectedLength()
        {
            return SelectedText.Length;
        }

        CursorVisibility savedCursorVisibility;

        void SaveCursorVisibility()
        {
            if (desiredCursorVisibility != CursorVisibility.Invisible)
            {
                if (savedCursorVisibility == 0)
                {
                    savedCursorVisibility = desiredCursorVisibility;
                }
                DesiredCursorVisibility = CursorVisibility.Invisible;
            }
        }

        void ResetCursorVisibility()
        {
            if (savedCursorVisibility != 0)
            {
                DesiredCursorVisibility = savedCursorVisibility;
                savedCursorVisibility = 0;
            }
        }

        /// <summary>
        /// Loads the contents of the file into the <see cref="TextView"/>.
        /// </summary>
        /// <returns><c>true</c>, if file was loaded, <c>false</c> otherwise.</returns>
        /// <param name="path">Path to the file to load.</param>
        public bool LoadFile(string path)
        {
            bool res;
            try
            {
                SetWrapModel();
                res = model.LoadFile(path);
                historyText.Clear(Text);
                ResetPosition();
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                UpdateWrapModel();
                SetNeedsDisplay();
                Adjust();
            }
            return res;
        }

        /// <summary>
        /// Loads the contents of the stream into the <see cref="TextView"/>.
        /// </summary>
        /// <returns><c>true</c>, if stream was loaded, <c>false</c> otherwise.</returns>
        /// <param name="stream">Stream to load the contents from.</param>
        public void LoadStream(Stream stream)
        {
            model.LoadStream(stream);
            historyText.Clear(Text);
            ResetPosition();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Closes the contents of the stream into the <see cref="TextView"/>.
        /// </summary>
        /// <returns><c>true</c>, if stream was closed, <c>false</c> otherwise.</returns>
        public bool CloseFile()
        {
            var res = model.CloseFile();
            ResetPosition();
            SetNeedsDisplay();
            return res;
        }

        /// <summary>
        ///  Gets the current cursor row.
        /// </summary>
        public int CurrentRow => currentRow;

        /// <summary>
        /// Gets the cursor column.
        /// </summary>
        /// <value>The cursor column.</value>
        public int CurrentColumn => currentColumn;

        /// <summary>
        ///  Positions the cursor on the current row and column
        /// </summary>
        public override void PositionCursor()
        {
            if (!CanFocus || !Enabled)
            {
                return;
            }

            if (selecting)
            {
                var minRow = Math.Min(Math.Max(Math.Min(selectionStartRow, currentRow) - topRow, 0), Frame.Height);
                var maxRow = Math.Min(Math.Max(Math.Max(selectionStartRow, currentRow) - topRow, 0), Frame.Height);

                SetNeedsDisplay(new Rect(0, minRow, Frame.Width, maxRow));
            }
            var line = model.GetLine(currentRow);
            var col = 0;
            if (line.Count > 0)
            {
                for (int idx = leftColumn; idx < line.Count; idx++)
                {
                    if (idx >= currentColumn)
                        break;
                    var cols = Rune.ColumnWidth(line[idx]);
                    if (line[idx] == '\t')
                    {
                        cols += TabWidth + 1;
                    }
                    if (!TextModel.SetCol(ref col, Frame.Width, cols))
                    {
                        col = currentColumn;
                        break;
                    }
                }
            }
            var posX = currentColumn - leftColumn;
            var posY = currentRow - topRow;
            if (posX > -1 && col >= posX && posX < Frame.Width - RightOffset
                && topRow <= currentRow && posY < Frame.Height - BottomOffset)
            {
                ResetCursorVisibility();
                Move(col, currentRow - topRow);
            }
            else
            {
                SaveCursorVisibility();
            }
        }

        void ClearRegion(int left, int top, int right, int bottom)
        {
            for (int row = top; row < bottom; row++)
            {
                Move(left, row);
                for (int col = left; col < right; col++)
                    AddRune(col, row, ' ');
            }
        }

        /// <summary>
        /// Sets the driver to the default color for the control where no text is being rendered. Defaults to <see cref="ColorScheme.Normal"/>.
        /// </summary>
        protected virtual void SetNormalColor()
        {
            Driver.SetAttribute(GetNormalColor());
        }

        /// <summary>
        /// Sets the <see cref="View.Driver"/> to an appropriate color for rendering the given <paramref name="idx"/> of the
        /// current <paramref name="line"/>. Override to provide custom coloring by calling <see cref="ConsoleDriver.SetAttribute(Attribute)"/>
        /// Defaults to <see cref="ColorScheme.Normal"/>.
        /// </summary>
        /// <param name="line"></param>
        /// <param name="idx"></param>
        protected virtual void SetNormalColor(List<Rune> line, int idx)
        {
            Driver.SetAttribute(GetNormalColor());
        }

        /// <summary>
        /// Sets the <see cref="View.Driver"/> to an appropriate color for rendering the given <paramref name="idx"/> of the
        /// current <paramref name="line"/>. Override to provide custom coloring by calling <see cref="ConsoleDriver.SetAttribute(Attribute)"/>
        /// Defaults to <see cref="ColorScheme.Focus"/>.
        /// </summary>
        /// <param name="line"></param>
        /// <param name="idx"></param>
        protected virtual void SetSelectionColor(List<Rune> line, int idx)
        {
            Driver.SetAttribute(new Attribute(ColorScheme.Focus.Background, ColorScheme.Focus.Foreground));
        }

        /// <summary>
        /// Sets the <see cref="View.Driver"/> to an appropriate color for rendering the given <paramref name="idx"/> of the
        /// current <paramref name="line"/>. Override to provide custom coloring by calling <see cref="ConsoleDriver.SetAttribute(Attribute)"/>
        /// Defaults to <see cref="ColorScheme.Focus"/>.
        /// </summary>
        /// <param name="line"></param>
        /// <param name="idx"></param>
        protected virtual void SetReadOnlyColor(List<Rune> line, int idx)
        {
            Attribute attribute;
            if (ColorScheme.Disabled.Foreground == ColorScheme.Focus.Background)
            {
                attribute = new Attribute(ColorScheme.Focus.Foreground, ColorScheme.Focus.Background);
            }
            else
            {
                attribute = new Attribute(ColorScheme.Disabled.Foreground, ColorScheme.Focus.Background);
            }
            Driver.SetAttribute(attribute);
        }

        /// <summary>
        /// Sets the <see cref="View.Driver"/> to an appropriate color for rendering the given <paramref name="idx"/> of the
        /// current <paramref name="line"/>. Override to provide custom coloring by calling <see cref="ConsoleDriver.SetAttribute(Attribute)"/>
        /// Defaults to <see cref="ColorScheme.HotFocus"/>.
        /// </summary>
        /// <param name="line"></param>
        /// <param name="idx"></param>
        protected virtual void SetUsedColor(List<Rune> line, int idx)
        {
            Driver.SetAttribute(ColorScheme.HotFocus);
        }

        bool isReadOnly = false;

        /// <summary>
        /// Gets or sets whether the <see cref="TextView"/> is in read-only mode or not
        /// </summary>
        /// <value>Boolean value(Default false)</value>
        public bool ReadOnly
        {
            get => isReadOnly;
            set
            {
                if (value != isReadOnly)
                {
                    isReadOnly = value;

                    SetNeedsDisplay();
                    Adjust();
                }
            }
        }

        CursorVisibility desiredCursorVisibility = CursorVisibility.Default;

        /// <summary>
        /// Get / Set the wished cursor when the field is focused
        /// </summary>
        public CursorVisibility DesiredCursorVisibility
        {
            get => desiredCursorVisibility;
            set
            {
                if (HasFocus)
                {
                    Application.Driver.SetCursorVisibility(value);
                }

                desiredCursorVisibility = value;
                SetNeedsDisplay();
            }
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            //TODO: Improve it by handling read only mode of the text field
            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);

            return base.OnEnter(view);
        }

        ///<inheritdoc/>
        public override bool OnLeave(View view)
        {
            if (Application.MouseGrabView != null && Application.MouseGrabView == this)
            {
                Application.UngrabMouse();
            }

            return base.OnLeave(view);
        }

        // Returns an encoded region start..end (top 32 bits are the row, low32 the column)
        void GetEncodedRegionBounds(out long start, out long end,
            int? startRow = null, int? startCol = null, int? cRow = null, int? cCol = null)
        {
            long selection;
            long point;
            if (startRow == null || startCol == null || cRow == null || cCol == null)
            {
                selection = ((long)(uint)selectionStartRow << 32) | (uint)selectionStartColumn;
                point = ((long)(uint)currentRow << 32) | (uint)currentColumn;
            }
            else
            {
                selection = ((long)(uint)startRow << 32) | (uint)startCol;
                point = ((long)(uint)cRow << 32) | (uint)cCol;
            }
            if (selection > point)
            {
                start = point;
                end = selection;
            }
            else
            {
                start = selection;
                end = point;
            }
        }

        bool PointInSelection(int col, int row)
        {
            long start, end;
            GetEncodedRegionBounds(out start, out end);
            var q = ((long)(uint)row << 32) | (uint)col;
            return q >= start && q <= end - 1;
        }

        //
        // Returns a ustring with the text in the selected 
        // region.
        //
        ustring GetRegion(int? sRow = null, int? sCol = null, int? cRow = null, int? cCol = null, TextModel model = null)
        {
            long start, end;
            GetEncodedRegionBounds(out start, out end, sRow, sCol, cRow, cCol);
            if (start == end)
            {
                return ustring.Empty;
            }
            int startRow = (int)(start >> 32);
            var maxrow = ((int)(end >> 32));
            int startCol = (int)(start & 0xffffffff);
            var endCol = (int)(end & 0xffffffff);
            var line = model == null ? this.model.GetLine(startRow) : model.GetLine(startRow);

            if (startRow == maxrow)
                return StringFromRunes(line.GetRange(startCol, endCol - startCol));

            ustring res = StringFromRunes(line.GetRange(startCol, line.Count - startCol));

            for (int row = startRow + 1; row < maxrow; row++)
            {
                res = res + ustring.Make(Environment.NewLine) + StringFromRunes(model == null
                    ? this.model.GetLine(row) : model.GetLine(row));
            }
            line = model == null ? this.model.GetLine(maxrow) : model.GetLine(maxrow);
            res = res + ustring.Make(Environment.NewLine) + StringFromRunes(line.GetRange(0, endCol));
            return res;
        }

        //
        // Clears the contents of the selected region
        //
        void ClearRegion()
        {
            SetWrapModel();

            long start, end;
            long currentEncoded = ((long)(uint)currentRow << 32) | (uint)currentColumn;
            GetEncodedRegionBounds(out start, out end);
            int startRow = (int)(start >> 32);
            var maxrow = ((int)(end >> 32));
            int startCol = (int)(start & 0xffffffff);
            var endCol = (int)(end & 0xffffffff);
            var line = model.GetLine(startRow);

            historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, new Point(startCol, startRow));

            List<List<Rune>> removedLines = new List<List<Rune>>();

            if (startRow == maxrow)
            {
                removedLines.Add(new List<Rune>(line));

                line.RemoveRange(startCol, endCol - startCol);
                currentColumn = startCol;
                if (wordWrap)
                {
                    SetNeedsDisplay();
                }
                else
                {
                    SetNeedsDisplay(new Rect(0, startRow - topRow, Frame.Width, startRow - topRow + 1));
                }

                historyText.Add(new List<List<Rune>>(removedLines), CursorPosition, HistoryText.LineStatus.Removed);

                UpdateWrapModel();

                return;
            }

            removedLines.Add(new List<Rune>(line));

            line.RemoveRange(startCol, line.Count - startCol);
            var line2 = model.GetLine(maxrow);
            line.AddRange(line2.Skip(endCol));
            for (int row = startRow + 1; row <= maxrow; row++)
            {

                removedLines.Add(new List<Rune>(model.GetLine(startRow + 1)));

                model.RemoveLine(startRow + 1);
            }
            if (currentEncoded == end)
            {
                currentRow -= maxrow - (startRow);
            }
            currentColumn = startCol;

            historyText.Add(new List<List<Rune>>(removedLines), CursorPosition,
                HistoryText.LineStatus.Removed);

            UpdateWrapModel();

            SetNeedsDisplay();
        }

        /// <summary>
        /// Select all text.
        /// </summary>
        public void SelectAll()
        {
            if (model.Count == 0)
            {
                return;
            }

            StartSelecting();
            selectionStartColumn = 0;
            selectionStartRow = 0;
            currentColumn = model.GetLine(model.Count - 1).Count;
            currentRow = model.Count - 1;
            SetNeedsDisplay();
        }

        /// <summary>
        /// Find the next text based on the match case with the option to replace it.
        /// </summary>
        /// <param name="textToFind">The text to find.</param>
        /// <param name="gaveFullTurn"><c>true</c>If all the text was forward searched.<c>false</c>otherwise.</param>
        /// <param name="matchCase">The match case setting.</param>
        /// <param name="matchWholeWord">The match whole word setting.</param>
        /// <param name="textToReplace">The text to replace.</param>
        /// <param name="replace"><c>true</c>If is replacing.<c>false</c>otherwise.</param>
        /// <returns><c>true</c>If the text was found.<c>false</c>otherwise.</returns>
        public bool FindNextText(ustring textToFind, out bool gaveFullTurn, bool matchCase = false,
            bool matchWholeWord = false, ustring textToReplace = null, bool replace = false)
        {
            if (model.Count == 0)
            {
                gaveFullTurn = false;
                return false;
            }

            SetWrapModel();
            ResetContinuousFind();
            var foundPos = model.FindNextText(textToFind, out gaveFullTurn, matchCase, matchWholeWord);

            return SetFoundText(textToFind, foundPos, textToReplace, replace);
        }

        /// <summary>
        /// Find the previous text based on the match case with the option to replace it.
        /// </summary>
        /// <param name="textToFind">The text to find.</param>
        /// <param name="gaveFullTurn"><c>true</c>If all the text was backward searched.<c>false</c>otherwise.</param>
        /// <param name="matchCase">The match case setting.</param>
        /// <param name="matchWholeWord">The match whole word setting.</param>
        /// <param name="textToReplace">The text to replace.</param>
        /// <param name="replace"><c>true</c>If the text was found.<c>false</c>otherwise.</param>
        /// <returns><c>true</c>If the text was found.<c>false</c>otherwise.</returns>
        public bool FindPreviousText(ustring textToFind, out bool gaveFullTurn, bool matchCase = false,
            bool matchWholeWord = false, ustring textToReplace = null, bool replace = false)
        {
            if (model.Count == 0)
            {
                gaveFullTurn = false;
                return false;
            }

            SetWrapModel();
            ResetContinuousFind();
            var foundPos = model.FindPreviousText(textToFind, out gaveFullTurn, matchCase, matchWholeWord);

            return SetFoundText(textToFind, foundPos, textToReplace, replace);
        }

        /// <summary>
        /// Reset the flag to stop continuous find.
        /// </summary>
        public void FindTextChanged()
        {
            continuousFind = false;
        }

        /// <summary>
        /// Replaces all the text based on the match case.
        /// </summary>
        /// <param name="textToFind">The text to find.</param>
        /// <param name="matchCase">The match case setting.</param>
        /// <param name="matchWholeWord">The match whole word setting.</param>
        /// <param name="textToReplace">The text to replace.</param>
        /// <returns><c>true</c>If the text was found.<c>false</c>otherwise.</returns>
        public bool ReplaceAllText(ustring textToFind, bool matchCase = false, bool matchWholeWord = false,
            ustring textToReplace = null)
        {
            if (isReadOnly || model.Count == 0)
            {
                return false;
            }

            SetWrapModel();
            ResetContinuousFind();
            var foundPos = model.ReplaceAllText(textToFind, matchCase, matchWholeWord, textToReplace);

            return SetFoundText(textToFind, foundPos, textToReplace, false, true);
        }

        bool SetFoundText(ustring text, (Point current, bool found) foundPos,
            ustring textToReplace = null, bool replace = false, bool replaceAll = false)
        {
            if (foundPos.found)
            {
                StartSelecting();
                selectionStartColumn = foundPos.current.X;
                selectionStartRow = foundPos.current.Y;
                if (!replaceAll)
                {
                    currentColumn = selectionStartColumn + text.RuneCount;
                }
                else
                {
                    currentColumn = selectionStartColumn + textToReplace.RuneCount;
                }
                currentRow = foundPos.current.Y;
                if (!isReadOnly && replace)
                {
                    Adjust();
                    ClearSelectedRegion();
                    InsertText(textToReplace);
                    StartSelecting();
                    selectionStartColumn = currentColumn - textToReplace.RuneCount;
                }
                else
                {
                    UpdateWrapModel();
                    SetNeedsDisplay();
                    Adjust();
                }
                continuousFind = true;
                return foundPos.found;
            }
            UpdateWrapModel();
            continuousFind = false;

            return foundPos.found;
        }

        void ResetContinuousFind()
        {
            if (!continuousFind)
            {
                var col = selecting ? selectionStartColumn : currentColumn;
                var row = selecting ? selectionStartRow : currentRow;
                model.ResetContinuousFind(new Point(col, row));
            }
        }

        string currentCaller;

        /// <summary>
        /// Restore from original model.
        /// </summary>
        void SetWrapModel([CallerMemberName] string caller = null)
        {
            if (currentCaller != null)
                return;

            if (wordWrap)
            {
                currentCaller = caller;

                currentColumn = wrapManager.GetModelColFromWrappedLines(currentRow, currentColumn);
                currentRow = wrapManager.GetModelLineFromWrappedLines(currentRow);
                selectionStartColumn = wrapManager.GetModelColFromWrappedLines(selectionStartRow, selectionStartColumn);
                selectionStartRow = wrapManager.GetModelLineFromWrappedLines(selectionStartRow);
                model = wrapManager.Model;
            }
        }

        /// <summary>
        /// Update the original model.
        /// </summary>
        void UpdateWrapModel([CallerMemberName] string caller = null)
        {
            if (currentCaller != null && currentCaller != caller)
                return;

            if (wordWrap)
            {
                currentCaller = null;

                wrapManager.UpdateModel(model, out int nRow, out int nCol,
                    out int nStartRow, out int nStartCol,
                    currentRow, currentColumn,
                    selectionStartRow, selectionStartColumn, preserveTrailingSpaces: true);
                currentRow = nRow;
                currentColumn = nCol;
                selectionStartRow = nStartRow;
                selectionStartColumn = nStartCol;
                wrapNeeded = true;

                SetNeedsDisplay();
            }
            if (currentCaller != null)
                throw new InvalidOperationException($"WordWrap settings was changed after the {currentCaller} call.");
        }

        /// <summary>
        /// Invoke the <see cref="UnwrappedCursorPosition"/> event with the unwrapped <see cref="CursorPosition"/>.
        /// </summary>
        public virtual void OnUnwrappedCursorPosition(int? cRow = null, int? cCol = null)
        {
            var row = cRow == null ? currentRow : cRow;
            var col = cCol == null ? currentColumn : cCol;
            if (cRow == null && cCol == null && wordWrap)
            {
                row = wrapManager.GetModelLineFromWrappedLines(currentRow);
                col = wrapManager.GetModelColFromWrappedLines(currentRow, currentColumn);
            }
            UnwrappedCursorPosition?.Invoke(new Point((int)col, (int)row));
        }

        ustring GetSelectedRegion()
        {
            var cRow = currentRow;
            var cCol = currentColumn;
            var startRow = selectionStartRow;
            var startCol = selectionStartColumn;
            var model = this.model;
            if (wordWrap)
            {
                cRow = wrapManager.GetModelLineFromWrappedLines(currentRow);
                cCol = wrapManager.GetModelColFromWrappedLines(currentRow, currentColumn);
                startRow = wrapManager.GetModelLineFromWrappedLines(selectionStartRow);
                startCol = wrapManager.GetModelColFromWrappedLines(selectionStartRow, selectionStartColumn);
                model = wrapManager.Model;
            }
            OnUnwrappedCursorPosition(cRow, cCol);
            return GetRegion(startRow, startCol, cRow, cCol, model);
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            SetNormalColor();

            var offB = OffSetBackground();
            int right = Frame.Width + offB.width + RightOffset;
            int bottom = Frame.Height + offB.height + BottomOffset;
            var row = 0;
            for (int idxRow = topRow; idxRow < model.Count; idxRow++)
            {
                var line = model.GetLine(idxRow);
                int lineRuneCount = line.Count;
                var col = 0;

                Move(0, row);
                for (int idxCol = leftColumn; idxCol < lineRuneCount; idxCol++)
                {
                    var rune = idxCol >= lineRuneCount ? ' ' : line[idxCol];
                    var cols = Rune.ColumnWidth(rune);
                    if (idxCol < line.Count && selecting && PointInSelection(idxCol, idxRow))
                    {
                        SetSelectionColor(line, idxCol);
                    }
                    else if (idxCol == currentColumn && idxRow == currentRow && !selecting && !Used
                      && HasFocus && idxCol < lineRuneCount)
                    {
                        SetSelectionColor(line, idxCol);
                    }
                    else if (ReadOnly)
                    {
                        SetReadOnlyColor(line, idxCol);
                    }
                    else
                    {
                        SetNormalColor(line, idxCol);
                    }

                    if (rune == '\t')
                    {
                        cols += TabWidth + 1;
                        if (col + cols > right)
                        {
                            cols = right - col;
                        }
                        for (int i = 0; i < cols; i++)
                        {
                            if (col + i < right)
                            {
                                AddRune(col + i, row, ' ');
                            }
                        }
                    }
                    else
                    {
                        AddRune(col, row, rune);
                    }
                    if (!TextModel.SetCol(ref col, bounds.Right, cols))
                    {
                        break;
                    }
                    if (idxCol + 1 < lineRuneCount && col + Rune.ColumnWidth(line[idxCol + 1]) > right)
                    {
                        break;
                    }
                }
                if (col < right)
                {
                    SetNormalColor();
                    ClearRegion(col, row, right, row + 1);
                }
                row++;
            }
            if (row < bottom)
            {
                SetNormalColor();
                ClearRegion(bounds.Left, row, right, bottom);
            }

            PositionCursor();

            if (clickWithSelecting)
            {
                clickWithSelecting = false;
                return;
            }
            if (SelectedLength > 0)
                return;

            // draw autocomplete
            Autocomplete.GenerateSuggestions();

            var renderAt = new Point(
                CursorPosition.X - LeftColumn,
                Autocomplete.PopupInsideContainer
                    ? (CursorPosition.Y + 1) - TopRow
                    : 0);

            Autocomplete.RenderOverlay(renderAt);
        }

        /// <inheritdoc/>
        public override Attribute GetNormalColor()
        {
            return Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
        }

        ///<inheritdoc/>
        public override bool CanFocus
        {
            get => base.CanFocus;
            set { base.CanFocus = value; }
        }

        void SetClipboard(ustring text)
        {
            if (text != null)
            {
                Clipboard.Contents = text;
            }
        }

        void AppendClipboard(ustring text)
        {
            Clipboard.Contents += text;
        }


        /// <summary>
        /// Inserts the given <paramref name="toAdd"/> text at the current cursor position
        /// exactly as if the user had just typed it
        /// </summary>
        /// <param name="toAdd">Text to add</param>
        public void InsertText(string toAdd)
        {
            foreach (var ch in toAdd)
            {

                Key key;

                try
                {
                    key = (Key)ch;
                }
                catch (Exception)
                {

                    throw new ArgumentException($"Cannot insert character '{ch}' because it does not map to a Key");
                }


                InsertText(new KeyEvent() { Key = key });
            }

            if (NeedDisplay.IsEmpty)
            {
                PositionCursor();
            }
            else
            {
                Adjust();
            }
        }

        void Insert(Rune rune)
        {
            var line = GetCurrentLine();
            if (Used)
            {
                line.Insert(Math.Min(currentColumn, line.Count), rune);
            }
            else
            {
                if (currentColumn < line.Count)
                {
                    line.RemoveAt(currentColumn);
                }
                line.Insert(Math.Min(currentColumn, line.Count), rune);
            }
            var prow = currentRow - topRow;
            if (!wrapNeeded)
            {
                SetNeedsDisplay(new Rect(0, prow, Math.Max(Frame.Width, 0), Math.Max(prow + 1, 0)));
            }
        }

        ustring StringFromRunes(List<Rune> runes)
        {
            if (runes == null)
                throw new ArgumentNullException(nameof(runes));
            int size = 0;
            foreach (var rune in runes)
            {
                size += Utf8.RuneLen(rune);
            }
            var encoded = new byte[size];
            int offset = 0;
            foreach (var rune in runes)
            {
                offset += Utf8.EncodeRune(rune, encoded, offset);
            }
            return ustring.Make(encoded);
        }

        /// <summary>
        /// Returns the characters on the current line (where the cursor is positioned).
        /// Use <see cref="CurrentColumn"/> to determine the position of the cursor within
        /// that line
        /// </summary>
        /// <returns></returns>
        public List<Rune> GetCurrentLine() => model.GetLine(currentRow);

        void InsertText(ustring text)
        {
            if (ustring.IsNullOrEmpty(text))
            {
                return;
            }

            var lines = TextModel.StringToRunes(text);

            if (lines.Count == 0)
            {
                return;
            }

            SetWrapModel();

            var line = GetCurrentLine();

            historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, CursorPosition);

            // Optimize single line
            if (lines.Count == 1)
            {
                line.InsertRange(currentColumn, lines[0]);
                currentColumn += lines[0].Count;

                historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                if (!wordWrap && currentColumn - leftColumn > Frame.Width)
                {
                    leftColumn = Math.Max(currentColumn - Frame.Width + 1, 0);
                }
                if (wordWrap)
                {
                    SetNeedsDisplay();
                }
                else
                {
                    SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Math.Max(currentRow - topRow + 1, 0)));
                }

                UpdateWrapModel();

                OnContentsChanged();

                return;
            }

            List<Rune> rest = null;
            int lastp = 0;

            if (model.Count > 0 && line.Count > 0 && !copyWithoutSelection)
            {
                // Keep a copy of the rest of the line
                var restCount = line.Count - currentColumn;
                rest = line.GetRange(currentColumn, restCount);
                line.RemoveRange(currentColumn, restCount);
            }

            // First line is inserted at the current location, the rest is appended
            line.InsertRange(currentColumn, lines[0]);
            //model.AddLine (currentRow, lines [0]);

            var addedLines = new List<List<Rune>>() { new List<Rune>(line) };

            for (int i = 1; i < lines.Count; i++)
            {
                model.AddLine(currentRow + i, lines[i]);

                addedLines.Add(new List<Rune>(lines[i]));
            }

            if (rest != null)
            {
                var last = model.GetLine(currentRow + lines.Count - 1);
                lastp = last.Count;
                last.InsertRange(last.Count, rest);

                addedLines.Last().InsertRange(addedLines.Last().Count, rest);
            }

            historyText.Add(addedLines, CursorPosition, HistoryText.LineStatus.Added);

            // Now adjust column and row positions
            currentRow += lines.Count - 1;
            currentColumn = rest != null ? lastp : lines[lines.Count - 1].Count;
            Adjust();

            historyText.Add(new List<List<Rune>>() { new List<Rune>(line) }, CursorPosition,
                HistoryText.LineStatus.Replaced);

            UpdateWrapModel();
            OnContentsChanged();
        }

        // The column we are tracking, or -1 if we are not tracking any column
        int columnTrack = -1;

        // Tries to snap the cursor to the tracking column
        void TrackColumn()
        {
            // Now track the column
            var line = GetCurrentLine();
            if (line.Count < columnTrack)
                currentColumn = line.Count;
            else if (columnTrack != -1)
                currentColumn = columnTrack;
            else if (currentColumn > line.Count)
                currentColumn = line.Count;
            Adjust();
        }

        void Adjust()
        {
            var offB = OffSetBackground();
            var line = GetCurrentLine();
            bool need = !NeedDisplay.IsEmpty || wrapNeeded;
            var tSize = TextModel.DisplaySize(line, -1, -1, false, TabWidth);
            var dSize = TextModel.DisplaySize(line, leftColumn, currentColumn, true, TabWidth);
            if (!wordWrap && currentColumn < leftColumn)
            {
                leftColumn = currentColumn;
                need = true;
            }
            else if (!wordWrap && (currentColumn - leftColumn + RightOffset > Frame.Width + offB.width
              || dSize.size + RightOffset >= Frame.Width + offB.width))
            {
                leftColumn = TextModel.CalculateLeftColumn(line, leftColumn, currentColumn,
                    Frame.Width + offB.width - RightOffset, TabWidth);
                need = true;
            }
            else if ((wordWrap && leftColumn > 0) || (dSize.size + RightOffset < Frame.Width + offB.width
              && tSize.size + RightOffset < Frame.Width + offB.width))
            {
                if (leftColumn > 0)
                {
                    leftColumn = 0;
                    need = true;
                }
            }

            if (currentRow < topRow)
            {
                topRow = currentRow;
                need = true;
            }
            else if (currentRow - topRow + BottomOffset >= Frame.Height + offB.height)
            {
                topRow = Math.Min(Math.Max(currentRow - Frame.Height + 1 + BottomOffset, 0), currentRow);
                need = true;
            }
            else if (topRow > 0 && currentRow < topRow)
            {
                topRow = Math.Max(topRow - 1, 0);
                need = true;
            }
            if (need)
            {
                if (wrapNeeded)
                {
                    WrapTextModel();
                    wrapNeeded = false;
                }
                SetNeedsDisplay();
            }
            else
            {
                PositionCursor();
            }

            OnUnwrappedCursorPosition();
        }

        int AdjustOffset(int valueOffset, bool isRow = true)
        {
            var curWrap = isRow ? false : wordWrap;
            var curLength = isRow ? Lines - 1 : GetCurrentLine().Count;
            var curStart = isRow ? topRow : leftColumn;
            var curOffset = isRow ? bottomOffset : rightOffset;
            var curSize = isRow ? Frame.Height - valueOffset : Frame.Width - valueOffset;
            var newStart = curStart;

            if (!curWrap)
            {
                if (curStart > 0 && curOffset > 0 && valueOffset == 0)
                {
                    newStart = Math.Max(curStart - curOffset, 0);
                }
                else if (curStart > 0 && curOffset == 0 && valueOffset > 0)
                {
                    newStart = Math.Max(Math.Min(curStart + valueOffset, curLength - curSize + 1), 0);
                }

                if (newStart != curStart)
                {
                    Application.MainLoop.Invoke(() => SetNeedsDisplay());
                }
            }

            return newStart;
        }

        /// <summary>
        /// Event arguments for events for when the contents of the TextView change. E.g. the <see cref="ContentsChanged"/> event.
        /// </summary>
        public class ContentsChangedEventArgs : EventArgs
        {
            /// <summary>
            /// Creates a new <see cref="ContentsChanged"/> instance.
            /// </summary>
            /// <param name="currentRow">Contains the row where the change occurred.</param>
            /// <param name="currentColumn">Contains the column where the change occured.</param>
            public ContentsChangedEventArgs(int currentRow, int currentColumn)
            {
                Row = currentRow;
                Col = currentColumn;
            }

            /// <summary>
            /// 
            /// Contains the row where the change occurred.
            /// </summary>
            public int Row { get; private set; }

            /// <summary>
            /// Contains the column where the change occurred.
            /// </summary>
            public int Col { get; private set; }
        }

        /// <summary>
        /// Called when the contents of the TextView change. E.g. when the user types text or deletes text. Raises
        /// the <see cref="ContentsChanged"/> event.
        /// </summary>
        public virtual void OnContentsChanged()
        {
            ContentsChanged?.Invoke(new ContentsChangedEventArgs(CurrentRow, CurrentColumn));
        }

        (int width, int height) OffSetBackground()
        {
            int w = 0;
            int h = 0;
            if (SuperView?.Frame.Right - Frame.Right < 0)
            {
                w = SuperView.Frame.Right - Frame.Right - 1;
            }
            if (SuperView?.Frame.Bottom - Frame.Bottom < 0)
            {
                h = SuperView.Frame.Bottom - Frame.Bottom - 1;
            }
            return (w, h);
        }

        /// <summary>
        /// Will scroll the <see cref="TextView"/> to display the specified row at the top if <paramref name="isRow"/> is true or
        /// will scroll the <see cref="TextView"/> to display the specified column at the left if <paramref name="isRow"/> is false.
        /// </summary>
        /// <param name="idx">Row that should be displayed at the top or Column that should be displayed at the left,
        /// if the value is negative it will be reset to zero</param>
        /// <param name="isRow">If true (default) the <paramref name="idx"/> is a row, column otherwise.</param>
        public void ScrollTo(int idx, bool isRow = true)
        {
            if (idx < 0)
            {
                idx = 0;
            }
            if (isRow)
            {
                topRow = Math.Max(idx > model.Count - 1 ? model.Count - 1 : idx, 0);
            }
            else if (!wordWrap)
            {
                var maxlength = model.GetMaxVisibleLine(topRow, topRow + Frame.Height + RightOffset, TabWidth);
                leftColumn = Math.Max(!wordWrap && idx > maxlength - 1 ? maxlength - 1 : idx, 0);
            }
            SetNeedsDisplay();
        }

        bool lastWasKill;
        bool wrapNeeded;
        bool shiftSelecting;

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            if (!CanFocus)
            {
                return true;
            }

            // Give autocomplete first opportunity to respond to key presses
            if (SelectedLength == 0 && Autocomplete.ProcessKey(kb))
            {
                return true;
            }

            var result = InvokeKeybindings(new KeyEvent(ShortcutHelper.GetModifiersKey(kb),
                new KeyModifiers() { Alt = kb.IsAlt, Ctrl = kb.IsCtrl, Shift = kb.IsShift }));
            if (result != null)
                return (bool)result;

            ResetColumnTrack();
            // Ignore control characters and other special keys
            if (kb.Key < Key.Space || kb.Key > Key.CharMask)
                return false;

            InsertText(kb);
            DoNeededAction();

            return true;
        }

        void RedoChanges()
        {
            if (ReadOnly)
                return;

            historyText.Redo();
        }

        void UndoChanges()
        {
            if (ReadOnly)
                return;

            historyText.Undo();
        }

        bool ProcessMovePreviousView()
        {
            ResetColumnTrack();
            return MovePreviousView();
        }

        bool ProcessMoveNextView()
        {
            ResetColumnTrack();
            return MoveNextView();
        }

        void ProcessSetOverwrite()
        {
            ResetColumnTrack();
            SetOverwrite(!Used);
        }

        void ProcessSelectAll()
        {
            ResetColumnTrack();
            SelectAll();
        }

        void MoveTopHomeExtend()
        {
            ResetColumnTrack();
            StartSelecting();
            MoveHome();
        }

        void MoveTopHome()
        {
            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveHome();
        }

        void MoveBottomEndExtend()
        {
            ResetAllTrack();
            StartSelecting();
            MoveEnd();
        }

        void MoveBottomEnd()
        {
            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveEnd();
        }

        void ProcessKillWordBackward()
        {
            ResetColumnTrack();
            KillWordBackward();
        }

        void ProcessKillWordForward()
        {
            ResetColumnTrack();
            KillWordForward();
        }

        void ProcessMoveWordForwardExtend()
        {
            ResetAllTrack();
            StartSelecting();
            MoveWordForward();
        }

        void ProcessMoveWordForward()
        {
            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveWordForward();
        }

        void ProcessMoveWordBackwardExtend()
        {
            ResetAllTrack();
            StartSelecting();
            MoveWordBackward();
        }

        void ProcessMoveWordBackward()
        {
            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveWordBackward();
        }

        void ProcessCut()
        {
            ResetColumnTrack();
            Cut();
        }

        void ProcessCopy()
        {
            ResetColumnTrack();
            Copy();
        }

        void ToggleSelecting()
        {
            ResetColumnTrack();
            selecting = !selecting;
            selectionStartColumn = currentColumn;
            selectionStartRow = currentRow;
        }

        void ProcessPaste()
        {
            ResetColumnTrack();
            if (isReadOnly)
                return;
            Paste();
        }

        void ProcessMoveEndOfLineExtend()
        {
            ResetAllTrack();
            StartSelecting();
            MoveEndOfLine();
        }

        void ProcessMoveEndOfLine()
        {
            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveEndOfLine();
        }

        void ProcessDeleteCharRight()
        {
            ResetColumnTrack();
            DeleteCharRight();
        }

        void ProcessMoveStartOfLineExtend()
        {
            ResetAllTrack();
            StartSelecting();
            MoveStartOfLine();
        }

        void ProcessMoveStartOfLine()
        {
            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveStartOfLine();
        }

        void ProcessDeleteCharLeft()
        {
            ResetColumnTrack();
            DeleteCharLeft();
        }

        void ProcessMoveLeftExtend()
        {
            ResetAllTrack();
            StartSelecting();
            MoveLeft();
        }

        bool ProcessMoveLeft()
        {
            // if the user presses Left (without any control keys) and they are at the start of the text
            if (currentColumn == 0 && currentRow == 0)
            {
                // do not respond (this lets the key press fall through to navigation system - which usually changes focus backward)
                return false;
            }

            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveLeft();
            return true;
        }

        void ProcessMoveRightExtend()
        {
            ResetAllTrack();
            StartSelecting();
            MoveRight();
        }

        bool ProcessMoveRight()
        {
            // if the user presses Right (without any control keys)
            // determine where the last cursor position in the text is
            var lastRow = model.Count - 1;
            var lastCol = model.GetLine(lastRow).Count;

            // if they are at the very end of all the text do not respond (this lets the key press fall through to navigation system - which usually changes focus forward)
            if (currentColumn == lastCol && currentRow == lastRow)
            {
                return false;
            }

            ResetAllTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveRight();
            return true;
        }

        void ProcessMoveUpExtend()
        {
            ResetColumnTrack();
            StartSelecting();
            MoveUp();
        }

        void ProcessMoveUp()
        {
            ResetContinuousFindTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveUp();
        }

        void ProcessMoveDownExtend()
        {
            ResetColumnTrack();
            StartSelecting();
            MoveDown();
        }

        void ProcessMoveDown()
        {
            ResetContinuousFindTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MoveDown();
        }

        void ProcessPageUpExtend()
        {
            ResetColumnTrack();
            StartSelecting();
            MovePageUp();
        }

        void ProcessPageUp()
        {
            ResetColumnTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MovePageUp();
        }

        void ProcessPageDownExtend()
        {
            ResetColumnTrack();
            StartSelecting();
            MovePageDown();
        }

        void ProcessPageDown()
        {
            ResetColumnTrack();
            if (shiftSelecting && selecting)
            {
                StopSelecting();
            }
            MovePageDown();
        }

        bool MovePreviousView()
        {
            if (Application.MdiTop != null)
            {
                return SuperView?.FocusPrev() == true;
            }

            return false;
        }

        bool MoveNextView()
        {
            if (Application.MdiTop != null)
            {
                return SuperView?.FocusNext() == true;
            }

            return false;
        }

        bool ProcessBackTab()
        {
            ResetColumnTrack();

            if (!AllowsTab || isReadOnly)
            {
                return ProcessMovePreviousView();
            }
            if (currentColumn > 0)
            {
                SetWrapModel();

                var currentLine = GetCurrentLine();
                if (currentLine.Count > 0 && currentLine[currentColumn - 1] == '\t')
                {

                    historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

                    currentLine.RemoveAt(currentColumn - 1);
                    currentColumn--;

                    historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                        HistoryText.LineStatus.Replaced);
                }

                UpdateWrapModel();
            }
            DoNeededAction();
            return true;
        }

        bool ProcessTab()
        {
            ResetColumnTrack();

            if (!AllowsTab || isReadOnly)
            {
                return ProcessMoveNextView();
            }
            InsertText(new KeyEvent((Key)'\t', null));
            DoNeededAction();
            return true;
        }

        void SetOverwrite(bool overwrite)
        {
            Used = overwrite;
            SetNeedsDisplay();
            DoNeededAction();
        }

        bool ProcessReturn()
        {
            ResetColumnTrack();

            if (!AllowsReturn || isReadOnly)
            {
                return false;
            }

            SetWrapModel();

            var currentLine = GetCurrentLine();

            historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

            if (selecting)
            {
                ClearSelectedRegion();
                currentLine = GetCurrentLine();
            }
            var restCount = currentLine.Count - currentColumn;
            var rest = currentLine.GetRange(currentColumn, restCount);
            currentLine.RemoveRange(currentColumn, restCount);

            var addedLines = new List<List<Rune>>() { new List<Rune>(currentLine) };

            model.AddLine(currentRow + 1, rest);

            addedLines.Add(new List<Rune>(model.GetLine(currentRow + 1)));

            historyText.Add(addedLines, CursorPosition, HistoryText.LineStatus.Added);

            currentRow++;

            bool fullNeedsDisplay = false;
            if (currentRow >= topRow + Frame.Height)
            {
                topRow++;
                fullNeedsDisplay = true;
            }
            currentColumn = 0;

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                HistoryText.LineStatus.Replaced);

            if (!wordWrap && currentColumn < leftColumn)
            {
                fullNeedsDisplay = true;
                leftColumn = 0;
            }

            if (fullNeedsDisplay)
                SetNeedsDisplay();
            else
                SetNeedsDisplay(new Rect(0, currentRow - topRow, 2, Frame.Height));

            UpdateWrapModel();

            DoNeededAction();
            OnContentsChanged();
            return true;
        }

        void KillWordBackward()
        {
            if (isReadOnly)
                return;

            SetWrapModel();

            var currentLine = GetCurrentLine();

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition);

            if (currentColumn == 0)
            {
                DeleteTextBackwards();

                historyText.ReplaceLast(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                UpdateWrapModel();

                return;
            }
            var newPos = WordBackward(currentColumn, currentRow);
            if (newPos.HasValue && currentRow == newPos.Value.row)
            {
                var restCount = currentColumn - newPos.Value.col;
                currentLine.RemoveRange(newPos.Value.col, restCount);
                if (wordWrap)
                {
                    wrapNeeded = true;
                }
                currentColumn = newPos.Value.col;
            }
            else if (newPos.HasValue)
            {
                var restCount = currentLine.Count - currentColumn;
                currentLine.RemoveRange(currentColumn, restCount);
                if (wordWrap)
                {
                    wrapNeeded = true;
                }
                currentColumn = newPos.Value.col;
                currentRow = newPos.Value.row;
            }

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                HistoryText.LineStatus.Replaced);

            UpdateWrapModel();

            if (wrapNeeded)
            {
                SetNeedsDisplay();
            }
            else
            {
                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
            }
            DoNeededAction();
        }

        void KillWordForward()
        {
            if (isReadOnly)
                return;

            SetWrapModel();

            var currentLine = GetCurrentLine();

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition);

            if (currentLine.Count == 0 || currentColumn == currentLine.Count)
            {
                DeleteTextForwards();

                historyText.ReplaceLast(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                UpdateWrapModel();

                return;
            }
            var newPos = WordForward(currentColumn, currentRow);
            var restCount = 0;
            if (newPos.HasValue && currentRow == newPos.Value.row)
            {
                restCount = newPos.Value.col - currentColumn;
                currentLine.RemoveRange(currentColumn, restCount);
            }
            else if (newPos.HasValue)
            {
                restCount = currentLine.Count - currentColumn;
                currentLine.RemoveRange(currentColumn, restCount);
            }
            if (wordWrap)
            {
                wrapNeeded = true;
            }

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                HistoryText.LineStatus.Replaced);

            UpdateWrapModel();

            if (wrapNeeded)
            {
                SetNeedsDisplay();
            }
            else
            {
                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
            }
            DoNeededAction();
        }

        void MoveWordForward()
        {
            var newPos = WordForward(currentColumn, currentRow);
            if (newPos.HasValue)
            {
                currentColumn = newPos.Value.col;
                currentRow = newPos.Value.row;
            }
            Adjust();
            DoNeededAction();
        }

        void MoveWordBackward()
        {
            var newPos = WordBackward(currentColumn, currentRow);
            if (newPos.HasValue)
            {
                currentColumn = newPos.Value.col;
                currentRow = newPos.Value.row;
            }
            Adjust();
            DoNeededAction();
        }

        void KillToStartOfLine()
        {
            if (isReadOnly)
                return;
            if (model.Count == 1 && GetCurrentLine().Count == 0)
            {
                // Prevents from adding line feeds if there is no more lines.
                return;
            }

            SetWrapModel();

            var currentLine = GetCurrentLine();
            var setLastWasKill = true;
            if (currentLine.Count > 0 && currentColumn == 0)
            {
                UpdateWrapModel();

                DeleteTextBackwards();
                return;
            }

            historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

            if (currentLine.Count == 0)
            {
                if (currentRow > 0)
                {
                    model.RemoveLine(currentRow);

                    if (model.Count > 0 || lastWasKill)
                    {
                        var val = ustring.Make(Environment.NewLine);
                        if (lastWasKill)
                        {
                            AppendClipboard(val);
                        }
                        else
                        {
                            SetClipboard(val);
                        }
                    }
                    if (model.Count == 0)
                    {
                        // Prevents from adding line feeds if there is no more lines.
                        setLastWasKill = false;
                    }

                    currentRow--;
                    currentLine = model.GetLine(currentRow);

                    var removedLine = new List<List<Rune>>() { new List<Rune>(currentLine) };

                    removedLine.Add(new List<Rune>());

                    historyText.Add(new List<List<Rune>>(removedLine), CursorPosition, HistoryText.LineStatus.Removed);

                    currentColumn = currentLine.Count;
                }
            }
            else
            {
                var restCount = currentColumn;
                var rest = currentLine.GetRange(0, restCount);
                var val = ustring.Empty;
                val += StringFromRunes(rest);
                if (lastWasKill)
                {
                    AppendClipboard(val);
                }
                else
                {
                    SetClipboard(val);
                }
                currentLine.RemoveRange(0, restCount);
                currentColumn = 0;
            }

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                HistoryText.LineStatus.Replaced);

            UpdateWrapModel();

            if (wrapNeeded)
                SetNeedsDisplay();
            else
                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
            lastWasKill = setLastWasKill;
            DoNeededAction();
        }

        void KillToEndOfLine()
        {
            if (isReadOnly)
                return;
            if (model.Count == 1 && GetCurrentLine().Count == 0)
            {
                // Prevents from adding line feeds if there is no more lines.
                return;
            }

            SetWrapModel();

            var currentLine = GetCurrentLine();
            var setLastWasKill = true;
            if (currentLine.Count > 0 && currentColumn == currentLine.Count)
            {
                UpdateWrapModel();

                DeleteTextForwards();
                return;
            }

            historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

            if (currentLine.Count == 0)
            {
                if (currentRow < model.Count - 1)
                {
                    var removedLines = new List<List<Rune>>() { new List<Rune>(currentLine) };

                    model.RemoveLine(currentRow);

                    removedLines.Add(new List<Rune>(GetCurrentLine()));

                    historyText.Add(new List<List<Rune>>(removedLines), CursorPosition,
                        HistoryText.LineStatus.Removed);
                }
                if (model.Count > 0 || lastWasKill)
                {
                    var val = ustring.Make(Environment.NewLine);
                    if (lastWasKill)
                    {
                        AppendClipboard(val);
                    }
                    else
                    {
                        SetClipboard(val);
                    }
                }
                if (model.Count == 0)
                {
                    // Prevents from adding line feeds if there is no more lines.
                    setLastWasKill = false;
                }
            }
            else
            {
                var restCount = currentLine.Count - currentColumn;
                var rest = currentLine.GetRange(currentColumn, restCount);
                var val = ustring.Empty;
                val += StringFromRunes(rest);
                if (lastWasKill)
                {
                    AppendClipboard(val);
                }
                else
                {
                    SetClipboard(val);
                }
                currentLine.RemoveRange(currentColumn, restCount);
            }

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                HistoryText.LineStatus.Replaced);

            UpdateWrapModel();

            if (wrapNeeded)
                SetNeedsDisplay();
            else
                SetNeedsDisplay(new Rect(0, currentRow - topRow, Frame.Width, Frame.Height));
            lastWasKill = setLastWasKill;
            DoNeededAction();
        }

        void MoveEndOfLine()
        {
            var currentLine = GetCurrentLine();
            currentColumn = currentLine.Count;
            Adjust();
            DoNeededAction();
        }

        void MoveStartOfLine()
        {
            currentColumn = 0;
            leftColumn = 0;
            Adjust();
            DoNeededAction();
        }

        /// <summary>
        /// Deletes all the selected or a single character at right from the position of the cursor.
        /// </summary>
        public void DeleteCharRight()
        {
            if (isReadOnly)
                return;

            SetWrapModel();

            if (selecting)
            {
                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                    HistoryText.LineStatus.Original);

                ClearSelectedRegion();

                var currentLine = GetCurrentLine();

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                UpdateWrapModel();

                return;
            }
            if (DeleteTextForwards())
            {
                UpdateWrapModel();
                OnContentsChanged();

                return;
            }

            UpdateWrapModel();

            DoNeededAction();
            OnContentsChanged();
        }

        /// <summary>
        /// Deletes all the selected or a single character at left from the position of the cursor.
        /// </summary>
        public void DeleteCharLeft()
        {
            if (isReadOnly)
                return;

            SetWrapModel();

            if (selecting)
            {
                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                    HistoryText.LineStatus.Original);

                ClearSelectedRegion();

                var currentLine = GetCurrentLine();

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                UpdateWrapModel();
                OnContentsChanged();

                return;
            }
            if (DeleteTextBackwards())
            {
                UpdateWrapModel();
                OnContentsChanged();

                return;
            }

            UpdateWrapModel();

            DoNeededAction();
            OnContentsChanged();
        }

        void MoveLeft()
        {
            if (currentColumn > 0)
            {
                currentColumn--;
            }
            else
            {
                if (currentRow > 0)
                {
                    currentRow--;
                    if (currentRow < topRow)
                    {
                        topRow--;
                        SetNeedsDisplay();
                    }
                    var currentLine = GetCurrentLine();
                    currentColumn = currentLine.Count;
                }
            }
            Adjust();
            DoNeededAction();
        }

        void MoveRight()
        {
            var currentLine = GetCurrentLine();
            if (currentColumn < currentLine.Count)
            {
                currentColumn++;
            }
            else
            {
                if (currentRow + 1 < model.Count)
                {
                    currentRow++;
                    currentColumn = 0;
                    if (currentRow >= topRow + Frame.Height)
                    {
                        topRow++;
                        SetNeedsDisplay();
                    }
                }
            }
            Adjust();
            DoNeededAction();
        }

        void MovePageUp()
        {
            int nPageUpShift = Frame.Height - 1;
            if (currentRow > 0)
            {
                if (columnTrack == -1)
                    columnTrack = currentColumn;
                currentRow = currentRow - nPageUpShift < 0 ? 0 : currentRow - nPageUpShift;
                if (currentRow < topRow)
                {
                    topRow = topRow - nPageUpShift < 0 ? 0 : topRow - nPageUpShift;
                    SetNeedsDisplay();
                }
                TrackColumn();
                PositionCursor();
            }
            DoNeededAction();
        }

        void MovePageDown()
        {
            int nPageDnShift = Frame.Height - 1;
            if (currentRow >= 0 && currentRow < model.Count)
            {
                if (columnTrack == -1)
                    columnTrack = currentColumn;
                currentRow = (currentRow + nPageDnShift) > model.Count
                    ? model.Count > 0 ? model.Count - 1 : 0
                    : currentRow + nPageDnShift;
                if (topRow < currentRow - nPageDnShift)
                {
                    topRow = currentRow >= model.Count ? currentRow - nPageDnShift : topRow + nPageDnShift;
                    SetNeedsDisplay();
                }
                TrackColumn();
                PositionCursor();
            }
            DoNeededAction();
        }

        void ResetContinuousFindTrack()
        {
            // Handle some state here - whether the last command was a kill
            // operation and the column tracking (up/down)
            lastWasKill = false;
            continuousFind = false;
        }

        void ResetColumnTrack()
        {
            // Handle some state here - whether the last command was a kill
            // operation and the column tracking (up/down)
            lastWasKill = false;
            columnTrack = -1;
        }

        void ResetAllTrack()
        {
            // Handle some state here - whether the last command was a kill
            // operation and the column tracking (up/down)
            lastWasKill = false;
            columnTrack = -1;
            continuousFind = false;
        }

        bool InsertText(KeyEvent kb)
        {
            //So that special keys like tab can be processed
            if (isReadOnly)
                return true;

            SetWrapModel();

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition);

            if (selecting)
            {
                ClearSelectedRegion();
            }
            if (kb.Key == Key.Enter)
            {
                model.AddLine(currentRow + 1, new List<Rune>());
                currentRow++;
                currentColumn = 0;
            }
            else if ((uint)kb.Key == 13)
            {
                currentColumn = 0;
            }
            else
            {
                if (Used)
                {
                    Insert((uint)kb.Key);
                    currentColumn++;
                    if (currentColumn >= leftColumn + Frame.Width)
                    {
                        leftColumn++;
                        SetNeedsDisplay();
                    }
                }
                else
                {
                    Insert((uint)kb.Key);
                    currentColumn++;
                }
            }

            historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                HistoryText.LineStatus.Replaced);

            UpdateWrapModel();
            OnContentsChanged();

            return true;
        }

        void ShowContextMenu()
        {
            if (currentCulture != Thread.CurrentThread.CurrentUICulture)
            {

                currentCulture = Thread.CurrentThread.CurrentUICulture;

                ContextMenu.MenuItems = BuildContextMenuBarItem();
            }
            ContextMenu.Show();
        }

        /// <summary>
        /// Deletes all text.
        /// </summary>
        public void DeleteAll()
        {
            if (Lines == 0)
            {
                return;
            }

            selectionStartColumn = 0;
            selectionStartRow = 0;
            MoveBottomEndExtend();
            DeleteCharLeft();
            SetNeedsDisplay();
        }

        ///<inheritdoc/>
        public override bool OnKeyUp(KeyEvent kb)
        {
            switch (kb.Key)
            {
                case Key.Space | Key.CtrlMask:
                    return true;
            }

            return false;
        }

        void DoNeededAction()
        {
            if (NeedDisplay.IsEmpty)
            {
                PositionCursor();
            }
            else
            {
                Adjust();
            }
        }

        bool DeleteTextForwards()
        {
            SetWrapModel();

            var currentLine = GetCurrentLine();
            if (currentColumn == currentLine.Count)
            {
                if (currentRow + 1 == model.Count)
                {
                    UpdateWrapModel();

                    return true;
                }

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

                var removedLines = new List<List<Rune>>() { new List<Rune>(currentLine) };

                var nextLine = model.GetLine(currentRow + 1);

                removedLines.Add(new List<Rune>(nextLine));

                historyText.Add(removedLines, CursorPosition, HistoryText.LineStatus.Removed);

                currentLine.AddRange(nextLine);
                model.RemoveLine(currentRow + 1);

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                if (wordWrap)
                {
                    wrapNeeded = true;
                }
                if (wrapNeeded)
                {
                    SetNeedsDisplay();
                }
                else
                {
                    var sr = currentRow - topRow;
                    SetNeedsDisplay(new Rect(0, sr, Frame.Width, sr + 1));
                }
            }
            else
            {
                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

                currentLine.RemoveAt(currentColumn);

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                if (wordWrap)
                {
                    wrapNeeded = true;
                }

                if (wrapNeeded)
                {
                    SetNeedsDisplay();
                }
                else
                {
                    var r = currentRow - topRow;
                    SetNeedsDisplay(new Rect(currentColumn - leftColumn, r, Frame.Width, r + 1));
                }
            }

            UpdateWrapModel();

            return false;
        }

        bool DeleteTextBackwards()
        {
            SetWrapModel();

            if (currentColumn > 0)
            {
                // Delete backwards 
                var currentLine = GetCurrentLine();

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

                currentLine.RemoveAt(currentColumn - 1);
                if (wordWrap)
                {
                    wrapNeeded = true;
                }
                currentColumn--;

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                if (currentColumn < leftColumn)
                {
                    leftColumn--;
                    SetNeedsDisplay();
                }
                else
                    SetNeedsDisplay(new Rect(0, currentRow - topRow, 1, Frame.Width));
            }
            else
            {
                // Merges the current line with the previous one.
                if (currentRow == 0)
                    return true;
                var prowIdx = currentRow - 1;
                var prevRow = model.GetLine(prowIdx);

                historyText.Add(new List<List<Rune>>() { new List<Rune>(prevRow) }, CursorPosition);

                List<List<Rune>> removedLines = new List<List<Rune>>() { new List<Rune>(prevRow) };

                removedLines.Add(new List<Rune>(GetCurrentLine()));

                historyText.Add(removedLines, new Point(currentColumn, prowIdx),
                    HistoryText.LineStatus.Removed);

                var prevCount = prevRow.Count;
                model.GetLine(prowIdx).AddRange(GetCurrentLine());
                model.RemoveLine(currentRow);
                if (wordWrap)
                {
                    wrapNeeded = true;
                }
                currentRow--;

                historyText.Add(new List<List<Rune>>() { GetCurrentLine() }, new Point(currentColumn, prowIdx),
                    HistoryText.LineStatus.Replaced);

                currentColumn = prevCount;
                SetNeedsDisplay();
            }

            UpdateWrapModel();

            return false;
        }

        bool copyWithoutSelection;

        /// <summary>
        /// Copy the selected text to the clipboard contents.
        /// </summary>
        public void Copy()
        {
            SetWrapModel();
            if (selecting)
            {
                SetClipboard(GetRegion());
                copyWithoutSelection = false;
            }
            else
            {
                var currentLine = GetCurrentLine();
                SetClipboard(ustring.Make(currentLine));
                copyWithoutSelection = true;
            }
            UpdateWrapModel();
            DoNeededAction();
        }

        /// <summary>
        /// Cut the selected text to the clipboard contents.
        /// </summary>
        public void Cut()
        {
            SetWrapModel();
            SetClipboard(GetRegion());
            if (!isReadOnly)
            {
                ClearRegion();

                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);
            }
            UpdateWrapModel();
            selecting = false;
            DoNeededAction();
            OnContentsChanged();
        }

        /// <summary>
        /// Paste the clipboard contents into the current selected position.
        /// </summary>
        public void Paste()
        {
            if (isReadOnly)
            {
                return;
            }

            SetWrapModel();
            var contents = Clipboard.Contents;
            if (copyWithoutSelection && contents.FirstOrDefault(x => x == '\n' || x == '\r') == 0)
            {
                var runeList = contents == null ? new List<Rune>() : contents.ToRuneList();
                var currentLine = GetCurrentLine();

                historyText.Add(new List<List<Rune>>() { new List<Rune>(currentLine) }, CursorPosition);

                var addedLine = new List<List<Rune>>() { new List<Rune>(currentLine) };

                addedLine.Add(runeList);

                historyText.Add(new List<List<Rune>>(addedLine), CursorPosition, HistoryText.LineStatus.Added);

                model.AddLine(currentRow, runeList);
                currentRow++;

                historyText.Add(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                    HistoryText.LineStatus.Replaced);

                SetNeedsDisplay();
                OnContentsChanged();
            }
            else
            {
                if (selecting)
                {
                    ClearRegion();
                }
                copyWithoutSelection = false;
                InsertText(contents);

                if (selecting)
                {
                    historyText.ReplaceLast(new List<List<Rune>>() { new List<Rune>(GetCurrentLine()) }, CursorPosition,
                        HistoryText.LineStatus.Original);
                }

                SetNeedsDisplay();
            }
            UpdateWrapModel();
            selecting = false;
            DoNeededAction();
        }

        void StartSelecting()
        {
            if (shiftSelecting && selecting)
            {
                return;
            }
            shiftSelecting = true;
            selecting = true;
            selectionStartColumn = currentColumn;
            selectionStartRow = currentRow;
        }

        void StopSelecting()
        {
            shiftSelecting = false;
            selecting = false;
            isButtonShift = false;
        }

        void ClearSelectedRegion()
        {
            SetWrapModel();
            if (!isReadOnly)
            {
                ClearRegion();
            }
            UpdateWrapModel();
            selecting = false;
            DoNeededAction();
        }

        void MoveUp()
        {
            if (currentRow > 0)
            {
                if (columnTrack == -1)
                {
                    columnTrack = currentColumn;
                }
                currentRow--;
                if (currentRow < topRow)
                {
                    topRow--;
                    SetNeedsDisplay();
                }
                TrackColumn();
                PositionCursor();
            }
            DoNeededAction();
        }

        void MoveDown()
        {
            if (currentRow + 1 < model.Count)
            {
                if (columnTrack == -1)
                {
                    columnTrack = currentColumn;
                }
                currentRow++;
                if (currentRow + BottomOffset >= topRow + Frame.Height)
                {
                    topRow++;
                    SetNeedsDisplay();
                }
                TrackColumn();
                PositionCursor();
            }
            else if (currentRow > Frame.Height)
            {
                Adjust();
            }
            DoNeededAction();
        }

        IEnumerable<(int col, int row, Rune rune)> ForwardIterator(int col, int row)
        {
            if (col < 0 || row < 0)
                yield break;
            if (row >= model.Count)
                yield break;
            var line = GetCurrentLine();
            if (col >= line.Count)
                yield break;

            while (row < model.Count)
            {
                for (int c = col; c < line.Count; c++)
                {
                    yield return (c, row, line[c]);
                }
                col = 0;
                row++;
                line = GetCurrentLine();
            }
        }

        Rune RuneAt(int col, int row)
        {
            var line = model.GetLine(row);
            if (line.Count > 0)
            {
                return line[col > line.Count - 1 ? line.Count - 1 : col];
            }
            else
            {
                return 0;
            }
        }

        /// <summary>
        /// Will scroll the <see cref="TextView"/> to the last line and position the cursor there.
        /// </summary>
        public void MoveEnd()
        {
            currentRow = model.Count - 1;
            var line = GetCurrentLine();
            currentColumn = line.Count;
            TrackColumn();
            PositionCursor();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Will scroll the <see cref="TextView"/> to the first line and position the cursor there.
        /// </summary>
        public void MoveHome()
        {
            currentRow = 0;
            topRow = 0;
            currentColumn = 0;
            leftColumn = 0;
            TrackColumn();
            PositionCursor();
            SetNeedsDisplay();
        }

        bool MoveNext(ref int col, ref int row, out Rune rune)
        {
            var line = model.GetLine(row);
            if (col + 1 < line.Count)
            {
                col++;
                rune = line[col];
                if (col + 1 == line.Count && !Rune.IsLetterOrDigit(rune)
                    && !Rune.IsWhiteSpace(line[col - 1]))
                {
                    col++;
                }
                return true;
            }
            else if (col + 1 == line.Count)
            {
                col++;
            }
            while (row + 1 < model.Count)
            {
                col = 0;
                row++;
                line = model.GetLine(row);
                if (line.Count > 0)
                {
                    rune = line[0];
                    return true;
                }
            }
            rune = 0;
            return false;
        }

        bool MovePrev(ref int col, ref int row, out Rune rune)
        {
            var line = model.GetLine(row);

            if (col > 0)
            {
                col--;
                rune = line[col];
                return true;
            }
            if (row == 0)
            {
                rune = 0;
                return false;
            }
            while (row > 0)
            {
                row--;
                line = model.GetLine(row);
                col = line.Count - 1;
                if (col >= 0)
                {
                    rune = line[col];
                    return true;
                }
            }
            rune = 0;
            return false;
        }

        (int col, int row)? WordForward(int fromCol, int fromRow)
        {
            var col = fromCol;
            var row = fromRow;
            try
            {
                var rune = RuneAt(col, row);

                void ProcMoveNext(ref int nCol, ref int nRow, Rune nRune)
                {
                    if (Rune.IsSymbol(nRune) || Rune.IsWhiteSpace(nRune))
                    {
                        while (MoveNext(ref nCol, ref nRow, out nRune))
                        {
                            if (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune))
                                return;
                        }
                        if (nRow != fromRow && (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune)))
                        {
                            return;
                        }
                        while (MoveNext(ref nCol, ref nRow, out nRune))
                        {
                            if (!Rune.IsLetterOrDigit(nRune) && !Rune.IsPunctuation(nRune))
                                break;
                        }
                    }
                    else
                    {
                        if (!MoveNext(ref nCol, ref nRow, out nRune))
                        {
                            return;
                        }

                        var line = model.GetLine(fromRow);
                        if ((nRow != fromRow && fromCol < line.Count)
                            || (nRow == fromRow && nCol == line.Count - 1))
                        {
                            nCol = line.Count;
                            nRow = fromRow;
                            return;
                        }
                        else if (nRow != fromRow && fromCol == line.Count)
                        {
                            line = model.GetLine(nRow);
                            if (Rune.IsLetterOrDigit(line[nCol]) || Rune.IsPunctuation(line[nCol]))
                            {
                                return;
                            }
                        }
                        ProcMoveNext(ref nCol, ref nRow, nRune);
                    }
                }

                ProcMoveNext(ref col, ref row, rune);

                if (fromCol != col || fromRow != row)
                    return (col, row);
                return null;
            }
            catch (Exception)
            {
                return null;
            }
        }

        (int col, int row)? WordBackward(int fromCol, int fromRow)
        {
            if (fromRow == 0 && fromCol == 0)
                return null;

            var col = Math.Max(fromCol - 1, 0);
            var row = fromRow;
            try
            {
                var rune = RuneAt(col, row);
                int lastValidCol = Rune.IsLetterOrDigit(rune) || Rune.IsPunctuation(rune) ? col : -1;

                void ProcMovePrev(ref int nCol, ref int nRow, Rune nRune)
                {
                    if (Rune.IsSymbol(nRune) || Rune.IsWhiteSpace(nRune))
                    {
                        while (MovePrev(ref nCol, ref nRow, out nRune))
                        {
                            if (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune))
                            {
                                lastValidCol = nCol;
                                break;
                            }
                        }
                        if (nRow != fromRow && (Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune)))
                        {
                            if (lastValidCol > -1)
                            {
                                nCol = lastValidCol;
                            }
                            return;
                        }
                        while (MovePrev(ref nCol, ref nRow, out nRune))
                        {
                            if (!Rune.IsLetterOrDigit(nRune) && !Rune.IsPunctuation(nRune))
                                break;
                            if (nRow != fromRow)
                            {
                                break;
                            }
                            lastValidCol = nCol;
                        }
                        if (lastValidCol > -1)
                        {
                            nCol = lastValidCol;
                            nRow = fromRow;
                        }
                    }
                    else
                    {
                        if (!MovePrev(ref nCol, ref nRow, out nRune))
                        {
                            return;
                        }

                        var line = model.GetLine(nRow);
                        if (nCol == 0 && nRow == fromRow && (Rune.IsLetterOrDigit(line[0]) || Rune.IsPunctuation(line[0])))
                        {
                            return;
                        }
                        lastValidCol = Rune.IsLetterOrDigit(nRune) || Rune.IsPunctuation(nRune) ? nCol : lastValidCol;
                        if (lastValidCol > -1 && (Rune.IsSymbol(nRune) || Rune.IsWhiteSpace(nRune)))
                        {
                            nCol = lastValidCol;
                            return;
                        }
                        if (fromRow != nRow)
                        {
                            nCol = line.Count;
                            return;
                        }
                        ProcMovePrev(ref nCol, ref nRow, nRune);
                    }
                }

                ProcMovePrev(ref col, ref row, rune);

                if (fromCol != col || fromRow != row)
                    return (col, row);
                return null;
            }
            catch (Exception)
            {
                return null;
            }
        }

        bool isButtonShift;
        bool clickWithSelecting;

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent ev)
        {
            if (!ev.Flags.HasFlag(MouseFlags.Button1Clicked) && !ev.Flags.HasFlag(MouseFlags.Button1Pressed)
                && !ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition)
                && !ev.Flags.HasFlag(MouseFlags.Button1Released)
                && !ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ButtonShift)
                && !ev.Flags.HasFlag(MouseFlags.WheeledDown) && !ev.Flags.HasFlag(MouseFlags.WheeledUp)
                && !ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked)
                && !ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked | MouseFlags.ButtonShift)
                && !ev.Flags.HasFlag(MouseFlags.Button1TripleClicked)
                && !ev.Flags.HasFlag(ContextMenu.MouseFlags))
            {
                return false;
            }

            if (!CanFocus)
            {
                return true;
            }

            if (!HasFocus)
            {
                SetFocus();
            }

            continuousFind = false;

            // Give autocomplete first opportunity to respond to mouse clicks
            if (SelectedLength == 0 && Autocomplete.MouseEvent(ev, true))
            {
                return true;
            }

            if (ev.Flags == MouseFlags.Button1Clicked)
            {
                if (shiftSelecting && !isButtonShift)
                {
                    StopSelecting();
                }
                ProcessMouseClick(ev, out _);
                PositionCursor();
                lastWasKill = false;
                columnTrack = currentColumn;
            }
            else if (ev.Flags == MouseFlags.WheeledDown)
            {
                lastWasKill = false;
                columnTrack = currentColumn;
                ScrollTo(topRow + 1);
            }
            else if (ev.Flags == MouseFlags.WheeledUp)
            {
                lastWasKill = false;
                columnTrack = currentColumn;
                ScrollTo(topRow - 1);
            }
            else if (ev.Flags == MouseFlags.WheeledRight)
            {
                lastWasKill = false;
                columnTrack = currentColumn;
                ScrollTo(leftColumn + 1, false);
            }
            else if (ev.Flags == MouseFlags.WheeledLeft)
            {
                lastWasKill = false;
                columnTrack = currentColumn;
                ScrollTo(leftColumn - 1, false);
            }
            else if (ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition))
            {
                ProcessMouseClick(ev, out List<Rune> line);
                PositionCursor();
                if (model.Count > 0 && shiftSelecting && selecting)
                {
                    if (currentRow - topRow + BottomOffset >= Frame.Height - 1
                        && model.Count + BottomOffset > topRow + currentRow)
                    {
                        ScrollTo(topRow + Frame.Height);
                    }
                    else if (topRow > 0 && currentRow <= topRow)
                    {
                        ScrollTo(topRow - Frame.Height);
                    }
                    else if (ev.Y >= Frame.Height)
                    {
                        ScrollTo(model.Count + BottomOffset);
                    }
                    else if (ev.Y < 0 && topRow > 0)
                    {
                        ScrollTo(0);
                    }
                    if (currentColumn - leftColumn + RightOffset >= Frame.Width - 1
                        && line.Count + RightOffset > leftColumn + currentColumn)
                    {
                        ScrollTo(leftColumn + Frame.Width, false);
                    }
                    else if (leftColumn > 0 && currentColumn <= leftColumn)
                    {
                        ScrollTo(leftColumn - Frame.Width, false);
                    }
                    else if (ev.X >= Frame.Width)
                    {
                        ScrollTo(line.Count + RightOffset, false);
                    }
                    else if (ev.X < 0 && leftColumn > 0)
                    {
                        ScrollTo(0, false);
                    }
                }
                lastWasKill = false;
                columnTrack = currentColumn;
            }
            else if (ev.Flags.HasFlag(MouseFlags.Button1Pressed | MouseFlags.ButtonShift))
            {
                if (!shiftSelecting)
                {
                    isButtonShift = true;
                    StartSelecting();
                }
                ProcessMouseClick(ev, out _);
                PositionCursor();
                lastWasKill = false;
                columnTrack = currentColumn;
            }
            else if (ev.Flags.HasFlag(MouseFlags.Button1Pressed))
            {
                if (shiftSelecting)
                {
                    clickWithSelecting = true;
                    StopSelecting();
                }
                ProcessMouseClick(ev, out _);
                PositionCursor();
                if (!selecting)
                {
                    StartSelecting();
                }
                lastWasKill = false;
                columnTrack = currentColumn;
                if (Application.MouseGrabView == null)
                {
                    Application.GrabMouse(this);
                }
            }
            else if (ev.Flags.HasFlag(MouseFlags.Button1Released))
            {
                Application.UngrabMouse();
            }
            else if (ev.Flags.HasFlag(MouseFlags.Button1DoubleClicked))
            {
                if (ev.Flags.HasFlag(MouseFlags.ButtonShift))
                {
                    if (!selecting)
                    {
                        StartSelecting();
                    }
                }
                else if (selecting)
                {
                    StopSelecting();
                }
                ProcessMouseClick(ev, out List<Rune> line);
                (int col, int row)? newPos;
                if (currentColumn == line.Count || (currentColumn > 0 && (line[currentColumn - 1] != ' '
                    || line[currentColumn] == ' ')))
                {

                    newPos = WordBackward(currentColumn, currentRow);
                    if (newPos.HasValue)
                    {
                        currentColumn = currentRow == newPos.Value.row ? newPos.Value.col : 0;
                    }
                }
                if (!selecting)
                {
                    StartSelecting();
                }
                newPos = WordForward(currentColumn, currentRow);
                if (newPos != null && newPos.HasValue)
                {
                    currentColumn = currentRow == newPos.Value.row ? newPos.Value.col : line.Count;
                }
                PositionCursor();
                lastWasKill = false;
                columnTrack = currentColumn;
            }
            else if (ev.Flags.HasFlag(MouseFlags.Button1TripleClicked))
            {
                if (selecting)
                {
                    StopSelecting();
                }
                ProcessMouseClick(ev, out List<Rune> line);
                currentColumn = 0;
                if (!selecting)
                {
                    StartSelecting();
                }
                currentColumn = line.Count;
                PositionCursor();
                lastWasKill = false;
                columnTrack = currentColumn;
            }
            else if (ev.Flags == ContextMenu.MouseFlags)
            {
                ContextMenu.Position = new Point(ev.X + 2, ev.Y + 2);
                ShowContextMenu();
            }

            return true;
        }

        void ProcessMouseClick(MouseEvent ev, out List<Rune> line)
        {
            List<Rune> r = null;
            if (model.Count > 0)
            {
                var maxCursorPositionableLine = Math.Max((model.Count - 1) - topRow, 0);
                if (Math.Max(ev.Y, 0) > maxCursorPositionableLine)
                {
                    currentRow = maxCursorPositionableLine + topRow;
                }
                else
                {
                    currentRow = Math.Max(ev.Y + topRow, 0);
                }
                r = GetCurrentLine();
                var idx = TextModel.GetColFromX(r, leftColumn, Math.Max(ev.X, 0), TabWidth);
                if (idx - leftColumn >= r.Count + RightOffset)
                {
                    currentColumn = Math.Max(r.Count - leftColumn + RightOffset, 0);
                }
                else
                {
                    currentColumn = idx + leftColumn;
                }
            }

            line = r;
        }

        /// <summary>
        /// Allows clearing the <see cref="HistoryText.HistoryTextItem"/> items updating the original text.
        /// </summary>
        public void ClearHistoryChanges()
        {
            historyText?.Clear(Text);
        }
    }


    /// <summary>
    /// Renders an overlay on another view at a given point that allows selecting
    /// from a range of 'autocomplete' options.
    /// An implementation on a TextView.
    /// </summary>
    public class TextViewAutocomplete : Autocomplete
    {

        ///<inheritdoc/>
        protected override string GetCurrentWord(int columnOffset = 0)
        {
            var host = (TextView)HostControl;
            var currentLine = host.GetCurrentLine();
            var cursorPosition = Math.Min(host.CurrentColumn + columnOffset, currentLine.Count);
            return IdxToWord(currentLine, cursorPosition, columnOffset);
        }

        /// <inheritdoc/>
        protected override void DeleteTextBackwards()
        {
            ((TextView)HostControl).DeleteCharLeft();
        }

        /// <inheritdoc/>
        protected override void InsertText(string accepted)
        {
            ((TextView)HostControl).InsertText(accepted);
        }
    }
    //=======================================================================
    //
    // TimeField.cs: text entry for time
    //
    // Author: Jörg Preiß
    //
    // Licensed under the MIT license

    /// <summary>
    ///   Time editing <see cref="View"/>
    /// </summary>
    /// <remarks>
    ///   The <see cref="TimeField"/> <see cref="View"/> provides time editing functionality with mouse support.
    /// </remarks>
    public class TimeField : TextField
    {
        TimeSpan time;
        bool isShort;

        int longFieldLen = 8;
        int shortFieldLen = 5;
        string sepChar;
        string longFormat;
        string shortFormat;

        int fieldLen => isShort ? shortFieldLen : longFieldLen;
        string format => isShort ? shortFormat : longFormat;

        /// <summary>
        ///   TimeChanged event, raised when the Date has changed.
        /// </summary>
        /// <remarks>
        ///   This event is raised when the <see cref="Time"/> changes.
        /// </remarks>
        /// <remarks>
        ///   The passed <see cref="EventArgs"/> is a <see cref="DateTimeEventArgs{T}"/> containing the old value, new value, and format string.
        /// </remarks>
        public event Action<DateTimeEventArgs<TimeSpan>> TimeChanged;

        /// <summary>
        ///    Initializes a new instance of <see cref="TimeField"/> using <see cref="LayoutStyle.Absolute"/> positioning.
        /// </summary>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        /// <param name="time">Initial time.</param>
        /// <param name="isShort">If true, the seconds are hidden. Sets the <see cref="IsShortFormat"/> property.</param>
        public TimeField(int x, int y, TimeSpan time, bool isShort = false) : base(x, y, isShort ? 7 : 10, "")
        {
            Initialize(time, isShort);
        }

        /// <summary>
        ///    Initializes a new instance of <see cref="TimeField"/> using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        /// <param name="time">Initial time</param>
        public TimeField(TimeSpan time) : base(string.Empty)
        {
            Width = fieldLen + 2;
            Initialize(time);
        }

        /// <summary>
        ///    Initializes a new instance of <see cref="TimeField"/> using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        public TimeField() : this(time: TimeSpan.MinValue) { }

        void Initialize(TimeSpan time, bool isShort = false)
        {
            CultureInfo cultureInfo = CultureInfo.CurrentCulture;
            sepChar = cultureInfo.DateTimeFormat.TimeSeparator;
            longFormat = $" hh\\{sepChar}mm\\{sepChar}ss";
            shortFormat = $" hh\\{sepChar}mm";
            this.isShort = isShort;
            Time = time;
            CursorPosition = 1;
            TextChanged += TextField_TextChanged;

            // Things this view knows how to do
            AddCommand(Command.DeleteCharRight, () => { DeleteCharRight(); return true; });
            AddCommand(Command.DeleteCharLeft, () => { DeleteCharLeft(); return true; });
            AddCommand(Command.LeftHome, () => MoveHome());
            AddCommand(Command.Left, () => MoveLeft());
            AddCommand(Command.RightEnd, () => MoveEnd());
            AddCommand(Command.Right, () => MoveRight());

            // Default keybindings for this view
            AddKeyBinding(Key.DeleteChar, Command.DeleteCharRight);
            AddKeyBinding(Key.D | Key.CtrlMask, Command.DeleteCharRight);

            AddKeyBinding(Key.Delete, Command.DeleteCharLeft);
            AddKeyBinding(Key.Backspace, Command.DeleteCharLeft);

            AddKeyBinding(Key.Home, Command.LeftHome);
            AddKeyBinding(Key.A | Key.CtrlMask, Command.LeftHome);

            AddKeyBinding(Key.CursorLeft, Command.Left);
            AddKeyBinding(Key.B | Key.CtrlMask, Command.Left);

            AddKeyBinding(Key.End, Command.RightEnd);
            AddKeyBinding(Key.E | Key.CtrlMask, Command.RightEnd);

            AddKeyBinding(Key.CursorRight, Command.Right);
            AddKeyBinding(Key.F | Key.CtrlMask, Command.Right);
        }

        void TextField_TextChanged(ustring e)
        {
            try
            {
                if (!TimeSpan.TryParseExact(Text.ToString().Trim(), format.Trim(), CultureInfo.CurrentCulture, TimeSpanStyles.None, out TimeSpan result))
                    Text = e;
            }
            catch (Exception)
            {
                Text = e;
            }
        }

        /// <summary>
        ///   Gets or sets the time of the <see cref="TimeField"/>.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public TimeSpan Time
        {
            get
            {
                return time;
            }
            set
            {
                if (ReadOnly)
                    return;

                var oldTime = time;
                time = value;
                this.Text = " " + value.ToString(format.Trim());
                var args = new DateTimeEventArgs<TimeSpan>(oldTime, value, format);
                if (oldTime != value)
                {
                    OnTimeChanged(args);
                }
            }
        }

        /// <summary>
        /// Get or sets whether <see cref="TimeField"/> uses the short or long time format.
        /// </summary>
        public bool IsShortFormat
        {
            get => isShort;
            set
            {
                isShort = value;
                if (isShort)
                    Width = 7;
                else
                    Width = 10;
                var ro = ReadOnly;
                if (ro)
                    ReadOnly = false;
                SetText(Text);
                ReadOnly = ro;
                SetNeedsDisplay();
            }
        }

        /// <inheritdoc/>
        public override int CursorPosition
        {
            get => base.CursorPosition;
            set
            {
                base.CursorPosition = Math.Max(Math.Min(value, fieldLen), 1);
            }
        }

        bool SetText(Rune key)
        {
            var text = TextModel.ToRunes(Text);
            var newText = text.GetRange(0, CursorPosition);
            newText.Add(key);
            if (CursorPosition < fieldLen)
                newText = newText.Concat(text.GetRange(CursorPosition + 1, text.Count - (CursorPosition + 1))).ToList();
            return SetText(ustring.Make(newText));
        }

        bool SetText(ustring text)
        {
            if (text.IsEmpty)
            {
                return false;
            }

            ustring[] vals = text.Split(ustring.Make(sepChar));
            bool isValidTime = true;
            int hour = Int32.Parse(vals[0].ToString());
            int minute = Int32.Parse(vals[1].ToString());
            int second = isShort ? 0 : vals.Length > 2 ? Int32.Parse(vals[2].ToString()) : 0;
            if (hour < 0)
            {
                isValidTime = false;
                hour = 0;
                vals[0] = "0";
            }
            else if (hour > 23)
            {
                isValidTime = false;
                hour = 23;
                vals[0] = "23";
            }
            if (minute < 0)
            {
                isValidTime = false;
                minute = 0;
                vals[1] = "0";
            }
            else if (minute > 59)
            {
                isValidTime = false;
                minute = 59;
                vals[1] = "59";
            }
            if (second < 0)
            {
                isValidTime = false;
                second = 0;
                vals[2] = "0";
            }
            else if (second > 59)
            {
                isValidTime = false;
                second = 59;
                vals[2] = "59";
            }
            string t = isShort ? $" {hour,2:00}{sepChar}{minute,2:00}" : $" {hour,2:00}{sepChar}{minute,2:00}{sepChar}{second,2:00}";

            if (!TimeSpan.TryParseExact(t.Trim(), format.Trim(), CultureInfo.CurrentCulture, TimeSpanStyles.None, out TimeSpan result) ||
                !isValidTime)
                return false;
            Time = result;
            return true;
        }

        void IncCursorPosition()
        {
            if (CursorPosition == fieldLen)
                return;
            if (Text[++CursorPosition] == sepChar.ToCharArray()[0])
                CursorPosition++;
        }

        void DecCursorPosition()
        {
            if (CursorPosition == 1)
                return;
            if (Text[--CursorPosition] == sepChar.ToCharArray()[0])
                CursorPosition--;
        }

        void AdjCursorPosition()
        {
            if (Text[CursorPosition] == sepChar.ToCharArray()[0])
                CursorPosition++;
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent kb)
        {
            var result = InvokeKeybindings(kb);
            if (result != null)
                return (bool)result;

            // Ignore non-numeric characters.
            if (kb.Key < (Key)((int)Key.D0) || kb.Key > (Key)((int)Key.D9))
                return false;

            if (ReadOnly)
                return true;

            if (SetText(TextModel.ToRunes(ustring.Make((uint)kb.Key)).First()))
                IncCursorPosition();

            return true;
        }

        bool MoveRight()
        {
            IncCursorPosition();
            return true;
        }

        bool MoveEnd()
        {
            CursorPosition = fieldLen;
            return true;
        }

        bool MoveLeft()
        {
            DecCursorPosition();
            return true;
        }

        bool MoveHome()
        {
            // Home, C-A
            CursorPosition = 1;
            return true;
        }

        /// <inheritdoc/>
        public override void DeleteCharLeft(bool useOldCursorPos = true)
        {
            if (ReadOnly)
                return;

            SetText('0');
            DecCursorPosition();
            return;
        }

        /// <inheritdoc/>
        public override void DeleteCharRight()
        {
            if (ReadOnly)
                return;

            SetText('0');
            return;
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent ev)
        {
            if (!ev.Flags.HasFlag(MouseFlags.Button1Clicked))
                return false;
            if (!HasFocus)
                SetFocus();

            var point = ev.X;
            if (point > fieldLen)
                point = fieldLen;
            if (point < 1)
                point = 1;
            CursorPosition = point;
            AdjCursorPosition();
            return true;
        }

        /// <summary>
        /// Event firing method that invokes the <see cref="TimeChanged"/> event.
        /// </summary>
        /// <param name="args">The event arguments</param>
        public virtual void OnTimeChanged(DateTimeEventArgs<TimeSpan> args)
        {
            TimeChanged?.Invoke(args);
        }
    }
    //=======================================================================
    /// <summary>
    /// Toplevel views can be modally executed. They are used for both an application's main view (filling the entire screen and
    /// for pop-up views such as <see cref="Dialog"/>, <see cref="MessageBox"/>, and <see cref="Wizard"/>.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     Toplevels can be modally executing views, started by calling <see cref="Application.Run(Toplevel, Func{Exception, bool})"/>. 
    ///     They return control to the caller when <see cref="Application.RequestStop(Toplevel)"/> has 
    ///     been called (which sets the <see cref="Toplevel.Running"/> property to <c>false</c>). 
    ///   </para>
    ///   <para>
    ///     A Toplevel is created when an application initializes Terminal.Gui by calling <see cref="Application.Init(ConsoleDriver, IMainLoopDriver)"/>.
    ///     The application Toplevel can be accessed via <see cref="Application.Top"/>. Additional Toplevels can be created 
    ///     and run (e.g. <see cref="Dialog"/>s. To run a Toplevel, create the <see cref="Toplevel"/> and 
    ///     call <see cref="Application.Run(Toplevel, Func{Exception, bool})"/>.
    ///   </para>
    ///   <para>
    ///     Toplevels can also opt-in to more sophisticated initialization
    ///     by implementing <see cref="ISupportInitialize"/>. When they do
    ///     so, the <see cref="ISupportInitialize.BeginInit"/> and
    ///     <see cref="ISupportInitialize.EndInit"/> methods will be called
    ///     before running the view.
    ///     If first-run-only initialization is preferred, the <see cref="ISupportInitializeNotification"/>
    ///     can be implemented too, in which case the <see cref="ISupportInitialize"/>
    ///     methods will only be called if <see cref="ISupportInitializeNotification.IsInitialized"/>
    ///     is <see langword="false"/>. This allows proper <see cref="View"/> inheritance hierarchies
    ///     to override base class layout code optimally by doing so only on first run,
    ///     instead of on every run.
    ///   </para>
    /// </remarks>
    public class Toplevel : View
    {
        /// <summary>
        /// Gets or sets whether the <see cref="MainLoop"/> for this <see cref="Toplevel"/> is running or not. 
        /// </summary>
        /// <remarks>
        ///    Setting this property directly is discouraged. Use <see cref="Application.RequestStop"/> instead. 
        /// </remarks>
        public bool Running { get; set; }

        /// <summary>
        /// Invoked when the Toplevel <see cref="Application.RunState"/> has begun to be loaded.
        /// A Loaded event handler is a good place to finalize initialization before calling 
        /// <see cref="Application.RunLoop(Application.RunState, bool)"/>.
        /// </summary>
        public event Action Loaded;

        /// <summary>
        /// Invoked when the Toplevel <see cref="MainLoop"/> has started it's first iteration.
        /// Subscribe to this event to perform tasks when the <see cref="Toplevel"/> has been laid out and focus has been set.
        /// changes. 
        /// <para>A Ready event handler is a good place to finalize initialization after calling 
        /// <see cref="Application.Run(Func{Exception, bool})"/> on this Toplevel.</para>
        /// </summary>
        public event Action Ready;

        /// <summary>
        /// Invoked when the Toplevel <see cref="Application.RunState"/> has been unloaded.
        /// A Unloaded event handler is a good place to dispose objects after calling <see cref="Application.End(Application.RunState)"/>.
        /// </summary>
        public event Action Unloaded;

        /// <summary>
        /// Invoked when the Toplevel <see cref="Application.RunState"/> becomes the <see cref="Application.Current"/> Toplevel.
        /// </summary>
        public event Action<Toplevel> Activate;

        /// <summary>
        /// Invoked when the Toplevel<see cref="Application.RunState"/> ceases to be the <see cref="Application.Current"/> Toplevel.
        /// </summary>
        public event Action<Toplevel> Deactivate;

        /// <summary>
        /// Invoked when a child of the Toplevel <see cref="Application.RunState"/> is closed by  
        /// <see cref="Application.End(Application.RunState)"/>.
        /// </summary>
        public event Action<Toplevel> ChildClosed;

        /// <summary>
        /// Invoked when the last child of the Toplevel <see cref="Application.RunState"/> is closed from 
        /// by <see cref="Application.End(Application.RunState)"/>.
        /// </summary>
        public event Action AllChildClosed;

        /// <summary>
        /// Invoked when the Toplevel's <see cref="Application.RunState"/> is being closed by  
        /// <see cref="Application.RequestStop(Toplevel)"/>.
        /// </summary>
        public event Action<ToplevelClosingEventArgs> Closing;

        /// <summary>
        /// Invoked when the Toplevel's <see cref="Application.RunState"/> is closed by <see cref="Application.End(Application.RunState)"/>.
        /// </summary>
        public event Action<Toplevel> Closed;

        /// <summary>
        /// Invoked when a child Toplevel's <see cref="Application.RunState"/> has been loaded.
        /// </summary>
        public event Action<Toplevel> ChildLoaded;

        /// <summary>
        /// Invoked when a cjhild Toplevel's <see cref="Application.RunState"/> has been unloaded.
        /// </summary>
        public event Action<Toplevel> ChildUnloaded;

        /// <summary>
        /// Invoked when the terminal has been resized. The new <see cref="Size"/> of the terminal is provided.
        /// </summary>
        public event Action<Size> Resized;

        internal virtual void OnResized(Size size)
        {
            Resized?.Invoke(size);
        }

        internal virtual void OnChildUnloaded(Toplevel top)
        {
            ChildUnloaded?.Invoke(top);
        }

        internal virtual void OnChildLoaded(Toplevel top)
        {
            ChildLoaded?.Invoke(top);
        }

        internal virtual void OnClosed(Toplevel top)
        {
            Closed?.Invoke(top);
        }

        internal virtual bool OnClosing(ToplevelClosingEventArgs ev)
        {
            Closing?.Invoke(ev);
            return ev.Cancel;
        }

        internal virtual void OnAllChildClosed()
        {
            AllChildClosed?.Invoke();
        }

        internal virtual void OnChildClosed(Toplevel top)
        {
            if (IsMdiContainer)
            {
                SetChildNeedsDisplay();
            }
            ChildClosed?.Invoke(top);
        }

        internal virtual void OnDeactivate(Toplevel activated)
        {
            Deactivate?.Invoke(activated);
        }

        internal virtual void OnActivate(Toplevel deactivated)
        {
            Activate?.Invoke(deactivated);
        }

        /// <summary>
        /// Called from <see cref="Application.Begin(Toplevel)"/> before the <see cref="Toplevel"/> redraws for the first time. 
        /// </summary>
        virtual public void OnLoaded()
        {
            foreach (Toplevel tl in Subviews.Where(v => v is Toplevel))
            {
                tl.OnLoaded();
            }
            Loaded?.Invoke();
        }

        /// <summary>
        /// Called from <see cref="Application.RunLoop"/> after the <see cref="Toplevel"/> has entered the 
        /// first iteration of the loop.
        /// </summary>
        internal virtual void OnReady()
        {
            foreach (Toplevel tl in Subviews.Where(v => v is Toplevel))
            {
                tl.OnReady();
            }
            Ready?.Invoke();
        }

        /// <summary>
        /// Called from <see cref="Application.End(Application.RunState)"/> before the <see cref="Toplevel"/> is disposed.
        /// </summary>
        internal virtual void OnUnloaded()
        {
            foreach (Toplevel tl in Subviews.Where(v => v is Toplevel))
            {
                tl.OnUnloaded();
            }
            Unloaded?.Invoke();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Toplevel"/> class with the specified <see cref="LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <param name="frame">A superview-relative rectangle specifying the location and size for the new Toplevel</param>
        public Toplevel(Rect frame) : base(frame)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Toplevel"/> class with <see cref="LayoutStyle.Computed"/> layout, 
        /// defaulting to full screen.
        /// </summary>
        public Toplevel() : base()
        {
            Initialize();
            Width = Dim.Fill();
            Height = Dim.Fill();
        }

        void Initialize()
        {
            ColorScheme = Colors.TopLevel;

            Application.GrabbingMouse += Application_GrabbingMouse;
            Application.UnGrabbingMouse += Application_UnGrabbingMouse;

            // Things this view knows how to do
            AddCommand(Command.QuitToplevel, () => { QuitToplevel(); return true; });
            AddCommand(Command.Suspend, () => { Driver.Suspend(); ; return true; });
            AddCommand(Command.NextView, () => { MoveNextView(); return true; });
            AddCommand(Command.PreviousView, () => { MovePreviousView(); return true; });
            AddCommand(Command.NextViewOrTop, () => { MoveNextViewOrTop(); return true; });
            AddCommand(Command.PreviousViewOrTop, () => { MovePreviousViewOrTop(); return true; });
            AddCommand(Command.Refresh, () => { Application.Refresh(); return true; });

            // Default keybindings for this view
            AddKeyBinding(Application.QuitKey, Command.QuitToplevel);
            AddKeyBinding(Key.Z | Key.CtrlMask, Command.Suspend);

            AddKeyBinding(Key.Tab, Command.NextView);

            AddKeyBinding(Key.CursorRight, Command.NextView);
            AddKeyBinding(Key.F | Key.CtrlMask, Command.NextView);

            AddKeyBinding(Key.CursorDown, Command.NextView);
            AddKeyBinding(Key.I | Key.CtrlMask, Command.NextView); // Unix

            AddKeyBinding(Key.BackTab | Key.ShiftMask, Command.PreviousView);
            AddKeyBinding(Key.CursorLeft, Command.PreviousView);
            AddKeyBinding(Key.CursorUp, Command.PreviousView);
            AddKeyBinding(Key.B | Key.CtrlMask, Command.PreviousView);

            AddKeyBinding(Key.Tab | Key.CtrlMask, Command.NextViewOrTop);
            AddKeyBinding(Application.AlternateForwardKey, Command.NextViewOrTop); // Needed on Unix

            AddKeyBinding(Key.Tab | Key.ShiftMask | Key.CtrlMask, Command.PreviousViewOrTop);
            AddKeyBinding(Application.AlternateBackwardKey, Command.PreviousViewOrTop); // Needed on Unix

            AddKeyBinding(Key.L | Key.CtrlMask, Command.Refresh);
        }

        private bool Application_UnGrabbingMouse(View e)
        {
            if (dragPosition.HasValue)
            {
                return true;
            }

            return false;
        }

        private bool Application_GrabbingMouse(View e)
        {
            if (Application.MouseGrabView == this && dragPosition.HasValue)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Invoked when the <see cref="Application.AlternateForwardKey"/> is changed.
        /// </summary>
        public event Action<Key> AlternateForwardKeyChanged;

        /// <summary>
        /// Virtual method to invoke the <see cref="AlternateForwardKeyChanged"/> event.
        /// </summary>
        /// <param name="oldKey"></param>
        public virtual void OnAlternateForwardKeyChanged(Key oldKey)
        {
            ReplaceKeyBinding(oldKey, Application.AlternateForwardKey);
            AlternateForwardKeyChanged?.Invoke(oldKey);
        }

        /// <summary>
        /// Invoked when the <see cref="Application.AlternateBackwardKey"/> is changed.
        /// </summary>
        public event Action<Key> AlternateBackwardKeyChanged;

        /// <summary>
        /// Virtual method to invoke the <see cref="AlternateBackwardKeyChanged"/> event.
        /// </summary>
        /// <param name="oldKey"></param>
        public virtual void OnAlternateBackwardKeyChanged(Key oldKey)
        {
            ReplaceKeyBinding(oldKey, Application.AlternateBackwardKey);
            AlternateBackwardKeyChanged?.Invoke(oldKey);
        }

        /// <summary>
        /// Invoked when the <see cref="Application.QuitKey"/> is changed.
        /// </summary>
        public event Action<Key> QuitKeyChanged;

        /// <summary>
        /// Virtual method to invoke the <see cref="QuitKeyChanged"/> event.
        /// </summary>
        /// <param name="oldKey"></param>
        public virtual void OnQuitKeyChanged(Key oldKey)
        {
            ReplaceKeyBinding(oldKey, Application.QuitKey);
            QuitKeyChanged?.Invoke(oldKey);
        }

        /// <summary>
        /// Convenience factory method that creates a new Toplevel with the current terminal dimensions.
        /// </summary>
        /// <returns>The created Toplevel.</returns>
        public static Toplevel Create()
        {
            return new Toplevel(new Rect(0, 0, Driver.Cols, Driver.Rows));
        }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="Toplevel"/> can focus.
        /// </summary>
        /// <value><c>true</c> if can focus; otherwise, <c>false</c>.</value>
        public override bool CanFocus
        {
            get => SuperView == null ? true : base.CanFocus;
        }

        /// <summary>
        /// Determines whether the <see cref="Toplevel"/> is modal or not. 
        /// If set to <c>false</c> (the default):
        /// 
        /// <list type="bullet">
        ///   <item>
        ///		<description><see cref="ProcessKey(KeyEvent)"/> events will propagate keys upwards.</description>
        ///   </item>
        ///   <item>
        ///		<description>The Toplevel will act as an embedded view (not a modal/pop-up).</description>
        ///   </item>
        /// </list>
        ///
        /// If set to <c>true</c>:
        /// 
        /// <list type="bullet">
        ///   <item>
        ///		<description><see cref="ProcessKey(KeyEvent)"/> events will NOT propogate keys upwards.</description>
        ///	  </item>
        ///   <item>
        ///		<description>The Toplevel will and look like a modal (pop-up) (e.g. see <see cref="Dialog"/>.</description>
        ///   </item>
        /// </list>
        /// </summary>
        public bool Modal { get; set; }

        /// <summary>
        /// Gets or sets the menu for this Toplevel.
        /// </summary>
        public virtual MenuBar MenuBar { get; set; }

        /// <summary>
        /// Gets or sets the status bar for this Toplevel.
        /// </summary>
        public virtual StatusBar StatusBar { get; set; }

        /// <summary>
        /// Gets or sets if this Toplevel is a Mdi container.
        /// </summary>
        public bool IsMdiContainer { get; set; }

        /// <summary>
        /// Gets or sets if this Toplevel is a Mdi child.
        /// </summary>
        public bool IsMdiChild
        {
            get
            {
                return Application.MdiTop != null && Application.MdiTop != this && !Modal;
            }
        }

        ///<inheritdoc/>
        public override bool OnKeyDown(KeyEvent keyEvent)
        {
            if (base.OnKeyDown(keyEvent))
            {
                return true;
            }

            switch (keyEvent.Key)
            {
                case Key.AltMask:
                case Key.AltMask | Key.Space:
                case Key.CtrlMask | Key.Space:
                case Key _ when (keyEvent.Key & Key.AltMask) == Key.AltMask:
                    return MenuBar != null && MenuBar.OnKeyDown(keyEvent);
            }

            return false;
        }

        ///<inheritdoc/>
        public override bool OnKeyUp(KeyEvent keyEvent)
        {
            if (base.OnKeyUp(keyEvent))
            {
                return true;
            }

            switch (keyEvent.Key)
            {
                case Key.AltMask:
                case Key.AltMask | Key.Space:
                case Key.CtrlMask | Key.Space:
                    if (MenuBar != null && MenuBar.OnKeyUp(keyEvent))
                    {
                        return true;
                    }
                    break;
            }

            return false;
        }

        ///<inheritdoc/>
        public override bool ProcessKey(KeyEvent keyEvent)
        {
            if (base.ProcessKey(keyEvent))
                return true;

            var result = InvokeKeybindings(new KeyEvent(ShortcutHelper.GetModifiersKey(keyEvent),
                new KeyModifiers() { Alt = keyEvent.IsAlt, Ctrl = keyEvent.IsCtrl, Shift = keyEvent.IsShift }));
            if (result != null)
                return (bool)result;

#if false
			if (keyEvent.Key == Key.F5) {
				Application.DebugDrawBounds = !Application.DebugDrawBounds;
				SetNeedsDisplay ();
				return true;
			}
#endif
            return false;
        }

        ///<inheritdoc/>
        public override bool ProcessHotKey(KeyEvent keyEvent)
        {
            if (base.ProcessHotKey(keyEvent))
            {
                return true;
            }

            if (this.IsMdiChild && Application.Top.ProcessHotKey(keyEvent))
            {
                return true;
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool ProcessColdKey(KeyEvent keyEvent)
        {
            if (base.ProcessColdKey(keyEvent))
            {
                return true;
            }

            if (ShortcutHelper.FindAndOpenByShortcut(keyEvent, this))
            {
                return true;
            }
            return false;
        }

        private void MovePreviousViewOrTop()
        {
            if (Application.MdiTop == null)
            {
                var top = Modal ? this : Application.Top;
                top.FocusPrev();
                if (top.Focused == null)
                {
                    top.FocusPrev();
                }
                top.SetNeedsDisplay();
                Application.EnsuresTopOnFront();
            }
            else
            {
                MovePrevious();
            }
        }

        private void MoveNextViewOrTop()
        {
            if (Application.MdiTop == null)
            {
                var top = Modal ? this : Application.Top;
                top.FocusNext();
                if (top.Focused == null)
                {
                    top.FocusNext();
                }
                top.SetNeedsDisplay();
                Application.EnsuresTopOnFront();
            }
            else
            {
                MoveNext();
            }
        }

        private void MovePreviousView()
        {
            var old = GetDeepestFocusedSubview(Focused);
            if (!FocusPrev())
                FocusPrev();
            if (old != Focused && old != Focused?.Focused)
            {
                old?.SetNeedsDisplay();
                Focused?.SetNeedsDisplay();
            }
            else
            {
                FocusNearestView(SuperView?.TabIndexes?.Reverse(), Direction.Backward);
            }
        }

        private void MoveNextView()
        {
            var old = GetDeepestFocusedSubview(Focused);
            if (!FocusNext())
                FocusNext();
            if (old != Focused && old != Focused?.Focused)
            {
                old?.SetNeedsDisplay();
                Focused?.SetNeedsDisplay();
            }
            else
            {
                FocusNearestView(SuperView?.TabIndexes, Direction.Forward);
            }
        }

        private void QuitToplevel()
        {
            if (IsMdiChild)
            {
                RequestStop();
            }
            else if (Application.MdiTop != null)
            {
                Application.MdiTop.RequestStop();
            }
            else
            {
                Application.RequestStop();
            }
        }

        View GetDeepestFocusedSubview(View view)
        {
            if (view == null)
            {
                return null;
            }

            foreach (var v in view.Subviews)
            {
                if (v.HasFocus)
                {
                    return GetDeepestFocusedSubview(v);
                }
            }
            return view;
        }

        void FocusNearestView(IEnumerable<View> views, Direction direction)
        {
            if (views == null)
            {
                return;
            }

            bool found = false;
            bool focusProcessed = false;
            int idx = 0;

            foreach (var v in views)
            {
                if (v == this)
                {
                    found = true;
                }
                if (found && v != this)
                {
                    if (direction == Direction.Forward)
                    {
                        SuperView?.FocusNext();
                    }
                    else
                    {
                        SuperView?.FocusPrev();
                    }
                    focusProcessed = true;
                    if (SuperView.Focused != null && SuperView.Focused != this)
                    {
                        return;
                    }
                }
                else if (found && !focusProcessed && idx == views.Count() - 1)
                {
                    views.ToList()[0].SetFocus();
                }
                idx++;
            }
        }

        ///<inheritdoc/>
        public override void Add(View view)
        {
            CanFocus = true;
            AddMenuStatusBar(view);
            base.Add(view);
        }

        internal void AddMenuStatusBar(View view)
        {
            if (view is MenuBar)
            {
                MenuBar = view as MenuBar;
            }
            if (view is StatusBar)
            {
                StatusBar = view as StatusBar;
            }
        }

        ///<inheritdoc/>
        public override void Remove(View view)
        {
            if (this is Toplevel toplevel && toplevel.MenuBar != null)
            {
                RemoveMenuStatusBar(view);
            }
            base.Remove(view);
        }

        ///<inheritdoc/>
        public override void RemoveAll()
        {
            if (this == Application.Top)
            {
                MenuBar?.Dispose();
                MenuBar = null;
                StatusBar?.Dispose();
                StatusBar = null;
            }
            base.RemoveAll();
        }

        internal void RemoveMenuStatusBar(View view)
        {
            if (view is MenuBar)
            {
                MenuBar?.Dispose();
                MenuBar = null;
            }
            if (view is StatusBar)
            {
                StatusBar?.Dispose();
                StatusBar = null;
            }
        }

        internal View EnsureVisibleBounds(Toplevel top, int x, int y,
            out int nx, out int ny, out View mb, out View sb)
        {
            int l;
            View superView = GetSuperView(top);
            if (superView == null || top == Application.Top || superView == Application.Top)
            {
                l = Driver.Cols;
                superView = Application.Top;
            }
            else
            {
                l = superView.Frame.Width;
            }
            mb = null; sb = null;
            if (!(superView is Toplevel))
            {
                nx = Math.Max(Math.Min(x, top.Frame.Right - 1), 0);
                ny = Math.Max(Math.Min(y, top.Frame.Bottom - 1), 0);
                return superView;
            }
            var superViewBorder = superView.Border != null ? (superView.Border.DrawMarginFrame ? 1 : 0) : 0;
            var topBorder = top.Modal ? 0 : top.Border != null ? (top.Border.DrawMarginFrame ? 1 : 0) : 0;
            nx = Math.Max(x, 0);
            nx = !top.IsMdiChild && !top.Modal && nx + superViewBorder * 2 + top.Frame.Width >= l ? Math.Max(l - top.Frame.Width - superViewBorder * 2, 0) : nx;
            nx = top.Modal && nx == 0 ? superViewBorder : nx;
            nx = top.IsMdiChild && nx < superViewBorder ? superViewBorder : nx;
            nx = top.Modal && nx + superViewBorder + top.Frame.Width >= l ? l - top.Frame.Width - superViewBorder : nx;
            nx = top.IsMdiChild && nx + superViewBorder + top.Frame.Width >= l ? l - top.Frame.Width - superViewBorder : nx;
            if (nx + topBorder * 2 > top.Frame.X + top.Frame.Width)
            {
                nx = Math.Max(top.Frame.Right - topBorder * 2, 0);
            }
            //System.Diagnostics.Debug.WriteLine ($"nx:{nx}, rWidth:{rWidth}");
            bool m = false, s = false;
            if (!(top is Window && top == Application.Top) && (superView == null || top == Application.Top || superView == Application.Top))
            {
                m = Application.Top.MenuBar?.Visible == true;
                mb = Application.Top.MenuBar;
            }
            else if (!(top is Window && top == Application.Top))
            {
                var t = superView;
                while (!(t is Toplevel))
                {
                    t = GetSuperView(t);
                }
                m = ((Toplevel)t).MenuBar?.Visible == true;
                mb = ((Toplevel)t).MenuBar;
            }
            if (superView == null || top == Application.Top || superView == Application.Top)
            {
                l = m ? 1 + (top.Modal ? superViewBorder - topBorder : 0) : 0;
            }
            else
            {
                l = 0;
            }
            ny = Math.Max(y, l);
            ny = top.Modal && ny == 0 ? superViewBorder : ny;
            ny = top.IsMdiChild && ny < superViewBorder + l ? ny + superViewBorder : ny;
            if (!(top is Window && top == Application.Top) && (superView == null || top == Application.Top || superView == Application.Top))
            {
                s = Application.Top.StatusBar?.Visible == true;
                sb = Application.Top.StatusBar;
            }
            else if (!(top is Window && top == Application.Top))
            {
                var t = superView;
                while (!(t is Toplevel))
                {
                    t = GetSuperView(t);
                }
                s = ((Toplevel)t).StatusBar?.Visible == true;
                sb = ((Toplevel)t).StatusBar;
            }
            if (superView == null || top == Application.Top || superView == Application.Top)
            {
                l = (s ? Driver.Rows - 1 : Driver.Rows);
            }
            else
            {
                l = (s ? superView.Frame.Height - 1 : superView.Frame.Height);
            }
            ny = Math.Min(ny, l);
            ny = !top.IsMdiChild && !top.Modal && ny + superViewBorder * 2 + top.Frame.Height >= l ? Math.Max(l - top.Frame.Height - superViewBorder * 2, m ? 1 : 0) : ny;
            ny = top.Modal && ny + superViewBorder * 2 + top.Frame.Height >= l ? l - top.Frame.Height - superViewBorder : ny;
            ny = top.IsMdiChild && ny + superViewBorder + top.Frame.Height >= l ? Math.Max(l - top.Frame.Height - superViewBorder, m ? 1 : 0) : ny;
            if (ny + topBorder * 2 > top.Frame.Y + top.Frame.Height)
            {
                ny = Math.Max(top.Frame.Bottom - topBorder * 2, 0);
            }
            //System.Diagnostics.Debug.WriteLine ($"ny:{ny}, rHeight:{rHeight}");

            if (superView != null && superView == top && superView == Application.Top)
            {
                nx = superView.Frame.X; ny = superView.Frame.Y;
            }

            return superView;
        }

        View GetSuperView(View view)
        {
            if (view.SuperView == null)
            {
                return Application.Top;
            }
            var superView = view.SuperView;
            if (superView.GetType().Name == "ContentView")
            {
                return superView.SuperView;
            }
            return superView;
        }

        internal void PositionToplevels()
        {
            PositionToplevel(this);
            foreach (var top in Subviews)
            {
                if (top is Toplevel)
                {
                    PositionToplevel((Toplevel)top);
                }
                else if (top.GetType().Name == "ContentView")
                {
                    foreach (var subTop in top.Subviews.Where(v => v is Toplevel))
                    {
                        PositionToplevel((Toplevel)subTop);
                    }
                }
            }
        }

        /// <summary>
        /// Virtual method enabling implementation of specific positions for inherited <see cref="Toplevel"/> views.
        /// </summary>
        /// <param name="top">The toplevel.</param>
        public virtual void PositionToplevel(Toplevel top)
        {
            var superView = EnsureVisibleBounds(top, top.Frame.X, top.Frame.Y,
                out int nx, out int ny, out _, out View sb);
            if (superView != null && superView == top && superView == Application.Top)
            {
                return;
            }
            bool layoutSubviews = false;
            if ((superView != null || (top != Application.Top && top.Modal)
                || (superView == null && top.IsMdiChild))
                && (nx != top.Frame.X || ny != top.Frame.Y) && top.LayoutStyle == LayoutStyle.Computed)
            {

                if ((top.X == null || top.X is Pos.PosAbsolute) && top.Frame.X != nx)
                {
                    top.X = nx;
                    layoutSubviews = true;
                }
                if ((top.Y == null || top.Y is Pos.PosAbsolute) && top.Frame.Y != ny)
                {
                    top.Y = ny;
                    layoutSubviews = true;
                }
            }

            if (sb != null && ny + top.Frame.Height != superView.Frame.Height - (sb.Visible ? 1 : 0)
                && top.Height is Dim.DimFill && -top.Height.Anchor(0) < 1)
            {

                top.Height = Dim.Fill(sb.Visible ? 1 : 0);
                layoutSubviews = true;
            }

            if (layoutSubviews)
            {
                superView.LayoutSubviews();
            }
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            if (!Visible)
            {
                return;
            }

            if (!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded)
            {
                Driver.SetAttribute(GetNormalColor());

                // This is the Application.Top. Clear just the region we're being asked to redraw 
                // (the bounds passed to us).
                Clear();
                Driver.SetAttribute(Enabled ? Colors.Base.Normal : Colors.Base.Disabled);

                LayoutSubviews();
                PositionToplevels();

                if (this == Application.MdiTop)
                {
                    foreach (var top in Application.MdiChildes.AsEnumerable().Reverse())
                    {
                        if (top.Frame.IntersectsWith(bounds))
                        {
                            if (top != this && !top.IsCurrentTop && !OutsideTopFrame(top) && top.Visible)
                            {
                                top.SetNeedsLayout();
                                top.SetNeedsDisplay(top.Bounds);
                                top.Redraw(top.Bounds);
                            }
                        }
                    }
                }

                foreach (var view in Subviews)
                {
                    if (view.Frame.IntersectsWith(bounds) && !OutsideTopFrame(this))
                    {
                        view.SetNeedsLayout();
                        view.SetNeedsDisplay(view.Bounds);
                        //view.Redraw (view.Bounds);
                    }
                }

                ClearLayoutNeeded();
                ClearNeedsDisplay();
            }

            base.Redraw(Bounds);
        }

        internal bool OutsideTopFrame(Toplevel top)
        {
            if (top.Frame.X > Driver.Cols || top.Frame.Y > Driver.Rows)
            {
                return true;
            }
            return false;
        }

        internal static Point? dragPosition;
        Point start;

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent mouseEvent)
        {
            if (!CanFocus)
            {
                return true;
            }

            //System.Diagnostics.Debug.WriteLine ($"dragPosition before: {dragPosition.HasValue}");

            int nx, ny;
            if (!dragPosition.HasValue && (mouseEvent.Flags == MouseFlags.Button1Pressed
                || mouseEvent.Flags == MouseFlags.Button2Pressed
                || mouseEvent.Flags == MouseFlags.Button3Pressed))
            {

                SetFocus();
                Application.EnsuresTopOnFront();

                // Only start grabbing if the user clicks on the title bar.
                if (mouseEvent.Y == 0 && mouseEvent.Flags == MouseFlags.Button1Pressed)
                {
                    start = new Point(mouseEvent.X, mouseEvent.Y);
                    Application.GrabMouse(this);
                    nx = mouseEvent.X - mouseEvent.OfX;
                    ny = mouseEvent.Y - mouseEvent.OfY;
                    dragPosition = new Point(nx, ny);
                }

                //System.Diagnostics.Debug.WriteLine ($"Starting at {dragPosition}");
                return true;
            }
            else if (mouseEvent.Flags == (MouseFlags.Button1Pressed | MouseFlags.ReportMousePosition) ||
              mouseEvent.Flags == MouseFlags.Button3Pressed)
            {
                if (dragPosition.HasValue)
                {
                    if (SuperView == null)
                    {
                        // Redraw the entire app window using just our Frame. Since we are 
                        // Application.Top, and our Frame always == our Bounds (Location is always (0,0))
                        // our Frame is actually view-relative (which is what Redraw takes).
                        // We need to pass all the view bounds because since the windows was 
                        // moved around, we don't know exactly what was the affected region.
                        Application.Top.SetNeedsDisplay();
                    }
                    else
                    {
                        SuperView.SetNeedsDisplay();
                    }
                    EnsureVisibleBounds(this, mouseEvent.X + (SuperView == null ? mouseEvent.OfX - start.X : Frame.X - start.X),
                        mouseEvent.Y + (SuperView == null ? mouseEvent.OfY - start.Y : Frame.Y - start.Y),
                        out nx, out ny, out _, out _);

                    dragPosition = new Point(nx, ny);
                    X = nx;
                    Y = ny;
                    //System.Diagnostics.Debug.WriteLine ($"Drag: nx:{nx},ny:{ny}");

                    SetNeedsDisplay();
                    return true;
                }
            }

            if (mouseEvent.Flags.HasFlag(MouseFlags.Button1Released) && dragPosition.HasValue)
            {
                dragPosition = null;
                Application.UngrabMouse();
            }

            //System.Diagnostics.Debug.WriteLine ($"dragPosition after: {dragPosition.HasValue}");
            //System.Diagnostics.Debug.WriteLine ($"Toplevel: {mouseEvent}");
            return false;
        }

        /// <summary>
        /// Invoked by <see cref="Application.Begin"/> as part of  <see cref="Application.Run(Toplevel, Func{Exception, bool})"/> 
        /// after the views have been laid out, and before the views are drawn for the first time.
        /// </summary>
        public virtual void WillPresent()
        {
            FocusFirst();
        }

        /// <summary>
        /// Move to the next Mdi child from the <see cref="Application.MdiTop"/>.
        /// </summary>
        public virtual void MoveNext()
        {
            Application.MoveNext();
        }

        /// <summary>
        /// Move to the previous Mdi child from the <see cref="Application.MdiTop"/>.
        /// </summary>
        public virtual void MovePrevious()
        {
            Application.MovePrevious();
        }

        /// <summary>
        /// Stops and closes this <see cref="Toplevel"/>. If this Toplevel is the top-most Toplevel, 
        /// <see cref="Application.RequestStop(Toplevel)"/> will be called, causing the application to exit.
        /// </summary>
        public virtual void RequestStop()
        {
            if (IsMdiContainer && Running
                && (Application.Current == this
                || Application.Current?.Modal == false
                || Application.Current?.Modal == true && Application.Current?.Running == false))
            {

                foreach (var child in Application.MdiChildes)
                {
                    var ev = new ToplevelClosingEventArgs(this);
                    if (child.OnClosing(ev))
                    {
                        return;
                    }
                    child.Running = false;
                    Application.RequestStop(child);
                }
                Running = false;
                Application.RequestStop(this);
            }
            else if (IsMdiContainer && Running && Application.Current?.Modal == true && Application.Current?.Running == true)
            {
                var ev = new ToplevelClosingEventArgs(Application.Current);
                if (OnClosing(ev))
                {
                    return;
                }
                Application.RequestStop(Application.Current);
            }
            else if (!IsMdiContainer && Running && (!Modal || (Modal && Application.Current != this)))
            {
                var ev = new ToplevelClosingEventArgs(this);
                if (OnClosing(ev))
                {
                    return;
                }
                Running = false;
                Application.RequestStop(this);
            }
            else
            {
                Application.RequestStop(Application.Current);
            }
        }

        /// <summary>
        /// Stops and closes the <see cref="Toplevel"/> specified by <paramref name="top"/>. If <paramref name="top"/> is the top-most Toplevel, 
        /// <see cref="Application.RequestStop(Toplevel)"/> will be called, causing the application to exit.
        /// </summary>
        /// <param name="top">The toplevel to request stop.</param>
        public virtual void RequestStop(Toplevel top)
        {
            top.RequestStop();
        }

        ///<inheritdoc/>
        public override void PositionCursor()
        {
            if (!IsMdiContainer)
            {
                base.PositionCursor();
                if (Focused == null)
                {
                    EnsureFocus();
                    if (Focused == null)
                    {
                        Driver.SetCursorVisibility(CursorVisibility.Invisible);
                    }
                }
                return;
            }

            if (Focused == null)
            {
                foreach (var top in Application.MdiChildes)
                {
                    if (top != this && top.Visible)
                    {
                        top.SetFocus();
                        return;
                    }
                }
            }
            base.PositionCursor();
            if (Focused == null)
            {
                Driver.SetCursorVisibility(CursorVisibility.Invisible);
            }
        }

        /// <summary>
        /// Gets the current visible Toplevel Mdi child that matches the arguments pattern.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="exclude">The strings to exclude.</param>
        /// <returns>The matched view.</returns>
        public View GetTopMdiChild(Type type = null, string[] exclude = null)
        {
            if (Application.MdiTop == null)
            {
                return null;
            }

            foreach (var top in Application.MdiChildes)
            {
                if (type != null && top.GetType() == type
                    && exclude?.Contains(top.Data.ToString()) == false)
                {
                    return top;
                }
                else if ((type != null && top.GetType() != type)
                  || (exclude?.Contains(top.Data.ToString()) == true))
                {
                    continue;
                }
                return top;
            }
            return null;
        }

        /// <summary>
        /// Shows the Mdi child indicated by <paramref name="top"/>, setting it as <see cref="Application.Current"/>.
        /// </summary>
        /// <param name="top">The Toplevel.</param>
        /// <returns><c>true</c> if the toplevel can be shown or <c>false</c> if not.</returns>
        public virtual bool ShowChild(Toplevel top = null)
        {
            if (Application.MdiTop != null)
            {
                return Application.ShowChild(top == null ? this : top);
            }
            return false;
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            return MostFocused?.OnEnter(view) ?? base.OnEnter(view);
        }

        ///<inheritdoc/>
        public override bool OnLeave(View view)
        {
            return MostFocused?.OnLeave(view) ?? base.OnLeave(view);
        }

        ///<inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            Application.GrabbingMouse -= Application_GrabbingMouse;
            Application.UnGrabbingMouse -= Application_UnGrabbingMouse;

            dragPosition = null;
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// Implements the <see cref="IEqualityComparer{T}"/> for comparing two <see cref="Toplevel"/>s
    /// used by <see cref="StackExtensions"/>.
    /// </summary>
    public class ToplevelEqualityComparer : IEqualityComparer<Toplevel>
    {
        /// <summary>Determines whether the specified objects are equal.</summary>
        /// <param name="x">The first object of type <see cref="Toplevel" /> to compare.</param>
        /// <param name="y">The second object of type <see cref="Toplevel" /> to compare.</param>
        /// <returns>
        ///     <see langword="true" /> if the specified objects are equal; otherwise, <see langword="false" />.</returns>
        public bool Equals(Toplevel x, Toplevel y)
        {
            if (y == null && x == null)
                return true;
            else if (x == null || y == null)
                return false;
            else if (x.Id == y.Id)
                return true;
            else
                return false;
        }

        /// <summary>Returns a hash code for the specified object.</summary>
        /// <param name="obj">The <see cref="Toplevel" /> for which a hash code is to be returned.</param>
        /// <returns>A hash code for the specified object.</returns>
        /// <exception cref="ArgumentNullException">The type of <paramref name="obj" /> 
        /// is a reference type and <paramref name="obj" /> is <see langword="null" />.</exception>
        public int GetHashCode(Toplevel obj)
        {
            if (obj == null)
                throw new ArgumentNullException();

            int hCode = 0;
            if (int.TryParse(obj.Id.ToString(), out int result))
            {
                hCode = result;
            }
            return hCode.GetHashCode();
        }
    }

    /// <summary>
    /// Implements the <see cref="IComparer{T}"/> to sort the <see cref="Toplevel"/> 
    /// from the <see cref="Application.MdiChildes"/> if needed.
    /// </summary>
    public sealed class ToplevelComparer : IComparer<Toplevel>
    {
        /// <summary>Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.</summary>
        /// <param name="x">The first object to compare.</param>
        /// <param name="y">The second object to compare.</param>
        /// <returns>A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />, as shown in the following table.Value Meaning Less than zero
        ///             <paramref name="x" /> is less than <paramref name="y" />.Zero
        ///             <paramref name="x" /> equals <paramref name="y" />.Greater than zero
        ///             <paramref name="x" /> is greater than <paramref name="y" />.</returns>
        public int Compare(Toplevel x, Toplevel y)
        {
            if (ReferenceEquals(x, y))
                return 0;
            else if (x == null)
                return -1;
            else if (y == null)
                return 1;
            else
                return string.Compare(x.Id.ToString(), y.Id.ToString());
        }
    }
    /// <summary>
    /// <see cref="EventArgs"/> implementation for the <see cref="Toplevel.Closing"/> event.
    /// </summary>
    public class ToplevelClosingEventArgs : EventArgs
    {
        /// <summary>
        /// The toplevel requesting stop.
        /// </summary>
        public View RequestingTop { get; }
        /// <summary>
        /// Provides an event cancellation option.
        /// </summary>
        public bool Cancel { get; set; }

        /// <summary>
        /// Initializes the event arguments with the requesting toplevel.
        /// </summary>
        /// <param name="requestingTop">The <see cref="RequestingTop"/>.</param>
        public ToplevelClosingEventArgs(Toplevel requestingTop)
        {
            RequestingTop = requestingTop;
        }
    }
    //=======================================================================
    // This code is based on http://objectlistview.sourceforge.net (GPLv3 tree/list controls 
    // by phillip.piper@gmail.com). Phillip has explicitly granted permission for his design
    // and code to be used in this library under the MIT license.

    /// <summary>
    /// Interface for all non generic members of <see cref="TreeView{T}"/>.
    /// 
    /// <a href="https://gui-cs.github.io/Terminal.Gui/articles/treeview.html">See TreeView Deep Dive for more information</a>.
    /// </summary>
    public interface ITreeView
    {
        /// <summary>
        /// Contains options for changing how the tree is rendered.
        /// </summary>
        TreeStyle Style { get; set; }

        /// <summary>
        /// Removes all objects from the tree and clears selection.
        /// </summary>
        void ClearObjects();

        /// <summary>
        /// Sets a flag indicating this view needs to be redisplayed because its state has changed.
        /// </summary>
        void SetNeedsDisplay();
    }

    /// <summary>
    /// Convenience implementation of generic <see cref="TreeView{T}"/> for any tree were all nodes
    /// implement <see cref="ITreeNode"/>.
    /// 
    /// <a href="https://gui-cs.github.io/Terminal.Gui/articles/treeview.html">See TreeView Deep Dive for more information</a>.
    /// </summary>
    public class TreeView : TreeView<ITreeNode>
    {

        /// <summary>
        /// Creates a new instance of the tree control with absolute positioning and initialises
        /// <see cref="TreeBuilder{T}"/> with default <see cref="ITreeNode"/> based builder.
        /// </summary>
        public TreeView()
        {
            TreeBuilder = new TreeNodeBuilder();
            AspectGetter = o => o == null ? "Null" : (o.Text ?? o?.ToString() ?? "Unamed Node");
        }
    }

    /// <summary>
    /// Hierarchical tree view with expandable branches. Branch objects are dynamically determined
    /// when expanded using a user defined <see cref="ITreeBuilder{T}"/>.
    /// 
    /// <a href="https://gui-cs.github.io/Terminal.Gui/articles/treeview.html">See TreeView Deep Dive for more information</a>.
    /// </summary>
    public class TreeView<T> : View, ITreeView where T : class
    {
        private int scrollOffsetVertical;
        private int scrollOffsetHorizontal;

        /// <summary>
        /// Determines how sub branches of the tree are dynamically built at runtime as the user
        /// expands root nodes.
        /// </summary>
        /// <value></value>
        public ITreeBuilder<T> TreeBuilder { get; set; }

        /// <summary>
        /// private variable for <see cref="SelectedObject"/>
        /// </summary>
        T selectedObject;

        /// <summary>
        /// Contains options for changing how the tree is rendered.
        /// </summary>
        public TreeStyle Style { get; set; } = new TreeStyle();

        /// <summary>
        /// True to allow multiple objects to be selected at once.
        /// </summary>
        /// <value></value>
        public bool MultiSelect { get; set; } = true;

        /// <summary>
        /// Maximum number of nodes that can be expanded in any given branch.
        /// </summary>
        public int MaxDepth { get; set; } = 100;

        /// <summary>
        /// True makes a letter key press navigate to the next visible branch that begins with
        /// that letter/digit.
        /// </summary>
        /// <value></value>
        public bool AllowLetterBasedNavigation { get; set; } = true;

        /// <summary>
        /// The currently selected object in the tree. When <see cref="MultiSelect"/> is true this
        /// is the object at which the cursor is at.
        /// </summary>
        public T SelectedObject
        {
            get => selectedObject;
            set
            {
                var oldValue = selectedObject;
                selectedObject = value;

                if (!ReferenceEquals(oldValue, value))
                {
                    OnSelectionChanged(new SelectionChangedEventArgs<T>(this, oldValue, value));
                }
            }
        }

        /// <summary>
        /// This event is raised when an object is activated e.g. by double clicking or 
        /// pressing <see cref="ObjectActivationKey"/>.
        /// </summary>
        public event Action<ObjectActivatedEventArgs<T>> ObjectActivated;

        /// <summary>
        /// Key which when pressed triggers <see cref="TreeView{T}.ObjectActivated"/>.
        /// Defaults to Enter.
        /// </summary>
        public Key ObjectActivationKey
        {
            get => objectActivationKey;
            set
            {
                if (objectActivationKey != value)
                {
                    ReplaceKeyBinding(ObjectActivationKey, value);
                    objectActivationKey = value;
                }
            }
        }

        /// <summary>
        /// Mouse event to trigger <see cref="TreeView{T}.ObjectActivated"/>.
        /// Defaults to double click (<see cref="MouseFlags.Button1DoubleClicked"/>).
        /// Set to null to disable this feature.
        /// </summary>
        /// <value></value>
        public MouseFlags? ObjectActivationButton { get; set; } = MouseFlags.Button1DoubleClicked;

        /// <summary>
        /// Delegate for multi colored tree views. Return the <see cref="ColorScheme"/> to use
        /// for each passed object or null to use the default.
        /// </summary>
        public Func<T, ColorScheme> ColorGetter { get; set; }

        /// <summary>
        /// Secondary selected regions of tree when <see cref="MultiSelect"/> is true.
        /// </summary>
        private Stack<TreeSelection<T>> multiSelectedRegions = new Stack<TreeSelection<T>>();

        /// <summary>
        /// Cached result of <see cref="BuildLineMap"/>
        /// </summary>
        private IReadOnlyCollection<Branch<T>> cachedLineMap;

        /// <summary>
        /// Error message to display when the control is not properly initialized at draw time 
        /// (nodes added but no tree builder set).
        /// </summary>
        public static ustring NoBuilderError = "ERROR: TreeBuilder Not Set";
        private Key objectActivationKey = Key.Enter;

        /// <summary>
        /// Called when the <see cref="SelectedObject"/> changes.
        /// </summary>
        public event EventHandler<SelectionChangedEventArgs<T>> SelectionChanged;

        /// <summary>
        /// The root objects in the tree, note that this collection is of root objects only.
        /// </summary>
        public IEnumerable<T> Objects { get => roots.Keys; }

        /// <summary>
        /// Map of root objects to the branches under them. All objects have 
        /// a <see cref="Branch{T}"/> even if that branch has no children.
        /// </summary>
        internal Dictionary<T, Branch<T>> roots { get; set; } = new Dictionary<T, Branch<T>>();

        /// <summary>
        /// The amount of tree view that has been scrolled off the top of the screen (by the user 
        /// scrolling down).
        /// </summary>
        /// <remarks>Setting a value of less than 0 will result in a offset of 0. To see changes 
        /// in the UI call <see cref="View.SetNeedsDisplay()"/>.</remarks>
        public int ScrollOffsetVertical
        {
            get => scrollOffsetVertical;
            set
            {
                scrollOffsetVertical = Math.Max(0, value);
            }
        }

        /// <summary>
        /// The amount of tree view that has been scrolled to the right (horizontally).
        /// </summary>
        /// <remarks>Setting a value of less than 0 will result in a offset of 0. To see changes 
        /// in the UI call <see cref="View.SetNeedsDisplay()"/>.</remarks>
        public int ScrollOffsetHorizontal
        {
            get => scrollOffsetHorizontal;
            set
            {
                scrollOffsetHorizontal = Math.Max(0, value);
            }
        }

        /// <summary>
        /// The current number of rows in the tree (ignoring the controls bounds).
        /// </summary>
        public int ContentHeight => BuildLineMap().Count();

        /// <summary>
        /// Returns the string representation of model objects hosted in the tree. Default 
        /// implementation is to call <see cref="object.ToString"/>.
        /// </summary>
        /// <value></value>
        public AspectGetterDelegate<T> AspectGetter { get; set; } = (o) => o.ToString() ?? "";

        CursorVisibility desiredCursorVisibility = CursorVisibility.Invisible;

        /// <summary>
        /// Interface for filtering which lines of the tree are displayed
        ///  e.g. to provide text searching.  Defaults to <see langword="null"/>
        /// (no filtering).
        /// </summary>
        public ITreeViewFilter<T> Filter = null;

        /// <summary>
        /// Get / Set the wished cursor when the tree is focused.
        /// Only applies when <see cref="MultiSelect"/> is true.
        /// Defaults to <see cref="CursorVisibility.Invisible"/>.
        /// </summary>
        public CursorVisibility DesiredCursorVisibility
        {
            get
            {
                return MultiSelect ? desiredCursorVisibility : CursorVisibility.Invisible;
            }
            set
            {
                if (desiredCursorVisibility != value)
                {
                    desiredCursorVisibility = value;
                    if (HasFocus)
                    {
                        Application.Driver.SetCursorVisibility(DesiredCursorVisibility);
                    }
                }
            }
        }

        /// <summary>
        /// Creates a new tree view with absolute positioning. 
        /// Use <see cref="AddObjects(IEnumerable{T})"/> to set set root objects for the tree.
        /// Children will not be rendered until you set <see cref="TreeBuilder"/>.
        /// </summary>
        public TreeView() : base()
        {
            CanFocus = true;

            // Things this view knows how to do
            AddCommand(Command.PageUp, () => { MovePageUp(false); return true; });
            AddCommand(Command.PageDown, () => { MovePageDown(false); return true; });
            AddCommand(Command.PageUpExtend, () => { MovePageUp(true); return true; });
            AddCommand(Command.PageDownExtend, () => { MovePageDown(true); return true; });
            AddCommand(Command.Expand, () => { Expand(); return true; });
            AddCommand(Command.ExpandAll, () => { ExpandAll(SelectedObject); return true; });
            AddCommand(Command.Collapse, () => { CursorLeft(false); return true; });
            AddCommand(Command.CollapseAll, () => { CursorLeft(true); return true; });
            AddCommand(Command.LineUp, () => { AdjustSelection(-1, false); return true; });
            AddCommand(Command.LineUpExtend, () => { AdjustSelection(-1, true); return true; });
            AddCommand(Command.LineUpToFirstBranch, () => { AdjustSelectionToBranchStart(); return true; });

            AddCommand(Command.LineDown, () => { AdjustSelection(1, false); return true; });
            AddCommand(Command.LineDownExtend, () => { AdjustSelection(1, true); return true; });
            AddCommand(Command.LineDownToLastBranch, () => { AdjustSelectionToBranchEnd(); return true; });

            AddCommand(Command.TopHome, () => { GoToFirst(); return true; });
            AddCommand(Command.BottomEnd, () => { GoToEnd(); return true; });
            AddCommand(Command.SelectAll, () => { SelectAll(); return true; });

            AddCommand(Command.ScrollUp, () => { ScrollUp(); return true; });
            AddCommand(Command.ScrollDown, () => { ScrollDown(); return true; });
            AddCommand(Command.Accept, () => { ActivateSelectedObjectIfAny(); return true; });

            // Default keybindings for this view
            AddKeyBinding(Key.PageUp, Command.PageUp);
            AddKeyBinding(Key.PageDown, Command.PageDown);
            AddKeyBinding(Key.PageUp | Key.ShiftMask, Command.PageUpExtend);
            AddKeyBinding(Key.PageDown | Key.ShiftMask, Command.PageDownExtend);
            AddKeyBinding(Key.CursorRight, Command.Expand);
            AddKeyBinding(Key.CursorRight | Key.CtrlMask, Command.ExpandAll);
            AddKeyBinding(Key.CursorLeft, Command.Collapse);
            AddKeyBinding(Key.CursorLeft | Key.CtrlMask, Command.CollapseAll);

            AddKeyBinding(Key.CursorUp, Command.LineUp);
            AddKeyBinding(Key.CursorUp | Key.ShiftMask, Command.LineUpExtend);
            AddKeyBinding(Key.CursorUp | Key.CtrlMask, Command.LineUpToFirstBranch);

            AddKeyBinding(Key.CursorDown, Command.LineDown);
            AddKeyBinding(Key.CursorDown | Key.ShiftMask, Command.LineDownExtend);
            AddKeyBinding(Key.CursorDown | Key.CtrlMask, Command.LineDownToLastBranch);

            AddKeyBinding(Key.Home, Command.TopHome);
            AddKeyBinding(Key.End, Command.BottomEnd);
            AddKeyBinding(Key.A | Key.CtrlMask, Command.SelectAll);
            AddKeyBinding(ObjectActivationKey, Command.Accept);
        }

        /// <summary>
        /// Initialises <see cref="TreeBuilder"/>.Creates a new tree view with absolute 
        /// positioning. Use <see cref="AddObjects(IEnumerable{T})"/> to set set root 
        /// objects for the tree.
        /// </summary>
        public TreeView(ITreeBuilder<T> builder) : this()
        {
            TreeBuilder = builder;
        }

        ///<inheritdoc/>
        public override bool OnEnter(View view)
        {
            Application.Driver.SetCursorVisibility(DesiredCursorVisibility);

            return base.OnEnter(view);
        }

        /// <summary>
        /// Adds a new root level object unless it is already a root of the tree.
        /// </summary>
        /// <param name="o"></param>
        public void AddObject(T o)
        {
            if (!roots.ContainsKey(o))
            {
                roots.Add(o, new Branch<T>(this, null, o));
                InvalidateLineMap();
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Removes all objects from the tree and clears <see cref="SelectedObject"/>.
        /// </summary>
        public void ClearObjects()
        {
            SelectedObject = default(T);
            multiSelectedRegions.Clear();
            roots = new Dictionary<T, Branch<T>>();
            InvalidateLineMap();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Removes the given root object from the tree
        /// </summary>
        /// <remarks>If <paramref name="o"/> is the currently <see cref="SelectedObject"/> then the
        /// selection is cleared</remarks>.
        /// <param name="o"></param>
        public void Remove(T o)
        {
            if (roots.ContainsKey(o))
            {
                roots.Remove(o);
                InvalidateLineMap();
                SetNeedsDisplay();

                if (Equals(SelectedObject, o))
                {
                    SelectedObject = default(T);
                }
            }
        }

        /// <summary>
        /// Adds many new root level objects. Objects that are already root objects are ignored.
        /// </summary>
        /// <param name="collection">Objects to add as new root level objects.</param>.\
        public void AddObjects(IEnumerable<T> collection)
        {
            bool objectsAdded = false;

            foreach (var o in collection)
            {
                if (!roots.ContainsKey(o))
                {
                    roots.Add(o, new Branch<T>(this, null, o));
                    objectsAdded = true;
                }
            }

            if (objectsAdded)
            {
                InvalidateLineMap();
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Refreshes the state of the object <paramref name="o"/> in the tree. This will 
        /// recompute children, string representation etc.
        /// </summary>
        /// <remarks>This has no effect if the object is not exposed in the tree.</remarks>
        /// <param name="o"></param>
        /// <param name="startAtTop">True to also refresh all ancestors of the objects branch 
        /// (starting with the root). False to refresh only the passed node.</param>
        public void RefreshObject(T o, bool startAtTop = false)
        {
            var branch = ObjectToBranch(o);
            if (branch != null)
            {
                branch.Refresh(startAtTop);
                InvalidateLineMap();
                SetNeedsDisplay();
            }

        }

        /// <summary>
        /// Rebuilds the tree structure for all exposed objects starting with the root objects.
        /// Call this method when you know there are changes to the tree but don't know which 
        /// objects have changed (otherwise use <see cref="RefreshObject(T, bool)"/>).
        /// </summary>
        public void RebuildTree()
        {
            foreach (var branch in roots.Values)
            {
                branch.Rebuild();
            }

            InvalidateLineMap();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Returns the currently expanded children of the passed object. Returns an empty
        /// collection if the branch is not exposed or not expanded.
        /// </summary>
        /// <param name="o">An object in the tree.</param>
        /// <returns></returns>
        public IEnumerable<T> GetChildren(T o)
        {
            var branch = ObjectToBranch(o);

            if (branch == null || !branch.IsExpanded)
            {
                return new T[0];
            }

            return branch.ChildBranches?.Values?.Select(b => b.Model)?.ToArray() ?? new T[0];
        }
        /// <summary>
        /// Returns the parent object of <paramref name="o"/> in the tree. Returns null if 
        /// the object is not exposed in the tree.
        /// </summary>
        /// <param name="o">An object in the tree.</param>
        /// <returns></returns>
        public T GetParent(T o)
        {
            return ObjectToBranch(o)?.Parent?.Model;
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            if (roots == null)
            {
                return;
            }

            if (TreeBuilder == null)
            {
                Move(0, 0);
                Driver.AddStr(NoBuilderError);
                return;
            }

            var map = BuildLineMap();

            for (int line = 0; line < bounds.Height; line++)
            {

                var idxToRender = ScrollOffsetVertical + line;

                // Is there part of the tree view to render?
                if (idxToRender < map.Count)
                {
                    // Render the line
                    map.ElementAt(idxToRender).Draw(Driver, ColorScheme, line, bounds.Width);
                }
                else
                {

                    // Else clear the line to prevent stale symbols due to scrolling etc
                    Move(0, line);
                    Driver.SetAttribute(GetNormalColor());
                    Driver.AddStr(new string(' ', bounds.Width));
                }
            }
        }

        /// <summary>
        /// Returns the index of the object <paramref name="o"/> if it is currently exposed (it's 
        /// parent(s) have been expanded). This can be used with <see cref="ScrollOffsetVertical"/>
        /// and <see cref="View.SetNeedsDisplay()"/> to scroll to a specific object.
        /// </summary>
        /// <remarks>Uses the Equals method and returns the first index at which the object is found
        /// or -1 if it is not found.</remarks>
        /// <param name="o">An object that appears in your tree and is currently exposed.</param>
        /// <returns>The index the object was found at or -1 if it is not currently revealed or
        /// not in the tree at all.</returns>
        public int GetScrollOffsetOf(T o)
        {
            var map = BuildLineMap();
            for (int i = 0; i < map.Count; i++)
            {
                if (map.ElementAt(i).Model.Equals(o))
                {
                    return i;
                }
            }

            //object not found
            return -1;
        }

        /// <summary>
        /// Returns the maximum width line in the tree including prefix and expansion symbols.
        /// </summary>
        /// <param name="visible">True to consider only rows currently visible (based on window
        /// bounds and <see cref="ScrollOffsetVertical"/>. False to calculate the width of 
        /// every exposed branch in the tree.</param>
        /// <returns></returns>
        public int GetContentWidth(bool visible)
        {
            var map = BuildLineMap();

            if (map.Count == 0)
            {
                return 0;
            }

            if (visible)
            {

                //Somehow we managed to scroll off the end of the control
                if (ScrollOffsetVertical >= map.Count)
                {
                    return 0;
                }

                // If control has no height to it then there is no visible area for content
                if (Bounds.Height == 0)
                {
                    return 0;
                }

                return map.Skip(ScrollOffsetVertical).Take(Bounds.Height).Max(b => b.GetWidth(Driver));
            }
            else
            {

                return map.Max(b => b.GetWidth(Driver));
            }
        }

        /// <summary>
        /// Calculates all currently visible/expanded branches (including leafs) and outputs them 
        /// by index from the top of the screen.
        /// </summary>
        /// <remarks>Index 0 of the returned array is the first item that should be visible in the
        /// top of the control, index 1 is the next etc.</remarks>
        /// <returns></returns>
        private IReadOnlyCollection<Branch<T>> BuildLineMap()
        {
            if (cachedLineMap != null)
            {
                return cachedLineMap;
            }

            List<Branch<T>> toReturn = new List<Branch<T>>();

            foreach (var root in roots.Values)
            {

                var toAdd = AddToLineMap(root, false, out var isMatch);
                if (isMatch)
                {
                    toReturn.AddRange(toAdd);
                }
            }

            cachedLineMap = new ReadOnlyCollection<Branch<T>>(toReturn);

            // Update the collection used for search-typing
            KeystrokeNavigator.Collection = cachedLineMap.Select(b => AspectGetter(b.Model)).ToArray();
            return cachedLineMap;
        }

        private bool IsFilterMatch(Branch<T> branch)
        {
            return Filter?.IsMatch(branch.Model) ?? true;
        }

        private IEnumerable<Branch<T>> AddToLineMap(Branch<T> currentBranch, bool parentMatches, out bool match)
        {
            bool weMatch = IsFilterMatch(currentBranch);
            bool anyChildMatches = false;

            var toReturn = new List<Branch<T>>();
            var children = new List<Branch<T>>();

            if (currentBranch.IsExpanded)
            {
                foreach (var subBranch in currentBranch.ChildBranches.Values)
                {

                    foreach (var sub in AddToLineMap(subBranch, weMatch, out var childMatch))
                    {

                        if (childMatch)
                        {
                            children.Add(sub);
                            anyChildMatches = true;
                        }
                    }
                }
            }

            if (parentMatches || weMatch || anyChildMatches)
            {
                match = true;
                toReturn.Add(currentBranch);
            }
            else
            {
                match = false;
            }

            toReturn.AddRange(children);
            return toReturn;
        }

        /// <summary>
        /// Gets the <see cref="CollectionNavigator"/> that searches the <see cref="Objects"/> collection as
        /// the user types.
        /// </summary>
        public CollectionNavigator KeystrokeNavigator { get; private set; } = new CollectionNavigator();

        /// <inheritdoc/>
        public override bool ProcessKey(KeyEvent keyEvent)
        {
            if (!Enabled)
            {
                return false;
            }

            try
            {
                // First of all deal with any registered keybindings
                var result = InvokeKeybindings(keyEvent);
                if (result != null)
                {
                    return (bool)result;
                }

                // If not a keybinding, is the key a searchable key press?
                if (CollectionNavigator.IsCompatibleKey(keyEvent) && AllowLetterBasedNavigation)
                {
                    IReadOnlyCollection<Branch<T>> map;

                    // If there has been a call to InvalidateMap since the last time
                    // we need a new one to reflect the new exposed tree state
                    map = BuildLineMap();

                    // Find the current selected object within the tree
                    var current = map.IndexOf(b => b.Model == SelectedObject);
                    var newIndex = KeystrokeNavigator?.GetNextMatchingItem(current, (char)keyEvent.KeyValue);

                    if (newIndex is int && newIndex != -1)
                    {
                        SelectedObject = map.ElementAt((int)newIndex).Model;
                        EnsureVisible(selectedObject);
                        SetNeedsDisplay();
                        return true;
                    }
                }
            }
            finally
            {
                PositionCursor();
            }

            return base.ProcessKey(keyEvent);
        }


        /// <summary>
        /// <para>Triggers the <see cref="ObjectActivated"/> event with the <see cref="SelectedObject"/>.</para>
        /// 
        /// <para>This method also ensures that the selected object is visible.</para>
        /// </summary>
        public void ActivateSelectedObjectIfAny()
        {
            var o = SelectedObject;

            if (o != null)
            {
                OnObjectActivated(new ObjectActivatedEventArgs<T>(this, o));
                PositionCursor();
            }
        }

        /// <summary>
        /// <para>
        /// Returns the Y coordinate within the <see cref="View.Bounds"/> of the
        /// tree at which <paramref name="toFind"/> would be displayed or null if
        /// it is not currently exposed (e.g. its parent is collapsed).
        /// </para>
        /// <para>
        /// Note that the returned value can be negative if the TreeView is scrolled
        /// down and the <paramref name="toFind"/> object is off the top of the view.
        /// </para>
        /// </summary>
        /// <param name="toFind"></param>
        /// <returns></returns>
        public int? GetObjectRow(T toFind)
        {
            var idx = BuildLineMap().IndexOf(o => o.Model.Equals(toFind));

            if (idx == -1)
                return null;

            return idx - ScrollOffsetVertical;
        }

        /// <summary>
        /// <para>Moves the <see cref="SelectedObject"/> to the next item that begins with <paramref name="character"/>.</para>
        /// <para>This method will loop back to the start of the tree if reaching the end without finding a match.</para>
        /// </summary>
        /// <param name="character">The first character of the next item you want selected.</param>
        /// <param name="caseSensitivity">Case sensitivity of the search.</param>
        public void AdjustSelectionToNextItemBeginningWith(char character, StringComparison caseSensitivity = StringComparison.CurrentCultureIgnoreCase)
        {
            // search for next branch that begins with that letter
            var characterAsStr = character.ToString();
            AdjustSelectionToNext(b => AspectGetter(b.Model).StartsWith(characterAsStr, caseSensitivity));

            PositionCursor();
        }

        /// <summary>
        /// Moves the selection up by the height of the control (1 page).
        /// </summary>
        /// <param name="expandSelection">True if the navigation should add the covered nodes to the selected current selection.</param>
        /// <exception cref="NotImplementedException"></exception>
        public void MovePageUp(bool expandSelection = false)
        {
            AdjustSelection(-Bounds.Height, expandSelection);
        }

        /// <summary>
        /// Moves the selection down by the height of the control (1 page).
        /// </summary>
        /// <param name="expandSelection">True if the navigation should add the covered nodes to the selected current selection.</param>
        /// <exception cref="NotImplementedException"></exception>
        public void MovePageDown(bool expandSelection = false)
        {
            AdjustSelection(Bounds.Height, expandSelection);
        }

        /// <summary>
        /// Scrolls the view area down a single line without changing the current selection.
        /// </summary>
        public void ScrollDown()
        {
            if (ScrollOffsetVertical <= ContentHeight - 2)
            {
                ScrollOffsetVertical++;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Scrolls the view area up a single line without changing the current selection.
        /// </summary>
        public void ScrollUp()
        {
            if (scrollOffsetVertical > 0)
            {
                ScrollOffsetVertical--;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Raises the <see cref="ObjectActivated"/> event.
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnObjectActivated(ObjectActivatedEventArgs<T> e)
        {
            ObjectActivated?.Invoke(e);
        }

        /// <summary>
        /// Returns the object in the tree list that is currently visible.
        /// at the provided row. Returns null if no object is at that location.
        /// <remarks>
        /// </remarks>
        /// If you have screen coordinates then use <see cref="View.ScreenToView(int, int)"/>
        /// to translate these into the client area of the <see cref="TreeView{T}"/>.
        /// </summary>
        /// <param name="row">The row of the <see cref="View.Bounds"/> of the <see cref="TreeView{T}"/>.</param>
        /// <returns>The object currently displayed on this row or null.</returns>
        public T GetObjectOnRow(int row)
        {
            return HitTest(row)?.Model;
        }

        ///<inheritdoc/>
        public override bool MouseEvent(MouseEvent me)
        {
            // If it is not an event we care about
            if (!me.Flags.HasFlag(MouseFlags.Button1Clicked) &&
                !me.Flags.HasFlag(ObjectActivationButton ?? MouseFlags.Button1DoubleClicked) &&
                !me.Flags.HasFlag(MouseFlags.WheeledDown) &&
                !me.Flags.HasFlag(MouseFlags.WheeledUp) &&
                !me.Flags.HasFlag(MouseFlags.WheeledRight) &&
                !me.Flags.HasFlag(MouseFlags.WheeledLeft))
            {

                // do nothing
                return false;
            }

            if (!HasFocus && CanFocus)
            {
                SetFocus();
            }

            if (me.Flags == MouseFlags.WheeledDown)
            {

                ScrollDown();

                return true;
            }
            else if (me.Flags == MouseFlags.WheeledUp)
            {
                ScrollUp();

                return true;
            }

            if (me.Flags == MouseFlags.WheeledRight)
            {

                ScrollOffsetHorizontal++;
                SetNeedsDisplay();

                return true;
            }
            else if (me.Flags == MouseFlags.WheeledLeft)
            {
                ScrollOffsetHorizontal--;
                SetNeedsDisplay();

                return true;
            }

            if (me.Flags.HasFlag(MouseFlags.Button1Clicked))
            {

                // The line they clicked on a branch
                var clickedBranch = HitTest(me.Y);

                if (clickedBranch == null)
                {
                    return false;
                }

                bool isExpandToggleAttempt = clickedBranch.IsHitOnExpandableSymbol(Driver, me.X);

                // If we are already selected (double click)
                if (Equals(SelectedObject, clickedBranch.Model))
                {
                    isExpandToggleAttempt = true;
                }

                // if they clicked on the +/- expansion symbol
                if (isExpandToggleAttempt)
                {

                    if (clickedBranch.IsExpanded)
                    {
                        clickedBranch.Collapse();
                        InvalidateLineMap();
                    }
                    else
                    if (clickedBranch.CanExpand())
                    {
                        clickedBranch.Expand();
                        InvalidateLineMap();
                    }
                    else
                    {
                        SelectedObject = clickedBranch.Model; // It is a leaf node
                        multiSelectedRegions.Clear();
                    }
                }
                else
                {
                    // It is a first click somewhere in the current line that doesn't look like an expansion/collapse attempt
                    SelectedObject = clickedBranch.Model;
                    multiSelectedRegions.Clear();
                }

                SetNeedsDisplay();
                return true;
            }

            // If it is activation via mouse (e.g. double click)
            if (ObjectActivationButton.HasValue && me.Flags.HasFlag(ObjectActivationButton.Value))
            {
                // The line they clicked on a branch
                var clickedBranch = HitTest(me.Y);

                if (clickedBranch == null)
                {
                    return false;
                }

                // Double click changes the selection to the clicked node as well as triggering
                // activation otherwise it feels wierd
                SelectedObject = clickedBranch.Model;
                SetNeedsDisplay();

                // trigger activation event				
                OnObjectActivated(new ObjectActivatedEventArgs<T>(this, clickedBranch.Model));

                // mouse event is handled.
                return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the branch at the given <paramref name="y"/> client
        /// coordinate e.g. following a click event.
        /// </summary>
        /// <param name="y">Client Y position in the controls bounds.</param>
        /// <returns>The clicked branch or null if outside of tree region.</returns>
        private Branch<T> HitTest(int y)
        {
            var map = BuildLineMap();

            var idx = y + ScrollOffsetVertical;

            // click is outside any visible nodes
            if (idx < 0 || idx >= map.Count)
            {
                return null;
            }

            // The line they clicked on
            return map.ElementAt(idx);
        }

        /// <summary>
        /// Positions the cursor at the start of the selected objects line (if visible).
        /// </summary>
        public override void PositionCursor()
        {
            if (CanFocus && HasFocus && Visible && SelectedObject != null)
            {

                var map = BuildLineMap();
                var idx = map.IndexOf(b => b.Model.Equals(SelectedObject));

                // if currently selected line is visible
                if (idx - ScrollOffsetVertical >= 0 && idx - ScrollOffsetVertical < Bounds.Height)
                {
                    Move(0, idx - ScrollOffsetVertical);
                }
                else
                {
                    base.PositionCursor();
                }

            }
            else
            {
                base.PositionCursor();
            }
        }

        /// <summary>
        /// Determines systems behaviour when the left arrow key is pressed. Default behaviour is
        /// to collapse the current tree node if possible otherwise changes selection to current 
        /// branches parent.
        /// </summary>
        protected virtual void CursorLeft(bool ctrl)
        {
            if (IsExpanded(SelectedObject))
            {

                if (ctrl)
                {
                    CollapseAll(SelectedObject);
                }
                else
                {
                    Collapse(SelectedObject);
                }
            }
            else
            {
                var parent = GetParent(SelectedObject);

                if (parent != null)
                {
                    SelectedObject = parent;
                    AdjustSelection(0);
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Changes the <see cref="SelectedObject"/> to the first root object and resets 
        /// the <see cref="ScrollOffsetVertical"/> to 0.
        /// </summary>
        public void GoToFirst()
        {
            ScrollOffsetVertical = 0;
            SelectedObject = roots.Keys.FirstOrDefault();

            SetNeedsDisplay();
        }

        /// <summary>
        /// Changes the <see cref="SelectedObject"/> to the last object in the tree and scrolls so
        /// that it is visible.
        /// </summary>
        public void GoToEnd()
        {
            var map = BuildLineMap();
            ScrollOffsetVertical = Math.Max(0, map.Count - Bounds.Height + 1);
            SelectedObject = map.LastOrDefault()?.Model;

            SetNeedsDisplay();
        }

        /// <summary>
        /// Changes the <see cref="SelectedObject"/> to <paramref name="toSelect"/> and scrolls to ensure
        /// it is visible. Has no effect if <paramref name="toSelect"/> is not exposed in the tree (e.g. 
        /// its parents are collapsed).
        /// </summary>
        /// <param name="toSelect"></param>
        public void GoTo(T toSelect)
        {
            if (ObjectToBranch(toSelect) == null)
            {
                return;
            }

            SelectedObject = toSelect;
            EnsureVisible(toSelect);
            SetNeedsDisplay();
        }

        /// <summary>
        /// The number of screen lines to move the currently selected object by. Supports negative values.
        /// <paramref name="offset"/>. Each branch occupies 1 line on screen.
        /// </summary>
        /// <remarks>If nothing is currently selected or the selected object is no longer in the tree
        /// then the first object in the tree is selected instead.</remarks>
        /// <param name="offset">Positive to move the selection down the screen, negative to move it up</param>
        /// <param name="expandSelection">True to expand the selection (assuming 
        /// <see cref="MultiSelect"/> is enabled). False to replace.</param>
        public void AdjustSelection(int offset, bool expandSelection = false)
        {
            // if it is not a shift click or we don't allow multi select
            if (!expandSelection || !MultiSelect)
            {
                multiSelectedRegions.Clear();
            }

            if (SelectedObject == null)
            {
                SelectedObject = roots.Keys.FirstOrDefault();
            }
            else
            {
                var map = BuildLineMap();

                var idx = map.IndexOf(b => b.Model.Equals(SelectedObject));

                if (idx == -1)
                {
                    // The current selection has disapeared!
                    SelectedObject = roots.Keys.FirstOrDefault();
                }
                else
                {
                    var newIdx = Math.Min(Math.Max(0, idx + offset), map.Count - 1);

                    var newBranch = map.ElementAt(newIdx);

                    // If it is a multi selection
                    if (expandSelection && MultiSelect)
                    {
                        if (multiSelectedRegions.Any())
                        {
                            // expand the existing head selection
                            var head = multiSelectedRegions.Pop();
                            multiSelectedRegions.Push(new TreeSelection<T>(head.Origin, newIdx, map));
                        }
                        else
                        {
                            // or start a new multi selection region
                            multiSelectedRegions.Push(new TreeSelection<T>(map.ElementAt(idx), newIdx, map));
                        }
                    }

                    SelectedObject = newBranch.Model;

                    EnsureVisible(SelectedObject);
                }
            }
            SetNeedsDisplay();
        }

        /// <summary>
        /// Moves the selection to the first child in the currently selected level.
        /// </summary>
        public void AdjustSelectionToBranchStart()
        {
            var o = SelectedObject;
            if (o == null)
            {
                return;
            }

            var map = BuildLineMap();

            int currentIdx = map.IndexOf(b => Equals(b.Model, o));

            if (currentIdx == -1)
            {
                return;
            }

            var currentBranch = map.ElementAt(currentIdx);
            var next = currentBranch;

            for (; currentIdx >= 0; currentIdx--)
            {
                //if it is the beginning of the current depth of branch
                if (currentBranch.Depth != next.Depth)
                {

                    SelectedObject = currentBranch.Model;
                    EnsureVisible(currentBranch.Model);
                    SetNeedsDisplay();
                    return;
                }

                // look at next branch up for consideration
                currentBranch = next;
                next = map.ElementAt(currentIdx);
            }

            // We ran all the way to top of tree
            GoToFirst();
        }

        /// <summary>
        /// Moves the selection to the last child in the currently selected level.
        /// </summary>
        public void AdjustSelectionToBranchEnd()
        {
            var o = SelectedObject;
            if (o == null)
            {
                return;
            }

            var map = BuildLineMap();

            int currentIdx = map.IndexOf(b => Equals(b.Model, o));

            if (currentIdx == -1)
            {
                return;
            }

            var currentBranch = map.ElementAt(currentIdx);
            var next = currentBranch;

            for (; currentIdx < map.Count; currentIdx++)
            {
                //if it is the end of the current depth of branch
                if (currentBranch.Depth != next.Depth)
                {

                    SelectedObject = currentBranch.Model;
                    EnsureVisible(currentBranch.Model);
                    SetNeedsDisplay();
                    return;
                }

                // look at next branch for consideration
                currentBranch = next;
                next = map.ElementAt(currentIdx);
            }
            GoToEnd();
        }


        /// <summary>
        /// Sets the selection to the next branch that matches the <paramref name="predicate"/>.
        /// </summary>
        /// <param name="predicate"></param>
        private void AdjustSelectionToNext(Func<Branch<T>, bool> predicate)
        {
            var map = BuildLineMap();

            // empty map means we can't select anything anyway
            if (map.Count == 0)
            {
                return;
            }

            // Start searching from the first element in the map
            var idxStart = 0;

            // or the current selected branch
            if (SelectedObject != null)
            {
                idxStart = map.IndexOf(b => Equals(b.Model, SelectedObject));
            }

            // if currently selected object mysteriously vanished, search from beginning
            if (idxStart == -1)
            {
                idxStart = 0;
            }

            // loop around all indexes and back to first index
            for (int idxCur = (idxStart + 1) % map.Count; idxCur != idxStart; idxCur = (idxCur + 1) % map.Count)
            {
                if (predicate(map.ElementAt(idxCur)))
                {
                    SelectedObject = map.ElementAt(idxCur).Model;
                    EnsureVisible(map.ElementAt(idxCur).Model);
                    SetNeedsDisplay();
                    return;
                }
            }
        }

        /// <summary>
        /// Adjusts the <see cref="ScrollOffsetVertical"/> to ensure the given
        /// <paramref name="model"/> is visible. Has no effect if already visible.
        /// </summary>
        public void EnsureVisible(T model)
        {
            var map = BuildLineMap();

            var idx = map.IndexOf(b => Equals(b.Model, model));

            if (idx == -1)
            {
                return;
            }


            /*this -1 allows for possible horizontal scroll bar in the last row of the control*/
            int leaveSpace = Style.LeaveLastRow ? 1 : 0;

            if (idx < ScrollOffsetVertical)
            {
                //if user has scrolled up too far to see their selection
                ScrollOffsetVertical = idx;
            }
            else if (idx >= ScrollOffsetVertical + Bounds.Height - leaveSpace)
            {

                //if user has scrolled off bottom of visible tree
                ScrollOffsetVertical = Math.Max(0, (idx + 1) - (Bounds.Height - leaveSpace));
            }
        }

        /// <summary>
        /// Expands the currently <see cref="SelectedObject"/>.
        /// </summary>
        public void Expand()
        {
            Expand(SelectedObject);
        }

        /// <summary>
        /// Expands the supplied object if it is contained in the tree (either as a root object or 
        /// as an exposed branch object).
        /// </summary>
        /// <param name="toExpand">The object to expand.</param>
        public void Expand(T toExpand)
        {
            if (toExpand == null)
            {
                return;
            }

            ObjectToBranch(toExpand)?.Expand();
            InvalidateLineMap();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Expands the supplied object and all child objects.
        /// </summary>
        /// <param name="toExpand">The object to expand.</param>
        public void ExpandAll(T toExpand)
        {
            if (toExpand == null)
            {
                return;
            }

            ObjectToBranch(toExpand)?.ExpandAll();
            InvalidateLineMap();
            SetNeedsDisplay();
        }
        /// <summary>
        /// Fully expands all nodes in the tree, if the tree is very big and built dynamically this
        /// may take a while (e.g. for file system).
        /// </summary>
        public void ExpandAll()
        {
            foreach (var item in roots)
            {
                item.Value.ExpandAll();
            }

            InvalidateLineMap();
            SetNeedsDisplay();
        }
        /// <summary>
        /// Returns true if the given object <paramref name="o"/> is exposed in the tree and can be
        /// expanded otherwise false.
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        public bool CanExpand(T o)
        {
            return ObjectToBranch(o)?.CanExpand() ?? false;
        }

        /// <summary>
        /// Returns true if the given object <paramref name="o"/> is exposed in the tree and 
        /// expanded otherwise false.
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        public bool IsExpanded(T o)
        {
            return ObjectToBranch(o)?.IsExpanded ?? false;
        }

        /// <summary>
        /// Collapses the <see cref="SelectedObject"/>
        /// </summary>
        public void Collapse()
        {
            Collapse(selectedObject);
        }

        /// <summary>
        /// Collapses the supplied object if it is currently expanded .
        /// </summary>
        /// <param name="toCollapse">The object to collapse.</param>
        public void Collapse(T toCollapse)
        {
            CollapseImpl(toCollapse, false);
        }

        /// <summary>
        /// Collapses the supplied object if it is currently expanded. Also collapses all children
        /// branches (this will only become apparent when/if the user expands it again).
        /// </summary>
        /// <param name="toCollapse">The object to collapse.</param>
        public void CollapseAll(T toCollapse)
        {
            CollapseImpl(toCollapse, true);
        }

        /// <summary>
        /// Collapses all root nodes in the tree.
        /// </summary>
        public void CollapseAll()
        {
            foreach (var item in roots)
            {
                item.Value.Collapse();
            }

            InvalidateLineMap();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Implementation of <see cref="Collapse(T)"/> and <see cref="CollapseAll(T)"/>. Performs
        /// operation and updates selection if disapeared.
        /// </summary>
        /// <param name="toCollapse"></param>
        /// <param name="all"></param>
        protected void CollapseImpl(T toCollapse, bool all)
        {
            if (toCollapse == null)
            {
                return;
            }

            var branch = ObjectToBranch(toCollapse);

            // Nothing to collapse
            if (branch == null)
            {
                return;
            }

            if (all)
            {
                branch.CollapseAll();
            }
            else
            {
                branch.Collapse();
            }

            if (SelectedObject != null && ObjectToBranch(SelectedObject) == null)
            {
                // If the old selection suddenly became invalid then clear it
                SelectedObject = null;
            }

            InvalidateLineMap();
            SetNeedsDisplay();
        }

        /// <summary>
        /// Clears any cached results of the tree state.
        /// </summary>
        public void InvalidateLineMap()
        {
            cachedLineMap = null;
        }

        /// <summary>
        /// Returns the corresponding <see cref="Branch{T}"/> in the tree for
        /// <paramref name="toFind"/>. This will not work for objects hidden
        /// by their parent being collapsed.
        /// </summary>
        /// <param name="toFind"></param>
        /// <returns>The branch for <paramref name="toFind"/> or null if it is not currently 
        /// exposed in the tree.</returns>
        private Branch<T> ObjectToBranch(T toFind)
        {
            return BuildLineMap().FirstOrDefault(o => o.Model.Equals(toFind));
        }

        /// <summary>
        /// Returns true if the <paramref name="model"/> is either the 
        /// <see cref="SelectedObject"/> or part of a <see cref="MultiSelect"/>.
        /// </summary>
        /// <param name="model"></param>
        /// <returns></returns>
        public bool IsSelected(T model)
        {
            return Equals(SelectedObject, model) ||
                (MultiSelect && multiSelectedRegions.Any(s => s.Contains(model)));
        }

        /// <summary>
        /// Returns <see cref="SelectedObject"/> (if not null) and all multi selected objects if 
        /// <see cref="MultiSelect"/> is true
        /// </summary>
        /// <returns></returns>
        public IEnumerable<T> GetAllSelectedObjects()
        {
            var map = BuildLineMap();

            // To determine multi selected objects, start with the line map, that avoids yielding 
            // hidden nodes that were selected then the parent collapsed e.g. programmatically or
            // with mouse click
            if (MultiSelect)
            {
                foreach (var m in map.Select(b => b.Model).Where(IsSelected))
                {
                    yield return m;
                }
            }
            else
            {
                if (SelectedObject != null)
                {
                    yield return SelectedObject;
                }
            }
        }

        /// <summary>
        /// Selects all objects in the tree when <see cref="MultiSelect"/> is enabled otherwise 
        /// does nothing.
        /// </summary>
        public void SelectAll()
        {
            if (!MultiSelect)
            {
                return;
            }

            multiSelectedRegions.Clear();

            var map = BuildLineMap();

            if (map.Count == 0)
            {
                return;
            }

            multiSelectedRegions.Push(new TreeSelection<T>(map.ElementAt(0), map.Count, map));
            SetNeedsDisplay();

            OnSelectionChanged(new SelectionChangedEventArgs<T>(this, SelectedObject, SelectedObject));
        }

        /// <summary>
        /// Raises the SelectionChanged event.
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnSelectionChanged(SelectionChangedEventArgs<T> e)
        {
            SelectionChanged?.Invoke(this, e);
        }
    }

    class TreeSelection<T> where T : class
    {

        public Branch<T> Origin { get; }

        private HashSet<T> included = new HashSet<T>();

        /// <summary>
        /// Creates a new selection between two branches in the tree
        /// </summary>
        /// <param name="from"></param>
        /// <param name="toIndex"></param>
        /// <param name="map"></param>
        public TreeSelection(Branch<T> from, int toIndex, IReadOnlyCollection<Branch<T>> map)
        {
            Origin = from;
            included.Add(Origin.Model);

            var oldIdx = map.IndexOf(from);

            var lowIndex = Math.Min(oldIdx, toIndex);
            var highIndex = Math.Max(oldIdx, toIndex);

            // Select everything between the old and new indexes
            foreach (var alsoInclude in map.Skip(lowIndex).Take(highIndex - lowIndex))
            {
                included.Add(alsoInclude.Model);
            }

        }
        public bool Contains(T model)
        {
            return included.Contains(model);
        }
    }
    //=======================================================================
    /// <summary>
    /// <see cref="ITreeViewFilter{T}"/> implementation which searches the
    /// <see cref="TreeView{T}.AspectGetter"/> of the model for the given
    /// <see cref="Text"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class TreeViewTextFilter<T> : ITreeViewFilter<T> where T : class
    {
        readonly TreeView<T> _forTree;

        /// <summary>
        /// Creates a new instance of the filter for use with <paramref name="forTree"/>.
        /// Set <see cref="Text"/> to begin filtering.
        /// </summary>
        /// <param name="forTree"></param>
        /// <exception cref="ArgumentNullException"></exception>
        public TreeViewTextFilter(TreeView<T> forTree)
        {
            _forTree = forTree ?? throw new ArgumentNullException(nameof(forTree));
        }

        /// <summary>
        /// The case sensitivity of the search match. 
        /// Defaults to <see cref="StringComparison.OrdinalIgnoreCase"/>.
        /// </summary>
        public StringComparison Comparer { get; set; } = StringComparison.OrdinalIgnoreCase;
        private string text;

        /// <summary>
        /// The text that will be searched for in the <see cref="TreeView{T}"/>
        /// </summary>
        public string Text
        {
            get { return text; }
            set
            {
                text = value;
                RefreshTreeView();
            }
        }

        private void RefreshTreeView()
        {
            _forTree.InvalidateLineMap();
            _forTree.SetNeedsDisplay();
        }

        /// <summary>
        /// Returns <typeparamref name="T"/> if there is no <see cref="Text"/> or
        /// the text matches the <see cref="TreeView{T}.AspectGetter"/> of the
        /// <paramref name="model"/>.
        /// </summary>
        /// <param name="model"></param>
        /// <returns></returns>
        public bool IsMatch(T model)
        {
            if (string.IsNullOrWhiteSpace(Text))
            {
                return true;
            }

            return _forTree.AspectGetter(model)?.IndexOf(Text, Comparer) != -1;
        }
    }
    //=======================================================================
    //
    // mainloop.cs: Simple managed mainloop implementation.
    //

    /// <summary>
    /// Unix main loop, suitable for using on Posix systems
    /// </summary>
    /// <remarks>
    /// In addition to the general functions of the mainloop, the Unix version
    /// can watch file descriptors using the AddWatch methods.
    /// </remarks>
    internal class UnixMainLoop : IMainLoopDriver
    {
        public UnixMainLoop(ConsoleDriver consoleDriver = null)
        {
            // UnixDriver doesn't use the consoleDriver parameter, but the WindowsDriver does.
        }

        public const int KEY_RESIZE = unchecked((int)0xffffffffffffffff);

        [StructLayout(LayoutKind.Sequential)]
        struct Pollfd
        {
            public int fd;
            public short events, revents;
        }

        /// <summary>
        ///	Condition on which to wake up from file descriptor activity.  These match the Linux/BSD poll definitions.
        /// </summary>
        [Flags]
        public enum Condition : short
        {
            /// <summary>
            /// There is data to read
            /// </summary>
            PollIn = 1,
            /// <summary>
            /// Writing to the specified descriptor will not block
            /// </summary>
            PollOut = 4,
            /// <summary>
            /// There is urgent data to read
            /// </summary>
            PollPri = 2,
            /// <summary>
            ///  Error condition on output
            /// </summary>
            PollErr = 8,
            /// <summary>
            /// Hang-up on output
            /// </summary>
            PollHup = 16,
            /// <summary>
            /// File descriptor is not open.
            /// </summary>
            PollNval = 32
        }

        class Watch
        {
            public int File;
            public Condition Condition;
            public Func<MainLoop, bool> Callback;
        }

        Dictionary<int, Watch> descriptorWatchers = new Dictionary<int, Watch>();

        [DllImport("libc")]
        extern static int poll([In, Out] Pollfd[] ufds, uint nfds, int timeout);

        [DllImport("libc")]
        extern static int pipe([In, Out] int[] pipes);

        [DllImport("libc")]
        extern static int read(int fd, IntPtr buf, IntPtr n);

        [DllImport("libc")]
        extern static int write(int fd, IntPtr buf, IntPtr n);

        Pollfd[] pollmap;
        bool poll_dirty = true;
        int[] wakeupPipes = new int[2];
        static IntPtr ignore = Marshal.AllocHGlobal(1);
        MainLoop mainLoop;
        bool winChanged;

        public Action WinChanged;

        void IMainLoopDriver.Wakeup()
        {
            write(wakeupPipes[1], ignore, (IntPtr)1);
        }

        void IMainLoopDriver.Setup(MainLoop mainLoop)
        {
            this.mainLoop = mainLoop;
            pipe(wakeupPipes);
            AddWatch(wakeupPipes[0], Condition.PollIn, ml =>
            {
                read(wakeupPipes[0], ignore, (IntPtr)1);
                return true;
            });
        }

        /// <summary>
        ///	Removes an active watch from the mainloop.
        /// </summary>
        /// <remarks>
        ///	The token parameter is the value returned from AddWatch
        /// </remarks>
        public void RemoveWatch(object token)
        {
            var watch = token as Watch;
            if (watch == null)
                return;
            descriptorWatchers.Remove(watch.File);
        }

        /// <summary>
        ///  Watches a file descriptor for activity.
        /// </summary>
        /// <remarks>
        ///  When the condition is met, the provided callback
        ///  is invoked.  If the callback returns false, the
        ///  watch is automatically removed.
        ///
        ///  The return value is a token that represents this watch, you can
        ///  use this token to remove the watch by calling RemoveWatch.
        /// </remarks>
        public object AddWatch(int fileDescriptor, Condition condition, Func<MainLoop, bool> callback)
        {
            if (callback == null)
                throw new ArgumentNullException(nameof(callback));

            var watch = new Watch() { Condition = condition, Callback = callback, File = fileDescriptor };
            descriptorWatchers[fileDescriptor] = watch;
            poll_dirty = true;
            return watch;
        }

        void UpdatePollMap()
        {
            if (!poll_dirty)
                return;
            poll_dirty = false;

            pollmap = new Pollfd[descriptorWatchers.Count];
            int i = 0;
            foreach (var fd in descriptorWatchers.Keys)
            {
                pollmap[i].fd = fd;
                pollmap[i].events = (short)descriptorWatchers[fd].Condition;
                i++;
            }
        }

        bool IMainLoopDriver.EventsPending(bool wait)
        {
            UpdatePollMap();

            bool checkTimersResult = CheckTimers(wait, out var pollTimeout);

            var n = poll(pollmap, (uint)pollmap.Length, pollTimeout);

            if (n == KEY_RESIZE)
            {
                winChanged = true;
            }

            return checkTimersResult || n >= KEY_RESIZE;
        }

        bool CheckTimers(bool wait, out int pollTimeout)
        {
            long now = DateTime.UtcNow.Ticks;

            if (mainLoop.timeouts.Count > 0)
            {
                pollTimeout = (int)((mainLoop.timeouts.Keys[0] - now) / TimeSpan.TicksPerMillisecond);
                if (pollTimeout < 0)
                {
                    // This avoids 'poll' waiting infinitely if 'pollTimeout < 0' until some action is detected
                    // This can occur after IMainLoopDriver.Wakeup is executed where the pollTimeout is less than 0
                    // and no event occurred in elapsed time when the 'poll' is start running again.
                    /*
					The 'poll' function in the C standard library uses a signed integer as the timeout argument, where:

					    - A positive value specifies a timeout in milliseconds.
					    - A value of 0 means the poll function will return immediately, checking for events and not waiting.
					    - A value of -1 means the poll function will wait indefinitely until an event occurs or an error occurs.
					    - A negative value other than -1 typically indicates an error.
					 */
                    pollTimeout = 0;
                    return true;
                }
            }
            else
                pollTimeout = -1;

            if (!wait)
                pollTimeout = 0;

            int ic;
            lock (mainLoop.idleHandlers)
            {
                ic = mainLoop.idleHandlers.Count;
            }

            return ic > 0;
        }

        void IMainLoopDriver.MainIteration()
        {
            if (winChanged)
            {
                winChanged = false;
                WinChanged?.Invoke();
            }
            if (pollmap != null)
            {
                foreach (var p in pollmap)
                {
                    Watch watch;

                    if (p.revents == 0)
                        continue;

                    if (!descriptorWatchers.TryGetValue(p.fd, out watch))
                        continue;
                    if (!watch.Callback(this.mainLoop))
                        descriptorWatchers.Remove(p.fd);
                }
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Determines the LayoutStyle for a <see cref="View"/>, if Absolute, during <see cref="View.LayoutSubviews"/>, the
    /// value from the <see cref="View.Frame"/> will be used, if the value is Computed, then <see cref="View.Frame"/>
    /// will be updated from the X, Y <see cref="Pos"/> objects and the Width and Height <see cref="Dim"/> objects.
    /// </summary>
    public enum LayoutStyle
    {
        /// <summary>
        /// The position and size of the view are based on the Frame value.
        /// </summary>
        Absolute,

        /// <summary>
        /// The position and size of the view will be computed based on the
        /// X, Y, Width and Height properties and set on the Frame.
        /// </summary>
        Computed
    }

    /// <summary>
    /// View is the base class for all views on the screen and represents a visible element that can render itself and 
    /// contains zero or more nested views.
    /// </summary>
    /// <remarks>
    /// <para>
    ///    The View defines the base functionality for user interface elements in Terminal.Gui. Views
    ///    can contain one or more subviews, can respond to user input and render themselves on the screen.
    /// </para>
    /// <para>
    ///    Views supports two layout styles: <see cref="LayoutStyle.Absolute"/> or <see cref="LayoutStyle.Computed"/>. 
    ///    The choice as to which layout style is used by the View 
    ///    is determined when the View is initialized. To create a View using Absolute layout, call a constructor that takes a
    ///    Rect parameter to specify the absolute position and size (the View.<see cref="View.Frame "/>). To create a View 
    ///    using Computed layout use a constructor that does not take a Rect parameter and set the X, Y, Width and Height 
    ///    properties on the view. Both approaches use coordinates that are relative to the container they are being added to. 
    /// </para>
    /// <para>
    ///    To switch between Absolute and Computed layout, use the <see cref="LayoutStyle"/> property. 
    /// </para>
    /// <para>
    ///    Computed layout is more flexible and supports dynamic console apps where controls adjust layout
    ///    as the terminal resizes or other Views change size or position. The X, Y, Width and Height 
    ///    properties are Dim and Pos objects that dynamically update the position of a view.
    ///    The X and Y properties are of type <see cref="Pos"/>
    ///    and you can use either absolute positions, percentages or anchor
    ///    points. The Width and Height properties are of type
    ///    <see cref="Dim"/> and can use absolute position,
    ///    percentages and anchors. These are useful as they will take
    ///    care of repositioning views when view's frames are resized or
    ///    if the terminal size changes.
    /// </para>
    /// <para>
    ///    Absolute layout requires specifying coordinates and sizes of Views explicitly, and the
    ///    View will typically stay in a fixed position and size. To change the position and size use the
    ///    <see cref="Frame"/> property.
    /// </para>
    /// <para>
    ///    Subviews (child views) can be added to a View by calling the <see cref="Add(View)"/> method. 
    ///    The container of a View can be accessed with the <see cref="SuperView"/> property.
    /// </para>
    /// <para>
    ///    To flag a region of the View's <see cref="Bounds"/> to be redrawn call <see cref="SetNeedsDisplay(Rect)"/>. 
    ///    To flag the entire view for redraw call <see cref="SetNeedsDisplay()"/>.
    /// </para>
    /// <para>
    ///    Views have a <see cref="ColorScheme"/> property that defines the default colors that subviews
    ///    should use for rendering. This ensures that the views fit in the context where
    ///    they are being used, and allows for themes to be plugged in. For example, the
    ///    default colors for windows and toplevels uses a blue background, while it uses
    ///    a white background for dialog boxes and a red background for errors.
    /// </para>
    /// <para>
    ///    Subclasses should not rely on <see cref="ColorScheme"/> being
    ///    set at construction time. If a <see cref="ColorScheme"/> is not set on a view, the view will inherit the
    ///    value from its <see cref="SuperView"/> and the value might only be valid once a view has been
    ///    added to a SuperView. 
    /// </para>
    /// <para>
    ///    By using  <see cref="ColorScheme"/> applications will work both
    ///    in color as well as black and white displays.
    /// </para>
    /// <para>
    ///    Views that are focusable should implement the <see cref="PositionCursor"/> to make sure that
    ///    the cursor is placed in a location that makes sense. Unix terminals do not have
    ///    a way of hiding the cursor, so it can be distracting to have the cursor left at
    ///    the last focused view. So views should make sure that they place the cursor
    ///    in a visually sensible place.
    /// </para>
    /// <para>
    ///    The <see cref="LayoutSubviews"/> method is invoked when the size or layout of a view has
    ///    changed. The default processing system will keep the size and dimensions
    ///    for views that use the <see cref="LayoutStyle.Absolute"/>, and will recompute the
    ///    frames for the vies that use <see cref="LayoutStyle.Computed"/>.
    /// </para>
    /// </remarks>
    public partial class View : Responder, ISupportInitializeNotification
    {
        //*master//
        public ScriptEngine.Machine.IValue Tag { get; set; }
        //master*//

        internal enum Direction
        {
            Forward,
            Backward
        }

        // container == SuperView
        View container = null;
        View focused = null;
        Direction focusDirection;
        bool autoSize;

        ShortcutHelper shortcutHelper;

        /// <summary>
        /// Event fired when a subview is being added to this view.
        /// </summary>
        public event Action<View> Added;

        /// <summary>
        /// Event fired when a subview is being removed from this view.
        /// </summary>
        public event Action<View> Removed;

        /// <summary>
        /// Event fired when the view gets focus.
        /// </summary>
        public event Action<FocusEventArgs> Enter;

        /// <summary>
        /// Event fired when the view looses focus.
        /// </summary>
        public event Action<FocusEventArgs> Leave;

        /// <summary>
        /// Event fired when the view receives the mouse event for the first time.
        /// </summary>
        public event Action<MouseEventArgs> MouseEnter;

        /// <summary>
        /// Event fired when the view receives a mouse event for the last time.
        /// </summary>
        public event Action<MouseEventArgs> MouseLeave;

        /// <summary>
        /// Event fired when a mouse event is generated.
        /// </summary>
        public event Action<MouseEventArgs> MouseClick;

        /// <summary>
        /// Event fired when the <see cref="CanFocus"/> value is being changed.
        /// </summary>
        public event Action CanFocusChanged;

        /// <summary>
        /// Event fired when the <see cref="Enabled"/> value is being changed.
        /// </summary>
        public event Action EnabledChanged;

        /// <summary>
        /// Event fired when the <see cref="Visible"/> value is being changed.
        /// </summary>
        public event Action VisibleChanged;

        /// <summary>
        /// Event invoked when the <see cref="HotKey"/> is changed.
        /// </summary>
        public event Action<Key> HotKeyChanged;

        Key hotKey = Key.Null;

        /// <summary>
        /// Gets or sets the HotKey defined for this view. A user pressing HotKey on the keyboard while this view has focus will cause the Clicked event to fire.
        /// </summary>
        public virtual Key HotKey
        {
            get => hotKey;
            set
            {
                if (hotKey != value)
                {
                    hotKey = TextFormatter.HotKey = (value == Key.Unknown ? Key.Null : value);
                }
            }
        }

        /// <summary>
        /// Gets or sets the specifier character for the hotkey (e.g. '_'). Set to '\xffff' to disable hotkey support for this View instance. The default is '\xffff'. 
        /// </summary>
        public virtual Rune HotKeySpecifier
        {
            get => TextFormatter.HotKeySpecifier;
            set
            {
                TextFormatter.HotKeySpecifier = value;
                SetHotKey();
            }
        }

        /// <summary>
        /// This is the global setting that can be used as a global shortcut to invoke an action if provided.
        /// </summary>
        public Key Shortcut
        {
            get => shortcutHelper.Shortcut;
            set
            {
                if (shortcutHelper.Shortcut != value && (ShortcutHelper.PostShortcutValidation(value) || value == Key.Null))
                {
                    shortcutHelper.Shortcut = value;
                }
            }
        }

        /// <summary>
        /// The keystroke combination used in the <see cref="Shortcut"/> as string.
        /// </summary>
        public ustring ShortcutTag => ShortcutHelper.GetShortcutTag(shortcutHelper.Shortcut);

        /// <summary>
        /// The action to run if the <see cref="Shortcut"/> is defined.
        /// </summary>
        public virtual Action ShortcutAction { get; set; }

        /// <summary>
        /// Gets or sets arbitrary data for the view.
        /// </summary>
        /// <remarks>This property is not used internally.</remarks>
        public object Data { get; set; }

        internal Direction FocusDirection
        {
            get => SuperView?.FocusDirection ?? focusDirection;
            set
            {
                if (SuperView != null)
                    SuperView.FocusDirection = value;
                else
                    focusDirection = value;
            }
        }

        /// <summary>
        /// Points to the current driver in use by the view, it is a convenience property
        /// for simplifying the development of new views.
        /// </summary>
        public static ConsoleDriver Driver => Application.Driver;

        static readonly IList<View> empty = new List<View>(0).AsReadOnly();

        // This is null, and allocated on demand.
        List<View> subviews;

        /// <summary>
        /// This returns a list of the subviews contained by this view.
        /// </summary>
        /// <value>The subviews.</value>
        public IList<View> Subviews => subviews?.AsReadOnly() ?? empty;

        // Internally, we use InternalSubviews rather than subviews, as we do not expect us
        // to make the same mistakes our users make when they poke at the Subviews.
        internal IList<View> InternalSubviews => subviews ?? empty;

        // This is null, and allocated on demand.
        List<View> tabIndexes;

        /// <summary>
        /// Configurable keybindings supported by the control
        /// </summary>
        private Dictionary<Key, Command[]> KeyBindings { get; set; } = new Dictionary<Key, Command[]>();
        private Dictionary<Command, Func<bool?>> CommandImplementations { get; set; } = new Dictionary<Command, Func<bool?>>();

        /// <summary>
        /// This returns a tab index list of the subviews contained by this view.
        /// </summary>
        /// <value>The tabIndexes.</value>
        public IList<View> TabIndexes => tabIndexes?.AsReadOnly() ?? empty;

        int tabIndex = -1;

        /// <summary>
        /// Indicates the index of the current <see cref="View"/> from the <see cref="TabIndexes"/> list.
        /// </summary>
        public int TabIndex
        {
            get { return tabIndex; }
            set
            {
                if (!CanFocus)
                {
                    tabIndex = -1;
                    return;
                }
                else if (SuperView?.tabIndexes == null || SuperView?.tabIndexes.Count == 1)
                {
                    tabIndex = 0;
                    return;
                }
                else if (tabIndex == value && TabIndexes.IndexOf(this) == value)
                {
                    return;
                }
                tabIndex = value > SuperView.tabIndexes.Count - 1 ? SuperView.tabIndexes.Count - 1 : value < 0 ? 0 : value;
                tabIndex = GetTabIndex(tabIndex);
                if (SuperView.tabIndexes.IndexOf(this) != tabIndex)
                {
                    SuperView.tabIndexes.Remove(this);
                    SuperView.tabIndexes.Insert(tabIndex, this);
                    SetTabIndex();
                }
            }
        }

        int GetTabIndex(int idx)
        {
            var i = 0;
            foreach (var v in SuperView.tabIndexes)
            {
                if (v.tabIndex == -1 || v == this)
                {
                    continue;
                }
                i++;
            }
            return Math.Min(i, idx);
        }

        void SetTabIndex()
        {
            var i = 0;
            foreach (var v in SuperView.tabIndexes)
            {
                if (v.tabIndex == -1)
                {
                    continue;
                }
                v.tabIndex = i;
                i++;
            }
        }

        bool tabStop = true;

        /// <summary>
        /// This only be <see langword="true"/> if the <see cref="CanFocus"/> is also <see langword="true"/> 
        /// and the focus can be avoided by setting this to <see langword="false"/>
        /// </summary>
        public bool TabStop
        {
            get => tabStop;
            set
            {
                if (tabStop == value)
                {
                    return;
                }
                tabStop = CanFocus && value;
            }
        }

        bool oldCanFocus;
        int oldTabIndex;

        /// <inheritdoc/>
        public override bool CanFocus
        {
            get => base.CanFocus;
            set
            {
                if (!addingView && IsInitialized && SuperView?.CanFocus == false && value)
                {
                    throw new InvalidOperationException("Cannot set CanFocus to true if the SuperView CanFocus is false!");
                }
                if (base.CanFocus != value)
                {
                    base.CanFocus = value;

                    switch (value)
                    {
                        case false when tabIndex > -1:
                            TabIndex = -1;
                            break;
                        case true when SuperView?.CanFocus == false && addingView:
                            SuperView.CanFocus = true;
                            break;
                    }

                    if (value && tabIndex == -1)
                    {
                        TabIndex = SuperView != null ? SuperView.tabIndexes.IndexOf(this) : -1;
                    }
                    TabStop = value;

                    if (!value && SuperView?.Focused == this)
                    {
                        SuperView.focused = null;
                    }
                    if (!value && HasFocus)
                    {
                        SetHasFocus(false, this);
                        SuperView?.EnsureFocus();
                        if (SuperView != null && SuperView.Focused == null)
                        {
                            SuperView.FocusNext();
                            if (SuperView.Focused == null && Application.Current != null)
                            {
                                Application.Current.FocusNext();
                            }
                            Application.EnsuresTopOnFront();
                        }
                    }
                    if (subviews != null && IsInitialized)
                    {
                        foreach (var view in subviews)
                        {
                            if (view.CanFocus != value)
                            {
                                if (!value)
                                {
                                    view.oldCanFocus = view.CanFocus;
                                    view.oldTabIndex = view.tabIndex;
                                    view.CanFocus = false;
                                    view.tabIndex = -1;
                                }
                                else
                                {
                                    if (addingView)
                                    {
                                        view.addingView = true;
                                    }
                                    view.CanFocus = view.oldCanFocus;
                                    view.tabIndex = view.oldTabIndex;
                                    view.addingView = false;
                                }
                            }
                        }

                        if (SuperView is Toplevel && Application.Current?.Focused != SuperView)
                        {
                            Application.EnsuresTopOnFront();
                        }
                    }
                    OnCanFocusChanged();
                    SetNeedsDisplay();
                }
            }
        }

        internal Rect NeedDisplay { get; private set; } = Rect.Empty;

        // The frame for the object. Superview relative.
        Rect frame;

        /// <summary>
        /// Gets or sets an identifier for the view;
        /// </summary>
        /// <value>The identifier.</value>
        /// <remarks>The id should be unique across all Views that share a SuperView.</remarks>
        public ustring Id { get; set; } = "";

        /// <summary>
        /// Returns a value indicating if this View is currently on Top (Active)
        /// </summary>
        public bool IsCurrentTop => Application.Current == this;

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="View"/> wants mouse position reports.
        /// </summary>
        /// <value><see langword="true"/> if want mouse position reports; otherwise, <see langword="false"/>.</value>
        public virtual bool WantMousePositionReports { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="View"/> want continuous button pressed event.
        /// </summary>
        public virtual bool WantContinuousButtonPressed { get; set; }

        /// <summary>
        /// Gets or sets the frame for the view. The frame is relative to the view's container (<see cref="SuperView"/>).
        /// </summary>
        /// <value>The frame.</value>
        /// <remarks>
        /// <para>
        ///    Change the Frame when using the <see cref="Terminal.Gui.LayoutStyle.Absolute"/> layout style to move or resize views. 
        /// </para>
        /// <para>
        ///    Altering the Frame of a view will trigger the redrawing of the
        ///    view as well as the redrawing of the affected regions of the <see cref="SuperView"/>.
        /// </para>
        /// </remarks>
        public virtual Rect Frame
        {
            get => frame;
            set
            {
                frame = value;
                TextFormatter.Size = GetBoundsTextFormatterSize();
                SetNeedsLayout();
                SetNeedsDisplay();
            }
        }

        ///// <summary>
        ///// Gets an enumerator that enumerates the subviews in this view.
        ///// </summary>
        ///// <returns>The enumerator.</returns>
        //public IEnumerator GetEnumerator ()
        //{
        //	foreach (var v in InternalSubviews)
        //		yield return v;
        //}

        LayoutStyle layoutStyle;

        /// <summary>
        /// Controls how the View's <see cref="Frame"/> is computed during the LayoutSubviews method, if the style is set to
        /// <see cref="Terminal.Gui.LayoutStyle.Absolute"/>, 
        /// LayoutSubviews does not change the <see cref="Frame"/>. If the style is <see cref="Terminal.Gui.LayoutStyle.Computed"/>
        /// the <see cref="Frame"/> is updated using
        /// the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties.
        /// </summary>
        /// <value>The layout style.</value>
        public LayoutStyle LayoutStyle
        {
            get => layoutStyle;
            set
            {
                layoutStyle = value;
                SetNeedsLayout();
            }
        }

        /// <summary>
        /// The bounds represent the View-relative rectangle used for this view; the area inside of the view.
        /// </summary>
        /// <value>The bounds.</value>
        /// <remarks>
        /// <para>
        /// Updates to the Bounds update the <see cref="Frame"/>,
        /// and has the same side effects as updating the <see cref="Frame"/>.
        /// </para>
        /// <para>
        /// Because <see cref="Bounds"/> coordinates are relative to the upper-left corner of the <see cref="View"/>, 
        /// the coordinates of the upper-left corner of the rectangle returned by this property are (0,0). 
        /// Use this property to obtain the size and coordinates of the client area of the 
        /// control for tasks such as drawing on the surface of the control.
        /// </para>
        /// </remarks>
        public Rect Bounds
        {
            get => new Rect(Point.Empty, Frame.Size);
            set => Frame = new Rect(frame.Location, value.Size);
        }

        Pos x, y;

        /// <summary>
        /// Gets or sets the X position for the view (the column). Only used if the <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Computed"/>.
        /// </summary>
        /// <value>The X Position.</value>
        /// <remarks>
        /// If <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Absolute"/> changing this property has no effect and its value is indeterminate. 
        /// </remarks>
        public Pos X
        {
            get => x;
            set
            {
                if (ForceValidatePosDim && !ValidatePosDim(x, value))
                {
                    throw new ArgumentException();
                }

                x = value;

                ProcessResizeView();
            }
        }

        /// <summary>
        /// Gets or sets the Y position for the view (the row). Only used if the <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Computed"/>.
        /// </summary>
        /// <value>The y position (line).</value>
        /// <remarks>
        /// If <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Absolute"/> changing this property has no effect and its value is indeterminate. 
        /// </remarks>
        public Pos Y
        {
            get => y;
            set
            {
                if (ForceValidatePosDim && !ValidatePosDim(y, value))
                {
                    throw new ArgumentException();
                }

                y = value;

                ProcessResizeView();
            }
        }
        Dim width, height;

        /// <summary>
        /// Gets or sets the width of the view. Only used the <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Computed"/>.
        /// </summary>
        /// <value>The width.</value>
        /// <remarks>
        /// If <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Absolute"/> changing this property has no effect and its value is indeterminate. 
        /// </remarks>
        public Dim Width
        {
            get => width;
            set
            {
                if (ForceValidatePosDim && !ValidatePosDim(width, value))
                {
                    throw new ArgumentException("ForceValidatePosDim is enabled", nameof(Width));
                }

                width = value;

                if (ForceValidatePosDim)
                {
                    var isValidNewAutSize = autoSize && IsValidAutoSizeWidth(width);

                    if (IsAdded && autoSize && !isValidNewAutSize)
                    {
                        throw new InvalidOperationException("Must set AutoSize to false before set the Width.");
                    }
                }
                ProcessResizeView();
            }
        }

        /// <summary>
        /// Gets or sets the height of the view. Only used the <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Computed"/>.
        /// </summary>
        /// <value>The height.</value>
        /// If <see cref="LayoutStyle"/> is <see cref="Terminal.Gui.LayoutStyle.Absolute"/> changing this property has no effect and its value is indeterminate. 
        public Dim Height
        {
            get => height;
            set
            {
                if (ForceValidatePosDim && !ValidatePosDim(height, value))
                {
                    throw new ArgumentException("ForceValidatePosDim is enabled", nameof(Height));
                }

                height = value;

                if (ForceValidatePosDim)
                {
                    var isValidNewAutSize = autoSize && IsValidAutoSizeHeight(height);

                    if (IsAdded && autoSize && !isValidNewAutSize)
                    {
                        throw new InvalidOperationException("Must set AutoSize to false before set the Height.");
                    }
                }
                ProcessResizeView();
            }
        }

        /// <summary>
        /// Forces validation with <see cref="Terminal.Gui.LayoutStyle.Computed"/> layout
        ///  to avoid breaking the <see cref="Pos"/> and <see cref="Dim"/> settings.
        /// </summary>
        public bool ForceValidatePosDim { get; set; }

        bool ValidatePosDim(object oldValue, object newValue)
        {
            if (!IsInitialized || layoutStyle == LayoutStyle.Absolute || oldValue == null || oldValue.GetType() == newValue.GetType() || this is Toplevel)
            {
                return true;
            }
            if (layoutStyle == LayoutStyle.Computed)
            {
                if (oldValue.GetType() != newValue.GetType() && !(newValue is Pos.PosAbsolute || newValue is Dim.DimAbsolute))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Verifies if the minimum width or height can be sets in the view.
        /// </summary>
        /// <param name="size">The size.</param>
        /// <returns><see langword="true"/> if the size can be set, <see langword="false"/> otherwise.</returns>
        public bool GetMinWidthHeight(out Size size)
        {
            size = Size.Empty;

            if (!AutoSize && !ustring.IsNullOrEmpty(TextFormatter.Text))
            {
                switch (TextFormatter.IsVerticalDirection(TextDirection))
                {
                    case true:
                        var colWidth = TextFormatter.GetSumMaxCharWidth(new List<ustring> { TextFormatter.Text }, 0, 1);
                        if (frame.Width < colWidth && (Width == null || (Bounds.Width >= 0 && Width is Dim.DimAbsolute
                            && Width.Anchor(0) >= 0 && Width.Anchor(0) < colWidth)))
                        {
                            size = new Size(colWidth, Bounds.Height);
                            return true;
                        }
                        break;
                    default:
                        if (frame.Height < 1 && (Height == null || (Height is Dim.DimAbsolute && Height.Anchor(0) == 0)))
                        {
                            size = new Size(Bounds.Width, 1);
                            return true;
                        }
                        break;
                }
            }
            return false;
        }

        /// <summary>
        /// Sets the minimum width or height if the view can be resized.
        /// </summary>
        /// <returns><see langword="true"/> if the size can be set, <see langword="false"/> otherwise.</returns>
        public bool SetMinWidthHeight()
        {
            if (GetMinWidthHeight(out Size size))
            {
                Bounds = new Rect(Bounds.Location, size);
                TextFormatter.Size = GetBoundsTextFormatterSize();
                return true;
            }
            return false;
        }

        /// <summary>
        /// Gets or sets the <see cref="Terminal.Gui.TextFormatter"/> which can be handled differently by any derived class.
        /// </summary>
        public TextFormatter TextFormatter { get; set; }

        /// <summary>
        /// Returns the container for this view, or null if this view has not been added to a container.
        /// </summary>
        /// <value>The super view.</value>
        public View SuperView => container;

        /// <summary>
        /// Initializes a new instance of a <see cref="Terminal.Gui.LayoutStyle.Absolute"/> <see cref="View"/> class with the absolute
        /// dimensions specified in the <see langword="frame"/> parameter. 
        /// </summary>
        /// <param name="frame">The region covered by this view.</param>
        /// <remarks>
        /// This constructor initialize a View with a <see cref="LayoutStyle"/> of <see cref="Terminal.Gui.LayoutStyle.Absolute"/>.
        /// Use <see cref="View"/> to initialize a View with  <see cref="LayoutStyle"/> of <see cref="Terminal.Gui.LayoutStyle.Computed"/> 
        /// </remarks>
        public View(Rect frame)
        {
            Initialize(ustring.Empty, frame, LayoutStyle.Absolute, TextDirection.LeftRight_TopBottom);
        }

        /// <summary>
        ///   Initializes a new instance of <see cref="View"/> using <see cref="Terminal.Gui.LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <remarks>
        /// <para>
        ///   Use <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties to dynamically control the size and location of the view.
        ///   The <see cref="View"/> will be created using <see cref="Terminal.Gui.LayoutStyle.Computed"/>
        ///   coordinates. The initial size (<see cref="View.Frame"/>) will be 
        ///   adjusted to fit the contents of <see cref="Text"/>, including newlines ('\n') for multiple lines. 
        /// </para>
        /// <para>
        ///   If <see cref="Height"/> is greater than one, word wrapping is provided.
        /// </para>
        /// <para>
        ///   This constructor initialize a View with a <see cref="LayoutStyle"/> of <see cref="Terminal.Gui.LayoutStyle.Computed"/>. 
        ///   Use <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties to dynamically control the size and location of the view.
        /// </para>
        /// </remarks>
        public View() : this(text: string.Empty, direction: TextDirection.LeftRight_TopBottom) { }

        /// <summary>
        ///   Initializes a new instance of <see cref="View"/> using <see cref="Terminal.Gui.LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <remarks>
        /// <para>
        ///   The <see cref="View"/> will be created at the given
        ///   coordinates with the given string. The size (<see cref="View.Frame"/>) will be 
        ///   adjusted to fit the contents of <see cref="Text"/>, including newlines ('\n') for multiple lines. 
        /// </para>
        /// <para>
        ///   No line wrapping is provided.
        /// </para>
        /// </remarks>
        /// <param name="x">column to locate the View.</param>
        /// <param name="y">row to locate the View.</param>
        /// <param name="text">text to initialize the <see cref="Text"/> property with.</param>
        public View(int x, int y, ustring text) : this(TextFormatter.CalcRect(x, y, text), text) { }

        /// <summary>
        ///   Initializes a new instance of <see cref="View"/> using <see cref="Terminal.Gui.LayoutStyle.Absolute"/> layout.
        /// </summary>
        /// <remarks>
        /// <para>
        ///   The <see cref="View"/> will be created at the given
        ///   coordinates with the given string. The initial size (<see cref="View.Frame"/>) will be 
        ///   adjusted to fit the contents of <see cref="Text"/>, including newlines ('\n') for multiple lines. 
        /// </para>
        /// <para>
        ///   If <c>rect.Height</c> is greater than one, word wrapping is provided.
        /// </para>
        /// </remarks>
        /// <param name="rect">Location.</param>
        /// <param name="text">text to initialize the <see cref="Text"/> property with.</param>
        /// <param name="border">The <see cref="Border"/>.</param>
        public View(Rect rect, ustring text, Border border = null)
        {
            Initialize(text, rect, LayoutStyle.Absolute, TextDirection.LeftRight_TopBottom, border);
        }

        /// <summary>
        ///   Initializes a new instance of <see cref="View"/> using <see cref="Terminal.Gui.LayoutStyle.Computed"/> layout.
        /// </summary>
        /// <remarks>
        /// <para>
        ///   The <see cref="View"/> will be created using <see cref="Terminal.Gui.LayoutStyle.Computed"/>
        ///   coordinates with the given string. The initial size (<see cref="View.Frame"/>) will be 
        ///   adjusted to fit the contents of <see cref="Text"/>, including newlines ('\n') for multiple lines. 
        /// </para>
        /// <para>
        ///   If <see cref="Height"/> is greater than one, word wrapping is provided.
        /// </para>
        /// </remarks>
        /// <param name="text">text to initialize the <see cref="Text"/> property with.</param>
        /// <param name="direction">The text direction.</param>
        /// <param name="border">The <see cref="Border"/>.</param>
        public View(ustring text, TextDirection direction = TextDirection.LeftRight_TopBottom, Border border = null)
        {
            Initialize(text, Rect.Empty, LayoutStyle.Computed, direction, border);
        }

        void Initialize(ustring text, Rect rect, LayoutStyle layoutStyle = LayoutStyle.Computed,
            TextDirection direction = TextDirection.LeftRight_TopBottom, Border border = null)
        {
            TextFormatter = new TextFormatter();
            TextFormatter.HotKeyChanged += TextFormatter_HotKeyChanged;
            TextDirection = direction;
            Border = border;
            if (Border != null)
            {
                Border.Child = this;
            }
            shortcutHelper = new ShortcutHelper();
            CanFocus = false;
            TabIndex = -1;
            TabStop = false;
            LayoutStyle = layoutStyle;
            // BUGBUG: CalcRect doesn't account for line wrapping

            var r = rect.IsEmpty ? TextFormatter.CalcRect(0, 0, text, direction) : rect;
            Frame = r;

            Text = text;
            UpdateTextFormatterText();
            ProcessResizeView();
        }

        /// <summary>
        /// Can be overridden if the <see cref="Terminal.Gui.TextFormatter.Text"/> has
        ///  different format than the default.
        /// </summary>
        protected virtual void UpdateTextFormatterText()
        {
            TextFormatter.Text = text;
        }

        /// <summary>
        /// Can be overridden if the view resize behavior is
        ///  different than the default.
        /// </summary>
        protected virtual void ProcessResizeView()
        {
            var actX = x is Pos.PosAbsolute ? x.Anchor(0) : frame.X;
            var actY = y is Pos.PosAbsolute ? y.Anchor(0) : frame.Y;
            Rect oldFrame = frame;

            if (AutoSize)
            {
                var s = GetAutoSize();
                var w = width is Dim.DimAbsolute && width.Anchor(0) > s.Width ? width.Anchor(0) : s.Width;
                var h = height is Dim.DimAbsolute && height.Anchor(0) > s.Height ? height.Anchor(0) : s.Height;
                frame = new Rect(new Point(actX, actY), new Size(w, h));
            }
            else
            {
                var w = width is Dim.DimAbsolute ? width.Anchor(0) : frame.Width;
                var h = height is Dim.DimAbsolute ? height.Anchor(0) : frame.Height;
                frame = new Rect(new Point(actX, actY), new Size(w, h));
                SetMinWidthHeight();
            }
            TextFormatter.Size = GetBoundsTextFormatterSize();
            SetNeedsLayout();
            SetNeedsDisplay();
        }

        void TextFormatter_HotKeyChanged(Key obj)
        {
            HotKeyChanged?.Invoke(obj);
        }

        /// <summary>
        /// Sets a flag indicating this view needs to be redisplayed because its state has changed.
        /// </summary>
        public void SetNeedsDisplay()
        {
            SetNeedsDisplay(Bounds);
        }

        internal bool LayoutNeeded { get; private set; } = true;

        internal void SetNeedsLayout()
        {
            if (LayoutNeeded)
                return;
            LayoutNeeded = true;
            if (SuperView == null)
                return;
            SuperView.SetNeedsLayout();
            foreach (var view in Subviews)
            {
                view.SetNeedsLayout();
            }
            TextFormatter.NeedsFormat = true;
        }

        /// <summary>
        /// Removes the <see cref="SetNeedsLayout"/> setting on this view.
        /// </summary>
        protected void ClearLayoutNeeded()
        {
            LayoutNeeded = false;
        }

        /// <summary>
        /// Flags the view-relative region on this View as needing to be repainted.
        /// </summary>
        /// <param name="region">The view-relative region that must be flagged for repaint.</param>
        public void SetNeedsDisplay(Rect region)
        {
            if (NeedDisplay.IsEmpty)
                NeedDisplay = region;
            else
            {
                var x = Math.Min(NeedDisplay.X, region.X);
                var y = Math.Min(NeedDisplay.Y, region.Y);
                var w = Math.Max(NeedDisplay.Width, region.Width);
                var h = Math.Max(NeedDisplay.Height, region.Height);
                NeedDisplay = new Rect(x, y, w, h);
            }
            container?.SetChildNeedsDisplay();

            if (subviews == null)
                return;

            foreach (var view in subviews)
                if (view.Frame.IntersectsWith(region))
                {
                    var childRegion = Rect.Intersect(view.Frame, region);
                    childRegion.X -= view.Frame.X;
                    childRegion.Y -= view.Frame.Y;
                    view.SetNeedsDisplay(childRegion);
                }
        }

        internal bool ChildNeedsDisplay { get; private set; }

        /// <summary>
        /// Indicates that any child views (in the <see cref="Subviews"/> list) need to be repainted.
        /// </summary>
        public void SetChildNeedsDisplay()
        {
            ChildNeedsDisplay = true;
            if (container != null)
                container.SetChildNeedsDisplay();
        }

        internal bool addingView;

        /// <summary>
        ///   Adds a subview (child) to this view.
        /// </summary>
        /// <remarks>
        /// The Views that have been added to this view can be retrieved via the <see cref="Subviews"/> property. 
        /// See also <seealso cref="Remove(View)"/> <seealso cref="RemoveAll"/> 
        /// </remarks>
        public virtual void Add(View view)
        {
            if (view == null)
                return;
            if (subviews == null)
            {
                subviews = new List<View>();
            }
            if (tabIndexes == null)
            {
                tabIndexes = new List<View>();
            }
            subviews.Add(view);
            tabIndexes.Add(view);
            view.container = this;
            if (view.CanFocus)
            {
                addingView = true;
                if (SuperView?.CanFocus == false)
                {
                    SuperView.addingView = true;
                    SuperView.CanFocus = true;
                    SuperView.addingView = false;
                }
                CanFocus = true;
                view.tabIndex = tabIndexes.IndexOf(view);
                addingView = false;
            }
            if (view.Enabled && !Enabled)
            {
                view.oldEnabled = true;
                view.Enabled = false;
            }
            SetNeedsLayout();
            SetNeedsDisplay();
            OnAdded(view);
            if (IsInitialized)
            {
                view.BeginInit();
                view.EndInit();
            }
        }

        /// <summary>
        /// Adds the specified views (children) to the view.
        /// </summary>
        /// <param name="views">Array of one or more views (can be optional parameter).</param>
        /// <remarks>
        /// The Views that have been added to this view can be retrieved via the <see cref="Subviews"/> property. 
        /// See also <seealso cref="Remove(View)"/> <seealso cref="RemoveAll"/> 
        /// </remarks>
        public void Add(params View[] views)
        {
            if (views == null)
                return;
            foreach (var view in views)
                Add(view);
        }

        /// <summary>
        ///   Removes all subviews (children) added via <see cref="Add(View)"/> or <see cref="Add(View[])"/> from this View.
        /// </summary>
        public virtual void RemoveAll()
        {
            if (subviews == null)
                return;

            while (subviews.Count > 0)
            {
                Remove(subviews[0]);
            }
        }

        /// <summary>
        ///   Removes a subview added via <see cref="Add(View)"/> or <see cref="Add(View[])"/> from this View.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public virtual void Remove(View view)
        {
            if (view == null || subviews == null)
                return;

            var touched = view.Frame;
            subviews.Remove(view);
            tabIndexes.Remove(view);
            view.container = null;
            view.tabIndex = -1;
            SetNeedsLayout();
            SetNeedsDisplay();
            foreach (var v in subviews)
            {
                if (v.Frame.IntersectsWith(touched))
                    view.SetNeedsDisplay();
            }
            OnRemoved(view);
            if (focused == view)
            {
                focused = null;
            }
        }

        void PerformActionForSubview(View subview, Action<View> action)
        {
            if (subviews.Contains(subview))
            {
                action(subview);
            }

            SetNeedsDisplay();
            subview.SetNeedsDisplay();
        }

        /// <summary>
        /// Brings the specified subview to the front so it is drawn on top of any other views.
        /// </summary>
        /// <param name="subview">The subview to send to the front</param>
        /// <remarks>
        ///   <seealso cref="SendSubviewToBack"/>.
        /// </remarks>
        public void BringSubviewToFront(View subview)
        {
            PerformActionForSubview(subview, x =>
            {
                subviews.Remove(x);
                subviews.Add(x);
            });
        }

        /// <summary>
        /// Sends the specified subview to the front so it is the first view drawn
        /// </summary>
        /// <param name="subview">The subview to send to the front</param>
        /// <remarks>
        ///   <seealso cref="BringSubviewToFront(View)"/>.
        /// </remarks>
        public void SendSubviewToBack(View subview)
        {
            PerformActionForSubview(subview, x =>
            {
                subviews.Remove(x);
                subviews.Insert(0, subview);
            });
        }

        /// <summary>
        /// Moves the subview backwards in the hierarchy, only one step
        /// </summary>
        /// <param name="subview">The subview to send backwards</param>
        /// <remarks>
        /// If you want to send the view all the way to the back use SendSubviewToBack.
        /// </remarks>
        public void SendSubviewBackwards(View subview)
        {
            PerformActionForSubview(subview, x =>
            {
                var idx = subviews.IndexOf(x);
                if (idx > 0)
                {
                    subviews.Remove(x);
                    subviews.Insert(idx - 1, x);
                }
            });
        }

        /// <summary>
        /// Moves the subview backwards in the hierarchy, only one step
        /// </summary>
        /// <param name="subview">The subview to send backwards</param>
        /// <remarks>
        /// If you want to send the view all the way to the back use SendSubviewToBack.
        /// </remarks>
        public void BringSubviewForward(View subview)
        {
            PerformActionForSubview(subview, x =>
            {
                var idx = subviews.IndexOf(x);
                if (idx + 1 < subviews.Count)
                {
                    subviews.Remove(x);
                    subviews.Insert(idx + 1, x);
                }
            });
        }

        /// <summary>
        ///   Clears the view region with the current color.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     This clears the entire region used by this view.
        ///   </para>
        /// </remarks>
        public void Clear()
        {
            var h = Frame.Height;
            var w = Frame.Width;
            for (var line = 0; line < h; line++)
            {
                Move(0, line);
                for (var col = 0; col < w; col++)
                    Driver.AddRune(' ');
            }
        }

        /// <summary>
        ///   Clears the specified region with the current color. 
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="regionScreen">The screen-relative region to clear.</param>
        public void Clear(Rect regionScreen)
        {
            var h = regionScreen.Height;
            var w = regionScreen.Width;
            for (var line = regionScreen.Y; line < regionScreen.Y + h; line++)
            {
                Driver.Move(regionScreen.X, line);
                for (var col = 0; col < w; col++)
                    Driver.AddRune(' ');
            }
        }

        /// <summary>
        /// Converts a view-relative (col,row) position to a screen-relative position (col,row). The values are optionally clamped to the screen dimensions.
        /// </summary>
        /// <param name="col">View-relative column.</param>
        /// <param name="row">View-relative row.</param>
        /// <param name="rcol">Absolute column; screen-relative.</param>
        /// <param name="rrow">Absolute row; screen-relative.</param>
        /// <param name="clipped">Whether to clip the result of the ViewToScreen method, if set to <see langword="true"/>, the rcol, rrow values are clamped to the screen (terminal) dimensions (0..TerminalDim-1).</param>
        internal void ViewToScreen(int col, int row, out int rcol, out int rrow, bool clipped = false)
        {
            // Computes the real row, col relative to the screen.
            rrow = row + frame.Y;
            rcol = col + frame.X;

            var curContainer = container;
            while (curContainer != null)
            {
                rrow += curContainer.frame.Y;
                rcol += curContainer.frame.X;
                curContainer = curContainer.container;
            }

            // The following ensures that the cursor is always in the screen boundaries.
            if (clipped)
            {
                rrow = Math.Min(rrow, Driver.Rows - 1);
                rcol = Math.Min(rcol, Driver.Cols - 1);
            }
        }

        /// <summary>
        /// Converts a point from screen-relative coordinates to view-relative coordinates.
        /// </summary>
        /// <returns>The mapped point.</returns>
        /// <param name="x">X screen-coordinate point.</param>
        /// <param name="y">Y screen-coordinate point.</param>
        public Point ScreenToView(int x, int y)
        {
            if (SuperView == null)
            {
                return new Point(x - Frame.X, y - frame.Y);
            }
            else
            {
                var parent = SuperView.ScreenToView(x, y);
                return new Point(parent.X - frame.X, parent.Y - frame.Y);
            }
        }

        /// <summary>
        /// Converts a region in view-relative coordinates to screen-relative coordinates.
        /// </summary>
        internal Rect ViewToScreen(Rect region)
        {
            ViewToScreen(region.X, region.Y, out var x, out var y, clipped: false);
            return new Rect(x, y, region.Width, region.Height);
        }

        // Clips a rectangle in screen coordinates to the dimensions currently available on the screen
        internal Rect ScreenClip(Rect regionScreen)
        {
            var x = regionScreen.X < 0 ? 0 : regionScreen.X;
            var y = regionScreen.Y < 0 ? 0 : regionScreen.Y;
            var w = regionScreen.X + regionScreen.Width >= Driver.Cols ? Driver.Cols - regionScreen.X : regionScreen.Width;
            var h = regionScreen.Y + regionScreen.Height >= Driver.Rows ? Driver.Rows - regionScreen.Y : regionScreen.Height;

            return new Rect(x, y, w, h);
        }

        /// <summary>
        /// Sets the <see cref="ConsoleDriver"/>'s clip region to the current View's <see cref="Bounds"/>.
        /// </summary>
        /// <returns>The existing driver's clip region, which can be then re-applied by setting <c><see cref="Driver"/>.Clip</c> (<see cref="ConsoleDriver.Clip"/>).</returns>
        /// <remarks>
        /// <see cref="Bounds"/> is View-relative.
        /// </remarks>
        public Rect ClipToBounds()
        {
            return SetClip(Bounds);
        }

        /// <summary>
        /// Sets the clip region to the specified view-relative region.
        /// </summary>
        /// <returns>The previous screen-relative clip region.</returns>
        /// <param name="region">View-relative clip region.</param>
        public Rect SetClip(Rect region)
        {
            var previous = Driver.Clip;
            Driver.Clip = Rect.Intersect(previous, ViewToScreen(region));
            return previous;
        }

        /// <summary>
        /// Draws a frame in the current view, clipped by the boundary of this view
        /// </summary>
        /// <param name="region">View-relative region for the frame to be drawn.</param>
        /// <param name="padding">The padding to add around the outside of the drawn frame.</param>
        /// <param name="fill">If set to <see langword="true"/> it fill will the contents.</param>
        public void DrawFrame(Rect region, int padding = 0, bool fill = false)
        {
            var scrRect = ViewToScreen(region);
            var savedClip = ClipToBounds();
            Driver.DrawWindowFrame(scrRect, padding + 1, padding + 1, padding + 1, padding + 1, border: true, fill: fill);
            Driver.Clip = savedClip;
        }

        /// <summary>
        /// Utility function to draw strings that contain a hotkey.
        /// </summary>
        /// <param name="text">String to display, the hotkey specifier before a letter flags the next letter as the hotkey.</param>
        /// <param name="hotColor">Hot color.</param>
        /// <param name="normalColor">Normal color.</param>
        /// <remarks>
        /// <para>The hotkey is any character following the hotkey specifier, which is the underscore ('_') character by default.</para>
        /// <para>The hotkey specifier can be changed via <see cref="HotKeySpecifier"/></para>
        /// </remarks>
        public void DrawHotString(ustring text, Attribute hotColor, Attribute normalColor)
        {
            var hotkeySpec = HotKeySpecifier == (Rune)0xffff ? (Rune)'_' : HotKeySpecifier;
            Application.Driver.SetAttribute(normalColor);
            foreach (var rune in text)
            {
                if (rune == hotkeySpec)
                {
                    Application.Driver.SetAttribute(hotColor);
                    continue;
                }
                Application.Driver.AddRune(rune);
                Application.Driver.SetAttribute(normalColor);
            }
        }

        /// <summary>
        /// Utility function to draw strings that contains a hotkey using a <see cref="ColorScheme"/> and the "focused" state.
        /// </summary>
        /// <param name="text">String to display, the underscore before a letter flags the next letter as the hotkey.</param>
        /// <param name="focused">If set to <see langword="true"/> this uses the focused colors from the color scheme, otherwise the regular ones.</param>
        /// <param name="scheme">The color scheme to use.</param>
        public void DrawHotString(ustring text, bool focused, ColorScheme scheme)
        {
            if (focused)
                DrawHotString(text, scheme.HotFocus, scheme.Focus);
            else
                DrawHotString(text, Enabled ? scheme.HotNormal : scheme.Disabled, Enabled ? scheme.Normal : scheme.Disabled);
        }

        /// <summary>
        /// This moves the cursor to the specified column and row in the view.
        /// </summary>
        /// <returns>The move.</returns>
        /// <param name="col">Col.</param>
        /// <param name="row">Row.</param>
        /// <param name="clipped">Whether to clip the result of the ViewToScreen method,
        ///  if set to <see langword="true"/>, the col, row values are clamped to the screen (terminal) dimensions (0..TerminalDim-1).</param>
        public void Move(int col, int row, bool clipped = false)
        {
            if (Driver.Rows == 0)
            {
                return;
            }

            ViewToScreen(col, row, out var rCol, out var rRow, clipped);
            Driver.Move(rCol, rRow);
        }

        /// <summary>
        ///   Positions the cursor in the right position based on the currently focused view in the chain.
        /// </summary>
        ///    Views that are focusable should override <see cref="PositionCursor"/> to ensure
        ///    the cursor is placed in a location that makes sense. Unix terminals do not have
        ///    a way of hiding the cursor, so it can be distracting to have the cursor left at
        ///    the last focused view. Views should make sure that they place the cursor
        ///    in a visually sensible place.
        public virtual void PositionCursor()
        {
            if (!CanBeVisible(this) || !Enabled)
            {
                return;
            }

            if (focused == null && SuperView != null)
            {
                SuperView.EnsureFocus();
            }
            else if (focused?.Visible == true && focused?.Enabled == true && focused?.Frame.Width > 0 && focused.Frame.Height > 0)
            {
                focused.PositionCursor();
            }
            else if (focused?.Visible == true && focused?.Enabled == false)
            {
                focused = null;
            }
            else if (CanFocus && HasFocus && Visible && Frame.Width > 0 && Frame.Height > 0)
            {
                Move(TextFormatter.HotKeyPos == -1 ? 0 : TextFormatter.CursorPosition, 0);
            }
            else
            {
                Move(frame.X, frame.Y);
            }
        }

        bool hasFocus;

        /// <inheritdoc/>
        public override bool HasFocus => hasFocus;

        void SetHasFocus(bool value, View view, bool force = false)
        {
            if (hasFocus != value || force)
            {
                hasFocus = value;
                if (value)
                {
                    OnEnter(view);
                }
                else
                {
                    OnLeave(view);
                }
                SetNeedsDisplay();
            }

            // Remove focus down the chain of subviews if focus is removed
            if (!value && focused != null)
            {
                var f = focused;
                f.OnLeave(view);
                f.SetHasFocus(false, view);
                focused = null;
            }
        }

        /// <summary>
        /// Defines the event arguments for <see cref="SetFocus(View)"/>
        /// </summary>
        public class FocusEventArgs : EventArgs
        {
            /// <summary>
            /// Constructs.
            /// </summary>
            /// <param name="view">The view that gets or loses focus.</param>
            public FocusEventArgs(View view) { View = view; }
            /// <summary>
            /// Indicates if the current focus event has already been processed and the driver should stop notifying any other event subscriber.
            /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
            /// </summary>
            public bool Handled { get; set; }
            /// <summary>
            /// Indicates the current view that gets or loses focus.
            /// </summary>
            public View View { get; set; }
        }

        /// <summary>
        /// Method invoked when a subview is being added to this view.
        /// </summary>
        /// <param name="view">The subview being added.</param>
        public virtual void OnAdded(View view)
        {
            view.IsAdded = true;
            view.x = view.x ?? view.frame.X;
            view.y = view.y ?? view.frame.Y;
            view.width = view.width ?? view.frame.Width;
            view.height = view.height ?? view.frame.Height;

            view.Added?.Invoke(this);
        }

        /// <summary>
        /// Method invoked when a subview is being removed from this view.
        /// </summary>
        /// <param name="view">The subview being removed.</param>
        public virtual void OnRemoved(View view)
        {
            view.IsAdded = false;
            view.Removed?.Invoke(this);
        }

        /// <inheritdoc/>
        public override bool OnEnter(View view)
        {
            var args = new FocusEventArgs(view);
            Enter?.Invoke(args);
            if (args.Handled)
                return true;
            if (base.OnEnter(view))
                return true;

            return false;
        }

        /// <inheritdoc/>
        public override bool OnLeave(View view)
        {
            var args = new FocusEventArgs(view);
            Leave?.Invoke(args);
            if (args.Handled)
                return true;
            if (base.OnLeave(view))
                return true;

            return false;
        }

        /// <summary>
        /// Returns the currently focused view inside this view, or null if nothing is focused.
        /// </summary>
        /// <value>The focused.</value>
        public View Focused => focused;

        /// <summary>
        /// Returns the most focused view in the chain of subviews (the leaf view that has the focus).
        /// </summary>
        /// <value>The most focused View.</value>
        public View MostFocused
        {
            get
            {
                if (Focused == null)
                    return null;
                var most = Focused.MostFocused;
                if (most != null)
                    return most;
                return Focused;
            }
        }

        ColorScheme colorScheme;

        /// <summary>
        /// The color scheme for this view, if it is not defined, it returns the <see cref="SuperView"/>'s
        /// color scheme.
        /// </summary>
        public virtual ColorScheme ColorScheme
        {
            get
            {
                if (colorScheme == null)
                {
                    return SuperView?.ColorScheme;
                }
                return colorScheme;
            }
            set
            {
                if (colorScheme != value)
                {
                    colorScheme = value;
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Displays the specified character in the specified column and row of the View.
        /// </summary>
        /// <param name="col">Column (view-relative).</param>
        /// <param name="row">Row (view-relative).</param>
        /// <param name="ch">Ch.</param>
        public void AddRune(int col, int row, Rune ch)
        {
            if (row < 0 || col < 0)
                return;
            if (row > frame.Height - 1 || col > frame.Width - 1)
                return;
            Move(col, row);
            Driver.AddRune(ch);
        }

        /// <summary>
        /// Removes the <see cref="SetNeedsDisplay()"/> and the <see cref="ChildNeedsDisplay"/> setting on this view.
        /// </summary>
        protected void ClearNeedsDisplay()
        {
            NeedDisplay = Rect.Empty;
            ChildNeedsDisplay = false;
        }

        /// <summary>
        /// Redraws this view and its subviews; only redraws the views that have been flagged for a re-display.
        /// </summary>
        /// <param name="bounds">The bounds (view-relative region) to redraw.</param>
        /// <remarks>
        /// <para>
        ///    Always use <see cref="Bounds"/> (view-relative) when calling <see cref="Redraw(Rect)"/>, NOT <see cref="Frame"/> (superview-relative).
        /// </para>
        /// <para>
        ///    Views should set the color that they want to use on entry, as otherwise this will inherit
        ///    the last color that was set globally on the driver.
        /// </para>
        /// <para>
        ///    Overrides of <see cref="Redraw"/> must ensure they do not set <c>Driver.Clip</c> to a clip region
        ///    larger than the <ref name="bounds"/> parameter, as this will cause the driver to clip the entire region.
        /// </para>
        /// </remarks>
        public virtual void Redraw(Rect bounds)
        {
            if (!CanBeVisible(this))
            {
                return;
            }

            var clipRect = new Rect(Point.Empty, frame.Size);

            if (ColorScheme != null)
            {
                Driver.SetAttribute(HasFocus ? GetFocusColor() : GetNormalColor());
            }

            if (!IgnoreBorderPropertyOnRedraw && Border != null)
            {
                Border.DrawContent(this);
            }
            else if (ustring.IsNullOrEmpty(TextFormatter.Text) &&
              (GetType().IsNestedPublic && !IsOverridden(this, "Redraw") || GetType().Name == "View") &&
              (!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded))
            {

                if (ColorScheme != null)
                {
                    Driver.SetAttribute(GetNormalColor());
                    Clear();
                    SetChildNeedsDisplay();
                }
            }

            if (!ustring.IsNullOrEmpty(TextFormatter.Text))
            {
                Rect containerBounds = GetContainerBounds();
                Clear(ViewToScreen(GetNeedDisplay(containerBounds)));
                SetChildNeedsDisplay();
                // Draw any Text
                if (TextFormatter != null)
                {
                    TextFormatter.NeedsFormat = true;
                }
                TextFormatter?.Draw(ViewToScreen(Bounds), HasFocus ? GetFocusColor() : GetNormalColor(),
                    HasFocus ? ColorScheme.HotFocus : GetHotNormalColor(),
                    containerBounds);
            }

            // Invoke DrawContentEvent
            OnDrawContent(bounds);

            if (subviews != null)
            {
                foreach (var view in subviews)
                {
                    if (!view.NeedDisplay.IsEmpty || view.ChildNeedsDisplay || view.LayoutNeeded)
                    {
                        if (view.Frame.IntersectsWith(clipRect) && (view.Frame.IntersectsWith(bounds) || bounds.X < 0 || bounds.Y < 0))
                        {
                            if (view.LayoutNeeded)
                                view.LayoutSubviews();

                            // Draw the subview
                            // Use the view's bounds (view-relative; Location will always be (0,0)
                            if (view.Visible && view.Frame.Width > 0 && view.Frame.Height > 0)
                            {
                                var rect = view.Bounds;
                                view.OnDrawContent(rect);
                                view.Redraw(rect);
                                view.OnDrawContentComplete(rect);
                            }
                        }
                        view.NeedDisplay = Rect.Empty;
                        view.ChildNeedsDisplay = false;
                    }
                }
            }

            // Invoke DrawContentCompleteEvent
            OnDrawContentComplete(bounds);

            ClearLayoutNeeded();
            ClearNeedsDisplay();
        }

        Rect GetNeedDisplay(Rect containerBounds)
        {
            Rect rect = NeedDisplay;
            if (!containerBounds.IsEmpty)
            {
                rect.Width = Math.Min(NeedDisplay.Width, containerBounds.Width);
                rect.Height = Math.Min(NeedDisplay.Height, containerBounds.Height);
            }

            return rect;
        }

        Rect GetContainerBounds()
        {
            var containerBounds = SuperView == null ? default : SuperView.ViewToScreen(SuperView.Bounds);
            var driverClip = Driver == null ? Rect.Empty : Driver.Clip;
            containerBounds.X = Math.Max(containerBounds.X, driverClip.X);
            containerBounds.Y = Math.Max(containerBounds.Y, driverClip.Y);
            var lenOffset = (driverClip.X + driverClip.Width) - (containerBounds.X + containerBounds.Width);
            if (containerBounds.X + containerBounds.Width > driverClip.X + driverClip.Width)
            {
                containerBounds.Width = Math.Max(containerBounds.Width + lenOffset, 0);
            }
            else
            {
                containerBounds.Width = Math.Min(containerBounds.Width, driverClip.Width);
            }
            lenOffset = (driverClip.Y + driverClip.Height) - (containerBounds.Y + containerBounds.Height);
            if (containerBounds.Y + containerBounds.Height > driverClip.Y + driverClip.Height)
            {
                containerBounds.Height = Math.Max(containerBounds.Height + lenOffset, 0);
            }
            else
            {
                containerBounds.Height = Math.Min(containerBounds.Height, driverClip.Height);
            }
            return containerBounds;
        }

        /// <summary>
        /// Event invoked when the content area of the View is to be drawn.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Will be invoked before any subviews added with <see cref="Add(View)"/> have been drawn.
        /// </para>
        /// <para>
        /// Rect provides the view-relative rectangle describing the currently visible viewport into the <see cref="View"/>.
        /// </para>
        /// </remarks>
        public event Action<Rect> DrawContent;

        /// <summary>
        /// Enables overrides to draw infinitely scrolled content and/or a background behind added controls. 
        /// </summary>
        /// <param name="viewport">The view-relative rectangle describing the currently visible viewport into the <see cref="View"/></param>
        /// <remarks>
        /// This method will be called before any subviews added with <see cref="Add(View)"/> have been drawn. 
        /// </remarks>
        public virtual void OnDrawContent(Rect viewport)
        {
            DrawContent?.Invoke(viewport);
        }

        /// <summary>
        /// Event invoked when the content area of the View is completed drawing.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Will be invoked after any subviews removed with <see cref="Remove(View)"/> have been completed drawing.
        /// </para>
        /// <para>
        /// Rect provides the view-relative rectangle describing the currently visible viewport into the <see cref="View"/>.
        /// </para>
        /// </remarks>
        public event Action<Rect> DrawContentComplete;

        /// <summary>
        /// Enables overrides after completed drawing infinitely scrolled content and/or a background behind removed controls.
        /// </summary>
        /// <param name="viewport">The view-relative rectangle describing the currently visible viewport into the <see cref="View"/></param>
        /// <remarks>
        /// This method will be called after any subviews removed with <see cref="Remove(View)"/> have been completed drawing.
        /// </remarks>
        public virtual void OnDrawContentComplete(Rect viewport)
        {
            DrawContentComplete?.Invoke(viewport);
        }

        /// <summary>
        /// Causes the specified subview to have focus.
        /// </summary>
        /// <param name="view">View.</param>
        void SetFocus(View view)
        {
            if (view == null)
                return;
            //Console.WriteLine ($"Request to focus {view}");
            if (!view.CanFocus || !view.Visible || !view.Enabled)
                return;
            if (focused?.hasFocus == true && focused == view)
                return;

            // Make sure that this view is a subview
            View c;
            for (c = view.container; c != null; c = c.container)
                if (c == this)
                    break;
            if (c == null)
                throw new ArgumentException("the specified view is not part of the hierarchy of this view");

            if (focused != null)
                focused.SetHasFocus(false, view);

            var f = focused;
            focused = view;
            focused.SetHasFocus(true, f);
            focused.EnsureFocus();

            // Send focus upwards
            SuperView?.SetFocus(this);
        }

        /// <summary>
        /// Causes the specified view and the entire parent hierarchy to have the focused order updated.
        /// </summary>
        public void SetFocus()
        {
            if (!CanBeVisible(this) || !Enabled)
            {
                if (HasFocus)
                {
                    SetHasFocus(false, this);
                }
                return;
            }

            SuperView?.SetFocus(this);
        }

        /// <summary>
        /// Defines the event arguments for <see cref="KeyEvent"/>
        /// </summary>
        public class KeyEventEventArgs : EventArgs
        {
            /// <summary>
            /// Constructs.
            /// </summary>
            /// <param name="ke"></param>
            public KeyEventEventArgs(KeyEvent ke) => KeyEvent = ke;
            /// <summary>
            /// The <see cref="KeyEvent"/> for the event.
            /// </summary>
            public KeyEvent KeyEvent { get; set; }
            /// <summary>
            /// Indicates if the current Key event has already been processed and the driver should stop notifying any other event subscriber.
            /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
            /// </summary>
            public bool Handled { get; set; } = false;
        }

        /// <summary>
        /// Invoked when a character key is pressed and occurs after the key up event.
        /// </summary>
        public event Action<KeyEventEventArgs> KeyPress;

        /// <inheritdoc/>
        public override bool ProcessKey(KeyEvent keyEvent)
        {
            if (!Enabled)
            {
                return false;
            }

            var args = new KeyEventEventArgs(keyEvent);
            KeyPress?.Invoke(args);
            if (args.Handled)
                return true;
            if (Focused?.Enabled == true)
            {
                Focused?.KeyPress?.Invoke(args);
                if (args.Handled)
                    return true;
            }

            return Focused?.Enabled == true && Focused?.ProcessKey(keyEvent) == true;
        }

        /// <summary>
        /// Invokes any binding that is registered on this <see cref="View"/>
        /// and matches the <paramref name="keyEvent"/>
        /// </summary>
        /// <param name="keyEvent">The key event passed.</param>
        protected bool? InvokeKeybindings(KeyEvent keyEvent)
        {
            bool? toReturn = null;

            if (KeyBindings.ContainsKey(keyEvent.Key))
            {

                foreach (var command in KeyBindings[keyEvent.Key])
                {

                    if (!CommandImplementations.ContainsKey(command))
                    {
                        throw new NotSupportedException($"A KeyBinding was set up for the command {command} ({keyEvent.Key}) but that command is not supported by this View ({GetType().Name})");
                    }

                    // each command has its own return value
                    var thisReturn = CommandImplementations[command]();

                    // if we haven't got anything yet, the current command result should be used
                    if (toReturn == null)
                    {
                        toReturn = thisReturn;
                    }

                    // if ever see a true then that's what we will return
                    if (thisReturn ?? false)
                    {
                        toReturn = true;
                    }
                }
            }

            return toReturn;
        }


        /// <summary>
        /// <para>Adds a new key combination that will trigger the given <paramref name="command"/>
        /// (if supported by the View - see <see cref="GetSupportedCommands"/>)
        /// </para>
        /// <para>If the key is already bound to a different <see cref="Command"/> it will be
        /// rebound to this one</para>
        /// <remarks>Commands are only ever applied to the current <see cref="View"/>(i.e. this feature
        /// cannot be used to switch focus to another view and perform multiple commands there) </remarks>
        /// </summary>
        /// <param name="key"></param>
        /// <param name="command">The command(s) to run on the <see cref="View"/> when <paramref name="key"/> is pressed.
        /// When specifying multiple commands, all commands will be applied in sequence. The bound <paramref name="key"/> strike
        /// will be consumed if any took effect.</param>
        public void AddKeyBinding(Key key, params Command[] command)
        {
            if (command.Length == 0)
            {
                throw new ArgumentException("At least one command must be specified", nameof(command));
            }

            if (KeyBindings.ContainsKey(key))
            {
                KeyBindings[key] = command;
            }
            else
            {
                KeyBindings.Add(key, command);
            }
        }

        /// <summary>
        /// Replaces a key combination already bound to <see cref="Command"/>.
        /// </summary>
        /// <param name="fromKey">The key to be replaced.</param>
        /// <param name="toKey">The new key to be used.</param>
        protected void ReplaceKeyBinding(Key fromKey, Key toKey)
        {
            if (KeyBindings.ContainsKey(fromKey))
            {
                var value = KeyBindings[fromKey];
                KeyBindings.Remove(fromKey);
                KeyBindings[toKey] = value;
            }
        }

        /// <summary>
        /// Checks if the key binding already exists.
        /// </summary>
        /// <param name="key">The key to check.</param>
        /// <returns><see langword="true"/> If the key already exist, <see langword="false"/> otherwise.</returns>
        public bool ContainsKeyBinding(Key key)
        {
            return KeyBindings.ContainsKey(key);
        }

        /// <summary>
        /// Removes all bound keys from the View and resets the default bindings.
        /// </summary>
        public void ClearKeybindings()
        {
            KeyBindings.Clear();
        }

        /// <summary>
        /// Clears the existing keybinding (if any) for the given <paramref name="key"/>.
        /// </summary>
        /// <param name="key"></param>
        public void ClearKeybinding(Key key)
        {
            KeyBindings.Remove(key);
        }

        /// <summary>
        /// Removes all key bindings that trigger the given command. Views can have multiple different
        /// keys bound to the same command and this method will clear all of them.
        /// </summary>
        /// <param name="command"></param>
        public void ClearKeybinding(params Command[] command)
        {
            foreach (var kvp in KeyBindings.Where(kvp => kvp.Value.SequenceEqual(command)).ToArray())
            {
                KeyBindings.Remove(kvp.Key);
            }
        }

        /// <summary>
        /// <para>States that the given <see cref="View"/> supports a given <paramref name="command"/>
        /// and what <paramref name="f"/> to perform to make that command happen
        /// </para>
        /// <para>If the <paramref name="command"/> already has an implementation the <paramref name="f"/>
        /// will replace the old one</para>
        /// </summary>
        /// <param name="command">The command.</param>
        /// <param name="f">The function.</param>
        protected void AddCommand(Command command, Func<bool?> f)
        {
            // if there is already an implementation of this command
            if (CommandImplementations.ContainsKey(command))
            {
                // replace that implementation
                CommandImplementations[command] = f;
            }
            else
            {
                // else record how to perform the action (this should be the normal case)
                CommandImplementations.Add(command, f);
            }
        }

        /// <summary>
        /// Returns all commands that are supported by this <see cref="View"/>.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<Command> GetSupportedCommands()
        {
            return CommandImplementations.Keys;
        }

        /// <summary>
        /// Gets the key used by a command.
        /// </summary>
        /// <param name="command">The command to search.</param>
        /// <returns>The <see cref="Key"/> used by a <see cref="Command"/></returns>
        public Key GetKeyFromCommand(params Command[] command)
        {
            return KeyBindings.First(kb => kb.Value.SequenceEqual(command)).Key;
        }

        /// <inheritdoc/>
        public override bool ProcessHotKey(KeyEvent keyEvent)
        {
            if (!Enabled)
            {
                return false;
            }

            var args = new KeyEventEventArgs(keyEvent);
            if (MostFocused?.Enabled == true)
            {
                MostFocused?.KeyPress?.Invoke(args);
                if (args.Handled)
                    return true;
            }
            if (MostFocused?.Enabled == true && MostFocused?.ProcessKey(keyEvent) == true)
                return true;
            if (subviews == null || subviews.Count == 0)
                return false;

            foreach (var view in subviews)
                if (view.Enabled && view.ProcessHotKey(keyEvent))
                    return true;
            return false;
        }

        /// <inheritdoc/>
        public override bool ProcessColdKey(KeyEvent keyEvent)
        {
            if (!Enabled)
            {
                return false;
            }

            var args = new KeyEventEventArgs(keyEvent);
            KeyPress?.Invoke(args);
            if (args.Handled)
                return true;
            if (MostFocused?.Enabled == true)
            {
                MostFocused?.KeyPress?.Invoke(args);
                if (args.Handled)
                    return true;
            }
            if (MostFocused?.Enabled == true && MostFocused?.ProcessKey(keyEvent) == true)
                return true;
            if (subviews == null || subviews.Count == 0)
                return false;

            foreach (var view in subviews)
                if (view.Enabled && view.ProcessColdKey(keyEvent))
                    return true;
            return false;
        }

        /// <summary>
        /// Invoked when a key is pressed.
        /// </summary>
        public event Action<KeyEventEventArgs> KeyDown;

        /// <inheritdoc/>
        public override bool OnKeyDown(KeyEvent keyEvent)
        {
            if (!Enabled)
            {
                return false;
            }

            var args = new KeyEventEventArgs(keyEvent);
            KeyDown?.Invoke(args);
            if (args.Handled)
            {
                return true;
            }
            if (Focused?.Enabled == true)
            {
                Focused.KeyDown?.Invoke(args);
                if (args.Handled)
                {
                    return true;
                }
                if (Focused?.OnKeyDown(keyEvent) == true)
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Invoked when a key is released.
        /// </summary>
        public event Action<KeyEventEventArgs> KeyUp;

        /// <inheritdoc/>
        public override bool OnKeyUp(KeyEvent keyEvent)
        {
            if (!Enabled)
            {
                return false;
            }

            var args = new KeyEventEventArgs(keyEvent);
            KeyUp?.Invoke(args);
            if (args.Handled)
            {
                return true;
            }
            if (Focused?.Enabled == true)
            {
                Focused.KeyUp?.Invoke(args);
                if (args.Handled)
                {
                    return true;
                }
                if (Focused?.OnKeyUp(keyEvent) == true)
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Finds the first view in the hierarchy that wants to get the focus if nothing is currently focused, otherwise, does nothing.
        /// </summary>
        public void EnsureFocus()
        {
            if (focused == null && subviews?.Count > 0)
            {
                if (FocusDirection == Direction.Forward)
                {
                    FocusFirst();
                }
                else
                {
                    FocusLast();
                }
            }
        }

        /// <summary>
        /// Focuses the first focusable subview if one exists.
        /// </summary>
        public void FocusFirst()
        {
            if (!CanBeVisible(this))
            {
                return;
            }

            if (tabIndexes == null)
            {
                SuperView?.SetFocus(this);
                return;
            }

            foreach (var view in tabIndexes)
            {
                if (view.CanFocus && view.tabStop && view.Visible && view.Enabled)
                {
                    SetFocus(view);
                    return;
                }
            }
        }

        /// <summary>
        /// Focuses the last focusable subview if one exists.
        /// </summary>
        public void FocusLast()
        {
            if (!CanBeVisible(this))
            {
                return;
            }

            if (tabIndexes == null)
            {
                SuperView?.SetFocus(this);
                return;
            }

            for (var i = tabIndexes.Count; i > 0;)
            {
                i--;

                var v = tabIndexes[i];
                if (v.CanFocus && v.tabStop && v.Visible && v.Enabled)
                {
                    SetFocus(v);
                    return;
                }
            }
        }

        /// <summary>
        /// Focuses the previous view.
        /// </summary>
        /// <returns><see langword="true"/> if previous was focused, <see langword="false"/> otherwise.</returns>
        public bool FocusPrev()
        {
            if (!CanBeVisible(this))
            {
                return false;
            }

            FocusDirection = Direction.Backward;
            if (tabIndexes == null || tabIndexes.Count == 0)
                return false;

            if (focused == null)
            {
                FocusLast();
                return focused != null;
            }

            var focusedIdx = -1;
            for (var i = tabIndexes.Count; i > 0;)
            {
                i--;
                var w = tabIndexes[i];

                if (w.HasFocus)
                {
                    if (w.FocusPrev())
                        return true;
                    focusedIdx = i;
                    continue;
                }
                if (w.CanFocus && focusedIdx != -1 && w.tabStop && w.Visible && w.Enabled)
                {
                    focused.SetHasFocus(false, w);

                    if (w.CanFocus && w.tabStop && w.Visible && w.Enabled)
                        w.FocusLast();

                    SetFocus(w);
                    return true;
                }
            }
            if (focused != null)
            {
                focused.SetHasFocus(false, this);
                focused = null;
            }
            return false;
        }

        /// <summary>
        /// Focuses the next view.
        /// </summary>
        /// <returns><see langword="true"/> if next was focused, <see langword="false"/> otherwise.</returns>
        public bool FocusNext()
        {
            if (!CanBeVisible(this))
            {
                return false;
            }

            FocusDirection = Direction.Forward;
            if (tabIndexes == null || tabIndexes.Count == 0)
                return false;

            if (focused == null)
            {
                FocusFirst();
                return focused != null;
            }
            var n = tabIndexes.Count;
            var focusedIdx = -1;
            for (var i = 0; i < n; i++)
            {
                var w = tabIndexes[i];

                if (w.HasFocus)
                {
                    if (w.FocusNext())
                        return true;
                    focusedIdx = i;
                    continue;
                }
                if (w.CanFocus && focusedIdx != -1 && w.tabStop && w.Visible && w.Enabled)
                {
                    focused.SetHasFocus(false, w);

                    if (w.CanFocus && w.tabStop && w.Visible && w.Enabled)
                        w.FocusFirst();

                    SetFocus(w);
                    return true;
                }
            }
            if (focused != null)
            {
                focused.SetHasFocus(false, this);
                focused = null;
            }
            return false;
        }

        View GetMostFocused(View view)
        {
            if (view == null)
            {
                return null;
            }

            return view.focused != null ? GetMostFocused(view.focused) : view;
        }

        /// <summary>
        /// Sets the View's <see cref="Frame"/> to the relative coordinates if its container, given the <see cref="Frame"/> for its container.
        /// </summary>
        /// <param name="hostFrame">The screen-relative frame for the host.</param>
        /// <remarks>
        /// Reminder: <see cref="Frame"/> is superview-relative; <see cref="Bounds"/> is view-relative.
        /// </remarks>
        internal void SetRelativeLayout(Rect hostFrame)
        {
            int actW, actH, actX, actY;
            var s = Size.Empty;

            if (AutoSize)
            {
                s = GetAutoSize();
            }

            if (x is Pos.PosCenter)
            {
                if (width == null)
                {
                    actW = AutoSize ? s.Width : hostFrame.Width;
                }
                else
                {
                    actW = width.Anchor(hostFrame.Width);
                    actW = AutoSize && s.Width > actW ? s.Width : actW;
                }
                actX = x.Anchor(hostFrame.Width - actW);
            }
            else
            {
                actX = x?.Anchor(hostFrame.Width) ?? 0;

                actW = Math.Max(CalculateActualWidth(width, hostFrame, actX, s), 0);
            }

            if (y is Pos.PosCenter)
            {
                if (height == null)
                {
                    actH = AutoSize ? s.Height : hostFrame.Height;
                }
                else
                {
                    actH = height.Anchor(hostFrame.Height);
                    actH = AutoSize && s.Height > actH ? s.Height : actH;
                }
                actY = y.Anchor(hostFrame.Height - actH);
            }
            else
            {
                actY = y?.Anchor(hostFrame.Height) ?? 0;

                actH = Math.Max(CalculateActualHeight(height, hostFrame, actY, s), 0);
            }

            var r = new Rect(actX, actY, actW, actH);
            if (Frame != r)
            {
                Frame = r;
                if (!SetMinWidthHeight())
                    TextFormatter.Size = GetBoundsTextFormatterSize();
            }
        }

        private int CalculateActualWidth(Dim width, Rect hostFrame, int actX, Size s)
        {
            int actW;
            switch (width)
            {
                case null:
                    actW = AutoSize ? s.Width : hostFrame.Width;
                    break;
                case Dim.DimCombine combine:
                    int leftActW = CalculateActualWidth(combine.left, hostFrame, actX, s);
                    int rightActW = CalculateActualWidth(combine.right, hostFrame, actX, s);
                    if (combine.add)
                    {
                        actW = leftActW + rightActW;
                    }
                    else
                    {
                        actW = leftActW - rightActW;
                    }
                    actW = AutoSize && s.Width > actW ? s.Width : actW;
                    break;
                case Dim.DimFactor factor when !factor.IsFromRemaining():
                    actW = width.Anchor(hostFrame.Width);
                    actW = AutoSize && s.Width > actW ? s.Width : actW;
                    break;
                default:
                    actW = Math.Max(width.Anchor(hostFrame.Width - actX), 0);
                    actW = AutoSize && s.Width > actW ? s.Width : actW;
                    break;
            }

            return actW;
        }

        private int CalculateActualHeight(Dim height, Rect hostFrame, int actY, Size s)
        {
            int actH;
            switch (height)
            {
                case null:
                    actH = AutoSize ? s.Height : hostFrame.Height;
                    break;
                case Dim.DimCombine combine:
                    int leftActH = CalculateActualHeight(combine.left, hostFrame, actY, s);
                    int rightActH = CalculateActualHeight(combine.right, hostFrame, actY, s);
                    if (combine.add)
                    {
                        actH = leftActH + rightActH;
                    }
                    else
                    {
                        actH = leftActH - rightActH;
                    }
                    actH = AutoSize && s.Height > actH ? s.Height : actH;
                    break;
                case Dim.DimFactor factor when !factor.IsFromRemaining():
                    actH = height.Anchor(hostFrame.Height);
                    actH = AutoSize && s.Height > actH ? s.Height : actH;
                    break;
                default:
                    actH = Math.Max(height.Anchor(hostFrame.Height - actY), 0);
                    actH = AutoSize && s.Height > actH ? s.Height : actH;
                    break;
            }

            return actH;
        }

        // https://en.wikipedia.org/wiki/Topological_sorting
        List<View> TopologicalSort(IEnumerable<View> nodes, ICollection<(View From, View To)> edges)
        {
            var result = new List<View>();

            // Set of all nodes with no incoming edges
            var noEdgeNodes = new HashSet<View>(nodes.Where(n => edges.All(e => !e.To.Equals(n))));

            while (noEdgeNodes.Any())
            {
                //  remove a node n from S
                var n = noEdgeNodes.First();
                noEdgeNodes.Remove(n);

                // add n to tail of L
                if (n != this?.SuperView)
                    result.Add(n);

                // for each node m with an edge e from n to m do
                foreach (var e in edges.Where(e => e.From.Equals(n)).ToArray())
                {
                    var m = e.To;

                    // remove edge e from the graph
                    edges.Remove(e);

                    // if m has no other incoming edges then
                    if (edges.All(me => !me.To.Equals(m)) && m != this?.SuperView)
                    {
                        // insert m into S
                        noEdgeNodes.Add(m);
                    }
                }
            }

            if (edges.Any())
            {
                (var from, var to) = edges.First();
                if (from != Application.Top)
                {
                    if (!ReferenceEquals(from, to))
                    {
                        throw new InvalidOperationException($"TopologicalSort (for Pos/Dim) cannot find {from} linked with {to}. Did you forget to add it to {this}?");
                    }
                    else
                    {
                        throw new InvalidOperationException("TopologicalSort encountered a recursive cycle in the relative Pos/Dim in the views of " + this);
                    }
                }
            }

            // return L (a topologically sorted order)
            return result;
        }

        /// <summary>
        /// Event arguments for the <see cref="LayoutComplete"/> event.
        /// </summary>
        public class LayoutEventArgs : EventArgs
        {
            /// <summary>
            /// The view-relative bounds of the <see cref="View"/> before it was laid out.
            /// </summary>
            public Rect OldBounds { get; set; }
        }

        /// <summary>
        /// Fired after the View's <see cref="LayoutSubviews"/> method has completed. 
        /// </summary>
        /// <remarks>
        /// Subscribe to this event to perform tasks when the <see cref="View"/> has been resized or the layout has otherwise changed.
        /// </remarks>
        public event Action<LayoutEventArgs> LayoutStarted;

        /// <summary>
        /// Raises the <see cref="LayoutStarted"/> event. Called from  <see cref="LayoutSubviews"/> before any subviews have been laid out.
        /// </summary>
        internal virtual void OnLayoutStarted(LayoutEventArgs args)
        {
            LayoutStarted?.Invoke(args);
        }

        /// <summary>
        /// Fired after the View's <see cref="LayoutSubviews"/> method has completed. 
        /// </summary>
        /// <remarks>
        /// Subscribe to this event to perform tasks when the <see cref="View"/> has been resized or the layout has otherwise changed.
        /// </remarks>
        public event Action<LayoutEventArgs> LayoutComplete;

        /// <summary>
        /// Event called only once when the <see cref="View"/> is being initialized for the first time.
        /// Allows configurations and assignments to be performed before the <see cref="View"/> being shown.
        /// This derived from <see cref="ISupportInitializeNotification"/> to allow notify all the views that are being initialized.
        /// </summary>
        public event EventHandler Initialized;

        /// <summary>
        /// Raises the <see cref="LayoutComplete"/> event. Called from  <see cref="LayoutSubviews"/> before all sub-views have been laid out.
        /// </summary>
        internal virtual void OnLayoutComplete(LayoutEventArgs args)
        {
            LayoutComplete?.Invoke(args);
        }

        /// <summary>
        /// Invoked when a view starts executing or when the dimensions of the view have changed, for example in
        /// response to the container view or terminal resizing.
        /// </summary>
        /// <remarks>
        /// Calls <see cref="OnLayoutComplete"/> (which raises the <see cref="LayoutComplete"/> event) before it returns.
        /// </remarks>
        public virtual void LayoutSubviews()
        {
            if (!LayoutNeeded)
            {
                return;
            }

            var oldBounds = Bounds;
            OnLayoutStarted(new LayoutEventArgs() { OldBounds = oldBounds });

            TextFormatter.Size = GetBoundsTextFormatterSize();


            // Sort out the dependencies of the X, Y, Width, Height properties
            var nodes = new HashSet<View>();
            var edges = new HashSet<(View, View)>();

            void CollectPos(Pos pos, View from, ref HashSet<View> nNodes, ref HashSet<(View, View)> nEdges)
            {
                switch (pos)
                {
                    case Pos.PosView pv:
                        if (pv.Target != this)
                        {
                            nEdges.Add((pv.Target, from));
                        }
                        foreach (var v in from.InternalSubviews)
                        {
                            CollectAll(v, ref nNodes, ref nEdges);
                        }
                        return;
                    case Pos.PosCombine pc:
                        foreach (var v in from.InternalSubviews)
                        {
                            CollectPos(pc.left, from, ref nNodes, ref nEdges);
                            CollectPos(pc.right, from, ref nNodes, ref nEdges);
                        }
                        break;
                }
            }

            void CollectDim(Dim dim, View from, ref HashSet<View> nNodes, ref HashSet<(View, View)> nEdges)
            {
                switch (dim)
                {
                    case Dim.DimView dv:
                        if (dv.Target != this)
                        {
                            nEdges.Add((dv.Target, from));
                        }
                        foreach (var v in from.InternalSubviews)
                        {
                            CollectAll(v, ref nNodes, ref nEdges);
                        }
                        return;
                    case Dim.DimCombine dc:
                        foreach (var v in from.InternalSubviews)
                        {
                            CollectDim(dc.left, from, ref nNodes, ref nEdges);
                            CollectDim(dc.right, from, ref nNodes, ref nEdges);
                        }
                        break;
                }
            }

            void CollectAll(View from, ref HashSet<View> nNodes, ref HashSet<(View, View)> nEdges)
            {
                foreach (var v in from.InternalSubviews)
                {
                    nNodes.Add(v);
                    if (v.layoutStyle != LayoutStyle.Computed)
                    {
                        continue;
                    }
                    CollectPos(v.X, v, ref nNodes, ref nEdges);
                    CollectPos(v.Y, v, ref nNodes, ref nEdges);
                    CollectDim(v.Width, v, ref nNodes, ref nEdges);
                    CollectDim(v.Height, v, ref nNodes, ref nEdges);
                }
            }

            CollectAll(this, ref nodes, ref edges);

            var ordered = TopologicalSort(nodes, edges);

            foreach (var v in ordered)
            {
                if (v.LayoutStyle == LayoutStyle.Computed)
                {
                    v.SetRelativeLayout(v?.SuperView.Frame ?? Frame);
                }

                v.LayoutSubviews();
                v.LayoutNeeded = false;
            }

            if (SuperView != null && SuperView == Application.Top && LayoutNeeded
                && ordered.Count == 0 && LayoutStyle == LayoutStyle.Computed)
            {
                SetRelativeLayout(SuperView.Frame);
            }

            LayoutNeeded = false;

            OnLayoutComplete(new LayoutEventArgs() { OldBounds = oldBounds });
        }

        ustring text;

        /// <summary>
        ///   The text displayed by the <see cref="View"/>.
        /// </summary>
        /// <remarks>
        /// <para>
        ///  If provided, the text will be drawn before any subviews are drawn.
        /// </para>
        /// <para>
        ///  The text will be drawn starting at the view origin (0, 0) and will be formatted according
        ///  to the <see cref="TextAlignment"/> property. If the view's height is greater than 1, the
        ///  text will word-wrap to additional lines if it does not fit horizontally. If the view's height
        ///  is 1, the text will be clipped.
        /// </para>
        /// <para>
        ///  Set the <see cref="HotKeySpecifier"/> to enable hotkey support. To disable hotkey support set <see cref="HotKeySpecifier"/> to
        ///  <c>(Rune)0xffff</c>.
        /// </para>
        /// </remarks>
        public virtual ustring Text
        {
            get => text;
            set
            {
                text = value;
                SetHotKey();
                UpdateTextFormatterText();
                ProcessResizeView();
            }
        }

        /// <summary>
        /// Gets or sets a flag that determines whether the View will be automatically resized to fit the <see cref="Text"/>.
        /// The default is <see langword="false"/>. Set to <see langword="true"/> to turn on AutoSize. If <see cref="AutoSize"/> is <see langword="true"/> the <see cref="Width"/>
        /// and <see cref="Height"/> will always be used if the text size is lower. If the text size is higher the bounds will
        /// be resized to fit it.
        /// In addition, if <see cref="ForceValidatePosDim"/> is <see langword="true"/> the new values of <see cref="Width"/> and
        /// <see cref="Height"/> must be of the same types of the existing one to avoid breaking the <see cref="Dim"/> settings.
        /// </summary>
        public virtual bool AutoSize
        {
            get => autoSize;
            set
            {
                var v = ResizeView(value);
                TextFormatter.AutoSize = v;
                if (autoSize != v)
                {
                    autoSize = v;
                    TextFormatter.NeedsFormat = true;
                    UpdateTextFormatterText();
                    ProcessResizeView();
                }
            }
        }

        /// <summary>
        /// Gets or sets a flag that determines whether <see cref="Terminal.Gui.TextFormatter.Text"/> will have trailing spaces preserved
        /// or not when <see cref="Terminal.Gui.TextFormatter.WordWrap"/> is enabled. If <see langword="true"/> 
        /// any trailing spaces will be trimmed when either the <see cref="Text"/> property is changed or 
        /// when <see cref="Terminal.Gui.TextFormatter.WordWrap"/> is set to <see langword="true"/>.
        /// The default is <see langword="false"/>.
        /// </summary>
        public virtual bool PreserveTrailingSpaces
        {
            get => TextFormatter.PreserveTrailingSpaces;
            set
            {
                if (TextFormatter.PreserveTrailingSpaces != value)
                {
                    TextFormatter.PreserveTrailingSpaces = value;
                    TextFormatter.NeedsFormat = true;
                }
            }
        }

        /// <summary>
        /// Gets or sets how the View's <see cref="Text"/> is aligned horizontally when drawn. Changing this property will redisplay the <see cref="View"/>.
        /// </summary>
        /// <value>The text alignment.</value>
        public virtual TextAlignment TextAlignment
        {
            get => TextFormatter.Alignment;
            set
            {
                TextFormatter.Alignment = value;
                UpdateTextFormatterText();
                ProcessResizeView();
            }
        }

        /// <summary>
        /// Gets or sets how the View's <see cref="Text"/> is aligned vertically when drawn. Changing this property will redisplay the <see cref="View"/>.
        /// </summary>
        /// <value>The text alignment.</value>
        public virtual VerticalTextAlignment VerticalTextAlignment
        {
            get => TextFormatter.VerticalAlignment;
            set
            {
                TextFormatter.VerticalAlignment = value;
                SetNeedsDisplay();
            }
        }

        /// <summary>
        /// Gets or sets the direction of the View's <see cref="Text"/>. Changing this property will redisplay the <see cref="View"/>.
        /// </summary>
        /// <value>The text alignment.</value>
        public virtual TextDirection TextDirection
        {
            get => TextFormatter.Direction;
            set
            {
                if (TextFormatter.Direction != value)
                {
                    var isValidOldAutSize = autoSize && IsValidAutoSize(out var _);
                    var directionChanged = TextFormatter.IsHorizontalDirection(TextFormatter.Direction)
                        != TextFormatter.IsHorizontalDirection(value);

                    TextFormatter.Direction = value;
                    UpdateTextFormatterText();

                    if ((!ForceValidatePosDim && directionChanged && AutoSize)
                        || (ForceValidatePosDim && directionChanged && AutoSize && isValidOldAutSize))
                    {
                        ProcessResizeView();
                    }
                    else if (directionChanged && IsAdded)
                    {
                        SetWidthHeight(Bounds.Size);
                        SetMinWidthHeight();
                    }
                    else
                    {
                        SetMinWidthHeight();
                    }
                    TextFormatter.Size = GetBoundsTextFormatterSize();
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Get or sets if  the <see cref="View"/> was already initialized.
        /// This derived from <see cref="ISupportInitializeNotification"/> to allow notify all the views that are being initialized.
        /// </summary>
        public virtual bool IsInitialized { get; set; }

        /// <summary>
        /// Gets information if the view was already added to the <see cref="SuperView"/>.
        /// </summary>
        public bool IsAdded { get; private set; }

        bool oldEnabled;

        /// <inheritdoc/>
        public override bool Enabled
        {
            get => base.Enabled;
            set
            {
                if (base.Enabled != value)
                {
                    if (value)
                    {
                        if (SuperView == null || SuperView?.Enabled == true)
                        {
                            base.Enabled = value;
                        }
                    }
                    else
                    {
                        base.Enabled = value;
                    }
                    if (!value && HasFocus)
                    {
                        SetHasFocus(false, this);
                    }
                    OnEnabledChanged();
                    SetNeedsDisplay();

                    if (subviews != null)
                    {
                        foreach (var view in subviews)
                        {
                            if (!value)
                            {
                                view.oldEnabled = view.Enabled;
                                view.Enabled = false;
                            }
                            else
                            {
                                view.Enabled = view.oldEnabled;
                                view.addingView = false;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets whether a view is cleared if the <see cref="Visible"/> property is <see langword="false"/>.
        /// </summary>
        public bool ClearOnVisibleFalse { get; set; } = true;

        /// <inheritdoc/>>
        public override bool Visible
        {
            get => base.Visible;
            set
            {
                if (base.Visible != value)
                {
                    base.Visible = value;
                    if (!value)
                    {
                        if (HasFocus)
                        {
                            SetHasFocus(false, this);
                        }
                        if (ClearOnVisibleFalse)
                        {
                            Clear();
                        }
                    }
                    OnVisibleChanged();
                    SetNeedsDisplay();
                }
            }
        }

        Border border;

        /// <inheritdoc/>
        public virtual Border Border
        {
            get => border;
            set
            {
                if (border != value)
                {
                    border = value;
                    SetNeedsDisplay();
                }
            }
        }

        /// <summary>
        /// Get or sets whether the view will use <see cref="Terminal.Gui.Border"/> (if <see cref="Border"/> is set) to draw 
        /// a border. If <see langword="false"/> (the default),
        /// <see cref="View.Redraw(Rect)"/> will call <see cref="Border.DrawContent(View, bool)"/>
        /// to draw the view's border. If <see langword="true"/> no border is drawn (and the view is expected to draw the border
        /// itself).
        /// </summary>
        public virtual bool IgnoreBorderPropertyOnRedraw { get; set; }

        /// <summary>
        /// Pretty prints the View
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return $"{GetType().Name}({Id})({Frame})";
        }

        void SetHotKey()
        {
            TextFormatter.FindHotKey(text, HotKeySpecifier, true, out _, out var hk);
            if (hotKey != hk)
            {
                HotKey = hk;
            }
        }

        bool ResizeView(bool autoSize)
        {
            if (!autoSize)
            {
                return false;
            }

            var aSize = true;
            var nBoundsSize = GetAutoSize();
            if (nBoundsSize != Bounds.Size)
            {
                if (ForceValidatePosDim)
                {
                    aSize = SetWidthHeight(nBoundsSize);
                }
                else
                {
                    Bounds = new Rect(Bounds.X, Bounds.Y, nBoundsSize.Width, nBoundsSize.Height);
                }
            }
            TextFormatter.Size = GetBoundsTextFormatterSize();
            return aSize;
        }

        bool SetWidthHeight(Size nBounds)
        {
            var aSize = false;
            var canSizeW = SetWidth(nBounds.Width - GetHotKeySpecifierLength(), out var rW);
            var canSizeH = SetHeight(nBounds.Height - GetHotKeySpecifierLength(false), out var rH);
            if (canSizeW)
            {
                aSize = true;
                width = rW;
            }
            if (canSizeH)
            {
                aSize = true;
                height = rH;
            }
            if (aSize)
            {
                Bounds = new Rect(Bounds.X, Bounds.Y, canSizeW ? rW : Bounds.Width, canSizeH ? rH : Bounds.Height);
                TextFormatter.Size = GetBoundsTextFormatterSize();
            }

            return aSize;
        }

        /// <summary>
        /// Gets the size to fit all text if <see cref="AutoSize"/> is true.
        /// </summary>
        /// <returns>The <see cref="Size"/></returns>
        public Size GetAutoSize()
        {
            var rect = TextFormatter.CalcRect(Bounds.X, Bounds.Y, TextFormatter.Text, TextFormatter.Direction);
            return new Size(rect.Size.Width - GetHotKeySpecifierLength(),
                rect.Size.Height - GetHotKeySpecifierLength(false));
        }

        bool IsValidAutoSize(out Size autoSize)
        {
            var rect = TextFormatter.CalcRect(frame.X, frame.Y, TextFormatter.Text, TextDirection);
            autoSize = new Size(rect.Size.Width - GetHotKeySpecifierLength(),
                rect.Size.Height - GetHotKeySpecifierLength(false));
            return !(ForceValidatePosDim && (!(Width is Dim.DimAbsolute) || !(Height is Dim.DimAbsolute))
                || frame.Size.Width != rect.Size.Width - GetHotKeySpecifierLength()
                || frame.Size.Height != rect.Size.Height - GetHotKeySpecifierLength(false));
        }

        bool IsValidAutoSizeWidth(Dim width)
        {
            var rect = TextFormatter.CalcRect(frame.X, frame.Y, TextFormatter.Text, TextDirection);
            var dimValue = width.Anchor(0);
            return !(ForceValidatePosDim && (!(width is Dim.DimAbsolute)) || dimValue != rect.Size.Width
                - GetHotKeySpecifierLength());
        }

        bool IsValidAutoSizeHeight(Dim height)
        {
            var rect = TextFormatter.CalcRect(frame.X, frame.Y, TextFormatter.Text, TextDirection);
            var dimValue = height.Anchor(0);
            return !(ForceValidatePosDim && (!(height is Dim.DimAbsolute)) || dimValue != rect.Size.Height
                - GetHotKeySpecifierLength(false));
        }

        /// <summary>
        /// Get the width or height of the <see cref="Terminal.Gui.TextFormatter.HotKeySpecifier"/> length.
        /// </summary>
        /// <param name="isWidth"><see langword="true"/> if is the width (default) <see langword="false"/> if is the height.</param>
        /// <returns>The length of the <see cref="Terminal.Gui.TextFormatter.HotKeySpecifier"/>.</returns>
        public int GetHotKeySpecifierLength(bool isWidth = true)
        {
            if (isWidth)
            {
                return TextFormatter.IsHorizontalDirection(TextDirection) &&
                    TextFormatter.Text?.Contains(HotKeySpecifier) == true
                    ? Math.Max(Rune.ColumnWidth(HotKeySpecifier), 0) : 0;
            }
            else
            {
                return TextFormatter.IsVerticalDirection(TextDirection) &&
                    TextFormatter.Text?.Contains(HotKeySpecifier) == true
                    ? Math.Max(Rune.ColumnWidth(HotKeySpecifier), 0) : 0;
            }
        }

        /// <summary>
        /// Gets the bounds size from a <see cref="Terminal.Gui.TextFormatter.Size"/>.
        /// </summary>
        /// <returns>The bounds size minus the <see cref="Terminal.Gui.TextFormatter.HotKeySpecifier"/> length.</returns>
        public Size GetTextFormatterBoundsSize()
        {
            return new Size(TextFormatter.Size.Width - GetHotKeySpecifierLength(),
                TextFormatter.Size.Height - GetHotKeySpecifierLength(false));
        }

        /// <summary>
        /// Gets the text formatter size from a <see cref="Bounds"/> size.
        /// </summary>
        /// <returns>The text formatter size more the <see cref="Terminal.Gui.TextFormatter.HotKeySpecifier"/> length.</returns>
        public Size GetBoundsTextFormatterSize()
        {
            if (ustring.IsNullOrEmpty(TextFormatter.Text))
                return Bounds.Size;

            return new Size(frame.Size.Width + GetHotKeySpecifierLength(),
                frame.Size.Height + GetHotKeySpecifierLength(false));
        }

        /// <summary>
        /// Specifies the event arguments for <see cref="MouseEvent"/>. This is a higher-level construct
        /// than the wrapped <see cref="MouseEvent"/> class and is used for the events defined on <see cref="View"/>
        /// and subclasses of View (e.g. <see cref="View.MouseEnter"/> and <see cref="View.MouseClick"/>).
        /// </summary>
        public class MouseEventArgs : EventArgs
        {
            /// <summary>
            /// Constructs.
            /// </summary>
            /// <param name="me"></param>
            public MouseEventArgs(MouseEvent me) => MouseEvent = me;
            /// <summary>
            /// The <see cref="MouseEvent"/> for the event.
            /// </summary>
            public MouseEvent MouseEvent { get; set; }

            /// <summary>
            /// Indicates if the current mouse event has already been processed and the driver should stop notifying any other event subscriber.
            /// Its important to set this value to true specially when updating any View's layout from inside the subscriber method.
            /// </summary>
            /// <remarks>This property forwards to the <see cref="MouseEvent.Handled"/> property and is provided as a convenience and for
            /// backwards compatibility</remarks>
            public bool Handled
            {
                get => MouseEvent.Handled;
                set => MouseEvent.Handled = value;
            }
        }

        /// <inheritdoc/>
        public override bool OnMouseEnter(MouseEvent mouseEvent)
        {
            if (!Enabled)
            {
                return true;
            }

            if (!CanBeVisible(this))
            {
                return false;
            }

            var args = new MouseEventArgs(mouseEvent);
            MouseEnter?.Invoke(args);

            return args.Handled || base.OnMouseEnter(mouseEvent);
        }

        /// <inheritdoc/>
        public override bool OnMouseLeave(MouseEvent mouseEvent)
        {
            if (!Enabled)
            {
                return true;
            }

            if (!CanBeVisible(this))
            {
                return false;
            }

            var args = new MouseEventArgs(mouseEvent);
            MouseLeave?.Invoke(args);

            return args.Handled || base.OnMouseLeave(mouseEvent);
        }

        /// <summary>
        /// Method invoked when a mouse event is generated
        /// </summary>
        /// <param name="mouseEvent"></param>
        /// <returns><see langword="true"/>, if the event was handled, <see langword="false"/> otherwise.</returns>
        public virtual bool OnMouseEvent(MouseEvent mouseEvent)
        {
            if (!Enabled)
            {
                return true;
            }

            if (!CanBeVisible(this))
            {
                return false;
            }

            if ((mouseEvent.Flags & MouseFlags.Button1Clicked) != 0 || (mouseEvent.Flags & MouseFlags.Button2Clicked) != 0
                || (mouseEvent.Flags & MouseFlags.Button3Clicked) != 0 || (mouseEvent.Flags & MouseFlags.Button4Clicked) != 0)
            {

                var args = new MouseEventArgs(mouseEvent);
                if (OnMouseClick(args))
                {
                    return true;
                }
            }
            if (MouseEvent(mouseEvent))
                return true;

            if (mouseEvent.Flags == MouseFlags.Button1Clicked)
            {
                if (CanFocus && !HasFocus && SuperView != null)
                {
                    SuperView.SetFocus(this);
                    SetNeedsDisplay();
                }

                return true;
            }
            return false;
        }

        /// <summary>
        /// Invokes the MouseClick event.
        /// </summary>
        protected bool OnMouseClick(MouseEventArgs args)
        {
            if (!Enabled)
            {
                return true;
            }

            MouseClick?.Invoke(args);
            return args.Handled;
        }

        /// <inheritdoc/>
        public override void OnCanFocusChanged() => CanFocusChanged?.Invoke();

        /// <inheritdoc/>
        public override void OnEnabledChanged() => EnabledChanged?.Invoke();

        /// <inheritdoc/>
        public override void OnVisibleChanged() => VisibleChanged?.Invoke();

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            height = null;
            width = null;
            x = null;
            y = null;
            for (var i = InternalSubviews.Count - 1; i >= 0; i--)
            {
                var subview = InternalSubviews[i];
                Remove(subview);
                subview.Dispose();
            }
            base.Dispose(disposing);
            System.Diagnostics.Debug.Assert(InternalSubviews.Count == 0);
        }

        /// <summary>
        /// This derived from <see cref="ISupportInitializeNotification"/> to allow notify all the views that are beginning initialized.
        /// </summary>
        public void BeginInit()
        {
            if (!IsInitialized)
            {
                oldCanFocus = CanFocus;
                oldTabIndex = tabIndex;
            }
            if (subviews?.Count > 0)
            {
                foreach (var view in subviews)
                {
                    if (!view.IsInitialized)
                    {
                        view.BeginInit();
                    }
                }
            }
        }

        /// <summary>
        /// This derived from <see cref="ISupportInitializeNotification"/> to allow notify all the views that are ending initialized.
        /// </summary>
        public void EndInit()
        {
            IsInitialized = true;
            if (subviews?.Count > 0)
            {
                //*master//
                // Эту конструкцию помещаю в попытку, так как возникает ошибка обработки события 
                // Текстовый.СодержимоеИзменено (TextView.ContentsChanged) Событие
                //////foreach (var view in subviews)
                //////{
                //////    if (!view.IsInitialized)
                //////    {
                //////        view.EndInit();
                //////    }
                //////}

                try
                {
                    foreach (var view in subviews)
                    {
                        if (!view.IsInitialized)
                        {
                            view.EndInit();
                        }
                    }
                }
                catch { }
                //master*//
            }
            Initialized?.Invoke(this, EventArgs.Empty);
        }

        bool CanBeVisible(View view)
        {
            if (!view.Visible)
            {
                return false;
            }
            for (var c = view.SuperView; c != null; c = c.SuperView)
            {
                if (!c.Visible)
                {
                    return false;
                }
            }

            return true;
        }

        bool CanSetWidth(int desiredWidth, out int resultWidth)
        {
            var w = desiredWidth;
            bool canSetWidth;
            if (Width is Dim.DimCombine || Width is Dim.DimView || Width is Dim.DimFill)
            {
                // It's a Dim.DimCombine and so can't be assigned. Let it have it's width anchored.
                w = Width.Anchor(w);
                canSetWidth = !ForceValidatePosDim;
            }
            else if (Width is Dim.DimFactor factor)
            {
                // Tries to get the SuperView width otherwise the view width.
                var sw = SuperView != null ? SuperView.Frame.Width : w;
                if (factor.IsFromRemaining())
                {
                    sw -= Frame.X;
                }
                w = Width.Anchor(sw);
                canSetWidth = !ForceValidatePosDim;
            }
            else
            {
                canSetWidth = true;
            }
            resultWidth = w;

            return canSetWidth;
        }

        bool CanSetHeight(int desiredHeight, out int resultHeight)
        {
            var h = desiredHeight;
            bool canSetHeight;
            switch (Height)
            {
                case Dim.DimCombine _:
                case Dim.DimView _:
                case Dim.DimFill _:
                    // It's a Dim.DimCombine and so can't be assigned. Let it have it's height anchored.
                    h = Height.Anchor(h);
                    canSetHeight = !ForceValidatePosDim;
                    break;
                case Dim.DimFactor factor:
                    // Tries to get the SuperView height otherwise the view height.
                    var sh = SuperView != null ? SuperView.Frame.Height : h;
                    if (factor.IsFromRemaining())
                    {
                        sh -= Frame.Y;
                    }
                    h = Height.Anchor(sh);
                    canSetHeight = !ForceValidatePosDim;
                    break;
                default:
                    canSetHeight = true;
                    break;
            }
            resultHeight = h;

            return canSetHeight;
        }

        /// <summary>
        /// Calculate the width based on the <see cref="Width"/> settings.
        /// </summary>
        /// <param name="desiredWidth">The desired width.</param>
        /// <param name="resultWidth">The real result width.</param>
        /// <returns><see langword="true"/> if the width can be directly assigned, <see langword="false"/> otherwise.</returns>
        public bool SetWidth(int desiredWidth, out int resultWidth)
        {
            return CanSetWidth(desiredWidth, out resultWidth);
        }

        /// <summary>
        /// Calculate the height based on the <see cref="Height"/> settings.
        /// </summary>
        /// <param name="desiredHeight">The desired height.</param>
        /// <param name="resultHeight">The real result height.</param>
        /// <returns><see langword="true"/> if the height can be directly assigned, <see langword="false"/> otherwise.</returns>
        public bool SetHeight(int desiredHeight, out int resultHeight)
        {
            return CanSetHeight(desiredHeight, out resultHeight);
        }

        /// <summary>
        /// Gets the current width based on the <see cref="Width"/> settings.
        /// </summary>
        /// <param name="currentWidth">The real current width.</param>
        /// <returns><see langword="true"/> if the width can be directly assigned, <see langword="false"/> otherwise.</returns>
        public bool GetCurrentWidth(out int currentWidth)
        {
            SetRelativeLayout(SuperView?.frame ?? frame);
            currentWidth = frame.Width;

            return CanSetWidth(0, out _);
        }

        /// <summary>
        /// Calculate the height based on the <see cref="Height"/> settings.
        /// </summary>
        /// <param name="currentHeight">The real current height.</param>
        /// <returns><see langword="true"/> if the height can be directly assigned, <see langword="false"/> otherwise.</returns>
        public bool GetCurrentHeight(out int currentHeight)
        {
            SetRelativeLayout(SuperView?.frame ?? frame);
            currentHeight = frame.Height;

            return CanSetHeight(0, out _);
        }

        /// <summary>
        /// Determines the current <see cref="ColorScheme"/> based on the <see cref="Enabled"/> value.
        /// </summary>
        /// <returns><see cref="Terminal.Gui.ColorScheme.Normal"/> if <see cref="Enabled"/> is <see langword="true"/>
        /// or <see cref="Terminal.Gui.ColorScheme.Disabled"/> if <see cref="Enabled"/> is <see langword="false"/>.
        /// If it's overridden can return other values.</returns>
        public virtual Attribute GetNormalColor()
        {
            return Enabled ? ColorScheme.Normal : ColorScheme.Disabled;
        }

        /// <summary>
        /// Determines the current <see cref="ColorScheme"/> based on the <see cref="Enabled"/> value.
        /// </summary>
        /// <returns><see cref="Terminal.Gui.ColorScheme.Focus"/> if <see cref="Enabled"/> is <see langword="true"/>
        /// or <see cref="Terminal.Gui.ColorScheme.Disabled"/> if <see cref="Enabled"/> is <see langword="false"/>.
        /// If it's overridden can return other values.</returns>
        public virtual Attribute GetFocusColor()
        {
            return Enabled ? ColorScheme.Focus : ColorScheme.Disabled;
        }

        /// <summary>
        /// Determines the current <see cref="ColorScheme"/> based on the <see cref="Enabled"/> value.
        /// </summary>
        /// <returns><see cref="Terminal.Gui.ColorScheme.HotNormal"/> if <see cref="Enabled"/> is <see langword="true"/>
        /// or <see cref="Terminal.Gui.ColorScheme.Disabled"/> if <see cref="Enabled"/> is <see langword="false"/>.
        /// If it's overridden can return other values.</returns>
        public virtual Attribute GetHotNormalColor()
        {
            return Enabled ? ColorScheme.HotNormal : ColorScheme.Disabled;
        }

        /// <summary>
        /// Get the top superview of a given <see cref="View"/>.
        /// </summary>
        /// <returns>The superview view.</returns>
        public View GetTopSuperView()
        {
            View top = Application.Top;
            for (var v = this?.SuperView; v != null; v = v.SuperView)
            {
                top = v;
            }

            return top;
        }
    }
    //=======================================================================
    //
    // Authors:
    //   Miguel de Icaza (miguel@gnome.org)
    //
    // NOTE: Window is functionally identical to FrameView with the following exceptions. 
    //  - Window is a Toplevel
    //  - FrameView Does not support padding (but should)
    //  - FrameView Does not support mouse dragging
    //  - FrameView Does not support IEnumerable
    // Any udpates done here should probably be done in FrameView as well; TODO: Merge these classes

    /// <summary>
    /// A <see cref="Toplevel"/> <see cref="View"/> that draws a border around its <see cref="View.Frame"/> with a <see cref="Title"/> at the top.
    /// </summary>
    /// <remarks>
    /// The 'client area' of a <see cref="Window"/> is a rectangle deflated by one or more rows/columns from <see cref="View.Bounds"/>. A this time there is no
    /// API to determine this rectangle.
    /// </remarks>
    public class Window : Toplevel
    {
        View contentView;
        ustring title = ustring.Empty;

        /// <summary>
        /// The title to be displayed for this window.
        /// </summary>
        /// <value>The title</value>
        public ustring Title
        {
            get => title;
            set
            {
                if (!OnTitleChanging(title, value))
                {
                    var old = title;
                    title = value;
                    if (Border != null)
                    {
                        Border.Title = title;
                    }
                    OnTitleChanged(old, title);
                }
                SetNeedsDisplay();
            }
        }

        /// <inheritdoc/>
        public override Border Border
        {
            get => base.Border;
            set
            {
                if (base.Border != null && base.Border.Child != null && value.Child == null)
                {
                    value.Child = base.Border.Child;
                }
                base.Border = value;
                if (value == null)
                {
                    return;
                }
                Rect frame;
                if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
                {
                    frame = Rect.Empty;
                }
                else
                {
                    frame = Frame;
                }
                AdjustContentView(frame);

                Border.BorderChanged += Border_BorderChanged;
            }
        }

        void Border_BorderChanged(Border border)
        {
            Rect frame;
            if (contentView != null && (contentView.Width is Dim || contentView.Height is Dim))
            {
                frame = Rect.Empty;
            }
            else
            {
                frame = Frame;
            }
            AdjustContentView(frame);
        }

        /// <summary>
        /// ContentView is an internal implementation detail of Window. It is used to host Views added with <see cref="Add(View)"/>. 
        /// Its ONLY reason for being is to provide a simple way for Window to expose to those SubViews that the Window's Bounds 
        /// are actually deflated due to the border. 
        /// </summary>
        class ContentView : View
        {
            Window instance;

            public ContentView(Rect frame, Window instance) : base(frame)
            {
                Initialize(instance);
            }
            public ContentView(Window instance) : base()
            {
                Initialize(instance);
            }

            private void Initialize(Window instance)
            {
                this.instance = instance;
                CanFocus = this.instance.CanFocus;
                Driver?.SetCursorVisibility(CursorVisibility.Invisible);
            }

            public override void OnCanFocusChanged()
            {
                if (HasFocus && MostFocused == null && CanFocus && Visible)
                {
                    EnsureFocus();
                }

                base.OnCanFocusChanged();
            }

            public override bool OnMouseEvent(MouseEvent mouseEvent)
            {
                return instance.OnMouseEvent(mouseEvent);
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Gui.Window"/> class with an optional title using <see cref="LayoutStyle.Absolute"/> positioning.
        /// </summary>
        /// <param name="frame">Superview-relative rectangle specifying the location and size</param>
        /// <param name="title">Title</param>
        /// <remarks>
        /// This constructor initializes a Window with a <see cref="LayoutStyle"/> of <see cref="LayoutStyle.Absolute"/>. Use constructors
        /// that do not take <c>Rect</c> parameters to initialize a Window with <see cref="LayoutStyle.Computed"/>. 
        /// </remarks>
        public Window(Rect frame, ustring title = null) : this(frame, title, padding: 0, border: null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Window"/> class with an optional title using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        /// <param name="title">Title.</param>
        /// <remarks>
        ///   This constructor initializes a View with a <see cref="LayoutStyle"/> of <see cref="LayoutStyle.Computed"/>. 
        ///   Use <see cref="View.X"/>, <see cref="View.Y"/>, <see cref="View.Width"/>, and <see cref="View.Height"/> properties to dynamically control the size and location of the view.
        /// </remarks>
        public Window(ustring title = null) : this(title, padding: 0, border: null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Window"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        public Window() : this(title: null) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Window"/> using <see cref="LayoutStyle.Absolute"/> positioning with the specified frame for its location, with the specified frame padding,
        /// and an optional title.
        /// </summary>
        /// <param name="frame">Superview-relative rectangle specifying the location and size</param>
        /// <param name="title">Title</param>
        /// <param name="padding">Number of characters to use for padding of the drawn frame.</param>
        /// <param name="border">The <see cref="Border"/>.</param>
        /// <remarks>
        /// This constructor initializes a Window with a <see cref="LayoutStyle"/> of <see cref="LayoutStyle.Absolute"/>. Use constructors
        /// that do not take <c>Rect</c> parameters to initialize a Window with  <see cref="LayoutStyle"/> of <see cref="LayoutStyle.Computed"/> 
        /// </remarks>
        public Window(Rect frame, ustring title = null, int padding = 0, Border border = null) : base(frame)
        {
            Initialize(title, frame, padding, border);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Window"/> using <see cref="LayoutStyle.Computed"/> positioning,
        /// and an optional title.
        /// </summary>
        /// <param name="title">Title.</param>
        /// <param name="padding">Number of characters to use for padding of the drawn frame.</param>
        /// <param name="border">The <see cref="Border"/>.</param>
        /// <remarks>
        ///   This constructor initializes a View with a <see cref="LayoutStyle"/> of <see cref="LayoutStyle.Computed"/>. 
        ///   Use <see cref="View.X"/>, <see cref="View.Y"/>, <see cref="View.Width"/>, and <see cref="View.Height"/> properties to dynamically control the size and location of the view.
        /// </remarks>
        public Window(ustring title = null, int padding = 0, Border border = null) : base()
        {
            Initialize(title, Rect.Empty, padding, border);
        }

        void Initialize(ustring title, Rect frame, int padding = 0, Border border = null)
        {
            CanFocus = true;
            ColorScheme = Colors.Base;
            if (title == null) title = ustring.Empty;
            Title = title;
            if (border == null)
            {
                Border = new Border()
                {
                    BorderStyle = BorderStyle.Single,
                    Padding = new Thickness(padding),
                    Title = title
                };
            }
            else
            {
                Border = border;
                if (ustring.IsNullOrEmpty(border.Title))
                {
                    border.Title = title;
                }
            }
            AdjustContentView(frame);
        }

        void AdjustContentView(Rect frame)
        {
            var borderLength = Border.DrawMarginFrame ? 1 : 0;
            var sumPadding = Border.GetSumThickness();
            var wp = new Point();
            var wb = new Size();
            if (frame == Rect.Empty)
            {
                wp.X = borderLength + sumPadding.Left;
                wp.Y = borderLength + sumPadding.Top;
                wb.Width = borderLength + sumPadding.Right;
                wb.Height = borderLength + sumPadding.Bottom;
                if (contentView == null)
                {
                    contentView = new ContentView(this)
                    {
                        X = wp.X,
                        Y = wp.Y,
                        Width = Dim.Fill(wb.Width),
                        Height = Dim.Fill(wb.Height)
                    };
                }
                else
                {
                    contentView.X = wp.X;
                    contentView.Y = wp.Y;
                    contentView.Width = Dim.Fill(wb.Width);
                    contentView.Height = Dim.Fill(wb.Height);
                }
            }
            else
            {
                wb.Width = (2 * borderLength) + sumPadding.Right + sumPadding.Left;
                wb.Height = (2 * borderLength) + sumPadding.Bottom + sumPadding.Top;
                var cFrame = new Rect(borderLength + sumPadding.Left, borderLength + sumPadding.Top, frame.Width - wb.Width, frame.Height - wb.Height);
                if (contentView == null)
                {
                    contentView = new ContentView(cFrame, this);
                }
                else
                {
                    contentView.Frame = cFrame;
                }
            }
            if (Subviews?.Count == 0)
                base.Add(contentView);
            Border.Child = contentView;
        }

        ///// <summary>
        ///// Enumerates the various <see cref="View"/>s in the embedded <see cref="ContentView"/>.
        ///// </summary>
        ///// <returns>The enumerator.</returns>
        //public new IEnumerator GetEnumerator ()
        //{
        //	return contentView.GetEnumerator ();
        //}

        /// <inheritdoc/>
        public override void Add(View view)
        {
            contentView.Add(view);
            if (view.CanFocus)
            {
                CanFocus = true;
                if (contentView.HasFocus && contentView.MostFocused == null)
                {
                    view.SetFocus();
                }
            }
            AddMenuStatusBar(view);
        }

        /// <inheritdoc/>
        public override void Remove(View view)
        {
            if (view == null)
            {
                return;
            }

            SetNeedsDisplay();
            if (view == contentView)
            {
                base.Remove(view);
            }
            else
            {
                contentView.Remove(view);
            }

            RemoveMenuStatusBar(view);
            if (view != contentView && Focused == null)
            {
                FocusFirst();
            }
        }

        /// <inheritdoc/>
        public override void RemoveAll()
        {
            contentView.RemoveAll();
        }

        ///<inheritdoc/>
        public override void Redraw(Rect bounds)
        {
            if (!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded)
            {
                Driver.SetAttribute(GetNormalColor());
                Clear();
                var savedFrame = Frame;
                PositionToplevels();
                if (Application.MdiTop != null && SuperView == null && this != Application.Top && LayoutStyle == LayoutStyle.Computed)
                {
                    SetRelativeLayout(Application.Top.Frame);
                    if (Frame != savedFrame)
                    {
                        Application.Top.SetNeedsDisplay();
                        Application.Top.Redraw(Application.Top.Bounds);
                        Redraw(Bounds);
                    }
                }
                LayoutSubviews();
                if (this == Application.MdiTop)
                {
                    foreach (var top in Application.MdiChildes.AsEnumerable().Reverse())
                    {
                        if (top.Frame.IntersectsWith(bounds))
                        {
                            if (top != this && !top.IsCurrentTop && !OutsideTopFrame(top) && top.Visible)
                            {
                                top.SetNeedsLayout();
                                top.SetNeedsDisplay(top.Bounds);
                                top.Redraw(top.Bounds);
                            }
                        }
                    }
                }
                contentView.SetNeedsDisplay();
            }
            var savedClip = contentView.ClipToBounds();

            // Redraw our contentView
            contentView.Redraw(!NeedDisplay.IsEmpty || ChildNeedsDisplay || LayoutNeeded ? contentView.Bounds : bounds);
            Driver.Clip = savedClip;

            ClearLayoutNeeded();
            ClearNeedsDisplay();

            Driver.SetAttribute(GetNormalColor());
            Border.DrawContent(this, false);
        }

        /// <inheritdoc/>
        public override void OnCanFocusChanged()
        {
            if (contentView != null)
            {
                contentView.CanFocus = CanFocus;
            }
            base.OnCanFocusChanged();
        }

        /// <summary>
        ///   The text displayed by the <see cref="Label"/>.
        /// </summary>
        public override ustring Text
        {
            get => contentView?.Text;
            set
            {
                base.Text = value;
                if (contentView != null)
                {
                    contentView.Text = value;
                }
            }
        }

        /// <summary>
        /// Controls the text-alignment property of the label, changing it will redisplay the <see cref="Label"/>.
        /// </summary>
        /// <value>The text alignment.</value>
        public override TextAlignment TextAlignment
        {
            get => contentView.TextAlignment;
            set
            {
                base.TextAlignment = contentView.TextAlignment = value;
            }
        }

        /// <summary>
        /// An <see cref="EventArgs"/> which allows passing a cancelable new <see cref="Title"/> value event.
        /// </summary>
        public class TitleEventArgs : EventArgs
        {
            /// <summary>
            /// The new Window Title.
            /// </summary>
            public ustring NewTitle { get; set; }

            /// <summary>
            /// The old Window Title.
            /// </summary>
            public ustring OldTitle { get; set; }

            /// <summary>
            /// Flag which allows cancelling the Title change.
            /// </summary>
            public bool Cancel { get; set; }

            /// <summary>
            /// Initializes a new instance of <see cref="TitleEventArgs"/>
            /// </summary>
            /// <param name="oldTitle">The <see cref="Window.Title"/> that is/has been replaced.</param>
            /// <param name="newTitle">The new <see cref="Window.Title"/> to be replaced.</param>
            public TitleEventArgs(ustring oldTitle, ustring newTitle)
            {
                OldTitle = oldTitle;
                NewTitle = newTitle;
            }
        }
        /// <summary>
        /// Called before the <see cref="Window.Title"/> changes. Invokes the <see cref="TitleChanging"/> event, which can be cancelled.
        /// </summary>
        /// <param name="oldTitle">The <see cref="Window.Title"/> that is/has been replaced.</param>
        /// <param name="newTitle">The new <see cref="Window.Title"/> to be replaced.</param>
        /// <returns>`true` if an event handler cancelled the Title change.</returns>
        public virtual bool OnTitleChanging(ustring oldTitle, ustring newTitle)
        {
            var args = new TitleEventArgs(oldTitle, newTitle);
            TitleChanging?.Invoke(args);
            return args.Cancel;
        }

        /// <summary>
        /// Event fired when the <see cref="Window.Title"/> is changing. Set <see cref="TitleEventArgs.Cancel"/> to 
        /// `true` to cancel the Title change.
        /// </summary>
        public event Action<TitleEventArgs> TitleChanging;

        /// <summary>
        /// Called when the <see cref="Window.Title"/> has been changed. Invokes the <see cref="TitleChanged"/> event.
        /// </summary>
        /// <param name="oldTitle">The <see cref="Window.Title"/> that is/has been replaced.</param>
        /// <param name="newTitle">The new <see cref="Window.Title"/> to be replaced.</param>
        public virtual void OnTitleChanged(ustring oldTitle, ustring newTitle)
        {
            var args = new TitleEventArgs(oldTitle, newTitle);
            TitleChanged?.Invoke(args);
        }

        /// <summary>
        /// Event fired after the <see cref="Window.Title"/> has been changed. 
        /// </summary>
        public event Action<TitleEventArgs> TitleChanged;
    }
    //=======================================================================
    //
    // WindowsDriver.cs: Windows specific driver
    //

    internal class WindowsConsole
    {
        public const int STD_OUTPUT_HANDLE = -11;
        public const int STD_INPUT_HANDLE = -10;
        public const int STD_ERROR_HANDLE = -12;

        internal IntPtr InputHandle, OutputHandle;
        IntPtr screenBuffer;
        readonly uint originalConsoleMode;
        CursorVisibility? initialCursorVisibility = null;
        CursorVisibility? currentCursorVisibility = null;
        CursorVisibility? pendingCursorVisibility = null;

        public WindowsConsole()
        {
            InputHandle = GetStdHandle(STD_INPUT_HANDLE);
            OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
            originalConsoleMode = ConsoleMode;
            var newConsoleMode = originalConsoleMode;
            newConsoleMode |= (uint)(ConsoleModes.EnableMouseInput | ConsoleModes.EnableExtendedFlags);
            newConsoleMode &= ~(uint)ConsoleModes.EnableQuickEditMode;
            newConsoleMode &= ~(uint)ConsoleModes.EnableProcessedInput;
            ConsoleMode = newConsoleMode;
        }

        public CharInfo[] OriginalStdOutChars;

        public bool WriteToConsole(Size size, CharInfo[] charInfoBuffer, Coord coords, SmallRect window)
        {
            if (!IsWindowsTerminal && screenBuffer == IntPtr.Zero)
            {
                ReadFromConsoleOutput(size, coords, ref window);
            }

            if (!initialCursorVisibility.HasValue && GetCursorVisibility(out CursorVisibility visibility))
            {
                initialCursorVisibility = visibility;
            }

            return WriteConsoleOutput(IsWindowsTerminal ? OutputHandle : screenBuffer, charInfoBuffer, coords, new Coord() { X = window.Left, Y = window.Top }, ref window);
        }

        public void ReadFromConsoleOutput(Size size, Coord coords, ref SmallRect window)
        {
            screenBuffer = CreateConsoleScreenBuffer(
                DesiredAccess.GenericRead | DesiredAccess.GenericWrite,
                ShareMode.FileShareRead | ShareMode.FileShareWrite,
                IntPtr.Zero,
                1,
                IntPtr.Zero
            );
            if (screenBuffer == INVALID_HANDLE_VALUE)
            {
                var err = Marshal.GetLastWin32Error();

                if (err != 0)
                    throw new System.ComponentModel.Win32Exception(err);
            }

            if (!SetConsoleActiveScreenBuffer(screenBuffer))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }

            OriginalStdOutChars = new CharInfo[size.Height * size.Width];

            if (!ReadConsoleOutput(screenBuffer, OriginalStdOutChars, coords, new Coord() { X = 0, Y = 0 }, ref window))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }
        }

        public bool SetCursorPosition(Coord position)
        {
            return SetConsoleCursorPosition(IsWindowsTerminal ? OutputHandle : screenBuffer, position);
        }

        public void SetInitialCursorVisibility()
        {
            if (initialCursorVisibility.HasValue == false && GetCursorVisibility(out CursorVisibility visibility))
            {
                initialCursorVisibility = visibility;
            }
        }

        public bool GetCursorVisibility(out CursorVisibility visibility)
        {
            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) == IntPtr.Zero)
            {
                visibility = CursorVisibility.Invisible;
                return false;
            }
            if (!GetConsoleCursorInfo(IsWindowsTerminal ? OutputHandle : screenBuffer, out ConsoleCursorInfo info))
            {
                var err = Marshal.GetLastWin32Error();
                if (err != 0)
                {
                    throw new System.ComponentModel.Win32Exception(err);
                }
                visibility = Gui.CursorVisibility.Default;

                return false;
            }

            if (!info.bVisible)
                visibility = CursorVisibility.Invisible;
            else if (info.dwSize > 50)
                visibility = CursorVisibility.Box;
            else
                visibility = CursorVisibility.Underline;

            return true;
        }

        public bool EnsureCursorVisibility()
        {
            if (initialCursorVisibility.HasValue && pendingCursorVisibility.HasValue && SetCursorVisibility(pendingCursorVisibility.Value))
            {
                pendingCursorVisibility = null;

                return true;
            }

            return false;
        }

        public void ForceRefreshCursorVisibility()
        {
            if (currentCursorVisibility.HasValue)
            {
                pendingCursorVisibility = currentCursorVisibility;
                currentCursorVisibility = null;
            }
        }

        public bool SetCursorVisibility(CursorVisibility visibility)
        {
            if (initialCursorVisibility.HasValue == false)
            {
                pendingCursorVisibility = visibility;

                return false;
            }

            if (currentCursorVisibility.HasValue == false || currentCursorVisibility.Value != visibility)
            {
                ConsoleCursorInfo info = new ConsoleCursorInfo
                {
                    dwSize = (uint)visibility & 0x00FF,
                    bVisible = ((uint)visibility & 0xFF00) != 0
                };

                if (!SetConsoleCursorInfo(IsWindowsTerminal ? OutputHandle : screenBuffer, ref info))
                    return false;

                currentCursorVisibility = visibility;
            }

            return true;
        }

        public void Cleanup()
        {
            if (initialCursorVisibility.HasValue)
            {
                SetCursorVisibility(initialCursorVisibility.Value);
            }

            ConsoleMode = originalConsoleMode;
            if (!SetConsoleActiveScreenBuffer(OutputHandle))
            {
                var err = Marshal.GetLastWin32Error();
                Console.WriteLine("Error: {0}", err);
            }

            if (screenBuffer != IntPtr.Zero)
            {
                CloseHandle(screenBuffer);
            }

            screenBuffer = IntPtr.Zero;
        }

        internal Size GetConsoleBufferWindow(out Point position)
        {
            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) == IntPtr.Zero)
            {
                position = Point.Empty;
                return Size.Empty;
            }

            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
            csbi.cbSize = (uint)Marshal.SizeOf(csbi);
            if (!GetConsoleScreenBufferInfoEx((IsWindowsTerminal ? OutputHandle : screenBuffer), ref csbi))
            {
                //throw new System.ComponentModel.Win32Exception (Marshal.GetLastWin32Error ());
                position = Point.Empty;
                return Size.Empty;
            }
            var sz = new Size(csbi.srWindow.Right - csbi.srWindow.Left + 1,
                csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
            position = new Point(csbi.srWindow.Left, csbi.srWindow.Top);

            return sz;
        }

        internal Size GetConsoleOutputWindow(out Point position)
        {
            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
            csbi.cbSize = (uint)Marshal.SizeOf(csbi);
            if (!GetConsoleScreenBufferInfoEx(OutputHandle, ref csbi))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }
            var sz = new Size(csbi.srWindow.Right - csbi.srWindow.Left + 1,
                csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
            position = new Point(csbi.srWindow.Left, csbi.srWindow.Top);

            return sz;
        }

        //*master//
        // Этот метод заменю на метод с ограничением минимального размера терминала, иначе в windows программа закрывается.
        //////internal Size SetConsoleWindow(short cols, short rows)
        //////{
        //////    var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
        //////    csbi.cbSize = (uint)Marshal.SizeOf(csbi);

        //////    if (!GetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
        //////    {
        //////        throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
        //////    }
        //////    var maxWinSize = GetLargestConsoleWindowSize(IsWindowsTerminal ? OutputHandle : screenBuffer);
        //////    var newCols = Math.Min(cols, maxWinSize.X);
        //////    var newRows = Math.Min(rows, maxWinSize.Y);
        //////    csbi.dwSize = new Coord(newCols, Math.Max(newRows, (short)1));
        //////    csbi.srWindow = new SmallRect(0, 0, newCols, newRows);
        //////    csbi.dwMaximumWindowSize = new Coord(newCols, newRows);
        //////    if (!SetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
        //////    {
        //////        throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
        //////    }
        //////    var winRect = new SmallRect(0, 0, (short)(newCols - 1), (short)Math.Max(newRows - 1, 0));
        //////    if (!SetConsoleWindowInfo(OutputHandle, true, ref winRect))
        //////    {
        //////        //throw new System.ComponentModel.Win32Exception (Marshal.GetLastWin32Error ());
        //////        return new Size(cols, rows);
        //////    }
        //////    SetConsoleOutputWindow(csbi);
        //////    return new Size(winRect.Right + 1, newRows - 1 < 0 ? 0 : winRect.Bottom + 1);
        //////}
        internal Size SetConsoleWindow(short cols, short rows)
        {
            short _cols = cols;
            short _rows = rows;
            if (cols < Convert.ToInt16(ostgui.Utils.minCols))
            {
                _cols = Convert.ToInt16(ostgui.Utils.minCols);
            }
            if (rows < Convert.ToInt16(ostgui.Utils.minRows))
            {
                _rows = Convert.ToInt16(ostgui.Utils.minRows);
            }

            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
            csbi.cbSize = (uint)Marshal.SizeOf(csbi);

            if (!GetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }
            var maxWinSize = GetLargestConsoleWindowSize(IsWindowsTerminal ? OutputHandle : screenBuffer);
            var newCols = Math.Min(_cols, maxWinSize.X);
            var newRows = Math.Min(_rows, maxWinSize.Y);
            csbi.dwSize = new Coord(newCols, Math.Max(newRows, (short)1));
            csbi.srWindow = new SmallRect(0, 0, newCols, newRows);
            csbi.dwMaximumWindowSize = new Coord(newCols, newRows);
            if (!SetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }
            var winRect = new SmallRect(0, 0, (short)(newCols - 1), (short)Math.Max(newRows - 1, 0));
            if (!SetConsoleWindowInfo(OutputHandle, true, ref winRect))
            {
                //throw new System.ComponentModel.Win32Exception (Marshal.GetLastWin32Error ());
                return new Size(_cols, _rows);
            }
            SetConsoleOutputWindow(csbi);
            return new Size(winRect.Right + 1, newRows - 1 < 0 ? 0 : winRect.Bottom + 1);
        }
        //master*//

        void SetConsoleOutputWindow(CONSOLE_SCREEN_BUFFER_INFOEX csbi)
        {
            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) != IntPtr.Zero && !SetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }
        }

        internal Size SetConsoleOutputWindow(out Point position)
        {
            if ((IsWindowsTerminal ? OutputHandle : screenBuffer) == IntPtr.Zero)
            {
                position = Point.Empty;
                return Size.Empty;
            }

            var csbi = new CONSOLE_SCREEN_BUFFER_INFOEX();
            csbi.cbSize = (uint)Marshal.SizeOf(csbi);
            if (!GetConsoleScreenBufferInfoEx(IsWindowsTerminal ? OutputHandle : screenBuffer, ref csbi))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }
            var sz = new Size(csbi.srWindow.Right - csbi.srWindow.Left + 1,
                Math.Max(csbi.srWindow.Bottom - csbi.srWindow.Top + 1, 0));
            position = new Point(csbi.srWindow.Left, csbi.srWindow.Top);
            SetConsoleOutputWindow(csbi);
            var winRect = new SmallRect(0, 0, (short)(sz.Width - 1), (short)Math.Max(sz.Height - 1, 0));
            if (!SetConsoleScreenBufferInfoEx(OutputHandle, ref csbi))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }
            if (!SetConsoleWindowInfo(OutputHandle, true, ref winRect))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
            }

            return sz;
        }

        //bool ContinueListeningForConsoleEvents = true;

        internal bool IsWindowsTerminal { get; set; }

        public uint ConsoleMode
        {
            get
            {
                GetConsoleMode(InputHandle, out uint v);
                return v;
            }
            set
            {
                SetConsoleMode(InputHandle, value);
            }
        }

        [Flags]
        public enum ConsoleModes : uint
        {
            EnableProcessedInput = 1,
            EnableMouseInput = 16,
            EnableQuickEditMode = 64,
            EnableExtendedFlags = 128,
        }

        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public struct KeyEventRecord
        {
            [FieldOffset(0), MarshalAs(UnmanagedType.Bool)]
            public bool bKeyDown;
            [FieldOffset(4), MarshalAs(UnmanagedType.U2)]
            public ushort wRepeatCount;
            [FieldOffset(6), MarshalAs(UnmanagedType.U2)]
            public ushort wVirtualKeyCode;
            [FieldOffset(8), MarshalAs(UnmanagedType.U2)]
            public ushort wVirtualScanCode;
            [FieldOffset(10)]
            public char UnicodeChar;
            [FieldOffset(12), MarshalAs(UnmanagedType.U4)]
            public ControlKeyState dwControlKeyState;
        }

        [Flags]
        public enum ButtonState
        {
            Button1Pressed = 1,
            Button2Pressed = 4,
            Button3Pressed = 8,
            Button4Pressed = 16,
            RightmostButtonPressed = 2
        }

        [Flags]
        public enum ControlKeyState
        {
            RightAltPressed = 1,
            LeftAltPressed = 2,
            RightControlPressed = 4,
            LeftControlPressed = 8,
            ShiftPressed = 16,
            NumlockOn = 32,
            ScrolllockOn = 64,
            CapslockOn = 128,
            EnhancedKey = 256
        }

        [Flags]
        public enum EventFlags
        {
            MouseMoved = 1,
            DoubleClick = 2,
            MouseWheeled = 4,
            MouseHorizontalWheeled = 8
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct MouseEventRecord
        {
            [FieldOffset(0)]
            public Coord MousePosition;
            [FieldOffset(4)]
            public ButtonState ButtonState;
            [FieldOffset(8)]
            public ControlKeyState ControlKeyState;
            [FieldOffset(12)]
            public EventFlags EventFlags;

            public override string ToString()
            {
                return $"[Mouse({MousePosition},{ButtonState},{ControlKeyState},{EventFlags}";
            }
        }

        public struct WindowBufferSizeRecord
        {
            public Coord size;

            public WindowBufferSizeRecord(short x, short y)
            {
                this.size = new Coord(x, y);
            }

            public override string ToString() => $"[WindowBufferSize{size}";
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MenuEventRecord
        {
            public uint dwCommandId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct FocusEventRecord
        {
            public uint bSetFocus;
        }

        public enum EventType : ushort
        {
            Focus = 0x10,
            Key = 0x1,
            Menu = 0x8,
            Mouse = 2,
            WindowBufferSize = 4
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct InputRecord
        {
            [FieldOffset(0)]
            public EventType EventType;
            [FieldOffset(4)]
            public KeyEventRecord KeyEvent;
            [FieldOffset(4)]
            public MouseEventRecord MouseEvent;
            [FieldOffset(4)]
            public WindowBufferSizeRecord WindowBufferSizeEvent;
            [FieldOffset(4)]
            public MenuEventRecord MenuEvent;
            [FieldOffset(4)]
            public FocusEventRecord FocusEvent;

            public override string ToString()
            {
                switch (EventType)
                {
                    case EventType.Focus:
                        return FocusEvent.ToString();
                    case EventType.Key:
                        return KeyEvent.ToString();
                    case EventType.Menu:
                        return MenuEvent.ToString();
                    case EventType.Mouse:
                        return MouseEvent.ToString();
                    case EventType.WindowBufferSize:
                        return WindowBufferSizeEvent.ToString();
                    default:
                        return "Unknown event type: " + EventType;
                }
            }
        };

        [Flags]
        enum ShareMode : uint
        {
            FileShareRead = 1,
            FileShareWrite = 2,
        }

        [Flags]
        enum DesiredAccess : uint
        {
            GenericRead = 2147483648,
            GenericWrite = 1073741824,
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct ConsoleScreenBufferInfo
        {
            public Coord dwSize;
            public Coord dwCursorPosition;
            public ushort wAttributes;
            public SmallRect srWindow;
            public Coord dwMaximumWindowSize;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct Coord
        {
            public short X;
            public short Y;

            public Coord(short X, short Y)
            {
                this.X = X;
                this.Y = Y;
            }
            public override string ToString() => $"({X},{Y})";
        };

        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public struct CharUnion
        {
            [FieldOffset(0)] public char UnicodeChar;
            [FieldOffset(0)] public byte AsciiChar;
        }

        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public struct CharInfo
        {
            [FieldOffset(0)] public CharUnion Char;
            [FieldOffset(2)] public ushort Attributes;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SmallRect
        {
            public short Left;
            public short Top;
            public short Right;
            public short Bottom;

            public SmallRect(short left, short top, short right, short bottom)
            {
                Left = left;
                Top = top;
                Right = right;
                Bottom = bottom;
            }

            public static void MakeEmpty(ref SmallRect rect)
            {
                rect.Left = -1;
            }

            public static void Update(ref SmallRect rect, short col, short row)
            {
                if (rect.Left == -1)
                {
                    //System.Diagnostics.Debugger.Log (0, "debug", $"damager From Empty {col},{row}\n");
                    rect.Left = rect.Right = col;
                    rect.Bottom = rect.Top = row;
                    return;
                }
                if (col >= rect.Left && col <= rect.Right && row >= rect.Top && row <= rect.Bottom)
                    return;
                if (col < rect.Left)
                    rect.Left = col;
                if (col > rect.Right)
                    rect.Right = col;
                if (row < rect.Top)
                    rect.Top = row;
                if (row > rect.Bottom)
                    rect.Bottom = row;
                //System.Diagnostics.Debugger.Log (0, "debug", $"Expanding {rect.ToString ()}\n");
            }

            public override string ToString()
            {
                return $"Left={Left},Top={Top},Right={Right},Bottom={Bottom}";
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct ConsoleKeyInfoEx
        {
            public ConsoleKeyInfo consoleKeyInfo;
            public bool CapsLock;
            public bool NumLock;
            public bool Scrolllock;

            public ConsoleKeyInfoEx(ConsoleKeyInfo consoleKeyInfo, bool capslock, bool numlock, bool scrolllock)
            {
                this.consoleKeyInfo = consoleKeyInfo;
                CapsLock = capslock;
                NumLock = numlock;
                Scrolllock = scrolllock;
            }
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool CloseHandle(IntPtr handle);

        [DllImport("kernel32.dll", EntryPoint = "ReadConsoleInputW", CharSet = CharSet.Unicode)]
        public static extern bool ReadConsoleInput(
            IntPtr hConsoleInput,
            IntPtr lpBuffer,
            uint nLength,
            out uint lpNumberOfEventsRead);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        static extern bool ReadConsoleOutput(
            IntPtr hConsoleOutput,
            [Out] CharInfo[] lpBuffer,
            Coord dwBufferSize,
            Coord dwBufferCoord,
            ref SmallRect lpReadRegion
        );

        [DllImport("kernel32.dll", EntryPoint = "WriteConsoleOutput", SetLastError = true, CharSet = CharSet.Unicode)]
        static extern bool WriteConsoleOutput(
            IntPtr hConsoleOutput,
            CharInfo[] lpBuffer,
            Coord dwBufferSize,
            Coord dwBufferCoord,
            ref SmallRect lpWriteRegion
        );

        [DllImport("kernel32.dll")]
        static extern bool SetConsoleCursorPosition(IntPtr hConsoleOutput, Coord dwCursorPosition);

        [StructLayout(LayoutKind.Sequential)]
        public struct ConsoleCursorInfo
        {
            public uint dwSize;
            public bool bVisible;
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool SetConsoleCursorInfo(IntPtr hConsoleOutput, [In] ref ConsoleCursorInfo lpConsoleCursorInfo);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool GetConsoleCursorInfo(IntPtr hConsoleOutput, out ConsoleCursorInfo lpConsoleCursorInfo);

        [DllImport("kernel32.dll")]
        static extern bool GetConsoleMode(IntPtr hConsoleHandle, out uint lpMode);


        [DllImport("kernel32.dll")]
        static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint dwMode);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateConsoleScreenBuffer(
            DesiredAccess dwDesiredAccess,
            ShareMode dwShareMode,
            IntPtr secutiryAttributes,
            uint flags,
            IntPtr screenBufferData
        );

        internal static IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool SetConsoleActiveScreenBuffer(IntPtr Handle);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool GetNumberOfConsoleInputEvents(IntPtr handle, out uint lpcNumberOfEvents);
        public uint InputEventCount
        {
            get
            {
                GetNumberOfConsoleInputEvents(InputHandle, out uint v);
                return v;
            }
        }

        public InputRecord[] ReadConsoleInput()
        {
            const int bufferSize = 1;
            var pRecord = Marshal.AllocHGlobal(Marshal.SizeOf<InputRecord>() * bufferSize);
            try
            {
                ReadConsoleInput(InputHandle, pRecord, bufferSize,
                    out var numberEventsRead);

                return numberEventsRead == 0
                    ? null
                    : new[] { Marshal.PtrToStructure<InputRecord>(pRecord) };
            }
            catch (Exception)
            {
                return null;
            }
            finally
            {
                Marshal.FreeHGlobal(pRecord);
            }
        }

#if false      // Not needed on the constructor. Perhaps could be used on resizing. To study.                                                                                     
		[DllImport ("kernel32.dll", ExactSpelling = true)]
		static extern IntPtr GetConsoleWindow ();

		[DllImport ("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		static extern bool ShowWindow (IntPtr hWnd, int nCmdShow);

		public const int HIDE = 0;
		public const int MAXIMIZE = 3;
		public const int MINIMIZE = 6;
		public const int RESTORE = 9;

		internal void ShowWindow (int state)
		{
			IntPtr thisConsole = GetConsoleWindow ();
			ShowWindow (thisConsole, state);
		}
#endif
        // See: https://github.com/gui-cs/Terminal.Gui/issues/357

        [StructLayout(LayoutKind.Sequential)]
        public struct CONSOLE_SCREEN_BUFFER_INFOEX
        {
            public uint cbSize;
            public Coord dwSize;
            public Coord dwCursorPosition;
            public ushort wAttributes;
            public SmallRect srWindow;
            public Coord dwMaximumWindowSize;
            public ushort wPopupAttributes;
            public bool bFullscreenSupported;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public COLORREF[] ColorTable;
        }

        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public struct COLORREF
        {
            public COLORREF(byte r, byte g, byte b)
            {
                Value = 0;
                R = r;
                G = g;
                B = b;
            }

            public COLORREF(uint value)
            {
                R = 0;
                G = 0;
                B = 0;
                Value = value & 0x00FFFFFF;
            }

            [FieldOffset(0)]
            public byte R;
            [FieldOffset(1)]
            public byte G;
            [FieldOffset(2)]
            public byte B;

            [FieldOffset(0)]
            public uint Value;
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool GetConsoleScreenBufferInfoEx(IntPtr hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFOEX csbi);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool SetConsoleScreenBufferInfoEx(IntPtr hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFOEX ConsoleScreenBufferInfo);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool SetConsoleWindowInfo(
            IntPtr hConsoleOutput,
            bool bAbsolute,
            [In] ref SmallRect lpConsoleWindow);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern Coord GetLargestConsoleWindowSize(
            IntPtr hConsoleOutput);
    }

    internal class WindowsDriver : ConsoleDriver
    {
        static bool sync = false;
        WindowsConsole.CharInfo[] OutputBuffer;
        int cols, rows, left, top;
        WindowsConsole.SmallRect damageRegion;
        IClipboard clipboard;
        int[,,] contents;
        readonly bool isWindowsTerminal;

        public override int Cols => cols;
        public override int Rows => rows;
        public override int Left => left;
        public override int Top => top;
        [Obsolete("This API is deprecated", false)]
        public override bool EnableConsoleScrolling { get; set; }
        [Obsolete("This API is deprecated", false)]
        public override bool HeightAsBuffer { get; set; }
        public override IClipboard Clipboard => clipboard;
        public override int[,,] Contents => contents;

        public WindowsConsole WinConsole { get; private set; }

        Action<KeyEvent> keyHandler;
        Action<KeyEvent> keyDownHandler;
        Action<KeyEvent> keyUpHandler;
        Action<MouseEvent> mouseHandler;

        public WindowsDriver()
        {
            WinConsole = new WindowsConsole();
            clipboard = new WindowsClipboard();

            WinConsole.IsWindowsTerminal = isWindowsTerminal = Environment.GetEnvironmentVariable("WT_SESSION") != null || Environment.GetEnvironmentVariable("VSAPPIDNAME") != null;
        }

        public override void PrepareToRun(MainLoop mainLoop, Action<KeyEvent> keyHandler, Action<KeyEvent> keyDownHandler, Action<KeyEvent> keyUpHandler, Action<MouseEvent> mouseHandler)
        {
            this.keyHandler = keyHandler;
            this.keyDownHandler = keyDownHandler;
            this.keyUpHandler = keyUpHandler;
            this.mouseHandler = mouseHandler;

            var mLoop = mainLoop.Driver as WindowsMainLoop;

            mLoop.ProcessInput = (e) => ProcessInput(e);

            mLoop.WinChanged = (e) =>
            {
                ChangeWin(e);
            };
        }

        private void ChangeWin(Size e)
        {
            var w = e.Width;
            if (w == cols - 3 && e.Height < rows)
            {
                w += 3;
            }
            var newSize = WinConsole.SetConsoleWindow(
                (short)Math.Max(w, 16), (short)Math.Max(e.Height, 0));

            left = 0;
            top = 0;
            cols = newSize.Width;
            rows = newSize.Height;
            ResizeScreen();
            UpdateOffScreen();
            TerminalResized.Invoke();
        }

        void ProcessInput(WindowsConsole.InputRecord inputEvent)
        {
            switch (inputEvent.EventType)
            {
                case WindowsConsole.EventType.Key:
                    var fromPacketKey = inputEvent.KeyEvent.wVirtualKeyCode == (uint)ConsoleKey.Packet;
                    if (fromPacketKey)
                    {
                        inputEvent.KeyEvent = FromVKPacketToKeyEventRecord(inputEvent.KeyEvent);
                    }
                    var map = MapKey(ToConsoleKeyInfoEx(inputEvent.KeyEvent));
                    //var ke = inputEvent.KeyEvent;
                    //System.Diagnostics.Debug.WriteLine ($"fromPacketKey: {fromPacketKey}");
                    //if (ke.UnicodeChar == '\0') {
                    //	System.Diagnostics.Debug.WriteLine ("UnicodeChar: 0'\\0'");
                    //} else if (ke.UnicodeChar == 13) {
                    //	System.Diagnostics.Debug.WriteLine ("UnicodeChar: 13'\\n'");
                    //} else {
                    //	System.Diagnostics.Debug.WriteLine ($"UnicodeChar: {(uint)ke.UnicodeChar}'{ke.UnicodeChar}'");
                    //}
                    //System.Diagnostics.Debug.WriteLine ($"bKeyDown: {ke.bKeyDown}");
                    //System.Diagnostics.Debug.WriteLine ($"dwControlKeyState: {ke.dwControlKeyState}");
                    //System.Diagnostics.Debug.WriteLine ($"wRepeatCount: {ke.wRepeatCount}");
                    //System.Diagnostics.Debug.WriteLine ($"wVirtualKeyCode: {ke.wVirtualKeyCode}");
                    //System.Diagnostics.Debug.WriteLine ($"wVirtualScanCode: {ke.wVirtualScanCode}");

                    if (map == (Key)0xffffffff)
                    {
                        KeyEvent key = new KeyEvent();

                        // Shift = VK_SHIFT = 0x10
                        // Ctrl = VK_CONTROL = 0x11
                        // Alt = VK_MENU = 0x12

                        if (inputEvent.KeyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.CapslockOn))
                        {
                            inputEvent.KeyEvent.dwControlKeyState &= ~WindowsConsole.ControlKeyState.CapslockOn;
                        }

                        if (inputEvent.KeyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.ScrolllockOn))
                        {
                            inputEvent.KeyEvent.dwControlKeyState &= ~WindowsConsole.ControlKeyState.ScrolllockOn;
                        }

                        if (inputEvent.KeyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.NumlockOn))
                        {
                            inputEvent.KeyEvent.dwControlKeyState &= ~WindowsConsole.ControlKeyState.NumlockOn;
                        }

                        switch (inputEvent.KeyEvent.dwControlKeyState)
                        {
                            case WindowsConsole.ControlKeyState.RightAltPressed:
                            case WindowsConsole.ControlKeyState.RightAltPressed |
                            WindowsConsole.ControlKeyState.LeftControlPressed |
                            WindowsConsole.ControlKeyState.EnhancedKey:
                            case WindowsConsole.ControlKeyState.EnhancedKey:
                                key = new KeyEvent(Key.CtrlMask | Key.AltMask, keyModifiers);
                                break;
                            case WindowsConsole.ControlKeyState.LeftAltPressed:
                                key = new KeyEvent(Key.AltMask, keyModifiers);
                                break;
                            case WindowsConsole.ControlKeyState.RightControlPressed:
                            case WindowsConsole.ControlKeyState.LeftControlPressed:
                                key = new KeyEvent(Key.CtrlMask, keyModifiers);
                                break;
                            case WindowsConsole.ControlKeyState.ShiftPressed:
                                key = new KeyEvent(Key.ShiftMask, keyModifiers);
                                break;
                            case WindowsConsole.ControlKeyState.NumlockOn:
                                break;
                            case WindowsConsole.ControlKeyState.ScrolllockOn:
                                break;
                            case WindowsConsole.ControlKeyState.CapslockOn:
                                break;
                            default:
                                switch (inputEvent.KeyEvent.wVirtualKeyCode)
                                {
                                    case 0x10:
                                        key = new KeyEvent(Key.ShiftMask, keyModifiers);
                                        break;
                                    case 0x11:
                                        key = new KeyEvent(Key.CtrlMask, keyModifiers);
                                        break;
                                    case 0x12:
                                        key = new KeyEvent(Key.AltMask, keyModifiers);
                                        break;
                                    default:
                                        key = new KeyEvent(Key.Unknown, keyModifiers);
                                        break;
                                }
                                break;
                        }

                        if (inputEvent.KeyEvent.bKeyDown)
                            keyDownHandler(key);
                        else
                            keyUpHandler(key);
                    }
                    else
                    {
                        if (inputEvent.KeyEvent.bKeyDown)
                        {
                            // May occurs using SendKeys
                            if (keyModifiers == null)
                                keyModifiers = new KeyModifiers();
                            // Key Down - Fire KeyDown Event and KeyStroke (ProcessKey) Event
                            keyDownHandler(new KeyEvent(map, keyModifiers));
                            keyHandler(new KeyEvent(map, keyModifiers));
                        }
                        else
                        {
                            keyUpHandler(new KeyEvent(map, keyModifiers));
                        }
                    }
                    if (!inputEvent.KeyEvent.bKeyDown && (inputEvent.KeyEvent.dwControlKeyState == 0 || inputEvent.KeyEvent.dwControlKeyState == WindowsConsole.ControlKeyState.EnhancedKey))
                    {
                        keyModifiers = null;
                    }
                    break;

                case WindowsConsole.EventType.Mouse:
                    var me = ToDriverMouse(inputEvent.MouseEvent);
                    mouseHandler(me);
                    if (processButtonClick)
                    {
                        mouseHandler(
                            new MouseEvent()
                            {
                                X = me.X,
                                Y = me.Y,
                                Flags = ProcessButtonClick(inputEvent.MouseEvent)
                            });
                    }
                    break;

                case WindowsConsole.EventType.Focus:
                    keyModifiers = null;
                    break;
            }
        }

        WindowsConsole.ButtonState? lastMouseButtonPressed = null;
        bool isButtonPressed = false;
        bool isButtonReleased = false;
        bool isButtonDoubleClicked = false;
        Point? point;
        Point pointMove;
        //int buttonPressedCount;
        bool isOneFingerDoubleClicked = false;
        bool processButtonClick;

        MouseEvent ToDriverMouse(WindowsConsole.MouseEventRecord mouseEvent)
        {
            MouseFlags mouseFlag = MouseFlags.AllEvents;

            //System.Diagnostics.Debug.WriteLine (
            //	$"X:{mouseEvent.MousePosition.X};Y:{mouseEvent.MousePosition.Y};ButtonState:{mouseEvent.ButtonState};EventFlags:{mouseEvent.EventFlags}");

            if (isButtonDoubleClicked || isOneFingerDoubleClicked)
            {
                Application.MainLoop.AddIdle(() =>
                {
                    Task.Run(async () => await ProcessButtonDoubleClickedAsync());
                    return false;
                });
            }

            // The ButtonState member of the MouseEvent structure has bit corresponding to each mouse button.
            // This will tell when a mouse button is pressed. When the button is released this event will
            // be fired with it's bit set to 0. So when the button is up ButtonState will be 0.
            // To map to the correct driver events we save the last pressed mouse button so we can
            // map to the correct clicked event.
            if ((lastMouseButtonPressed != null || isButtonReleased) && mouseEvent.ButtonState != 0)
            {
                lastMouseButtonPressed = null;
                //isButtonPressed = false;
                isButtonReleased = false;
            }

            var p = new Point()
            {
                X = mouseEvent.MousePosition.X,
                Y = mouseEvent.MousePosition.Y
            };

            //if (!isButtonPressed && buttonPressedCount < 2
            //	&& mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved
            //	&& (mouseEvent.ButtonState == WindowsConsole.ButtonState.Button1Pressed
            //	|| mouseEvent.ButtonState == WindowsConsole.ButtonState.Button2Pressed
            //	|| mouseEvent.ButtonState == WindowsConsole.ButtonState.Button3Pressed)) {

            //	lastMouseButtonPressed = mouseEvent.ButtonState;
            //	buttonPressedCount++;
            //} else if (!isButtonPressed && buttonPressedCount > 0 && mouseEvent.ButtonState == 0
            //	&& mouseEvent.EventFlags == 0) {

            //	buttonPressedCount++;
            //}
            //System.Diagnostics.Debug.WriteLine ($"isButtonPressed: {isButtonPressed};buttonPressedCount: {buttonPressedCount};lastMouseButtonPressed: {lastMouseButtonPressed}");
            //System.Diagnostics.Debug.WriteLine ($"isOneFingerDoubleClicked: {isOneFingerDoubleClicked}");

            //if (buttonPressedCount == 1 && lastMouseButtonPressed != null && p == point
            //	&& lastMouseButtonPressed == WindowsConsole.ButtonState.Button1Pressed
            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button2Pressed
            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button3Pressed) {

            //	switch (lastMouseButtonPressed) {
            //	case WindowsConsole.ButtonState.Button1Pressed:
            //		mouseFlag = MouseFlags.Button1DoubleClicked;
            //		break;

            //	case WindowsConsole.ButtonState.Button2Pressed:
            //		mouseFlag = MouseFlags.Button2DoubleClicked;
            //		break;

            //	case WindowsConsole.ButtonState.Button3Pressed:
            //		mouseFlag = MouseFlags.Button3DoubleClicked;
            //		break;
            //	}
            //	isOneFingerDoubleClicked = true;

            //} else if (buttonPressedCount == 3 && lastMouseButtonPressed != null && isOneFingerDoubleClicked && p == point
            //	&& lastMouseButtonPressed == WindowsConsole.ButtonState.Button1Pressed
            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button2Pressed
            //	|| lastMouseButtonPressed == WindowsConsole.ButtonState.Button3Pressed) {

            //	switch (lastMouseButtonPressed) {
            //	case WindowsConsole.ButtonState.Button1Pressed:
            //		mouseFlag = MouseFlags.Button1TripleClicked;
            //		break;

            //	case WindowsConsole.ButtonState.Button2Pressed:
            //		mouseFlag = MouseFlags.Button2TripleClicked;
            //		break;

            //	case WindowsConsole.ButtonState.Button3Pressed:
            //		mouseFlag = MouseFlags.Button3TripleClicked;
            //		break;
            //	}
            //	buttonPressedCount = 0;
            //	lastMouseButtonPressed = null;
            //	isOneFingerDoubleClicked = false;
            //	isButtonReleased = false;

            //}
            if ((mouseEvent.ButtonState != 0 && mouseEvent.EventFlags == 0 && lastMouseButtonPressed == null && !isButtonDoubleClicked) ||
                 (lastMouseButtonPressed == null && mouseEvent.EventFlags.HasFlag(WindowsConsole.EventFlags.MouseMoved) &&
                 mouseEvent.ButtonState != 0 && !isButtonReleased && !isButtonDoubleClicked))
            {
                switch (mouseEvent.ButtonState)
                {
                    case WindowsConsole.ButtonState.Button1Pressed:
                        mouseFlag = MouseFlags.Button1Pressed;
                        break;

                    case WindowsConsole.ButtonState.Button2Pressed:
                        mouseFlag = MouseFlags.Button2Pressed;
                        break;

                    case WindowsConsole.ButtonState.RightmostButtonPressed:
                        mouseFlag = MouseFlags.Button3Pressed;
                        break;
                }

                if (point == null)
                    point = p;

                if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved)
                {
                    mouseFlag |= MouseFlags.ReportMousePosition;
                    isButtonReleased = false;
                    processButtonClick = false;
                }
                lastMouseButtonPressed = mouseEvent.ButtonState;
                isButtonPressed = true;

                if ((mouseFlag & MouseFlags.ReportMousePosition) == 0)
                {
                    Application.MainLoop.AddIdle(() =>
                    {
                        Task.Run(async () => await ProcessContinuousButtonPressedAsync(mouseFlag));
                        return false;
                    });
                }

            }
            else if (lastMouseButtonPressed != null && mouseEvent.EventFlags == 0
              && !isButtonReleased && !isButtonDoubleClicked && !isOneFingerDoubleClicked)
            {
                switch (lastMouseButtonPressed)
                {
                    case WindowsConsole.ButtonState.Button1Pressed:
                        mouseFlag = MouseFlags.Button1Released;
                        break;

                    case WindowsConsole.ButtonState.Button2Pressed:
                        mouseFlag = MouseFlags.Button2Released;
                        break;

                    case WindowsConsole.ButtonState.RightmostButtonPressed:
                        mouseFlag = MouseFlags.Button3Released;
                        break;
                }
                isButtonPressed = false;
                isButtonReleased = true;
                if (point != null && (((Point)point).X == mouseEvent.MousePosition.X && ((Point)point).Y == mouseEvent.MousePosition.Y))
                {
                    processButtonClick = true;
                }
                else
                {
                    point = null;
                }
            }
            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved
              && !isOneFingerDoubleClicked && isButtonReleased && p == point)
            {

                mouseFlag = ProcessButtonClick(mouseEvent);

            }
            else if (mouseEvent.EventFlags.HasFlag(WindowsConsole.EventFlags.DoubleClick))
            {
                switch (mouseEvent.ButtonState)
                {
                    case WindowsConsole.ButtonState.Button1Pressed:
                        mouseFlag = MouseFlags.Button1DoubleClicked;
                        break;

                    case WindowsConsole.ButtonState.Button2Pressed:
                        mouseFlag = MouseFlags.Button2DoubleClicked;
                        break;

                    case WindowsConsole.ButtonState.RightmostButtonPressed:
                        mouseFlag = MouseFlags.Button3DoubleClicked;
                        break;
                }
                isButtonDoubleClicked = true;
            }
            else if (mouseEvent.EventFlags == 0 && mouseEvent.ButtonState != 0 && isButtonDoubleClicked)
            {
                switch (mouseEvent.ButtonState)
                {
                    case WindowsConsole.ButtonState.Button1Pressed:
                        mouseFlag = MouseFlags.Button1TripleClicked;
                        break;

                    case WindowsConsole.ButtonState.Button2Pressed:
                        mouseFlag = MouseFlags.Button2TripleClicked;
                        break;

                    case WindowsConsole.ButtonState.RightmostButtonPressed:
                        mouseFlag = MouseFlags.Button3TripleClicked;
                        break;
                }
                isButtonDoubleClicked = false;
            }
            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseWheeled)
            {
                switch ((int)mouseEvent.ButtonState)
                {
                    case int v when v > 0:
                        mouseFlag = MouseFlags.WheeledUp;
                        break;

                    case int v when v < 0:
                        mouseFlag = MouseFlags.WheeledDown;
                        break;
                }

            }
            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseWheeled &&
              mouseEvent.ControlKeyState == WindowsConsole.ControlKeyState.ShiftPressed)
            {
                switch ((int)mouseEvent.ButtonState)
                {
                    case int v when v > 0:
                        mouseFlag = MouseFlags.WheeledLeft;
                        break;

                    case int v when v < 0:
                        mouseFlag = MouseFlags.WheeledRight;
                        break;
                }

            }
            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseHorizontalWheeled)
            {
                switch ((int)mouseEvent.ButtonState)
                {
                    case int v when v < 0:
                        mouseFlag = MouseFlags.WheeledLeft;
                        break;

                    case int v when v > 0:
                        mouseFlag = MouseFlags.WheeledRight;
                        break;
                }

            }
            else if (mouseEvent.EventFlags == WindowsConsole.EventFlags.MouseMoved)
            {
                mouseFlag = MouseFlags.ReportMousePosition;
                if (mouseEvent.MousePosition.X != pointMove.X || mouseEvent.MousePosition.Y != pointMove.Y)
                {
                    pointMove = new Point(mouseEvent.MousePosition.X, mouseEvent.MousePosition.Y);
                }
            }
            else if (mouseEvent.ButtonState == 0 && mouseEvent.EventFlags == 0)
            {
                mouseFlag = 0;
            }

            mouseFlag = SetControlKeyStates(mouseEvent, mouseFlag);

            //System.Diagnostics.Debug.WriteLine (
            //	$"point.X:{(point != null ? ((Point)point).X : -1)};point.Y:{(point != null ? ((Point)point).Y : -1)}");

            return new MouseEvent()
            {
                X = mouseEvent.MousePosition.X,
                Y = mouseEvent.MousePosition.Y,
                Flags = mouseFlag
            };
        }

        MouseFlags ProcessButtonClick(WindowsConsole.MouseEventRecord mouseEvent)
        {
            MouseFlags mouseFlag = 0;
            switch (lastMouseButtonPressed)
            {
                case WindowsConsole.ButtonState.Button1Pressed:
                    mouseFlag = MouseFlags.Button1Clicked;
                    break;

                case WindowsConsole.ButtonState.Button2Pressed:
                    mouseFlag = MouseFlags.Button2Clicked;
                    break;

                case WindowsConsole.ButtonState.RightmostButtonPressed:
                    mouseFlag = MouseFlags.Button3Clicked;
                    break;
            }
            point = new Point()
            {
                X = mouseEvent.MousePosition.X,
                Y = mouseEvent.MousePosition.Y
            };
            lastMouseButtonPressed = null;
            isButtonReleased = false;
            processButtonClick = false;
            point = null;
            return mouseFlag;
        }

        async Task ProcessButtonDoubleClickedAsync()
        {
            await Task.Delay(300);
            isButtonDoubleClicked = false;
            isOneFingerDoubleClicked = false;
            //buttonPressedCount = 0;
        }

        async Task ProcessContinuousButtonPressedAsync(MouseFlags mouseFlag)
        {
            while (isButtonPressed)
            {
                await Task.Delay(100);
                var me = new MouseEvent()
                {
                    X = pointMove.X,
                    Y = pointMove.Y,
                    Flags = mouseFlag
                };

                var view = Application.WantContinuousButtonPressedView;
                if (view == null)
                {
                    break;
                }
                if (isButtonPressed && (mouseFlag & MouseFlags.ReportMousePosition) == 0)
                {
                    Application.MainLoop.Invoke(() => mouseHandler(me));
                }
            }
        }

        static MouseFlags SetControlKeyStates(WindowsConsole.MouseEventRecord mouseEvent, MouseFlags mouseFlag)
        {
            if (mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightControlPressed) ||
                mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftControlPressed))
                mouseFlag |= MouseFlags.ButtonCtrl;

            if (mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.ShiftPressed))
                mouseFlag |= MouseFlags.ButtonShift;

            if (mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightAltPressed) ||
                 mouseEvent.ControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftAltPressed))
                mouseFlag |= MouseFlags.ButtonAlt;
            return mouseFlag;
        }

        KeyModifiers keyModifiers;

        public WindowsConsole.ConsoleKeyInfoEx ToConsoleKeyInfoEx(WindowsConsole.KeyEventRecord keyEvent)
        {
            var state = keyEvent.dwControlKeyState;

            bool shift = (state & WindowsConsole.ControlKeyState.ShiftPressed) != 0;
            bool alt = (state & (WindowsConsole.ControlKeyState.LeftAltPressed | WindowsConsole.ControlKeyState.RightAltPressed)) != 0;
            bool control = (state & (WindowsConsole.ControlKeyState.LeftControlPressed | WindowsConsole.ControlKeyState.RightControlPressed)) != 0;
            bool capslock = (state & (WindowsConsole.ControlKeyState.CapslockOn)) != 0;
            bool numlock = (state & (WindowsConsole.ControlKeyState.NumlockOn)) != 0;
            bool scrolllock = (state & (WindowsConsole.ControlKeyState.ScrolllockOn)) != 0;

            if (keyModifiers == null)
                keyModifiers = new KeyModifiers();
            if (shift)
                keyModifiers.Shift = shift;
            if (alt)
                keyModifiers.Alt = alt;
            if (control)
                keyModifiers.Ctrl = control;
            if (capslock)
                keyModifiers.Capslock = capslock;
            if (numlock)
                keyModifiers.Numlock = numlock;
            if (scrolllock)
                keyModifiers.Scrolllock = scrolllock;

            var ConsoleKeyInfo = new ConsoleKeyInfo(keyEvent.UnicodeChar, (ConsoleKey)keyEvent.wVirtualKeyCode, shift, alt, control);

            return new WindowsConsole.ConsoleKeyInfoEx(ConsoleKeyInfo, capslock, numlock, scrolllock);
        }

        public WindowsConsole.KeyEventRecord FromVKPacketToKeyEventRecord(WindowsConsole.KeyEventRecord keyEvent)
        {
            if (keyEvent.wVirtualKeyCode != (uint)ConsoleKey.Packet)
            {
                return keyEvent;
            }

            var mod = new ConsoleModifiers();
            if (keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.ShiftPressed))
            {
                mod |= ConsoleModifiers.Shift;
            }
            if (keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightAltPressed) ||
                keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftAltPressed))
            {
                mod |= ConsoleModifiers.Alt;
            }
            if (keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.LeftControlPressed) ||
                keyEvent.dwControlKeyState.HasFlag(WindowsConsole.ControlKeyState.RightControlPressed))
            {
                mod |= ConsoleModifiers.Control;
            }
            var keyChar = ConsoleKeyMapping.GetKeyCharFromConsoleKey(keyEvent.UnicodeChar, mod, out uint virtualKey, out uint scanCode);

            return new WindowsConsole.KeyEventRecord
            {
                UnicodeChar = (char)keyChar,
                bKeyDown = keyEvent.bKeyDown,
                dwControlKeyState = keyEvent.dwControlKeyState,
                wRepeatCount = keyEvent.wRepeatCount,
                wVirtualKeyCode = (ushort)virtualKey,
                wVirtualScanCode = (ushort)scanCode
            };
        }

        public Key MapKey(WindowsConsole.ConsoleKeyInfoEx keyInfoEx)
        {
            var keyInfo = keyInfoEx.consoleKeyInfo;
            switch (keyInfo.Key)
            {
                case ConsoleKey.Escape:
                    return MapKeyModifiers(keyInfo, Key.Esc);
                case ConsoleKey.Tab:
                    return keyInfo.Modifiers == ConsoleModifiers.Shift ? Key.BackTab : Key.Tab;
                case ConsoleKey.Clear:
                    return MapKeyModifiers(keyInfo, Key.Clear);
                case ConsoleKey.Home:
                    return MapKeyModifiers(keyInfo, Key.Home);
                case ConsoleKey.End:
                    return MapKeyModifiers(keyInfo, Key.End);
                case ConsoleKey.LeftArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorLeft);
                case ConsoleKey.RightArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorRight);
                case ConsoleKey.UpArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorUp);
                case ConsoleKey.DownArrow:
                    return MapKeyModifiers(keyInfo, Key.CursorDown);
                case ConsoleKey.PageUp:
                    return MapKeyModifiers(keyInfo, Key.PageUp);
                case ConsoleKey.PageDown:
                    return MapKeyModifiers(keyInfo, Key.PageDown);
                case ConsoleKey.Enter:
                    return MapKeyModifiers(keyInfo, Key.Enter);
                case ConsoleKey.Spacebar:
                    return MapKeyModifiers(keyInfo, keyInfo.KeyChar == 0 ? Key.Space : (Key)keyInfo.KeyChar);
                case ConsoleKey.Backspace:
                    return MapKeyModifiers(keyInfo, Key.Backspace);
                case ConsoleKey.Delete:
                    return MapKeyModifiers(keyInfo, Key.DeleteChar);
                case ConsoleKey.Insert:
                    return MapKeyModifiers(keyInfo, Key.InsertChar);
                case ConsoleKey.PrintScreen:
                    return MapKeyModifiers(keyInfo, Key.PrintScreen);

                case ConsoleKey.NumPad0:
                    return keyInfoEx.NumLock ? Key.D0 : Key.InsertChar;
                case ConsoleKey.NumPad1:
                    return keyInfoEx.NumLock ? Key.D1 : Key.End;
                case ConsoleKey.NumPad2:
                    return keyInfoEx.NumLock ? Key.D2 : Key.CursorDown;
                case ConsoleKey.NumPad3:
                    return keyInfoEx.NumLock ? Key.D3 : Key.PageDown;
                case ConsoleKey.NumPad4:
                    return keyInfoEx.NumLock ? Key.D4 : Key.CursorLeft;
                case ConsoleKey.NumPad5:
                    return keyInfoEx.NumLock ? Key.D5 : (Key)((uint)keyInfo.KeyChar);
                case ConsoleKey.NumPad6:
                    return keyInfoEx.NumLock ? Key.D6 : Key.CursorRight;
                case ConsoleKey.NumPad7:
                    return keyInfoEx.NumLock ? Key.D7 : Key.Home;
                case ConsoleKey.NumPad8:
                    return keyInfoEx.NumLock ? Key.D8 : Key.CursorUp;
                case ConsoleKey.NumPad9:
                    return keyInfoEx.NumLock ? Key.D9 : Key.PageUp;

                case ConsoleKey.Oem1:
                case ConsoleKey.Oem2:
                case ConsoleKey.Oem3:
                case ConsoleKey.Oem4:
                case ConsoleKey.Oem5:
                case ConsoleKey.Oem6:
                case ConsoleKey.Oem7:
                case ConsoleKey.Oem8:
                case ConsoleKey.Oem102:
                case ConsoleKey.OemPeriod:
                case ConsoleKey.OemComma:
                case ConsoleKey.OemPlus:
                case ConsoleKey.OemMinus:
                    if (keyInfo.KeyChar == 0)
                        return Key.Unknown;

                    return (Key)((uint)keyInfo.KeyChar);
            }

            var key = keyInfo.Key;
            //var alphaBase = ((keyInfo.Modifiers == ConsoleModifiers.Shift) ^ (keyInfoEx.CapsLock)) ? 'A' : 'a';

            if (key >= ConsoleKey.A && key <= ConsoleKey.Z)
            {
                var delta = key - ConsoleKey.A;
                if (keyInfo.Modifiers == ConsoleModifiers.Control)
                {
                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.A + delta));
                }
                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
                {
                    return (Key)(((uint)Key.AltMask) | ((uint)Key.A + delta));
                }
                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
                {
                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
                }
                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    if (keyInfo.KeyChar == 0 || (keyInfo.KeyChar != 0 && keyInfo.KeyChar >= 1 && keyInfo.KeyChar <= 26))
                    {
                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.A + delta));
                    }
                }
                //return (Key)((uint)alphaBase + delta);
                return (Key)((uint)keyInfo.KeyChar);
            }
            if (key >= ConsoleKey.D0 && key <= ConsoleKey.D9)
            {
                var delta = key - ConsoleKey.D0;
                if (keyInfo.Modifiers == ConsoleModifiers.Alt)
                {
                    return (Key)(((uint)Key.AltMask) | ((uint)Key.D0 + delta));
                }
                if (keyInfo.Modifiers == ConsoleModifiers.Control)
                {
                    return (Key)(((uint)Key.CtrlMask) | ((uint)Key.D0 + delta));
                }
                if (keyInfo.Modifiers == (ConsoleModifiers.Shift | ConsoleModifiers.Alt))
                {
                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
                }
                if ((keyInfo.Modifiers & (ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    if (keyInfo.KeyChar == 0 || keyInfo.KeyChar == 30 || keyInfo.KeyChar == ((uint)Key.D0 + delta))
                    {
                        return MapKeyModifiers(keyInfo, (Key)((uint)Key.D0 + delta));
                    }
                }
                return (Key)((uint)keyInfo.KeyChar);
            }
            if (key >= ConsoleKey.F1 && key <= ConsoleKey.F12)
            {
                var delta = key - ConsoleKey.F1;
                if ((keyInfo.Modifiers & (ConsoleModifiers.Shift | ConsoleModifiers.Alt | ConsoleModifiers.Control)) != 0)
                {
                    return MapKeyModifiers(keyInfo, (Key)((uint)Key.F1 + delta));
                }

                return (Key)((uint)Key.F1 + delta);
            }
            if (keyInfo.KeyChar != 0)
            {
                return MapKeyModifiers(keyInfo, (Key)((uint)keyInfo.KeyChar));
            }

            return (Key)(0xffffffff);
        }

        private Key MapKeyModifiers(ConsoleKeyInfo keyInfo, Key key)
        {
            Key keyMod = new Key();
            if ((keyInfo.Modifiers & ConsoleModifiers.Shift) != 0)
                keyMod = Key.ShiftMask;
            if ((keyInfo.Modifiers & ConsoleModifiers.Control) != 0)
                keyMod |= Key.CtrlMask;
            if ((keyInfo.Modifiers & ConsoleModifiers.Alt) != 0)
                keyMod |= Key.AltMask;

            return keyMod != Key.Null ? keyMod | key : key;
        }

        public override void Init(Action terminalResized)
        {
            TerminalResized = terminalResized;

            try
            {
                // Needed for Windows Terminal
                // ESC [ ? 1047 h  Save cursor position and activate xterm alternative buffer (no backscroll)
                // ESC [ ? 1047 l  Restore cursor position and restore xterm working buffer (with backscroll)
                // ESC [ ? 1048 h  Save cursor position
                // ESC [ ? 1048 l  Restore cursor position
                // ESC [ ? 1049 h  Activate xterm alternative buffer (no backscroll)
                // ESC [ ? 1049 l  Restore xterm working buffer (with backscroll)
                // Per Issue #2264 using the alternative screen buffer is required for Windows Terminal to not 
                // wipe out the backscroll buffer when the application exits.
                if (isWindowsTerminal)
                {
                    Console.Out.Write("\x1b[?1049h");
                }

                var winSize = WinConsole.GetConsoleOutputWindow(out Point pos);
                cols = winSize.Width;
                rows = winSize.Height;
                WindowsConsole.SmallRect.MakeEmpty(ref damageRegion);

                CurrentAttribute = MakeColor(Color.White, Color.Black);
                InitalizeColorSchemes();

                CurrentAttribute = MakeColor(Color.White, Color.Black);
                InitalizeColorSchemes();

                OutputBuffer = new WindowsConsole.CharInfo[Rows * Cols];
                Clip = new Rect(0, 0, Cols, Rows);
                damageRegion = new WindowsConsole.SmallRect()
                {
                    Top = 0,
                    Left = 0,
                    Bottom = (short)Rows,
                    Right = (short)Cols
                };

                UpdateOffScreen();

            }
            catch (Win32Exception e)
            {
                throw new InvalidOperationException("The Windows Console output window is not available.", e);
            }
        }

        public override void ResizeScreen()
        {
            OutputBuffer = new WindowsConsole.CharInfo[Rows * Cols];
            Clip = new Rect(0, 0, Cols, Rows);
            damageRegion = new WindowsConsole.SmallRect()
            {
                Top = 0,
                Left = 0,
                Bottom = (short)Rows,
                Right = (short)Cols
            };
            WinConsole.ForceRefreshCursorVisibility();
        }

        public override void UpdateOffScreen()
        {
            contents = new int[rows, cols, 3];
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < cols; col++)
                {
                    int position = row * cols + col;
                    OutputBuffer[position].Attributes = (ushort)Colors.TopLevel.Normal;
                    OutputBuffer[position].Char.UnicodeChar = ' ';
                    contents[row, col, 0] = OutputBuffer[position].Char.UnicodeChar;
                    contents[row, col, 1] = OutputBuffer[position].Attributes;
                    contents[row, col, 2] = 0;
                }
            }
        }

        int ccol, crow;
        public override void Move(int col, int row)
        {
            ccol = col;
            crow = row;
        }

        int GetOutputBufferPosition()
        {
            return crow * Cols + ccol;
        }

        public override void AddRune(Rune rune)
        {
            rune = MakePrintable(rune);
            var runeWidth = Rune.ColumnWidth(rune);
            var position = GetOutputBufferPosition();
            var validClip = IsValidContent(ccol, crow, Clip);

            if (validClip)
            {
                if (runeWidth == 0 && ccol > 0)
                {
                    var r = contents[crow, ccol - 1, 0];
                    var s = new string(new char[] { (char)r, (char)rune });
                    string sn;
                    if (!s.IsNormalized())
                    {
                        sn = s.Normalize();
                    }
                    else
                    {
                        sn = s;
                    }
                    var c = sn[0];
                    var prevPosition = crow * Cols + (ccol - 1);
                    OutputBuffer[prevPosition].Char.UnicodeChar = c;
                    contents[crow, ccol - 1, 0] = c;
                    OutputBuffer[prevPosition].Attributes = (ushort)CurrentAttribute;
                    contents[crow, ccol - 1, 1] = CurrentAttribute;
                    contents[crow, ccol - 1, 2] = 1;
                    WindowsConsole.SmallRect.Update(ref damageRegion, (short)(ccol - 1), (short)crow);
                }
                else
                {
                    if (runeWidth < 2 && ccol > 0
                        && Rune.ColumnWidth((char)contents[crow, ccol - 1, 0]) > 1)
                    {

                        var prevPosition = crow * Cols + (ccol - 1);
                        OutputBuffer[prevPosition].Char.UnicodeChar = ' ';
                        contents[crow, ccol - 1, 0] = (int)(uint)' ';

                    }
                    else if (runeWidth < 2 && ccol <= Clip.Right - 1
                      && Rune.ColumnWidth((char)contents[crow, ccol, 0]) > 1)
                    {

                        var prevPosition = GetOutputBufferPosition() + 1;
                        OutputBuffer[prevPosition].Char.UnicodeChar = (char)' ';
                        contents[crow, ccol + 1, 0] = (int)(uint)' ';

                    }
                    if (runeWidth > 1 && ccol == Clip.Right - 1)
                    {
                        OutputBuffer[position].Char.UnicodeChar = (char)' ';
                        contents[crow, ccol, 0] = (int)(uint)' ';
                    }
                    else
                    {
                        OutputBuffer[position].Char.UnicodeChar = (char)rune;
                        contents[crow, ccol, 0] = (int)(uint)rune;
                    }
                    OutputBuffer[position].Attributes = (ushort)CurrentAttribute;
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 1;
                    WindowsConsole.SmallRect.Update(ref damageRegion, (short)ccol, (short)crow);
                }
            }

            if (runeWidth < 0 || runeWidth > 0)
            {
                ccol++;
            }

            if (runeWidth > 1)
            {
                if (validClip && ccol < Clip.Right)
                {
                    position = GetOutputBufferPosition();
                    OutputBuffer[position].Attributes = (ushort)CurrentAttribute;
                    OutputBuffer[position].Char.UnicodeChar = (char)0x00;
                    contents[crow, ccol, 0] = (int)(uint)0x00;
                    contents[crow, ccol, 1] = CurrentAttribute;
                    contents[crow, ccol, 2] = 0;
                }
                ccol++;
            }

            if (sync)
            {
                UpdateScreen();
            }
        }

        public override void AddStr(ustring str)
        {
            foreach (var rune in str)
                AddRune(rune);
        }

        public override void SetAttribute(Attribute c)
        {
            base.SetAttribute(c);
        }

        public override Attribute MakeColor(Color foreground, Color background)
        {
            return MakeColor((ConsoleColor)foreground, (ConsoleColor)background);
        }

        Attribute MakeColor(ConsoleColor f, ConsoleColor b)
        {
            // Encode the colors into the int value.
            return new Attribute(
                value: ((int)f | (int)b << 4),
                foreground: (Color)f,
                background: (Color)b
            );
        }

        public override Attribute MakeAttribute(Color fore, Color back)
        {
            return MakeColor((ConsoleColor)fore, (ConsoleColor)back);
        }

        public override void Refresh()
        {
            UpdateScreen();

            WinConsole.SetInitialCursorVisibility();

            UpdateCursor();
#if false
			var bufferCoords = new WindowsConsole.Coord (){
				X = (short)Clip.Width,
				Y = (short)Clip.Height
			};

			var window = new WindowsConsole.SmallRect (){
				Top = 0,
				Left = 0,
				Right = (short)Clip.Right,
				Bottom = (short)Clip.Bottom
			};

			UpdateCursor();
			WinConsole.WriteToConsole (OutputBuffer, bufferCoords, window);
#endif
        }

        public override void UpdateScreen()
        {
            if (damageRegion.Left == -1)
                return;

            var windowSize = WinConsole.GetConsoleBufferWindow(out _);
            if (!windowSize.IsEmpty && (windowSize.Width != Cols || windowSize.Height != Rows))
                return;

            var bufferCoords = new WindowsConsole.Coord()
            {
                X = (short)Clip.Width,
                Y = (short)Clip.Height
            };

            WinConsole.WriteToConsole(new Size(Cols, Rows), OutputBuffer, bufferCoords, damageRegion);

            // System.Diagnostics.Debugger.Log (0, "debug", $"Region={damageRegion.Right - damageRegion.Left},{damageRegion.Bottom - damageRegion.Top}\n");
            WindowsConsole.SmallRect.MakeEmpty(ref damageRegion);
        }

        CursorVisibility savedCursorVisibility;

        public override void UpdateCursor()
        {
            if (ccol < 0 || crow < 0 || ccol > Cols || crow > Rows)
            {
                GetCursorVisibility(out CursorVisibility cursorVisibility);
                savedCursorVisibility = cursorVisibility;
                SetCursorVisibility(CursorVisibility.Invisible);
                return;
            }

            SetCursorVisibility(savedCursorVisibility);
            var position = new WindowsConsole.Coord()
            {
                X = (short)ccol,
                Y = (short)crow
            };
            WinConsole.SetCursorPosition(position);
        }

        public override void End()
        {
            WinConsole.Cleanup();
            WinConsole = null;

            // Disable alternative screen buffer.
            if (isWindowsTerminal)
            {
                Console.Out.Write("\x1b[?1049l");
            }
        }

        /// <inheritdoc/>
        public override bool GetCursorVisibility(out CursorVisibility visibility)
        {
            return WinConsole.GetCursorVisibility(out visibility);
        }

        /// <inheritdoc/>
        public override bool SetCursorVisibility(CursorVisibility visibility)
        {
            savedCursorVisibility = visibility;
            return WinConsole.SetCursorVisibility(visibility);
        }

        /// <inheritdoc/>
        public override bool EnsureCursorVisibility()
        {
            return WinConsole.EnsureCursorVisibility();
        }

        public override void SendKeys(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
        {
            WindowsConsole.InputRecord input = new WindowsConsole.InputRecord
            {
                EventType = WindowsConsole.EventType.Key
            };

            WindowsConsole.KeyEventRecord keyEvent = new WindowsConsole.KeyEventRecord
            {
                bKeyDown = true
            };
            WindowsConsole.ControlKeyState controlKey = new WindowsConsole.ControlKeyState();
            if (shift)
            {
                controlKey |= WindowsConsole.ControlKeyState.ShiftPressed;
                keyEvent.UnicodeChar = '\0';
                keyEvent.wVirtualKeyCode = 16;
            }
            if (alt)
            {
                controlKey |= WindowsConsole.ControlKeyState.LeftAltPressed;
                controlKey |= WindowsConsole.ControlKeyState.RightAltPressed;
                keyEvent.UnicodeChar = '\0';
                keyEvent.wVirtualKeyCode = 18;
            }
            if (control)
            {
                controlKey |= WindowsConsole.ControlKeyState.LeftControlPressed;
                controlKey |= WindowsConsole.ControlKeyState.RightControlPressed;
                keyEvent.UnicodeChar = '\0';
                keyEvent.wVirtualKeyCode = 17;
            }
            keyEvent.dwControlKeyState = controlKey;

            input.KeyEvent = keyEvent;

            if (shift || alt || control)
            {
                ProcessInput(input);
            }

            keyEvent.UnicodeChar = keyChar;
            if ((uint)key < 255)
            {
                keyEvent.wVirtualKeyCode = (ushort)key;
            }
            else
            {
                keyEvent.wVirtualKeyCode = '\0';
            }

            input.KeyEvent = keyEvent;

            try
            {
                ProcessInput(input);
            }
            catch (OverflowException) { }
            finally
            {
                keyEvent.bKeyDown = false;
                input.KeyEvent = keyEvent;
                ProcessInput(input);
            }
        }

        public override bool GetColors(int value, out Color foreground, out Color background)
        {
            bool hasColor = false;
            foreground = default;
            background = default;
            IEnumerable<int> values = Enum.GetValues(typeof(ConsoleColor))
                .OfType<ConsoleColor>()
                .Select(s => (int)s);
            if (values.Contains((value >> 4) & 0xffff))
            {
                hasColor = true;
                background = (Color)(ConsoleColor)((value >> 4) & 0xffff);
            }
            if (values.Contains(value - ((int)background << 4)))
            {
                hasColor = true;
                foreground = (Color)(ConsoleColor)(value - ((int)background << 4));
            }
            return hasColor;
        }

        #region Unused
        public override void SetColors(ConsoleColor foreground, ConsoleColor background)
        {
        }

        public override void SetColors(short foregroundColorId, short backgroundColorId)
        {
        }

        public override void Suspend()
        {
        }

        public override void StartReportingMouseMoves()
        {
        }

        public override void StopReportingMouseMoves()
        {
        }

        public override void UncookMouse()
        {
        }

        public override void CookMouse()
        {
        }
        #endregion
    }

    /// <summary>
    /// Mainloop intended to be used with the <see cref="WindowsDriver"/>, and can
    /// only be used on Windows.
    /// </summary>
    /// <remarks>
    /// This implementation is used for WindowsDriver.
    /// </remarks>
    internal class WindowsMainLoop : IMainLoopDriver
    {
        ManualResetEventSlim eventReady = new ManualResetEventSlim(false);
        ManualResetEventSlim waitForProbe = new ManualResetEventSlim(false);
        ManualResetEventSlim winChange = new ManualResetEventSlim(false);
        MainLoop mainLoop;
        ConsoleDriver consoleDriver;
        WindowsConsole winConsole;
        bool winChanged;
        Size windowSize;
        CancellationTokenSource tokenSource = new CancellationTokenSource();

        // The records that we keep fetching
        Queue<WindowsConsole.InputRecord[]> resultQueue = new Queue<WindowsConsole.InputRecord[]>();

        /// <summary>
        /// Invoked when a Key is pressed or released.
        /// </summary>
        public Action<WindowsConsole.InputRecord> ProcessInput;

        /// <summary>
        /// Invoked when the window is changed.
        /// </summary>
        public Action<Size> WinChanged;

        public WindowsMainLoop(ConsoleDriver consoleDriver = null)
        {
            this.consoleDriver = consoleDriver ?? throw new ArgumentNullException("Console driver instance must be provided.");
            winConsole = ((WindowsDriver)consoleDriver).WinConsole;
        }

        void IMainLoopDriver.Setup(MainLoop mainLoop)
        {
            this.mainLoop = mainLoop;
            Task.Run(WindowsInputHandler);
            Task.Run(CheckWinChange);
        }

        void WindowsInputHandler()
        {
            while (true)
            {
                waitForProbe.Wait();
                waitForProbe.Reset();

                if (resultQueue?.Count == 0)
                {
                    resultQueue.Enqueue(winConsole.ReadConsoleInput());
                }

                eventReady.Set();
            }
        }

        void CheckWinChange()
        {
            while (true)
            {
                winChange.Wait();
                winChange.Reset();
                WaitWinChange();
                winChanged = true;
                eventReady.Set();
            }
        }

        void WaitWinChange()
        {
            while (true)
            {
                // Wait for a while then check if screen has changed sizes
                Task.Delay(500).Wait();
                windowSize = winConsole.GetConsoleBufferWindow(out _);
                if (windowSize != Size.Empty && windowSize.Width != consoleDriver.Cols
                    || windowSize.Height != consoleDriver.Rows)
                {
                    return;
                }
            }
        }

        void IMainLoopDriver.Wakeup()
        {
            //tokenSource.Cancel ();
            eventReady.Set();
        }

        bool IMainLoopDriver.EventsPending(bool wait)
        {
            waitForProbe.Set();
            winChange.Set();

            if (CheckTimers(wait, out var waitTimeout))
            {
                return true;
            }

            try
            {
                if (!tokenSource.IsCancellationRequested)
                {
                    eventReady.Wait(waitTimeout, tokenSource.Token);
                }
            }
            catch (OperationCanceledException)
            {
                return true;
            }
            finally
            {
                eventReady.Reset();
            }

            if (!tokenSource.IsCancellationRequested)
            {
                return resultQueue.Count > 0 || CheckTimers(wait, out _) || winChanged;
            }

            tokenSource.Dispose();
            tokenSource = new CancellationTokenSource();
            return true;
        }

        bool CheckTimers(bool wait, out int waitTimeout)
        {
            long now = DateTime.UtcNow.Ticks;

            if (mainLoop.timeouts.Count > 0)
            {
                waitTimeout = (int)((mainLoop.timeouts.Keys[0] - now) / TimeSpan.TicksPerMillisecond);
                if (waitTimeout < 0)
                    return true;
            }
            else
            {
                waitTimeout = -1;
            }

            if (!wait)
                waitTimeout = 0;

            int ic;
            lock (mainLoop.idleHandlers)
            {
                ic = mainLoop.idleHandlers.Count;
            }

            return ic > 0;
        }

        void IMainLoopDriver.MainIteration()
        {
            while (resultQueue.Count > 0)
            {
                var inputRecords = resultQueue.Dequeue();
                if (inputRecords != null && inputRecords.Length > 0)
                {
                    var inputEvent = inputRecords[0];
                    ProcessInput?.Invoke(inputEvent);
                }
            }
            if (winChanged)
            {
                winChanged = false;
                WinChanged?.Invoke(windowSize);
            }
        }
    }

    class WindowsClipboard : ClipboardBase
    {
        public WindowsClipboard()
        {
            IsSupported = CheckClipboardIsAvailable();
        }

        private static bool CheckClipboardIsAvailable()
        {
            // Attempt to open the clipboard
            if (OpenClipboard(IntPtr.Zero))
            {
                // Clipboard is available
                // Close the clipboard after use
                CloseClipboard();

                return true;
            }
            // Clipboard is not available
            return false;
        }

        public override bool IsSupported { get; }

        protected override string GetClipboardDataImpl()
        {
            //if (!IsClipboardFormatAvailable (cfUnicodeText))
            //	return null;

            try
            {
                if (!OpenClipboard(IntPtr.Zero))
                    return null;

                IntPtr handle = GetClipboardData(cfUnicodeText);
                if (handle == IntPtr.Zero)
                    return null;

                IntPtr pointer = IntPtr.Zero;

                try
                {
                    pointer = GlobalLock(handle);
                    if (pointer == IntPtr.Zero)
                        return null;

                    int size = GlobalSize(handle);
                    byte[] buff = new byte[size];

                    Marshal.Copy(pointer, buff, 0, size);

                    return System.Text.Encoding.Unicode.GetString(buff)
                        .TrimEnd('\0');
                }
                finally
                {
                    if (pointer != IntPtr.Zero)
                        GlobalUnlock(handle);
                }
            }
            finally
            {
                CloseClipboard();
            }
        }

        protected override void SetClipboardDataImpl(string text)
        {
            OpenClipboard();

            EmptyClipboard();
            IntPtr hGlobal = default;
            try
            {
                var bytes = (text.Length + 1) * 2;
                hGlobal = Marshal.AllocHGlobal(bytes);

                if (hGlobal == default)
                {
                    ThrowWin32();
                }

                var target = GlobalLock(hGlobal);

                if (target == default)
                {
                    ThrowWin32();
                }

                try
                {
                    Marshal.Copy(text.ToCharArray(), 0, target, text.Length);
                }
                finally
                {
                    GlobalUnlock(target);
                }

                if (SetClipboardData(cfUnicodeText, hGlobal) == default)
                {
                    ThrowWin32();
                }

                hGlobal = default;
            }
            finally
            {
                if (hGlobal != default)
                {
                    Marshal.FreeHGlobal(hGlobal);
                }

                CloseClipboard();
            }
        }

        void OpenClipboard()
        {
            var num = 10;
            while (true)
            {
                if (OpenClipboard(default))
                {
                    break;
                }

                if (--num == 0)
                {
                    ThrowWin32();
                }

                Thread.Sleep(100);
            }
        }

        const uint cfUnicodeText = 13;

        void ThrowWin32()
        {
            throw new Win32Exception(Marshal.GetLastWin32Error());
        }

        [DllImport("User32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool IsClipboardFormatAvailable(uint format);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern int GlobalSize(IntPtr handle);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GlobalLock(IntPtr hMem);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GlobalUnlock(IntPtr hMem);

        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool OpenClipboard(IntPtr hWndNewOwner);

        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool CloseClipboard();

        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr SetClipboardData(uint uFormat, IntPtr data);

        [DllImport("user32.dll")]
        static extern bool EmptyClipboard();

        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr GetClipboardData(uint uFormat);
    }
    //=======================================================================
    /// <summary>
    /// Provides navigation and a user interface (UI) to collect related data across multiple steps. Each step (<see cref="WizardStep"/>) can host 
    /// arbitrary <see cref="View"/>s, much like a <see cref="Dialog"/>. Each step also has a pane for help text. Along the
    /// bottom of the Wizard view are customizable buttons enabling the user to navigate forward and backward through the Wizard. 
    /// </summary>
    /// <remarks>
    /// The Wizard can be displayed either as a modal (pop-up) <see cref="Window"/> (like <see cref="Dialog"/>) or as an embedded <see cref="View"/>. 
    /// 
    /// By default, <see cref="Wizard.Modal"/> is <c>true</c>. In this case launch the Wizard with <c>Application.Run(wizard)</c>. 
    /// 
    /// See <see cref="Wizard.Modal"/> for more details.
    /// </remarks>
    /// <example>
    /// <code>
    /// using Terminal.Gui;
    /// using NStack;
    /// 
    /// Application.Init();
    /// 
    /// var wizard = new Wizard ($"Setup Wizard");
    /// 
    /// // Add 1st step
    /// var firstStep = new Wizard.WizardStep ("End User License Agreement");
    /// wizard.AddStep(firstStep);
    /// firstStep.NextButtonText = "Accept!";
    /// firstStep.HelpText = "This is the End User License Agreement.";
    /// 
    /// // Add 2nd step
    /// var secondStep = new Wizard.WizardStep ("Second Step");
    /// wizard.AddStep(secondStep);
    /// secondStep.HelpText = "This is the help text for the Second Step.";
    /// var lbl = new Label ("Name:") { AutoSize = true };
    /// secondStep.Add(lbl);
    /// 
    /// var name = new TextField () { X = Pos.Right (lbl) + 1, Width = Dim.Fill () - 1 };
    /// secondStep.Add(name);
    /// 
    /// wizard.Finished += (args) =>
    /// {
    ///     MessageBox.Query("Wizard", $"Finished. The Name entered is '{name.Text}'", "Ok");
    ///     Application.RequestStop();
    /// };
    /// 
    /// Application.Top.Add (wizard);
    /// Application.Run ();
    /// Application.Shutdown ();
    /// </code>
    /// </example>
    public class Wizard : Dialog
    {
        /// <summary>
        /// Represents a basic step that is displayed in a <see cref="Wizard"/>. The <see cref="WizardStep"/> view is divided horizontally in two. On the left is the
        /// content view where <see cref="View"/>s can be added,  On the right is the help for the step.
        /// Set <see cref="WizardStep.HelpText"/> to set the help text. If the help text is empty the help pane will not
        /// be shown. 
        /// 
        /// If there are no Views added to the WizardStep the <see cref="HelpText"/> (if not empty) will fill the wizard step. 
        /// </summary>
        /// <remarks>
        /// If <see cref="Button"/>s are added, do not set <see cref="Button.IsDefault"/> to true as this will conflict
        /// with the Next button of the Wizard.
        /// 
        /// Subscribe to the <see cref="View.VisibleChanged"/> event to be notified when the step is active; see also: <see cref="Wizard.StepChanged"/>.
        /// 
        /// To enable or disable a step from being shown to the user, set <see cref="View.Enabled"/>.
        /// 
        /// </remarks>
        public class WizardStep : FrameView
        {
            /// <summary>
            /// The title of the <see cref="WizardStep"/>. 
            /// </summary>
            /// <remarks>The Title is only displayed when the <see cref="Wizard"/> is used as a modal pop-up (see <see cref="Wizard.Modal"/>.</remarks>
            public new ustring Title
            {
                get => title;
                set
                {
                    if (!OnTitleChanging(title, value))
                    {
                        var old = title;
                        title = value;
                        OnTitleChanged(old, title);
                    }
                    base.Title = value;
                    SetNeedsDisplay();
                }
            }

            private ustring title = ustring.Empty;

            /// <summary>
            /// An <see cref="EventArgs"/> which allows passing a cancelable new <see cref="Title"/> value event.
            /// </summary>
            public class TitleEventArgs : EventArgs
            {
                /// <summary>
                /// The new Window Title.
                /// </summary>
                public ustring NewTitle { get; set; }

                /// <summary>
                /// The old Window Title.
                /// </summary>
                public ustring OldTitle { get; set; }

                /// <summary>
                /// Flag which allows cancelling the Title change.
                /// </summary>
                public bool Cancel { get; set; }

                /// <summary>
                /// Initializes a new instance of <see cref="TitleEventArgs"/>
                /// </summary>
                /// <param name="oldTitle">The <see cref="Title"/> that is/has been replaced.</param>
                /// <param name="newTitle">The new <see cref="Title"/> to be replaced.</param>
                public TitleEventArgs(ustring oldTitle, ustring newTitle)
                {
                    OldTitle = oldTitle;
                    NewTitle = newTitle;
                }
            }

            /// <summary>
            /// Called before the <see cref="Title"/> changes. Invokes the <see cref="TitleChanging"/> event, which can be cancelled.
            /// </summary>
            /// <param name="oldTitle">The <see cref="Title"/> that is/has been replaced.</param>
            /// <param name="newTitle">The new <see cref="Title"/> to be replaced.</param>
            /// <returns><c>true</c> if an event handler cancelled the Title change.</returns>
            public virtual bool OnTitleChanging(ustring oldTitle, ustring newTitle)
            {
                var args = new TitleEventArgs(oldTitle, newTitle);
                TitleChanging?.Invoke(args);
                return args.Cancel;
            }

            /// <summary>
            /// Event fired when the <see cref="Title"/> is changing. Set <see cref="TitleEventArgs.Cancel"/> to 
            /// <c>true</c> to cancel the Title change.
            /// </summary>
            public event Action<TitleEventArgs> TitleChanging;

            /// <summary>
            /// Called when the <see cref="Title"/> has been changed. Invokes the <see cref="TitleChanged"/> event.
            /// </summary>
            /// <param name="oldTitle">The <see cref="Title"/> that is/has been replaced.</param>
            /// <param name="newTitle">The new <see cref="Title"/> to be replaced.</param>
            public virtual void OnTitleChanged(ustring oldTitle, ustring newTitle)
            {
                var args = new TitleEventArgs(oldTitle, newTitle);
                TitleChanged?.Invoke(args);
            }

            /// <summary>
            /// Event fired after the <see cref="Title"/> has been changed. 
            /// </summary>
            public event Action<TitleEventArgs> TitleChanged;

            /// <summary>
            /// WizardContentView is an internal implementation detail of Window. It is used to host Views added with <see cref="Add(View)"/>. 
            /// Its ONLY reason for being is to provide a simple way for Window to expose to those SubViews that the Window's Bounds 
            /// are actually deflated due to the border. 
            /// </summary>
            class WizardContentView : View { }

            private WizardContentView contentView = new WizardContentView();

            /// <summary>
            /// Sets or gets help text for the <see cref="WizardStep"/>.If <see cref="WizardStep.HelpText"/> is empty
            /// the help pane will not be visible and the content will fill the entire WizardStep.
            /// </summary>
            /// <remarks>The help text is displayed using a read-only <see cref="TextView"/>.</remarks>
            public ustring HelpText
            {
                get => helpTextView.Text;
                set
                {
                    helpTextView.Text = value;
                    ShowHide();
                    SetNeedsDisplay();
                }
            }
            private TextView helpTextView = new TextView();

            /// <summary>
            /// Sets or gets the text for the back button. The back button will only be visible on 
            /// steps after the first step.
            /// </summary>
            /// <remarks>The default text is "Back"</remarks>
            public ustring BackButtonText { get; set; } = ustring.Empty;

            /// <summary>
            /// Sets or gets the text for the next/finish button.
            /// </summary>
            /// <remarks>The default text is "Next..." if the Pane is not the last pane. Otherwise it is "Finish"</remarks>
            public ustring NextButtonText { get; set; } = ustring.Empty;

            /// <summary>
            /// Initializes a new instance of the <see cref="Wizard"/> class using <see cref="LayoutStyle.Computed"/> positioning.
            /// </summary>
            /// <param name="title">Title for the Step. Will be appended to the containing Wizard's title as 
            /// "Wizard Title - Wizard Step Title" when this step is active.</param>
            /// <remarks>
            /// </remarks>
            public WizardStep(ustring title)
            {
                this.Title = title; // this.Title holds just the "Wizard Title"; base.Title holds "Wizard Title - Step Title"
                this.Border.BorderStyle = BorderStyle.Rounded;

                base.Add(contentView);

                helpTextView.ReadOnly = true;
                helpTextView.WordWrap = true;
                base.Add(helpTextView);

                ShowHide();

                var scrollBar = new ScrollBarView(helpTextView, true);

                scrollBar.ChangedPosition += () =>
                {
                    helpTextView.TopRow = scrollBar.Position;
                    if (helpTextView.TopRow != scrollBar.Position)
                    {
                        scrollBar.Position = helpTextView.TopRow;
                    }
                    helpTextView.SetNeedsDisplay();
                };

                scrollBar.OtherScrollBarView.ChangedPosition += () =>
                {
                    helpTextView.LeftColumn = scrollBar.OtherScrollBarView.Position;
                    if (helpTextView.LeftColumn != scrollBar.OtherScrollBarView.Position)
                    {
                        scrollBar.OtherScrollBarView.Position = helpTextView.LeftColumn;
                    }
                    helpTextView.SetNeedsDisplay();
                };

                scrollBar.VisibleChanged += () =>
                {
                    if (scrollBar.Visible && helpTextView.RightOffset == 0)
                    {
                        helpTextView.RightOffset = 1;
                    }
                    else if (!scrollBar.Visible && helpTextView.RightOffset == 1)
                    {
                        helpTextView.RightOffset = 0;
                    }
                };

                scrollBar.OtherScrollBarView.VisibleChanged += () =>
                {
                    if (scrollBar.OtherScrollBarView.Visible && helpTextView.BottomOffset == 0)
                    {
                        helpTextView.BottomOffset = 1;
                    }
                    else if (!scrollBar.OtherScrollBarView.Visible && helpTextView.BottomOffset == 1)
                    {
                        helpTextView.BottomOffset = 0;
                    }
                };

                helpTextView.DrawContent += (e) =>
                {
                    scrollBar.Size = helpTextView.Lines;
                    scrollBar.Position = helpTextView.TopRow;
                    if (scrollBar.OtherScrollBarView != null)
                    {
                        scrollBar.OtherScrollBarView.Size = helpTextView.Maxlength;
                        scrollBar.OtherScrollBarView.Position = helpTextView.LeftColumn;
                    }
                    scrollBar.LayoutSubviews();
                    scrollBar.Refresh();
                };
                base.Add(scrollBar);
            }

            /// <summary>
            /// Does the work to show and hide the contentView and helpView as appropriate
            /// </summary>
            internal void ShowHide()
            {
                contentView.Height = Dim.Fill();
                helpTextView.Height = Dim.Fill();
                helpTextView.Width = Dim.Fill();

                if (contentView.InternalSubviews?.Count > 0)
                {
                    if (helpTextView.Text.Length > 0)
                    {
                        contentView.Width = Dim.Percent(70);
                        helpTextView.X = Pos.Right(contentView);
                        helpTextView.Width = Dim.Fill();

                    }
                    else
                    {
                        contentView.Width = Dim.Percent(100);
                    }
                }
                else
                {
                    if (helpTextView.Text.Length > 0)
                    {
                        helpTextView.X = 0;
                    }
                    else
                    {
                        // Error - no pane shown
                    }

                }
                contentView.Visible = contentView.InternalSubviews?.Count > 0;
                helpTextView.Visible = helpTextView.Text.Length > 0;
            }

            /// <summary>
            /// Add the specified <see cref="View"/> to the <see cref="WizardStep"/>. 
            /// </summary>
            /// <param name="view"><see cref="View"/> to add to this container</param>
            public override void Add(View view)
            {
                contentView.Add(view);
                if (view.CanFocus)
                    CanFocus = true;
                ShowHide();
            }

            /// <summary>
            ///   Removes a <see cref="View"/> from <see cref="WizardStep"/>.
            /// </summary>
            /// <remarks>
            /// </remarks>
            public override void Remove(View view)
            {
                if (view == null)
                    return;

                SetNeedsDisplay();
                var touched = view.Frame;
                if (view == contentView || view.GetType().Name == "ContentView")
                {
                    base.Remove(view);
                }
                else
                {
                    contentView.Remove(view);
                }

                if (contentView.InternalSubviews.Count < 1)
                    this.CanFocus = false;
                ShowHide();
            }

            /// <summary>
            ///   Removes all <see cref="View"/>s from the <see cref="WizardStep"/>.
            /// </summary>
            /// <remarks>
            /// </remarks>
            public override void RemoveAll()
            {
                contentView.RemoveAll();
                ShowHide();
            }

        } // end of WizardStep class

        /// <summary>
        /// Initializes a new instance of the <see cref="Wizard"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        /// <remarks>
        /// The Wizard will be vertically and horizontally centered in the container.
        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> change size and position.
        /// </remarks>
        public Wizard() : this(ustring.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Wizard"/> class using <see cref="LayoutStyle.Computed"/> positioning.
        /// </summary>
        /// <param name="title">Sets the <see cref="Title"/> for the Wizard.</param>
        /// <remarks>
        /// The Wizard will be vertically and horizontally centered in the container.
        /// After initialization use <c>X</c>, <c>Y</c>, <c>Width</c>, and <c>Height</c> change size and position.
        /// </remarks>
        public Wizard(ustring title) : base(title)
        {
            wizardTitle = title;
            // Using Justify causes the Back and Next buttons to be hard justified against
            // the left and right edge
            ButtonAlignment = ButtonAlignments.Justify;
            this.Border.BorderStyle = BorderStyle.Double;
            this.Border.Padding = new Thickness(0);

            //// Add a horiz separator
            //var separator = new LineView (Graphs.Orientation.Horizontal) {
            //	Y = Pos.AnchorEnd (2)
            //};
            //Add (separator);

            // BUGBUG: Space is to work around https://github.com/gui-cs/Terminal.Gui/issues/1812
            backBtn = new Button(Strings.wzBack) { AutoSize = true };
            AddButton(backBtn);

            nextfinishBtn = new Button(Strings.wzFinish) { AutoSize = true };
            nextfinishBtn.IsDefault = true;
            AddButton(nextfinishBtn);

            backBtn.Clicked += BackBtn_Clicked;
            nextfinishBtn.Clicked += NextfinishBtn_Clicked;

            Loaded += Wizard_Loaded;
            Closing += Wizard_Closing;

            if (Modal)
            {
                ClearKeybinding(Command.QuitToplevel);
                AddKeyBinding(Key.Esc, Command.QuitToplevel);
            }

            Initialized += (s, e) => Wizard_Loaded();
        }

        private void Wizard_Loaded()
        {
            CurrentStep = GetFirstStep(); // gets the first step if CurrentStep == null
        }

        private bool finishedPressed = false;

        private void Wizard_Closing(ToplevelClosingEventArgs obj)
        {
            if (!finishedPressed)
            {
                var args = new WizardButtonEventArgs();
                Cancelled?.Invoke(args);
            }
        }

        private void NextfinishBtn_Clicked()
        {
            if (CurrentStep == GetLastStep())
            {
                var args = new WizardButtonEventArgs();
                Finished?.Invoke(args);
                if (!args.Cancel)
                {
                    finishedPressed = true;
                    if (IsCurrentTop)
                    {
                        Application.RequestStop(this);
                    }
                    else
                    {
                        // Wizard was created as a non-modal (just added to another View). 
                        // Do nothing
                    }
                }
            }
            else
            {
                var args = new WizardButtonEventArgs();
                MovingNext?.Invoke(args);
                if (!args.Cancel)
                {
                    GoNext();
                }
            }
        }

        /// <summary>
        /// <see cref="Wizard"/> is derived from <see cref="Dialog"/> and Dialog causes <c>Esc</c> to call
        /// <see cref="Application.RequestStop(Toplevel)"/>, closing the Dialog. Wizard overrides <see cref="Responder.ProcessKey(KeyEvent)"/>
        /// to instead fire the <see cref="Cancelled"/> event when Wizard is being used as a non-modal (see <see cref="Wizard.Modal"/>.
        /// See <see cref="Responder.ProcessKey(KeyEvent)"/> for more.
        /// </summary>
        /// <param name="kb"></param>
        /// <returns></returns>
        public override bool ProcessKey(KeyEvent kb)
        {
            if (!Modal)
            {
                switch (kb.Key)
                {
                    case Key.Esc:
                        var args = new WizardButtonEventArgs();
                        Cancelled?.Invoke(args);
                        return false;
                }
            }
            return base.ProcessKey(kb);
        }

        /// <summary>
        /// Causes the wizad to move to the next enabled step (or last step if <see cref="CurrentStep"/> is not set). 
        /// If there is no previous step, does nothing.
        /// </summary>
        public void GoNext()
        {
            var nextStep = GetNextStep();
            if (nextStep != null)
            {
                GoToStep(nextStep);
            }
        }

        /// <summary>
        /// Returns the next enabled <see cref="WizardStep"/> after the current step. Takes into account steps which
        /// are disabled. If <see cref="CurrentStep"/> is <c>null</c> returns the first enabled step.
        /// </summary>
        /// <returns>The next step after the current step, if there is one; otherwise returns <c>null</c>, which 
        /// indicates either there are no enabled steps or the current step is the last enabled step.</returns>
        public WizardStep GetNextStep()
        {
            LinkedListNode<WizardStep> step = null;
            if (CurrentStep == null)
            {
                // Get first step, assume it is next
                step = steps.First;
            }
            else
            {
                // Get the step after current
                step = steps.Find(CurrentStep);
                if (step != null)
                {
                    step = step.Next;
                }
            }

            // step now points to the potential next step
            while (step != null)
            {
                if (step.Value.Enabled)
                {
                    return step.Value;
                }
                step = step.Next;
            }
            return null;
        }

        private void BackBtn_Clicked()
        {
            var args = new WizardButtonEventArgs();
            MovingBack?.Invoke(args);
            if (!args.Cancel)
            {
                GoBack();
            }
        }

        /// <summary>
        /// Causes the wizad to move to the previous enabled step (or first step if <see cref="CurrentStep"/> is not set). 
        /// If there is no previous step, does nothing.
        /// </summary>
        public void GoBack()
        {
            var previous = GetPreviousStep();
            if (previous != null)
            {
                GoToStep(previous);
            }
        }

        /// <summary>
        /// Returns the first enabled <see cref="WizardStep"/> before the current step. Takes into account steps which
        /// are disabled. If <see cref="CurrentStep"/> is <c>null</c> returns the last enabled step.
        /// </summary>
        /// <returns>The first step ahead of the current step, if there is one; otherwise returns <c>null</c>, which 
        /// indicates either there are no enabled steps or the current step is the first enabled step.</returns>
        public WizardStep GetPreviousStep()
        {
            LinkedListNode<WizardStep> step = null;
            if (CurrentStep == null)
            {
                // Get last step, assume it is previous
                step = steps.Last;
            }
            else
            {
                // Get the step before current
                step = steps.Find(CurrentStep);
                if (step != null)
                {
                    step = step.Previous;
                }
            }

            // step now points to the potential previous step
            while (step != null)
            {
                if (step.Value.Enabled)
                {
                    return step.Value;
                }
                step = step.Previous;
            }
            return null;
        }

        /// <summary>
        /// Returns the first enabled step in the Wizard
        /// </summary>
        /// <returns>The last enabled step</returns>
        public WizardStep GetFirstStep()
        {
            return steps.FirstOrDefault(s => s.Enabled);
        }

        /// <summary>
        /// Returns the last enabled step in the Wizard
        /// </summary>
        /// <returns>The last enabled step</returns>
        public WizardStep GetLastStep()
        {
            return steps.LastOrDefault(s => s.Enabled);
        }

        private LinkedList<WizardStep> steps = new LinkedList<WizardStep>();
        private WizardStep currentStep = null;

        /// <summary>
        /// If the <see cref="CurrentStep"/> is not the first step in the wizard, this button causes
        /// the <see cref="MovingBack"/> event to be fired and the wizard moves to the previous step. 
        /// </summary>
        /// <remarks>
        /// Use the <see cref="MovingBack"></see> event to be notified when the user attempts to go back.
        /// </remarks>
        public Button BackButton { get => backBtn; }
        private Button backBtn;

        /// <summary>
        /// If the <see cref="CurrentStep"/> is the last step in the wizard, this button causes
        /// the <see cref="Finished"/> event to be fired and the wizard to close. If the step is not the last step,
        /// the <see cref="MovingNext"/> event will be fired and the wizard will move next step. 
        /// </summary>
        /// <remarks>
        /// Use the <see cref="MovingNext"></see> and <see cref="Finished"></see> events to be notified 
        /// when the user attempts go to the next step or finish the wizard.
        /// </remarks>
        public Button NextFinishButton { get => nextfinishBtn; }
        private Button nextfinishBtn;

        /// <summary>
        /// Adds a step to the wizard. The Next and Back buttons navigate through the added steps in the
        /// order they were added.
        /// </summary>
        /// <param name="newStep"></param>
        /// <remarks>The "Next..." button of the last step added will read "Finish" (unless changed from default).</remarks>
        public void AddStep(WizardStep newStep)
        {
            SizeStep(newStep);

            newStep.EnabledChanged += UpdateButtonsAndTitle;
            newStep.TitleChanged += (args) => UpdateButtonsAndTitle();
            steps.AddLast(newStep);
            this.Add(newStep);
            UpdateButtonsAndTitle();
        }

        /// <summary>
        /// The title of the Wizard, shown at the top of the Wizard with " - currentStep.Title" appended.
        /// </summary>
        /// <remarks>
        /// The Title is only displayed when the <see cref="Wizard"/> <see cref="Wizard.Modal"/> is set to <c>false</c>.
        /// </remarks>
        public new ustring Title
        {
            get
            {
                // The base (Dialog) Title holds the full title ("Wizard Title - Step Title")
                return base.Title;
            }
            set
            {
                wizardTitle = value;
                base.Title = $"{wizardTitle}{(steps.Count > 0 && currentStep != null ? " - " + currentStep.Title : string.Empty)}";
            }
        }
        private ustring wizardTitle = ustring.Empty;

        /// <summary>	
        /// <see cref="EventArgs"/> for <see cref="WizardStep"/> transition events.
        /// </summary>
        public class WizardButtonEventArgs : EventArgs
        {
            /// <summary>
            /// Set to true to cancel the transition to the next step.
            /// </summary>
            public bool Cancel { get; set; }

            /// <summary>
            /// Initializes a new instance of <see cref="WizardButtonEventArgs"/>
            /// </summary>
            public WizardButtonEventArgs()
            {
                Cancel = false;
            }
        }

        /// <summary>
        /// Raised when the Back button in the <see cref="Wizard"/> is clicked. The Back button is always
        /// the first button in the array of Buttons passed to the <see cref="Wizard"/> constructor, if any.
        /// </summary>
        public event Action<WizardButtonEventArgs> MovingBack;

        /// <summary>
        /// Raised when the Next/Finish button in the <see cref="Wizard"/> is clicked (or the user presses Enter). 
        /// The Next/Finish button is always the last button in the array of Buttons passed to the <see cref="Wizard"/> constructor, 
        /// if any. This event is only raised if the <see cref="CurrentStep"/> is the last Step in the Wizard flow 
        /// (otherwise the <see cref="Finished"/> event is raised).
        /// </summary>
        public event Action<WizardButtonEventArgs> MovingNext;

        /// <summary>
        /// Raised when the Next/Finish button in the <see cref="Wizard"/> is clicked. The Next/Finish button is always
        /// the last button in the array of Buttons passed to the <see cref="Wizard"/> constructor, if any. This event is only
        /// raised if the <see cref="CurrentStep"/> is the last Step in the Wizard flow 
        /// (otherwise the <see cref="Finished"/> event is raised).
        /// </summary>
        public event Action<WizardButtonEventArgs> Finished;

        /// <summary>
        /// Raised when the user has cancelled the <see cref="Wizard"/> by pressin the Esc key. 
        /// To prevent a modal (<see cref="Wizard.Modal"/> is <c>true</c>) Wizard from
        /// closing, cancel the event by setting <see cref="WizardButtonEventArgs.Cancel"/> to 
        /// <c>true</c> before returning from the event handler.
        /// </summary>
        public event Action<WizardButtonEventArgs> Cancelled;

        /// <summary>
        /// <see cref="EventArgs"/> for <see cref="WizardStep"/> events.
        /// </summary>
        public class StepChangeEventArgs : EventArgs
        {
            /// <summary>
            /// The current (or previous) <see cref="WizardStep"/>.
            /// </summary>
            public WizardStep OldStep { get; }

            /// <summary>
            /// The <see cref="WizardStep"/> the <see cref="Wizard"/> is changing to or has changed to.
            /// </summary>
            public WizardStep NewStep { get; }

            /// <summary>
            /// Event handlers can set to true before returning to cancel the step transition.
            /// </summary>
            public bool Cancel { get; set; }

            /// <summary>
            /// Initializes a new instance of <see cref="StepChangeEventArgs"/>
            /// </summary>
            /// <param name="oldStep">The current <see cref="WizardStep"/>.</param>
            /// <param name="newStep">The new <see cref="WizardStep"/>.</param>
            public StepChangeEventArgs(WizardStep oldStep, WizardStep newStep)
            {
                OldStep = oldStep;
                NewStep = newStep;
                Cancel = false;
            }
        }

        /// <summary>
        /// This event is raised when the current <see cref="CurrentStep"/>) is about to change. Use <see cref="StepChangeEventArgs.Cancel"/> 
        /// to abort the transition.
        /// </summary>
        public event Action<StepChangeEventArgs> StepChanging;

        /// <summary>
        /// This event is raised after the <see cref="Wizard"/> has changed the <see cref="CurrentStep"/>. 
        /// </summary>
        public event Action<StepChangeEventArgs> StepChanged;

        /// <summary>
        /// Gets or sets the currently active <see cref="WizardStep"/>.
        /// </summary>
        public WizardStep CurrentStep
        {
            get => currentStep;
            set
            {
                GoToStep(value);
            }
        }

        /// <summary>
        /// Called when the <see cref="Wizard"/> is about to transition to another <see cref="WizardStep"/>. Fires the <see cref="StepChanging"/> event. 
        /// </summary>
        /// <param name="oldStep">The step the Wizard is about to change from</param>
        /// <param name="newStep">The step the Wizard is about to change to</param>
        /// <returns>True if the change is to be cancelled.</returns>
        public virtual bool OnStepChanging(WizardStep oldStep, WizardStep newStep)
        {
            var args = new StepChangeEventArgs(oldStep, newStep);
            StepChanging?.Invoke(args);
            return args.Cancel;
        }

        /// <summary>
        /// Called when the <see cref="Wizard"/> has completed transition to a new <see cref="WizardStep"/>. Fires the <see cref="StepChanged"/> event. 
        /// </summary>
        /// <param name="oldStep">The step the Wizard changed from</param>
        /// <param name="newStep">The step the Wizard has changed to</param>
        /// <returns>True if the change is to be cancelled.</returns>
        public virtual bool OnStepChanged(WizardStep oldStep, WizardStep newStep)
        {
            var args = new StepChangeEventArgs(oldStep, newStep);
            StepChanged?.Invoke(args);
            return args.Cancel;
        }

        /// <summary>
        /// Changes to the specified <see cref="WizardStep"/>.
        /// </summary>
        /// <param name="newStep">The step to go to.</param>
        /// <returns>True if the transition to the step succeeded. False if the step was not found or the operation was cancelled.</returns>
        public bool GoToStep(WizardStep newStep)
        {
            if (OnStepChanging(currentStep, newStep) || (newStep != null && !newStep.Enabled))
            {
                return false;
            }

            // Hide all but the new step
            foreach (WizardStep step in steps)
            {
                step.Visible = (step == newStep);
                step.ShowHide();
            }

            var oldStep = currentStep;
            currentStep = newStep;

            if (currentStep is null)
            {
                return false;
            }

            UpdateButtonsAndTitle();

            // Set focus to the nav buttons
            if (backBtn.HasFocus)
            {
                backBtn.SetFocus();
            }
            else
            {
                nextfinishBtn.SetFocus();
            }

            if (OnStepChanged(oldStep, currentStep))
            {
                // For correctness we do this, but it's meaningless because there's nothing to cancel
                return false;
            }

            return true;
        }

        private void UpdateButtonsAndTitle()
        {
            if (CurrentStep == null) return;

            base.Title = $"{wizardTitle}{(steps.Count > 0 ? " - " + CurrentStep.Title : string.Empty)}";

            // Configure the Back button
            backBtn.Text = CurrentStep.BackButtonText != ustring.Empty ? CurrentStep.BackButtonText : Strings.wzBack; // "_Back";
            backBtn.Visible = (CurrentStep != GetFirstStep());

            // Configure the Next/Finished button
            if (CurrentStep == GetLastStep())
            {
                nextfinishBtn.Text = CurrentStep.NextButtonText != ustring.Empty ? CurrentStep.NextButtonText : Strings.wzFinish; // "Fi_nish";
            }
            else
            {
                nextfinishBtn.Text = CurrentStep.NextButtonText != ustring.Empty ? CurrentStep.NextButtonText : Strings.wzNext; // "_Next...";
            }

            SizeStep(CurrentStep);

            SetNeedsLayout();
            LayoutSubviews();
            Redraw(Bounds);
        }

        private void SizeStep(WizardStep step)
        {
            if (Modal)
            {
                // If we're modal, then we expand the WizardStep so that the top and side 
                // borders and not visible. The bottom border is the separator above the buttons.
                step.X = step.Y = -1;
                step.Height = Dim.Fill(1); // for button frame
                step.Width = Dim.Fill(-1);
            }
            else
            {
                // If we're not a modal, then we show the border around the WizardStep
                step.X = step.Y = 0;
                step.Height = Dim.Fill(1); // for button frame
                step.Width = Dim.Fill(0);
            }
        }

        /// <summary>
        /// Determines whether the <see cref="Wizard"/> is displayed as modal pop-up or not.
        /// 
        /// The default is <c>true</c>. The Wizard will be shown with a frame with <see cref="Title"/> and will behave like
        /// any <see cref="Toplevel"/> window.
        /// 
        /// If set to <c>false</c> the Wizard will have no frame and will behave like any embedded <see cref="View"/>.
        /// 
        /// To use Wizard as an embedded View 
        /// <list type="number">
        /// <item><description>Set <see cref="Modal"/> to <c>false</c>.</description></item>
        /// <item><description>Add the Wizard to a containing view with <see cref="View.Add(View)"/>.</description></item>
        /// </list>
        /// 
        /// If a non-Modal Wizard is added to the application after <see cref="Application.Run(Func{Exception, bool})"/> has been called
        /// the first step must be explicitly set by setting <see cref="CurrentStep"/> to <see cref="GetNextStep()"/>:
        /// <code>
        ///    wizard.CurrentStep = wizard.GetNextStep();
        /// </code>
        /// </summary>
        public new bool Modal
        {
            get => base.Modal;
            set
            {
                base.Modal = value;
                foreach (var step in steps)
                {
                    SizeStep(step);
                }
                if (base.Modal)
                {
                    ColorScheme = Colors.Dialog;
                    Border.BorderStyle = BorderStyle.Rounded;
                    Border.Effect3D = true;
                    Border.DrawMarginFrame = true;
                }
                else
                {
                    if (SuperView != null)
                    {
                        ColorScheme = SuperView.ColorScheme;
                    }
                    else
                    {
                        ColorScheme = Colors.Base;
                    }
                    CanFocus = true;
                    Border.Effect3D = false;
                    Border.BorderStyle = BorderStyle.None;
                    Border.DrawMarginFrame = false;
                }
            }
        }
    }
}//namespace Terminal.Gui
//=======================================================================
namespace Terminal.Gui.Trees
{

    /// <summary>
    /// Delegates of this type are used to fetch string representations of user's model objects
    /// </summary>
    /// <param name="toRender">The object that is being rendered</param>
    /// <returns></returns>
    public delegate string AspectGetterDelegate<T>(T toRender) where T : class;
    //=======================================================================
    class Branch<T> where T : class
    {
        /// <summary>
        /// True if the branch is expanded to reveal child branches.
        /// </summary>
        public bool IsExpanded { get; set; }

        /// <summary>
        /// The users object that is being displayed by this branch of the tree.
        /// </summary>
        public T Model { get; private set; }

        /// <summary>
        /// The depth of the current branch.  Depth of 0 indicates root level branches.
        /// </summary>
        public int Depth { get; private set; } = 0;

        /// <summary>
        /// The children of the current branch.  This is null until the first call to 
        /// <see cref="FetchChildren"/> to avoid enumerating the entire underlying hierarchy.
        /// </summary>
        public Dictionary<T, Branch<T>> ChildBranches { get; set; }

        /// <summary>
        /// The parent <see cref="Branch{T}"/> or null if it is a root.
        /// </summary>
        public Branch<T> Parent { get; private set; }

        private TreeView<T> tree;

        /// <summary>
        /// Declares a new branch of <paramref name="tree"/> in which the users object 
        /// <paramref name="model"/> is presented.
        /// </summary>
        /// <param name="tree">The UI control in which the branch resides.</param>
        /// <param name="parentBranchIfAny">Pass null for root level branches, otherwise
        /// pass the parent.</param>
        /// <param name="model">The user's object that should be displayed.</param>
        public Branch(TreeView<T> tree, Branch<T> parentBranchIfAny, T model)
        {
            this.tree = tree;
            this.Model = model;

            if (parentBranchIfAny != null)
            {
                Depth = parentBranchIfAny.Depth + 1;
                Parent = parentBranchIfAny;
            }
        }


        /// <summary>
        /// Fetch the children of this branch. This method populates <see cref="ChildBranches"/>.
        /// </summary>
        public virtual void FetchChildren()
        {
            if (tree.TreeBuilder == null)
            {
                return;
            }

            IEnumerable<T> children;

            if (Depth >= tree.MaxDepth)
            {
                children = Enumerable.Empty<T>();
            }
            else
            {
                children = tree.TreeBuilder.GetChildren(this.Model) ?? Enumerable.Empty<T>();
            }

            this.ChildBranches = children.ToDictionary(k => k, val => new Branch<T>(tree, this, val));
        }

        /// <summary>
        /// Returns the width of the line including prefix and the results 
        /// of <see cref="TreeView{T}.AspectGetter"/> (the line body).
        /// </summary>
        /// <returns></returns>
        public virtual int GetWidth(ConsoleDriver driver)
        {
            return
                GetLinePrefix(driver).Sum(Rune.ColumnWidth) +
                Rune.ColumnWidth(GetExpandableSymbol(driver)) +
                (tree.AspectGetter(Model) ?? "").Length;
        }

        /// <summary>
        /// Renders the current <see cref="Model"/> on the specified line <paramref name="y"/>.
        /// </summary>
        /// <param name="driver"></param>
        /// <param name="colorScheme"></param>
        /// <param name="y"></param>
        /// <param name="availableWidth"></param>
        public virtual void Draw(ConsoleDriver driver, ColorScheme colorScheme, int y, int availableWidth)
        {
            // true if the current line of the tree is the selected one and control has focus
            bool isSelected = tree.IsSelected(Model);

            Attribute textColor = isSelected ? (tree.HasFocus ? colorScheme.Focus : colorScheme.HotNormal) : colorScheme.Normal;
            Attribute symbolColor = tree.Style.HighlightModelTextOnly ? colorScheme.Normal : textColor;

            // Everything on line before the expansion run and branch text
            Rune[] prefix = GetLinePrefix(driver).ToArray();
            Rune expansion = GetExpandableSymbol(driver);
            string lineBody = tree.AspectGetter(Model) ?? "";

            tree.Move(0, y);

            // if we have scrolled to the right then bits of the prefix will have dispeared off the screen
            int toSkip = tree.ScrollOffsetHorizontal;

            driver.SetAttribute(symbolColor);
            // Draw the line prefix (all parallel lanes or whitespace and an expand/collapse/leaf symbol)
            foreach (Rune r in prefix)
            {

                if (toSkip > 0)
                {
                    toSkip--;
                }
                else
                {
                    driver.AddRune(r);
                    availableWidth -= Rune.ColumnWidth(r);
                }
            }

            // pick color for expanded symbol
            if (tree.Style.ColorExpandSymbol || tree.Style.InvertExpandSymbolColors)
            {
                Attribute color = symbolColor;

                if (tree.Style.ColorExpandSymbol)
                {
                    if (isSelected)
                    {
                        color = tree.Style.HighlightModelTextOnly ? colorScheme.HotNormal : (tree.HasFocus ? tree.ColorScheme.HotFocus : tree.ColorScheme.HotNormal);
                    }
                    else
                    {
                        color = tree.ColorScheme.HotNormal;
                    }
                }
                else
                {
                    color = symbolColor;
                }

                if (tree.Style.InvertExpandSymbolColors)
                {
                    color = new Attribute(color.Background, color.Foreground);
                }

                driver.SetAttribute(color);
            }

            if (toSkip > 0)
            {
                toSkip--;
            }
            else
            {
                driver.AddRune(expansion);
                availableWidth -= Rune.ColumnWidth(expansion);
            }

            // horizontal scrolling has already skipped the prefix but now must also skip some of the line body
            if (toSkip > 0)
            {
                if (toSkip > lineBody.Length)
                {
                    lineBody = "";
                }
                else
                {
                    lineBody = lineBody.Substring(toSkip);
                }
            }

            // If body of line is too long
            if (lineBody.Sum(l => Rune.ColumnWidth(l)) > availableWidth)
            {
                // remaining space is zero and truncate the line
                lineBody = new string(lineBody.TakeWhile(c => (availableWidth -= Rune.ColumnWidth(c)) >= 0).ToArray());
                availableWidth = 0;
            }
            else
            {

                // line is short so remaining width will be whatever comes after the line body
                availableWidth -= lineBody.Length;
            }


            // default behaviour is for model to use the color scheme
            // of the tree view
            var modelColor = textColor;

            // if custom color delegate invoke it
            if (tree.ColorGetter != null)
            {
                var modelScheme = tree.ColorGetter(Model);

                // if custom color scheme is defined for this Model
                if (modelScheme != null)
                {
                    // use it
                    modelColor = isSelected ? modelScheme.Focus : modelScheme.Normal;
                }
            }

            driver.SetAttribute(modelColor);
            driver.AddStr(lineBody);

            if (availableWidth > 0)
            {
                driver.SetAttribute(symbolColor);
                driver.AddStr(new string(' ', availableWidth));
            }
            driver.SetAttribute(colorScheme.Normal);
        }

        /// <summary>
        /// Gets all characters to render prior to the current branches line.  This includes indentation
        /// whitespace and any tree branches (if enabled).
        /// </summary>
        /// <param name="driver"></param>
        /// <returns></returns>
        private IEnumerable<Rune> GetLinePrefix(ConsoleDriver driver)
        {
            // If not showing line branches or this is a root object.
            if (!tree.Style.ShowBranchLines)
            {
                for (int i = 0; i < Depth; i++)
                {
                    yield return new Rune(' ');
                }

                yield break;
            }

            // yield indentations with runes appropriate to the state of the parents
            foreach (var cur in GetParentBranches().Reverse())
            {
                if (cur.IsLast())
                {
                    yield return new Rune(' ');
                }
                else
                {
                    yield return driver.VLine;
                }

                yield return new Rune(' ');
            }

            if (IsLast())
            {
                yield return driver.LLCorner;
            }
            else
            {
                yield return driver.LeftTee;
            }
        }

        /// <summary>
        /// Returns all parents starting with the immediate parent and ending at the root.
        /// </summary>
        /// <returns></returns>
        private IEnumerable<Branch<T>> GetParentBranches()
        {
            var cur = Parent;

            while (cur != null)
            {
                yield return cur;
                cur = cur.Parent;
            }
        }

        /// <summary>
        /// Returns an appropriate symbol for displaying next to the string representation of 
        /// the <see cref="Model"/> object to indicate whether it <see cref="IsExpanded"/> or
        /// not (or it is a leaf).
        /// </summary>
        /// <param name="driver"></param>
        /// <returns></returns>
        public Rune GetExpandableSymbol(ConsoleDriver driver)
        {
            var leafSymbol = tree.Style.ShowBranchLines ? driver.HLine : ' ';

            if (IsExpanded)
            {
                return tree.Style.CollapseableSymbol ?? leafSymbol;
            }

            if (CanExpand())
            {
                return tree.Style.ExpandableSymbol ?? leafSymbol;
            }

            return leafSymbol;
        }

        /// <summary>
        /// Returns true if the current branch can be expanded according to 
        /// the <see cref="TreeBuilder{T}"/> or cached children already fetched.
        /// </summary>
        /// <returns></returns>
        public bool CanExpand()
        {
            // if we do not know the children yet
            if (ChildBranches == null)
            {

                //if there is a rapid method for determining whether there are children
                if (tree.TreeBuilder.SupportsCanExpand)
                {
                    return tree.TreeBuilder.CanExpand(Model);
                }

                //there is no way of knowing whether we can expand without fetching the children
                FetchChildren();
            }

            //we fetched or already know the children, so return whether we have any
            return ChildBranches.Any();
        }

        /// <summary>
        /// Expands the current branch if possible.
        /// </summary>
        public void Expand()
        {
            if (ChildBranches == null)
            {
                FetchChildren();
            }

            if (ChildBranches.Any())
            {
                IsExpanded = true;
            }
        }

        /// <summary>
        /// Marks the branch as collapsed (<see cref="IsExpanded"/> false).
        /// </summary>
        public void Collapse()
        {
            IsExpanded = false;
        }

        /// <summary>
        /// Refreshes cached knowledge in this branch e.g. what children an object has.
        /// </summary>
        /// <param name="startAtTop">True to also refresh all <see cref="Parent"/> 
        /// branches (starting with the root).</param>
        public void Refresh(bool startAtTop)
        {
            // if we must go up and refresh from the top down
            if (startAtTop)
            {
                Parent?.Refresh(true);
            }

            // we don't want to loose the state of our children so lets be selective about how we refresh
            //if we don't know about any children yet just use the normal method
            if (ChildBranches == null)
            {
                FetchChildren();
            }
            else
            {
                // we already knew about some children so preserve the state of the old children

                // first gather the new Children
                var newChildren = tree.TreeBuilder?.GetChildren(this.Model) ?? Enumerable.Empty<T>();

                // Children who no longer appear need to go
                foreach (var toRemove in ChildBranches.Keys.Except(newChildren).ToArray())
                {
                    ChildBranches.Remove(toRemove);

                    //also if the user has this node selected (its disapearing) so lets change selection to us (the parent object) to be helpful
                    if (Equals(tree.SelectedObject, toRemove))
                    {
                        tree.SelectedObject = Model;
                    }
                }

                // New children need to be added
                foreach (var newChild in newChildren)
                {
                    // If we don't know about the child yet we need a new branch
                    if (!ChildBranches.ContainsKey(newChild))
                    {
                        ChildBranches.Add(newChild, new Branch<T>(tree, this, newChild));
                    }
                    else
                    {
                        //we already have this object but update the reference anyway incase Equality match but the references are new
                        ChildBranches[newChild].Model = newChild;
                    }
                }
            }

        }

        /// <summary>
        /// Calls <see cref="Refresh(bool)"/> on the current branch and all expanded children.
        /// </summary>
        internal void Rebuild()
        {
            Refresh(false);

            // if we know about our children
            if (ChildBranches != null)
            {
                if (IsExpanded)
                {
                    //if we are expanded we need to updatethe visible children
                    foreach (var child in ChildBranches)
                    {
                        child.Value.Rebuild();
                    }

                }
                else
                {
                    // we are not expanded so should forget about children because they may not exist anymore
                    ChildBranches = null;
                }
            }

        }

        /// <summary>
        /// Returns true if this branch has parents and it is the last node of it's parents 
        /// branches (or last root of the tree).
        /// </summary>
        /// <returns></returns>
        private bool IsLast()
        {
            if (Parent == null)
            {
                return this == tree.roots.Values.LastOrDefault();
            }

            return Parent.ChildBranches.Values.LastOrDefault() == this;
        }

        /// <summary>
        /// Returns true if the given x offset on the branch line is the +/- symbol.  Returns 
        /// false if not showing expansion symbols or leaf node etc.
        /// </summary>
        /// <param name="driver"></param>
        /// <param name="x"></param>
        /// <returns></returns>
        internal bool IsHitOnExpandableSymbol(ConsoleDriver driver, int x)
        {
            // if leaf node then we cannot expand
            if (!CanExpand())
            {
                return false;
            }

            // if we could theoretically expand
            if (!IsExpanded && tree.Style.ExpandableSymbol != null)
            {
                return x == GetLinePrefix(driver).Count();
            }

            // if we could theoretically collapse
            if (IsExpanded && tree.Style.CollapseableSymbol != null)
            {
                return x == GetLinePrefix(driver).Count();
            }

            return false;
        }

        /// <summary>
        /// Expands the current branch and all children branches.
        /// </summary>
        internal void ExpandAll()
        {
            Expand();

            if (ChildBranches != null)
            {
                foreach (var child in ChildBranches)
                {
                    child.Value.ExpandAll();
                }
            }
        }

        /// <summary>
        /// Collapses the current branch and all children branches (even though those branches are 
        /// no longer visible they retain collapse/expansion state).
        /// </summary>
        internal void CollapseAll()
        {
            Collapse();

            if (ChildBranches != null)
            {
                foreach (var child in ChildBranches)
                {
                    child.Value.CollapseAll();
                }
            }
        }
    }
    //=======================================================================
    /// <summary>
    /// Implementation of <see cref="ITreeBuilder{T}"/> that uses user defined functions
    /// </summary>
    public class DelegateTreeBuilder<T> : TreeBuilder<T>
    {
        private Func<T, IEnumerable<T>> childGetter;
        private Func<T, bool> canExpand;

        /// <summary>
        /// Constructs an implementation of <see cref="ITreeBuilder{T}"/> that calls the user 
        /// defined method <paramref name="childGetter"/> to determine children
        /// </summary>
        /// <param name="childGetter"></param>
        /// <returns></returns>
        public DelegateTreeBuilder(Func<T, IEnumerable<T>> childGetter) : base(false)
        {
            this.childGetter = childGetter;
        }

        /// <summary>
        /// Constructs an implementation of <see cref="ITreeBuilder{T}"/> that calls the user 
        /// defined method <paramref name="childGetter"/> to determine children 
        /// and <paramref name="canExpand"/> to determine expandability
        /// </summary>
        /// <param name="childGetter"></param>
        /// <param name="canExpand"></param>
        /// <returns></returns>
        public DelegateTreeBuilder(Func<T, IEnumerable<T>> childGetter, Func<T, bool> canExpand) : base(true)
        {
            this.childGetter = childGetter;
            this.canExpand = canExpand;
        }

        /// <summary>
        /// Returns whether a node can be expanded based on the delegate passed during construction
        /// </summary>
        /// <param name="toExpand"></param>
        /// <returns></returns>
        public override bool CanExpand(T toExpand)
        {
            return canExpand?.Invoke(toExpand) ?? base.CanExpand(toExpand);
        }

        /// <summary>
        /// Returns children using the delegate method passed during construction
        /// </summary>
        /// <param name="forObject"></param>
        /// <returns></returns>
        public override IEnumerable<T> GetChildren(T forObject)
        {
            return childGetter.Invoke(forObject);
        }
    }
    //=======================================================================
    /// <summary>
    /// Interface for supplying data to a <see cref="TreeView{T}"/> on demand as root level nodes
    /// are expanded by the user
    /// </summary>
    public interface ITreeBuilder<T>
    {
        /// <summary>
        /// Returns true if <see cref="CanExpand"/> is implemented by this class
        /// </summary>
        /// <value></value>
        bool SupportsCanExpand { get; }

        /// <summary>
        /// Returns true/false for whether a model has children.  This method should be implemented
        /// when <see cref="GetChildren"/> is an expensive operation otherwise 
        /// <see cref="SupportsCanExpand"/> should return false (in which case this method will not
        /// be called)
        /// </summary>
        /// <remarks>Only implement this method if you have a very fast way of determining whether 
        /// an object can have children e.g. checking a Type (directories can always be expanded)
        /// </remarks>
        /// <param name="toExpand"></param>
        /// <returns></returns>
        bool CanExpand(T toExpand);

        /// <summary>
        /// Returns all children of a given <paramref name="forObject"/> which should be added to the 
        /// tree as new branches underneath it
        /// </summary>
        /// <param name="forObject"></param>
        /// <returns></returns>
        IEnumerable<T> GetChildren(T forObject);
    }
    //=======================================================================
    /// <summary>
    /// Event args for the <see cref="TreeView{T}.ObjectActivated"/> event
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class ObjectActivatedEventArgs<T> where T : class
    {

        /// <summary>
        /// The tree in which the activation occurred
        /// </summary>
        /// <value></value>
        public TreeView<T> Tree { get; }

        /// <summary>
        /// The object that was selected at the time of activation
        /// </summary>
        /// <value></value>
        public T ActivatedObject { get; }


        /// <summary>
        /// Creates a new instance documenting activation of the <paramref name="activated"/> object
        /// </summary>
        /// <param name="tree">Tree in which the activation is happening</param>
        /// <param name="activated">What object is being activated</param>
        public ObjectActivatedEventArgs(TreeView<T> tree, T activated)
        {
            Tree = tree;
            ActivatedObject = activated;
        }
    }
    //=======================================================================
    /// <summary>
    /// Event arguments describing a change in selected object in a tree view
    /// </summary>
    public class SelectionChangedEventArgs<T> : EventArgs where T : class
    {
        /// <summary>
        /// The view in which the change occurred
        /// </summary>
        public TreeView<T> Tree { get; }

        /// <summary>
        /// The previously selected value (can be null)
        /// </summary>
        public T OldValue { get; }

        /// <summary>
        /// The newly selected value in the <see cref="Tree"/> (can be null)
        /// </summary>
        public T NewValue { get; }

        /// <summary>
        /// Creates a new instance of event args describing a change of selection 
        /// in <paramref name="tree"/>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="oldValue"></param>
        /// <param name="newValue"></param>
        public SelectionChangedEventArgs(TreeView<T> tree, T oldValue, T newValue)
        {
            Tree = tree;
            OldValue = oldValue;
            NewValue = newValue;
        }
    }
    //=======================================================================
    /// <summary>
    /// Abstract implementation of <see cref="ITreeBuilder{T}"/>.
    /// </summary>
    public abstract class TreeBuilder<T> : ITreeBuilder<T>
    {

        /// <inheritdoc/>
        public bool SupportsCanExpand { get; protected set; } = false;

        /// <summary>
        /// Override this method to return a rapid answer as to whether <see cref="GetChildren(T)"/> 
        /// returns results.  If you are implementing this method ensure you passed true in base 
        /// constructor or set <see cref="SupportsCanExpand"/>
        /// </summary>
        /// <param name="toExpand"></param>
        /// <returns></returns>
        public virtual bool CanExpand(T toExpand)
        {

            return GetChildren(toExpand).Any();
        }

        /// <inheritdoc/>
        public abstract IEnumerable<T> GetChildren(T forObject);

        /// <summary>
        /// Constructs base and initializes <see cref="SupportsCanExpand"/>
        /// </summary>
        /// <param name="supportsCanExpand">Pass true if you intend to 
        /// implement <see cref="CanExpand(T)"/> otherwise false</param>
        public TreeBuilder(bool supportsCanExpand)
        {
            SupportsCanExpand = supportsCanExpand;
        }
    }
    //=======================================================================
    /// <summary>
    /// Interface to implement when you want the regular (non generic) <see cref="TreeView"/>
    /// to automatically determine children for your class (without having to specify 
    /// an <see cref="ITreeBuilder{T}"/>)
    /// </summary>
    public interface ITreeNode
    {
        /// <summary>
        /// Text to display when rendering the node
        /// </summary>
        string Text { get; set; }

        /// <summary>
        /// The children of your class which should be rendered underneath it when expanded
        /// </summary>
        /// <value></value>
        IList<ITreeNode> Children { get; }

        /// <summary>
        /// Optionally allows you to store some custom data/class here.
        /// </summary>
        object Tag { get; set; }
    }

    /// <summary>
    /// Simple class for representing nodes, use with regular (non generic) <see cref="TreeView"/>.
    /// </summary>
    public class TreeNode : ITreeNode
    {
        //*master//
        public ScriptEngine.Machine.IValue TagProp { get; set; }
        //master*//

        /// <summary>
        /// Children of the current node
        /// </summary>
        /// <returns></returns>
        public virtual IList<ITreeNode> Children { get; set; } = new List<ITreeNode>();

        /// <summary>
        /// Text to display in tree node for current entry
        /// </summary>
        /// <value></value>
        public virtual string Text { get; set; }

        /// <summary>
        /// Optionally allows you to store some custom data/class here.
        /// </summary>
        public object Tag { get; set; }

        /// <summary>
        /// returns <see cref="Text"/>
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return Text ?? "Unamed Node";
        }

        /// <summary>
        /// Initialises a new instance with no <see cref="Text"/>
        /// </summary>
        public TreeNode()
        {

        }
        /// <summary>
        /// Initialises a new instance and sets starting <see cref="Text"/>
        /// </summary>
        public TreeNode(string text)
        {
            Text = text;
        }
    }
    //=======================================================================
    /// <summary>
    /// <see cref="ITreeBuilder{T}"/> implementation for <see cref="ITreeNode"/> objects
    /// </summary>
    public class TreeNodeBuilder : TreeBuilder<ITreeNode>
    {

        /// <summary>
        /// Initialises a new instance of builder for any model objects of 
        /// Type <see cref="ITreeNode"/>
        /// </summary>
        public TreeNodeBuilder() : base(false)
        {

        }

        /// <summary>
        /// Returns <see cref="ITreeNode.Children"/> from <paramref name="model"/>
        /// </summary>
        /// <param name="model"></param>
        /// <returns></returns>
        public override IEnumerable<ITreeNode> GetChildren(ITreeNode model)
        {
            return model.Children;
        }
    }
    //=======================================================================
    /// <summary>
    /// Defines rendering options that affect how the tree is displayed.
    /// </summary>
    public class TreeStyle
    {

        /// <summary>
        /// <see langword="true"/> to render vertical lines under expanded nodes to show which node belongs to which 
        /// parent. <see langword="false"/> to use only whitespace.
        /// </summary>
        /// <value></value>
        public bool ShowBranchLines { get; set; } = true;

        /// <summary>
        /// Symbol to use for branch nodes that can be expanded to indicate this to the user. 
        /// Defaults to '+'. Set to null to hide.
        /// </summary>
        public Rune? ExpandableSymbol { get; set; } = '+';

        /// <summary>
        /// Symbol to use for branch nodes that can be collapsed (are currently expanded).
        /// Defaults to '-'. Set to null to hide.
        /// </summary>
        public Rune? CollapseableSymbol { get; set; } = '-';

        /// <summary>
        /// Set to <see langword="true"/> to highlight expand/collapse symbols in hot key color.
        /// </summary>
        public bool ColorExpandSymbol { get; set; }

        /// <summary>
        /// Invert console colours used to render the expand symbol.
        /// </summary>
        public bool InvertExpandSymbolColors { get; set; }

        /// <summary>
        /// <see langword="true"/> to leave the last row of the control free for overwritting (e.g. by a scrollbar)
        /// When <see langword="true"/> scrolling will be triggered on the second last row of the control rather than.
        /// the last.
        /// </summary>
        /// <value></value>
        public bool LeaveLastRow { get; set; }

        /// <summary>
        /// Set to <see langword="true"/> to cause the selected item to be rendered with only the <see cref="Branch{T}.Model"/> text
        /// to be highlighted. If <see langword="false"/> (the default), the entire row will be highlighted.
        /// </summary>
        public bool HighlightModelTextOnly { get; set; } = false;
    }
}//namespace Terminal.Gui.Trees
//=======================================================================
//
// TODO:
// * FindNCurses needs to remove the old probing code
// * Removal of that proxy code
// * Need to implement reading pointers with the new API
// * Can remove the manual Dlopen features
// * initscr() diagnostics based on DLL can be fixed
//
// binding.cs.in: Core binding for curses.
//
// This file attempts to call into ncurses without relying on Mono's
// dllmap, so it will work with .NET Core.  This means that it needs
// two sets of bindings, one for "ncurses" which works on OSX, and one
// that works against "libncursesw.so.5" which is what you find on
// assorted Linux systems.
//
// Additionally, I do not want to rely on an external native library
// which is why all this pain to bind two separate ncurses is here.
//
// Authors:
//   Miguel de Icaza (miguel.de.icaza@gmail.com)
//
// Copyright (C) 2007 Novell (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

//#define USE_IOCTL


namespace Unix.Terminal
{
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
    public partial class Curses
    {
#if USE_IOCTL

		[StructLayout (LayoutKind.Sequential)]
		public struct winsize {
			public ushort ws_row;
			public ushort ws_col;
			public ushort ws_xpixel;   /* unused */
			public ushort ws_ypixel;   /* unused */
		};
#endif
        [StructLayout(LayoutKind.Sequential)]
        public struct MouseEvent
        {
            public short ID;
            public int X, Y, Z;
            public Event ButtonState;
        }

        static int lines, cols;
        static Window main_window;
        static IntPtr curses_handle, curscr_ptr, lines_ptr, cols_ptr;

        // If true, uses the DllImport into "ncurses", otherwise "libncursesw.so.5"
        //static bool use_naked_driver;

        static UnmanagedLibrary curses_library;
        static NativeMethods methods;


        [DllImport("libc")]
        public extern static int setlocale(int cate, [MarshalAs(UnmanagedType.LPStr)] string locale);
#if USE_IOCTL

		[DllImport ("libc")]
		public extern static int ioctl (int fd, int cmd, out winsize argp);
#endif
        static void LoadMethods()
        {
            var libs = UnmanagedLibrary.IsMacOSPlatform ? new string[] { "libncurses.dylib" } : new string[] { "libncursesw.so.6", "libncursesw.so.5" };
            var attempts = 1;
            while (true)
            {
                try
                {
                    curses_library = new UnmanagedLibrary(libs, false);
                    methods = new NativeMethods(curses_library);
                    break;
                }
                catch (Exception ex)
                {

                    if (attempts == 1)
                    {
                        attempts++;
                        var (exitCode, result) = ClipboardProcessRunner.Bash("cat /etc/os-release", waitForOutput: true);
                        if (exitCode == 0 && result.Contains("opensuse"))
                        {
                            libs[0] = "libncursesw.so.5";
                        }
                    }
                    else
                    {
                        throw ex.GetBaseException();
                    }
                }
            }
        }

        static void FindNCurses()
        {
            LoadMethods();
            curses_handle = methods.UnmanagedLibrary.NativeLibraryHandle;

            stdscr = read_static_ptr("stdscr");
            curscr_ptr = get_ptr("curscr");
            lines_ptr = get_ptr("LINES");
            cols_ptr = get_ptr("COLS");
        }

        static public Window initscr()
        {
            setlocale(LC_ALL, "");
            FindNCurses();

            // Prevents the terminal from being locked after exiting.
            reset_shell_mode();

            main_window = new Window(methods.initscr());
            try
            {
                console_sharp_get_dims(out lines, out cols);
            }
            catch (DllNotFoundException)
            {
                endwin();
                Console.Error.WriteLine("Unable to find the @MONO_CURSES@ native library\n" +
                             "this is different than the managed mono-curses.dll\n\n" +
                             "Typically you need to install to a LD_LIBRARY_PATH directory\n" +
                             "or DYLD_LIBRARY_PATH directory or run /sbin/ldconfig");
                Environment.Exit(1);
            }
            return main_window;
        }

        public static int Lines
        {
            get
            {
                return lines;
            }
        }

        public static int Cols
        {
            get
            {
                return cols;
            }
        }

        //
        // Returns true if the window changed since the last invocation, as a
        // side effect, the Lines and Cols properties are updated
        //
        public static bool CheckWinChange()
        {
            int l, c;

            console_sharp_get_dims(out l, out c);

            if (l < 1)
            {
                l = 1;
            }
            if (l != lines || c != cols)
            {
                lines = l;
                cols = c;
                return true;
            }
            return false;
        }

        public static int addstr(string format, params object[] args)
        {
            var s = string.Format(format, args);
            return addwstr(s);
        }

        static char[] r = new char[1];

        //
        // Have to wrap the native addch, as it can not
        // display unicode characters, we have to use addstr
        // for that.   but we need addch to render special ACS
        // characters
        //
        public static int addch(int ch)
        {
            if (ch < 127 || ch > 0xffff)
                return methods.addch(ch);
            char c = (char)ch;
            return addwstr(new String(c, 1));
        }

        public static int mvaddch(int y, int x, int ch)
        {
            if (ch < 127 || ch > 0xffff)
                return methods.mvaddch(y, x, ch);
            char c = (char)ch;
            return mvaddwstr(y, x, new String(c, 1));
        }

        static IntPtr stdscr;

        static IntPtr get_ptr(string key)
        {
            var ptr = curses_library.LoadSymbol(key);

            if (ptr == IntPtr.Zero)
                throw new Exception("Could not load the key " + key);
            return ptr;
        }

        internal static IntPtr read_static_ptr(string key)
        {
            var ptr = get_ptr(key);
            return Marshal.ReadIntPtr(ptr);
        }

        internal static IntPtr console_sharp_get_stdscr() => stdscr;

        internal static IntPtr console_sharp_get_curscr()
        {
            return Marshal.ReadIntPtr(curscr_ptr);
        }

        internal static void console_sharp_get_dims(out int lines, out int cols)
        {
#if USE_IOCTL

			if (UnmanagedLibrary.IsMacOSPlatform) {
				int cmd = TIOCGWINSZ_MAC;

				if (ioctl (1, cmd, out winsize ws) == 0) {
					lines = ws.ws_row;
					cols = ws.ws_col;

					if (lines == Lines && cols == Cols) {
						return;
					}

					resizeterm (lines, cols);
				} else {
					lines = Lines;
					cols = Cols;
				}
			} else {
				lines = Marshal.ReadInt32 (lines_ptr);
				cols = Marshal.ReadInt32 (cols_ptr);
			}
#else
            lines = Marshal.ReadInt32(lines_ptr);
            cols = Marshal.ReadInt32(cols_ptr);
#endif
            //int cmd;
            //if (UnmanagedLibrary.IsMacOSPlatform) {
            //	cmd = TIOCGWINSZ_MAC;
            //} else {
            //	cmd = TIOCGWINSZ;
            //}

            //if (ioctl (1, cmd, out winsize ws) == 0) {
            //	lines = ws.ws_row;
            //	cols = ws.ws_col;

            //	if (lines == Lines && cols == Cols) {
            //		return;
            //	}

            //	resizeterm (lines, cols);
            //} else {
            //	lines = Lines;
            //	cols = Cols;
            //}
        }

        public static Event mousemask(Event newmask, out Event oldmask)
        {
            IntPtr e;
            var ret = (Event)(methods.mousemask((IntPtr)newmask, out e));
            oldmask = (Event)e;
            return ret;
        }

        // We encode ESC + char (what Alt-char generates) as 0x2000 + char
        public const int KeyAlt = 0x2000;

        static public int IsAlt(int key)
        {
            if ((key & KeyAlt) != 0)
                return key & ~KeyAlt;
            return 0;
        }

        public static int StartColor() => methods.start_color();
        public static bool HasColors => methods.has_colors();
        public static int InitColorPair(short pair, short foreground, short background) => methods.init_pair(pair, foreground, background);
        public static int UseDefaultColors() => methods.use_default_colors();
        public static int ColorPairs => methods.COLOR_PAIRS();

        //
        // The proxy methods to call into each version
        //
        static public int endwin() => methods.endwin();
        static public bool isendwin() => methods.isendwin();
        static public int cbreak() => methods.cbreak();
        static public int nocbreak() => methods.nocbreak();
        static public int echo() => methods.echo();
        static public int noecho() => methods.noecho();
        static public int halfdelay(int t) => methods.halfdelay(t);
        static public int raw() => methods.raw();
        static public int noraw() => methods.noraw();
        static public void noqiflush() => methods.noqiflush();
        static public void qiflush() => methods.qiflush();
        static public int typeahead(IntPtr fd) => methods.typeahead(fd);
        static public int timeout(int delay) => methods.timeout(delay);
        static public int wtimeout(IntPtr win, int delay) => methods.wtimeout(win, delay);
        static public int notimeout(IntPtr win, bool bf) => methods.notimeout(win, bf);
        static public int keypad(IntPtr win, bool bf) => methods.keypad(win, bf);
        static public int meta(IntPtr win, bool bf) => methods.meta(win, bf);
        static public int intrflush(IntPtr win, bool bf) => methods.intrflush(win, bf);
        static public int clearok(IntPtr win, bool bf) => methods.clearok(win, bf);
        static public int idlok(IntPtr win, bool bf) => methods.idlok(win, bf);
        static public void idcok(IntPtr win, bool bf) => methods.idcok(win, bf);
        static public void immedok(IntPtr win, bool bf) => methods.immedok(win, bf);
        static public int leaveok(IntPtr win, bool bf) => methods.leaveok(win, bf);
        static public int wsetscrreg(IntPtr win, int top, int bot) => methods.wsetscrreg(win, top, bot);
        static public int scrollok(IntPtr win, bool bf) => methods.scrollok(win, bf);
        static public int nl() => methods.nl();
        static public int nonl() => methods.nonl();
        static public int setscrreg(int top, int bot) => methods.setscrreg(top, bot);
        static public int refresh() => methods.refresh();
        static public int doupdate() => methods.doupdate();
        static public int wrefresh(IntPtr win) => methods.wrefresh(win);
        static public int redrawwin(IntPtr win) => methods.redrawwin(win);
        //static public int wredrawwin (IntPtr win, int beg_line, int num_lines) => methods.wredrawwin (win, beg_line, num_lines);
        static public int wnoutrefresh(IntPtr win) => methods.wnoutrefresh(win);
        static public int move(int line, int col) => methods.move(line, col);
        static public int curs_set(int visibility) => methods.curs_set(visibility);
        //static public int addch (int ch) => methods.addch (ch);
        static public int addwstr(string s) => methods.addwstr(s);
        static public int mvaddwstr(int y, int x, string s) => methods.mvaddwstr(y, x, s);
        static public int wmove(IntPtr win, int line, int col) => methods.wmove(win, line, col);
        static public int waddch(IntPtr win, int ch) => methods.waddch(win, ch);
        static public int attron(int attrs) => methods.attron(attrs);
        static public int attroff(int attrs) => methods.attroff(attrs);
        static public int attrset(int attrs) => methods.attrset(attrs);
        static public int getch() => methods.getch();
        static public int get_wch(out int sequence) => methods.get_wch(out sequence);
        static public int ungetch(int ch) => methods.ungetch(ch);
        static public int mvgetch(int y, int x) => methods.mvgetch(y, x);
        static public bool has_colors() => methods.has_colors();
        static public int start_color() => methods.start_color();
        static public int init_pair(short pair, short f, short b) => methods.init_pair(pair, f, b);
        static public int use_default_colors() => methods.use_default_colors();
        static public int COLOR_PAIRS() => methods.COLOR_PAIRS();
        static public uint getmouse(out MouseEvent ev) => methods.getmouse(out ev);
        static public uint ungetmouse(ref MouseEvent ev) => methods.ungetmouse(ref ev);
        static public int mouseinterval(int interval) => methods.mouseinterval(interval);
        static public bool is_term_resized(int lines, int columns) => methods.is_term_resized(lines, columns);
        static public int resize_term(int lines, int columns) => methods.resize_term(lines, columns);
        static public int resizeterm(int lines, int columns) => methods.resizeterm(lines, columns);
        static public void use_env(bool f) => methods.use_env(f);
        static public int flushinp() => methods.flushinp();
        static public int def_prog_mode() => methods.def_prog_mode();
        static public int def_shell_mode() => methods.def_shell_mode();
        static public int reset_prog_mode() => methods.reset_prog_mode();
        static public int reset_shell_mode() => methods.reset_shell_mode();
        static public int savetty() => methods.savetty();
        static public int resetty() => methods.resetty();
        static public int set_escdelay(int size) => methods.set_escdelay(size);
        static public int nodelay(IntPtr win, bool bf) => methods.nodelay(win, bf);
    }

#pragma warning disable RCS1102 // Make class static.
    internal class Delegates
    {
#pragma warning restore RCS1102 // Make class static.
#pragma warning disable CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
        public delegate IntPtr initscr();
        public delegate int endwin();
        public delegate bool isendwin();
        public delegate int cbreak();
        public delegate int nocbreak();
        public delegate int echo();
        public delegate int noecho();
        public delegate int halfdelay(int t);
        public delegate int raw();
        public delegate int noraw();
        public delegate void noqiflush();
        public delegate void qiflush();
        public delegate int typeahead(IntPtr fd);
        public delegate int timeout(int delay);
        public delegate int wtimeout(IntPtr win, int delay);
        public delegate int notimeout(IntPtr win, bool bf);
        public delegate int keypad(IntPtr win, bool bf);
        public delegate int meta(IntPtr win, bool bf);
        public delegate int intrflush(IntPtr win, bool bf);
        public delegate int clearok(IntPtr win, bool bf);
        public delegate int idlok(IntPtr win, bool bf);
        public delegate void idcok(IntPtr win, bool bf);
        public delegate void immedok(IntPtr win, bool bf);
        public delegate int leaveok(IntPtr win, bool bf);
        public delegate int wsetscrreg(IntPtr win, int top, int bot);
        public delegate int scrollok(IntPtr win, bool bf);
        public delegate int nl();
        public delegate int nonl();
        public delegate int setscrreg(int top, int bot);
        public delegate int refresh();
        public delegate int doupdate();
        public delegate int wrefresh(IntPtr win);
        public delegate int redrawwin(IntPtr win);
        //public delegate int wredrawwin (IntPtr win, int beg_line, int num_lines);
        public delegate int wnoutrefresh(IntPtr win);
        public delegate int move(int line, int col);
        public delegate int curs_set(int visibility);
        public delegate int addch(int ch);
        public delegate int mvaddch(int y, int x, int ch);
        public delegate int addwstr([MarshalAs(UnmanagedType.LPWStr)] string s);
        public delegate int mvaddwstr(int y, int x, [MarshalAs(UnmanagedType.LPWStr)] string s);
        public delegate int wmove(IntPtr win, int line, int col);
        public delegate int waddch(IntPtr win, int ch);
        public delegate int attron(int attrs);
        public delegate int attroff(int attrs);
        public delegate int attrset(int attrs);
        public delegate int getch();
        public delegate int get_wch(out int sequence);
        public delegate int ungetch(int ch);
        public delegate int mvgetch(int y, int x);
        public delegate bool has_colors();
        public delegate int start_color();
        public delegate int init_pair(short pair, short f, short b);
        public delegate int use_default_colors();
        public delegate int COLOR_PAIRS();
        public delegate uint getmouse(out Curses.MouseEvent ev);
        public delegate uint ungetmouse(ref Curses.MouseEvent ev);
        public delegate int mouseinterval(int interval);
        public delegate IntPtr mousemask(IntPtr newmask, out IntPtr oldMask);
        public delegate bool is_term_resized(int lines, int columns);
        public delegate int resize_term(int lines, int columns);
        public delegate int resizeterm(int lines, int columns);
        public delegate void use_env(bool f);
        public delegate int flushinp();
        public delegate int def_prog_mode();
        public delegate int def_shell_mode();
        public delegate int reset_prog_mode();
        public delegate int reset_shell_mode();
        public delegate int savetty();
        public delegate int resetty();
        public delegate int set_escdelay(int size);
        public delegate int nodelay(IntPtr win, bool bf);
    }

    internal class NativeMethods
    {
        public readonly Delegates.initscr initscr;
        public readonly Delegates.endwin endwin;
        public readonly Delegates.isendwin isendwin;
        public readonly Delegates.cbreak cbreak;
        public readonly Delegates.nocbreak nocbreak;
        public readonly Delegates.echo echo;
        public readonly Delegates.noecho noecho;
        public readonly Delegates.halfdelay halfdelay;
        public readonly Delegates.raw raw;
        public readonly Delegates.noraw noraw;
        public readonly Delegates.noqiflush noqiflush;
        public readonly Delegates.qiflush qiflush;
        public readonly Delegates.typeahead typeahead;
        public readonly Delegates.timeout timeout;
        public readonly Delegates.wtimeout wtimeout;
        public readonly Delegates.notimeout notimeout;
        public readonly Delegates.keypad keypad;
        public readonly Delegates.meta meta;
        public readonly Delegates.intrflush intrflush;
        public readonly Delegates.clearok clearok;
        public readonly Delegates.idlok idlok;
        public readonly Delegates.idcok idcok;
        public readonly Delegates.immedok immedok;
        public readonly Delegates.leaveok leaveok;
        public readonly Delegates.wsetscrreg wsetscrreg;
        public readonly Delegates.scrollok scrollok;
        public readonly Delegates.nl nl;
        public readonly Delegates.nonl nonl;
        public readonly Delegates.setscrreg setscrreg;
        public readonly Delegates.refresh refresh;
        public readonly Delegates.doupdate doupdate;
        public readonly Delegates.wrefresh wrefresh;
        public readonly Delegates.redrawwin redrawwin;
        //public readonly Delegates.wredrawwin wredrawwin;
        public readonly Delegates.wnoutrefresh wnoutrefresh;
        public readonly Delegates.move move;
        public readonly Delegates.curs_set curs_set;
        public readonly Delegates.addch addch;
        public readonly Delegates.mvaddch mvaddch;
        public readonly Delegates.addwstr addwstr;
        public readonly Delegates.mvaddwstr mvaddwstr;
        public readonly Delegates.wmove wmove;
        public readonly Delegates.waddch waddch;
        public readonly Delegates.attron attron;
        public readonly Delegates.attroff attroff;
        public readonly Delegates.attrset attrset;
        public readonly Delegates.getch getch;
        public readonly Delegates.get_wch get_wch;
        public readonly Delegates.ungetch ungetch;
        public readonly Delegates.mvgetch mvgetch;
        public readonly Delegates.has_colors has_colors;
        public readonly Delegates.start_color start_color;
        public readonly Delegates.init_pair init_pair;
        public readonly Delegates.use_default_colors use_default_colors;
        public readonly Delegates.COLOR_PAIRS COLOR_PAIRS;
        public readonly Delegates.getmouse getmouse;
        public readonly Delegates.ungetmouse ungetmouse;
        public readonly Delegates.mouseinterval mouseinterval;
        public readonly Delegates.mousemask mousemask;
        public readonly Delegates.is_term_resized is_term_resized;
        public readonly Delegates.resize_term resize_term;
        public readonly Delegates.resizeterm resizeterm;
        public readonly Delegates.use_env use_env;
        public readonly Delegates.flushinp flushinp;
        public readonly Delegates.def_prog_mode def_prog_mode;
        public readonly Delegates.def_shell_mode def_shell_mode;
        public readonly Delegates.reset_prog_mode reset_prog_mode;
        public readonly Delegates.reset_shell_mode reset_shell_mode;
        public readonly Delegates.savetty savetty;
        public readonly Delegates.resetty resetty;
        public readonly Delegates.set_escdelay set_escdelay;
        public readonly Delegates.nodelay nodelay;
        public UnmanagedLibrary UnmanagedLibrary;

        public NativeMethods(UnmanagedLibrary lib)
        {
            this.UnmanagedLibrary = lib;
            initscr = lib.GetNativeMethodDelegate<Delegates.initscr>("initscr");
            endwin = lib.GetNativeMethodDelegate<Delegates.endwin>("endwin");
            isendwin = lib.GetNativeMethodDelegate<Delegates.isendwin>("isendwin");
            cbreak = lib.GetNativeMethodDelegate<Delegates.cbreak>("cbreak");
            nocbreak = lib.GetNativeMethodDelegate<Delegates.nocbreak>("nocbreak");
            echo = lib.GetNativeMethodDelegate<Delegates.echo>("echo");
            noecho = lib.GetNativeMethodDelegate<Delegates.noecho>("noecho");
            halfdelay = lib.GetNativeMethodDelegate<Delegates.halfdelay>("halfdelay");
            raw = lib.GetNativeMethodDelegate<Delegates.raw>("raw");
            noraw = lib.GetNativeMethodDelegate<Delegates.noraw>("noraw");
            noqiflush = lib.GetNativeMethodDelegate<Delegates.noqiflush>("noqiflush");
            qiflush = lib.GetNativeMethodDelegate<Delegates.qiflush>("qiflush");
            typeahead = lib.GetNativeMethodDelegate<Delegates.typeahead>("typeahead");
            timeout = lib.GetNativeMethodDelegate<Delegates.timeout>("timeout");
            wtimeout = lib.GetNativeMethodDelegate<Delegates.wtimeout>("wtimeout");
            notimeout = lib.GetNativeMethodDelegate<Delegates.notimeout>("notimeout");
            keypad = lib.GetNativeMethodDelegate<Delegates.keypad>("keypad");
            meta = lib.GetNativeMethodDelegate<Delegates.meta>("meta");
            intrflush = lib.GetNativeMethodDelegate<Delegates.intrflush>("intrflush");
            clearok = lib.GetNativeMethodDelegate<Delegates.clearok>("clearok");
            idlok = lib.GetNativeMethodDelegate<Delegates.idlok>("idlok");
            idcok = lib.GetNativeMethodDelegate<Delegates.idcok>("idcok");
            immedok = lib.GetNativeMethodDelegate<Delegates.immedok>("immedok");
            leaveok = lib.GetNativeMethodDelegate<Delegates.leaveok>("leaveok");
            wsetscrreg = lib.GetNativeMethodDelegate<Delegates.wsetscrreg>("wsetscrreg");
            scrollok = lib.GetNativeMethodDelegate<Delegates.scrollok>("scrollok");
            nl = lib.GetNativeMethodDelegate<Delegates.nl>("nl");
            nonl = lib.GetNativeMethodDelegate<Delegates.nonl>("nonl");
            setscrreg = lib.GetNativeMethodDelegate<Delegates.setscrreg>("setscrreg");
            refresh = lib.GetNativeMethodDelegate<Delegates.refresh>("refresh");
            doupdate = lib.GetNativeMethodDelegate<Delegates.doupdate>("doupdate");
            wrefresh = lib.GetNativeMethodDelegate<Delegates.wrefresh>("wrefresh");
            redrawwin = lib.GetNativeMethodDelegate<Delegates.redrawwin>("redrawwin");
            //wredrawwin = lib.GetNativeMethodDelegate<Delegates.wredrawwin> ("wredrawwin");
            wnoutrefresh = lib.GetNativeMethodDelegate<Delegates.wnoutrefresh>("wnoutrefresh");
            move = lib.GetNativeMethodDelegate<Delegates.move>("move");
            curs_set = lib.GetNativeMethodDelegate<Delegates.curs_set>("curs_set");
            addch = lib.GetNativeMethodDelegate<Delegates.addch>("addch");
            mvaddch = lib.GetNativeMethodDelegate<Delegates.mvaddch>("mvaddch");
            addwstr = lib.GetNativeMethodDelegate<Delegates.addwstr>("addwstr");
            mvaddwstr = lib.GetNativeMethodDelegate<Delegates.mvaddwstr>("mvaddwstr");
            wmove = lib.GetNativeMethodDelegate<Delegates.wmove>("wmove");
            waddch = lib.GetNativeMethodDelegate<Delegates.waddch>("waddch");
            attron = lib.GetNativeMethodDelegate<Delegates.attron>("attron");
            attroff = lib.GetNativeMethodDelegate<Delegates.attroff>("attroff");
            attrset = lib.GetNativeMethodDelegate<Delegates.attrset>("attrset");
            getch = lib.GetNativeMethodDelegate<Delegates.getch>("getch");
            get_wch = lib.GetNativeMethodDelegate<Delegates.get_wch>("get_wch");
            ungetch = lib.GetNativeMethodDelegate<Delegates.ungetch>("ungetch");
            mvgetch = lib.GetNativeMethodDelegate<Delegates.mvgetch>("mvgetch");
            has_colors = lib.GetNativeMethodDelegate<Delegates.has_colors>("has_colors");
            start_color = lib.GetNativeMethodDelegate<Delegates.start_color>("start_color");
            init_pair = lib.GetNativeMethodDelegate<Delegates.init_pair>("init_pair");
            use_default_colors = lib.GetNativeMethodDelegate<Delegates.use_default_colors>("use_default_colors");
            COLOR_PAIRS = lib.GetNativeMethodDelegate<Delegates.COLOR_PAIRS>("COLOR_PAIRS");
            getmouse = lib.GetNativeMethodDelegate<Delegates.getmouse>("getmouse");
            ungetmouse = lib.GetNativeMethodDelegate<Delegates.ungetmouse>("ungetmouse");
            mouseinterval = lib.GetNativeMethodDelegate<Delegates.mouseinterval>("mouseinterval");
            mousemask = lib.GetNativeMethodDelegate<Delegates.mousemask>("mousemask");
            is_term_resized = lib.GetNativeMethodDelegate<Delegates.is_term_resized>("is_term_resized");
            resize_term = lib.GetNativeMethodDelegate<Delegates.resize_term>("resize_term");
            resizeterm = lib.GetNativeMethodDelegate<Delegates.resizeterm>("resizeterm");
            use_env = lib.GetNativeMethodDelegate<Delegates.use_env>("use_env");
            flushinp = lib.GetNativeMethodDelegate<Delegates.flushinp>("flushinp");
            def_prog_mode = lib.GetNativeMethodDelegate<Delegates.def_prog_mode>("def_prog_mode");
            def_shell_mode = lib.GetNativeMethodDelegate<Delegates.def_shell_mode>("def_shell_mode");
            reset_prog_mode = lib.GetNativeMethodDelegate<Delegates.reset_prog_mode>("reset_prog_mode");
            reset_shell_mode = lib.GetNativeMethodDelegate<Delegates.reset_shell_mode>("reset_shell_mode");
            savetty = lib.GetNativeMethodDelegate<Delegates.savetty>("savetty");
            resetty = lib.GetNativeMethodDelegate<Delegates.resetty>("resetty");
            set_escdelay = lib.GetNativeMethodDelegate<Delegates.set_escdelay>("set_escdelay");
            nodelay = lib.GetNativeMethodDelegate<Delegates.nodelay>("nodelay");
        }
    }
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
#pragma warning restore CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
    //=======================================================================
    /*
     * This file is autogenerated by the attrib.c program, do not edit
     */

    //#define XTERM1006

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
    public partial class Curses
    {
        public const int A_NORMAL = unchecked((int)0x0);
        public const int A_STANDOUT = unchecked((int)0x10000);
        public const int A_UNDERLINE = unchecked((int)0x20000);
        public const int A_REVERSE = unchecked((int)0x40000);
        public const int A_BLINK = unchecked((int)0x80000);
        public const int A_DIM = unchecked((int)0x100000);
        public const int A_BOLD = unchecked((int)0x200000);
        public const int A_PROTECT = unchecked((int)0x1000000);
        public const int A_INVIS = unchecked((int)0x800000);
        public const int ACS_LLCORNER = unchecked((int)0x40006d);
        public const int ACS_LRCORNER = unchecked((int)0x40006a);
        public const int ACS_HLINE = unchecked((int)0x400071);
        public const int ACS_ULCORNER = unchecked((int)0x40006c);
        public const int ACS_URCORNER = unchecked((int)0x40006b);
        public const int ACS_VLINE = unchecked((int)0x400078);
        public const int ACS_LTEE = unchecked((int)0x400074);
        public const int ACS_RTEE = unchecked((int)0x400075);
        public const int ACS_BTEE = unchecked((int)0x400076);
        public const int ACS_TTEE = unchecked((int)0x400077);
        public const int ACS_PLUS = unchecked((int)0x40006e);
        public const int ACS_S1 = unchecked((int)0x40006f);
        public const int ACS_S9 = unchecked((int)0x400073);
        public const int ACS_DIAMOND = unchecked((int)0x400060);
        public const int ACS_CKBOARD = unchecked((int)0x400061);
        public const int ACS_DEGREE = unchecked((int)0x400066);
        public const int ACS_PLMINUS = unchecked((int)0x400067);
        public const int ACS_BULLET = unchecked((int)0x40007e);
        public const int ACS_LARROW = unchecked((int)0x40002c);
        public const int ACS_RARROW = unchecked((int)0x40002b);
        public const int ACS_DARROW = unchecked((int)0x40002e);
        public const int ACS_UARROW = unchecked((int)0x40002d);
        public const int ACS_BOARD = unchecked((int)0x400068);
        public const int ACS_LANTERN = unchecked((int)0x400069);
        public const int ACS_BLOCK = unchecked((int)0x400030);
        public const int COLOR_BLACK = unchecked((int)0x0);
        public const int COLOR_RED = unchecked((int)0x1);
        public const int COLOR_GREEN = unchecked((int)0x2);
        public const int COLOR_YELLOW = unchecked((int)0x3);
        public const int COLOR_BLUE = unchecked((int)0x4);
        public const int COLOR_MAGENTA = unchecked((int)0x5);
        public const int COLOR_CYAN = unchecked((int)0x6);
        public const int COLOR_WHITE = unchecked((int)0x7);
        public const int COLOR_GRAY = unchecked((int)0x8);
        public const int KEY_CODE_YES = unchecked((int)0x100);
        public const int ERR = unchecked((int)0xffffffff);
        public const int TIOCGWINSZ = unchecked((int)0x5413);
        public const int TIOCGWINSZ_MAC = unchecked((int)0x40087468);

        [Flags]
        public enum Event : long
        {
            Button1Pressed = unchecked((int)0x2),
            Button1Released = unchecked((int)0x1),
            Button1Clicked = unchecked((int)0x4),
            Button1DoubleClicked = unchecked((int)0x8),
            Button1TripleClicked = unchecked((int)0x10),
            Button2Pressed = unchecked((int)0x40),
            Button2Released = unchecked((int)0x20),
            Button2Clicked = unchecked((int)0x80),
            Button2DoubleClicked = unchecked((int)0x100),
            Button2TripleClicked = unchecked((int)0x200),
            Button3Pressed = unchecked((int)0x800),
            Button3Released = unchecked((int)0x400),
            Button3Clicked = unchecked((int)0x1000),
            Button3DoubleClicked = unchecked((int)0x2000),
            Button3TripleClicked = unchecked((int)0x4000),
            ButtonWheeledUp = unchecked((int)0x10000),
            ButtonWheeledDown = unchecked((int)0x200000),
            Button4Pressed = unchecked((int)0x80000),
            Button4Released = unchecked((int)0x40000),
            Button4Clicked = unchecked((int)0x100000),
            Button4DoubleClicked = unchecked((int)0x20000),
            Button4TripleClicked = unchecked((int)0x400000),
            ButtonShift = unchecked((int)0x4000000),
            ButtonCtrl = unchecked((int)0x2000000),
            ButtonAlt = unchecked((int)0x8000000),
            ReportMousePosition = unchecked((int)0x10000000),
            AllEvents = unchecked((int)0x7ffffff),
        }
#if XTERM1006
		public const int LeftRightUpNPagePPage= unchecked((int)0x8);
		public const int DownEnd = unchecked((int)0x6);
		public const int Home = unchecked((int)0x7);
#else
        public const int LeftRightUpNPagePPage = unchecked((int)0x0);
        public const int DownEnd = unchecked((int)0x0);
        public const int Home = unchecked((int)0x0);
#endif
        public const int KeyBackspace = unchecked((int)0x107);
        public const int KeyUp = unchecked((int)0x103);
        public const int KeyDown = unchecked((int)0x102);
        public const int KeyLeft = unchecked((int)0x104);
        public const int KeyRight = unchecked((int)0x105);
        public const int KeyNPage = unchecked((int)0x152);
        public const int KeyPPage = unchecked((int)0x153);
        public const int KeyHome = unchecked((int)0x106);
        public const int KeyMouse = unchecked((int)0x199);
        public const int KeyCSI = unchecked((int)0x5b);
        public const int KeySS3 = unchecked((int)0x4f);
        public const int KeyEnd = unchecked((int)0x168);
        public const int KeyDeleteChar = unchecked((int)0x14a);
        public const int KeyInsertChar = unchecked((int)0x14b);
        public const int KeyTab = unchecked((int)0x009);
        public const int KeyBackTab = unchecked((int)0x161);
        public const int KeyF1 = unchecked((int)0x109);
        public const int KeyF2 = unchecked((int)0x10a);
        public const int KeyF3 = unchecked((int)0x10b);
        public const int KeyF4 = unchecked((int)0x10c);
        public const int KeyF5 = unchecked((int)0x10d);
        public const int KeyF6 = unchecked((int)0x10e);
        public const int KeyF7 = unchecked((int)0x10f);
        public const int KeyF8 = unchecked((int)0x110);
        public const int KeyF9 = unchecked((int)0x111);
        public const int KeyF10 = unchecked((int)0x112);
        public const int KeyF11 = unchecked((int)0x113);
        public const int KeyF12 = unchecked((int)0x114);
        public const int KeyResize = unchecked((int)0x19a);
        public const int ShiftKeyUp = unchecked((int)0x151);
        public const int ShiftKeyDown = unchecked((int)0x150);
        public const int ShiftKeyLeft = unchecked((int)0x189);
        public const int ShiftKeyRight = unchecked((int)0x192);
        public const int ShiftKeyNPage = unchecked((int)0x18c);
        public const int ShiftKeyPPage = unchecked((int)0x18e);
        public const int ShiftKeyHome = unchecked((int)0x187);
        public const int ShiftKeyEnd = unchecked((int)0x182);
        public const int AltKeyUp = unchecked((int)0x234 + LeftRightUpNPagePPage);
        public const int AltKeyDown = unchecked((int)0x20b + DownEnd);
        public const int AltKeyLeft = unchecked((int)0x21f + LeftRightUpNPagePPage);
        public const int AltKeyRight = unchecked((int)0x22e + LeftRightUpNPagePPage);
        public const int AltKeyNPage = unchecked((int)0x224 + LeftRightUpNPagePPage);
        public const int AltKeyPPage = unchecked((int)0x229 + LeftRightUpNPagePPage);
        public const int AltKeyHome = unchecked((int)0x215 + Home);
        public const int AltKeyEnd = unchecked((int)0x210 + DownEnd);
        public const int CtrlKeyUp = unchecked((int)0x236 + LeftRightUpNPagePPage);
        public const int CtrlKeyDown = unchecked((int)0x20d + DownEnd);
        public const int CtrlKeyLeft = unchecked((int)0x221 + LeftRightUpNPagePPage);
        public const int CtrlKeyRight = unchecked((int)0x230 + LeftRightUpNPagePPage);
        public const int CtrlKeyNPage = unchecked((int)0x226 + LeftRightUpNPagePPage);
        public const int CtrlKeyPPage = unchecked((int)0x22b + LeftRightUpNPagePPage);
        public const int CtrlKeyHome = unchecked((int)0x217 + Home);
        public const int CtrlKeyEnd = unchecked((int)0x212 + DownEnd);
        public const int ShiftCtrlKeyUp = unchecked((int)0x237 + LeftRightUpNPagePPage);
        public const int ShiftCtrlKeyDown = unchecked((int)0x20e + DownEnd);
        public const int ShiftCtrlKeyLeft = unchecked((int)0x222 + LeftRightUpNPagePPage);
        public const int ShiftCtrlKeyRight = unchecked((int)0x231 + LeftRightUpNPagePPage);
        public const int ShiftCtrlKeyNPage = unchecked((int)0x227 + LeftRightUpNPagePPage);
        public const int ShiftCtrlKeyPPage = unchecked((int)0x22c + LeftRightUpNPagePPage);
        public const int ShiftCtrlKeyHome = unchecked((int)0x218 + Home);
        public const int ShiftCtrlKeyEnd = unchecked((int)0x213 + DownEnd);
        public const int ShiftAltKeyUp = unchecked((int)0x235 + LeftRightUpNPagePPage);
        public const int ShiftAltKeyDown = unchecked((int)0x20c + DownEnd);
        public const int ShiftAltKeyLeft = unchecked((int)0x220 + LeftRightUpNPagePPage);
        public const int ShiftAltKeyRight = unchecked((int)0x22f + LeftRightUpNPagePPage);
        public const int ShiftAltKeyNPage = unchecked((int)0x225 + LeftRightUpNPagePPage);
        public const int ShiftAltKeyPPage = unchecked((int)0x22a + LeftRightUpNPagePPage);
        public const int ShiftAltKeyHome = unchecked((int)0x216 + Home);
        public const int ShiftAltKeyEnd = unchecked((int)0x211 + DownEnd);
        public const int AltCtrlKeyNPage = unchecked((int)0x228 + LeftRightUpNPagePPage);
        public const int AltCtrlKeyPPage = unchecked((int)0x22d + LeftRightUpNPagePPage);
        public const int AltCtrlKeyHome = unchecked((int)0x219 + Home);
        public const int AltCtrlKeyEnd = unchecked((int)0x214 + DownEnd);

        // see #949
        static public int LC_ALL { get; private set; }
        static Curses()
        {
            LC_ALL = System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.OSX) ? 0 : 6;
        }

        static public int ColorPair(int n)
        {
            return 0 + n * 256;
        }
    }
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    //=======================================================================
    //
    // handles.cs: OO wrappers for some curses objects
    //
    // Authors:
    //   Miguel de Icaza (miguel.de.icaza@gmail.com)
    //
    // Copyright (C) 2007 Novell (http://www.novell.com)
    //
    // Permission is hereby granted, free of charge, to any person obtaining
    // a copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to
    // permit persons to whom the Software is furnished to do so, subject to
    // the following conditions:
    // 
    // The above copyright notice and this permission notice shall be
    // included in all copies or substantial portions of the Software.
    // 
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    //

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
    public partial class Curses
    {
        public class Window
        {
            public readonly IntPtr Handle;
            static Window curscr;
            static Window stdscr;

            static Window()
            {
                Curses.initscr();
                stdscr = new Window(Curses.console_sharp_get_stdscr());
                curscr = new Window(Curses.console_sharp_get_curscr());
            }

            internal Window(IntPtr handle)
            {
                Handle = handle;
            }

            static public Window Standard
            {
                get
                {
                    return stdscr;
                }
            }

            static public Window Current
            {
                get
                {
                    return curscr;
                }
            }


            public int wtimeout(int delay)
            {
                return Curses.wtimeout(Handle, delay);
            }

            public int notimeout(bool bf)
            {
                return Curses.notimeout(Handle, bf);
            }

            public int keypad(bool bf)
            {
                return Curses.keypad(Handle, bf);
            }

            public int meta(bool bf)
            {
                return Curses.meta(Handle, bf);
            }

            public int intrflush(bool bf)
            {
                return Curses.intrflush(Handle, bf);
            }

            public int clearok(bool bf)
            {
                return Curses.clearok(Handle, bf);
            }

            public int idlok(bool bf)
            {
                return Curses.idlok(Handle, bf);
            }

            public void idcok(bool bf)
            {
                Curses.idcok(Handle, bf);
            }

            public void immedok(bool bf)
            {
                Curses.immedok(Handle, bf);
            }

            public int leaveok(bool bf)
            {
                return Curses.leaveok(Handle, bf);
            }

            public int setscrreg(int top, int bot)
            {
                return Curses.wsetscrreg(Handle, top, bot);
            }

            public int scrollok(bool bf)
            {
                return Curses.scrollok(Handle, bf);
            }

            public int wrefresh()
            {
                return Curses.wrefresh(Handle);
            }

            public int redrawwin()
            {
                return Curses.redrawwin(Handle);
            }

#if false
			public int wredrawwin (int beg_line, int num_lines)
			{
				return Curses.wredrawwin (Handle, beg_line, num_lines);
			}
#endif
            public int wnoutrefresh()
            {
                return Curses.wnoutrefresh(Handle);
            }

            public int move(int line, int col)
            {
                return Curses.wmove(Handle, line, col);
            }

            public int addch(char ch)
            {
                return Curses.waddch(Handle, ch);
            }

            public int refresh()
            {
                return Curses.wrefresh(Handle);
            }
        }

        // Currently unused, to do later
        internal class Screen
        {
            public readonly IntPtr Handle;

            internal Screen(IntPtr handle)
            {
                Handle = handle;
            }
        }

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }
    //=======================================================================
    // Copyright 2015 gRPC authors.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    //	 http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    //#define GUICS

    /// <summary>
    /// Represents a dynamically loaded unmanaged library in a (partially) platform independent manner.
    /// First, the native library is loaded using dlopen (on Unix systems) or using LoadLibrary (on Windows).
    /// dlsym or GetProcAddress are then used to obtain symbol addresses. <c>Marshal.GetDelegateForFunctionPointer</c>
    /// transforms the addresses into delegates to native methods.
    /// See http://stackoverflow.com/questions/13461989/p-invoke-to-dynamically-loaded-library-on-mono.
    /// </summary>
    internal class UnmanagedLibrary
    {
        const string UnityEngineApplicationClassName = "UnityEngine.Application, UnityEngine";
        const string XamarinAndroidObjectClassName = "Java.Lang.Object, Mono.Android";
        const string XamarinIOSObjectClassName = "Foundation.NSObject, Xamarin.iOS";
        static bool IsWindows, IsLinux, IsMacOS;
        static bool Is64Bit;
#if GUICS
        static bool IsMono;
#else
        static bool IsMono, IsUnity, IsXamarinIOS, IsXamarinAndroid, IsXamarin;
#endif
        static bool IsNetCore;

        public static bool IsMacOSPlatform => IsMacOS;

        [DllImport("libc")]
        static extern int uname(IntPtr buf);

        static string GetUname()
        {
            var buffer = Marshal.AllocHGlobal(8192);
            try
            {
                if (uname(buffer) == 0)
                {
                    return Marshal.PtrToStringAnsi(buffer);
                }
                return string.Empty;
            }
            catch
            {
                return string.Empty;
            }
            finally
            {
                if (buffer != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(buffer);
                }
            }
        }

        static UnmanagedLibrary()
        {
            var platform = Environment.OSVersion.Platform;

            IsMacOS = (platform == PlatformID.Unix && GetUname() == "Darwin");
            IsLinux = (platform == PlatformID.Unix && !IsMacOS);
            IsWindows = (platform == PlatformID.Win32NT || platform == PlatformID.Win32S || platform == PlatformID.Win32Windows);
            Is64Bit = Marshal.SizeOf(typeof(IntPtr)) == 8;
            IsMono = Type.GetType("Mono.Runtime") != null;
            if (!IsMono)
            {
                IsNetCore = Type.GetType("System.MathF") != null;
            }
#if GUICS
            //IsUnity = IsXamarinIOS = IsXamarinAndroid = IsXamarin = false;
#else
            IsUnity = Type.GetType(UnityEngineApplicationClassName) != null;
            IsXamarinIOS = Type.GetType(XamarinIOSObjectClassName) != null;
            IsXamarinAndroid = Type.GetType(XamarinAndroidObjectClassName) != null;
            IsXamarin = IsXamarinIOS || IsXamarinAndroid;
#endif

        }

        // flags for dlopen
        const int RTLD_LAZY = 1;
        const int RTLD_GLOBAL = 8;

        readonly string libraryPath;
        readonly IntPtr handle;

        public IntPtr NativeLibraryHandle => handle;

        //
        // if isFullPath is set to true, the provided array of libraries are full paths
        // and are tested for the file existing, otherwise the file is merely the name
        // of the shared library that we pass to dlopen
        //
        public UnmanagedLibrary(string[] libraryPathAlternatives, bool isFullPath)
        {
            if (isFullPath)
            {
                this.libraryPath = FirstValidLibraryPath(libraryPathAlternatives);
                this.handle = PlatformSpecificLoadLibrary(this.libraryPath);
            }
            else
            {
                foreach (var lib in libraryPathAlternatives)
                {
                    this.handle = PlatformSpecificLoadLibrary(lib);
                    if (this.handle != IntPtr.Zero)
                        break;
                }
            }

            if (this.handle == IntPtr.Zero)
            {
                throw new IOException($"Error loading native library \"{string.Join(", ", libraryPathAlternatives)}\"");
            }
        }

        /// <summary>
        /// Loads symbol in a platform specific way.
        /// </summary>
        /// <param name="symbolName"></param>
        /// <returns></returns>
        public IntPtr LoadSymbol(string symbolName)
        {
            if (IsWindows)
            {
                // See http://stackoverflow.com/questions/10473310 for background on this.
                if (Is64Bit)
                {
                    return Windows.GetProcAddress(this.handle, symbolName);
                }
                else
                {
                    // Yes, we could potentially predict the size... but it's a lot simpler to just try
                    // all the candidates. Most functions have a suffix of @0, @4 or @8 so we won't be trying
                    // many options - and if it takes a little bit longer to fail if we've really got the wrong
                    // library, that's not a big problem. This is only called once per function in the native library.
                    symbolName = "_" + symbolName + "@";
                    for (int stackSize = 0; stackSize < 128; stackSize += 4)
                    {
                        IntPtr candidate = Windows.GetProcAddress(this.handle, symbolName + stackSize);
                        if (candidate != IntPtr.Zero)
                        {
                            return candidate;
                        }
                    }
                    // Fail.
                    return IntPtr.Zero;
                }
            }
            if (IsLinux)
            {
                if (IsMono)
                {
                    return Mono.dlsym(this.handle, symbolName);
                }
                if (IsNetCore)
                {
                    return CoreCLR.dlsym(this.handle, symbolName);
                }
                return Linux.dlsym(this.handle, symbolName);
            }
            if (IsMacOS)
            {
                return MacOSX.dlsym(this.handle, symbolName);
            }
            throw new InvalidOperationException("Unsupported platform.");
        }

        public T GetNativeMethodDelegate<T>(string methodName)
            where T : class
        {
            var ptr = LoadSymbol(methodName);
            if (ptr == IntPtr.Zero)
            {
                throw new MissingMethodException(string.Format("The native method \"{0}\" does not exist", methodName));
            }
            return Marshal.GetDelegateForFunctionPointer<T>(ptr);  // non-generic version is obsolete
        }

        /// <summary>
        /// Loads library in a platform specific way.
        /// </summary>
        static IntPtr PlatformSpecificLoadLibrary(string libraryPath)
        {
            if (IsWindows)
            {
                return Windows.LoadLibrary(libraryPath);
            }
            if (IsLinux)
            {
                if (IsMono)
                {
                    return Mono.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
                }
                if (IsNetCore)
                {
                    try
                    {
                        return CoreCLR.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
                    }
                    catch (Exception)
                    {

                        IsNetCore = false;
                    }
                }
                return Linux.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
            }
            if (IsMacOS)
            {
                return MacOSX.dlopen(libraryPath, RTLD_GLOBAL + RTLD_LAZY);
            }
            throw new InvalidOperationException("Unsupported platform.");
        }

        static string FirstValidLibraryPath(string[] libraryPathAlternatives)
        {
            foreach (var path in libraryPathAlternatives)
            {
                if (File.Exists(path))
                {
                    return path;
                }
            }
            throw new FileNotFoundException(
                String.Format("Error loading native library. Not found in any of the possible locations: {0}",
                string.Join(",", libraryPathAlternatives)));
        }

        static class Windows
        {
            [DllImport("kernel32.dll")]
            internal static extern IntPtr LoadLibrary(string filename);

            [DllImport("kernel32.dll")]
            internal static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        }

        static class Linux
        {
            [DllImport("libdl.so")]
            internal static extern IntPtr dlopen(string filename, int flags);

            [DllImport("libdl.so")]
            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
        }

        static class MacOSX
        {
            [DllImport("libSystem.dylib")]
            internal static extern IntPtr dlopen(string filename, int flags);

            [DllImport("libSystem.dylib")]
            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
        }

        /// <summary>
        /// On Linux systems, using using dlopen and dlsym results in
        /// DllNotFoundException("libdl.so not found") if libc6-dev
        /// is not installed. As a workaround, we load symbols for
        /// dlopen and dlsym from the current process as on Linux
        /// Mono sure is linked against these symbols.
        /// </summary>
        static class Mono
        {
            [DllImport("__Internal")]
            internal static extern IntPtr dlopen(string filename, int flags);

            [DllImport("__Internal")]
            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
        }

        /// <summary>
        /// Similarly as for Mono on Linux, we load symbols for
        /// dlopen and dlsym from the "libcoreclr.so",
        /// to avoid the dependency on libc-dev Linux.
        /// </summary>
        static class CoreCLR
        {
#if NET6_0_OR_GREATER
			// Custom resolver to support true single-file apps
			// (those which run directly from bundle; in-memory).
			//	 -1 on Unix means self-referencing binary (libcoreclr.so)
			//	 0 means fallback to CoreCLR's internal resolution
			// Note: meaning of -1 stay the same even for non-single-file form factors.
			static CoreCLR() =>  NativeLibrary.SetDllImportResolver(typeof(CoreCLR).Assembly,
				(string libraryName, Assembly assembly, DllImportSearchPath? searchPath) =>
					libraryName == "libcoreclr.so" ? (IntPtr)(-1) : IntPtr.Zero);
#endif
            [DllImport("libcoreclr.so")]
            internal static extern IntPtr dlopen(string filename, int flags);

            [DllImport("libcoreclr.so")]
            internal static extern IntPtr dlsym(IntPtr handle, string symbol);
        }
    }
}//namespace Unix.Terminal
//=======================================================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Terminal.Gui.Resources
{
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Strings
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Strings()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceMan, null))
                {
                    //*master//
                    //////global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(("Terminal.Gui.Resources.Strings", typeof(Strings).Assembly);
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ostgui.Properties.Resources", typeof(Strings).Assembly);
                    //master*//
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to _Copy.
        /// </summary>
        internal static string ctxCopy
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("ctxCopy", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("ctxCopy", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Cu_t.
        /// </summary>
        internal static string ctxCut
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("ctxCut", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("ctxCut", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to _Delete All.
        /// </summary>
        internal static string ctxDeleteAll
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("ctxDeleteAll", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("ctxDeleteAll", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to _Paste.
        /// </summary>
        internal static string ctxPaste
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("ctxPaste", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("ctxPaste", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to _Redo.
        /// </summary>
        internal static string ctxRedo
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("ctxRedo", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("ctxRedo", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to _Select All.
        /// </summary>
        internal static string ctxSelectAll
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("ctxSelectAll", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("ctxSelectAll", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to _Undo.
        /// </summary>
        internal static string ctxUndo
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("ctxUndo", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("ctxUndo", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Directory.
        /// </summary>
        internal static string fdDirectory
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("fdDirectory", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("fdDirectory", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to File.
        /// </summary>
        internal static string fdFile
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("fdFile", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("fdFile", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Open.
        /// </summary>
        internal static string fdOpen
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("fdOpen", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("fdOpen", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Save.
        /// </summary>
        internal static string fdSave
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("fdSave", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("fdSave", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Save as.
        /// </summary>
        internal static string fdSaveAs
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("fdSaveAs", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("fdSaveAs", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Select folder.
        /// </summary>
        internal static string fdSelectFolder
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("fdSelectFolder", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("fdSelectFolder", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Select Mixed.
        /// </summary>
        internal static string fdSelectMixed
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("fdSelectMixed", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("fdSelectMixed", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to _Back.
        /// </summary>
        internal static string wzBack
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("wzBack", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("wzBack", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to Fi_nish.
        /// </summary>
        internal static string wzFinish
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("wzFinish", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("wzFinish", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }

        /// <summary>
        ///   Looks up a localized string similar to _Next....
        /// </summary>
        internal static string wzNext
        {
            //*master//
            //////get
            //////{
            //////    return ResourceManager.GetString("wzNext", resourceCulture);
            //////}
            get
            {
                string str = ResourceManager.GetString("wzNext", resourceCulture);
                if (ostgui.OneScriptTerminalGui.instance.LabelLanguage == 0)
                {
                    return ostgui.Utils.labelRusEn[str];
                }
                return str;
            }
            //master*//
        }
    }
}//namespace Terminal.Gui.Resources
